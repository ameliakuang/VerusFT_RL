{"id": "adts_cc0b9f7d", "original_code": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": " use vstd::prelude::*;\n                verus! {\n              fn test_option(o: Option<u64>) -> (res: u64)     ensures         {\n                match o {\n                  Some(v) => v,         OptionNone => 0}\n            }\n              fn test_result<E>(r: Result<u64, E>) -> (res: u64)     ensures         {\n                match r {\n                  Ok(v) => v,         Err(_) => 0}\n            }\n              fn main() ;\n              }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/adts.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1235, "minimize_time_ms": 456360, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 85, "minimized_LOC": 12, "self_contained": true, "dependencies": ["verus_builtin_macros::", "vstd::prelude::"], "complexity_verus_tokens": 3, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.1411764705882353}, "labeling": {"segments": {"exec": " fn test_option(o: Option<u64>) -> (res: u64)     ensures         {\n\n fn test_result<E>(r: Result<u64, E>) -> (res: u64)     ensures         {", "spec": "              fn test_option(o: Option<u64>) -> (res: u64)     ensures         {\n\n              fn test_result<E>(r: Result<u64, E>) -> (res: u64)     ensures         {"}}}, "all_snapshots": ["use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use vstd::prelude::*;\n                verus! {\n              fn test_option(o: Option<u64>) -> (res: u64)     ensures         {\n                match o {\n                  Some(v) => v,         OptionNone => 0}\n            }\n              fn test_result<E>(r: Result<u64, E>) -> (res: u64)     ensures         {\n                match r {\n                  Ok(v) => v,         Err(_) => 0}\n            }\n              fn main() ;\n              }\n", " use vstd::prelude::*;\n                 verus! {               fn a(b: Option<u64>) ->  u64              {                 match b {                   Some(c) => c,         d => 0}             }               fn e<f>(r: Result<u64, f>) ->  u64              {                 match r {                   Ok(c) => c,         g => 0}             }               fn main() ;               }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "assert_by_compute_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/assert_by_compute.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1458, "minimize_time_ms": 187436, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 453, "minimized_LOC": 453, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::prelude::"], "complexity_verus_tokens": 56, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {\n\n fn test() {\n\n fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {", "spec": "spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n\nspec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n\nspec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n\nspec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n\nspec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n\nspec fn ex1() -> List<nat> {\n\nspec fn ex1_rev() -> List<nat> {\n\nspec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n\nspec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n\nspec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n\nspec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n\nspec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n\nspec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n\nspec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n\nspec fn pow_mod_crc(n: nat) -> Seq<bool> {\n\nspec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n\nspec fn zeroes(l: nat) -> Seq<bool> {\n\nspec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n\nspec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n\nspec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n\nspec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n\nspec fn pow_mod_crc(n: nat) -> Seq<bool> {\n\n        decreases x,\n\n        decreases exp,\n\n        decreases l,\n\n        decreases l,\n\n        decreases l,\n\n        decreases s.len(),\n\n        decreases len,\n\n        decreases l,\n\n        ensures\n\n        decreases l,\n\n        decreases p.len(),\n\n        requires\n\n        ensures\n\n        decreases p.len(),\n\n        decreases p.len(),\n\n        decreases s.len(),\n\n        decreases len,\n\n        decreases p.len(),\n\n        decreases s.len(),", "proof": "proof fn compute_list() {\n\nproof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n\nproof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n\nproof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n\nproof fn test_shift() {"}}}, "all_snapshots": ["// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use vstd::prelude::*;\n        verus! {\n       fn main() ;\n       }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "assorted_demo_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nfn main() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n#[derive(Eq, PartialEq, Structural)]\nstruct Train {\n    cars: u64,\n}\n\nfn main2() {\n    let t = Train { cars: 10 };\n    let q = Train { cars: 10 };\n    assert(t == q);\n}\n\nspec fn mul(a: u64, b: u64) -> u64 {\n    verus_builtin::mul(a, b)\n}\n\nspec fn divides(v: u64, d: u64) -> bool {\n    exists|k: u64| mul(d, k) == v\n}\n\n#[verifier::external]\nfn gcd_external(a: u64, b: u64) -> u64 {\n    let mut i = a;\n    while i >= 1 {\n        if a % i == 0 && b % i == 0 {\n            break ;\n        }\n        i -= 1;\n    }\n    i\n}\n\n#[verifier::external_body]\nfn gcd(a: u64, b: u64) -> (result: u64)\n    requires\n        a >= 0,\n        b >= 0,\n    ensures\n        divides(a, result),\n        divides(b, result),\n{\n    gcd_external(a, b)\n}\n\nfn main3() {\n    let x = 42;\n    let y = 182;\n    let z = gcd(x, y);\n    assert(divides(x, z));\n    assert(divides(y, z));\n    // TODO assert(x % z == 0);\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn divides(v : u64, d : u64)->bool;\n  fn gcd_external(a : u64, b : u64) -> u64 {\n    let i = a;\n    i\n  }\n#[verifier::external_body]\n  fn gcd(a\n         : u64, b\n         : u64) -> (result\n                    : u64)\n    requires a >= 0,\n  b >= 0, ensures divides(a, result), divides(b, result){\n    gcd_external(a, b)\n  }\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/assorted_demo.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 700, "minimize_time_ms": 641701, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 68, "minimized_LOC": 19, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 3, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.27941176470588236}, "labeling": {"segments": {"exec": " fn main();\n  spec fn divides(v : u64, d : u64)->bool;\n  fn gcd_external(a : u64, b : u64) -> u64 {\n\n fn gcd(a\n         : u64, b\n         : u64) -> (result\n                    : u64)\n    requires a >= 0,\n  b >= 0, ensures divides(a, result), divides(b, result){", "spec": "spec fn divides(v : u64, d : u64)->bool;\n  fn gcd_external(a : u64, b : u64) -> u64 {\n\n    requires a >= 0,\n\n  b >= 0, ensures divides(a, result), divides(b, result){"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nfn main() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n#[derive(Eq, PartialEq, Structural)]\nstruct Train {\n    cars: u64,\n}\n\nfn main2() {\n    let t = Train { cars: 10 };\n    let q = Train { cars: 10 };\n    assert(t == q);\n}\n\nspec fn mul(a: u64, b: u64) -> u64 {\n    verus_builtin::mul(a, b)\n}\n\nspec fn divides(v: u64, d: u64) -> bool {\n    exists|k: u64| mul(d, k) == v\n}\n\n#[verifier::external]\nfn gcd_external(a: u64, b: u64) -> u64 {\n    let mut i = a;\n    while i >= 1 {\n        if a % i == 0 && b % i == 0 {\n            break ;\n        }\n        i -= 1;\n    }\n    i\n}\n\n#[verifier::external_body]\nfn gcd(a: u64, b: u64) -> (result: u64)\n    requires\n        a >= 0,\n        b >= 0,\n    ensures\n        divides(a, result),\n        divides(b, result),\n{\n    gcd_external(a, b)\n}\n\nfn main3() {\n    let x = 42;\n    let y = 182;\n    let z = gcd(x, y);\n    assert(divides(x, z));\n    assert(divides(y, z));\n    // TODO assert(x % z == 0);\n}\n\n} // verus!\n", "use verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn c(e : u64, d : u64)->bool;\n#[verifier::external_body]\n  fn f(a : u64, b : u64) -> (g : u64)ensures c(a, g) { b }\n}\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn divides(v : u64, d : u64)->bool;\n  fn gcd_external(a : u64, b : u64) -> u64 {\n    let i = a;\n    i\n  }\n#[verifier::external_body]\n  fn gcd(a\n         : u64, b\n         : u64) -> (result\n                    : u64)\n    requires a >= 0,\n  b >= 0, ensures divides(a, result), divides(b, result){\n    gcd_external(a, b)\n  }\n}\n", "use verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn divides(v : u64, d : u64)->bool;\n  fn gcd_external(a : u64, b : u64) -> u64 {\n    let i = a;\n    i\n  }\n#[verifier::external_body]\n  fn gcd(a\n         : u64, b\n         : u64) -> (result\n                    : u64)\n    requires ensures divides(a, result), {\n    gcd_external(a, b)\n  }\n}\n", "use verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn c(e : u64, d : u64)->bool;\n  fn f(a : u64, b : u64) -> u64 {\n    let g = a;\n    g\n  }\n#[verifier::external_body]\n  fn gcd(a\n         : u64, b\n         : u64) -> (h\n                    : u64)\n     ensures c(a, h) {\n     b\n  }\n}\n", "use verus_builtin_macros::*;\n     verus !{\n      fn main();\n      spec fn c(e : u64, d : u64)->bool;\n#[verifier::external_body]\n  fn gcd(a          : u64, b          : u64) -> (h                     : u64)      ensures c(a, h) {\n        b   }\n    }\n", "use verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn c(e : u64, d : u64)->bool;\n#[verifier::external_body]\n  fn gcd(a : u64, b : u64) -> (h : u64)ensures c(a, h) { b }\n}\n"]}
{"id": "atomics_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n        invariant on field with () is (b: bool, t: Option<T>) {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n    requires\n        lock.well_formed(),\n{\n    loop\n        invariant\n            lock.well_formed(),\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n        assert(new_val == old_val | 23);\n        assert(g == old_val);\n\n        g = proof_int(g | 23);\n\n        assert(g == new_val);\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));\n        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val\n            && ret.get_Err_0() == old_val));\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n        assert(ret == g);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n        invariant on field with () is (b: bool, t: Option<T>) {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n    requires\n        lock.well_formed(),\n{\n    loop\n        invariant\n            lock.well_formed(),\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n        assert(new_val == old_val | 23);\n        assert(g == old_val);\n\n        g = proof_int(g | 23);\n\n        assert(g == new_val);\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));\n        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val\n            && ret.get_Err_0() == old_val));\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n        assert(ret == g);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/atomics.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 946, "minimize_time_ms": 153158, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 139, "minimized_LOC": 139, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::atomic_ghost::", "vstd::prelude::", "vstd::"], "complexity_verus_tokens": 44, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n    requires\n        lock.well_formed(),\n{", "spec": "spec fn well_formed(&self) -> bool {\n\nspec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n\n        invariant on field with () is (b: bool, t: Option<T>) {\n\n    requires\n\n        invariant\n\n    ensures", "proof": "proof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n        invariant on field with () is (b: bool, t: Option<T>) {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n    requires\n        lock.well_formed(),\n{\n    loop\n        invariant\n            lock.well_formed(),\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n        assert(new_val == old_val | 23);\n        assert(g == old_val);\n\n        g = proof_int(g | 23);\n\n        assert(g == new_val);\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));\n        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val\n            && ret.get_Err_0() == old_val));\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n        assert(ret == g);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "basic_lock1_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic::*;\nuse vstd::invariant::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::atomic;\nuse vstd::modes::*;\n\nverus!{\n\nstruct LockInv { }\nimpl<T> InvariantPredicate<(AtomicCellId, CellId), (atomic::PermissionBool, Option<cell::PointsTo<T>>)> for LockInv {\n    open spec fn inv(\n        cell_ids: (AtomicCellId, CellId),\n        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n    ) -> bool {\n        ghost_stuff.0.id() == cell_ids.0\n        && match ghost_stuff.1 {\n            None => {\n                // When there's no PointsTo, the lock must be taken, thus\n                // the boolean value is 'true'.\n                ghost_stuff.0.value() == true\n            }\n            Some(points_to) => {\n                points_to.id() == cell_ids.1\n                  && points_to.is_init()\n                  && ghost_stuff.0.value() == false\n            }\n        }\n    }\n}\n\nstruct Lock<T> {\n    pub atomic: PAtomicBool,\n    pub cell: PCell<T>,\n    pub inv: Tracked<AtomicInvariant<\n        (AtomicCellId, CellId),\n        (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n        LockInv\n    >>,\n}\n\nimpl<T> Lock<T> {\n    spec fn wf(self) -> bool {\n        self.inv@.constant() == (self.atomic.id(), self.cell.id())\n    }\n\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (atomic, Tracked(atomic_perm)) = PAtomicBool::new(false);\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let tracked inv = AtomicInvariant::new(\n            (atomic.id(), cell.id()),\n            (atomic_perm, Some(cell_perm)),\n            1337);\n        Lock { atomic, cell, inv: Tracked(inv) }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked points_to_opt = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n                let tracked (mut atomic_permission, mut points_to_inv) = ghost_stuff;\n                res = self.atomic.compare_exchange(Tracked(&mut atomic_permission), false, true);\n                proof {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                    ghost_stuff = (atomic_permission, points_to_inv);\n                }\n            });\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n            let tracked (mut atomic_permission, _) = ghost_stuff;\n            self.atomic.store(Tracked(&mut atomic_permission), false);\n            proof {\n                ghost_stuff = (atomic_permission, Some(points_to.get()));\n            }\n        });\n    }\n}\n\n}\n\nfn main() { }\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic::*;\nuse vstd::invariant::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::atomic;\nuse vstd::modes::*;\n\nverus!{\n\nstruct LockInv { }\nimpl<T> InvariantPredicate<(AtomicCellId, CellId), (atomic::PermissionBool, Option<cell::PointsTo<T>>)> for LockInv {\n    open spec fn inv(\n        cell_ids: (AtomicCellId, CellId),\n        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n    ) -> bool {\n        ghost_stuff.0.id() == cell_ids.0\n        && match ghost_stuff.1 {\n            None => {\n                // When there's no PointsTo, the lock must be taken, thus\n                // the boolean value is 'true'.\n                ghost_stuff.0.value() == true\n            }\n            Some(points_to) => {\n                points_to.id() == cell_ids.1\n                  && points_to.is_init()\n                  && ghost_stuff.0.value() == false\n            }\n        }\n    }\n}\n\nstruct Lock<T> {\n    pub atomic: PAtomicBool,\n    pub cell: PCell<T>,\n    pub inv: Tracked<AtomicInvariant<\n        (AtomicCellId, CellId),\n        (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n        LockInv\n    >>,\n}\n\nimpl<T> Lock<T> {\n    spec fn wf(self) -> bool {\n        self.inv@.constant() == (self.atomic.id(), self.cell.id())\n    }\n\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (atomic, Tracked(atomic_perm)) = PAtomicBool::new(false);\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let tracked inv = AtomicInvariant::new(\n            (atomic.id(), cell.id()),\n            (atomic_perm, Some(cell_perm)),\n            1337);\n        Lock { atomic, cell, inv: Tracked(inv) }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked points_to_opt = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n                let tracked (mut atomic_permission, mut points_to_inv) = ghost_stuff;\n                res = self.atomic.compare_exchange(Tracked(&mut atomic_permission), false, true);\n                proof {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                    ghost_stuff = (atomic_permission, points_to_inv);\n                }\n            });\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n            let tracked (mut atomic_permission, _) = ghost_stuff;\n            self.atomic.store(Tracked(&mut atomic_permission), false);\n            proof {\n                ghost_stuff = (atomic_permission, Some(points_to.get()));\n            }\n        });\n    }\n}\n\n}\n\nfn main() { }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/basic_lock1.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1116, "minimize_time_ms": 122305, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 101, "minimized_LOC": 101, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::atomic::", "vstd::invariant::", "vstd::cell", "vstd::cell::", "vstd::atomic", "vstd::modes::"], "complexity_verus_tokens": 27, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n\n fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n\n fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n\n\nfn main() {", "spec": "spec fn inv(\n        cell_ids: (AtomicCellId, CellId),\n        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n    ) -> bool {\n\nspec fn wf(self) -> bool {\n\nuse vstd::invariant::*;\n\n        ensures lock.wf()\n\n        requires self.wf(),\n\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n\n            invariant self.wf(),\n\n        requires", "proof": "proof {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                    ghost_stuff = (atomic_permission, points_to_inv);\n                }\n\nproof {\n                ghost_stuff = (atomic_permission, Some(points_to.get()));\n            }"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic::*;\nuse vstd::invariant::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::atomic;\nuse vstd::modes::*;\n\nverus!{\n\nstruct LockInv { }\nimpl<T> InvariantPredicate<(AtomicCellId, CellId), (atomic::PermissionBool, Option<cell::PointsTo<T>>)> for LockInv {\n    open spec fn inv(\n        cell_ids: (AtomicCellId, CellId),\n        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n    ) -> bool {\n        ghost_stuff.0.id() == cell_ids.0\n        && match ghost_stuff.1 {\n            None => {\n                // When there's no PointsTo, the lock must be taken, thus\n                // the boolean value is 'true'.\n                ghost_stuff.0.value() == true\n            }\n            Some(points_to) => {\n                points_to.id() == cell_ids.1\n                  && points_to.is_init()\n                  && ghost_stuff.0.value() == false\n            }\n        }\n    }\n}\n\nstruct Lock<T> {\n    pub atomic: PAtomicBool,\n    pub cell: PCell<T>,\n    pub inv: Tracked<AtomicInvariant<\n        (AtomicCellId, CellId),\n        (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n        LockInv\n    >>,\n}\n\nimpl<T> Lock<T> {\n    spec fn wf(self) -> bool {\n        self.inv@.constant() == (self.atomic.id(), self.cell.id())\n    }\n\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (atomic, Tracked(atomic_perm)) = PAtomicBool::new(false);\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let tracked inv = AtomicInvariant::new(\n            (atomic.id(), cell.id()),\n            (atomic_perm, Some(cell_perm)),\n            1337);\n        Lock { atomic, cell, inv: Tracked(inv) }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked points_to_opt = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n                let tracked (mut atomic_permission, mut points_to_inv) = ghost_stuff;\n                res = self.atomic.compare_exchange(Tracked(&mut atomic_permission), false, true);\n                proof {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                    ghost_stuff = (atomic_permission, points_to_inv);\n                }\n            });\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n            let tracked (mut atomic_permission, _) = ghost_stuff;\n            self.atomic.store(Tracked(&mut atomic_permission), false);\n            proof {\n                ghost_stuff = (atomic_permission, Some(points_to.get()));\n            }\n        });\n    }\n}\n\n}\n\nfn main() { }\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "basic_lock2_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/basic_lock2.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 809, "minimize_time_ms": 122442, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 77, "minimized_LOC": 77, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::atomic_ghost::", "vstd::cell", "vstd::cell::", "vstd::modes::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": " fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n\n fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n\n fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n\n\nfn main() {", "spec": "spec fn wf(self) -> bool {\n\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n\n        ensures lock.wf()\n\n        requires self.wf(),\n\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n\n            invariant self.wf(),\n\n        requires"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bitmap_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n    requires\n        bv_new == set_bit64!(bv_old, index, bit),\n        index < 64,\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n    requires\n        bv_new == bv1 | bv2,\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n    requires\n        bv_new == u1 | u2,\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n        requires\n            index < self@.len(),\n        ensures\n            bit == self@[index as int],\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n        requires\n            index < old(self)@.len(),\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n        proof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n        ;\n        self.bits.set(seq_index, bv_new);\n        proof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n        requires\n            self@.len() == bm@.len(),\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n            invariant\n                i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n            proof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n", "minimized_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n    requires\n        bv_new == set_bit64!(bv_old, index, bit),\n        index < 64,\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n    requires\n        bv_new == bv1 | bv2,\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n    requires\n        bv_new == u1 | u2,\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n        requires\n            index < self@.len(),\n        ensures\n            bit == self@[index as int],\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n        requires\n            index < old(self)@.len(),\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n        proof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n        ;\n        self.bits.set(seq_index, bv_new);\n        proof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n        requires\n            self@.len() == bm@.len(),\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n            invariant\n                i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n            proof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/bitmap.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1312, "minimize_time_ms": 123642, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 175, "minimized_LOC": 175, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 39, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " fn from(v: Vec<u64>) -> BitMap {\n\n fn get_bit(&self, index: u32) -> (bit: bool)\n        requires\n            index < self@.len(),\n        ensures\n            bit == self@[index as int],\n    {\n\n fn set_bit(&mut self, index: u32, bit: bool)\n        requires\n            index < old(self)@.len(),\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n\n fn or(&self, bm: &BitMap) -> (ret: BitMap)\n        requires\n            self@.len() == bm@.len(),\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n\n\nfn main() {", "spec": "spec fn u64_view(u: u64) -> Seq<bool> {\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n\nspec fn view(&self) -> Seq<bool> {\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n            invariant", "proof": "proof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n    requires\n        bv_new == set_bit64!(bv_old, index, bit),\n        index < 64,\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n    requires\n        bv_new == bv1 | bv2,\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n    requires\n        bv_new == u1 | u2,\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n\nproof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n\nproof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n\nproof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n    requires\n        bv_new == set_bit64!(bv_old, index, bit),\n        index < 64,\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n    requires\n        bv_new == bv1 | bv2,\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n    requires\n        bv_new == u1 | u2,\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n        requires\n            index < self@.len(),\n        ensures\n            bit == self@[index as int],\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n        requires\n            index < old(self)@.len(),\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n        proof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n        ;\n        self.bits.set(seq_index, bv_new);\n        proof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n        requires\n            self@.len() == bm@.len(),\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n            invariant\n                i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n            proof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n", "use vstd;\nfn main() {}\n", " use vstd::{\n };\n          fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "bitvector_basic_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n// TODO: change this to a macro so that it can support u8, u16, u64, etc.\n//\n// Since &, |, ^, (bitwise)!, >>, << are uninterpreted functions for integers,\n// we need basic properties(communtativity, associativity, etc) for these operators.\n// We need to choose one of the below\n// 1) Make exactly the same formula using bit-vector reasoning, OR\n// 2) Make \"similar\" formula using bit-vector reasoning, and let the lemmas below do the rest.\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn bit_and32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a & b) == b & a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a & b) & c) == a & (b & c),\n        forall|a: u32| #[trigger] (a & a) == a,\n        forall|a: u32| #[trigger] (a & 0) == 0,\n        forall|a: u32| #[trigger] (a & 0xffffffffu32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a | b) == b | a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a | b) | c) == a | (b | c),\n        forall|a: u32| #[trigger] (a | a) == a,\n        forall|a: u32| #[trigger] (a | 0) == a,\n        forall|a: u32| #[trigger] (a | 0xffff_ffffu32) == 0xffff_ffffu32,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_xor32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a ^ b) == b ^ a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a ^ b) ^ c) == a ^ (b ^ c),\n        forall|a: u32| #[trigger] (a ^ a) == 0,\n        forall|a: u32| #[trigger] (a ^ 0) == a,\n        forall|a: u32| #[trigger] (a ^ 0xffff_ffffu32) == !a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_not32_auto()\n    ensures\n        forall|a: u32| #[trigger] !(!a) == a,\n        !0u32 == 0xffff_ffffu32,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_lshr32_auto()\n    ensures\n        forall|a: u32| #[trigger] (a >> 0u32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_shl32_auto()\n    ensures\n        forall|a: u32| #[trigger] (a << 0u32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_property32_auto()\n    ensures\n// absorb\n\n        forall|a: u32, b: u32| #[trigger] (a & (a | b)) == a,\n        forall|a: u32, b: u32| #[trigger] (a | (a & b)) == a,\n        // distributive\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b | c)) == (a & b) | (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b ^ c)) == (a & b) ^ (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a | (b & c)) == (a | b) & (a | c),\n        // De Morgan\n        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,\n        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,\n{\n}\n\nproof fn test9(b1: u32, b2: u32, b3: u32) {\n    bit_and32_auto();\n    assert(b1 & 0xff < 0x100) by (bit_vector);\n    assert(0xff & b1 < 0x100);\n    let zero = 0u32;\n    assert(zero & b3 == 0u32);\n}\n\nproof fn test10(a: u8, b: u8) {\n    // We can write conditions about overflow in bit_vector assertion\n    assert((a & b) == 0 ==> (a | b) == (a + b) && (a + b) < 256) by(bit_vector);\n}\n\nproof fn test11(x: u32, y: u32) {\n    // XOR operation is independent of bitwidth so we don't need bit_vector solver to do this:\n    assert((x as u64) ^ (y as u64) == (x ^ y) as u64);\n}\n\nproof fn test_usize(x: usize, y: usize, z: usize) {\n    assert(((x & y) & z) == (x & (y & z))) by(bit_vector);\n}\n\nproof fn test_signed(x: i8, y: i8, z: i8, u: u8) {\n    assert(!(x & y) == (!x | !y)) by(bit_vector);\n    assert((!z) == (!(z as i32))) by(bit_vector);\n    assert((z & (128u8 as i8)) != 0 <==> z < 0) by(bit_vector);\n\n    // Compare signed vs unsigned\n    assert(u > -1) by(bit_vector);\n    assert(u > 128 ==> u > x) by(bit_vector);\n}\n\nproof fn prove_associativity(a: u8, b: i8, c: u8) {\n    assert((a + b) + c == a + (b + c)) by(bit_vector);\n}\n\n} // verus!\n#[verifier::external_body]\nfn main() {}\n", "minimized_code": "use verus_builtin::*;\n  use verus_builtin_macros::*;\n   verus! {\n#[verifier::bit_vector]\nproof fn bit_and32_auto()     ensures         forall|a: u32, b: u32|   \n#[trigger] (a & b) == b & a,\n        forall|a: u32|   \n#[trigger] (a & 0) == 0,\n{\n }\n#[verifier::bit_vector]\nproof fn bit_xor32_auto()     ensures         forall|a: u32, b: u32|   \n#[trigger] (a ^ b) == b ^ a,\n{\n }\n  }\n  fn main() {\n }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/bitvector_basic.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1877, "minimize_time_ms": 187107, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 126, "minimized_LOC": 18, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 5, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 0.14285714285714285}, "labeling": {"segments": {"exec": " fn main() {", "spec": "proof fn bit_and32_auto()     ensures         forall|a: u32, b: u32|   \n\nproof fn bit_xor32_auto()     ensures         forall|a: u32, b: u32|   ", "proof": "proof fn bit_and32_auto()     ensures         forall|a: u32, b: u32|   \n#[trigger] (a & b) == b & a,\n        forall|a: u32|   \n#[trigger] (a & 0) == 0,\n{\n\nproof fn bit_xor32_auto()     ensures         forall|a: u32, b: u32|   \n#[trigger] (a ^ b) == b ^ a,\n{"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n// TODO: change this to a macro so that it can support u8, u16, u64, etc.\n//\n// Since &, |, ^, (bitwise)!, >>, << are uninterpreted functions for integers,\n// we need basic properties(communtativity, associativity, etc) for these operators.\n// We need to choose one of the below\n// 1) Make exactly the same formula using bit-vector reasoning, OR\n// 2) Make \"similar\" formula using bit-vector reasoning, and let the lemmas below do the rest.\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn bit_and32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a & b) == b & a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a & b) & c) == a & (b & c),\n        forall|a: u32| #[trigger] (a & a) == a,\n        forall|a: u32| #[trigger] (a & 0) == 0,\n        forall|a: u32| #[trigger] (a & 0xffffffffu32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a | b) == b | a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a | b) | c) == a | (b | c),\n        forall|a: u32| #[trigger] (a | a) == a,\n        forall|a: u32| #[trigger] (a | 0) == a,\n        forall|a: u32| #[trigger] (a | 0xffff_ffffu32) == 0xffff_ffffu32,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_xor32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a ^ b) == b ^ a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a ^ b) ^ c) == a ^ (b ^ c),\n        forall|a: u32| #[trigger] (a ^ a) == 0,\n        forall|a: u32| #[trigger] (a ^ 0) == a,\n        forall|a: u32| #[trigger] (a ^ 0xffff_ffffu32) == !a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_not32_auto()\n    ensures\n        forall|a: u32| #[trigger] !(!a) == a,\n        !0u32 == 0xffff_ffffu32,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_lshr32_auto()\n    ensures\n        forall|a: u32| #[trigger] (a >> 0u32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_shl32_auto()\n    ensures\n        forall|a: u32| #[trigger] (a << 0u32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_property32_auto()\n    ensures\n// absorb\n\n        forall|a: u32, b: u32| #[trigger] (a & (a | b)) == a,\n        forall|a: u32, b: u32| #[trigger] (a | (a & b)) == a,\n        // distributive\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b | c)) == (a & b) | (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b ^ c)) == (a & b) ^ (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a | (b & c)) == (a | b) & (a | c),\n        // De Morgan\n        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,\n        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,\n{\n}\n\nproof fn test9(b1: u32, b2: u32, b3: u32) {\n    bit_and32_auto();\n    assert(b1 & 0xff < 0x100) by (bit_vector);\n    assert(0xff & b1 < 0x100);\n    let zero = 0u32;\n    assert(zero & b3 == 0u32);\n}\n\nproof fn test10(a: u8, b: u8) {\n    // We can write conditions about overflow in bit_vector assertion\n    assert((a & b) == 0 ==> (a | b) == (a + b) && (a + b) < 256) by(bit_vector);\n}\n\nproof fn test11(x: u32, y: u32) {\n    // XOR operation is independent of bitwidth so we don't need bit_vector solver to do this:\n    assert((x as u64) ^ (y as u64) == (x ^ y) as u64);\n}\n\nproof fn test_usize(x: usize, y: usize, z: usize) {\n    assert(((x & y) & z) == (x & (y & z))) by(bit_vector);\n}\n\nproof fn test_signed(x: i8, y: i8, z: i8, u: u8) {\n    assert(!(x & y) == (!x | !y)) by(bit_vector);\n    assert((!z) == (!(z as i32))) by(bit_vector);\n    assert((z & (128u8 as i8)) != 0 <==> z < 0) by(bit_vector);\n\n    // Compare signed vs unsigned\n    assert(u > -1) by(bit_vector);\n    assert(u > 128 ==> u > x) by(bit_vector);\n}\n\nproof fn prove_associativity(a: u8, b: i8, c: u8) {\n    assert((a + b) + c == a + (b + c)) by(bit_vector);\n}\n\n} // verus!\n#[verifier::external_body]\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n  use verus_builtin_macros::*;\n   verus! {\n#[verifier::bit_vector]\nproof fn bit_and32_auto()     ensures         forall|a: u32, b: u32|   \n#[trigger] (a & b) == b & a,\n        forall|a: u32|   \n#[trigger] (a & 0) == 0,\n{\n }\n#[verifier::bit_vector]\nproof fn bit_xor32_auto()     ensures         forall|a: u32, b: u32|   \n#[trigger] (a ^ b) == b ^ a,\n{\n }\n  }\n  fn main() {\n }\n", "use verus_builtin::*;\n       use verus_builtin_macros::*;\n        verus! {}\n       fn main() {}\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "bitvector_equivalence_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\n// example from https://stackoverflow.com/questions/73145883/showing-equivalence-of-two-bitvectors\n\nverus! {\n\n// for the lower `n` bits, are `a` and `b` the same?\nspec fn equal_lower_n_bits(a: u32, b: u32, n: u32) -> bool\n    recommends\n        n <= 32,\n{\n    a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1)  // a & (1<<n -1) == b & (1<<n -1)\n\n}\n\n// bitvector translation for `equivalence_proof_increment`\n// in bit-vector mode, all spec functions should be unwrapped to definition (or use macro)\n#[verifier::bit_vector]\nproof fn equivalence_proof_increment_bv(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1),  // equal_lower_n_bits(a,b,n)\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        a & sub(1u32 << add(n, 1), 1) == b & sub(\n            1u32 << add(n, 1),\n            1,\n        ),  // equal_lower_n_bits(a,b,n+1)\n{\n}\n\n// when we know `a` and `b` have same lowewr `n` bits, and a[n] == b[n],\n// we ensure that `a` and `b` have same lowewr `n+1` bits\n// wrapper of `equivalence_proof_increment_bv` for the inductive proof below(`equivalence_proof_lower_n`)\nproof fn equivalence_proof_increment(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        equal_lower_n_bits(a, b, n),\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        equal_lower_n_bits(a, b, add(n, 1)),\n{\n    equivalence_proof_increment_bv(a, b, n);\n}\n\n// for the lower `n` bits, if each bit is the same,\n// we ensure that `a` and `b` have same lower `n` bits\nproof fn equivalence_proof_lower_n(a: u32, b: u32, n: u32)\n    requires\n        n <= 32,\n        forall|i: u32| #![auto] (i < n ==> (get_bit!(a, i) == get_bit!(b, i))),\n    ensures\n        equal_lower_n_bits(a, b, n),\n    decreases n,\n{\n    if n == 0 {\n        assert(a & sub(1u32 << 0, 1) == b & sub(1u32 << 0, 1)) by (bit_vector);\n        // assert(equal_lower_n_bits(a,b,0));\n    } else {\n        equivalence_proof_lower_n(a, b, sub(n, 1));  // lower `n-1` bits\n        equivalence_proof_increment(a, b, sub(n, 1));  // the `n`-th bit\n    }\n}\n\nproof fn equivalence_proof(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n    equivalence_proof_lower_n(a, b, 32);\n    // at this point, we have `equal_lower_n_bits(a,b,32)`\n    // now it is trivial to get `a==b`, however, we need additional call to conclude that a==b\n    // this is because Verus does not reason about bitvectors unless it is explicitly specified.\n    assert(a == b) by (bit_vector)\n        requires\n            a & sub(1u32 << 32, 1) == b & sub(1u32 << 32, 1),\n    ;\n}\n\n// This fails because of trigger not being instantiated\n// #[verifier::bit_vector]\n// proof fn equivalence_proof_bv(a:u32, b:u32)\n//     requires\n//         forall|i: u32| #![auto]\n//             i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n//     ensures\n//         a == b,\n// {}\n#[verifier::bit_vector]\nproof fn equivalence_proof_bv(a: u32, b: u32)\n    requires\n        get_bit!(a, 0u32) == get_bit!(b, 0u32),\n        get_bit!(a, 1u32) == get_bit!(b, 1u32),\n        get_bit!(a, 2u32) == get_bit!(b, 2u32),\n        get_bit!(a, 3u32) == get_bit!(b, 3u32),\n        get_bit!(a, 4u32) == get_bit!(b, 4u32),\n        get_bit!(a, 5u32) == get_bit!(b, 5u32),\n        get_bit!(a, 6u32) == get_bit!(b, 6u32),\n        get_bit!(a, 7u32) == get_bit!(b, 7u32),\n        get_bit!(a, 8u32) == get_bit!(b, 8u32),\n        get_bit!(a, 9u32) == get_bit!(b, 9u32),\n        get_bit!(a, 10u32) == get_bit!(b, 10u32),\n        get_bit!(a, 11u32) == get_bit!(b, 11u32),\n        get_bit!(a, 12u32) == get_bit!(b, 12u32),\n        get_bit!(a, 13u32) == get_bit!(b, 13u32),\n        get_bit!(a, 14u32) == get_bit!(b, 14u32),\n        get_bit!(a, 15u32) == get_bit!(b, 15u32),\n        get_bit!(a, 16u32) == get_bit!(b, 16u32),\n        get_bit!(a, 17u32) == get_bit!(b, 17u32),\n        get_bit!(a, 18u32) == get_bit!(b, 18u32),\n        get_bit!(a, 19u32) == get_bit!(b, 19u32),\n        get_bit!(a, 20u32) == get_bit!(b, 20u32),\n        get_bit!(a, 21u32) == get_bit!(b, 21u32),\n        get_bit!(a, 22u32) == get_bit!(b, 22u32),\n        get_bit!(a, 23u32) == get_bit!(b, 23u32),\n        get_bit!(a, 24u32) == get_bit!(b, 24u32),\n        get_bit!(a, 25u32) == get_bit!(b, 25u32),\n        get_bit!(a, 26u32) == get_bit!(b, 26u32),\n        get_bit!(a, 27u32) == get_bit!(b, 27u32),\n        get_bit!(a, 28u32) == get_bit!(b, 28u32),\n        get_bit!(a, 29u32) == get_bit!(b, 29u32),\n        get_bit!(a, 30u32) == get_bit!(b, 30u32),\n        get_bit!(a, 31u32) == get_bit!(b, 31u32),\n    ensures\n        a == b,\n{\n}\n\nproof fn equivalence_proof_2(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n    equivalence_proof_bv(a, b);\n}\n\n// #[verifier::spec]\n// fn u32_view(u: u32) -> Seq<bool> {\n//     Seq::new(32, |i: int| get_bit!(u, i as u32))\n// }\n// proof fn equivalence_proof_3(a:u32, b:u32)\n//     requires\n//         u32_view(a) == u32_view(b),\n//     ensures\n//         a == b,\n// {\n//     assert(u32_view(a).index(0) == u32_view(b).index(0));\n//     // assert(get_bit!(a, 0u32) == get_bit!(b, 0u32));\n//     // assert(get_bit!(a, 1u32) == get_bit!(b, 1u32));\n//     equivalence_proof_bv(a,b);\n// }\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\n// example from https://stackoverflow.com/questions/73145883/showing-equivalence-of-two-bitvectors\n\nverus! {\n\n// for the lower `n` bits, are `a` and `b` the same?\nspec fn equal_lower_n_bits(a: u32, b: u32, n: u32) -> bool\n    recommends\n        n <= 32,\n{\n    a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1)  // a & (1<<n -1) == b & (1<<n -1)\n\n}\n\n// bitvector translation for `equivalence_proof_increment`\n// in bit-vector mode, all spec functions should be unwrapped to definition (or use macro)\n#[verifier::bit_vector]\nproof fn equivalence_proof_increment_bv(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1),  // equal_lower_n_bits(a,b,n)\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        a & sub(1u32 << add(n, 1), 1) == b & sub(\n            1u32 << add(n, 1),\n            1,\n        ),  // equal_lower_n_bits(a,b,n+1)\n{\n}\n\n// when we know `a` and `b` have same lowewr `n` bits, and a[n] == b[n],\n// we ensure that `a` and `b` have same lowewr `n+1` bits\n// wrapper of `equivalence_proof_increment_bv` for the inductive proof below(`equivalence_proof_lower_n`)\nproof fn equivalence_proof_increment(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        equal_lower_n_bits(a, b, n),\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        equal_lower_n_bits(a, b, add(n, 1)),\n{\n    equivalence_proof_increment_bv(a, b, n);\n}\n\n// for the lower `n` bits, if each bit is the same,\n// we ensure that `a` and `b` have same lower `n` bits\nproof fn equivalence_proof_lower_n(a: u32, b: u32, n: u32)\n    requires\n        n <= 32,\n        forall|i: u32| #![auto] (i < n ==> (get_bit!(a, i) == get_bit!(b, i))),\n    ensures\n        equal_lower_n_bits(a, b, n),\n    decreases n,\n{\n    if n == 0 {\n        assert(a & sub(1u32 << 0, 1) == b & sub(1u32 << 0, 1)) by (bit_vector);\n        // assert(equal_lower_n_bits(a,b,0));\n    } else {\n        equivalence_proof_lower_n(a, b, sub(n, 1));  // lower `n-1` bits\n        equivalence_proof_increment(a, b, sub(n, 1));  // the `n`-th bit\n    }\n}\n\nproof fn equivalence_proof(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n    equivalence_proof_lower_n(a, b, 32);\n    // at this point, we have `equal_lower_n_bits(a,b,32)`\n    // now it is trivial to get `a==b`, however, we need additional call to conclude that a==b\n    // this is because Verus does not reason about bitvectors unless it is explicitly specified.\n    assert(a == b) by (bit_vector)\n        requires\n            a & sub(1u32 << 32, 1) == b & sub(1u32 << 32, 1),\n    ;\n}\n\n// This fails because of trigger not being instantiated\n// #[verifier::bit_vector]\n// proof fn equivalence_proof_bv(a:u32, b:u32)\n//     requires\n//         forall|i: u32| #![auto]\n//             i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n//     ensures\n//         a == b,\n// {}\n#[verifier::bit_vector]\nproof fn equivalence_proof_bv(a: u32, b: u32)\n    requires\n        get_bit!(a, 0u32) == get_bit!(b, 0u32),\n        get_bit!(a, 1u32) == get_bit!(b, 1u32),\n        get_bit!(a, 2u32) == get_bit!(b, 2u32),\n        get_bit!(a, 3u32) == get_bit!(b, 3u32),\n        get_bit!(a, 4u32) == get_bit!(b, 4u32),\n        get_bit!(a, 5u32) == get_bit!(b, 5u32),\n        get_bit!(a, 6u32) == get_bit!(b, 6u32),\n        get_bit!(a, 7u32) == get_bit!(b, 7u32),\n        get_bit!(a, 8u32) == get_bit!(b, 8u32),\n        get_bit!(a, 9u32) == get_bit!(b, 9u32),\n        get_bit!(a, 10u32) == get_bit!(b, 10u32),\n        get_bit!(a, 11u32) == get_bit!(b, 11u32),\n        get_bit!(a, 12u32) == get_bit!(b, 12u32),\n        get_bit!(a, 13u32) == get_bit!(b, 13u32),\n        get_bit!(a, 14u32) == get_bit!(b, 14u32),\n        get_bit!(a, 15u32) == get_bit!(b, 15u32),\n        get_bit!(a, 16u32) == get_bit!(b, 16u32),\n        get_bit!(a, 17u32) == get_bit!(b, 17u32),\n        get_bit!(a, 18u32) == get_bit!(b, 18u32),\n        get_bit!(a, 19u32) == get_bit!(b, 19u32),\n        get_bit!(a, 20u32) == get_bit!(b, 20u32),\n        get_bit!(a, 21u32) == get_bit!(b, 21u32),\n        get_bit!(a, 22u32) == get_bit!(b, 22u32),\n        get_bit!(a, 23u32) == get_bit!(b, 23u32),\n        get_bit!(a, 24u32) == get_bit!(b, 24u32),\n        get_bit!(a, 25u32) == get_bit!(b, 25u32),\n        get_bit!(a, 26u32) == get_bit!(b, 26u32),\n        get_bit!(a, 27u32) == get_bit!(b, 27u32),\n        get_bit!(a, 28u32) == get_bit!(b, 28u32),\n        get_bit!(a, 29u32) == get_bit!(b, 29u32),\n        get_bit!(a, 30u32) == get_bit!(b, 30u32),\n        get_bit!(a, 31u32) == get_bit!(b, 31u32),\n    ensures\n        a == b,\n{\n}\n\nproof fn equivalence_proof_2(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n    equivalence_proof_bv(a, b);\n}\n\n// #[verifier::spec]\n// fn u32_view(u: u32) -> Seq<bool> {\n//     Seq::new(32, |i: int| get_bit!(u, i as u32))\n// }\n// proof fn equivalence_proof_3(a:u32, b:u32)\n//     requires\n//         u32_view(a) == u32_view(b),\n//     ensures\n//         a == b,\n// {\n//     assert(u32_view(a).index(0) == u32_view(b).index(0));\n//     // assert(get_bit!(a, 0u32) == get_bit!(b, 0u32));\n//     // assert(get_bit!(a, 1u32) == get_bit!(b, 1u32));\n//     equivalence_proof_bv(a,b);\n// }\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/bitvector_equivalence.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1049, "minimize_time_ms": 154999, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 173, "minimized_LOC": 173, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 51, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"spec": "spec fn equal_lower_n_bits(a: u32, b: u32, n: u32) -> bool\n    recommends\n        n <= 32,\n{\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    decreases n,\n\n    requires\n\n    ensures\n\n        requires\n\n//     requires\n\n//     ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n//     requires\n\n//     ensures", "proof": "proof fn equivalence_proof_increment_bv(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1),  // equal_lower_n_bits(a,b,n)\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        a & sub(1u32 << add(n, 1), 1) == b & sub(\n            1u32 << add(n, 1),\n            1,\n        ),  // equal_lower_n_bits(a,b,n+1)\n{\n\nproof fn equivalence_proof_increment(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        equal_lower_n_bits(a, b, n),\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        equal_lower_n_bits(a, b, add(n, 1)),\n{\n\nproof fn equivalence_proof_lower_n(a: u32, b: u32, n: u32)\n    requires\n        n <= 32,\n        forall|i: u32| #![auto] (i < n ==> (get_bit!(a, i) == get_bit!(b, i))),\n    ensures\n        equal_lower_n_bits(a, b, n),\n    decreases n,\n{\n\nproof fn equivalence_proof(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n\nproof fn equivalence_proof_bv(a:u32, b:u32)\n//     requires\n//         forall|i: u32| #![auto]\n//             i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n//     ensures\n//         a == b,\n// {\n\nproof fn equivalence_proof_bv(a: u32, b: u32)\n    requires\n        get_bit!(a, 0u32) == get_bit!(b, 0u32),\n        get_bit!(a, 1u32) == get_bit!(b, 1u32),\n        get_bit!(a, 2u32) == get_bit!(b, 2u32),\n        get_bit!(a, 3u32) == get_bit!(b, 3u32),\n        get_bit!(a, 4u32) == get_bit!(b, 4u32),\n        get_bit!(a, 5u32) == get_bit!(b, 5u32),\n        get_bit!(a, 6u32) == get_bit!(b, 6u32),\n        get_bit!(a, 7u32) == get_bit!(b, 7u32),\n        get_bit!(a, 8u32) == get_bit!(b, 8u32),\n        get_bit!(a, 9u32) == get_bit!(b, 9u32),\n        get_bit!(a, 10u32) == get_bit!(b, 10u32),\n        get_bit!(a, 11u32) == get_bit!(b, 11u32),\n        get_bit!(a, 12u32) == get_bit!(b, 12u32),\n        get_bit!(a, 13u32) == get_bit!(b, 13u32),\n        get_bit!(a, 14u32) == get_bit!(b, 14u32),\n        get_bit!(a, 15u32) == get_bit!(b, 15u32),\n        get_bit!(a, 16u32) == get_bit!(b, 16u32),\n        get_bit!(a, 17u32) == get_bit!(b, 17u32),\n        get_bit!(a, 18u32) == get_bit!(b, 18u32),\n        get_bit!(a, 19u32) == get_bit!(b, 19u32),\n        get_bit!(a, 20u32) == get_bit!(b, 20u32),\n        get_bit!(a, 21u32) == get_bit!(b, 21u32),\n        get_bit!(a, 22u32) == get_bit!(b, 22u32),\n        get_bit!(a, 23u32) == get_bit!(b, 23u32),\n        get_bit!(a, 24u32) == get_bit!(b, 24u32),\n        get_bit!(a, 25u32) == get_bit!(b, 25u32),\n        get_bit!(a, 26u32) == get_bit!(b, 26u32),\n        get_bit!(a, 27u32) == get_bit!(b, 27u32),\n        get_bit!(a, 28u32) == get_bit!(b, 28u32),\n        get_bit!(a, 29u32) == get_bit!(b, 29u32),\n        get_bit!(a, 30u32) == get_bit!(b, 30u32),\n        get_bit!(a, 31u32) == get_bit!(b, 31u32),\n    ensures\n        a == b,\n{\n\nproof fn equivalence_proof_2(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n\nproof fn equivalence_proof_3(a:u32, b:u32)\n//     requires\n//         u32_view(a) == u32_view(b),\n//     ensures\n//         a == b,\n// {"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\n// example from https://stackoverflow.com/questions/73145883/showing-equivalence-of-two-bitvectors\n\nverus! {\n\n// for the lower `n` bits, are `a` and `b` the same?\nspec fn equal_lower_n_bits(a: u32, b: u32, n: u32) -> bool\n    recommends\n        n <= 32,\n{\n    a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1)  // a & (1<<n -1) == b & (1<<n -1)\n\n}\n\n// bitvector translation for `equivalence_proof_increment`\n// in bit-vector mode, all spec functions should be unwrapped to definition (or use macro)\n#[verifier::bit_vector]\nproof fn equivalence_proof_increment_bv(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1),  // equal_lower_n_bits(a,b,n)\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        a & sub(1u32 << add(n, 1), 1) == b & sub(\n            1u32 << add(n, 1),\n            1,\n        ),  // equal_lower_n_bits(a,b,n+1)\n{\n}\n\n// when we know `a` and `b` have same lowewr `n` bits, and a[n] == b[n],\n// we ensure that `a` and `b` have same lowewr `n+1` bits\n// wrapper of `equivalence_proof_increment_bv` for the inductive proof below(`equivalence_proof_lower_n`)\nproof fn equivalence_proof_increment(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        equal_lower_n_bits(a, b, n),\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        equal_lower_n_bits(a, b, add(n, 1)),\n{\n    equivalence_proof_increment_bv(a, b, n);\n}\n\n// for the lower `n` bits, if each bit is the same,\n// we ensure that `a` and `b` have same lower `n` bits\nproof fn equivalence_proof_lower_n(a: u32, b: u32, n: u32)\n    requires\n        n <= 32,\n        forall|i: u32| #![auto] (i < n ==> (get_bit!(a, i) == get_bit!(b, i))),\n    ensures\n        equal_lower_n_bits(a, b, n),\n    decreases n,\n{\n    if n == 0 {\n        assert(a & sub(1u32 << 0, 1) == b & sub(1u32 << 0, 1)) by (bit_vector);\n        // assert(equal_lower_n_bits(a,b,0));\n    } else {\n        equivalence_proof_lower_n(a, b, sub(n, 1));  // lower `n-1` bits\n        equivalence_proof_increment(a, b, sub(n, 1));  // the `n`-th bit\n    }\n}\n\nproof fn equivalence_proof(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n    equivalence_proof_lower_n(a, b, 32);\n    // at this point, we have `equal_lower_n_bits(a,b,32)`\n    // now it is trivial to get `a==b`, however, we need additional call to conclude that a==b\n    // this is because Verus does not reason about bitvectors unless it is explicitly specified.\n    assert(a == b) by (bit_vector)\n        requires\n            a & sub(1u32 << 32, 1) == b & sub(1u32 << 32, 1),\n    ;\n}\n\n// This fails because of trigger not being instantiated\n// #[verifier::bit_vector]\n// proof fn equivalence_proof_bv(a:u32, b:u32)\n//     requires\n//         forall|i: u32| #![auto]\n//             i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n//     ensures\n//         a == b,\n// {}\n#[verifier::bit_vector]\nproof fn equivalence_proof_bv(a: u32, b: u32)\n    requires\n        get_bit!(a, 0u32) == get_bit!(b, 0u32),\n        get_bit!(a, 1u32) == get_bit!(b, 1u32),\n        get_bit!(a, 2u32) == get_bit!(b, 2u32),\n        get_bit!(a, 3u32) == get_bit!(b, 3u32),\n        get_bit!(a, 4u32) == get_bit!(b, 4u32),\n        get_bit!(a, 5u32) == get_bit!(b, 5u32),\n        get_bit!(a, 6u32) == get_bit!(b, 6u32),\n        get_bit!(a, 7u32) == get_bit!(b, 7u32),\n        get_bit!(a, 8u32) == get_bit!(b, 8u32),\n        get_bit!(a, 9u32) == get_bit!(b, 9u32),\n        get_bit!(a, 10u32) == get_bit!(b, 10u32),\n        get_bit!(a, 11u32) == get_bit!(b, 11u32),\n        get_bit!(a, 12u32) == get_bit!(b, 12u32),\n        get_bit!(a, 13u32) == get_bit!(b, 13u32),\n        get_bit!(a, 14u32) == get_bit!(b, 14u32),\n        get_bit!(a, 15u32) == get_bit!(b, 15u32),\n        get_bit!(a, 16u32) == get_bit!(b, 16u32),\n        get_bit!(a, 17u32) == get_bit!(b, 17u32),\n        get_bit!(a, 18u32) == get_bit!(b, 18u32),\n        get_bit!(a, 19u32) == get_bit!(b, 19u32),\n        get_bit!(a, 20u32) == get_bit!(b, 20u32),\n        get_bit!(a, 21u32) == get_bit!(b, 21u32),\n        get_bit!(a, 22u32) == get_bit!(b, 22u32),\n        get_bit!(a, 23u32) == get_bit!(b, 23u32),\n        get_bit!(a, 24u32) == get_bit!(b, 24u32),\n        get_bit!(a, 25u32) == get_bit!(b, 25u32),\n        get_bit!(a, 26u32) == get_bit!(b, 26u32),\n        get_bit!(a, 27u32) == get_bit!(b, 27u32),\n        get_bit!(a, 28u32) == get_bit!(b, 28u32),\n        get_bit!(a, 29u32) == get_bit!(b, 29u32),\n        get_bit!(a, 30u32) == get_bit!(b, 30u32),\n        get_bit!(a, 31u32) == get_bit!(b, 31u32),\n    ensures\n        a == b,\n{\n}\n\nproof fn equivalence_proof_2(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n    equivalence_proof_bv(a, b);\n}\n\n// #[verifier::spec]\n// fn u32_view(u: u32) -> Seq<bool> {\n//     Seq::new(32, |i: int| get_bit!(u, i as u32))\n// }\n// proof fn equivalence_proof_3(a:u32, b:u32)\n//     requires\n//         u32_view(a) == u32_view(b),\n//     ensures\n//         a == b,\n// {\n//     assert(u32_view(a).index(0) == u32_view(b).index(0));\n//     // assert(get_bit!(a, 0u32) == get_bit!(b, 0u32));\n//     // assert(get_bit!(a, 1u32) == get_bit!(b, 1u32));\n//     equivalence_proof_bv(a,b);\n// }\n\n} // verus!\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n            fn main() {\n  }\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "bitvector_garbage_collection_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nenum Color {\n    White,  // 11\n    Gray,  // 10\n    Black,  // 01\n    Undefined,  // 00\n}\n\nspec fn color_view(high: bool, low: bool) -> Color {\n    if high {\n        if low {\n            Color::White\n        } else {\n            Color::Gray\n        }\n    } else {\n        if low {\n            Color::Black\n        } else {\n            Color::Undefined\n        }\n    }\n}\n\nspec fn bucket_view(bucket: u32) -> Seq<Color> {\n    Seq::new(\n        16,\n        |i: int|\n            color_view(\n                get_bit!(bucket, add(mul(i as u32, 2), 1)),\n                get_bit!(bucket, mul(i as u32, 2)),\n            ),\n    )\n}\n\n#[verifier::bit_vector]\nproof fn set_two_bit_proof(\n    bv: u32,\n    target: u32,\n    mask: u32,\n    result: u32,\n    low_loc: u32,\n    high: bool,\n    low: bool,\n)\n    requires\n        low_loc < 31,\n        target == (if high {\n            if low {\n                3u32\n            } else {\n                2u32\n            }\n        } else {\n            if low {\n                1u32\n            } else {\n                0u32\n            }\n        }) << low_loc,\n        mask == !(3u32 << low_loc),\n        result == (bv & mask) | target,\n    ensures\n        get_bit!(result, low_loc) == low,\n        get_bit!(result, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(result, loc2)\n                == get_bit!(bv, loc2),\n{\n}\n\nfn set_two_bit_exec(bv: u32, low_loc: u32, high: bool, low: bool) -> (ret: u32)\n    requires\n        low_loc < 31,\n    ensures\n        get_bit!(ret, low_loc) == low,\n        get_bit!(ret, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(ret, loc2)\n                == get_bit!(bv, loc2),\n{\n    let target: u32 = (if high {\n        if low {\n            3u32\n        } else {\n            2u32\n        }\n    } else {\n        if low {\n            1u32\n        } else {\n            0u32\n        }\n    }) << low_loc;\n    let mask: u32 = !(3u32 << low_loc);\n    let result: u32 = (bv & mask) | target;\n    proof {\n        set_two_bit_proof(bv, target, mask, result, low_loc, high, low);\n    }\n    result\n}\n\nfn set_color(bucket: u32, high: bool, low: bool, i: u32, ghost_bucket: Seq<Color>) -> (new_bucket:\n    u32)\n    requires\n        i < 16,\n        bucket_view(bucket) =~= ghost_bucket,\n    ensures\n        bucket_view(new_bucket) =~= ghost_bucket.update(i as int, color_view(high, low)),\n{\n    let new_bucket = set_two_bit_exec(bucket, 2 * i, high, low);\n    assert(color_view(high, low) == color_view(\n        get_bit!(new_bucket, add(mul(2, i), 1)),\n        get_bit!(new_bucket, mul(2, i)),\n    ));\n    new_bucket\n}\n\n#[verifier::bit_vector]\nproof fn get_color_proof(bv: u32, index: u32, v: u32)\n    requires\n        v == 3u32 & (bv >> mul(index, 2)),\n    ensures\n        v < 4u32,\n        v == 3 ==> get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 2 ==> !get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 1 ==> get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n        v == 0 ==> !get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n{\n}\n\nfn get_color(bv: u32, index: u32) -> (c: Color)\n    requires\n        index < 15,\n    ensures\n        c == color_view(get_bit!(bv, add(mul(2, index), 1)), get_bit!(bv, mul(2, index))),\n{\n    let v: u32 = 3u32 & (bv >> index * 2);\n    proof {\n        get_color_proof(bv, index, v);\n    }\n    let c = if v == 0 {\n        Color::Undefined\n    } else if v == 1 {\n        Color::Black\n    } else if v == 2 {\n        Color::Gray\n    } else {\n        Color::White\n    };\n    c\n}\n\n} // verus!\n", "minimized_code": "use vstd::prelude::*;\n       macro_rules! get_bit_macro {\n           () => \n     {\n             () == 1     }\n     ;\n       }\n       macro_rules! get_bit {\n           () => {\n              verus_proof_macro_exprs!()     }\n       }\n        fn main() {}\n        verus! {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/bitvector_garbage_collection.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1088, "minimize_time_ms": 185083, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 177, "minimized_LOC": 13, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 2, "has_meaningful_spec": false, "readability_score": 0.6, "reduction_ratio": 0.07344632768361582}, "labeling": {"segments": {"exec": "use vstd::prelude::*;\n       macro_rules! get_bit_macro {\n           () => \n     {\n             () == 1     }\n     ;\n       }\n       macro_rules! get_bit {\n           () => {\n              verus_proof_macro_exprs!()     }\n       }\n        fn main() {}\n        verus! {}\n"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nenum Color {\n    White,  // 11\n    Gray,  // 10\n    Black,  // 01\n    Undefined,  // 00\n}\n\nspec fn color_view(high: bool, low: bool) -> Color {\n    if high {\n        if low {\n            Color::White\n        } else {\n            Color::Gray\n        }\n    } else {\n        if low {\n            Color::Black\n        } else {\n            Color::Undefined\n        }\n    }\n}\n\nspec fn bucket_view(bucket: u32) -> Seq<Color> {\n    Seq::new(\n        16,\n        |i: int|\n            color_view(\n                get_bit!(bucket, add(mul(i as u32, 2), 1)),\n                get_bit!(bucket, mul(i as u32, 2)),\n            ),\n    )\n}\n\n#[verifier::bit_vector]\nproof fn set_two_bit_proof(\n    bv: u32,\n    target: u32,\n    mask: u32,\n    result: u32,\n    low_loc: u32,\n    high: bool,\n    low: bool,\n)\n    requires\n        low_loc < 31,\n        target == (if high {\n            if low {\n                3u32\n            } else {\n                2u32\n            }\n        } else {\n            if low {\n                1u32\n            } else {\n                0u32\n            }\n        }) << low_loc,\n        mask == !(3u32 << low_loc),\n        result == (bv & mask) | target,\n    ensures\n        get_bit!(result, low_loc) == low,\n        get_bit!(result, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(result, loc2)\n                == get_bit!(bv, loc2),\n{\n}\n\nfn set_two_bit_exec(bv: u32, low_loc: u32, high: bool, low: bool) -> (ret: u32)\n    requires\n        low_loc < 31,\n    ensures\n        get_bit!(ret, low_loc) == low,\n        get_bit!(ret, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(ret, loc2)\n                == get_bit!(bv, loc2),\n{\n    let target: u32 = (if high {\n        if low {\n            3u32\n        } else {\n            2u32\n        }\n    } else {\n        if low {\n            1u32\n        } else {\n            0u32\n        }\n    }) << low_loc;\n    let mask: u32 = !(3u32 << low_loc);\n    let result: u32 = (bv & mask) | target;\n    proof {\n        set_two_bit_proof(bv, target, mask, result, low_loc, high, low);\n    }\n    result\n}\n\nfn set_color(bucket: u32, high: bool, low: bool, i: u32, ghost_bucket: Seq<Color>) -> (new_bucket:\n    u32)\n    requires\n        i < 16,\n        bucket_view(bucket) =~= ghost_bucket,\n    ensures\n        bucket_view(new_bucket) =~= ghost_bucket.update(i as int, color_view(high, low)),\n{\n    let new_bucket = set_two_bit_exec(bucket, 2 * i, high, low);\n    assert(color_view(high, low) == color_view(\n        get_bit!(new_bucket, add(mul(2, i), 1)),\n        get_bit!(new_bucket, mul(2, i)),\n    ));\n    new_bucket\n}\n\n#[verifier::bit_vector]\nproof fn get_color_proof(bv: u32, index: u32, v: u32)\n    requires\n        v == 3u32 & (bv >> mul(index, 2)),\n    ensures\n        v < 4u32,\n        v == 3 ==> get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 2 ==> !get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 1 ==> get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n        v == 0 ==> !get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n{\n}\n\nfn get_color(bv: u32, index: u32) -> (c: Color)\n    requires\n        index < 15,\n    ensures\n        c == color_view(get_bit!(bv, add(mul(2, index), 1)), get_bit!(bv, mul(2, index))),\n{\n    let v: u32 = 3u32 & (bv >> index * 2);\n    proof {\n        get_color_proof(bv, index, v);\n    }\n    let c = if v == 0 {\n        Color::Undefined\n    } else if v == 1 {\n        Color::Black\n    } else if v == 2 {\n        Color::Gray\n    } else {\n        Color::White\n    };\n    c\n}\n\n} // verus!\n", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n       macro_rules! get_bit_macro {\n           () => \n     {\n             () == 1     }\n     ;\n       }\n       macro_rules! get_bit {\n           () => {\n              verus_proof_macro_exprs!()     }\n       }\n        fn main() {}\n        verus! {}\n", "use vstd::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "broadcast_proof_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n    \n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n    \n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n  \n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n  \n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)\n      //   requires\n      //     p1.i % p2.modulo == 0,\n      //     v % p2.modulo == 0,\n      //     p2.modulo != 0,\n      // { }\n      assert((p1.i + v + v) % p2.modulo == 0) by {\n        super::lib::mod_add_zero(\n          p1.i as int, v as int, p2.modulo as int);\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n  \n  \n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n      \n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n      assert(a[2] == 3);\n    }\n  }\n  \n} // verus!", "minimized_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n    \n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n    \n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n  \n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n  \n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)\n      //   requires\n      //     p1.i % p2.modulo == 0,\n      //     v % p2.modulo == 0,\n      //     p2.modulo != 0,\n      // { }\n      assert((p1.i + v + v) % p2.modulo == 0) by {\n        super::lib::mod_add_zero(\n          p1.i as int, v as int, p2.modulo as int);\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n  \n  \n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n      \n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n      assert(a[2] == 3);\n    }\n  }\n  \n} // verus!", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/broadcast_proof.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1091, "minimize_time_ms": 656, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 190, "minimized_LOC": 190, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 34, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 3, "segments": {"spec": "spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n\nspec fn aligned(&self) -> bool {\n\nspec fn add(&self, v: nat) -> Self {\n\nspec fn aligned(&self) -> bool {\n\nspec fn add(&self, v: Self) -> Self {\n\nspec fn mul(&self, v: Self) -> Self {\n\n        requires\n\n        ensures\n\n      requires\n\n      ensures\n\n      //   requires\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n      requires\n\n      ensures\n\n      requires\n\n      ensures\n\n      requires\n\n      ensures", "proof": "proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n\nproof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n\nproof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n\nproof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n\nproof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n\nproof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n\nproof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n\nproof fn some_vstd_lemma()\n    {"}}}, "all_snapshots": []}
{"id": "calc_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n#[allow(unused_imports)]\nuse vstd::{calc_macro::*, prelude, seq::*, seq_lib::*};\n\nverus! {\n\nfn main() {\n}\n\nproof fn calc_example_usage() {\n    let a: Seq<u8> = seq![1u8, 2u8];\n    let b: Seq<u8> = seq![1u8];\n    let c: Seq<u8> = seq![2u8];\n    let d: Seq<u8> = seq![1u8, 2u8];\n    calc! {\n        (==)\n        a; (==) {\n            assert_seqs_equal!(a == b + c);\n        }\n        b + c; {\n            assert_seqs_equal!(b + c == d);\n        }\n        d;\n    };\n    calc! {\n        (<=)\n        (2 as int); (==) {}\n        3 - 1; {}\n        5;\n    };\n    calc! {\n        (==>)\n        (5 > 4); (==) {}\n        (4 >= 4); (<==>) {}\n        (2 > 1); (==>) {}\n        (1 > 0); {}\n        true;\n    };\n    calc! {\n        (==>)\n        false; {}\n        true;\n    };\n}\n\n} // verus!\n", "minimized_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n#[allow(unused_imports)]\nuse vstd::{calc_macro::*, prelude, seq::*, seq_lib::*};\n\nverus! {\n\nfn main() {\n}\n\nproof fn calc_example_usage() {\n    let a: Seq<u8> = seq![1u8, 2u8];\n    let b: Seq<u8> = seq![1u8];\n    let c: Seq<u8> = seq![2u8];\n    let d: Seq<u8> = seq![1u8, 2u8];\n    calc! {\n        (==)\n        a; (==) {\n            assert_seqs_equal!(a == b + c);\n        }\n        b + c; {\n            assert_seqs_equal!(b + c == d);\n        }\n        d;\n    };\n    calc! {\n        (<=)\n        (2 as int); (==) {}\n        3 - 1; {}\n        5;\n    };\n    calc! {\n        (==>)\n        (5 > 4); (==) {}\n        (4 >= 4); (<==>) {}\n        (2 > 1); (==>) {}\n        (1 > 0); {}\n        true;\n    };\n    calc! {\n        (==>)\n        false; {}\n        true;\n    };\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/calc.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 731, "minimize_time_ms": 153154, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 3, "has_meaningful_spec": true, "readability_score": 0.8999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "proof": "proof fn calc_example_usage() {"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n#[allow(unused_imports)]\nuse vstd::{calc_macro::*, prelude, seq::*, seq_lib::*};\n\nverus! {\n\nfn main() {\n}\n\nproof fn calc_example_usage() {\n    let a: Seq<u8> = seq![1u8, 2u8];\n    let b: Seq<u8> = seq![1u8];\n    let c: Seq<u8> = seq![2u8];\n    let d: Seq<u8> = seq![1u8, 2u8];\n    calc! {\n        (==)\n        a; (==) {\n            assert_seqs_equal!(a == b + c);\n        }\n        b + c; {\n            assert_seqs_equal!(b + c == d);\n        }\n        d;\n    };\n    calc! {\n        (<=)\n        (2 as int); (==) {}\n        3 - 1; {}\n        5;\n    };\n    calc! {\n        (==>)\n        (5 > 4); (==) {}\n        (4 >= 4); (<==>) {}\n        (2 > 1); (==>) {}\n        (1 > 0); {}\n        true;\n    };\n    calc! {\n        (==>)\n        false; {}\n        true;\n    };\n}\n\n} // verus!\n", "use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n", "use verus_builtin_macros::*;\nuse vstd::{};\nverus !{ fn main(); }\n"]}
{"id": "datatypes_cc0b9f7d", "original_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n        invariant\n            len(list) <= 0xffffffffffffffff,\n            n + len(iter) == len(list),\n        ensures\n            n == len(list),\n        decreases len(iter),\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n                proof {\n                    reveal_with_fuel(len, 2);\n                }\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n    assert(i == 104);\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n    assert(j == 100);\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n    assert(j == 101);\n    assert(k == 7);\n}\n\n} // verus!\n", "minimized_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n        invariant\n            len(list) <= 0xffffffffffffffff,\n            n + len(iter) == len(list),\n        ensures\n            n == len(list),\n        decreases len(iter),\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n                proof {\n                    reveal_with_fuel(len, 2);\n                }\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n    assert(i == 104);\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n    assert(j == 100);\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n    assert(j == 101);\n    assert(k == 7);\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/datatypes.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 796, "minimize_time_ms": 245485, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 102, "minimized_LOC": 102, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 14, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n\n\nfn main() {", "spec": "spec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n\n    decreases list,\n\n    requires\n\n    ensures\n\n        invariant\n\n        ensures\n\n        decreases len(iter),\n\n    requires\n\n    ensures\n\n    decreases length,", "proof": "proof {\n                    reveal_with_fuel(len, 2);\n                }"}}}, "all_snapshots": ["#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n        invariant\n            len(list) <= 0xffffffffffffffff,\n            n + len(iter) == len(list),\n        ensures\n            n == len(list),\n        decreases len(iter),\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n                proof {\n                    reveal_with_fuel(len, 2);\n                }\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n    assert(i == 104);\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n    assert(j == 100);\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n    assert(j == 101);\n    assert(k == 7);\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use vstd::{\n          modes::*, prelude::*, seq::*, *};\n             verus! {\n           fn main() ;\n           }\n", "use vstd::{*, prelude::*, *, };\nverus !{ fn main(); }\n", "use vstd:: prelude:: * ;\nverus !{ fn main(); }\n"]}
{"id": "debug_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-failures\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\n/*\nfn test_params(i: int, n: nat, u: u8) {\n    assert(n >= 5);\n}\n\nfn test_mutation(i: int, n: nat, u: u8) {\n    let mut x = 5;\n    x = x + i;\n    x = x + n;\n    x = x + u;\n    assert(x >= 5);\n}\n*/\n\nspec fn add_one(i: int) -> int {\n    i + 1\n}\n\nfn very_simple(z: int) {\n    let mut x = z;  // 1_mutation\n    assert(add_one(x) < 3);\n}\n\n// fn test_if_else(b:bool, z:int) {\n//     let mut x : int;\n//     let mut y : int = z; // 0_entry\n//     let mut f : int;\n//     x = x + y;      // 1_mutation\n//     if b {\n//         x = 2*x;    // 2_mutation\n//         y = x + 1;  // 3_mutation\n//     } else {\n//         let mut dd : int;\n//         if b {\n//             let mut ddd : int;\n//             assert(true);\n//             x = 2*x;    // 4_mutation\n//             y = x + 1;  // 5_mutation\n//         } // 6_join\n//         x = y + 1;  // 7_mutation\n//         y = 7;      // 8_mutation\n//         f = 34;    // 9_mutation\n//     } // 10_join\n//     assert(x + y > 5);\n// }\n/*\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;  // 0_entry\n    i = i + 1;           // 1_mutation\n    i = i - 1;           // 2_mutation\n\n    while i < 100 {\n        invariant([\n            10 <= i,\n            i <= 100,\n            b1 as u64 == i * 2,\n        ]);\n                      // 3_while_begin\n        assert(b1 == 5);\n        i = i + 1;    // 4_mutation\n        b1 = b1 + 2;  // 5_mutation\n        b2 = b2 + 1;  // 6_mutation\n    } // 5_while_end\n\n    assert(true);   // 7_while_end\n}\n*/\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs expect-failures\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\n/*\nfn test_params(i: int, n: nat, u: u8) {\n    assert(n >= 5);\n}\n\nfn test_mutation(i: int, n: nat, u: u8) {\n    let mut x = 5;\n    x = x + i;\n    x = x + n;\n    x = x + u;\n    assert(x >= 5);\n}\n*/\n\nspec fn add_one(i: int) -> int {\n    i + 1\n}\n\nfn very_simple(z: int) {\n    let mut x = z;  // 1_mutation\n    assert(add_one(x) < 3);\n}\n\n// fn test_if_else(b:bool, z:int) {\n//     let mut x : int;\n//     let mut y : int = z; // 0_entry\n//     let mut f : int;\n//     x = x + y;      // 1_mutation\n//     if b {\n//         x = 2*x;    // 2_mutation\n//         y = x + 1;  // 3_mutation\n//     } else {\n//         let mut dd : int;\n//         if b {\n//             let mut ddd : int;\n//             assert(true);\n//             x = 2*x;    // 4_mutation\n//             y = x + 1;  // 5_mutation\n//         } // 6_join\n//         x = y + 1;  // 7_mutation\n//         y = 7;      // 8_mutation\n//         f = 34;    // 9_mutation\n//     } // 10_join\n//     assert(x + y > 5);\n// }\n/*\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;  // 0_entry\n    i = i + 1;           // 1_mutation\n    i = i - 1;           // 2_mutation\n\n    while i < 100 {\n        invariant([\n            10 <= i,\n            i <= 100,\n            b1 as u64 == i * 2,\n        ]);\n                      // 3_while_begin\n        assert(b1 == 5);\n        i = i + 1;    // 4_mutation\n        b1 = b1 + 2;  // 5_mutation\n        b2 = b2 + 1;  // 6_mutation\n    } // 5_while_end\n\n    assert(true);   // 7_while_end\n}\n*/\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/debug.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 664, "verus_errors": [{"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpqtbt9sou", "lines": [30, 30], "label": "assertion failed", "text": [{"text": "    assert(add_one(x) < 3);", "highlight_start": 12, "highlight_end": 26}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 80, "minimized_LOC": 80, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 4, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_invariant": true, "segments": {"exec": "\nfn main() {\n\n\nfn test_params(i: int, n: nat, u: u8) {\n\n\nfn test_mutation(i: int, n: nat, u: u8) {\n\n fn test_if_else(b:bool, z:int) {\n\n\nfn test_loop() {", "spec": "spec fn add_one(i: int) -> int {\n\n        invariant(["}}}, "all_snapshots": []}
{"id": "debug_expand_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-failures\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external]\nfn main() {\n}\n\n//example: simple conjunt\nproof fn test_expansion_very_easy() {\n    let x: int = 5;\n    assert((x >= 0) && (x != 5));\n    //                  ^^^^^^^\n}\n\n//example: simple function inline\nspec fn is_good_integer(z: int) -> bool {\n    z >= 0 && z != 5\n    //        ^^^^^^\n\n}\n\nproof fn test_expansion_easy() {\n    let x = 5;\n    assert(is_good_integer(x));\n}\n\n//example: simple `match` inline\nspec fn is_good_opt(opt: Option<int>) -> bool {\n    match opt {\n        Option::Some(k) => k > 10,\n        Option::None => true,\n    }\n}\n\nproof fn test_expansion_match() {\n    let x: Option<int> = Option::Some(5);\n    let y: Option<int> = Option::Some(4);\n    assert(is_good_opt(x));\n}\n\n//example: 3-level failure\n#[derive(PartialEq, Eq)]\npub enum Message {\n    Quit(bool),\n    Move { x: i32, y: i32 },\n    Write(bool),\n}\n\n#[verusfmt::skip]\nspec fn is_good_integer_3(x: int) -> bool {\n    x >= 0 && x != 5\n//  ^^^^^^\n\n}\n\nspec fn is_good_message(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_3((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nspec fn is_good(msg: Message) -> bool {\n    is_good_message(msg)\n    //^^^^^^^^^^^^^^^^^^\n\n}\n\nproof fn test_expansion_multiple_call() {\n    let x = Message::Move { x: 5, y: 6 };\n    assert(is_good(x));\n    //^^^^^^ ^^^^^^^^^\n}\n\n// example: boolean OR, negation\nspec fn is_good_integer_5(x: int) -> bool {\n    !(x < 0 || !(x != 5))\n    //           ^^^^^^\n\n}\n\nproof fn test_expansion_negate() {\n    assert(is_good_integer_5(5));\n    //^^^^^^ ^^^^^^^^^^^^^^^^^^\n}\n\n//example: requires\n#[verusfmt::skip]\nspec fn is_good_integer_7(x: int) -> bool {\n    x >= 0 && x != 5\n//  ^^^^^^\n}\n\nspec fn is_good_message_7(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_7((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_require_failure(m: Message, b: bool) -> (good_int: int)\n    requires\n        b,\n        is_good_message_7(m),\n//      ^^^^^^^^^^^^^^^^^^^^\n\n    ensures\n        is_good_integer_7(good_int),\n{\n    return 0;\n}\n\nproof fn test_7(x: int) {\n    let x = Message::Move { x: 0, y: 5 };\n    test_require_failure(x, true);\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    assert(false);\n}\n\n//example: ensures\nspec fn is_good_integer_8(x: int) -> bool {\n    x >= 0 && x != 5\n    //        ^^^^^^\n\n}\n\nspec fn is_good_message_8(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_8((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_ensures_failure(b: bool) -> (good_msg: Message)\n    ensures\n        is_good_message_8(good_msg),\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n{\n    let mut ret = Message::Write(true);\n    if !b {\n        ret = Message::Move { x: 10, y: 5 };\n    }\n    ret\n}\n\n// example: opaque/reveal\n#[verifier::opaque]\nspec fn is_good_integer_9(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n    x >= 0 && x != 5\n}\n\n#[verifier::opaque]\nspec fn is_good_message_9(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_9((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_opaque(b: bool) {\n    let good_msg = Message::Move { x: 0, y: 0 };\n    reveal(is_good_message_9);\n    assert(is_good_message_9(good_msg));\n    //^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n}\n\n// example: `reveal` does not flow\n#[verifier::opaque]\nspec fn is_good_message_10(msg: Message) -> bool {\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_9((x as int) - (y as int)),\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_reveal(b: bool) {\n    let good_msg = Message::Move { x: 0, y: 0 };\n    if b {\n        reveal(is_good_message_10);\n    } else {\n        assert_by(\n            true,\n            {\n                reveal(is_good_message_10);\n            },\n        );\n        assert(is_good_message_10(good_msg));\n        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    }\n}\n\n//example:`hide`\nspec fn is_good_integer_11(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n    x >= 0 && x != 5\n}\n\nproof fn test_hide(b: bool) {\n    hide(is_good_integer_11);\n    let i = 0;\n    assert(is_good_integer_11(i));\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^\n}\n\n//example: publish\nmod M3 {\n    use verus_builtin::*;\n\n    pub closed spec fn is_good_integer(\n        x: int,\n    ) -> bool\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is closed at the module boundary\n     {\n        x >= 0 && x != 5\n    }\n\n}\n\nmod M4 {\n    #[allow(unused_imports)]\n\n\n    use crate::M3;\n\n    proof fn test_publish(b: bool) {\n        let i = 0;\n        assert(M3::is_good_integer(i));\n        //^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^\n    }\n\n}\n\n// example: reveal at ensures\n#[verifier::opaque]\nspec fn is_good_integer_13(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n    x >= 0 && x != 5\n}\n\n#[verifier::opaque]\nspec fn is_good_message_13(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_13((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_reveal_at_ensures(b: bool) -> (good_msg: Message)\n    ensures\n        is_good_message_13(good_msg),\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n{\n    let good_msg = Message::Move { x: 0, y: 0 };\n    reveal(is_good_message_13);\n    good_msg\n}\n\n// example: recursive function\nspec fn is_even(\n    p: nat,\n) -> bool\n//   ------------------------- Note: this function is recursive with fuel 10\n {\n    decreases(p);\n    if p == 0 {\n        true\n    } else {\n        !is_even((p - 1) as nat)\n    }\n}\n\nproof fn test_rec() {\n    reveal_with_fuel(is_even, 10);\n    assert(is_even(1));\n    //^^^^^^ ^^^^^^^^^^\n}\n\nspec fn are_equal(x: int, y: int, z: int, w: int) -> bool {\n    #[verifier(custom_err(\"integers fail to be equal\"))]\n    (x == y) && #[verifier(custom_err(\"this ain't right. probably.\"))]\n    (z <= w)\n}\n\nproof fn proof_test_are_equal(x: int, y: int, z: int, w: int) {\n    assert(are_equal(x, y, z, w));\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs expect-failures\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external]\nfn main() {\n}\n\n//example: simple conjunt\nproof fn test_expansion_very_easy() {\n    let x: int = 5;\n    assert((x >= 0) && (x != 5));\n    //                  ^^^^^^^\n}\n\n//example: simple function inline\nspec fn is_good_integer(z: int) -> bool {\n    z >= 0 && z != 5\n    //        ^^^^^^\n\n}\n\nproof fn test_expansion_easy() {\n    let x = 5;\n    assert(is_good_integer(x));\n}\n\n//example: simple `match` inline\nspec fn is_good_opt(opt: Option<int>) -> bool {\n    match opt {\n        Option::Some(k) => k > 10,\n        Option::None => true,\n    }\n}\n\nproof fn test_expansion_match() {\n    let x: Option<int> = Option::Some(5);\n    let y: Option<int> = Option::Some(4);\n    assert(is_good_opt(x));\n}\n\n//example: 3-level failure\n#[derive(PartialEq, Eq)]\npub enum Message {\n    Quit(bool),\n    Move { x: i32, y: i32 },\n    Write(bool),\n}\n\n#[verusfmt::skip]\nspec fn is_good_integer_3(x: int) -> bool {\n    x >= 0 && x != 5\n//  ^^^^^^\n\n}\n\nspec fn is_good_message(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_3((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nspec fn is_good(msg: Message) -> bool {\n    is_good_message(msg)\n    //^^^^^^^^^^^^^^^^^^\n\n}\n\nproof fn test_expansion_multiple_call() {\n    let x = Message::Move { x: 5, y: 6 };\n    assert(is_good(x));\n    //^^^^^^ ^^^^^^^^^\n}\n\n// example: boolean OR, negation\nspec fn is_good_integer_5(x: int) -> bool {\n    !(x < 0 || !(x != 5))\n    //           ^^^^^^\n\n}\n\nproof fn test_expansion_negate() {\n    assert(is_good_integer_5(5));\n    //^^^^^^ ^^^^^^^^^^^^^^^^^^\n}\n\n//example: requires\n#[verusfmt::skip]\nspec fn is_good_integer_7(x: int) -> bool {\n    x >= 0 && x != 5\n//  ^^^^^^\n}\n\nspec fn is_good_message_7(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_7((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_require_failure(m: Message, b: bool) -> (good_int: int)\n    requires\n        b,\n        is_good_message_7(m),\n//      ^^^^^^^^^^^^^^^^^^^^\n\n    ensures\n        is_good_integer_7(good_int),\n{\n    return 0;\n}\n\nproof fn test_7(x: int) {\n    let x = Message::Move { x: 0, y: 5 };\n    test_require_failure(x, true);\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    assert(false);\n}\n\n//example: ensures\nspec fn is_good_integer_8(x: int) -> bool {\n    x >= 0 && x != 5\n    //        ^^^^^^\n\n}\n\nspec fn is_good_message_8(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_8((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_ensures_failure(b: bool) -> (good_msg: Message)\n    ensures\n        is_good_message_8(good_msg),\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n{\n    let mut ret = Message::Write(true);\n    if !b {\n        ret = Message::Move { x: 10, y: 5 };\n    }\n    ret\n}\n\n// example: opaque/reveal\n#[verifier::opaque]\nspec fn is_good_integer_9(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n    x >= 0 && x != 5\n}\n\n#[verifier::opaque]\nspec fn is_good_message_9(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_9((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_opaque(b: bool) {\n    let good_msg = Message::Move { x: 0, y: 0 };\n    reveal(is_good_message_9);\n    assert(is_good_message_9(good_msg));\n    //^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n}\n\n// example: `reveal` does not flow\n#[verifier::opaque]\nspec fn is_good_message_10(msg: Message) -> bool {\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_9((x as int) - (y as int)),\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_reveal(b: bool) {\n    let good_msg = Message::Move { x: 0, y: 0 };\n    if b {\n        reveal(is_good_message_10);\n    } else {\n        assert_by(\n            true,\n            {\n                reveal(is_good_message_10);\n            },\n        );\n        assert(is_good_message_10(good_msg));\n        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    }\n}\n\n//example:`hide`\nspec fn is_good_integer_11(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n    x >= 0 && x != 5\n}\n\nproof fn test_hide(b: bool) {\n    hide(is_good_integer_11);\n    let i = 0;\n    assert(is_good_integer_11(i));\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^\n}\n\n//example: publish\nmod M3 {\n    use verus_builtin::*;\n\n    pub closed spec fn is_good_integer(\n        x: int,\n    ) -> bool\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is closed at the module boundary\n     {\n        x >= 0 && x != 5\n    }\n\n}\n\nmod M4 {\n    #[allow(unused_imports)]\n\n\n    use crate::M3;\n\n    proof fn test_publish(b: bool) {\n        let i = 0;\n        assert(M3::is_good_integer(i));\n        //^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^\n    }\n\n}\n\n// example: reveal at ensures\n#[verifier::opaque]\nspec fn is_good_integer_13(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n    x >= 0 && x != 5\n}\n\n#[verifier::opaque]\nspec fn is_good_message_13(msg: Message) -> bool {\n    match msg {\n        Message::Quit(b) => b,\n        Message::Move { x, y } => is_good_integer_13((x as int) - (y as int)),\n        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        Message::Write(b) => b,\n    }\n}\n\nproof fn test_reveal_at_ensures(b: bool) -> (good_msg: Message)\n    ensures\n        is_good_message_13(good_msg),\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n{\n    let good_msg = Message::Move { x: 0, y: 0 };\n    reveal(is_good_message_13);\n    good_msg\n}\n\n// example: recursive function\nspec fn is_even(\n    p: nat,\n) -> bool\n//   ------------------------- Note: this function is recursive with fuel 10\n {\n    decreases(p);\n    if p == 0 {\n        true\n    } else {\n        !is_even((p - 1) as nat)\n    }\n}\n\nproof fn test_rec() {\n    reveal_with_fuel(is_even, 10);\n    assert(is_even(1));\n    //^^^^^^ ^^^^^^^^^^\n}\n\nspec fn are_equal(x: int, y: int, z: int, w: int) -> bool {\n    #[verifier(custom_err(\"integers fail to be equal\"))]\n    (x == y) && #[verifier(custom_err(\"this ain't right. probably.\"))]\n    (z <= w)\n}\n\nproof fn proof_test_are_equal(x: int, y: int, z: int, w: int) {\n    assert(are_equal(x, y, z, w));\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/debug_expand.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "precondition", "verify_time_ms": 767, "verus_errors": [{"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [251, 251], "label": "assertion failed", "text": [{"text": "        assert(M3::is_good_integer(i));", "highlight_start": 16, "highlight_end": 38}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [17, 17], "label": "assertion failed", "text": [{"text": "    assert((x >= 0) && (x != 5));", "highlight_start": 12, "highlight_end": 32}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [30, 30], "label": "assertion failed", "text": [{"text": "    assert(is_good_integer(x));", "highlight_start": 12, "highlight_end": 30}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [44, 44], "label": "assertion failed", "text": [{"text": "    assert(is_good_opt(x));", "highlight_start": 12, "highlight_end": 26}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [79, 79], "label": "assertion failed", "text": [{"text": "    assert(is_good(x));", "highlight_start": 12, "highlight_end": 22}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [91, 91], "label": "assertion failed", "text": [{"text": "    assert(is_good_integer_5(5));", "highlight_start": 12, "highlight_end": 32}]}]}, {"error_type": "PreCondFail", "error_text": "precondition not satisfied (failed precondition)", "message": "VerusErrorType.PreCondFail: precondition not satisfied (failed precondition)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [114, 114], "label": "failed precondition", "text": [{"text": "        is_good_message_7(m),", "highlight_start": 9, "highlight_end": 29}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [125, 125], "label": null, "text": [{"text": "    test_require_failure(x, true);", "highlight_start": 5, "highlight_end": 34}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [127, 127], "label": "assertion failed", "text": [{"text": "    assert(false);", "highlight_start": 12, "highlight_end": 17}]}]}, {"error_type": "PostCondFail", "error_text": "postcondition not satisfied (at the end of the function body; failed this postcondition)", "message": "VerusErrorType.PostCondFail: postcondition not satisfied (at the end of the function body; failed this postcondition)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [156, 156], "label": "at the end of the function body", "text": [{"text": "    ret", "highlight_start": 5, "highlight_end": 8}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [148, 148], "label": "failed this postcondition", "text": [{"text": "        is_good_message_8(good_msg),", "highlight_start": 9, "highlight_end": 36}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [182, 182], "label": "assertion failed", "text": [{"text": "    assert(is_good_message_9(good_msg));", "highlight_start": 12, "highlight_end": 39}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [208, 208], "label": "assertion failed", "text": [{"text": "        assert(is_good_message_10(good_msg));", "highlight_start": 16, "highlight_end": 44}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [225, 225], "label": "assertion failed", "text": [{"text": "    assert(is_good_integer_11(i));", "highlight_start": 12, "highlight_end": 33}]}]}, {"error_type": "PostCondFail", "error_text": "postcondition not satisfied (at the end of the function body; failed this postcondition)", "message": "VerusErrorType.PostCondFail: postcondition not satisfied (at the end of the function body; failed this postcondition)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [285, 285], "label": "at the end of the function body", "text": [{"text": "    good_msg", "highlight_start": 5, "highlight_end": 13}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [279, 279], "label": "failed this postcondition", "text": [{"text": "        is_good_message_13(good_msg),", "highlight_start": 9, "highlight_end": 37}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [304, 304], "label": "assertion failed", "text": [{"text": "    assert(is_even(1));", "highlight_start": 12, "highlight_end": 22}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmph4iohhgs", "lines": [315, 315], "label": "assertion failed", "text": [{"text": "    assert(are_equal(x, y, z, w));", "highlight_start": 12, "highlight_end": 33}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 318, "minimized_LOC": 318, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::prelude::"], "complexity_verus_tokens": 57, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_good_integer(z: int) -> bool {\n\nspec fn is_good_opt(opt: Option<int>) -> bool {\n\nspec fn is_good_integer_3(x: int) -> bool {\n\nspec fn is_good_message(msg: Message) -> bool {\n\nspec fn is_good(msg: Message) -> bool {\n\nspec fn is_good_integer_5(x: int) -> bool {\n\nspec fn is_good_integer_7(x: int) -> bool {\n\nspec fn is_good_message_7(msg: Message) -> bool {\n\nspec fn is_good_integer_8(x: int) -> bool {\n\nspec fn is_good_message_8(msg: Message) -> bool {\n\nspec fn is_good_integer_9(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n\nspec fn is_good_message_9(msg: Message) -> bool {\n\nspec fn is_good_message_10(msg: Message) -> bool {\n\nspec fn is_good_integer_11(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n\nspec fn is_good_integer(\n        x: int,\n    ) -> bool\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is closed at the module boundary\n     {\n\nspec fn is_good_integer_13(\n    x: int,\n) -> bool\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque\n {\n\nspec fn is_good_message_13(msg: Message) -> bool {\n\nspec fn is_even(\n    p: nat,\n) -> bool\n//   ------------------------- Note: this function is recursive with fuel 10\n {\n\nspec fn are_equal(x: int, y: int, z: int, w: int) -> bool {\n\n//example: requires\n\n    requires\n\n    ensures\n\n//example: ensures\n\n    ensures\n\n// example: reveal at ensures\n\n    ensures\n\n    decreases(p);", "proof": "proof fn test_expansion_very_easy() {\n\nproof fn test_expansion_easy() {\n\nproof fn test_expansion_match() {\n\nproof fn test_expansion_multiple_call() {\n\nproof fn test_expansion_negate() {\n\nproof fn test_require_failure(m: Message, b: bool) -> (good_int: int)\n    requires\n        b,\n        is_good_message_7(m),\n//      ^^^^^^^^^^^^^^^^^^^^\n\n    ensures\n        is_good_integer_7(good_int),\n{\n\nproof fn test_7(x: int) {\n\nproof fn test_ensures_failure(b: bool) -> (good_msg: Message)\n    ensures\n        is_good_message_8(good_msg),\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n{\n\nproof fn test_opaque(b: bool) {\n\nproof fn test_reveal(b: bool) {\n\nproof fn test_hide(b: bool) {\n\nproof fn test_publish(b: bool) {\n\nproof fn test_reveal_at_ensures(b: bool) -> (good_msg: Message)\n    ensures\n        is_good_message_13(good_msg),\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n{\n\nproof fn test_rec() {\n\nproof fn proof_test_are_equal(x: int, y: int, z: int, w: int) {"}}}, "all_snapshots": []}
{"id": "even_cell_cc0b9f7d", "original_code": "use vstd::prelude::*;\nuse vstd::invariant::*;\nuse vstd::cell::*;\n\nverus!{\n\nghost struct EvenCell { }\n\nimpl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {\n        points_to.id() == cell_id\n          && (match points_to.mem_contents() {\n              MemContents::Uninit => false,\n              MemContents::Init(x) => x % 2 == 0,\n          })\n    }\n}\n\nfn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)\n    requires inv.constant() == cell.id(),\n{\n    open_local_invariant!(inv => points_to => {\n        assert(points_to.is_init());\n        assert(points_to.value() % 2 == 0);\n\n        let x = cell.take(Tracked(&mut points_to));\n        assert(x % 2 == 0);\n\n        // Add 2 (wrap around if necessary)\n        let x_plus_2 = if x == 254 { 0 } else { x + 2 };\n\n        cell.put(Tracked(&mut points_to), x_plus_2);\n\n        assert(points_to.is_init());\n        assert(points_to.value() % 2 == 0);\n    });\n}\n\nfn main() {\n    let (cell, Tracked(points_to)) = PCell::new(4);\n\n    let tracked inv = LocalInvariant::new(\n        cell.id(),\n        points_to,\n        1337 /* arbitrary namespace */);\n\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n}\n\n}\n", "minimized_code": "use vstd::prelude::*;\n        use vstd::invariant::*;\n        use vstd::cell::*;\n        verus!{\n       ghost struct EvenCell ;\n       impl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n          open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool ;\n      }\n       fn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)     requires inv.constant() == cell.id(), ;\n       fn main() ;\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/even_cell.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 725, "minimize_time_ms": 216183, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 11, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::invariant::", "vstd::cell::"], "complexity_verus_tokens": 5, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.21153846153846154}, "labeling": {"segments": {"exec": "use vstd::prelude::*;\n        use vstd::invariant::*;\n        use vstd::cell::*;\n        verus!{\n       ghost struct EvenCell ;\n       impl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n          open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool ;\n      }\n       fn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)     requires inv.constant() == cell.id(), ;\n       fn main() ;\n       }\n", "spec": "        use vstd::invariant::*;\n\n       fn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)     requires inv.constant() == cell.id(), ;"}}}, "all_snapshots": ["use vstd::prelude::*;\nuse vstd::invariant::*;\nuse vstd::cell::*;\n\nverus!{\n\nghost struct EvenCell { }\n\nimpl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {\n        points_to.id() == cell_id\n          && (match points_to.mem_contents() {\n              MemContents::Uninit => false,\n              MemContents::Init(x) => x % 2 == 0,\n          })\n    }\n}\n\nfn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)\n    requires inv.constant() == cell.id(),\n{\n    open_local_invariant!(inv => points_to => {\n        assert(points_to.is_init());\n        assert(points_to.value() % 2 == 0);\n\n        let x = cell.take(Tracked(&mut points_to));\n        assert(x % 2 == 0);\n\n        // Add 2 (wrap around if necessary)\n        let x_plus_2 = if x == 254 { 0 } else { x + 2 };\n\n        cell.put(Tracked(&mut points_to), x_plus_2);\n\n        assert(points_to.is_init());\n        assert(points_to.value() % 2 == 0);\n    });\n}\n\nfn main() {\n    let (cell, Tracked(points_to)) = PCell::new(4);\n\n    let tracked inv = LocalInvariant::new(\n        cell.id(),\n        points_to,\n        1337 /* arbitrary namespace */);\n\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n}\n\n}\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\n        use vstd::invariant::*;\n        use vstd::cell::*;\n        verus!{\n       ghost struct EvenCell ;\n       impl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n          open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool ;\n      }\n       fn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)     requires inv.constant() == cell.id(), ;\n       fn main() ;\n       }\n", "use vstd::prelude::*;\n               verus!{\n             fn main() ;\n             }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "exec_termination_example_cc0b9f7d", "original_code": "use vstd::prelude::*;\n\nverus! {\n    // basic recursive expression\n    fn exec_basic_recursive_expr(i: u64) -> (r: u64)\n        ensures r == i\n        decreases i\n    {\n        if i == 0 { 0 } else { 1 + exec_basic_recursive_expr(i - 1) }\n    }\n\n    // basic recursive statement\n    fn exec_basic_recursive_stmt(i: u64)\n        decreases i \n    {\n        if i != 0 {\n            exec_basic_recursive_stmt(i - 1);\n        }\n    }\n\n    // basic while loop\n    fn exec_basic_while_loop() {\n        let mut i = 0;\n        while i < 10\n            invariant i <= 10\n            decreases 10 - i\n        {\n            i = i + 1;\n        }\n        assert(i == 10);\n    }\n\n    // nested while \n    fn exec_nested_while_loop() {\n        let mut i = 0;\n        let mut j = 0;\n        while i < 10 \n            invariant \n                i <= 10,\n                j <= 5\n            decreases 10 - i\n            {\n                i = i + 1;\n                while j < 5\n                    invariant j <= 5\n                    decreases 5 - j\n                    {\n                        j = j + 1;\n                    }\n            }\n    }\n\n    // infinite loop with break\n    fn exec_basic_loop_break() {\n        let mut i: i8 = 0;\n        loop\n            invariant_except_break i <= 9\n            invariant 0 <= i <= 10\n            ensures 1 <= i\n            decreases 10 - i\n        {\n            i = i + 1;\n            if i == 10 {\n                break;\n            }\n        }\n    }\n\n    // for loop \n    fn exec_for_loop() {\n        let mut n: u64 = 0;\n        for x in iter: 0..10\n            invariant n == iter.cur * 3,\n            // You can write a `decreases` if you want, but it's not needed\n            // because Verus inserts a decreases automatically for `for` loops:\n            //   decreases 10 - iter.cur,\n        {\n            n += 3;\n        }\n    }\n\n    fn exec_for_loop_2() {\n        let mut n: u64 = 0;\n        let mut end = 10;\n        for x in iter: 0..end \n            invariant \n                n == iter.cur * 3,\n                end == 10,\n            // You can write a `decreases` if you want, but it's not needed\n            // because Verus inserts a decreases automatically for `for` loops:\n            //   decreases end - iter.cur,\n        {\n            n += 3;\n        }\n    }\n\n    // basic recursive expression + basic while loop\n    #[verifier::loop_isolation(false)]\n    fn exec_basic_recursive_stmt_basic_while_loop(mut i: u64)\n        requires i <= 10,\n        decreases i,\n    {\n        let ghost initial_i = i;\n        while 0 < i && i <= 10\n            invariant\n                0 <= i <= 10,\n                i <= initial_i,\n            decreases i,\n        {\n            exec_basic_recursive_stmt_basic_while_loop(i - 1);\n            i -= 1;\n        }\n    }\n}", "minimized_code": "use vstd::prelude::*;\n\nverus! {\n    // basic recursive expression\n    fn exec_basic_recursive_expr(i: u64) -> (r: u64)\n        ensures r == i\n        decreases i\n    {\n        if i == 0 { 0 } else { 1 + exec_basic_recursive_expr(i - 1) }\n    }\n\n    // basic recursive statement\n    fn exec_basic_recursive_stmt(i: u64)\n        decreases i \n    {\n        if i != 0 {\n            exec_basic_recursive_stmt(i - 1);\n        }\n    }\n\n    // basic while loop\n    fn exec_basic_while_loop() {\n        let mut i = 0;\n        while i < 10\n            invariant i <= 10\n            decreases 10 - i\n        {\n            i = i + 1;\n        }\n        assert(i == 10);\n    }\n\n    // nested while \n    fn exec_nested_while_loop() {\n        let mut i = 0;\n        let mut j = 0;\n        while i < 10 \n            invariant \n                i <= 10,\n                j <= 5\n            decreases 10 - i\n            {\n                i = i + 1;\n                while j < 5\n                    invariant j <= 5\n                    decreases 5 - j\n                    {\n                        j = j + 1;\n                    }\n            }\n    }\n\n    // infinite loop with break\n    fn exec_basic_loop_break() {\n        let mut i: i8 = 0;\n        loop\n            invariant_except_break i <= 9\n            invariant 0 <= i <= 10\n            ensures 1 <= i\n            decreases 10 - i\n        {\n            i = i + 1;\n            if i == 10 {\n                break;\n            }\n        }\n    }\n\n    // for loop \n    fn exec_for_loop() {\n        let mut n: u64 = 0;\n        for x in iter: 0..10\n            invariant n == iter.cur * 3,\n            // You can write a `decreases` if you want, but it's not needed\n            // because Verus inserts a decreases automatically for `for` loops:\n            //   decreases 10 - iter.cur,\n        {\n            n += 3;\n        }\n    }\n\n    fn exec_for_loop_2() {\n        let mut n: u64 = 0;\n        let mut end = 10;\n        for x in iter: 0..end \n            invariant \n                n == iter.cur * 3,\n                end == 10,\n            // You can write a `decreases` if you want, but it's not needed\n            // because Verus inserts a decreases automatically for `for` loops:\n            //   decreases end - iter.cur,\n        {\n            n += 3;\n        }\n    }\n\n    // basic recursive expression + basic while loop\n    #[verifier::loop_isolation(false)]\n    fn exec_basic_recursive_stmt_basic_while_loop(mut i: u64)\n        requires i <= 10,\n        decreases i,\n    {\n        let ghost initial_i = i;\n        while 0 < i && i <= 10\n            invariant\n                0 <= i <= 10,\n                i <= initial_i,\n            decreases i,\n        {\n            exec_basic_recursive_stmt_basic_while_loop(i - 1);\n            i -= 1;\n        }\n    }\n}", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/exec_termination_example.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 931, "minimize_time_ms": 559, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 114, "minimized_LOC": 114, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 38, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": " fn exec_basic_recursive_expr(i: u64) -> (r: u64)\n        ensures r == i\n        decreases i\n    {\n\n fn exec_basic_recursive_stmt(i: u64)\n        decreases i \n    {\n\n fn exec_basic_while_loop() {\n\n fn exec_nested_while_loop() {\n\n fn exec_basic_loop_break() {\n\n fn exec_for_loop() {\n\n fn exec_for_loop_2() {\n\n fn exec_basic_recursive_stmt_basic_while_loop(mut i: u64)\n        requires i <= 10,\n        decreases i,\n    {", "spec": "        ensures r == i\n\n        decreases i\n\n        decreases i \n\n            invariant i <= 10\n\n            decreases 10 - i\n\n            invariant \n\n            decreases 10 - i\n\n                    invariant j <= 5\n\n                    decreases 5 - j\n\n            invariant 0 <= i <= 10\n\n            ensures 1 <= i\n\n            decreases 10 - i\n\n            invariant n == iter.cur * 3,\n\n            // You can write a `decreases` if you want, but it's not needed\n\n            // because Verus inserts a decreases automatically for `for` loops:\n\n            //   decreases 10 - iter.cur,\n\n            invariant \n\n            // You can write a `decreases` if you want, but it's not needed\n\n            // because Verus inserts a decreases automatically for `for` loops:\n\n            //   decreases end - iter.cur,\n\n        requires i <= 10,\n\n        decreases i,\n\n            invariant\n\n            decreases i,"}}}, "all_snapshots": []}
{"id": "hash_table_entry_cc0b9f7d", "original_code": "use vstd::prelude::*;\nuse vstd::std_specs::hash::*;\n\nuse core::borrow::Borrow;\nuse std::collections::hash_map::*;\nuse std::hash::*;\n\n// Examples of using the HashMap::entry function\n// https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry\n\nverus!{\n\n// Specs for OccupiedEntry, VacantEntry, and the Entry enum\n\n#[verifier::reject_recursive_types_in_ground_variants(K)]\n#[verifier::reject_recursive_types_in_ground_variants(V)]\n#[verifier::external_body]\n#[verifier::external_type_specification]\npub struct ExOccupiedEntry<'a, K: 'a, V: 'a>(OccupiedEntry<'a, K, V>);\n\n#[verifier::reject_recursive_types_in_ground_variants(K)]\n#[verifier::accept_recursive_types(V)]\n#[verifier::external_body]\n#[verifier::external_type_specification]\npub struct ExVacantEntry<'a, K: 'a, V: 'a>(VacantEntry<'a, K, V>);\n\n#[verifier::external_type_specification]\npub struct ExEntry<'a, K: 'a, V: 'a>(Entry<'a, K, V>);\n\npub trait OccupiedEntrySpecFns<K, V> : Sized {\n    spec fn key(self) -> K;\n    spec fn value(self) -> V;\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> OccupiedEntrySpecFns<K, V> for OccupiedEntry<'a, K, V> {\n    uninterp spec fn key(self) -> K;\n    uninterp spec fn value(self) -> V;\n    #[verifier::prophetic]\n    uninterp spec fn future_value(self) -> Option<V>;\n}\n\npub trait VacantEntrySpecFns<K, V> : Sized {\n    spec fn key(self) -> K;\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> VacantEntrySpecFns<K, V> for VacantEntry<'a, K, V> {\n    uninterp spec fn key(self) -> K;\n    #[verifier::prophetic]\n    uninterp spec fn future_value(self) -> Option<V>;\n}\n\npub trait EntrySpecFns<K, V> : Sized {\n    spec fn key(self) -> K;\n    spec fn value(self) -> Option<V>;\n\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> EntrySpecFns<K, V> for Entry<'a, K, V> {\n    open spec fn key(self) -> K {\n        match self {\n            Entry::Occupied(occupied_entry) => occupied_entry.key(),\n            Entry::Vacant(vacant_entry) => vacant_entry.key(),\n        }\n    }\n\n    open spec fn value(self) -> Option<V> {\n        match self {\n            Entry::Occupied(occupied_entry) => Some(occupied_entry.value()),\n            Entry::Vacant(vacant_entry) => None,\n        }\n    }\n\n    #[verifier::prophetic]\n    open spec fn future_value(self) -> Option<V> {\n        match self {\n            Entry::Occupied(occupied_entry) => occupied_entry.future_value(),\n            Entry::Vacant(vacant_entry) => vacant_entry.future_value(),\n        }\n    }\n}\n\npub broadcast axiom fn occupied_entry_has_resolved<K, V>(entry: OccupiedEntry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == Some(entry.value());\n\npub broadcast axiom fn vacant_entry_has_resolved<K, V>(entry: VacantEntry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == None::<V>;\n\npub broadcast proof fn entry_has_resolved<K, V>(entry: Entry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == entry.value()\n{\n    broadcast use occupied_entry_has_resolved;\n    broadcast use vacant_entry_has_resolved;\n}\n\npub assume_specification<\n    'a,\n    Key: Hash + Eq,\n    Value,\n    S: BuildHasher,\n>[ HashMap::<Key, Value, S>::entry ](m: &'a mut HashMap<Key, Value, S>, key: Key)\n  -> (entry: Entry<'a, Key, Value>)\nensures\n    obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> (\n            entry.key() == key\n         && entry.value() == mut_ref_current(m)@.get(key)\n         && mut_ref_future(m)@ == (match entry.future_value() {\n            Some(value) => mut_ref_current(m)@.insert(key, value),\n            None => mut_ref_current(m)@.remove(key),\n         })\n    );\n\npub assume_specification<'a, K, V> [ Entry::or_insert ]\n    (entry: Entry::<'a, K, V>, default: V) -> (value: &'a mut V)\nensures\n    mut_ref_current(value) == (match entry.value() {\n        Some(v) => v,\n        None => default\n    }),\n    entry.future_value() == Some(mut_ref_future(value));\n\npub assume_specification<'a, K, V> [ OccupiedEntry::remove_entry ]\n    (entry: OccupiedEntry::<'a, K, V>) -> (kv: (Key, Value))\nensures\n    entry.future_value() == None,\nreturns\n    (entry.key(), entry.value())\n\n\nfn main() {\n    broadcast use entry_has_resolved;\n\n    let mut m = HashMap::<u64, u64>::new();\n\n    // Use entry API to insert to the matp\n\n    let entry = m.entry(5);\n    assert(entry.key() == 5 && entry.value() === None);\n\n    let value_ref = entry.or_insert(20);\n    assert(*value_ref == 20);\n\n    *value_ref = 40;\n\n    assert(m@.dom().contains(5) && m@[5] == 40);\n\n    // Use entry API to remove from the map\n\n    let entry = m.entry(5);\n    match entry {\n        Entry::OccupiedEntry(occupied_entry) => {\n            let (k, v) == occupied_entry.remove_entry();\n            assert(k == 5);\n            assert(v == 40);\n        }\n        Entry::VacantEntry(_) => {\n            assert(false);\n        }\n    }\n\n    assert(!m@.dom().contains(5));\n}\n\n}\n\n", "minimized_code": "use vstd::prelude::*;\nuse vstd::std_specs::hash::*;\n\nuse core::borrow::Borrow;\nuse std::collections::hash_map::*;\nuse std::hash::*;\n\n// Examples of using the HashMap::entry function\n// https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry\n\nverus!{\n\n// Specs for OccupiedEntry, VacantEntry, and the Entry enum\n\n#[verifier::reject_recursive_types_in_ground_variants(K)]\n#[verifier::reject_recursive_types_in_ground_variants(V)]\n#[verifier::external_body]\n#[verifier::external_type_specification]\npub struct ExOccupiedEntry<'a, K: 'a, V: 'a>(OccupiedEntry<'a, K, V>);\n\n#[verifier::reject_recursive_types_in_ground_variants(K)]\n#[verifier::accept_recursive_types(V)]\n#[verifier::external_body]\n#[verifier::external_type_specification]\npub struct ExVacantEntry<'a, K: 'a, V: 'a>(VacantEntry<'a, K, V>);\n\n#[verifier::external_type_specification]\npub struct ExEntry<'a, K: 'a, V: 'a>(Entry<'a, K, V>);\n\npub trait OccupiedEntrySpecFns<K, V> : Sized {\n    spec fn key(self) -> K;\n    spec fn value(self) -> V;\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> OccupiedEntrySpecFns<K, V> for OccupiedEntry<'a, K, V> {\n    uninterp spec fn key(self) -> K;\n    uninterp spec fn value(self) -> V;\n    #[verifier::prophetic]\n    uninterp spec fn future_value(self) -> Option<V>;\n}\n\npub trait VacantEntrySpecFns<K, V> : Sized {\n    spec fn key(self) -> K;\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> VacantEntrySpecFns<K, V> for VacantEntry<'a, K, V> {\n    uninterp spec fn key(self) -> K;\n    #[verifier::prophetic]\n    uninterp spec fn future_value(self) -> Option<V>;\n}\n\npub trait EntrySpecFns<K, V> : Sized {\n    spec fn key(self) -> K;\n    spec fn value(self) -> Option<V>;\n\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> EntrySpecFns<K, V> for Entry<'a, K, V> {\n    open spec fn key(self) -> K {\n        match self {\n            Entry::Occupied(occupied_entry) => occupied_entry.key(),\n            Entry::Vacant(vacant_entry) => vacant_entry.key(),\n        }\n    }\n\n    open spec fn value(self) -> Option<V> {\n        match self {\n            Entry::Occupied(occupied_entry) => Some(occupied_entry.value()),\n            Entry::Vacant(vacant_entry) => None,\n        }\n    }\n\n    #[verifier::prophetic]\n    open spec fn future_value(self) -> Option<V> {\n        match self {\n            Entry::Occupied(occupied_entry) => occupied_entry.future_value(),\n            Entry::Vacant(vacant_entry) => vacant_entry.future_value(),\n        }\n    }\n}\n\npub broadcast axiom fn occupied_entry_has_resolved<K, V>(entry: OccupiedEntry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == Some(entry.value());\n\npub broadcast axiom fn vacant_entry_has_resolved<K, V>(entry: VacantEntry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == None::<V>;\n\npub broadcast proof fn entry_has_resolved<K, V>(entry: Entry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == entry.value()\n{\n    broadcast use occupied_entry_has_resolved;\n    broadcast use vacant_entry_has_resolved;\n}\n\npub assume_specification<\n    'a,\n    Key: Hash + Eq,\n    Value,\n    S: BuildHasher,\n>[ HashMap::<Key, Value, S>::entry ](m: &'a mut HashMap<Key, Value, S>, key: Key)\n  -> (entry: Entry<'a, Key, Value>)\nensures\n    obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> (\n            entry.key() == key\n         && entry.value() == mut_ref_current(m)@.get(key)\n         && mut_ref_future(m)@ == (match entry.future_value() {\n            Some(value) => mut_ref_current(m)@.insert(key, value),\n            None => mut_ref_current(m)@.remove(key),\n         })\n    );\n\npub assume_specification<'a, K, V> [ Entry::or_insert ]\n    (entry: Entry::<'a, K, V>, default: V) -> (value: &'a mut V)\nensures\n    mut_ref_current(value) == (match entry.value() {\n        Some(v) => v,\n        None => default\n    }),\n    entry.future_value() == Some(mut_ref_future(value));\n\npub assume_specification<'a, K, V> [ OccupiedEntry::remove_entry ]\n    (entry: OccupiedEntry::<'a, K, V>) -> (kv: (Key, Value))\nensures\n    entry.future_value() == None,\nreturns\n    (entry.key(), entry.value())\n\n\nfn main() {\n    broadcast use entry_has_resolved;\n\n    let mut m = HashMap::<u64, u64>::new();\n\n    // Use entry API to insert to the matp\n\n    let entry = m.entry(5);\n    assert(entry.key() == 5 && entry.value() === None);\n\n    let value_ref = entry.or_insert(20);\n    assert(*value_ref == 20);\n\n    *value_ref = 40;\n\n    assert(m@.dom().contains(5) && m@[5] == 40);\n\n    // Use entry API to remove from the map\n\n    let entry = m.entry(5);\n    match entry {\n        Entry::OccupiedEntry(occupied_entry) => {\n            let (k, v) == occupied_entry.remove_entry();\n            assert(k == 5);\n            assert(v == 40);\n        }\n        Entry::VacantEntry(_) => {\n            assert(false);\n        }\n    }\n\n    assert(!m@.dom().contains(5));\n}\n\n}\n\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/experimental_new_mut_ref/hash_table_entry.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 204, "verus_errors": [{"error_type": "Other", "error_text": "expected `;` ()", "message": "VerusErrorType.Other: expected `;` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmppl520f_8", "lines": [138, 138], "label": null, "text": [{"text": "fn main() {", "highlight_start": 1, "highlight_end": 3}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 173, "minimized_LOC": 173, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::std_specs::hash::", "core::borrow::Borrow", "std::collections::hash_map::", "std::hash::"], "complexity_verus_tokens": 31, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": " fn occupied_entry_has_resolved<K, V>(entry: OccupiedEntry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == Some(entry.value());\n\npub broadcast axiom fn vacant_entry_has_resolved<K, V>(entry: VacantEntry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == None::<V>;\n\npub broadcast proof fn entry_has_resolved<K, V>(entry: Entry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == entry.value()\n{\n\n fn vacant_entry_has_resolved<K, V>(entry: VacantEntry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == None::<V>;\n\npub broadcast proof fn entry_has_resolved<K, V>(entry: Entry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == entry.value()\n{\n\n\nfn main() {", "spec": "spec fn key(self) -> K;\n    spec fn value(self) -> V;\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> OccupiedEntrySpecFns<K, V> for OccupiedEntry<'a, K, V> {\n\nspec fn value(self) -> V;\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> OccupiedEntrySpecFns<K, V> for OccupiedEntry<'a, K, V> {\n\nspec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> OccupiedEntrySpecFns<K, V> for OccupiedEntry<'a, K, V> {\n\nspec fn key(self) -> K;\n    uninterp spec fn value(self) -> V;\n    #[verifier::prophetic]\n    uninterp spec fn future_value(self) -> Option<V>;\n}\n\npub trait VacantEntrySpecFns<K, V> : Sized {\n\nspec fn value(self) -> V;\n    #[verifier::prophetic]\n    uninterp spec fn future_value(self) -> Option<V>;\n}\n\npub trait VacantEntrySpecFns<K, V> : Sized {\n\nspec fn future_value(self) -> Option<V>;\n}\n\npub trait VacantEntrySpecFns<K, V> : Sized {\n\nspec fn key(self) -> K;\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> VacantEntrySpecFns<K, V> for VacantEntry<'a, K, V> {\n\nspec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> VacantEntrySpecFns<K, V> for VacantEntry<'a, K, V> {\n\nspec fn key(self) -> K;\n    #[verifier::prophetic]\n    uninterp spec fn future_value(self) -> Option<V>;\n}\n\npub trait EntrySpecFns<K, V> : Sized {\n\nspec fn future_value(self) -> Option<V>;\n}\n\npub trait EntrySpecFns<K, V> : Sized {\n\nspec fn key(self) -> K;\n    spec fn value(self) -> Option<V>;\n\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> EntrySpecFns<K, V> for Entry<'a, K, V> {\n\nspec fn value(self) -> Option<V>;\n\n    #[verifier::prophetic]\n    spec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> EntrySpecFns<K, V> for Entry<'a, K, V> {\n\nspec fn future_value(self) -> Option<V>;\n}\n\nimpl<'a, K, V> EntrySpecFns<K, V> for Entry<'a, K, V> {\n\nspec fn key(self) -> K {\n\nspec fn value(self) -> Option<V> {\n\nspec fn future_value(self) -> Option<V> {\n\n    ensures\n\n    ensures\n\n    ensures\n\nensures\n\nensures\n\nensures", "proof": "proof fn entry_has_resolved<K, V>(entry: Entry<K, V>)\n    ensures\n        #[trigger] has_resolved(entry) ==> entry.future_value() == entry.value()\n{"}}}, "all_snapshots": []}
{"id": "extensionality_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{map::*, seq::*, seq_lib::*, set::*, set_lib::*};\n\nverus! {\n\n// Sequence extensionality\nproof fn test_seqs(s1: Seq<u64>, s2: Seq<u64>)\n    requires\n        s1.len() == 3,\n        s1[0] == 0,\n        s1[1] == 4,\n        s1[2] == 8,\n        s2.len() == 3,\n        s2[0] == 0,\n        s2[1] == 4,\n        s2[2] == 8,\n{\n    assert_seqs_equal!(s1, s2);\n    assert(s1 == s2);\n}\n\nproof fn pop_and_push(s: Seq<u64>)\n    requires\n        s.len() >= 1,\n{\n    let t = s.subrange(0, s.len() as int - 1).push(s[s.len() as int - 1]);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nproof fn subrange_concat(s: Seq<u64>, i: int)\n    requires\n        0 <= i <= s.len(),\n{\n    let t1 = s.subrange(0, i);\n    let t2 = s.subrange(i, s.len() as int);\n    let t = t1.add(t2);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nspec fn are_equal(s: Seq<u64>, t: Seq<u64>, i: int) -> bool {\n    s[i] == t[i]\n}\n\nproof fn assert_seqs_equal_with_proof(s: Seq<u64>, t: Seq<u64>)\n    requires\n        s.len() == t.len(),\n        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i),\n{\n    assert_seqs_equal!(s, t, i => {\n        assert(are_equal(s, t, i)); // trigger\n    });\n    assert(s == t);\n}\n\n// Map extensionality\nproof fn test_map(m: Map<int, int>)\n    requires\n        m.contains_pair(5, 17),\n{\n    let q = m.remove(5).insert(5, 17);\n    assert_maps_equal!(m, q);\n    assert(m == q);\n}\n\nspec fn maps_are_equal_on(m: Map<int, int>, q: Map<int, int>, i: int) -> bool {\n    &&& m.dom().contains(i)\n    &&& q.dom().contains(i)\n    &&& m[i] == q[i]\n}\n\nproof fn assert_maps_equal_with_proof(m: Map<int, int>, q: Map<int, int>)\n    requires\n        forall|i| maps_are_equal_on(m, q, i),\n{\n    assert_maps_equal!(m, q, i => {\n        assert(maps_are_equal_on(m, q, i)); // trigger\n    });\n    assert(m == q);\n}\n\nproof fn assert_maps_equal_with_proof2() {\n    let m = Map::<u64, u64>::total(|t: u64| t & 184);\n    let q = Map::<u64, u64>::new(|t: u64| t ^ t == 0, |t: u64| 184 & t);\n    assert_maps_equal!(m, q, t => {\n        // show that the `q` map is total:\n        assert_bit_vector(t ^ t == 0);\n\n        // show that the values are equal:\n        assert_bit_vector(t & 184 == 184 & t);\n    });\n    assert(m == q);\n}\n\n// Set extensionality\nproof fn test_set(s: Set<int>, t: Set<int>) {\n    assert_sets_equal!(\n        s.union(t),\n        t.union(s),\n    );\n    assert(s.union(t) == t.union(s));\n}\n\nproof fn assert_sets_equal_with_proof() {\n    let s = Set::<u64>::new(|i: u64| i ^ 25 < 100);\n    let t = Set::<u64>::new(|i: u64| 25 ^ i < 100);\n    assert_sets_equal!(s, t, i => {\n        assert_bit_vector(i ^ 25 == 25 ^ i);\n    });\n    assert(s == t);\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "  use verus_builtin_macros::*;\n                use vstd::{\n      };\n                verus! {\n              fn main() ;\n              }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/extensionality.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1077, "minimize_time_ms": 154056, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 120, "minimized_LOC": 6, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 1, "has_meaningful_spec": false, "readability_score": 0.6, "reduction_ratio": 0.05}, "labeling": {"segments": {"exec": "  use verus_builtin_macros::*;\n                use vstd::{\n      };\n                verus! {\n              fn main() ;\n              }\n"}}}, "all_snapshots": ["#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{map::*, seq::*, seq_lib::*, set::*, set_lib::*};\n\nverus! {\n\n// Sequence extensionality\nproof fn test_seqs(s1: Seq<u64>, s2: Seq<u64>)\n    requires\n        s1.len() == 3,\n        s1[0] == 0,\n        s1[1] == 4,\n        s1[2] == 8,\n        s2.len() == 3,\n        s2[0] == 0,\n        s2[1] == 4,\n        s2[2] == 8,\n{\n    assert_seqs_equal!(s1, s2);\n    assert(s1 == s2);\n}\n\nproof fn pop_and_push(s: Seq<u64>)\n    requires\n        s.len() >= 1,\n{\n    let t = s.subrange(0, s.len() as int - 1).push(s[s.len() as int - 1]);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nproof fn subrange_concat(s: Seq<u64>, i: int)\n    requires\n        0 <= i <= s.len(),\n{\n    let t1 = s.subrange(0, i);\n    let t2 = s.subrange(i, s.len() as int);\n    let t = t1.add(t2);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nspec fn are_equal(s: Seq<u64>, t: Seq<u64>, i: int) -> bool {\n    s[i] == t[i]\n}\n\nproof fn assert_seqs_equal_with_proof(s: Seq<u64>, t: Seq<u64>)\n    requires\n        s.len() == t.len(),\n        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i),\n{\n    assert_seqs_equal!(s, t, i => {\n        assert(are_equal(s, t, i)); // trigger\n    });\n    assert(s == t);\n}\n\n// Map extensionality\nproof fn test_map(m: Map<int, int>)\n    requires\n        m.contains_pair(5, 17),\n{\n    let q = m.remove(5).insert(5, 17);\n    assert_maps_equal!(m, q);\n    assert(m == q);\n}\n\nspec fn maps_are_equal_on(m: Map<int, int>, q: Map<int, int>, i: int) -> bool {\n    &&& m.dom().contains(i)\n    &&& q.dom().contains(i)\n    &&& m[i] == q[i]\n}\n\nproof fn assert_maps_equal_with_proof(m: Map<int, int>, q: Map<int, int>)\n    requires\n        forall|i| maps_are_equal_on(m, q, i),\n{\n    assert_maps_equal!(m, q, i => {\n        assert(maps_are_equal_on(m, q, i)); // trigger\n    });\n    assert(m == q);\n}\n\nproof fn assert_maps_equal_with_proof2() {\n    let m = Map::<u64, u64>::total(|t: u64| t & 184);\n    let q = Map::<u64, u64>::new(|t: u64| t ^ t == 0, |t: u64| 184 & t);\n    assert_maps_equal!(m, q, t => {\n        // show that the `q` map is total:\n        assert_bit_vector(t ^ t == 0);\n\n        // show that the values are equal:\n        assert_bit_vector(t & 184 == 184 & t);\n    });\n    assert(m == q);\n}\n\n// Set extensionality\nproof fn test_set(s: Set<int>, t: Set<int>) {\n    assert_sets_equal!(\n        s.union(t),\n        t.union(s),\n    );\n    assert(s.union(t) == t.union(s));\n}\n\nproof fn assert_sets_equal_with_proof() {\n    let s = Set::<u64>::new(|i: u64| i ^ 25 < 100);\n    let t = Set::<u64>::new(|i: u64| 25 ^ i < 100);\n    assert_sets_equal!(s, t, i => {\n        assert_bit_vector(i ^ 25 == 25 ^ i);\n    });\n    assert(s == t);\n}\n\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n", "  use verus_builtin_macros::*;\n                use vstd::{\n      };\n                verus! {\n              fn main() ;\n              }\n", "use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n"]}
{"id": "float_cc0b9f7d", "original_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nuse vstd::std_specs::ops::AddSpec;\nuse vstd::float::FloatBitsProperties;\n\n/*\nVerus deliberately omits axioms about floating point from vstd,\nbecause the desired set of useful and sound axioms may vary by project and platform.\n(See https://github.com/rust-lang/rfcs/blob/master/text/3514-float-semantics.md for details\nabout why Rust floating point semantics are complex, may be non-deterministic, and may fall short\nof desired behavior on some platforms.)\nTherefore, projects that want to prove properties of about floating-point numbers may want\nto define their own axioms, or even define different groups of axioms for different situations.\n\nFor example, one useful axiom is that it is always safe to add any two floats\n(this assumes that the platform is correctly configured not to trap on a NaN result,\nwhich should usually be true):\n*/\n\npub broadcast axiom fn f64_can_add_anything(a: f64, b: f64)\n    ensures\n        #[trigger] a.add_req(b);\n\n/*\nThe axiom above doesn't guarantee non-NaN results -- it's possible to add large positive numbers to\nconstruct positive infinity, to add large negative numbers to construct negative infinity,\nand then add negative infinity to positive infinity to construct a NaN.\nAs an example of verifying something slightly nontrivial,\nthe axioms below only permit addition of positive numbers,\nand guarantee non-NaN results.\n*/\n\npub broadcast axiom fn f64_add_positive_spec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #![trigger a.add_spec(b)]\n        !a.add_spec(b).is_nan_spec(),\n        !a.add_spec(b).is_sign_negative_spec();\n\npub broadcast axiom fn f64_add_positive_exec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] a.add_req(b);\n\nuse vstd::std_specs::ops::add_ensures;\n\npub broadcast axiom fn f64_add_positive_ensures(a: f64, b: f64, o: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] add_ensures::<f64>(a, b, o) ==> o == a.add_spec(b);\n\npub broadcast group f64_add_positive {\n    f64_add_positive_spec,\n    f64_add_positive_exec,\n    f64_add_positive_ensures,\n}\n\nfn main() {\n    broadcast use f64_add_positive;\n    let a: f64 = 3.1;\n    let b: f64 = 2.8;\n    let c = a + b;\n    let d = b + c;\n    let e = c + d;\n\n    // This would fail the !b.is_sign_negative_spec() precondition:\n    // let f = e + (-0.7);\n\n    // But if we use the more permissive axiom, then we can add a negative number\n    // (albeit with no guarantee about the result):\n    broadcast use f64_can_add_anything;\n    let f = e + (-0.7);\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin_macros::*;\nverus !{\n  use vstd;\n  fn main();\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/float.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1248, "minimize_time_ms": 215378, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 91, "minimized_LOC": 5, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::", "vstd::std_specs::ops::AddSpec", "vstd::float::FloatBitsProperties", "vstd::std_specs::ops::add_ensures"], "has_meaningful_spec": false, "readability_score": 0.5, "reduction_ratio": 0.054945054945054944}, "labeling": {"segments": {"exec": "use verus_builtin_macros::*;\nverus !{\n  use vstd;\n  fn main();\n}\n"}}}, "all_snapshots": ["use verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nuse vstd::std_specs::ops::AddSpec;\nuse vstd::float::FloatBitsProperties;\n\n/*\nVerus deliberately omits axioms about floating point from vstd,\nbecause the desired set of useful and sound axioms may vary by project and platform.\n(See https://github.com/rust-lang/rfcs/blob/master/text/3514-float-semantics.md for details\nabout why Rust floating point semantics are complex, may be non-deterministic, and may fall short\nof desired behavior on some platforms.)\nTherefore, projects that want to prove properties of about floating-point numbers may want\nto define their own axioms, or even define different groups of axioms for different situations.\n\nFor example, one useful axiom is that it is always safe to add any two floats\n(this assumes that the platform is correctly configured not to trap on a NaN result,\nwhich should usually be true):\n*/\n\npub broadcast axiom fn f64_can_add_anything(a: f64, b: f64)\n    ensures\n        #[trigger] a.add_req(b);\n\n/*\nThe axiom above doesn't guarantee non-NaN results -- it's possible to add large positive numbers to\nconstruct positive infinity, to add large negative numbers to construct negative infinity,\nand then add negative infinity to positive infinity to construct a NaN.\nAs an example of verifying something slightly nontrivial,\nthe axioms below only permit addition of positive numbers,\nand guarantee non-NaN results.\n*/\n\npub broadcast axiom fn f64_add_positive_spec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #![trigger a.add_spec(b)]\n        !a.add_spec(b).is_nan_spec(),\n        !a.add_spec(b).is_sign_negative_spec();\n\npub broadcast axiom fn f64_add_positive_exec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] a.add_req(b);\n\nuse vstd::std_specs::ops::add_ensures;\n\npub broadcast axiom fn f64_add_positive_ensures(a: f64, b: f64, o: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] add_ensures::<f64>(a, b, o) ==> o == a.add_spec(b);\n\npub broadcast group f64_add_positive {\n    f64_add_positive_spec,\n    f64_add_positive_exec,\n    f64_add_positive_ensures,\n}\n\nfn main() {\n    broadcast use f64_add_positive;\n    let a: f64 = 3.1;\n    let b: f64 = 2.8;\n    let c = a + b;\n    let d = b + c;\n    let e = c + d;\n\n    // This would fail the !b.is_sign_negative_spec() precondition:\n    // let f = e + (-0.7);\n\n    // But if we use the more permissive axiom, then we can add a negative number\n    // (albeit with no guarantee about the result):\n    broadcast use f64_can_add_anything;\n    let f = e + (-0.7);\n}\n\n} // verus!\n", "use verus_builtin_macros::*;\nverus !{\n  use vstd;\n  fn main();\n}\n", " use verus_builtin_macros::*;\n            verus! {\n          use vstd::std_specs::ops::AddSpec;\n          fn main() ;\n          }\n", "use verus_builtin_macros::*;\nverus !{\n  use vstd;\n  fn main();\n}\n"]}
{"id": "generics_cc0b9f7d", "original_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n    requires\n        f(a, c),\n    ensures\n        f(r, a),\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n    ensures\n        f(r, id_u64(i)),\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n    assert(s_property(x) == s_property(y));\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n    assert(s_property(x) == s_property(y));\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n    assert(g(u) == u);\n}\n\nproof fn test_g2(u: u8) {\n    assert(g(u) < 256 as int);\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n    requires\n        f(a, c),\n    ensures\n        f(r, a),\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n    ensures\n        f(r, id_u64(i)),\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n    assert(s_property(x) == s_property(y));\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n    assert(s_property(x) == s_property(y));\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n    assert(g(u) == u);\n}\n\nproof fn test_g2(u: u8) {\n    assert(g(u) < 256 as int);\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/generics.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 691, "minimize_time_ms": 152612, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 75, "minimized_LOC": 75, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 21, "has_meaningful_spec": true, "readability_score": 0.8999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {\n\n\nfn id_u64_exec(i: u64) -> (r: u64)\n    ensures\n        f(r, id_u64(i)),\n{", "spec": "spec fn f<A>(a1: A, a2: A) -> bool {\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n\nspec fn id_int(i: int) -> int {\n\nspec fn id_u64(i: u64) -> u64 {\n\nspec fn s_property<B>(s: S<B>) -> int {\n\nspec fn id_s(s: S<int>) -> S<int> {\n\nspec fn g<A>(a: A) -> A {\n\n    requires\n\n    ensures\n\n    ensures", "proof": "proof fn s_prop1(x: S<int>, y: S<int>) {\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n\nproof fn test_g1(u: u8) {\n\nproof fn test_g2(u: u8) {"}}}, "all_snapshots": ["use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n    requires\n        f(a, c),\n    ensures\n        f(r, a),\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n    ensures\n        f(r, id_u64(i)),\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n    assert(s_property(x) == s_property(y));\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n    assert(s_property(x) == s_property(y));\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n    assert(g(u) == u);\n}\n\nproof fn test_g2(u: u8) {\n    assert(g(u) < 256 as int);\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "assert_by_compute_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::seq::*;\n\nfn main() {}\n\nverus! {\n\n// ANCHOR: pow_concrete\n// Naive definition of exponentiation\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp,\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nproof fn concrete_pow() {\n    assert(pow(2, 8) == 256) by (compute);  // Assertion 1\n    assert(pow(2, 9) == 512);  // Assertion 2\n    assert(pow(2, 8) == 256) by (compute_only);  // Assertion 3\n}\n// ANCHOR_END: pow_concrete\n\n/*\n// ANCHOR: let_fails\nlet x = 2;\nassert(pow(2, x) == 4) by (compute_only);\n// ANCHOR_END: let_fails\n*/\n\n// ANCHOR: let_passes\nproof fn let_passes() {\n    assert({\n        let x = 2;\n        pow(2, x) == 4\n    }) by (compute_only);\n}\n// ANCHOR_END: let_passes\n\n// ANCHOR: seq_example\nproof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {\n    assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n}\n// ANCHOR_END: seq_example\n\n// ANCHOR: fibonacci_memoize\n#[verifier::memoize]\nspec fn fibonacci(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)\n    }\n}\n\nproof fn test_fibonacci() {\n    assert(fibonacci(63) == 6557470319842) by(compute_only);\n}\n// ANCHOR_END: fibonacci_memoize\n\n// ANCHOR: all_spec\nuse vstd::compute::RangeAll;\n\nspec fn p(u: usize) -> bool {\n    u >> 8 == 0\n}\n\nproof fn range_property(u: usize)\n    requires 25 <= u < 100,\n    ensures p(u),\n{\n    assert((25..100int).all_spec(|x| p(x as usize))) by (compute_only);\n    let prop = |x| p(x as usize);\n    assert(prop(u));\n}\n// ANCHOR_END: all_spec\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\n     use verus_builtin_macros::*;\n      fn main() {\n    }\n      verus! {\n     }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/assert_by_compute.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1045, "minimize_time_ms": 155649, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 89, "minimized_LOC": 6, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::seq::", "vstd::compute::RangeAll"], "complexity_verus_tokens": 1, "has_meaningful_spec": false, "readability_score": 0.5, "reduction_ratio": 0.06741573033707865}, "labeling": {"segments": {"exec": " fn main() {"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::seq::*;\n\nfn main() {}\n\nverus! {\n\n// ANCHOR: pow_concrete\n// Naive definition of exponentiation\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp,\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nproof fn concrete_pow() {\n    assert(pow(2, 8) == 256) by (compute);  // Assertion 1\n    assert(pow(2, 9) == 512);  // Assertion 2\n    assert(pow(2, 8) == 256) by (compute_only);  // Assertion 3\n}\n// ANCHOR_END: pow_concrete\n\n/*\n// ANCHOR: let_fails\nlet x = 2;\nassert(pow(2, x) == 4) by (compute_only);\n// ANCHOR_END: let_fails\n*/\n\n// ANCHOR: let_passes\nproof fn let_passes() {\n    assert({\n        let x = 2;\n        pow(2, x) == 4\n    }) by (compute_only);\n}\n// ANCHOR_END: let_passes\n\n// ANCHOR: seq_example\nproof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {\n    assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n}\n// ANCHOR_END: seq_example\n\n// ANCHOR: fibonacci_memoize\n#[verifier::memoize]\nspec fn fibonacci(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)\n    }\n}\n\nproof fn test_fibonacci() {\n    assert(fibonacci(63) == 6557470319842) by(compute_only);\n}\n// ANCHOR_END: fibonacci_memoize\n\n// ANCHOR: all_spec\nuse vstd::compute::RangeAll;\n\nspec fn p(u: usize) -> bool {\n    u >> 8 == 0\n}\n\nproof fn range_property(u: usize)\n    requires 25 <= u < 100,\n    ensures p(u),\n{\n    assert((25..100int).all_spec(|x| p(x as usize))) by (compute_only);\n    let prop = |x| p(x as usize);\n    assert(prop(u));\n}\n// ANCHOR_END: all_spec\n\n} // verus!\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n     use verus_builtin_macros::*;\n      fn main() {\n    }\n      verus! {\n     }\n", "use verus_builtin::*;\n             fn main() {\n   }\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "bst_map_cc0b9f7d", "original_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self,\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "minimized_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self,\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/bst_map.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1387, "minimize_time_ms": 123370, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 341, "minimized_LOC": 341, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 35, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n\n fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n\n fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n\n pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n\n fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n\n fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n\n pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n\n fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n\n fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) {\n\n pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) {\n\n\nfn test() {\n\n\nfn test2() {\n\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n\n\nfn main() {", "spec": "spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n\nspec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n\nspec fn as_map(self) -> Map<u64, V> {\n\nspec fn view(&self) -> Map<u64, V> {\n\nspec fn well_formed(self) -> bool\n        decreases self,\n    {\n\nspec fn well_formed(self) -> bool {\n\n        decreases node_opt,\n\n        decreases self,\n\n        decreases self,\n\n        ensures\n\n        requires\n\n        ensures\n\n        decreases *old(node),\n\n        requires\n\n        ensures\n\n        decreases *old(self),\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n        decreases *old(node),\n\n        requires\n\n        ensures\n\n        decreases *old(node),\n\n        requires\n\n        ensures\n\n        requires\n\n        decreases node,\n\n        requires\n\n        decreases self,\n\n        requires\n\n    requires", "proof": "proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n\nproof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }"}}}, "all_snapshots": ["// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self,\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bst_map_type_invariant_cc0b9f7d", "original_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        ensures\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "minimized_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        ensures\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/bst_map_type_invariant.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1235, "minimize_time_ms": 154541, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 335, "minimized_LOC": 335, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 38, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature\n    {\n\n fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n\n fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n\n pub fn insert(&mut self, key: u64, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n\n fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n\n fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n\n pub fn delete(&mut self, key: u64)\n        ensures\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n\n fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n\n fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) {\n\n pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) {\n\n\nfn test() {\n\n\nfn test2(tree_map: TreeMap<bool>) {\n\n\nfn main() {", "spec": "spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n\nspec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n\nspec fn as_map(self) -> Map<u64, V> {\n\nspec fn view(&self) -> Map<u64, V> {\n\nspec fn well_formed(self) -> bool\n        decreases self\n    {\n\nspec fn well_formed(self) -> bool {\n\n        decreases node_opt,\n\n        decreases self,\n\n        decreases self\n\n        ensures\n\n        requires\n\n        ensures\n\n        decreases *old(node),\n\n        requires\n\n        ensures\n\n        decreases *old(self),\n\n        ensures\n\n        requires\n\n        ensures\n\n        decreases *old(node),\n\n        requires\n\n        ensures\n\n        decreases *old(node),\n\n        ensures\n\n        requires\n\n        decreases node,\n\n        requires\n\n        decreases self,", "proof": "proof { use_type_invariant(&*self); }\n\nproof { use_type_invariant(&*self); }\n\nproof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n\nproof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n\nproof { use_type_invariant(&*self); }"}}}, "all_snapshots": ["// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        ensures\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus!{}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "const_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/const.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 908, "minimize_time_ms": 183433, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 91, "minimized_LOC": 91, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::layout"], "complexity_verus_tokens": 31, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn spec_add_one(x: int) -> int {\n\nspec fn f() -> int {\n\n    ensures\n\n    ensures\n\n    ensures\n\n    requires\n\n    ensures\n\n    ensures"}}}, "all_snapshots": ["// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "datatypes_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/datatypes.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 838, "minimize_time_ms": 153169, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 130, "minimized_LOC": 130, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "Life::"], "complexity_verus_tokens": 13, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n\n fn new() -> Dessert {\n\n\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n\n\nfn main() {", "spec": "spec fn len2(&self) -> int {\n\nspec fn is_insect(l: Life) -> bool\n{\n\nspec fn area_2(s: Shape) -> int {\n\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n\nspec fn cuddly(l: Life) -> bool {\n\nspec fn is_kangaroo(l: Life) -> bool {\n\nspec fn walks_upright(l: Life) -> bool {\n\n    ensures o.len2() == p.len2()\n\n    requires bev is Soda\n\n    requires bev is Coffee", "proof": "proof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "exec_attr_cc0b9f7d", "original_code": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum => \n     requires \n         x < 100, \n         y < 100, \n     ensures \n         sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{ \n    x + y \n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32> \n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "minimized_code": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum => \n     requires \n         x < 100, \n         y < 100, \n     ensures \n         sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{ \n    x + y \n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32> \n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/exec_attr.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1511, "minimize_time_ms": 628, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 123, "minimized_LOC": 123, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 45, "has_meaningful_spec": false, "readability_score": 0.6, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{\n\n\nfn exec_tracked(x: u32) -> u32 {\n\n\nfn exec_external_test(x: u32) -> u32 {\n\n\nfn f(x: u32, y: u32) -> u32 {\n\n\npub fn f2(x: u32) -> u32 {", "spec": "     requires \n\n     ensures \n\n#[verus_spec(v => ensures true)]\n\n       invariant\n\nrequires\n\nensures\n\n    requires\n\n    requires"}}}, "all_snapshots": []}
{"id": "ext_equal_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\nmod m1 {\n    #[allow(unused_imports)]\n\n\n    use vstd::{seq::*, set::*, map::*, prelude::*};\n\n    // ANCHOR: ext_eq_struct_fields\n    struct Foo {\n        a: Seq<int>,\n        b: Set<int>,\n    }\n\n    proof fn ext_equal_struct() {\n        let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };\n        let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };\n        // assert(f1 == f2);    // FAILS -- need to use =~= first\n        assert(f1.a =~= f2.a);  // succeeds\n        assert(f1.b =~= f2.b);  // succeeds\n        assert(f1 == f2);  // succeeds, now that we've used =~= on .a and .b\n    }\n    // ANCHOR_END: ext_eq_struct_fields\n\n}\n\n// ANCHOR: ext_eq_struct\n#[verifier::ext_equal]  // necessary for invoking =~= on the struct\nstruct Foo {\n    a: Seq<int>,\n    b: Set<int>,\n}\n\nproof fn ext_equal_struct() {\n    let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };\n    let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };\n    assert(f1 =~= f2);  // succeeds\n}\n// ANCHOR_END: ext_eq_struct\n\n// ANCHOR: ext_eq_nested\nproof fn ext_equal_nested() {\n    let inner: Set<int> = set!{1, 2, 3};\n    let s1: Seq<Set<int>> = seq![inner];\n    let s2 = s1.update(0, s1[0].insert(1));\n    let s3 = s1.update(0, s1[0].insert(2).insert(3));\n    // assert(s2 =~= s3); // FAILS\n    assert(s2 =~~= s3);  // succeeds\n    let s4: Seq<Seq<Set<int>>> = seq![s1];\n    let s5: Seq<Seq<Set<int>>> = seq![s2];\n    assert(s4 =~~= s5);  // succeeds\n}\n// ANCHOR_END: ext_eq_nested\n\n// ANCHOR: ext_eq_fnspec\n#[verifier::ext_equal]  // necessary for invoking =~= on the struct\nstruct Bar {\n    a: spec_fn(int) -> int,\n}\n\nproof fn ext_equal_fnspec(n: int) {\n    // basic case\n    let f1 = (|i: int| i + 1);\n    let f2 = (|i: int| 1 + i);\n    assert(f1 =~= f2);  // succeeds\n    // struct case\n    let b1 = Bar { a: |i: int| if i == 1 { i } else { 1 } };\n    let b2 = Bar { a: |i: int| 1int };\n    assert(b1 =~= b2);  // succeeds\n    // nested case\n    let i1 = (|i: int| i + 2);\n    let i2 = (|i: int| 2 + i);\n    let n1: Seq<spec_fn(int) -> int> = seq![i1];\n    let n2: Seq<spec_fn(int) -> int> = seq![i2];\n    // assert(n1 =~= n2); // FAILS\n    assert(n1 =~~= n2);  // succeeds\n}\n// ANCHOR_END: ext_eq_fnspec\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "#[allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\nmod m1 {\n    #[allow(unused_imports)]\n\n\n    use vstd::{seq::*, set::*, map::*, prelude::*};\n\n    // ANCHOR: ext_eq_struct_fields\n    struct Foo {\n        a: Seq<int>,\n        b: Set<int>,\n    }\n\n    proof fn ext_equal_struct() {\n        let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };\n        let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };\n        // assert(f1 == f2);    // FAILS -- need to use =~= first\n        assert(f1.a =~= f2.a);  // succeeds\n        assert(f1.b =~= f2.b);  // succeeds\n        assert(f1 == f2);  // succeeds, now that we've used =~= on .a and .b\n    }\n    // ANCHOR_END: ext_eq_struct_fields\n\n}\n\n// ANCHOR: ext_eq_struct\n#[verifier::ext_equal]  // necessary for invoking =~= on the struct\nstruct Foo {\n    a: Seq<int>,\n    b: Set<int>,\n}\n\nproof fn ext_equal_struct() {\n    let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };\n    let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };\n    assert(f1 =~= f2);  // succeeds\n}\n// ANCHOR_END: ext_eq_struct\n\n// ANCHOR: ext_eq_nested\nproof fn ext_equal_nested() {\n    let inner: Set<int> = set!{1, 2, 3};\n    let s1: Seq<Set<int>> = seq![inner];\n    let s2 = s1.update(0, s1[0].insert(1));\n    let s3 = s1.update(0, s1[0].insert(2).insert(3));\n    // assert(s2 =~= s3); // FAILS\n    assert(s2 =~~= s3);  // succeeds\n    let s4: Seq<Seq<Set<int>>> = seq![s1];\n    let s5: Seq<Seq<Set<int>>> = seq![s2];\n    assert(s4 =~~= s5);  // succeeds\n}\n// ANCHOR_END: ext_eq_nested\n\n// ANCHOR: ext_eq_fnspec\n#[verifier::ext_equal]  // necessary for invoking =~= on the struct\nstruct Bar {\n    a: spec_fn(int) -> int,\n}\n\nproof fn ext_equal_fnspec(n: int) {\n    // basic case\n    let f1 = (|i: int| i + 1);\n    let f2 = (|i: int| 1 + i);\n    assert(f1 =~= f2);  // succeeds\n    // struct case\n    let b1 = Bar { a: |i: int| if i == 1 { i } else { 1 } };\n    let b2 = Bar { a: |i: int| 1int };\n    assert(b1 =~= b2);  // succeeds\n    // nested case\n    let i1 = (|i: int| i + 2);\n    let i2 = (|i: int| 2 + i);\n    let n1: Seq<spec_fn(int) -> int> = seq![i1];\n    let n2: Seq<spec_fn(int) -> int> = seq![i2];\n    // assert(n1 =~= n2); // FAILS\n    assert(n1 =~~= n2);  // succeeds\n}\n// ANCHOR_END: ext_eq_fnspec\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/ext_equal.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 957, "minimize_time_ms": 246677, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 86, "minimized_LOC": 86, "self_contained": true, "dependencies": ["vstd::"], "complexity_verus_tokens": 12, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"spec": "spec\n\nfn main() {", "proof": "proof fn ext_equal_struct() {\n\nproof fn ext_equal_struct() {\n\nproof fn ext_equal_nested() {\n\nproof fn ext_equal_fnspec(n: int) {"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\nmod m1 {\n    #[allow(unused_imports)]\n\n\n    use vstd::{seq::*, set::*, map::*, prelude::*};\n\n    // ANCHOR: ext_eq_struct_fields\n    struct Foo {\n        a: Seq<int>,\n        b: Set<int>,\n    }\n\n    proof fn ext_equal_struct() {\n        let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };\n        let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };\n        // assert(f1 == f2);    // FAILS -- need to use =~= first\n        assert(f1.a =~= f2.a);  // succeeds\n        assert(f1.b =~= f2.b);  // succeeds\n        assert(f1 == f2);  // succeeds, now that we've used =~= on .a and .b\n    }\n    // ANCHOR_END: ext_eq_struct_fields\n\n}\n\n// ANCHOR: ext_eq_struct\n#[verifier::ext_equal]  // necessary for invoking =~= on the struct\nstruct Foo {\n    a: Seq<int>,\n    b: Set<int>,\n}\n\nproof fn ext_equal_struct() {\n    let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };\n    let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };\n    assert(f1 =~= f2);  // succeeds\n}\n// ANCHOR_END: ext_eq_struct\n\n// ANCHOR: ext_eq_nested\nproof fn ext_equal_nested() {\n    let inner: Set<int> = set!{1, 2, 3};\n    let s1: Seq<Set<int>> = seq![inner];\n    let s2 = s1.update(0, s1[0].insert(1));\n    let s3 = s1.update(0, s1[0].insert(2).insert(3));\n    // assert(s2 =~= s3); // FAILS\n    assert(s2 =~~= s3);  // succeeds\n    let s4: Seq<Seq<Set<int>>> = seq![s1];\n    let s5: Seq<Seq<Set<int>>> = seq![s2];\n    assert(s4 =~~= s5);  // succeeds\n}\n// ANCHOR_END: ext_eq_nested\n\n// ANCHOR: ext_eq_fnspec\n#[verifier::ext_equal]  // necessary for invoking =~= on the struct\nstruct Bar {\n    a: spec_fn(int) -> int,\n}\n\nproof fn ext_equal_fnspec(n: int) {\n    // basic case\n    let f1 = (|i: int| i + 1);\n    let f2 = (|i: int| 1 + i);\n    assert(f1 =~= f2);  // succeeds\n    // struct case\n    let b1 = Bar { a: |i: int| if i == 1 { i } else { 1 } };\n    let b2 = Bar { a: |i: int| 1int };\n    assert(b1 =~= b2);  // succeeds\n    // nested case\n    let i1 = (|i: int| i + 2);\n    let i2 = (|i: int| 2 + i);\n    let n1: Seq<spec_fn(int) -> int> = seq![i1];\n    let n2: Seq<spec_fn(int) -> int> = seq![i2];\n    // assert(n1 =~= n2); // FAILS\n    assert(n1 =~~= n2);  // succeeds\n}\n// ANCHOR_END: ext_eq_fnspec\n\nfn main() {\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::{*, prelude::*};\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "higher_order_fns_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-failures\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::*;\n\nverus! {\n\nmod X {\n    use super::*;\n\n    // ANCHOR: example1\n    fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n        2 * x\n    }\n\n    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8) {\n        f(50)\n    }\n\n    fn test() {\n        higher_order_fn(double);\n    }\n    // ANCHOR_END: example1\n}\n\nmod Y {\n    use super::*;\n\n    // ANCHOR: example2\n    fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n        2 * x\n    }\n\n    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)\n        requires\n            call_requires(f, (50,)),\n    {\n        f(50)\n    }\n\n    fn test() {\n        higher_order_fn(double);\n    }\n    // ANCHOR_END: example2\n}\n\nmod Z {\n    use super::*;\n\n    // ANCHOR: example3\n    fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n        2 * x\n    }\n\n    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)\n        requires\n            call_requires(f, (50,)),\n            forall|x, y| call_ensures(f, x, y) ==> y % 2 == 0,\n        ensures\n            res % 2 == 0,\n    {\n        let ret = f(50);\n        return ret;\n    }\n\n    fn test() {\n        higher_order_fn(double);\n    }\n    // ANCHOR_END: example3\n}\n\n// ANCHOR: vec_map\n// ANCHOR: vec_map_signature\nfn vec_map<T, U>(v: &Vec<T>, f: impl Fn(T) -> U) -> (result: Vec<U>) where\n    T: Copy,\n    // ANCHOR_END: vec_map_signature\n\n    // ANCHOR: vec_map_requires\n    requires\n        forall|i|\n            0 <= i < v.len() ==> call_requires(\n                f,\n                (v[i],),\n            ),\n// ANCHOR_END: vec_map_requires\n// ANCHOR: vec_map_ensures\n    ensures\n        result.len() == v.len(),\n        forall|i|\n            0 <= i < v.len() ==> call_ensures(\n                f,\n                (v[i],),\n                #[trigger] result[i],\n            )\n        ,\n        // ANCHOR_END: vec_map_ensures\n{\n    let mut result = Vec::new();\n    let mut j = 0;\n    while j < v.len()\n        invariant\n            forall|i| 0 <= i < v.len() ==> call_requires(f, (v[i],)),\n            0 <= j <= v.len(),\n            j == result.len(),\n            forall|i| 0 <= i < j ==> call_ensures(f, (v[i],), #[trigger] result[i]),\n    {\n        result.push(f(v[j]));\n        j += 1;\n    }\n    result\n}\n// ANCHOR_END: vec_map\n\n// ANCHOR: vec_map_example\nfn double(x: u8) -> (res: u8)\n    requires\n        0 <= x < 128,\n    ensures\n        res == 2 * x,\n{\n    2 * x\n}\n\nfn test_vec_map() {\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    let w = vec_map(&v, double);\n    assert(w[2] == 40);\n}\n// ANCHOR_END: vec_map_example\n\n// ANCHOR: vec_map_example_with_closure\nfn test_vec_map_with_closure() {\n    let double = |x: u8| -> (res: u8)\n        requires 0 <= x < 128\n        ensures res == 2 * x\n    {\n        2 * x\n    };\n\n    assert(forall |x| 0 <= x < 128 ==> call_requires(double, (x,)));\n    assert(forall |x, y| call_ensures(double, (x,), y) ==> y == 2 * x);\n\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    let w = vec_map(&v, double);\n    assert(w[2] == 40);\n}\n// ANCHOR_END: vec_map_example_with_closure\n\n// ANCHOR: closure_capture\nfn example_closure_capture() {\n    let x: u8 = 20;\n\n    let f = || {\n        // Inside the closure, we have seamless access to\n        // variables defined outside the closure.\n        assert(x == 20);\n        x\n    };\n}\n// ANCHOR_END: closure_capture\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs expect-failures\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::*;\n\nverus! {\n\nmod X {\n    use super::*;\n\n    // ANCHOR: example1\n    fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n        2 * x\n    }\n\n    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8) {\n        f(50)\n    }\n\n    fn test() {\n        higher_order_fn(double);\n    }\n    // ANCHOR_END: example1\n}\n\nmod Y {\n    use super::*;\n\n    // ANCHOR: example2\n    fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n        2 * x\n    }\n\n    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)\n        requires\n            call_requires(f, (50,)),\n    {\n        f(50)\n    }\n\n    fn test() {\n        higher_order_fn(double);\n    }\n    // ANCHOR_END: example2\n}\n\nmod Z {\n    use super::*;\n\n    // ANCHOR: example3\n    fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n        2 * x\n    }\n\n    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)\n        requires\n            call_requires(f, (50,)),\n            forall|x, y| call_ensures(f, x, y) ==> y % 2 == 0,\n        ensures\n            res % 2 == 0,\n    {\n        let ret = f(50);\n        return ret;\n    }\n\n    fn test() {\n        higher_order_fn(double);\n    }\n    // ANCHOR_END: example3\n}\n\n// ANCHOR: vec_map\n// ANCHOR: vec_map_signature\nfn vec_map<T, U>(v: &Vec<T>, f: impl Fn(T) -> U) -> (result: Vec<U>) where\n    T: Copy,\n    // ANCHOR_END: vec_map_signature\n\n    // ANCHOR: vec_map_requires\n    requires\n        forall|i|\n            0 <= i < v.len() ==> call_requires(\n                f,\n                (v[i],),\n            ),\n// ANCHOR_END: vec_map_requires\n// ANCHOR: vec_map_ensures\n    ensures\n        result.len() == v.len(),\n        forall|i|\n            0 <= i < v.len() ==> call_ensures(\n                f,\n                (v[i],),\n                #[trigger] result[i],\n            )\n        ,\n        // ANCHOR_END: vec_map_ensures\n{\n    let mut result = Vec::new();\n    let mut j = 0;\n    while j < v.len()\n        invariant\n            forall|i| 0 <= i < v.len() ==> call_requires(f, (v[i],)),\n            0 <= j <= v.len(),\n            j == result.len(),\n            forall|i| 0 <= i < j ==> call_ensures(f, (v[i],), #[trigger] result[i]),\n    {\n        result.push(f(v[j]));\n        j += 1;\n    }\n    result\n}\n// ANCHOR_END: vec_map\n\n// ANCHOR: vec_map_example\nfn double(x: u8) -> (res: u8)\n    requires\n        0 <= x < 128,\n    ensures\n        res == 2 * x,\n{\n    2 * x\n}\n\nfn test_vec_map() {\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    let w = vec_map(&v, double);\n    assert(w[2] == 40);\n}\n// ANCHOR_END: vec_map_example\n\n// ANCHOR: vec_map_example_with_closure\nfn test_vec_map_with_closure() {\n    let double = |x: u8| -> (res: u8)\n        requires 0 <= x < 128\n        ensures res == 2 * x\n    {\n        2 * x\n    };\n\n    assert(forall |x| 0 <= x < 128 ==> call_requires(double, (x,)));\n    assert(forall |x, y| call_ensures(double, (x,), y) ==> y == 2 * x);\n\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    let w = vec_map(&v, double);\n    assert(w[2] == 40);\n}\n// ANCHOR_END: vec_map_example_with_closure\n\n// ANCHOR: closure_capture\nfn example_closure_capture() {\n    let x: u8 = 20;\n\n    let f = || {\n        // Inside the closure, we have seamless access to\n        // variables defined outside the closure.\n        assert(x == 20);\n        x\n    };\n}\n// ANCHOR_END: closure_capture\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/higher_order_fns.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 874, "verus_errors": [{"error_type": "Other", "error_text": "Call to non-static function fails to satisfy `callee.requires(args)` ()", "message": "VerusErrorType.Other: Call to non-static function fails to satisfy `callee.requires(args)` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpif90un55", "lines": [30, 30], "label": null, "text": [{"text": "        f(50)", "highlight_start": 9, "highlight_end": 14}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 194, "minimized_LOC": 194, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::map::", "vstd::modes::", "vstd::prelude::", "vstd::seq::", "vstd::"], "complexity_verus_tokens": 34, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": " fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n\n fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8) {\n\n fn test() {\n\n fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n\n fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)\n        requires\n            call_requires(f, (50,)),\n    {\n\n fn test() {\n\n fn double(x: u8) -> (res: u8)\n        requires\n            0 <= x < 128,\n        ensures\n            res == 2 * x,\n    {\n\n fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)\n        requires\n            call_requires(f, (50,)),\n            forall|x, y| call_ensures(f, x, y) ==> y % 2 == 0,\n        ensures\n            res % 2 == 0,\n    {\n\n fn test() {\n\n\nfn vec_map<T, U>(v: &Vec<T>, f: impl Fn(T) -> U) -> (result: Vec<U>) where\n    T: Copy,\n    // ANCHOR_END: vec_map_signature\n\n    // ANCHOR: vec_map_requires\n    requires\n        forall|i|\n            0 <= i < v.len() ==> call_requires(\n                f,\n                (v[i],),\n            ),\n// ANCHOR_END: vec_map_requires\n// ANCHOR: vec_map_ensures\n    ensures\n        result.len() == v.len(),\n        forall|i|\n            0 <= i < v.len() ==> call_ensures(\n                f,\n                (v[i],),\n                #[trigger] result[i],\n            )\n        ,\n        // ANCHOR_END: vec_map_ensures\n{\n\n\nfn double(x: u8) -> (res: u8)\n    requires\n        0 <= x < 128,\n    ensures\n        res == 2 * x,\n{\n\n\nfn test_vec_map() {\n\n\nfn test_vec_map_with_closure() {\n\n\nfn example_closure_capture() {\n\n\nfn main() {", "spec": "        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n    requires\n\n    ensures\n\n        invariant\n\n    requires\n\n    ensures\n\n        requires 0 <= x < 128\n\n        ensures res == 2 * x"}}}, "all_snapshots": []}
{"id": "integers_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: test_u8\nfn test_u8(u: u8) {\n    assert(0 <= u < 256);\n}\n// ANCHOR_END: test_u8\n\n// ANCHOR: test_consts\nfn test_consts() {\n    let u: u8 = 1u8;\n    assert({\n        let i: int = 2int;\n        let n: nat = 3nat;\n        0int <= u < i < n < 4int\n    });\n}\n// ANCHOR_END: test_consts\n\n// ANCHOR: test_consts_infer\nfn test_consts_infer() {\n    let u: u8 = 1;\n    assert({\n        let i: int = 2;\n        let n: nat = 3;\n        0 <= u < i < n < 4\n    });\n}\n// ANCHOR_END: test_consts_infer\n\n// ANCHOR: test_consts_large\nfn test_consts_large() {\n    assert({\n        let i: int = 0x10000000000000000000000000000000000000000000000000000000000000000int;\n        let j: int = i + i;\n        j == 2 * i\n    });\n}\n// ANCHOR_END: test_consts_large\n\n// ANCHOR: test_coerce\nfn test_coerce() {\n    let u: u8 = 1;\n    assert({\n        let i: int = u as int;\n        let n: nat = u as nat;\n        u == i && u == n\n    });\n}\n// ANCHOR_END: test_coerce\n\n/*\n// ANCHOR: test_coerce_fail\nfn test_coerce_fail() {\n    let v: u16 = 257;\n    let u: u8 = v as u8;\n    assert(u == v); // FAILS, because u has type u8 and therefore cannot be equal to 257\n}\n// ANCHOR_END: test_coerce_fail\n*/\n\n/*\n// ANCHOR: test_sum\nfn test_sum(x: u8, y: u8) {\n    let sum1: u8 = x + y; // FAILS: possible overflow\n}\n// ANCHOR_END: test_sum\n*/\n\n// ANCHOR: test_sum2\nfn test_sum2(x: u8, y: u8) {\n    assert({\n        let sum2: int = x + y;  // in ghost code, + returns int and does not overflow\n        0 <= sum2 < 511\n    });\n}\n// ANCHOR_END: test_sum2\n\n// ANCHOR: test_sum3\nfn test_sum3(x: u8, y: u8)\n    requires\n        x + y < 256,  // make sure \"let sum1: u8 = x + y\" can't overflow\n{\n    let sum1: u8 = x + y;  // succeeds\n}\n// ANCHOR_END: test_sum3\n\n// ANCHOR: test_sum_mixed\nfn test_sum_mixed(x: u8, y: u16) {\n    assert(x + y >= y);  // x + y has type int, so the assertion succeeds\n    assert(x - y <= x);  // x - y has type int, so the assertion succeeds\n}\n// ANCHOR_END: test_sum_mixed\n\n/*\n// ANCHOR: test_sum_add_sub\nfn test_sum_add_sub(x: u8, y: u8) {\n    assert(add(x, y) >= y); // FAILS: add(x, y) has type u8, so addition might overflow\n    assert(sub(x, y) <= x); // FAILS: sub(x, y) has type u8, so subtraction might underflow\n}\n// ANCHOR_END: test_sum_add_sub\n*/\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: test_u8\nfn test_u8(u: u8) {\n    assert(0 <= u < 256);\n}\n// ANCHOR_END: test_u8\n\n// ANCHOR: test_consts\nfn test_consts() {\n    let u: u8 = 1u8;\n    assert({\n        let i: int = 2int;\n        let n: nat = 3nat;\n        0int <= u < i < n < 4int\n    });\n}\n// ANCHOR_END: test_consts\n\n// ANCHOR: test_consts_infer\nfn test_consts_infer() {\n    let u: u8 = 1;\n    assert({\n        let i: int = 2;\n        let n: nat = 3;\n        0 <= u < i < n < 4\n    });\n}\n// ANCHOR_END: test_consts_infer\n\n// ANCHOR: test_consts_large\nfn test_consts_large() {\n    assert({\n        let i: int = 0x10000000000000000000000000000000000000000000000000000000000000000int;\n        let j: int = i + i;\n        j == 2 * i\n    });\n}\n// ANCHOR_END: test_consts_large\n\n// ANCHOR: test_coerce\nfn test_coerce() {\n    let u: u8 = 1;\n    assert({\n        let i: int = u as int;\n        let n: nat = u as nat;\n        u == i && u == n\n    });\n}\n// ANCHOR_END: test_coerce\n\n/*\n// ANCHOR: test_coerce_fail\nfn test_coerce_fail() {\n    let v: u16 = 257;\n    let u: u8 = v as u8;\n    assert(u == v); // FAILS, because u has type u8 and therefore cannot be equal to 257\n}\n// ANCHOR_END: test_coerce_fail\n*/\n\n/*\n// ANCHOR: test_sum\nfn test_sum(x: u8, y: u8) {\n    let sum1: u8 = x + y; // FAILS: possible overflow\n}\n// ANCHOR_END: test_sum\n*/\n\n// ANCHOR: test_sum2\nfn test_sum2(x: u8, y: u8) {\n    assert({\n        let sum2: int = x + y;  // in ghost code, + returns int and does not overflow\n        0 <= sum2 < 511\n    });\n}\n// ANCHOR_END: test_sum2\n\n// ANCHOR: test_sum3\nfn test_sum3(x: u8, y: u8)\n    requires\n        x + y < 256,  // make sure \"let sum1: u8 = x + y\" can't overflow\n{\n    let sum1: u8 = x + y;  // succeeds\n}\n// ANCHOR_END: test_sum3\n\n// ANCHOR: test_sum_mixed\nfn test_sum_mixed(x: u8, y: u16) {\n    assert(x + y >= y);  // x + y has type int, so the assertion succeeds\n    assert(x - y <= x);  // x - y has type int, so the assertion succeeds\n}\n// ANCHOR_END: test_sum_mixed\n\n/*\n// ANCHOR: test_sum_add_sub\nfn test_sum_add_sub(x: u8, y: u8) {\n    assert(add(x, y) >= y); // FAILS: add(x, y) has type u8, so addition might overflow\n    assert(sub(x, y) <= x); // FAILS: sub(x, y) has type u8, so subtraction might underflow\n}\n// ANCHOR_END: test_sum_add_sub\n*/\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/integers.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1108, "minimize_time_ms": 152681, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 112, "minimized_LOC": 112, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 4, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn test_u8(u: u8) {\n\n\nfn test_consts() {\n\n\nfn test_consts_infer() {\n\n\nfn test_consts_large() {\n\n\nfn test_coerce() {\n\n\nfn test_coerce_fail() {\n\n\nfn test_sum(x: u8, y: u8) {\n\n\nfn test_sum2(x: u8, y: u8) {\n\n\nfn test_sum3(x: u8, y: u8)\n    requires\n        x + y < 256,  // make sure \"let sum1: u8 = x + y\" can't overflow\n{\n\n\nfn test_sum_mixed(x: u8, y: u16) {\n\n\nfn test_sum_add_sub(x: u8, y: u8) {\n\n\nfn main() {", "spec": "    requires"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: test_u8\nfn test_u8(u: u8) {\n    assert(0 <= u < 256);\n}\n// ANCHOR_END: test_u8\n\n// ANCHOR: test_consts\nfn test_consts() {\n    let u: u8 = 1u8;\n    assert({\n        let i: int = 2int;\n        let n: nat = 3nat;\n        0int <= u < i < n < 4int\n    });\n}\n// ANCHOR_END: test_consts\n\n// ANCHOR: test_consts_infer\nfn test_consts_infer() {\n    let u: u8 = 1;\n    assert({\n        let i: int = 2;\n        let n: nat = 3;\n        0 <= u < i < n < 4\n    });\n}\n// ANCHOR_END: test_consts_infer\n\n// ANCHOR: test_consts_large\nfn test_consts_large() {\n    assert({\n        let i: int = 0x10000000000000000000000000000000000000000000000000000000000000000int;\n        let j: int = i + i;\n        j == 2 * i\n    });\n}\n// ANCHOR_END: test_consts_large\n\n// ANCHOR: test_coerce\nfn test_coerce() {\n    let u: u8 = 1;\n    assert({\n        let i: int = u as int;\n        let n: nat = u as nat;\n        u == i && u == n\n    });\n}\n// ANCHOR_END: test_coerce\n\n/*\n// ANCHOR: test_coerce_fail\nfn test_coerce_fail() {\n    let v: u16 = 257;\n    let u: u8 = v as u8;\n    assert(u == v); // FAILS, because u has type u8 and therefore cannot be equal to 257\n}\n// ANCHOR_END: test_coerce_fail\n*/\n\n/*\n// ANCHOR: test_sum\nfn test_sum(x: u8, y: u8) {\n    let sum1: u8 = x + y; // FAILS: possible overflow\n}\n// ANCHOR_END: test_sum\n*/\n\n// ANCHOR: test_sum2\nfn test_sum2(x: u8, y: u8) {\n    assert({\n        let sum2: int = x + y;  // in ghost code, + returns int and does not overflow\n        0 <= sum2 < 511\n    });\n}\n// ANCHOR_END: test_sum2\n\n// ANCHOR: test_sum3\nfn test_sum3(x: u8, y: u8)\n    requires\n        x + y < 256,  // make sure \"let sum1: u8 = x + y\" can't overflow\n{\n    let sum1: u8 = x + y;  // succeeds\n}\n// ANCHOR_END: test_sum3\n\n// ANCHOR: test_sum_mixed\nfn test_sum_mixed(x: u8, y: u16) {\n    assert(x + y >= y);  // x + y has type int, so the assertion succeeds\n    assert(x - y <= x);  // x - y has type int, so the assertion succeeds\n}\n// ANCHOR_END: test_sum_mixed\n\n/*\n// ANCHOR: test_sum_add_sub\nfn test_sum_add_sub(x: u8, y: u8) {\n    assert(add(x, y) >= y); // FAILS: add(x, y) has type u8, so addition might overflow\n    assert(sub(x, y) <= x); // FAILS: sub(x, y) has type u8, so subtraction might underflow\n}\n// ANCHOR_END: test_sum_add_sub\n*/\n\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "interior_mutability_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n    ensures\n        res == result_of_computation(),\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an invariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation(),\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n", "minimized_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n    ensures\n        res == result_of_computation(),\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an invariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation(),\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/interior_mutability.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 701, "minimize_time_ms": 122672, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation(),\n{\n\n\nfn main() {", "spec": "spec fn result_of_computation() -> u64 {\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n\n    ensures\n\n// says that the InvCell has an invariant that the interior contents is either\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n    ensures\n        res == result_of_computation(),\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an invariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation(),\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "invariants_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\n// ANCHOR: fib_spec\nspec fn fib(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fib((n - 2) as nat) + fib((n - 1) as nat)\n    }\n}\n// ANCHOR_END: fib_spec\n\n// ANCHOR: fib_is_mono\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fib_is_monotonic(i, (j - 1) as nat);\n        lemma_fib_is_monotonic(i, (j - 2) as nat);\n    }\n}\n// ANCHOR_END: fib_is_mono\n\n/*\n// ANCHOR: fib_impl_no_proof\nfn fib_impl(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n    {\n        i = i + 1;\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_impl_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_no_proof\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n{\n}\n// ANCHOR_END: fib_mono_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_skeleton\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        assume(false);\n    }\n\n}\n// ANCHOR_END: fib_mono_skeleton\n*/\n\n// ANCHOR: fib_final\nfn fib_impl(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur == fib(i as nat),\n            prev == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        proof {\n            lemma_fib_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_final\n\n// ANCHOR: fib_checked\nfn fib_checked(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.unwrap()\n}\n// ANCHOR_END: fib_checked\n\n// ANCHOR: fib_checked_no_precondition\nfn fib_checked_no_precondition(n: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(x) => x == fib(n as nat),\n            None => fib(n as nat) > u64::MAX,\n        },\n{\n    if n == 0 {\n        return Some(0);\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.to_option()\n}\n// ANCHOR_END: fib_checked_no_precondition\n\n// ANCHOR: bank_spec\nspec fn always_non_negative(s: Seq<i64>) -> bool\n{\n    forall|i: int| 0 <= i <= s.len() ==> sum(#[trigger] s.take(i)) >= 0    \n}\n\nspec fn sum(s: Seq<i64>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        sum(s.drop_last()) + s.last()\n    }\n}\n// ANCHOR_END: bank_spec\n\n/*\n// ANCHOR: bank_no_proof\nfn non_negative(operations: &[i64]) -> (r: bool)\n    ensures\n        r == always_non_negative(operations@),\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n    {\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_no_proof\n*/\n\n// ANCHOR: bank_final\nfn non_negative(operations: &[i64]) -> (r: bool)\n    ensures\n        r == always_non_negative(operations@),\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n        invariant\n            s == sum(operations@.take(i as int)),\n            forall|j: int| 0 <= j <= i ==> sum(#[trigger] operations@.take(j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i,\n    {\n        assert(operations@.take(i as int) =~= operations@.take(\n            (i + 1) as int,\n        ).drop_last());\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_final\n\n\nfn main() {\n}\n\n} // verus!\n\n", "minimized_code": " use vstd::prelude::*;\n           verus! {\n         spec fn always_non_negative(s: Seq<i64>) -> bool {\n           forall|i: int| 0 <= i <= s.len() ==> sum(          \n#[trigger] s.take(i)) >= 0    \n}\n         spec fn sum(s: Seq<i64>) -> int     decreases s.len(), {\n           if s.len() == 0 {              0     }\n       else {              sum(s.drop_last()) + s.last()     }\n       }\n         fn non_negative(operations: &[i64]) -> (r: bool)     ensures         r == always_non_negative(operations@), {\n           let mut s = 0i128;\n           for i in 0usize..operations.len()         invariant             s == sum(operations@.take(i as int)),             forall|j: int| 0 <= j <= i ==> sum(          \n#[trigger] operations@.take(j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i,     {              assert(operations@.take(i as int) =~= operations@.take(             (i + 1) as int,         ).drop_last());              s = s + operations[i] as i128;              if s < 0 {                 return false;             }          }\n           true }\n         fn main() ;\n         }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/invariants.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1193, "minimize_time_ms": 789915, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 257, "minimized_LOC": 18, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::prelude::", "vstd::arithmetic::overflow::"], "complexity_verus_tokens": 6, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.07003891050583658}, "labeling": {"segments": {"exec": " fn non_negative(operations: &[i64]) -> (r: bool)     ensures         r == always_non_negative(operations@), {", "spec": "spec fn always_non_negative(s: Seq<i64>) -> bool {\n\nspec fn sum(s: Seq<i64>) -> int     decreases s.len(), {\n\n         spec fn sum(s: Seq<i64>) -> int     decreases s.len(), {\n\n         fn non_negative(operations: &[i64]) -> (r: bool)     ensures         r == always_non_negative(operations@), {\n\n           for i in 0usize..operations.len()         invariant             s == sum(operations@.take(i as int)),             forall|j: int| 0 <= j <= i ==> sum(          "}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\n// ANCHOR: fib_spec\nspec fn fib(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fib((n - 2) as nat) + fib((n - 1) as nat)\n    }\n}\n// ANCHOR_END: fib_spec\n\n// ANCHOR: fib_is_mono\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fib_is_monotonic(i, (j - 1) as nat);\n        lemma_fib_is_monotonic(i, (j - 2) as nat);\n    }\n}\n// ANCHOR_END: fib_is_mono\n\n/*\n// ANCHOR: fib_impl_no_proof\nfn fib_impl(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n    {\n        i = i + 1;\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_impl_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_no_proof\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n{\n}\n// ANCHOR_END: fib_mono_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_skeleton\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        assume(false);\n    }\n\n}\n// ANCHOR_END: fib_mono_skeleton\n*/\n\n// ANCHOR: fib_final\nfn fib_impl(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur == fib(i as nat),\n            prev == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        proof {\n            lemma_fib_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_final\n\n// ANCHOR: fib_checked\nfn fib_checked(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.unwrap()\n}\n// ANCHOR_END: fib_checked\n\n// ANCHOR: fib_checked_no_precondition\nfn fib_checked_no_precondition(n: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(x) => x == fib(n as nat),\n            None => fib(n as nat) > u64::MAX,\n        },\n{\n    if n == 0 {\n        return Some(0);\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.to_option()\n}\n// ANCHOR_END: fib_checked_no_precondition\n\n// ANCHOR: bank_spec\nspec fn always_non_negative(s: Seq<i64>) -> bool\n{\n    forall|i: int| 0 <= i <= s.len() ==> sum(#[trigger] s.take(i)) >= 0    \n}\n\nspec fn sum(s: Seq<i64>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        sum(s.drop_last()) + s.last()\n    }\n}\n// ANCHOR_END: bank_spec\n\n/*\n// ANCHOR: bank_no_proof\nfn non_negative(operations: &[i64]) -> (r: bool)\n    ensures\n        r == always_non_negative(operations@),\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n    {\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_no_proof\n*/\n\n// ANCHOR: bank_final\nfn non_negative(operations: &[i64]) -> (r: bool)\n    ensures\n        r == always_non_negative(operations@),\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n        invariant\n            s == sum(operations@.take(i as int)),\n            forall|j: int| 0 <= j <= i ==> sum(#[trigger] operations@.take(j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i,\n    {\n        assert(operations@.take(i as int) =~= operations@.take(\n            (i + 1) as int,\n        ).drop_last());\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_final\n\n\nfn main() {\n}\n\n} // verus!\n\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use vstd::prelude::*;\n           verus! {\n         spec fn always_non_negative(s: Seq<i64>) -> bool {\n           forall|i: int| 0 <= i <= s.len() ==> sum(          \n#[trigger] s.take(i)) >= 0    \n}\n         spec fn sum(s: Seq<i64>) -> int     decreases s.len(), {\n           if s.len() == 0 {              0     }\n       else {              sum(s.drop_last()) + s.last()     }\n       }\n         fn non_negative(operations: &[i64]) -> (r: bool)     ensures         r == always_non_negative(operations@), {\n           let mut s = 0i128;\n           for i in 0usize..operations.len()         invariant             s == sum(operations@.take(i as int)),             forall|j: int| 0 <= j <= i ==> sum(          \n#[trigger] operations@.take(j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i,     {              assert(operations@.take(i as int) =~= operations@.take(             (i + 1) as int,         ).drop_last());              s = s + operations[i] as i128;              if s < 0 {                 return false;             }          }\n           true }\n         fn main() ;\n         }\n", " use vstd::prelude::*;\n                verus! {\n              spec fn always_non_negative(s: Seq<i64>) -> bool {\n                forall|i| sum(               \ns.take(i)) >= 0    \n}\n              spec fn sum(s: Seq<i64>) -> int     decreases s{\n                if s.len() == 0 {\n                  0     }\n            else {\n                  sum(s.drop_last()) + s.last()     }\n            }\n              fn non_negative(operations: &[i64]) -> (r: bool)     ensures         {\n                let mut s = 0;\n                for i in 0usize..operations.len()         invariant             forall|j| 0 <= j <= i ==> sum(               \noperations@.take(j)) >= 0,\n            s <= i64::MAX * i{\n                  assert(operations@.take(i as int) == operations@.take(             (i + 1) ).drop_last());\n                  s = {\n                    return false}\n              }\n                true }\n              fn main() ;\n              }\n", " use vstd::prelude::*;\n                verus! {\n              spec fn a() -> bool ;\n              spec fn d(b: Seq<i64>) -> int     decreases b{\n                if b.len() == 0 {\n                  0     }\n            else {\n                  d(b.drop_last()) + b.last()     }\n            }\n              fn e(f: &[i64]) ->  bool              {\n                let mut b = 0;\n                for c in 0usize..f.len()         invariant             forall|g| 0 <= g <= c ==> d(               \nf@.take(g))  \n             <= i64::MAX  {\n                  assert(f@.take(c as int) == f@.take             (c + 1) .drop_last());\n                    \n                    return false\n              }\n                true }\n              fn main() ;\n              }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "lib_examples_cc0b9f7d", "original_code": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/lib_examples.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 981, "minimize_time_ms": 214376, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 287, "minimized_LOC": 287, "self_contained": true, "dependencies": ["vstd::", "vstd::"], "complexity_verus_tokens": 41, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn test_vec1() {\n\n\nfn test_vec2() {", "spec": "spec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n\nspec fn adder(x: int) -> spec_fn(int) -> int {\n\n    requires\n\n    requires\n\n    requires\n\n    requires\n\n    ensures\n\n    decreases\n\n    requires\n\n    ensures\n\n    decreases\n\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n\n    requires\n\n    ensures\n\n    decreases\n\n    requires\n\n    ensures\n\n    decreases s1.len(),", "proof": "proof fn test_seq1() {\n\nproof fn test_set1() {\n\nproof fn test_map1() {\n\nproof fn test_seq2() {\n\nproof fn test_seq2() {\n\nproof fn test_set2() {\n\nproof fn test_map2() {\n\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n\nproof fn test_eq_fail() {\n\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n\nproof fn test_eq() {\n\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n\nproof fn test_eq2() {\n\nproof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n\nproof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n\nproof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n\nproof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n\nproof fn test_adder() {"}}}, "all_snapshots": ["#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::{*, prelude::*};\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "modes_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: fun_modes\nspec fn f1(x: int) -> int {\n    x / 2\n}\n\nproof fn f2(x: int) -> int {\n    x / 2\n}\n\n// \"exec\" is optional, and is usually omitted\nexec fn f3(x: u64) -> u64 {\n    x / 2\n}\n\n// ANCHOR_END: fun_modes\n/*\n// ANCHOR: fun_modes2\nfn f3(x: u64) -> u64 { x / 2 } // exec function\n// ANCHOR_END: fun_modes2\n*/\n\n/*\n// ANCHOR: spec_fun1\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn test() {\n    assert(min(10, 20) == 10); // succeeds\n    assert(min(100, 200) == 100); // succeeds\n}\n// ANCHOR_END: spec_fun1\n*/\n\n// ANCHOR: spec_fun3\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nspec fn min3(x: int, y: int, z: int) -> int {\n    min(x, min(y, z))\n}\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n    ensures\n        m == min3(x as int, y as int, z as int),\n{\n    let mut m = x;\n    if y < m {\n        m = y;\n    }\n    if z < m {\n        m = z;\n    }\n    m\n}\n\nfn test() {\n    let m = compute_min3(10, 20, 30);\n    assert(m == 10);\n}\n\n// ANCHOR_END: spec_fun3\n/*\n// ANCHOR: spec_fun_mod1\nmod M1 {\n    use verus_builtin::*;\n\n    pub open spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod1\n\n// ANCHOR: spec_fun_mod2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x,y) <= x && min(x,y) <= y,\n    {}\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == min(10, 20)); // succeeds\n        assert(min(10, 20) == 10); // FAILS\n        proof {\n            lemma_min(10,20);\n        }\n        assert(min(10, 20) <= 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod2\n*/\n\n/*\n// ANCHOR: spec_fun_proof\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test() {\n        lemma_min(10, 20);\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: spec_fun_proof\n*/\n\n// ANCHOR: spec_fun_proof_block1\nfn test_consts_infer() {\n    let u: u8 = 1;\n    proof {\n        let i: int = 2;\n        let n: nat = 3;\n        assert(0 <= u < i < n < 4);\n    }\n}\n\n// ANCHOR_END: spec_fun_proof_block1\n// ANCHOR: spec_fun_proof_block2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        proof {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10);  // succeeds\n        assert(min(100, 200) == 100);  // succeeds\n    }\n\n}\n\n// ANCHOR_END: spec_fun_proof_block2\n/*\n// ANCHOR: assert_by\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10) by {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: assert_by\n*/\n\n/*\n// ANCHOR: determinism\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn s(i: int) -> int {\n        i + 1\n    }\n\n    pub proof fn p(i: int) -> int {\n        i + 1\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test_determinism() {\n        let s1 = s(10);\n        let s2 = s(10);\n        assert(s1 == s2); // succeeds\n\n        let p1 = p(10);\n        let p2 = p(10);\n        assert(p1 == p2); // FAILS\n    }\n}\n// ANCHOR_END: determinism\n*/\n\n// ANCHOR: recommends1\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n    (i - 1) as nat\n}\n\nproof fn test1() {\n    assert(f(0) == f(0));  // succeeds\n}\n\n// ANCHOR_END: recommends1\n/*\n// ANCHOR: recommends2\nproof fn test2() {\n    assert(f(0) <= f(1)); // FAILS\n}\n// ANCHOR_END: recommends2\n*/\n\n// ANCHOR: recommends3\nspec fn caller1() -> nat {\n    f(0)  // no note, warning, or error generated\n\n}\n\n// ANCHOR_END: recommends3\n// ANCHOR: recommends4\nspec(checked) fn caller2() -> nat {\n    f(0)  // generates a warning because of \"(checked)\"\n\n}\n\n// ANCHOR_END: recommends4\n/*\n// ANCHOR: ghost_abilities0\nfn divide_by_zero() {\n    let x: u8 = 1;\n    assert(x / 0 == x / 0); // succeeds in ghost code\n    let y = x / 0; // FAILS in exec code\n}\n// ANCHOR_END: ghost_abilities0\n*/\n\n// ANCHOR: ghost_abilities1\nmod MA {\n    // does not implement Copy\n    // does not allow construction by other modules\n    pub struct S {\n        private_field: u8,\n    }\n\n}\n\nmod MB {\n    use verus_builtin::*;\n    use crate::MA::*;\n\n    // construct a ghost S\n    spec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n        (s, s)\n    }\n\n}\n\n// ANCHOR_END: ghost_abilities1\n/*\n// ANCHOR: ghost_abilities2\nfn test(s: S) {\n    let pair = duplicate_S(s); // FAILS\n}\n// ANCHOR_END: ghost_abilities2\n*/\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: fun_modes\nspec fn f1(x: int) -> int {\n    x / 2\n}\n\nproof fn f2(x: int) -> int {\n    x / 2\n}\n\n// \"exec\" is optional, and is usually omitted\nexec fn f3(x: u64) -> u64 {\n    x / 2\n}\n\n// ANCHOR_END: fun_modes\n/*\n// ANCHOR: fun_modes2\nfn f3(x: u64) -> u64 { x / 2 } // exec function\n// ANCHOR_END: fun_modes2\n*/\n\n/*\n// ANCHOR: spec_fun1\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn test() {\n    assert(min(10, 20) == 10); // succeeds\n    assert(min(100, 200) == 100); // succeeds\n}\n// ANCHOR_END: spec_fun1\n*/\n\n// ANCHOR: spec_fun3\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nspec fn min3(x: int, y: int, z: int) -> int {\n    min(x, min(y, z))\n}\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n    ensures\n        m == min3(x as int, y as int, z as int),\n{\n    let mut m = x;\n    if y < m {\n        m = y;\n    }\n    if z < m {\n        m = z;\n    }\n    m\n}\n\nfn test() {\n    let m = compute_min3(10, 20, 30);\n    assert(m == 10);\n}\n\n// ANCHOR_END: spec_fun3\n/*\n// ANCHOR: spec_fun_mod1\nmod M1 {\n    use verus_builtin::*;\n\n    pub open spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod1\n\n// ANCHOR: spec_fun_mod2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x,y) <= x && min(x,y) <= y,\n    {}\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == min(10, 20)); // succeeds\n        assert(min(10, 20) == 10); // FAILS\n        proof {\n            lemma_min(10,20);\n        }\n        assert(min(10, 20) <= 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod2\n*/\n\n/*\n// ANCHOR: spec_fun_proof\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test() {\n        lemma_min(10, 20);\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: spec_fun_proof\n*/\n\n// ANCHOR: spec_fun_proof_block1\nfn test_consts_infer() {\n    let u: u8 = 1;\n    proof {\n        let i: int = 2;\n        let n: nat = 3;\n        assert(0 <= u < i < n < 4);\n    }\n}\n\n// ANCHOR_END: spec_fun_proof_block1\n// ANCHOR: spec_fun_proof_block2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        proof {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10);  // succeeds\n        assert(min(100, 200) == 100);  // succeeds\n    }\n\n}\n\n// ANCHOR_END: spec_fun_proof_block2\n/*\n// ANCHOR: assert_by\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10) by {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: assert_by\n*/\n\n/*\n// ANCHOR: determinism\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn s(i: int) -> int {\n        i + 1\n    }\n\n    pub proof fn p(i: int) -> int {\n        i + 1\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test_determinism() {\n        let s1 = s(10);\n        let s2 = s(10);\n        assert(s1 == s2); // succeeds\n\n        let p1 = p(10);\n        let p2 = p(10);\n        assert(p1 == p2); // FAILS\n    }\n}\n// ANCHOR_END: determinism\n*/\n\n// ANCHOR: recommends1\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n    (i - 1) as nat\n}\n\nproof fn test1() {\n    assert(f(0) == f(0));  // succeeds\n}\n\n// ANCHOR_END: recommends1\n/*\n// ANCHOR: recommends2\nproof fn test2() {\n    assert(f(0) <= f(1)); // FAILS\n}\n// ANCHOR_END: recommends2\n*/\n\n// ANCHOR: recommends3\nspec fn caller1() -> nat {\n    f(0)  // no note, warning, or error generated\n\n}\n\n// ANCHOR_END: recommends3\n// ANCHOR: recommends4\nspec(checked) fn caller2() -> nat {\n    f(0)  // generates a warning because of \"(checked)\"\n\n}\n\n// ANCHOR_END: recommends4\n/*\n// ANCHOR: ghost_abilities0\nfn divide_by_zero() {\n    let x: u8 = 1;\n    assert(x / 0 == x / 0); // succeeds in ghost code\n    let y = x / 0; // FAILS in exec code\n}\n// ANCHOR_END: ghost_abilities0\n*/\n\n// ANCHOR: ghost_abilities1\nmod MA {\n    // does not implement Copy\n    // does not allow construction by other modules\n    pub struct S {\n        private_field: u8,\n    }\n\n}\n\nmod MB {\n    use verus_builtin::*;\n    use crate::MA::*;\n\n    // construct a ghost S\n    spec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n        (s, s)\n    }\n\n}\n\n// ANCHOR_END: ghost_abilities1\n/*\n// ANCHOR: ghost_abilities2\nfn test(s: S) {\n    let pair = duplicate_S(s); // FAILS\n}\n// ANCHOR_END: ghost_abilities2\n*/\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/modes.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 712, "minimize_time_ms": 152779, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 372, "minimized_LOC": 372, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 67, "has_meaningful_spec": true, "readability_score": 0.75, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " fn f3(x: u64) -> u64 {\n\n\nfn f3(x: u64) -> u64 {\n\n\nfn test() {\n\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n    ensures\n        m == min3(x as int, y as int, z as int),\n{\n\n\nfn test() {\n\n fn test() {\n\n fn test() {\n\n fn test() {\n\n fn test() {\n\n\nfn divide_by_zero() {\n\n\nfn test(s: S) {\n\n\nfn main() {", "spec": "spec fn f1(x: int) -> int {\n\nspec fn min(x: int, y: int) -> int {\n\nspec fn min(x: int, y: int) -> int {\n\nspec fn min3(x: int, y: int, z: int) -> int {\n\nspec fn min(x: int, y: int) -> int {\n\nspec fn min(x: int, y: int) -> int {\n\nspec fn min(x: int, y: int) -> int {\n\nspec fn min(x: int, y: int) -> int {\n\nspec fn min(x: int, y: int) -> int {\n\nspec fn s(i: int) -> int {\n\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n\nspec fn caller1() -> nat {\n\nspec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n\nspec fn duplicate_S(s: S) -> (S, S) {\n\n    ensures\n\n        ensures\n\n        ensures\n\n        ensures\n\n        ensures", "proof": "proof fn f2(x: int) -> int {\n\nproof fn lemma_min(x: int, y: int)\n        ensures\n            min(x,y) <= x && min(x,y) <= y,\n    {\n\nproof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n\nproof fn test() {\n\nproof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n\nproof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n\nproof fn p(i: int) -> int {\n\nproof fn test_determinism() {\n\nproof fn test1() {\n\nproof fn test2() {\n\nproof {\n            lemma_min(10,20);\n        }\n\nproof {\n        let i: int = 2;\n        let n: nat = 3;\n        assert(0 <= u < i < n < 4);\n    }\n\nproof {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }"}}}, "all_snapshots": ["// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: fun_modes\nspec fn f1(x: int) -> int {\n    x / 2\n}\n\nproof fn f2(x: int) -> int {\n    x / 2\n}\n\n// \"exec\" is optional, and is usually omitted\nexec fn f3(x: u64) -> u64 {\n    x / 2\n}\n\n// ANCHOR_END: fun_modes\n/*\n// ANCHOR: fun_modes2\nfn f3(x: u64) -> u64 { x / 2 } // exec function\n// ANCHOR_END: fun_modes2\n*/\n\n/*\n// ANCHOR: spec_fun1\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn test() {\n    assert(min(10, 20) == 10); // succeeds\n    assert(min(100, 200) == 100); // succeeds\n}\n// ANCHOR_END: spec_fun1\n*/\n\n// ANCHOR: spec_fun3\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nspec fn min3(x: int, y: int, z: int) -> int {\n    min(x, min(y, z))\n}\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n    ensures\n        m == min3(x as int, y as int, z as int),\n{\n    let mut m = x;\n    if y < m {\n        m = y;\n    }\n    if z < m {\n        m = z;\n    }\n    m\n}\n\nfn test() {\n    let m = compute_min3(10, 20, 30);\n    assert(m == 10);\n}\n\n// ANCHOR_END: spec_fun3\n/*\n// ANCHOR: spec_fun_mod1\nmod M1 {\n    use verus_builtin::*;\n\n    pub open spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod1\n\n// ANCHOR: spec_fun_mod2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x,y) <= x && min(x,y) <= y,\n    {}\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == min(10, 20)); // succeeds\n        assert(min(10, 20) == 10); // FAILS\n        proof {\n            lemma_min(10,20);\n        }\n        assert(min(10, 20) <= 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod2\n*/\n\n/*\n// ANCHOR: spec_fun_proof\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test() {\n        lemma_min(10, 20);\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: spec_fun_proof\n*/\n\n// ANCHOR: spec_fun_proof_block1\nfn test_consts_infer() {\n    let u: u8 = 1;\n    proof {\n        let i: int = 2;\n        let n: nat = 3;\n        assert(0 <= u < i < n < 4);\n    }\n}\n\n// ANCHOR_END: spec_fun_proof_block1\n// ANCHOR: spec_fun_proof_block2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        proof {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10);  // succeeds\n        assert(min(100, 200) == 100);  // succeeds\n    }\n\n}\n\n// ANCHOR_END: spec_fun_proof_block2\n/*\n// ANCHOR: assert_by\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10) by {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: assert_by\n*/\n\n/*\n// ANCHOR: determinism\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn s(i: int) -> int {\n        i + 1\n    }\n\n    pub proof fn p(i: int) -> int {\n        i + 1\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test_determinism() {\n        let s1 = s(10);\n        let s2 = s(10);\n        assert(s1 == s2); // succeeds\n\n        let p1 = p(10);\n        let p2 = p(10);\n        assert(p1 == p2); // FAILS\n    }\n}\n// ANCHOR_END: determinism\n*/\n\n// ANCHOR: recommends1\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n    (i - 1) as nat\n}\n\nproof fn test1() {\n    assert(f(0) == f(0));  // succeeds\n}\n\n// ANCHOR_END: recommends1\n/*\n// ANCHOR: recommends2\nproof fn test2() {\n    assert(f(0) <= f(1)); // FAILS\n}\n// ANCHOR_END: recommends2\n*/\n\n// ANCHOR: recommends3\nspec fn caller1() -> nat {\n    f(0)  // no note, warning, or error generated\n\n}\n\n// ANCHOR_END: recommends3\n// ANCHOR: recommends4\nspec(checked) fn caller2() -> nat {\n    f(0)  // generates a warning because of \"(checked)\"\n\n}\n\n// ANCHOR_END: recommends4\n/*\n// ANCHOR: ghost_abilities0\nfn divide_by_zero() {\n    let x: u8 = 1;\n    assert(x / 0 == x / 0); // succeeds in ghost code\n    let y = x / 0; // FAILS in exec code\n}\n// ANCHOR_END: ghost_abilities0\n*/\n\n// ANCHOR: ghost_abilities1\nmod MA {\n    // does not implement Copy\n    // does not allow construction by other modules\n    pub struct S {\n        private_field: u8,\n    }\n\n}\n\nmod MB {\n    use verus_builtin::*;\n    use crate::MA::*;\n\n    // construct a ghost S\n    spec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n        (s, s)\n    }\n\n}\n\n// ANCHOR_END: ghost_abilities1\n/*\n// ANCHOR: ghost_abilities2\nfn test(s: S) {\n    let pair = duplicate_S(s); // FAILS\n}\n// ANCHOR_END: ghost_abilities2\n*/\n\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "nonlinear_bitvec_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: bound_checking\nproof fn bound_check(x: u32, y: u32, z: u32)\n    requires\n        x <= 8,\n        y <= 8,\n{\n    assert(x * y <= 100) by (nonlinear_arith)\n        requires\n            x <= 10,\n            y <= 10;\n\n    assert(x * y <= 1000);\n}\n// ANCHOR_END: bound_checking\n\n// ANCHOR: bound_checking_func\nproof fn bound_check2(x: u32, y: u32, z: u32) by (nonlinear_arith)\n    requires\n        x <= 8,\n        y <= 8,\n    ensures\n        x * y <= 64\n{ }\n// ANCHOR_END: bound_checking_func\n\n// ANCHOR: de_morgan\nproof fn de_morgan_auto()\n    by (bit_vector)\n    ensures\n        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,\n        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,\n{\n}\n// ANCHOR_END: de_morgan\n\n// ANCHOR: bitvector_easy\nfn test_passes(b: u32) {\n    assert(b & 7 == b % 8) by (bit_vector);\n    assert(b & 0xff < 0x100) by (bit_vector);\n}\n// ANCHOR_END: bitvector_easy\n\n/*\n// ANCHOR: bitvector_fail\nfn test_fails(x: u32, y: u32)\n  requires x == y\n{\n  assert(x & 3 == y & 3) by(bit_vector);  // Fails\n}\n// ANCHOR_END: bitvector_fail\n*/\n\n// ANCHOR: bitvector_success\nfn test_success(x: u32, y: u32)\n    requires\n        x == y,\n{\n    assert(x & 3 == y & 3) by (bit_vector)\n        requires\n            x == y,\n    ;  // now x == y is available for the bit_vector proof\n}\n// ANCHOR_END: bitvector_success\n\n\n// ANCHOR: bitvector_spec_fn\nspec fn get_bit(val: u32, index: u32) -> bool {\n    0x1u32 & (val >> index) == 1\n}\n\nfn test_get_bit() {\n    assert(get_bit(128u32, 7)) by (bit_vector);\n}\n// ANCHOR_END: bitvector_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  proof fn de_morgan_auto() by(bit_vector) ensures forall | a : u32, b : u32 |\n#[trigger](!(a | b)) == !a & !b{\n  }\n  fn main();\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/nonlinear_bitvec.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1143, "minimize_time_ms": 370923, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 86, "minimized_LOC": 8, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 2, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 0.09302325581395349}, "labeling": {"segments": {"spec": "  proof fn de_morgan_auto() by(bit_vector) ensures forall | a : u32, b : u32 |", "proof": "proof fn de_morgan_auto() by(bit_vector) ensures forall | a : u32, b : u32 |\n#[trigger](!(a | b)) == !a & !b{"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: bound_checking\nproof fn bound_check(x: u32, y: u32, z: u32)\n    requires\n        x <= 8,\n        y <= 8,\n{\n    assert(x * y <= 100) by (nonlinear_arith)\n        requires\n            x <= 10,\n            y <= 10;\n\n    assert(x * y <= 1000);\n}\n// ANCHOR_END: bound_checking\n\n// ANCHOR: bound_checking_func\nproof fn bound_check2(x: u32, y: u32, z: u32) by (nonlinear_arith)\n    requires\n        x <= 8,\n        y <= 8,\n    ensures\n        x * y <= 64\n{ }\n// ANCHOR_END: bound_checking_func\n\n// ANCHOR: de_morgan\nproof fn de_morgan_auto()\n    by (bit_vector)\n    ensures\n        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,\n        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,\n{\n}\n// ANCHOR_END: de_morgan\n\n// ANCHOR: bitvector_easy\nfn test_passes(b: u32) {\n    assert(b & 7 == b % 8) by (bit_vector);\n    assert(b & 0xff < 0x100) by (bit_vector);\n}\n// ANCHOR_END: bitvector_easy\n\n/*\n// ANCHOR: bitvector_fail\nfn test_fails(x: u32, y: u32)\n  requires x == y\n{\n  assert(x & 3 == y & 3) by(bit_vector);  // Fails\n}\n// ANCHOR_END: bitvector_fail\n*/\n\n// ANCHOR: bitvector_success\nfn test_success(x: u32, y: u32)\n    requires\n        x == y,\n{\n    assert(x & 3 == y & 3) by (bit_vector)\n        requires\n            x == y,\n    ;  // now x == y is available for the bit_vector proof\n}\n// ANCHOR_END: bitvector_success\n\n\n// ANCHOR: bitvector_spec_fn\nspec fn get_bit(val: u32, index: u32) -> bool {\n    0x1u32 & (val >> index) == 1\n}\n\nfn test_get_bit() {\n    assert(get_bit(128u32, 7)) by (bit_vector);\n}\n// ANCHOR_END: bitvector_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  proof fn de_morgan_auto() by(bit_vector) ensures forall | a : u32, b : u32 |\n#[trigger](!(a | b)) == !a & !b{\n  }\n  fn main();\n}\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  proof fn de_morgan_auto() by(bit_vector) ensures forall | a : u32, b |\n(!(a | b)) == !a & !b{\n  }\n  fn main();\n}\n", "use verus_builtin::*;\n      use verus_builtin_macros::*;\n      verus !{\n       fn main();\n     }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "quants_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-warnings\n\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq::*};\n\nverus! {\n\n// ANCHOR: quants_finite\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_seq_5_is_evens(s: Seq<int>)\n    requires\n        s.len() == 5,\n        is_even(s[0]),\n        is_even(s[1]),\n        is_even(s[3]),\n        is_even(s[3]),\n        is_even(s[4]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_finite\n\nspec fn is_odd(i: int) -> bool {\n    i % 2 == 1\n}\n\n// ANCHOR: quants_recursion\nspec fn all_evens(s: Seq<int>) -> bool\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_even(s.last()) && all_evens(s.drop_last())\n    }\n}\n\nproof fn test_seq_recursive(s: Seq<int>)\n    requires\n        s.len() == 5,\n        all_evens(s),\n{\n    assert(is_even(s[3])) by {\n        reveal_with_fuel(all_evens, 2);\n    }\n}\n// ANCHOR_END: quants_recursion\n\n// ANCHOR: quants_use_forall\nproof fn test_use_forall(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_use_forall\n\n/*\n// ANCHOR: trigger_fails\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_use_forall_fail(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(s[3] % 2 == 0); // FAILS: doesn't trigger is_even(s[i])\n}\n// ANCHOR_END: trigger_fails\n*/\n\n// ANCHOR: test_use_forall_succeeds1\nproof fn test_use_forall_succeeds1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));  // triggers is_even(s[3])\n    assert(s[3] % 2 == 0);  // succeeds, because previous line already instantiated the forall\n}\n// ANCHOR_END: test_use_forall_succeeds1\n\n// ANCHOR: test_use_forall_succeeds2\nproof fn test_use_forall_succeeds2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]),\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds2\n\n/*\n// ANCHOR: test_use_forall_succeeds3\nproof fn test_use_forall_succeeds3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note\n{\n    assert(s[3] % 2 == 0); // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds3\n*/\n\n// ANCHOR: test_use_forall_succeeds4\nproof fn test_use_forall_succeeds4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            #![auto]\n            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds4\n\n/*\n// ANCHOR: test_use_forall_bad1\nproof fn test_use_forall_bad1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]),\n{\n    assert(s[3] % 2 == 0);\n}\n// ANCHOR_END: test_use_forall_bad1\n*/\n\n/*\n// ANCHOR: test_use_forall_bad2\nspec fn nonnegative(i: int) -> bool {\n    0 <= i\n}\n\nproof fn test_use_forall_bad2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]),\n{\n    assert(is_even(s[3])); // FAILS: doesn't trigger nonnegative(i)\n}\n// ANCHOR_END: test_use_forall_bad2\n*/\n\n// ANCHOR: test_distinct1\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nproof fn test_distinct1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]),\n{\n    assert(is_distinct(s[2], s[4]));\n}\n// ANCHOR_END: test_distinct1\n\n// ANCHOR: test_distinct2\nproof fn test_distinct2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct2\n\n// ANCHOR: test_distinct3\nproof fn test_distinct3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct3\n\n/*\n// ANCHOR: test_distinct_fail1\nproof fn test_distinct_fail1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct_fail1\n*/\n\n/*\n// ANCHOR: test_distinct_fail2\nproof fn test_distinct_fail2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]); // FAILS, because nothing matches is_even(i)\n}\n// ANCHOR_END: test_distinct_fail2\n*/\n\n// ANCHOR: test_distinct4\nproof fn test_distinct4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            #![trigger s[i], s[j]]\n            #![trigger is_even(i), is_even(j)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct4\n\n// ANCHOR: test_multitriggers\nproof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)\n    requires\n        5 <= a.len(),\n        a.len() == b.len(),\n        a.len() == c.len(),\n        forall|i: int, j: int|\n            #![trigger a[i], b[j]]\n            #![trigger a[i], c[j]]\n            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j],\n{\n    assert(a[2] != c[4]);  // succeeds, matches a[i], c[j]\n}\n// ANCHOR_END: test_multitriggers\n\n// ANCHOR: seq_update_different\nproof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {\n    assert(forall|i: int, j: int|\n        0 <= i < s.len() && 0 <= j < s.len() && i != j ==> s.update(j, a)[i] == s[i]);\n}\n// ANCHOR_END: seq_update_different\n\n// ANCHOR: test_sorted_good\nproof fn test_sorted_good(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_good\n\n/*\n// ANCHOR: test_sorted_bad1\nproof fn test_sorted_bad(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_bad1\n*/\n\n// ANCHOR: test_exists_succeeds\nproof fn test_exists_succeeds() {\n    assert(is_even(4));\n    assert(!is_even(5));\n    assert(is_even(6));\n    assert(exists|i: int| #[trigger] is_even(i));  // succeeds with witness i = 4 or i = 6\n}\n// ANCHOR_END: test_exists_succeeds\n\n/*\n// ANCHOR: test_exists_fails\nproof fn test_exists_fails() {\n    assert(exists|i: int| #[trigger] is_even(i)); // FAILS, no match for trigger\n}\n// ANCHOR_END: test_exists_fails\n*/\n\n// ANCHOR: test_choose_succeeds\nspec fn f(i: int) -> bool;\n\nproof fn test_choose_succeeds()\n    requires\n        exists|i: int| f(i),\n{\n    let i_witness = choose|i: int| f(i);\n    assert(f(i_witness));\n}\n// ANCHOR_END: test_choose_succeeds\n\n/*\n// ANCHOR: test_choose_fails\nproof fn test_choose_fails() {\n    let i_witness = choose|i: int| f(i);\n    assert(i_witness < 0 || i_witness >= 0); // i_witness is some integer\n    assert(f(i_witness)); // FAILS because we don't know exists|i: int| f(i)\n}\n// ANCHOR_END: test_choose_fails\n*/\n\n// ANCHOR: test_choose_same\nproof fn test_choose_same() {\n    let x = choose|i: int| f(i);\n    let y = choose|i: int| f(i);\n    assert(x == y);\n}\n// ANCHOR_END: test_choose_same\n\n// ANCHOR: test_choose_succeeds2\nspec fn less_than(x: int, y: int) -> bool {\n    x < y\n}\n\nproof fn test_choose_succeeds2() {\n    assert(less_than(3, 7));  // promote i = 3, i = 7 as a witness\n    let (x, y) = choose|i: int, j: int| less_than(i, j);\n    assert(x < y);\n}\n// ANCHOR_END: test_choose_succeeds2\n\n#[verusfmt::skip]\nmod M {\n#[allow(unused_imports)]\n\nuse verus_builtin::*;\n\n// ANCHOR: just_works\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nspec fn dummy(i: int) -> bool;\n\nproof fn prove_forall()\n    ensures\n        forall|i: int, j: int|\n            #![trigger dummy(i), dummy(j)]\n            is_distinct(i, j) ==> is_distinct(j, i),\n{\n    // proving the forall just works; the trigger is irrelevant\n}\n\nproof fn use_exists(x: int)\n    requires\n        exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5),\n{\n    // using the exists just works; the trigger is irrelevant\n    assert(x != 6);\n}\n// ANCHOR_END: just_works\n}\n\n// ANCHOR: hoist\nproof fn hoisted_forall(i: int, j: int)\n    ensures\n        is_distinct(i, j) ==> is_distinct(j, i),\n{\n}\n\nproof fn hoisted_exists(x: int, i: int)\n    requires\n        x == i + 1 && is_distinct(i, 5),\n{\n    assert(x != 6);\n}\n// ANCHOR_END: hoist\n\n#[verifier::external_body]\nproof fn lemma_even_f(i: int)\n    requires\n        is_even(i),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_even_f_fail1\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma\n{\n}\n// ANCHOR_END: test_even_f_fail1\n*/\n\n/*\n// ANCHOR: test_even_f_fail2\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    lemma_even_f(i); // ERROR: i is not in scope here\n}\n// ANCHOR_END: test_even_f_fail2\n*/\n\n// ANCHOR: test_even_f\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    assert forall|i: int| is_even(i) implies f(i) by {\n        // First, i is in scope here\n        // Second, we assume is_even(i) here\n        lemma_even_f(i);\n        // Finally, we have to prove f(i) here\n    }\n}\n// ANCHOR_END: test_even_f\n\nspec fn g(i: int, j: int) -> bool;\n\n#[verifier::external_body]\nproof fn lemma_g_proves_f(i: int, j: int)\n    requires\n        g(i, j),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_g_proves_f_fails\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, j); // ERROR: j is not in scope here\n}\n// ANCHOR_END: test_g_proves_f_fails\n*/\n\n// ANCHOR: test_g_proves_f\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, choose|j: int| g(i, j));\n}\n// ANCHOR_END: test_g_proves_f\n\n// ANCHOR: binary_search\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn main() {\n    let mut v: Vec<u64> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v[3] == 30);  // needed to trigger exists|i: int| ... k == v[i]\n    let r = binary_search(&v, 30);\n    assert(r == 3);\n}\n// ANCHOR_END: binary_search\n\n} // verus!\n", "minimized_code": " use vstd::{\n prelude::*, seq::*};\n   verus! {\n  spec fn is_even(i: int) -> bool {\n     i % 2 == 0 }\n  proof fn test_use_forall(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==>   \n#[trigger] is_even(s[i]),\n{\n     assert(is_even(s[3]));\n       assert(s[3] % 2 == 0);\n   }\n  proof fn test_use_forall_succeeds2(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==> is_even(  \n#[trigger] s[i]),\n{\n     assert(s[3] % 2 == 0);\n   }\n  fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)     requires         forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         exists|i: int| 0 <= i < v.len() && k == v[i],     ensures         r < v.len(),         k == v[r as int], {\n     let mut i1: usize = 0;\n     let mut i2: usize = v.len() - 1;\n     while i1 != i2         invariant             i2 < v.len(),             exists|i: int| i1 <= i <= i2 && k == v[i],             forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         decreases i2 - i1,     {         let ix = i1 + (i2 - i1) / 2;         if v[ix] < k {             i1 = ix + 1;         } else {             i2 = ix;         }     }\n     i1 }\n  fn main() {\n     let mut v: Vec<u64> = Vec::new();\n }\n  }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/quants.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1065, "minimize_time_ms": 337333, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 497, "minimized_LOC": 25, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::", "verus_builtin::"], "complexity_verus_tokens": 10, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 0.05030181086519115}, "labeling": {"segments": {"exec": " fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)     requires         forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         exists|i: int| 0 <= i < v.len() && k == v[i],     ensures         r < v.len(),         k == v[r as int], {\n\n fn main() {", "spec": "spec fn is_even(i: int) -> bool {\n\n  proof fn test_use_forall(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==>   \n\n  proof fn test_use_forall_succeeds2(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==> is_even(  \n\n  fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)     requires         forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         exists|i: int| 0 <= i < v.len() && k == v[i],     ensures         r < v.len(),         k == v[r as int], {\n\n     while i1 != i2         invariant             i2 < v.len(),             exists|i: int| i1 <= i <= i2 && k == v[i],             forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         decreases i2 - i1,     {         let ix = i1 + (i2 - i1) / 2;         if v[ix] < k {             i1 = ix + 1;         } else {             i2 = ix;         }     }", "proof": "proof fn test_use_forall(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==>   \n#[trigger] is_even(s[i]),\n{\n\nproof fn test_use_forall_succeeds2(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==> is_even(  \n#[trigger] s[i]),\n{"}}}, "all_snapshots": ["// rust_verify/tests/example.rs expect-warnings\n\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq::*};\n\nverus! {\n\n// ANCHOR: quants_finite\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_seq_5_is_evens(s: Seq<int>)\n    requires\n        s.len() == 5,\n        is_even(s[0]),\n        is_even(s[1]),\n        is_even(s[3]),\n        is_even(s[3]),\n        is_even(s[4]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_finite\n\nspec fn is_odd(i: int) -> bool {\n    i % 2 == 1\n}\n\n// ANCHOR: quants_recursion\nspec fn all_evens(s: Seq<int>) -> bool\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_even(s.last()) && all_evens(s.drop_last())\n    }\n}\n\nproof fn test_seq_recursive(s: Seq<int>)\n    requires\n        s.len() == 5,\n        all_evens(s),\n{\n    assert(is_even(s[3])) by {\n        reveal_with_fuel(all_evens, 2);\n    }\n}\n// ANCHOR_END: quants_recursion\n\n// ANCHOR: quants_use_forall\nproof fn test_use_forall(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_use_forall\n\n/*\n// ANCHOR: trigger_fails\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_use_forall_fail(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(s[3] % 2 == 0); // FAILS: doesn't trigger is_even(s[i])\n}\n// ANCHOR_END: trigger_fails\n*/\n\n// ANCHOR: test_use_forall_succeeds1\nproof fn test_use_forall_succeeds1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));  // triggers is_even(s[3])\n    assert(s[3] % 2 == 0);  // succeeds, because previous line already instantiated the forall\n}\n// ANCHOR_END: test_use_forall_succeeds1\n\n// ANCHOR: test_use_forall_succeeds2\nproof fn test_use_forall_succeeds2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]),\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds2\n\n/*\n// ANCHOR: test_use_forall_succeeds3\nproof fn test_use_forall_succeeds3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note\n{\n    assert(s[3] % 2 == 0); // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds3\n*/\n\n// ANCHOR: test_use_forall_succeeds4\nproof fn test_use_forall_succeeds4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            #![auto]\n            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds4\n\n/*\n// ANCHOR: test_use_forall_bad1\nproof fn test_use_forall_bad1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]),\n{\n    assert(s[3] % 2 == 0);\n}\n// ANCHOR_END: test_use_forall_bad1\n*/\n\n/*\n// ANCHOR: test_use_forall_bad2\nspec fn nonnegative(i: int) -> bool {\n    0 <= i\n}\n\nproof fn test_use_forall_bad2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]),\n{\n    assert(is_even(s[3])); // FAILS: doesn't trigger nonnegative(i)\n}\n// ANCHOR_END: test_use_forall_bad2\n*/\n\n// ANCHOR: test_distinct1\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nproof fn test_distinct1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]),\n{\n    assert(is_distinct(s[2], s[4]));\n}\n// ANCHOR_END: test_distinct1\n\n// ANCHOR: test_distinct2\nproof fn test_distinct2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct2\n\n// ANCHOR: test_distinct3\nproof fn test_distinct3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct3\n\n/*\n// ANCHOR: test_distinct_fail1\nproof fn test_distinct_fail1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct_fail1\n*/\n\n/*\n// ANCHOR: test_distinct_fail2\nproof fn test_distinct_fail2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]); // FAILS, because nothing matches is_even(i)\n}\n// ANCHOR_END: test_distinct_fail2\n*/\n\n// ANCHOR: test_distinct4\nproof fn test_distinct4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            #![trigger s[i], s[j]]\n            #![trigger is_even(i), is_even(j)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct4\n\n// ANCHOR: test_multitriggers\nproof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)\n    requires\n        5 <= a.len(),\n        a.len() == b.len(),\n        a.len() == c.len(),\n        forall|i: int, j: int|\n            #![trigger a[i], b[j]]\n            #![trigger a[i], c[j]]\n            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j],\n{\n    assert(a[2] != c[4]);  // succeeds, matches a[i], c[j]\n}\n// ANCHOR_END: test_multitriggers\n\n// ANCHOR: seq_update_different\nproof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {\n    assert(forall|i: int, j: int|\n        0 <= i < s.len() && 0 <= j < s.len() && i != j ==> s.update(j, a)[i] == s[i]);\n}\n// ANCHOR_END: seq_update_different\n\n// ANCHOR: test_sorted_good\nproof fn test_sorted_good(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_good\n\n/*\n// ANCHOR: test_sorted_bad1\nproof fn test_sorted_bad(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_bad1\n*/\n\n// ANCHOR: test_exists_succeeds\nproof fn test_exists_succeeds() {\n    assert(is_even(4));\n    assert(!is_even(5));\n    assert(is_even(6));\n    assert(exists|i: int| #[trigger] is_even(i));  // succeeds with witness i = 4 or i = 6\n}\n// ANCHOR_END: test_exists_succeeds\n\n/*\n// ANCHOR: test_exists_fails\nproof fn test_exists_fails() {\n    assert(exists|i: int| #[trigger] is_even(i)); // FAILS, no match for trigger\n}\n// ANCHOR_END: test_exists_fails\n*/\n\n// ANCHOR: test_choose_succeeds\nspec fn f(i: int) -> bool;\n\nproof fn test_choose_succeeds()\n    requires\n        exists|i: int| f(i),\n{\n    let i_witness = choose|i: int| f(i);\n    assert(f(i_witness));\n}\n// ANCHOR_END: test_choose_succeeds\n\n/*\n// ANCHOR: test_choose_fails\nproof fn test_choose_fails() {\n    let i_witness = choose|i: int| f(i);\n    assert(i_witness < 0 || i_witness >= 0); // i_witness is some integer\n    assert(f(i_witness)); // FAILS because we don't know exists|i: int| f(i)\n}\n// ANCHOR_END: test_choose_fails\n*/\n\n// ANCHOR: test_choose_same\nproof fn test_choose_same() {\n    let x = choose|i: int| f(i);\n    let y = choose|i: int| f(i);\n    assert(x == y);\n}\n// ANCHOR_END: test_choose_same\n\n// ANCHOR: test_choose_succeeds2\nspec fn less_than(x: int, y: int) -> bool {\n    x < y\n}\n\nproof fn test_choose_succeeds2() {\n    assert(less_than(3, 7));  // promote i = 3, i = 7 as a witness\n    let (x, y) = choose|i: int, j: int| less_than(i, j);\n    assert(x < y);\n}\n// ANCHOR_END: test_choose_succeeds2\n\n#[verusfmt::skip]\nmod M {\n#[allow(unused_imports)]\n\nuse verus_builtin::*;\n\n// ANCHOR: just_works\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nspec fn dummy(i: int) -> bool;\n\nproof fn prove_forall()\n    ensures\n        forall|i: int, j: int|\n            #![trigger dummy(i), dummy(j)]\n            is_distinct(i, j) ==> is_distinct(j, i),\n{\n    // proving the forall just works; the trigger is irrelevant\n}\n\nproof fn use_exists(x: int)\n    requires\n        exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5),\n{\n    // using the exists just works; the trigger is irrelevant\n    assert(x != 6);\n}\n// ANCHOR_END: just_works\n}\n\n// ANCHOR: hoist\nproof fn hoisted_forall(i: int, j: int)\n    ensures\n        is_distinct(i, j) ==> is_distinct(j, i),\n{\n}\n\nproof fn hoisted_exists(x: int, i: int)\n    requires\n        x == i + 1 && is_distinct(i, 5),\n{\n    assert(x != 6);\n}\n// ANCHOR_END: hoist\n\n#[verifier::external_body]\nproof fn lemma_even_f(i: int)\n    requires\n        is_even(i),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_even_f_fail1\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma\n{\n}\n// ANCHOR_END: test_even_f_fail1\n*/\n\n/*\n// ANCHOR: test_even_f_fail2\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    lemma_even_f(i); // ERROR: i is not in scope here\n}\n// ANCHOR_END: test_even_f_fail2\n*/\n\n// ANCHOR: test_even_f\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    assert forall|i: int| is_even(i) implies f(i) by {\n        // First, i is in scope here\n        // Second, we assume is_even(i) here\n        lemma_even_f(i);\n        // Finally, we have to prove f(i) here\n    }\n}\n// ANCHOR_END: test_even_f\n\nspec fn g(i: int, j: int) -> bool;\n\n#[verifier::external_body]\nproof fn lemma_g_proves_f(i: int, j: int)\n    requires\n        g(i, j),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_g_proves_f_fails\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, j); // ERROR: j is not in scope here\n}\n// ANCHOR_END: test_g_proves_f_fails\n*/\n\n// ANCHOR: test_g_proves_f\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, choose|j: int| g(i, j));\n}\n// ANCHOR_END: test_g_proves_f\n\n// ANCHOR: binary_search\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn main() {\n    let mut v: Vec<u64> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v[3] == 30);  // needed to trigger exists|i: int| ... k == v[i]\n    let r = binary_search(&v, 30);\n    assert(r == 3);\n}\n// ANCHOR_END: binary_search\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use vstd::{\n prelude::*, seq::*};\n   verus! {\n  spec fn is_even(i: int) -> bool {\n     i % 2 == 0 }\n  proof fn test_use_forall(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==>   \n#[trigger] is_even(s[i]),\n{\n     assert(is_even(s[3]));\n       assert(s[3] % 2 == 0);\n   }\n  proof fn test_use_forall_succeeds2(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==> is_even(  \n#[trigger] s[i]),\n{\n     assert(s[3] % 2 == 0);\n   }\n  fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)     requires         forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         exists|i: int| 0 <= i < v.len() && k == v[i],     ensures         r < v.len(),         k == v[r as int], {\n     let mut i1: usize = 0;\n     let mut i2: usize = v.len() - 1;\n     while i1 != i2         invariant             i2 < v.len(),             exists|i: int| i1 <= i <= i2 && k == v[i],             forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         decreases i2 - i1,     {         let ix = i1 + (i2 - i1) / 2;         if v[ix] < k {             i1 = ix + 1;         } else {             i2 = ix;         }     }\n     i1 }\n  fn main() {\n     let mut v: Vec<u64> = Vec::new();\n }\n  }\n", " use vstd::{\n       prelude::*, seq::*};\n          verus! {\n        fn main() ;\n        }\n", "use vstd::{prelude::*, *};\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "references_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    assert(x == 0);\n    assert(*immut_ref_x == 0);\n\n    // These point to different stack variables, but they compare equal.\n    assert(immut_ref_x == immut_ref_y);\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n    assert(y == 1);\n    modify_y(&mut y);\n    assert(y == 2);\n}\n// ANCHOR_END: mut\n\n// ANCHOR: requires\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n    assert(z == 1);\n}\n// ANCHOR_END: requires\n\n// ANCHOR: asserts\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n    assert(*old(a) == 0);\n    *a = *a + 1;\n    assert(*a == 1);\n    *a = *a + 1;\n    assert(*a == 2);\n    assert(*old(a) == 0);\n}\n\nfn asserts() \n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n    let mut i: u32 = 0;\n    while (*b > 0) \n        invariant\n            *b == (10 - i),\n        decreases *b,\n    {\n        *b = *b - 1;\n        i = i + 1;\n        assert(*b == (10 - i));\n    }\n    assert(*b == 0);\n    assert(*old(b) == 10);\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n    assert(d == 0);\n}\n// ANCHOR_END: complex\n\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    assert(x == 0);\n    assert(*immut_ref_x == 0);\n\n    // These point to different stack variables, but they compare equal.\n    assert(immut_ref_x == immut_ref_y);\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n    assert(y == 1);\n    modify_y(&mut y);\n    assert(y == 2);\n}\n// ANCHOR_END: mut\n\n// ANCHOR: requires\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n    assert(z == 1);\n}\n// ANCHOR_END: requires\n\n// ANCHOR: asserts\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n    assert(*old(a) == 0);\n    *a = *a + 1;\n    assert(*a == 1);\n    *a = *a + 1;\n    assert(*a == 2);\n    assert(*old(a) == 0);\n}\n\nfn asserts() \n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n    let mut i: u32 = 0;\n    while (*b > 0) \n        invariant\n            *b == (10 - i),\n        decreases *b,\n    {\n        *b = *b - 1;\n        i = i + 1;\n        assert(*b == (10 - i));\n    }\n    assert(*b == 0);\n    assert(*old(b) == 10);\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n    assert(d == 0);\n}\n// ANCHOR_END: complex\n\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/references.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 846, "minimize_time_ms": 154025, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 111, "minimized_LOC": 111, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.6, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn immutable_references_example() {\n\n\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n\n\nfn mutable_example()\n{\n\n\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n\n\nfn caller()\n{\n\n\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n\n\nfn asserts() \n{\n\n\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n\n\nfn complex_example()\n{\n\n\nfn main() {", "spec": "    ensures *a == 2\n\n// ANCHOR: requires\n\n    requires *old(a) < u32::MAX,\n\n    ensures *a == *old(a) + 1,\n\n// ANCHOR_END: requires\n\n    requires *old(a) == 0\n\n    requires\n\n    ensures\n\n        invariant\n\n        decreases *b,"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    assert(x == 0);\n    assert(*immut_ref_x == 0);\n\n    // These point to different stack variables, but they compare equal.\n    assert(immut_ref_x == immut_ref_y);\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n    assert(y == 1);\n    modify_y(&mut y);\n    assert(y == 2);\n}\n// ANCHOR_END: mut\n\n// ANCHOR: requires\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n    assert(z == 1);\n}\n// ANCHOR_END: requires\n\n// ANCHOR: asserts\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n    assert(*old(a) == 0);\n    *a = *a + 1;\n    assert(*a == 1);\n    *a = *a + 1;\n    assert(*a == 2);\n    assert(*old(a) == 0);\n}\n\nfn asserts() \n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n    let mut i: u32 = 0;\n    while (*b > 0) \n        invariant\n            *b == (10 - i),\n        decreases *b,\n    {\n        *b = *b - 1;\n        i = i + 1;\n        assert(*b == (10 - i));\n    }\n    assert(*b == 0);\n    assert(*old(b) == 10);\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n    assert(d == 0);\n}\n// ANCHOR_END: complex\n\n\nfn main() {\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "requires_ensures_edit_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n/*\n// ANCHOR: init\nfn octuple(x1: i8) -> i8 {\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: init\n\nfn main() {\n}\n\n// ANCHOR: pre1\nfn octuple(x1: i8) -> i8\n    requires\n        -64 <= x1,\n        x1 < 64,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre1\n\nfn main() {\n}\n\n// ANCHOR: pre2\nfn octuple(x1: i8) -> i8\n    requires\n        -16 <= x1,\n        x1 < 16,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre2\n\nfn main() {\n}\n\n// ANCHOR: pre3\nfn main() {\n    let n = octuple(20);\n}\n// ANCHOR_END: pre3\n\n// ANCHOR: pre4\nfn main() {\n    let n = octuple(10);\n}\n// ANCHOR_END: pre4\n*/\n\n// ANCHOR: post1\nfn main() {\n    let n = octuple(10);\n    assert(n == 80);\n}\n// ANCHOR_END: post1\n\n// ANCHOR: post2\nfn octuple(x1: i8) -> (x8: i8)\n    requires\n        -16 <= x1,\n        x1 < 16,\n    ensures\n        x8 == 8 * x1,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: post2\n\n} // verus!\n", "minimized_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n/*\n// ANCHOR: init\nfn octuple(x1: i8) -> i8 {\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: init\n\nfn main() {\n}\n\n// ANCHOR: pre1\nfn octuple(x1: i8) -> i8\n    requires\n        -64 <= x1,\n        x1 < 64,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre1\n\nfn main() {\n}\n\n// ANCHOR: pre2\nfn octuple(x1: i8) -> i8\n    requires\n        -16 <= x1,\n        x1 < 16,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre2\n\nfn main() {\n}\n\n// ANCHOR: pre3\nfn main() {\n    let n = octuple(20);\n}\n// ANCHOR_END: pre3\n\n// ANCHOR: pre4\nfn main() {\n    let n = octuple(10);\n}\n// ANCHOR_END: pre4\n*/\n\n// ANCHOR: post1\nfn main() {\n    let n = octuple(10);\n    assert(n == 80);\n}\n// ANCHOR_END: post1\n\n// ANCHOR: post2\nfn octuple(x1: i8) -> (x8: i8)\n    requires\n        -16 <= x1,\n        x1 < 16,\n    ensures\n        x8 == 8 * x1,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: post2\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/requires_ensures_edit.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 892, "minimize_time_ms": 152494, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 84, "minimized_LOC": 84, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 6, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn octuple(x1: i8) -> i8 {\n\n\nfn main() {\n\n\nfn octuple(x1: i8) -> i8\n    requires\n        -64 <= x1,\n        x1 < 64,\n{\n\n\nfn main() {\n\n\nfn octuple(x1: i8) -> i8\n    requires\n        -16 <= x1,\n        x1 < 16,\n{\n\n\nfn main() {\n\n\nfn main() {\n\n\nfn main() {\n\n\nfn main() {\n\n\nfn octuple(x1: i8) -> (x8: i8)\n    requires\n        -16 <= x1,\n        x1 < 16,\n    ensures\n        x8 == 8 * x1,\n{", "spec": "    requires\n\n    requires\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n/*\n// ANCHOR: init\nfn octuple(x1: i8) -> i8 {\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: init\n\nfn main() {\n}\n\n// ANCHOR: pre1\nfn octuple(x1: i8) -> i8\n    requires\n        -64 <= x1,\n        x1 < 64,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre1\n\nfn main() {\n}\n\n// ANCHOR: pre2\nfn octuple(x1: i8) -> i8\n    requires\n        -16 <= x1,\n        x1 < 16,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre2\n\nfn main() {\n}\n\n// ANCHOR: pre3\nfn main() {\n    let n = octuple(20);\n}\n// ANCHOR_END: pre3\n\n// ANCHOR: pre4\nfn main() {\n    let n = octuple(10);\n}\n// ANCHOR_END: pre4\n*/\n\n// ANCHOR: post1\nfn main() {\n    let n = octuple(10);\n    assert(n == 80);\n}\n// ANCHOR_END: post1\n\n// ANCHOR: post2\nfn octuple(x1: i8) -> (x8: i8)\n    requires\n        -16 <= x1,\n        x1 < 16,\n    ensures\n        x8 == 8 * x1,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: post2\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "strings_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "minimized_code": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/guide/strings.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 839, "minimize_time_ms": 663, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": true, "readability_score": 0.8999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn get_char() {\n\n\nfn literal_eq() {\n\n\nfn str_view() {\n\n\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n\n\nfn test() {", "spec": "    requires s@ =~= \"Hello\"@,", "proof": "proof {\n        reveal_strlit(\"hello world\");\n    }\n\nproof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n\nproof {\n        reveal_strlit(\"ABC\");\n    }\n\nproof {\n        reveal_strlit(\"C\");\n    }"}}}, "all_snapshots": []}
{"id": "imo_1988_6_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n// IMO 1988, #6.\n// Let a and b be positive integers such that (a^2 + b^2) / (ab + 1) is an integer.\n// Prove that it is a perfect square.\n//\n// This is a classic example of \"vieta jumping\". It makes a decent exercise\n// utilizing nonlinear arithmetic in Verus.\n// Closely following the solution given here:\n//    https://en.wikipedia.org/wiki/Vieta_jumping#Geometric_interpretation\n\nverus! {\n\nproof fn vieta_jump(b: int, c: int, x: int)\n    by (nonlinear_arith)\n    requires\n        x * x - b * x + c == 0,\n    ensures\n        ({\n            let y = b - x;\n            y * y - b * y + c == 0 && y * x == c\n        }),\n{\n}\n\nproof fn sqrt2_contradiction(a: int)\n    requires\n        a * a == 2,\n    ensures\n        false,\n{\n    assert(a * a == 2 ==> false) by (nonlinear_arith);\n}\n\nproof fn is_perfect_square_wlog(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n        q > 2,\n        a < b,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 0int,\n{\n    if a == 0 {\n        assert(a * a == 0);\n        assert(a * b == 0);\n        return b;\n    } else {\n        assert(b * b - (q * a) * b + (a * a - q) == 0) by {\n            assert((a * b + 1) * q == (a * b) * q + q) by (nonlinear_arith);\n            assert((a * b) * q == (q * a) * b) by (nonlinear_arith);\n        }\n        vieta_jump(q * a, a * a - q, b);\n        let b1 = q * a - b;\n        assert(b1 * b1 - (q * a) * b1 + (a * a - q) == 0);\n        assert(a * a + b1 * b1 == (a * b1 + 1) * q) by {\n            assert((a * b1 + 1) * q == (a * b1) * q + q) by (nonlinear_arith);\n            assert((a * b1) * q == (q * a) * b1) by (nonlinear_arith);\n        }\n        assert(b1 < b) by {\n            assert(a > 0);\n            assert(b1 * b == a * a - q);\n            assert(b1 <= a) by {\n                assert(a >= 0 && b >= 0 && b1 > a && b > a ==> b1 * b >= a * a)\n                    by (nonlinear_arith);\n            }\n        }\n        assert(b1 >= 0) by {\n            assert(a * a + b1 * b1 == (a * b1 + 1) * q && a >= 1 && q > 2 ==> a * b1 + 1 > 0)\n                by (nonlinear_arith);\n            assert(a * b1 + 1 > 0 && a > 0 ==> b1 >= 0) by (nonlinear_arith);\n        }\n        return is_perfect_square(a, b1, q);\n    }\n}\n\n// Main result\nproof fn is_perfect_square(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 1int,\n{\n    if q < 0 {\n        assert(a >= 0 && b >= 0 && a * a + b * b == (a * b + 1) * q ==> q >= 0)\n            by (nonlinear_arith);\n        assert(false);\n        return 0;\n    } else if q == 0 {\n        return 0;\n    } else if q == 1 {\n        return 1;\n    } else if q == 2 {\n        assert((a - b) * (a - b) == 2) by (nonlinear_arith)\n            requires\n                a * a + b * b == (a * b + 1) * 2,\n        ;\n        sqrt2_contradiction(a - b);\n        return 0;\n    } else {\n        assert(q > 2);\n        if a == b {\n            assert(2 * a * a == a * a + a * a) by (nonlinear_arith);\n            assert(q > 2 ==> (a * a + 1) * q >= (a * a + 1) * 2) by (nonlinear_arith);\n            assert(false);\n            return 0;\n        } else if a < b {\n            return is_perfect_square_wlog(a, b, q);\n        } else {\n            assert(a > b);\n            return is_perfect_square_wlog(b, a, q);\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  fn vieta_jump(b\n                      : int, c\n                      : int, x\n                      : int) by(nonlinear_arith)\n    requires c == 0, ({\n    let y = x;\n    x == c\n  }){}\n  fn main();\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/imo_1988_6.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1300, "minimize_time_ms": 245154, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 127, "minimized_LOC": 13, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 1, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.10236220472440945}, "labeling": {"segments": {"exec": " fn vieta_jump(b\n                      : int, c\n                      : int, x\n                      : int) by(nonlinear_arith)\n    requires c == 0, ({", "spec": "    requires c == 0, ({"}}}, "all_snapshots": ["#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n// IMO 1988, #6.\n// Let a and b be positive integers such that (a^2 + b^2) / (ab + 1) is an integer.\n// Prove that it is a perfect square.\n//\n// This is a classic example of \"vieta jumping\". It makes a decent exercise\n// utilizing nonlinear arithmetic in Verus.\n// Closely following the solution given here:\n//    https://en.wikipedia.org/wiki/Vieta_jumping#Geometric_interpretation\n\nverus! {\n\nproof fn vieta_jump(b: int, c: int, x: int)\n    by (nonlinear_arith)\n    requires\n        x * x - b * x + c == 0,\n    ensures\n        ({\n            let y = b - x;\n            y * y - b * y + c == 0 && y * x == c\n        }),\n{\n}\n\nproof fn sqrt2_contradiction(a: int)\n    requires\n        a * a == 2,\n    ensures\n        false,\n{\n    assert(a * a == 2 ==> false) by (nonlinear_arith);\n}\n\nproof fn is_perfect_square_wlog(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n        q > 2,\n        a < b,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 0int,\n{\n    if a == 0 {\n        assert(a * a == 0);\n        assert(a * b == 0);\n        return b;\n    } else {\n        assert(b * b - (q * a) * b + (a * a - q) == 0) by {\n            assert((a * b + 1) * q == (a * b) * q + q) by (nonlinear_arith);\n            assert((a * b) * q == (q * a) * b) by (nonlinear_arith);\n        }\n        vieta_jump(q * a, a * a - q, b);\n        let b1 = q * a - b;\n        assert(b1 * b1 - (q * a) * b1 + (a * a - q) == 0);\n        assert(a * a + b1 * b1 == (a * b1 + 1) * q) by {\n            assert((a * b1 + 1) * q == (a * b1) * q + q) by (nonlinear_arith);\n            assert((a * b1) * q == (q * a) * b1) by (nonlinear_arith);\n        }\n        assert(b1 < b) by {\n            assert(a > 0);\n            assert(b1 * b == a * a - q);\n            assert(b1 <= a) by {\n                assert(a >= 0 && b >= 0 && b1 > a && b > a ==> b1 * b >= a * a)\n                    by (nonlinear_arith);\n            }\n        }\n        assert(b1 >= 0) by {\n            assert(a * a + b1 * b1 == (a * b1 + 1) * q && a >= 1 && q > 2 ==> a * b1 + 1 > 0)\n                by (nonlinear_arith);\n            assert(a * b1 + 1 > 0 && a > 0 ==> b1 >= 0) by (nonlinear_arith);\n        }\n        return is_perfect_square(a, b1, q);\n    }\n}\n\n// Main result\nproof fn is_perfect_square(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 1int,\n{\n    if q < 0 {\n        assert(a >= 0 && b >= 0 && a * a + b * b == (a * b + 1) * q ==> q >= 0)\n            by (nonlinear_arith);\n        assert(false);\n        return 0;\n    } else if q == 0 {\n        return 0;\n    } else if q == 1 {\n        return 1;\n    } else if q == 2 {\n        assert((a - b) * (a - b) == 2) by (nonlinear_arith)\n            requires\n                a * a + b * b == (a * b + 1) * 2,\n        ;\n        sqrt2_contradiction(a - b);\n        return 0;\n    } else {\n        assert(q > 2);\n        if a == b {\n            assert(2 * a * a == a * a + a * a) by (nonlinear_arith);\n            assert(q > 2 ==> (a * a + 1) * q >= (a * a + 1) * 2) by (nonlinear_arith);\n            assert(false);\n            return 0;\n        } else if a < b {\n            return is_perfect_square_wlog(a, b, q);\n        } else {\n            assert(a > b);\n            return is_perfect_square_wlog(b, a, q);\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  fn vieta_jump(b\n                      : int, c\n                      : int, x\n                      : int) by(nonlinear_arith)\n    requires c == 0, ({\n    let y = x;\n    x == c\n  }){}\n  fn main();\n}\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  fn vieta_jump(c\n                      : int, x\n                      : int)\n    requires {}\n  fn main();\n}\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{\n  fn main();\n}\n"]}
{"id": "impl_basic_cc0b9f7d", "original_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Car {\n    four_doors: bool,\n    passengers: u64,\n}\n\nimpl Car {\n    fn new() -> Car {\n        ensures(|result: Car| equal(result.passengers, 201));\n        Car { four_doors: false, passengers: 201 }\n    }\n\n    fn get_passengers(&self) -> u64 {\n        ensures(|result: u64| result == self.passengers);\n        self.passengers\n    }\n}\n\n#[derive(PartialEq, Eq)]\nstruct TemplateCar<V> {\n    four_doors: bool,\n    passengers: u64,\n    the_v: V,\n}\n\nimpl<V> TemplateCar<V> {\n    fn template_new(v: V) -> (result: TemplateCar<V>)\n        ensures\n            result.passengers == 205 && result.the_v == v,\n    {\n        TemplateCar::<V> { four_doors: false, passengers: 205, the_v: v }\n    }\n\n    fn template_get_passengers(&self) -> (result: u64)\n        ensures\n            result == self.passengers,\n    {\n        self.passengers\n    }\n\n    fn template_get_v(self) -> (result: V)\n        ensures\n            result == self.the_v,\n    {\n        self.the_v\n    }\n}\n\nfn main() {\n    let c = Car { four_doors: true, passengers: 3 };\n    let p = c.get_passengers();\n    assert(p < 4);\n    let c2 = Car::new();\n    let p2 = c2.get_passengers();\n    assert(p2 == 201);\n    let c3 = TemplateCar::<u64>::template_new(5);\n    let p3 = c3.template_get_passengers();\n    assert(p3 == 205);\n    let v = c3.template_get_v();\n    assert(v == 5);\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Car {\n    four_doors: bool,\n    passengers: u64,\n}\n\nimpl Car {\n    fn new() -> Car {\n        ensures(|result: Car| equal(result.passengers, 201));\n        Car { four_doors: false, passengers: 201 }\n    }\n\n    fn get_passengers(&self) -> u64 {\n        ensures(|result: u64| result == self.passengers);\n        self.passengers\n    }\n}\n\n#[derive(PartialEq, Eq)]\nstruct TemplateCar<V> {\n    four_doors: bool,\n    passengers: u64,\n    the_v: V,\n}\n\nimpl<V> TemplateCar<V> {\n    fn template_new(v: V) -> (result: TemplateCar<V>)\n        ensures\n            result.passengers == 205 && result.the_v == v,\n    {\n        TemplateCar::<V> { four_doors: false, passengers: 205, the_v: v }\n    }\n\n    fn template_get_passengers(&self) -> (result: u64)\n        ensures\n            result == self.passengers,\n    {\n        self.passengers\n    }\n\n    fn template_get_v(self) -> (result: V)\n        ensures\n            result == self.the_v,\n    {\n        self.the_v\n    }\n}\n\nfn main() {\n    let c = Car { four_doors: true, passengers: 3 };\n    let p = c.get_passengers();\n    assert(p < 4);\n    let c2 = Car::new();\n    let p2 = c2.get_passengers();\n    assert(p2 == 201);\n    let c3 = TemplateCar::<u64>::template_new(5);\n    let p3 = c3.template_get_passengers();\n    assert(p3 == 205);\n    let v = c3.template_get_v();\n    assert(v == 5);\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/impl_basic.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 787, "minimize_time_ms": 153572, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 7, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 2, "segments": {"exec": " fn new() -> Car {\n\n fn get_passengers(&self) -> u64 {\n\n fn template_new(v: V) -> (result: TemplateCar<V>)\n        ensures\n            result.passengers == 205 && result.the_v == v,\n    {\n\n fn template_get_passengers(&self) -> (result: u64)\n        ensures\n            result == self.passengers,\n    {\n\n fn template_get_v(self) -> (result: V)\n        ensures\n            result == self.the_v,\n    {\n\n\nfn main() {", "spec": "        ensures(|result: Car| equal(result.passengers, 201));\n\n        ensures(|result: u64| result == self.passengers);\n\n        ensures\n\n        ensures\n\n        ensures"}}}, "all_snapshots": ["use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Car {\n    four_doors: bool,\n    passengers: u64,\n}\n\nimpl Car {\n    fn new() -> Car {\n        ensures(|result: Car| equal(result.passengers, 201));\n        Car { four_doors: false, passengers: 201 }\n    }\n\n    fn get_passengers(&self) -> u64 {\n        ensures(|result: u64| result == self.passengers);\n        self.passengers\n    }\n}\n\n#[derive(PartialEq, Eq)]\nstruct TemplateCar<V> {\n    four_doors: bool,\n    passengers: u64,\n    the_v: V,\n}\n\nimpl<V> TemplateCar<V> {\n    fn template_new(v: V) -> (result: TemplateCar<V>)\n        ensures\n            result.passengers == 205 && result.the_v == v,\n    {\n        TemplateCar::<V> { four_doors: false, passengers: 205, the_v: v }\n    }\n\n    fn template_get_passengers(&self) -> (result: u64)\n        ensures\n            result == self.passengers,\n    {\n        self.passengers\n    }\n\n    fn template_get_v(self) -> (result: V)\n        ensures\n            result == self.the_v,\n    {\n        self.the_v\n    }\n}\n\nfn main() {\n    let c = Car { four_doors: true, passengers: 3 };\n    let p = c.get_passengers();\n    assert(p < 4);\n    let c2 = Car::new();\n    let p2 = c2.get_passengers();\n    assert(p2 == 201);\n    let c3 = TemplateCar::<u64>::template_new(5);\n    let p3 = c3.template_get_passengers();\n    assert(p3 == 205);\n    let v = c3.template_get_v();\n    assert(v == 5);\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\n         use verus_builtin_macros::*;\n         verus! {        struct Car ;        impl Car {}        struct TemplateCar<V> {           four_doors: bool,     passengers: u64,     the_v: V, }        impl<V> TemplateCar<V> {}        fn main() ;        }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "circular_by_d_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs ignore --- currently times out\n\n// lemma originally from @hayley-leblanc\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\npub proof fn lemma_mod_subtract_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (x + y) % d,\n    ensures\n        (small_x + y - tmp1) % d == 0,\n{\n}\n\npub proof fn lemma_mod_subtract(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        (x % d) + y >= d,\n        0 <= y < d,\n    ensures\n        (x % d) + y - d == (x + y) % d,\n{\n    let small_x = x % d;\n    let small_y = y % d;\n    let tmp1 = (x + y) % d;\n    lemma_mod_subtract_helper(x, y, d, small_x, small_y, tmp1);\n}\n\npub proof fn lemma_mod_difference_equal_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n    tmp2: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (small_y - small_x) % d,\n        tmp2 == (y - x) % d,\n    ensures\n        (tmp1 - tmp2) % d == 0,\n{\n}\n\npub proof fn lemma_mod_difference_equal(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x <= y,\n        x % d <= y % d,\n        y - x < d,\n    ensures\n        y % d - x % d == y - x,\n{\n    let small_x = x % d;\n    let small_y = y % d;\n    let tmp1 = (small_y - small_x) % d;\n    let tmp2 = (y - x) % d;\n    lemma_mod_difference_equal_helper(x, y, d, small_x, small_y, tmp1, tmp2);\n}\n\npub proof fn lemma_mod_wrapped_len_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (d - small_x + small_y) % d,\n    ensures\n        (y - x - tmp1) % d == 0,\n{\n}\n\npub proof fn lemma_mod_wrapped_len(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x <= y,\n        x % d > y % d,\n        y - x < d,\n    ensures\n        d - (x % d) + (y % d) == y - x,\n{\n    let small_x = x % d;\n    let small_y = y % d;\n    let tmp1 = (d - small_x + small_y) % d;\n    lemma_mod_wrapped_len_helper(x, y, d, small_x, small_y, tmp1);\n}\n\npub proof fn lemma_mod_between_helper(x: int, y: int, d: int)\n    by (integer_ring)\n    requires\n        d != 0,\n    ensures\n        (x % d - y % d) % d == (x - y) % d,\n{\n}\n\n// note that below two facts are from the helper function, and the rest are done by this following function.\n// x % d - y % d == x - y  mod d\n// y % d - z % d == y - z  mod d\npub proof fn lemma_mod_between(d: int, x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x % d < y % d,\n        y - x <= d,\n        x <= z < y,\n    ensures\n        x % d <= z % d < y % d,\n{\n    lemma_mod_between_helper(x, z, d);\n    lemma_mod_between_helper(y, z, d);\n}\n\n// TODO: with the new, stable approach to AIR variable naming, this lemma now times out\n//       it is likely it was already unstable, and the new naming triggered the instability\n// note that below two facts are from the helper function, and the rest are done by this following function.\n// x % d - y % d == x - y  mod d\n// y % d - z % d == y - z  mod d\npub proof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        y % d < x % d,\n        y - x <= d,\n        x <= z < y,\n    ensures\n        z % d < y % d || z % d >= x % d,\n{\n    lemma_mod_between_helper(x, z, d);\n    lemma_mod_between_helper(z, y, d);\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs ignore --- currently times out\n\n// lemma originally from @hayley-leblanc\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\npub proof fn lemma_mod_subtract_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (x + y) % d,\n    ensures\n        (small_x + y - tmp1) % d == 0,\n{\n}\n\npub proof fn lemma_mod_subtract(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        (x % d) + y >= d,\n        0 <= y < d,\n    ensures\n        (x % d) + y - d == (x + y) % d,\n{\n    let small_x = x % d;\n    let small_y = y % d;\n    let tmp1 = (x + y) % d;\n    lemma_mod_subtract_helper(x, y, d, small_x, small_y, tmp1);\n}\n\npub proof fn lemma_mod_difference_equal_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n    tmp2: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (small_y - small_x) % d,\n        tmp2 == (y - x) % d,\n    ensures\n        (tmp1 - tmp2) % d == 0,\n{\n}\n\npub proof fn lemma_mod_difference_equal(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x <= y,\n        x % d <= y % d,\n        y - x < d,\n    ensures\n        y % d - x % d == y - x,\n{\n    let small_x = x % d;\n    let small_y = y % d;\n    let tmp1 = (small_y - small_x) % d;\n    let tmp2 = (y - x) % d;\n    lemma_mod_difference_equal_helper(x, y, d, small_x, small_y, tmp1, tmp2);\n}\n\npub proof fn lemma_mod_wrapped_len_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (d - small_x + small_y) % d,\n    ensures\n        (y - x - tmp1) % d == 0,\n{\n}\n\npub proof fn lemma_mod_wrapped_len(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x <= y,\n        x % d > y % d,\n        y - x < d,\n    ensures\n        d - (x % d) + (y % d) == y - x,\n{\n    let small_x = x % d;\n    let small_y = y % d;\n    let tmp1 = (d - small_x + small_y) % d;\n    lemma_mod_wrapped_len_helper(x, y, d, small_x, small_y, tmp1);\n}\n\npub proof fn lemma_mod_between_helper(x: int, y: int, d: int)\n    by (integer_ring)\n    requires\n        d != 0,\n    ensures\n        (x % d - y % d) % d == (x - y) % d,\n{\n}\n\n// note that below two facts are from the helper function, and the rest are done by this following function.\n// x % d - y % d == x - y  mod d\n// y % d - z % d == y - z  mod d\npub proof fn lemma_mod_between(d: int, x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x % d < y % d,\n        y - x <= d,\n        x <= z < y,\n    ensures\n        x % d <= z % d < y % d,\n{\n    lemma_mod_between_helper(x, z, d);\n    lemma_mod_between_helper(y, z, d);\n}\n\n// TODO: with the new, stable approach to AIR variable naming, this lemma now times out\n//       it is likely it was already unstable, and the new naming triggered the instability\n// note that below two facts are from the helper function, and the rest are done by this following function.\n// x % d - y % d == x - y  mod d\n// y % d - z % d == y - z  mod d\npub proof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        y % d < x % d,\n        y - x <= d,\n        x <= z < y,\n    ensures\n        z % d < y % d || z % d >= x % d,\n{\n    lemma_mod_between_helper(x, z, d);\n    lemma_mod_between_helper(z, y, d);\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/integer_ring/circular_by_d.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 524, "verus_errors": [{"error_type": "Other", "error_text": "Please cargo build with `--features singular` to use integer_ring attribute ()", "message": "VerusErrorType.Other: Please cargo build with `--features singular` to use integer_ring attribute ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxg1ueicv", "lines": [10, 17], "label": null, "text": [{"text": "pub proof fn lemma_mod_subtract_helper(", "highlight_start": 1, "highlight_end": 40}, {"text": "    x: int,", "highlight_start": 1, "highlight_end": 12}, {"text": "    y: int,", "highlight_start": 1, "highlight_end": 12}, {"text": "    d: int,", "highlight_start": 1, "highlight_end": 12}, {"text": "    small_x: int,", "highlight_start": 1, "highlight_end": 18}, {"text": "    small_y: int,", "highlight_start": 1, "highlight_end": 18}, {"text": "    tmp1: int,", "highlight_start": 1, "highlight_end": 15}, {"text": ")", "highlight_start": 1, "highlight_end": 2}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 165, "minimized_LOC": 165, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 29, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 5, "segments": {"exec": "\nfn main() {", "spec": "    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures", "proof": "proof fn lemma_mod_subtract_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (x + y) % d,\n    ensures\n        (small_x + y - tmp1) % d == 0,\n{\n\nproof fn lemma_mod_subtract(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        (x % d) + y >= d,\n        0 <= y < d,\n    ensures\n        (x % d) + y - d == (x + y) % d,\n{\n\nproof fn lemma_mod_difference_equal_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n    tmp2: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (small_y - small_x) % d,\n        tmp2 == (y - x) % d,\n    ensures\n        (tmp1 - tmp2) % d == 0,\n{\n\nproof fn lemma_mod_difference_equal(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x <= y,\n        x % d <= y % d,\n        y - x < d,\n    ensures\n        y % d - x % d == y - x,\n{\n\nproof fn lemma_mod_wrapped_len_helper(\n    x: int,\n    y: int,\n    d: int,\n    small_x: int,\n    small_y: int,\n    tmp1: int,\n)\n    by (integer_ring)\n    requires\n        d != 0,\n        small_x == x % d,\n        small_y == y % d,\n        tmp1 == (d - small_x + small_y) % d,\n    ensures\n        (y - x - tmp1) % d == 0,\n{\n\nproof fn lemma_mod_wrapped_len(x: int, y: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x <= y,\n        x % d > y % d,\n        y - x < d,\n    ensures\n        d - (x % d) + (y % d) == y - x,\n{\n\nproof fn lemma_mod_between_helper(x: int, y: int, d: int)\n    by (integer_ring)\n    requires\n        d != 0,\n    ensures\n        (x % d - y % d) % d == (x - y) % d,\n{\n\nproof fn lemma_mod_between(d: int, x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        x % d < y % d,\n        y - x <= d,\n        x <= z < y,\n    ensures\n        x % d <= z % d < y % d,\n{\n\nproof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n        y % d < x % d,\n        y - x <= d,\n        x <= z < y,\n    ensures\n        z % d < y % d || z % d >= x % d,\n{"}}}, "all_snapshots": []}
{"id": "integer_ring_cc0b9f7d", "original_code": "// most of the codes are copied from: https://github.com/utaal/verified-nrkernel/blob/main/page-table/lib.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nproof fn mod_of_mul_int(a: int, b: int)\n    by (integer_ring)\n    requires b != 0,\n    ensures (a * b) % b == 0,\n{\n}\n\nproof fn mod_of_mul(a: nat, b: nat)\n    by (nonlinear_arith)\n    requires\n        b > 0,\n    ensures\n        (a * b) % b == 0,\n{\n    mod_of_mul_int(a as int, b as int);\n    // if a == 0 {}\n    // else {\n    //     assert(a > 0);\n    //     assert(b > 0);\n    //     assert(a*b > 0);\n    //     assert( (a*b) % b >= 0);\n    // }\n}\n\npub proof fn mod_add_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        a % c == 0,\n        b % c == 0,\n    ensures\n        (a + b) % c == 0,\n{\n}\n\npub proof fn mod_add_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % c == 0,\n        b % c == 0,\n        c > 0,\n    ensures\n        (a + b) % c == 0,\n{\n    mod_add_zero_int(a as int, b as int, c as int);\n}\n\npub proof fn subtract_mod_aligned_int(a: int, b: int)\n    by (integer_ring)\n    requires\n        b != 0,\n    ensures\n        (a - (a % b)) % b == 0,\n{\n}\n\npub proof fn subtract_mod_aligned(a: nat, b: nat)\n    by (nonlinear_arith)\n    requires\n        0 < b,\n    ensures\n        (a - (a % b)) % (b as int) == 0,\n{\n    subtract_mod_aligned_int(a as int, b as int);\n}\n\npub proof fn mod_mult_zero_implies_mod_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        b != 0,\n        b * c != 0,\n        a % (b * c) == 0,\n    ensures\n        a % b == 0,\n{\n}\n\npub proof fn mod_mult_zero_implies_mod_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % (b * c) == 0,\n        b > 0,\n        c > 0,\n    ensures\n        a % b == 0,\n{\n    mod_mult_zero_implies_mod_zero_int(a as int, b as int, c as int);\n}\n\npub proof fn subtract_mod_eq_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        a % c == 0,\n        b % c == 0,\n    ensures\n        (b - a) % c == 0,\n{\n}\n\npub proof fn subtract_mod_eq_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % c == 0,\n        b % c == 0,\n        a <= b,\n        c > 0,\n    ensures\n        (b - a) % (c as int) == 0,\n{\n    subtract_mod_eq_zero_int(a as int, b as int, c as int);\n}\n\npub proof fn multiple_offsed_mod_gt_0_int(a: int, b: int, c: int, ac: int, bc: int, abc: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        ac == a % c,\n        bc == b % c,\n        abc == (a - b) % c,\n    ensures\n        (ac - bc - abc) % c == 0,\n{\n}\n\npub proof fn multiple_offsed_mod_gt_0(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a > b,\n        c > 0,\n        b % c == 0,\n        a % c > 0,\n    ensures\n        (a - b) % (c as int) > 0,\n{\n    multiple_offsed_mod_gt_0_int(\n        a as int,\n        b as int,\n        c as int,\n        (a % c) as int,\n        (b % c) as int,\n        ((a - b) % (c as int)) as int,\n    );\n}\n\n// currently can't use Singular for this proof\n// however, I think we can extend the encoding for div\npub proof fn FundamentalDivMod(x: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n    ensures\n        x == d * (x / d) + (x % d),\n{\n}\n\n// can't use Singular for this proof because of bound\n// however, there might be a way to encode this as an \"axiom\" in Singular\n// add an equality to the ring whenever we can prove a bound from Z3\npub proof fn LemmaSmallMod(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        x >= 0,\n        m > 0,\n        x < m,\n    ensures\n        x % m == x,\n{\n}\n\n// can't use Singular for this proof because of bound\npub proof fn LemmaModBasics(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n    ensures\n        m % m == 0,\n        (x % m) % m == x % m,\n        0 <= x % m,\n        x % m < m,\n{\n}\n\n// can't use Singular for this proof because of bound\npub proof fn LemmaModDecreases(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n        x >= 0,\n    ensures\n        x % m <= x,\n{\n}\n\n// can't use Singular for this proof because of bound\npub proof fn LemmaModIsZero(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n        x > 0,\n        x % m == 0,\n    ensures\n        m <= x,\n{\n}\n\npub proof fn LemmaModMultiplesBasic(x: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (x * m) % m == 0,\n{\n}\n\npub proof fn LemmaModMultipleVanish(b: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (b + m) % m == b % m,\n        (b - m) % m == b % m,\n{\n}\n\npub proof fn LemmaModMultiplesVanish(a: int, b: int, m: int)\n    by (integer_ring)\n    requires m != 0,\n    ensures\n        (b + a * m) % m == b % m,\n        (b + m * a) % m == b % m,\n        (b - a * m) % m == b % m,\n        (b - m * a) % m == b % m,\n{\n}\n\npub proof fn LemmaAddModNoopLeft(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        ((x % m) + y) % m == (x + y) % m,\n{\n}\n\npub proof fn LemmaSubModNoopRight(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (x - (y % m)) % m == (x - y) % m,\n{\n}\n\npub proof fn LemmaModNegNeg(x: int, d: int)\n    by (integer_ring)\n    requires\n        d != 0,\n    ensures\n        x % d == (x * (1 - d)) % d,\n{\n}\n\npub proof fn LemmaMulModNoopRight(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        x * (y % m) % m == (x * y) % m,\n{\n}\n\npub proof fn LemmaMulModNoopGeneral(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        ((x % m) * y) % m == (x * y) % m,\n        (x * (y % m)) % m == (x * y) % m,\n        ((x % m) * (y % m)) % m == (x * y) % m,\n{\n}\n\npub proof fn LemmaMulIsDistributive(x: int, y: int, z: int)\n    by (integer_ring)\n    ensures\n        x * (y + z) == x * y + x * z,\n        x * (y - z) == x * y - x * z,\n        (y + z) * x == y * x + z * x,\n        (y - z) * x == y * x - z * x,\n        x * (y + z) == (y + z) * x,\n        x * (y - z) == (y - z) * x,\n        x * y == y * x,\n        x * z == z * x,\n{\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// most of the codes are copied from: https://github.com/utaal/verified-nrkernel/blob/main/page-table/lib.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nproof fn mod_of_mul_int(a: int, b: int)\n    by (integer_ring)\n    requires b != 0,\n    ensures (a * b) % b == 0,\n{\n}\n\nproof fn mod_of_mul(a: nat, b: nat)\n    by (nonlinear_arith)\n    requires\n        b > 0,\n    ensures\n        (a * b) % b == 0,\n{\n    mod_of_mul_int(a as int, b as int);\n    // if a == 0 {}\n    // else {\n    //     assert(a > 0);\n    //     assert(b > 0);\n    //     assert(a*b > 0);\n    //     assert( (a*b) % b >= 0);\n    // }\n}\n\npub proof fn mod_add_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        a % c == 0,\n        b % c == 0,\n    ensures\n        (a + b) % c == 0,\n{\n}\n\npub proof fn mod_add_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % c == 0,\n        b % c == 0,\n        c > 0,\n    ensures\n        (a + b) % c == 0,\n{\n    mod_add_zero_int(a as int, b as int, c as int);\n}\n\npub proof fn subtract_mod_aligned_int(a: int, b: int)\n    by (integer_ring)\n    requires\n        b != 0,\n    ensures\n        (a - (a % b)) % b == 0,\n{\n}\n\npub proof fn subtract_mod_aligned(a: nat, b: nat)\n    by (nonlinear_arith)\n    requires\n        0 < b,\n    ensures\n        (a - (a % b)) % (b as int) == 0,\n{\n    subtract_mod_aligned_int(a as int, b as int);\n}\n\npub proof fn mod_mult_zero_implies_mod_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        b != 0,\n        b * c != 0,\n        a % (b * c) == 0,\n    ensures\n        a % b == 0,\n{\n}\n\npub proof fn mod_mult_zero_implies_mod_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % (b * c) == 0,\n        b > 0,\n        c > 0,\n    ensures\n        a % b == 0,\n{\n    mod_mult_zero_implies_mod_zero_int(a as int, b as int, c as int);\n}\n\npub proof fn subtract_mod_eq_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        a % c == 0,\n        b % c == 0,\n    ensures\n        (b - a) % c == 0,\n{\n}\n\npub proof fn subtract_mod_eq_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % c == 0,\n        b % c == 0,\n        a <= b,\n        c > 0,\n    ensures\n        (b - a) % (c as int) == 0,\n{\n    subtract_mod_eq_zero_int(a as int, b as int, c as int);\n}\n\npub proof fn multiple_offsed_mod_gt_0_int(a: int, b: int, c: int, ac: int, bc: int, abc: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        ac == a % c,\n        bc == b % c,\n        abc == (a - b) % c,\n    ensures\n        (ac - bc - abc) % c == 0,\n{\n}\n\npub proof fn multiple_offsed_mod_gt_0(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a > b,\n        c > 0,\n        b % c == 0,\n        a % c > 0,\n    ensures\n        (a - b) % (c as int) > 0,\n{\n    multiple_offsed_mod_gt_0_int(\n        a as int,\n        b as int,\n        c as int,\n        (a % c) as int,\n        (b % c) as int,\n        ((a - b) % (c as int)) as int,\n    );\n}\n\n// currently can't use Singular for this proof\n// however, I think we can extend the encoding for div\npub proof fn FundamentalDivMod(x: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n    ensures\n        x == d * (x / d) + (x % d),\n{\n}\n\n// can't use Singular for this proof because of bound\n// however, there might be a way to encode this as an \"axiom\" in Singular\n// add an equality to the ring whenever we can prove a bound from Z3\npub proof fn LemmaSmallMod(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        x >= 0,\n        m > 0,\n        x < m,\n    ensures\n        x % m == x,\n{\n}\n\n// can't use Singular for this proof because of bound\npub proof fn LemmaModBasics(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n    ensures\n        m % m == 0,\n        (x % m) % m == x % m,\n        0 <= x % m,\n        x % m < m,\n{\n}\n\n// can't use Singular for this proof because of bound\npub proof fn LemmaModDecreases(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n        x >= 0,\n    ensures\n        x % m <= x,\n{\n}\n\n// can't use Singular for this proof because of bound\npub proof fn LemmaModIsZero(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n        x > 0,\n        x % m == 0,\n    ensures\n        m <= x,\n{\n}\n\npub proof fn LemmaModMultiplesBasic(x: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (x * m) % m == 0,\n{\n}\n\npub proof fn LemmaModMultipleVanish(b: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (b + m) % m == b % m,\n        (b - m) % m == b % m,\n{\n}\n\npub proof fn LemmaModMultiplesVanish(a: int, b: int, m: int)\n    by (integer_ring)\n    requires m != 0,\n    ensures\n        (b + a * m) % m == b % m,\n        (b + m * a) % m == b % m,\n        (b - a * m) % m == b % m,\n        (b - m * a) % m == b % m,\n{\n}\n\npub proof fn LemmaAddModNoopLeft(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        ((x % m) + y) % m == (x + y) % m,\n{\n}\n\npub proof fn LemmaSubModNoopRight(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (x - (y % m)) % m == (x - y) % m,\n{\n}\n\npub proof fn LemmaModNegNeg(x: int, d: int)\n    by (integer_ring)\n    requires\n        d != 0,\n    ensures\n        x % d == (x * (1 - d)) % d,\n{\n}\n\npub proof fn LemmaMulModNoopRight(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        x * (y % m) % m == (x * y) % m,\n{\n}\n\npub proof fn LemmaMulModNoopGeneral(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        ((x % m) * y) % m == (x * y) % m,\n        (x * (y % m)) % m == (x * y) % m,\n        ((x % m) * (y % m)) % m == (x * y) % m,\n{\n}\n\npub proof fn LemmaMulIsDistributive(x: int, y: int, z: int)\n    by (integer_ring)\n    ensures\n        x * (y + z) == x * y + x * z,\n        x * (y - z) == x * y - x * z,\n        (y + z) * x == y * x + z * x,\n        (y - z) * x == y * x - z * x,\n        x * (y + z) == (y + z) * x,\n        x * (y - z) == (y - z) * x,\n        x * y == y * x,\n        x * z == z * x,\n{\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/integer_ring/integer_ring.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 625, "verus_errors": [{"error_type": "Other", "error_text": "Please cargo build with `--features singular` to use integer_ring attribute ()", "message": "VerusErrorType.Other: Please cargo build with `--features singular` to use integer_ring attribute ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpcrk3wo4v", "lines": [11, 11], "label": null, "text": [{"text": "proof fn mod_of_mul_int(a: int, b: int)", "highlight_start": 7, "highlight_end": 40}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 311, "minimized_LOC": 311, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 84, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 16, "segments": {"exec": "\nfn main() {", "spec": "    requires b != 0,\n\n    ensures (a * b) % b == 0,\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires m != 0,\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    ensures", "proof": "proof fn mod_of_mul_int(a: int, b: int)\n    by (integer_ring)\n    requires b != 0,\n    ensures (a * b) % b == 0,\n{\n\nproof fn mod_of_mul(a: nat, b: nat)\n    by (nonlinear_arith)\n    requires\n        b > 0,\n    ensures\n        (a * b) % b == 0,\n{\n\nproof fn mod_add_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        a % c == 0,\n        b % c == 0,\n    ensures\n        (a + b) % c == 0,\n{\n\nproof fn mod_add_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % c == 0,\n        b % c == 0,\n        c > 0,\n    ensures\n        (a + b) % c == 0,\n{\n\nproof fn subtract_mod_aligned_int(a: int, b: int)\n    by (integer_ring)\n    requires\n        b != 0,\n    ensures\n        (a - (a % b)) % b == 0,\n{\n\nproof fn subtract_mod_aligned(a: nat, b: nat)\n    by (nonlinear_arith)\n    requires\n        0 < b,\n    ensures\n        (a - (a % b)) % (b as int) == 0,\n{\n\nproof fn mod_mult_zero_implies_mod_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        b != 0,\n        b * c != 0,\n        a % (b * c) == 0,\n    ensures\n        a % b == 0,\n{\n\nproof fn mod_mult_zero_implies_mod_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % (b * c) == 0,\n        b > 0,\n        c > 0,\n    ensures\n        a % b == 0,\n{\n\nproof fn subtract_mod_eq_zero_int(a: int, b: int, c: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        a % c == 0,\n        b % c == 0,\n    ensures\n        (b - a) % c == 0,\n{\n\nproof fn subtract_mod_eq_zero(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a % c == 0,\n        b % c == 0,\n        a <= b,\n        c > 0,\n    ensures\n        (b - a) % (c as int) == 0,\n{\n\nproof fn multiple_offsed_mod_gt_0_int(a: int, b: int, c: int, ac: int, bc: int, abc: int)\n    by (integer_ring)\n    requires\n        c != 0,\n        ac == a % c,\n        bc == b % c,\n        abc == (a - b) % c,\n    ensures\n        (ac - bc - abc) % c == 0,\n{\n\nproof fn multiple_offsed_mod_gt_0(a: nat, b: nat, c: nat)\n    by (nonlinear_arith)\n    requires\n        a > b,\n        c > 0,\n        b % c == 0,\n        a % c > 0,\n    ensures\n        (a - b) % (c as int) > 0,\n{\n\nproof fn FundamentalDivMod(x: int, d: int)\n    by (nonlinear_arith)\n    requires\n        d > 0,\n    ensures\n        x == d * (x / d) + (x % d),\n{\n\nproof fn LemmaSmallMod(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        x >= 0,\n        m > 0,\n        x < m,\n    ensures\n        x % m == x,\n{\n\nproof fn LemmaModBasics(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n    ensures\n        m % m == 0,\n        (x % m) % m == x % m,\n        0 <= x % m,\n        x % m < m,\n{\n\nproof fn LemmaModDecreases(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n        x >= 0,\n    ensures\n        x % m <= x,\n{\n\nproof fn LemmaModIsZero(x: int, m: int)\n    by (nonlinear_arith)\n    requires\n        m > 0,\n        x > 0,\n        x % m == 0,\n    ensures\n        m <= x,\n{\n\nproof fn LemmaModMultiplesBasic(x: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (x * m) % m == 0,\n{\n\nproof fn LemmaModMultipleVanish(b: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (b + m) % m == b % m,\n        (b - m) % m == b % m,\n{\n\nproof fn LemmaModMultiplesVanish(a: int, b: int, m: int)\n    by (integer_ring)\n    requires m != 0,\n    ensures\n        (b + a * m) % m == b % m,\n        (b + m * a) % m == b % m,\n        (b - a * m) % m == b % m,\n        (b - m * a) % m == b % m,\n{\n\nproof fn LemmaAddModNoopLeft(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        ((x % m) + y) % m == (x + y) % m,\n{\n\nproof fn LemmaSubModNoopRight(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        (x - (y % m)) % m == (x - y) % m,\n{\n\nproof fn LemmaModNegNeg(x: int, d: int)\n    by (integer_ring)\n    requires\n        d != 0,\n    ensures\n        x % d == (x * (1 - d)) % d,\n{\n\nproof fn LemmaMulModNoopRight(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        x * (y % m) % m == (x * y) % m,\n{\n\nproof fn LemmaMulModNoopGeneral(x: int, y: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n    ensures\n        ((x % m) * y) % m == (x * y) % m,\n        (x * (y % m)) % m == (x * y) % m,\n        ((x % m) * (y % m)) % m == (x * y) % m,\n{\n\nproof fn LemmaMulIsDistributive(x: int, y: int, z: int)\n    by (integer_ring)\n    ensures\n        x * (y + z) == x * y + x * z,\n        x * (y - z) == x * y - x * z,\n        (y + z) * x == y * x + z * x,\n        (y - z) * x == y * x - z * x,\n        x * (y + z) == (y + z) * x,\n        x * (y - z) == (y - z) * x,\n        x * y == y * x,\n        x * z == z * x,\n{"}}}, "all_snapshots": []}
{"id": "integer_ring_bound_check_cc0b9f7d", "original_code": "// testcases and examples are ported from below two files\n// 1. https://github.com/secure-foundations/dafny/blob/b402d2aeb6129603277e35fcef33bf1024f4b217/Test/gb_test.dfy\n// 2. https://github.com/secure-foundations/veri-titan/blob/master/lib/generic_mm_lemmas.dfy\n//\n// With references from:\n// https://github.com/secure-foundations/libraries/blob/master/src/NonlinearArithmetic/Mul.dfy\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nproof fn ModAfterMul(x: int, y: int, z: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n        (x - y) % m == 0,\n    ensures\n        (x * z - y * z) % m == 0,\n{\n}\n\n// bound check lemmas\n#[verifier::external_body]\nproof fn LemmaMulUpperBound(x: int, XBound: int, y: int, YBound: int)\n    by (nonlinear_arith) {\n    requires([x <= XBound, y <= YBound, 0 <= x, 0 <= y]);\n    ensures(x * y <= XBound * YBound);\n}\n\nproof fn LemmaMulStayPositive(x: int, y: int)\n    by (nonlinear_arith)\n    requires\n        0 <= x,\n        0 <= y,\n    ensures\n        0 <= x * y,\n{\n}\n\nproof fn LemmaInequalityAfterMul(x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        x <= y,\n        0 <= z,\n    ensures\n        x * z <= y * z,\n{\n}\n\nproof fn ModAfterMul_u32(x: u32, y: u32, z: u32, m: u32)\n    requires\n        m > 0,\n        (x - y) % (m as int) == 0,\n        x >= y,\n        x <= 0xffff,\n        y <= 0xffff,\n        z <= 0xffff,\n        m <= 0xffff,\n    ensures\n        (x * z - y * z) % (m as int) == 0,\n{\n    ModAfterMul(x as int, y as int, z as int, m as int);\n    // below are for bound checks\n    // every single operation is in bound: x*z, y*z, (x*z - y*z)\n    LemmaMulUpperBound(x as int, 0xffff as int, z as int, 0xffff as int);\n    LemmaMulStayPositive(x as int, z as int);\n    // assert( (x as int) * (z as int) == ( (x*z) as int));\n    LemmaMulUpperBound(y as int, 0xffff as int, z as int, 0xffff as int);\n    LemmaMulStayPositive(y as int, z as int);\n    // assert( (y as int) * (z as int) == ( (y*z) as int));\n    LemmaInequalityAfterMul(y as int, x as int, z as int);\n    // assert( (((x*z - y*z) as int) % (m as int)) ==  (((x*z) as int) - ((y*z) as int)) % (m as int));\n}\n\nproof fn ModAfterMul_u32_with_assert_by_nonlinear(x: u32, y: u32, z: u32, m: u32)\n    requires\n        m > 0,\n        (x - y) % (m as int) == 0,\n        x >= y,\n        x <= 0xffff,\n        y <= 0xffff,\n        z <= 0xffff,\n        m <= 0xffff,\n    ensures\n        (x * z - y * z) % (m as int) == 0,\n{\n    ModAfterMul(x as int, y as int, z as int, m as int);\n    assert_nonlinear_by(\n        {\n            requires([x <= 0xffff, z <= 0xffff]);\n            ensures((x as int) * (z as int) == ((x * z) as int));\n            assert(0 <= (x as int) * (z as int));\n            assert((x as int) * (z as int) <= 0xffff * 0xffff);\n        },\n    );\n    assert((x as int) * (z as int) == ((x * z) as int));\n    assert_nonlinear_by(\n        {\n            requires([y <= 0xffff, z <= 0xffff]);\n            ensures((y as int) * (z as int) == ((y * z) as int));\n            assert(0 <= (y as int) * (z as int));\n            assert((y as int) * (z as int) <= 0xffff * 0xffff);\n        },\n    );\n    assert((y as int) * (z as int) == ((y * z) as int));\n    // below `assert_nonlinear_by` timeouts now in newer z3\n    // assert_nonlinear_by({\n    //     requires([\n    //         x <= 0xffff,\n    //         y <= 0xffff,\n    //         z <= 0xffff,\n    //         ((x as int) * (z as int) == ( (x*z) as int)),\n    //         ((y as int) * (z as int) == ( (y*z) as int)),\n    //         (y <= x),\n    //         (0 <= z),\n    //     ]);\n    //     ensures(y*z <= x*z);\n    // });\n    LemmaInequalityAfterMul(y as int, x as int, z as int);\n    assert(y * z <= x * z);\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// testcases and examples are ported from below two files\n// 1. https://github.com/secure-foundations/dafny/blob/b402d2aeb6129603277e35fcef33bf1024f4b217/Test/gb_test.dfy\n// 2. https://github.com/secure-foundations/veri-titan/blob/master/lib/generic_mm_lemmas.dfy\n//\n// With references from:\n// https://github.com/secure-foundations/libraries/blob/master/src/NonlinearArithmetic/Mul.dfy\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nproof fn ModAfterMul(x: int, y: int, z: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n        (x - y) % m == 0,\n    ensures\n        (x * z - y * z) % m == 0,\n{\n}\n\n// bound check lemmas\n#[verifier::external_body]\nproof fn LemmaMulUpperBound(x: int, XBound: int, y: int, YBound: int)\n    by (nonlinear_arith) {\n    requires([x <= XBound, y <= YBound, 0 <= x, 0 <= y]);\n    ensures(x * y <= XBound * YBound);\n}\n\nproof fn LemmaMulStayPositive(x: int, y: int)\n    by (nonlinear_arith)\n    requires\n        0 <= x,\n        0 <= y,\n    ensures\n        0 <= x * y,\n{\n}\n\nproof fn LemmaInequalityAfterMul(x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        x <= y,\n        0 <= z,\n    ensures\n        x * z <= y * z,\n{\n}\n\nproof fn ModAfterMul_u32(x: u32, y: u32, z: u32, m: u32)\n    requires\n        m > 0,\n        (x - y) % (m as int) == 0,\n        x >= y,\n        x <= 0xffff,\n        y <= 0xffff,\n        z <= 0xffff,\n        m <= 0xffff,\n    ensures\n        (x * z - y * z) % (m as int) == 0,\n{\n    ModAfterMul(x as int, y as int, z as int, m as int);\n    // below are for bound checks\n    // every single operation is in bound: x*z, y*z, (x*z - y*z)\n    LemmaMulUpperBound(x as int, 0xffff as int, z as int, 0xffff as int);\n    LemmaMulStayPositive(x as int, z as int);\n    // assert( (x as int) * (z as int) == ( (x*z) as int));\n    LemmaMulUpperBound(y as int, 0xffff as int, z as int, 0xffff as int);\n    LemmaMulStayPositive(y as int, z as int);\n    // assert( (y as int) * (z as int) == ( (y*z) as int));\n    LemmaInequalityAfterMul(y as int, x as int, z as int);\n    // assert( (((x*z - y*z) as int) % (m as int)) ==  (((x*z) as int) - ((y*z) as int)) % (m as int));\n}\n\nproof fn ModAfterMul_u32_with_assert_by_nonlinear(x: u32, y: u32, z: u32, m: u32)\n    requires\n        m > 0,\n        (x - y) % (m as int) == 0,\n        x >= y,\n        x <= 0xffff,\n        y <= 0xffff,\n        z <= 0xffff,\n        m <= 0xffff,\n    ensures\n        (x * z - y * z) % (m as int) == 0,\n{\n    ModAfterMul(x as int, y as int, z as int, m as int);\n    assert_nonlinear_by(\n        {\n            requires([x <= 0xffff, z <= 0xffff]);\n            ensures((x as int) * (z as int) == ((x * z) as int));\n            assert(0 <= (x as int) * (z as int));\n            assert((x as int) * (z as int) <= 0xffff * 0xffff);\n        },\n    );\n    assert((x as int) * (z as int) == ((x * z) as int));\n    assert_nonlinear_by(\n        {\n            requires([y <= 0xffff, z <= 0xffff]);\n            ensures((y as int) * (z as int) == ((y * z) as int));\n            assert(0 <= (y as int) * (z as int));\n            assert((y as int) * (z as int) <= 0xffff * 0xffff);\n        },\n    );\n    assert((y as int) * (z as int) == ((y * z) as int));\n    // below `assert_nonlinear_by` timeouts now in newer z3\n    // assert_nonlinear_by({\n    //     requires([\n    //         x <= 0xffff,\n    //         y <= 0xffff,\n    //         z <= 0xffff,\n    //         ((x as int) * (z as int) == ( (x*z) as int)),\n    //         ((y as int) * (z as int) == ( (y*z) as int)),\n    //         (y <= x),\n    //         (0 <= z),\n    //     ]);\n    //     ensures(y*z <= x*z);\n    // });\n    LemmaInequalityAfterMul(y as int, x as int, z as int);\n    assert(y * z <= x * z);\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/integer_ring/integer_ring_bound_check.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 586, "verus_errors": [{"error_type": "Other", "error_text": "Please cargo build with `--features singular` to use integer_ring attribute ()", "message": "VerusErrorType.Other: Please cargo build with `--features singular` to use integer_ring attribute ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmptwck1s8m", "lines": [16, 16], "label": null, "text": [{"text": "proof fn ModAfterMul(x: int, y: int, z: int, m: int)", "highlight_start": 7, "highlight_end": 53}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 130, "minimized_LOC": 130, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 26, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"requires_count": 4, "ensures_count": 7, "segments": {"exec": "\nfn main() {", "spec": "    requires\n\n    ensures\n\n    requires([x <= XBound, y <= YBound, 0 <= x, 0 <= y]);\n\n    ensures(x * y <= XBound * YBound);\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n            requires([x <= 0xffff, z <= 0xffff]);\n\n            ensures((x as int) * (z as int) == ((x * z) as int));\n\n            requires([y <= 0xffff, z <= 0xffff]);\n\n            ensures((y as int) * (z as int) == ((y * z) as int));\n\n    //     requires([\n\n    //     ensures(y*z <= x*z);", "proof": "proof fn ModAfterMul(x: int, y: int, z: int, m: int)\n    by (integer_ring)\n    requires\n        m != 0,\n        (x - y) % m == 0,\n    ensures\n        (x * z - y * z) % m == 0,\n{\n\nproof fn LemmaMulUpperBound(x: int, XBound: int, y: int, YBound: int)\n    by (nonlinear_arith) {\n\nproof fn LemmaMulStayPositive(x: int, y: int)\n    by (nonlinear_arith)\n    requires\n        0 <= x,\n        0 <= y,\n    ensures\n        0 <= x * y,\n{\n\nproof fn LemmaInequalityAfterMul(x: int, y: int, z: int)\n    by (nonlinear_arith)\n    requires\n        x <= y,\n        0 <= z,\n    ensures\n        x * z <= y * z,\n{\n\nproof fn ModAfterMul_u32(x: u32, y: u32, z: u32, m: u32)\n    requires\n        m > 0,\n        (x - y) % (m as int) == 0,\n        x >= y,\n        x <= 0xffff,\n        y <= 0xffff,\n        z <= 0xffff,\n        m <= 0xffff,\n    ensures\n        (x * z - y * z) % (m as int) == 0,\n{\n\nproof fn ModAfterMul_u32_with_assert_by_nonlinear(x: u32, y: u32, z: u32, m: u32)\n    requires\n        m > 0,\n        (x - y) % (m as int) == 0,\n        x >= y,\n        x <= 0xffff,\n        y <= 0xffff,\n        z <= 0xffff,\n        m <= 0xffff,\n    ensures\n        (x * z - y * z) % (m as int) == 0,\n{"}}}, "all_snapshots": []}
{"id": "integers_cc0b9f7d", "original_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n    assert(n >= 0);\n    assert(u >= 0);\n    assert(n + n >= 0);\n    assert((add(u, u) as int) < 256);\n    assert(u < 100 ==> (add(u, u) as int) < 250);\n    assert(add1_int(u as int) == u as int + 1);\n    // assert(add1_int(u) == (u + 1) as int); // FAILS\n    assert(add1_nat(u as nat) == u as nat + 1);\n    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n    assert(n0 >= 0);\n    assert(add1_nat_opaque(5) >= 0);\n    // assert(i / 2 <= n); // FAILS\n    assert(n / 2 <= n);\n    assert(u / 2 <= u);\n    assert(u % 10 < 10);\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n    assert(u3 > 100); // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n", "minimized_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n    assert(n >= 0);\n    assert(u >= 0);\n    assert(n + n >= 0);\n    assert((add(u, u) as int) < 256);\n    assert(u < 100 ==> (add(u, u) as int) < 250);\n    assert(add1_int(u as int) == u as int + 1);\n    // assert(add1_int(u) == (u + 1) as int); // FAILS\n    assert(add1_nat(u as nat) == u as nat + 1);\n    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n    assert(n0 >= 0);\n    assert(add1_nat_opaque(5) >= 0);\n    // assert(i / 2 <= n); // FAILS\n    assert(n / 2 <= n);\n    assert(u / 2 <= u);\n    assert(u % 10 < 10);\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n    assert(u3 > 100); // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/integers.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 607, "minimize_time_ms": 152647, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 65, "minimized_LOC": 65, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 8, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {\n\n\nfn typing(u: u64, i: int, n: nat) -> int {", "spec": "spec fn add1_int(i: int) -> int {\n\nspec fn add1_nat(i: nat) -> nat {\n\nspec fn add1_nat_opaque(i: nat) -> nat {\n\n    ensures", "proof": "proof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n\nproof fn test1(i: int, n: nat, u: u8) {"}}}, "all_snapshots": ["use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n    assert(n >= 0);\n    assert(u >= 0);\n    assert(n + n >= 0);\n    assert((add(u, u) as int) < 256);\n    assert(u < 100 ==> (add(u, u) as int) < 250);\n    assert(add1_int(u as int) == u as int + 1);\n    // assert(add1_int(u) == (u + 1) as int); // FAILS\n    assert(add1_nat(u as nat) == u as nat + 1);\n    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n    assert(n0 >= 0);\n    assert(add1_nat_opaque(5) >= 0);\n    // assert(i / 2 <= n); // FAILS\n    assert(n / 2 <= n);\n    assert(u / 2 <= u);\n    assert(u % 10 < 10);\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n    assert(u3 > 100); // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "mergesort_cc0b9f7d", "original_code": "use vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq_lib::group_seq_properties;\n\nverus! {\n\npub open spec fn is_sorted(v: &Vec<u64>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> #[trigger] v[i] <= #[trigger] v[j]\n}\n\nfn extend_from_idx(r: &mut Vec<u64>, v: &Vec<u64>, start: usize)\n    requires\n        start < v.len(),\n    ensures\n        r@ == old(r)@ + v@.subrange(start as int, v.len() as int),\n{\n    for i in start..v.len()\n        invariant\n            r@ =~= old(r)@ + v@.subrange(start as int, i as int),\n    {\n        r.push(v[i]);\n    }\n}\n\npub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)\n    ensures\n        #[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(),\n{\n    s2.to_multiset_ensures();\n    if s2.len() == 0 {\n        assert((s1 + s2).to_multiset() =~= s1.to_multiset());\n        assert(s2.to_multiset() =~= Multiset::<u64>::empty());\n    } else {\n        lemma_to_multiset_distributes_over_add(s1, s2.drop_last());\n        vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);\n        assert(s2.drop_last() =~= s2.remove(s2.len() - 1));\n        assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));\n        assert((s1 + s2).to_multiset() =~= ((s1 + s2).drop_last().push(\n            s2[(s2.len() - 1) as int],\n        )).to_multiset());\n        (s1 + s2).drop_last().to_multiset_ensures();\n    }\n}\n\nproof fn lemma_subrange_push(s1: Seq<u64>, start: int, end: int)\n    requires\n        0 <= start <= end < s1.len(),\n    ensures\n        s1.subrange(start, end).push(s1[end]) =~= s1.subrange(start, end + 1),\n{\n}\n\nproof fn lemma_subrange_add(s1: Seq<u64>, start: int, mid: int, end: int)\n    requires\n        0 <= start <= mid <= end <= s1.len(),\n    ensures\n        s1.subrange(start, mid) + s1.subrange(mid, end) =~= s1.subrange(start, end),\n{\n}\n\nfn merge(v1: &Vec<u64>, v2: &Vec<u64>) -> (r: Vec<u64>)\n    requires\n        is_sorted(v1),\n        is_sorted(v2),\n    ensures\n        r@.to_multiset() == (v1@ + v2@).to_multiset(),\n        is_sorted(&r),\n{\n    broadcast use lemma_to_multiset_distributes_over_add;\n\n    let mut r: Vec<u64> = Vec::new();\n    let mut i1: usize = 0;\n    let mut i2: usize = 0;\n    assert(v1@.subrange(0 as int, i1 as int) == Seq::<u64>::empty());\n\n    while i1 < v1.len() && i2 < v2.len()\n        invariant\n            0 <= i1 <= v1.len(),\n            0 <= i2 <= v2.len(),\n            is_sorted(v1),\n            is_sorted(v2),\n            forall|i: int| i1 < v1.len() ==> 0 <= i < r.len() ==> r[i] <= v1[i1 as int],\n            forall|i: int| i2 < v2.len() ==> 0 <= i < r.len() ==> r[i] <= v2[i2 as int],\n            r@.to_multiset() =~= (v1@.subrange(0 as int, i1 as int) + v2@.subrange(\n                0 as int,\n                i2 as int,\n            )).to_multiset(),\n            is_sorted(&r),\n        decreases v1.len() + v2.len() - i1 - i2,\n    {\n        proof {\n            r@.to_multiset_ensures();\n        }\n        if v1[i1] < v2[i2] {\n            r.push(v1[i1]);\n            proof {\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n                v1@.subrange(0 as int, i1 as int).to_multiset_ensures();\n                lemma_subrange_push(v1@, 0 as int, i1 as int);\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, (i1 + 1) as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n            }\n            i1 += 1;\n        } else {\n            r.push(v2[i2]);\n            proof {\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n                v2@.subrange(0 as int, i2 as int).to_multiset_ensures();\n                lemma_subrange_push(v2@, 0 as int, i2 as int);\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, (i2 + 1) as int),\n                );\n            }\n            i2 += 1;\n        }\n\n    }\n    assert(v1@.subrange(0 as int, v1.len() as int) =~= v1@);\n    assert(v2@.subrange(0 as int, v2.len() as int) =~= v2@);\n\n    if i1 < v1.len() {\n        extend_from_idx(&mut r, v1, i1);\n        proof {\n            lemma_subrange_add(v1@, 0 as int, i1 as int, v1.len() as int);\n            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());\n        }\n    } else if i2 < v2.len() {\n        extend_from_idx(&mut r, v2, i2);\n        proof {\n            lemma_subrange_add(v2@, 0 as int, i2 as int, v2.len() as int);\n            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());\n        }\n    }\n    r\n}\n\nfn merge_sort(v: &Vec<u64>) -> (r: Vec<u64>)\n    ensures\n        r@.to_multiset() == (*v)@.to_multiset(),\n        is_sorted(&r),\n    decreases v.len(),\n{\n    let n = v.len();\n    let mut v1 = v.clone();\n    if (n <= 1) {\n        v1\n    } else {\n        let mut v2 = v1.split_off(n / 2);\n        assert(v1@ + v2@ == v@);\n        proof {\n            lemma_to_multiset_distributes_over_add(v1@, v2@);\n        }\n        let r1 = merge_sort(&mut v1);\n        let r2 = merge_sort(&mut v2);\n        proof {\n            lemma_to_multiset_distributes_over_add(r1@, r2@);\n        }\n        let r = merge(&r1, &r2);\n        r\n    }\n}\n\nfn main() {\n    let v = vec![9, 10, 4, 5, 1, 3];\n    let v_sorted = merge_sort(&v);\n    let ghost expected_res: Seq<u64> = seq![1, 3, 4, 5, 9, 10];\n    proof {\n        broadcast use group_seq_properties; \n        assert(v@ =~= seq![9].push(10).push(4).push(5).push(1).push(3));\n        assert(expected_res =~= seq![1].push(3).push(4).push(5).push(9).push(10));\n\n        assert(expected_res.to_multiset() =~= v@.to_multiset());\n        vstd::seq_lib::lemma_sorted_unique(expected_res, v_sorted@, |a: u64, b: u64| a <= b);\n        assert(v_sorted@ =~= expected_res);\n    }\n}\n\n} // verus!\n", "minimized_code": "    use vstd::prelude::*;\n           verus! {\n         pub open spec fn is_sorted(v: &Vec<u64>) -> bool {\n           forall|i: int, j: int| 0 <= i < j < v.len() ==>           \n#[trigger] v[i] <= #[trigger] v[j]\n}\n         pub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)     ensures                   \n#[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(), {\n           s2.to_multiset_ensures();\n           if s2.len() == 0 {}\n       else {              lemma_to_multiset_distributes_over_add(s1, s2.drop_last());              vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);              assert(s2.drop_last() =~= s2.remove(s2.len() - 1));              assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));              (s1 + s2).drop_last().to_multiset_ensures();          }\n       }\n         fn main() ;\n         }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/mergesort.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1417, "minimize_time_ms": 1000654, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 188, "minimized_LOC": 15, "self_contained": true, "dependencies": ["vstd::multiset::", "vstd::prelude::", "vstd::seq_lib::group_seq_properties"], "complexity_verus_tokens": 7, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 0.0797872340425532}, "labeling": {"segments": {"spec": "spec fn is_sorted(v: &Vec<u64>) -> bool {\n\n         pub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)     ensures                   \n\n    decreases s2.len(), {", "proof": "proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)     ensures                   \n#[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(), {"}}}, "all_snapshots": ["use vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq_lib::group_seq_properties;\n\nverus! {\n\npub open spec fn is_sorted(v: &Vec<u64>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> #[trigger] v[i] <= #[trigger] v[j]\n}\n\nfn extend_from_idx(r: &mut Vec<u64>, v: &Vec<u64>, start: usize)\n    requires\n        start < v.len(),\n    ensures\n        r@ == old(r)@ + v@.subrange(start as int, v.len() as int),\n{\n    for i in start..v.len()\n        invariant\n            r@ =~= old(r)@ + v@.subrange(start as int, i as int),\n    {\n        r.push(v[i]);\n    }\n}\n\npub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)\n    ensures\n        #[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(),\n{\n    s2.to_multiset_ensures();\n    if s2.len() == 0 {\n        assert((s1 + s2).to_multiset() =~= s1.to_multiset());\n        assert(s2.to_multiset() =~= Multiset::<u64>::empty());\n    } else {\n        lemma_to_multiset_distributes_over_add(s1, s2.drop_last());\n        vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);\n        assert(s2.drop_last() =~= s2.remove(s2.len() - 1));\n        assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));\n        assert((s1 + s2).to_multiset() =~= ((s1 + s2).drop_last().push(\n            s2[(s2.len() - 1) as int],\n        )).to_multiset());\n        (s1 + s2).drop_last().to_multiset_ensures();\n    }\n}\n\nproof fn lemma_subrange_push(s1: Seq<u64>, start: int, end: int)\n    requires\n        0 <= start <= end < s1.len(),\n    ensures\n        s1.subrange(start, end).push(s1[end]) =~= s1.subrange(start, end + 1),\n{\n}\n\nproof fn lemma_subrange_add(s1: Seq<u64>, start: int, mid: int, end: int)\n    requires\n        0 <= start <= mid <= end <= s1.len(),\n    ensures\n        s1.subrange(start, mid) + s1.subrange(mid, end) =~= s1.subrange(start, end),\n{\n}\n\nfn merge(v1: &Vec<u64>, v2: &Vec<u64>) -> (r: Vec<u64>)\n    requires\n        is_sorted(v1),\n        is_sorted(v2),\n    ensures\n        r@.to_multiset() == (v1@ + v2@).to_multiset(),\n        is_sorted(&r),\n{\n    broadcast use lemma_to_multiset_distributes_over_add;\n\n    let mut r: Vec<u64> = Vec::new();\n    let mut i1: usize = 0;\n    let mut i2: usize = 0;\n    assert(v1@.subrange(0 as int, i1 as int) == Seq::<u64>::empty());\n\n    while i1 < v1.len() && i2 < v2.len()\n        invariant\n            0 <= i1 <= v1.len(),\n            0 <= i2 <= v2.len(),\n            is_sorted(v1),\n            is_sorted(v2),\n            forall|i: int| i1 < v1.len() ==> 0 <= i < r.len() ==> r[i] <= v1[i1 as int],\n            forall|i: int| i2 < v2.len() ==> 0 <= i < r.len() ==> r[i] <= v2[i2 as int],\n            r@.to_multiset() =~= (v1@.subrange(0 as int, i1 as int) + v2@.subrange(\n                0 as int,\n                i2 as int,\n            )).to_multiset(),\n            is_sorted(&r),\n        decreases v1.len() + v2.len() - i1 - i2,\n    {\n        proof {\n            r@.to_multiset_ensures();\n        }\n        if v1[i1] < v2[i2] {\n            r.push(v1[i1]);\n            proof {\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n                v1@.subrange(0 as int, i1 as int).to_multiset_ensures();\n                lemma_subrange_push(v1@, 0 as int, i1 as int);\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, (i1 + 1) as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n            }\n            i1 += 1;\n        } else {\n            r.push(v2[i2]);\n            proof {\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n                v2@.subrange(0 as int, i2 as int).to_multiset_ensures();\n                lemma_subrange_push(v2@, 0 as int, i2 as int);\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, (i2 + 1) as int),\n                );\n            }\n            i2 += 1;\n        }\n\n    }\n    assert(v1@.subrange(0 as int, v1.len() as int) =~= v1@);\n    assert(v2@.subrange(0 as int, v2.len() as int) =~= v2@);\n\n    if i1 < v1.len() {\n        extend_from_idx(&mut r, v1, i1);\n        proof {\n            lemma_subrange_add(v1@, 0 as int, i1 as int, v1.len() as int);\n            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());\n        }\n    } else if i2 < v2.len() {\n        extend_from_idx(&mut r, v2, i2);\n        proof {\n            lemma_subrange_add(v2@, 0 as int, i2 as int, v2.len() as int);\n            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());\n        }\n    }\n    r\n}\n\nfn merge_sort(v: &Vec<u64>) -> (r: Vec<u64>)\n    ensures\n        r@.to_multiset() == (*v)@.to_multiset(),\n        is_sorted(&r),\n    decreases v.len(),\n{\n    let n = v.len();\n    let mut v1 = v.clone();\n    if (n <= 1) {\n        v1\n    } else {\n        let mut v2 = v1.split_off(n / 2);\n        assert(v1@ + v2@ == v@);\n        proof {\n            lemma_to_multiset_distributes_over_add(v1@, v2@);\n        }\n        let r1 = merge_sort(&mut v1);\n        let r2 = merge_sort(&mut v2);\n        proof {\n            lemma_to_multiset_distributes_over_add(r1@, r2@);\n        }\n        let r = merge(&r1, &r2);\n        r\n    }\n}\n\nfn main() {\n    let v = vec![9, 10, 4, 5, 1, 3];\n    let v_sorted = merge_sort(&v);\n    let ghost expected_res: Seq<u64> = seq![1, 3, 4, 5, 9, 10];\n    proof {\n        broadcast use group_seq_properties; \n        assert(v@ =~= seq![9].push(10).push(4).push(5).push(1).push(3));\n        assert(expected_res =~= seq![1].push(3).push(4).push(5).push(9).push(10));\n\n        assert(expected_res.to_multiset() =~= v@.to_multiset());\n        vstd::seq_lib::lemma_sorted_unique(expected_res, v_sorted@, |a: u64, b: u64| a <= b);\n        assert(v_sorted@ =~= expected_res);\n    }\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "    use vstd::prelude::*;\n           verus! {\n         pub open spec fn is_sorted(v: &Vec<u64>) -> bool {\n           forall|i: int, j: int| 0 <= i < j < v.len() ==>           \n#[trigger] v[i] <= #[trigger] v[j]\n}\n         pub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)     ensures                   \n#[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(), {\n           s2.to_multiset_ensures();\n           if s2.len() == 0 {}\n       else {              lemma_to_multiset_distributes_over_add(s1, s2.drop_last());              vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);              assert(s2.drop_last() =~= s2.remove(s2.len() - 1));              assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));              (s1 + s2).drop_last().to_multiset_ensures();          }\n       }\n         fn main() ;\n         }\n", "    use vstd::prelude::*;\n                verus! {\n              spec fn a() -> bool ;\n              proof fn e(f: Seq<u64>, s2: Seq<u64>)     ensures                        \n(f + s2).to_multiset() == f.to_multiset().add(s2.to_multiset())decreases s2{\n                s2.to_multiset_ensures();\n                if s2.len() == 0 {}\n            else {\n                  e(f, s2.drop_last());\n                  Seq::drop_last_distributes_over_add(f, s2);\n                  assert(s2.drop_last() == s2.remove(s2.len() - 1));\n                  assert(f + s2 == (f + s2).drop_last().push(s2[s2.len() - 1 ]));\n                  (f + s2).drop_last().to_multiset_ensures()}\n            }\n              fn main() ;\n              }\n", "    use vstd::prelude::*;\n                      verus! {\n                   fn main() ;\n                   }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "nevd_script_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ;; Function-Def crate::max\n// (push)\n//  (declare-const ret~10@ Int)\n//  (declare-const a~2@ Int)\n//  (declare-const b~4@ Int)\n//  (assert fuel_defaults)\n//  (assert (uInv 64 a~2@))\n//  (assert (uInv 64 b~4@))\n//  ;; postcondition not satisfied\n//  (declare-const %%location_label%%0 Bool)\n//  ;; postcondition not satisfied\n//  (declare-const %%location_label%%1 Bool)\n//  (declare-const %%query%% Bool)\n//  (assert\n//   (=>\n//    %%query%%\n//    (not (=>\n//      (= ret~10@ (ite\n//        (>= a~2@ b~4@)\n//        a~2@\n//        b~4@\n//      ))\n//      (and\n//       (=>\n//        %%location_label%%0\n//        (or\n//         (= ret~10@ a~2@)\n//         (= ret~10@ b~4@)\n//       ))\n//       (=>\n//        %%location_label%%1\n//        (and\n//         (>= ret~10@ a~2@)\n//         (>= ret~10@ b~4@)\n//  )))))))\n//  (assert %%query%%)\n//  (set-option :rlimit 30000000)\n//  (check-sat)\n//  (set-option :rlimit 0)\n// (pop)\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// exec fn g_(v1: Vec<u64>, v2: Vec<u64>) -> (out: (Vec<u64>, Vec<u64>))\n//     requires\n//         v1@.len() == 2,\n//         v2@.len() == 3,\n//     ensures\n//         out.0@.len() == out.1@.len()\n// {\n//     let v1a = v1.push(42);\n//     let v1b = v1.push(43);\n//     let v2a.push(52);\n//     (v1b, v2a)\n// }\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ;; Function-Def crate::max\n// (push)\n//  (declare-const ret~10@ Int)\n//  (declare-const a~2@ Int)\n//  (declare-const b~4@ Int)\n//  (assert fuel_defaults)\n//  (assert (uInv 64 a~2@))\n//  (assert (uInv 64 b~4@))\n//  ;; postcondition not satisfied\n//  (declare-const %%location_label%%0 Bool)\n//  ;; postcondition not satisfied\n//  (declare-const %%location_label%%1 Bool)\n//  (declare-const %%query%% Bool)\n//  (assert\n//   (=>\n//    %%query%%\n//    (not (=>\n//      (= ret~10@ (ite\n//        (>= a~2@ b~4@)\n//        a~2@\n//        b~4@\n//      ))\n//      (and\n//       (=>\n//        %%location_label%%0\n//        (or\n//         (= ret~10@ a~2@)\n//         (= ret~10@ b~4@)\n//       ))\n//       (=>\n//        %%location_label%%1\n//        (and\n//         (>= ret~10@ a~2@)\n//         (>= ret~10@ b~4@)\n//  )))))))\n//  (assert %%query%%)\n//  (set-option :rlimit 30000000)\n//  (check-sat)\n//  (set-option :rlimit 0)\n// (pop)\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// exec fn g_(v1: Vec<u64>, v2: Vec<u64>) -> (out: (Vec<u64>, Vec<u64>))\n//     requires\n//         v1@.len() == 2,\n//         v2@.len() == 3,\n//     ensures\n//         out.0@.len() == out.1@.len()\n// {\n//     let v1a = v1.push(42);\n//     let v1b = v1.push(43);\n//     let v2a.push(52);\n//     (v1b, v2a)\n// }\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/nevd_script.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1007, "minimize_time_ms": 215673, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 213, "minimized_LOC": 213, "self_contained": true, "complexity_verus_tokens": 32, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"has_invariant": true, "has_proof_block": true, "ensures_count": 1, "segments": {"exec": "\nfn main() {\n\n\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n\n fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n\n fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n\n fn f(v: Vec<u64>) {\n\n fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n\n fn g_(v1: Vec<u64>, v2: Vec<u64>) -> (out: (Vec<u64>, Vec<u64>))\n//     requires\n//         v1@.len() == 2,\n//         v2@.len() == 3,\n//     ensures\n//         out.0@.len() == out.1@.len()\n// {\n\n\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{", "spec": "spec fn fibo(n: nat) -> nat\n    decreases n,\n{\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n\n    ensures\n\n    decreases n,\n\n    requires\n\n    ensures\n\n    decreases j - i,\n\n    requires\n\n    ensures\n\n        invariant\n\n    requires\n\n    ensures\n\n//     requires\n\n//     ensures\n\n    ensures([\n\n        invariant([\n\n    ensures", "proof": "proof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n\nproof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ;; Function-Def crate::max\n// (push)\n//  (declare-const ret~10@ Int)\n//  (declare-const a~2@ Int)\n//  (declare-const b~4@ Int)\n//  (assert fuel_defaults)\n//  (assert (uInv 64 a~2@))\n//  (assert (uInv 64 b~4@))\n//  ;; postcondition not satisfied\n//  (declare-const %%location_label%%0 Bool)\n//  ;; postcondition not satisfied\n//  (declare-const %%location_label%%1 Bool)\n//  (declare-const %%query%% Bool)\n//  (assert\n//   (=>\n//    %%query%%\n//    (not (=>\n//      (= ret~10@ (ite\n//        (>= a~2@ b~4@)\n//        a~2@\n//        b~4@\n//      ))\n//      (and\n//       (=>\n//        %%location_label%%0\n//        (or\n//         (= ret~10@ a~2@)\n//         (= ret~10@ b~4@)\n//       ))\n//       (=>\n//        %%location_label%%1\n//        (and\n//         (>= ret~10@ a~2@)\n//         (>= ret~10@ b~4@)\n//  )))))))\n//  (assert %%query%%)\n//  (set-option :rlimit 30000000)\n//  (check-sat)\n//  (set-option :rlimit 0)\n// (pop)\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// exec fn g_(v1: Vec<u64>, v2: Vec<u64>) -> (out: (Vec<u64>, Vec<u64>))\n//     requires\n//         v1@.len() == 2,\n//         v2@.len() == 3,\n//     ensures\n//         out.0@.len() == out.1@.len()\n// {\n//     let v1a = v1.push(42);\n//     let v1b = v1.push(43);\n//     let v2a.push(52);\n//     (v1b, v2a)\n// }\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "fn main() {}\nuse{vstd};\n", "fn main() {}\nuse{verus_builtin, verus_builtin_macros, prelude::*, seq::*, vstd::*};\n", "fn main() {}\nuse{vstd::*};\n", "fn main() {}\nuse{vstd};\n"]}
{"id": "overflow_cc0b9f7d", "original_code": "// examples of using `CheckedU32` and `CheckedU64`\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\nfn checked_u64_constants()\n{\n    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);\n    let x = w.add_value(1);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x10000000000000000);\n\n    let y = CheckedU64::new(0x8000000000000000);\n    let z = y.mul_value(2);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x10000000000000000);\n}\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d,\n            None => a * b + c * d > u64::MAX,\n        }\n{\n    let a_times_b = CheckedU64::new(a).mul_value(b);\n    let c_times_d = CheckedU64::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    if sum_of_products.is_overflowed() {\n        assert(a * b + c * d > u64::MAX);\n        None\n    }\n    else {\n        let i: u64 = sum_of_products.unwrap();\n        assert(i == a * b + c * d);\n        Some(i)\n    }\n}\n\nfn checked_u32_constants()\n{\n    let w = CheckedU32::new(0xFFFFFFFF);\n    let x = w.add_value(9);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x100000008);\n\n    let y = CheckedU32::new(0x40000000);\n    let z = y.mul_value(8);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x200000000);\n}\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d + e,\n            None => a * b + c * d + e > u32::MAX,\n        }\n{\n    let a_times_b = CheckedU32::new(a).mul_value(b);\n    let c_times_d = CheckedU32::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    let f = sum_of_products.add_value(e);\n    f.to_option()\n}\n\n} // verus!\nfn main() {}\n", "minimized_code": "// examples of using `CheckedU32` and `CheckedU64`\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\nfn checked_u64_constants()\n{\n    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);\n    let x = w.add_value(1);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x10000000000000000);\n\n    let y = CheckedU64::new(0x8000000000000000);\n    let z = y.mul_value(2);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x10000000000000000);\n}\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d,\n            None => a * b + c * d > u64::MAX,\n        }\n{\n    let a_times_b = CheckedU64::new(a).mul_value(b);\n    let c_times_d = CheckedU64::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    if sum_of_products.is_overflowed() {\n        assert(a * b + c * d > u64::MAX);\n        None\n    }\n    else {\n        let i: u64 = sum_of_products.unwrap();\n        assert(i == a * b + c * d);\n        Some(i)\n    }\n}\n\nfn checked_u32_constants()\n{\n    let w = CheckedU32::new(0xFFFFFFFF);\n    let x = w.add_value(9);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x100000008);\n\n    let y = CheckedU32::new(0x40000000);\n    let z = y.mul_value(8);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x200000000);\n}\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d + e,\n            None => a * b + c * d + e > u32::MAX,\n        }\n{\n    let a_times_b = CheckedU32::new(a).mul_value(b);\n    let c_times_d = CheckedU32::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    let f = sum_of_products.add_value(e);\n    f.to_option()\n}\n\n} // verus!\nfn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/overflow.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1047, "minimize_time_ms": 123082, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::arithmetic::overflow::"], "complexity_verus_tokens": 4, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn checked_u64_constants()\n{\n\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n\n\nfn checked_u32_constants()\n{\n\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n    ensures\n        match result {\n\n\nfn main() {", "spec": "    ensures\n\n    ensures"}}}, "all_snapshots": ["// examples of using `CheckedU32` and `CheckedU64`\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\nfn checked_u64_constants()\n{\n    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);\n    let x = w.add_value(1);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x10000000000000000);\n\n    let y = CheckedU64::new(0x8000000000000000);\n    let z = y.mul_value(2);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x10000000000000000);\n}\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d,\n            None => a * b + c * d > u64::MAX,\n        }\n{\n    let a_times_b = CheckedU64::new(a).mul_value(b);\n    let c_times_d = CheckedU64::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    if sum_of_products.is_overflowed() {\n        assert(a * b + c * d > u64::MAX);\n        None\n    }\n    else {\n        let i: u64 = sum_of_products.unwrap();\n        assert(i == a * b + c * d);\n        Some(i)\n    }\n}\n\nfn checked_u32_constants()\n{\n    let w = CheckedU32::new(0xFFFFFFFF);\n    let x = w.add_value(9);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x100000008);\n\n    let y = CheckedU32::new(0x40000000);\n    let z = y.mul_value(8);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x200000000);\n}\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d + e,\n            None => a * b + c * d + e > u32::MAX,\n        }\n{\n    let a_times_b = CheckedU32::new(a).mul_value(b);\n    let c_times_d = CheckedU32::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    let f = sum_of_products.add_value(e);\n    f.to_option()\n}\n\n} // verus!\nfn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "agreement_cc0b9f7d", "original_code": "//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//! assert(r1@ == 72);\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//! assert(r2.id() == r1.id());\n//! assert(r2@ == r1@);\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//! assert(r2.id() == r1.id());\n//! proof { r1.lemma_agreement(&mut r2); }\n//! assert(r2@ == r1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n    assert(r1@ == 72);\n    let tracked r2 = r1.duplicate();\n    assert(r2@ == r1@);\n    proof {\n        r1.lemma_agreement(&mut r2);\n    }\n}\n\n} // verus!\n", "minimized_code": "//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//! assert(r1@ == 72);\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//! assert(r2.id() == r1.id());\n//! assert(r2@ == r1@);\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//! assert(r2.id() == r1.id());\n//! proof { r1.lemma_agreement(&mut r2); }\n//! assert(r2@ == r1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n    assert(r1@ == 72);\n    let tracked r2 = r1.duplicate();\n    assert(r2@ == r1@);\n    proof {\n        r1.lemma_agreement(&mut r2);\n    }\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/pcm/agreement.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 818, "minimize_time_ms": 275657, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 168, "minimized_LOC": 168, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "std::result::", "vstd::pcm::", "vstd::pcm_lib::", "vstd::prelude::"], "complexity_verus_tokens": 24, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\npub fn main() {", "spec": "spec fn new(c: T) -> Self {\n\nspec fn valid(self) -> bool {\n\nspec fn op(self, other: Self) -> Self {\n\nspec fn unit() -> Self {\n\nspec fn inv(self) -> bool {\n\nspec fn id(self) -> Loc {\n\nspec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n\n        ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures", "proof": "proof fn closed_under_incl(a: Self, b: Self) {\n\nproof fn commutative(a: Self, b: Self) {\n\nproof fn associative(a: Self, b: Self, c: Self) {\n\nproof fn op_unit(a: Self) {\n\nproof fn unit_valid() {\n\nproof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n\nproof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n\nproof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n\nproof { r1.lemma_agreement(&mut r2); }\n\nproof {\n        r1.lemma_agreement(&mut r2);\n    }"}}}, "all_snapshots": ["//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//! assert(r1@ == 72);\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//! assert(r2.id() == r1.id());\n//! assert(r2@ == r1@);\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//! assert(r2.id() == r1.id());\n//! proof { r1.lemma_agreement(&mut r2); }\n//! assert(r2@ == r1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n    assert(r1@ == 72);\n    let tracked r2 = r1.duplicate();\n    assert(r2@ == r1@);\n    proof {\n        r1.lemma_agreement(&mut r2);\n    }\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "          use vstd::prelude::*;\n            verus! {\n          pub fn main() ;\n          }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "count_to_two_cc0b9f7d", "original_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\n\npub mod oneshot;\n\nuse crate::oneshot::*;\nuse std::sync::Arc;\nuse vstd::atomic::*;\nuse vstd::atomic_ghost::*;\nuse vstd::invariant::*;\n\nverus! {\n\n// This struct holds all the ghost tracked state that the counter\n// will keep in an invariant.\n//\n// `x_perm` -- permission to write to the shared atomic variable `x`\n//\n// `oneshot0_inv_half` -- the invariant's resource for thread 0's\n// one-shot, which contains either half the authority to complete that\n// one-shot or knowledge that that one-shot has been performed\n//\n// `oneshot1_inv_half` -- as above, but for thread 1's one-shot\npub struct CounterTrackedState {\n    pub x_perm: PermissionU32,\n    pub oneshot0_inv_half: OneShotResource,\n    pub oneshot1_inv_half: OneShotResource,\n}\n\n// This struct describes what's constant in the counter invariant.\n//\n// `x_id` -- the identity of the shared atomic variable `x`, which\n// links the permission to write it with the actual atomic\n// variable.\n//\n// `oneshot0_id` -- the ID of thread 0's one-shot\n//\n// `oneshot1_id` -- the ID of thread 1's one-shot\npub struct CounterInvariantConstants {\n    pub x_id: int,\n    pub oneshot0_id: int,\n    pub oneshot1_id: int,\n}\n\n// This is the invariant predicate that will be maintained for the\n// `CounterTrackedState`.\npub struct CounterInvariantPredicate {}\n\nimpl InvariantPredicate<\n    CounterInvariantConstants,\n    CounterTrackedState,\n> for CounterInvariantPredicate {\n    open spec fn inv(c: CounterInvariantConstants, cts: CounterTrackedState) -> bool {\n        // The IDs of the resources held match those in the constants\n        &&& cts.x_perm@.patomic == c.x_id\n        &&& cts.oneshot0_inv_half.id() == c.oneshot0_id\n        &&& cts.oneshot1_inv_half.id()\n            == c.oneshot1_id\n        // For each thread's one-shot, the invariant holds a resource that's either\n        // (1) half authority to complete that one-shot or (2) knowledge that that\n        // one-shot is complete.\n\n        &&& cts.oneshot0_inv_half@ is HalfRightToComplete || cts.oneshot0_inv_half@ is Complete\n        &&& cts.oneshot1_inv_half@ is HalfRightToComplete\n            || cts.oneshot1_inv_half@ is Complete\n        // The key invariant is that the value of `x` is the count\n        // of how many threads' one-shots have completed.\n\n        &&& cts.x_perm@.value == (if cts.oneshot0_inv_half@ is Complete {\n            1int\n        } else {\n            0int\n        }) + (if cts.oneshot1_inv_half@ is Complete {\n            1int\n        } else {\n            0int\n        })\n    }\n}\n\n// This `CounterSharedState` struct is shared among the threads, using\n// an atomic reference counter (Arc).\n//\n// `x` -- the actual counter implemented as an atomic u32\n// `inv` -- the invariant holding the shared counter tracked state\npub struct CounterSharedState {\n    pub x: PAtomicU32,\n    pub inv: Tracked<\n        AtomicInvariant<CounterInvariantConstants, CounterTrackedState, CounterInvariantPredicate>,\n    >,\n}\n\nimpl CounterSharedState {\n    // This is the well-formedness predicate for a `CounterSharedState`.\n    pub open spec fn wf(self) -> bool {\n        &&& self.x.id() == self.inv@.constant().x_id\n        &&& self.inv@.namespace() == 888\n    }\n\n    // This function gets, from the shared state's constants, the ID\n    // of the one-shot associated with the given thread.\n    pub open spec fn get_oneshot_id(self, which_thread: int) -> int\n        recommends\n            which_thread == 0 || which_thread == 1,\n    {\n        let c = self.inv@.constant();\n        if which_thread == 0 {\n            c.oneshot0_id\n        } else {\n            c.oneshot1_id\n        }\n    }\n\n    // This function creates a new `CounterSharedState`.\n    pub fn new(\n        Tracked(oneshot0_inv_half): Tracked<OneShotResource>,\n        Tracked(oneshot1_inv_half): Tracked<OneShotResource>,\n    ) -> (result: Arc<Self>)\n        requires\n            oneshot0_inv_half@ is HalfRightToComplete,\n            oneshot1_inv_half@ is HalfRightToComplete,\n        ensures\n            result.wf(),\n            result.get_oneshot_id(0) == oneshot0_inv_half.id(),\n            result.get_oneshot_id(1) == oneshot1_inv_half.id(),\n    {\n        // Create the atomic variable to be shared among threads.\n        let (x, Tracked(x_perm)): (PAtomicU32, Tracked<PermissionU32>) = PAtomicU32::new(0);\n        // Create the `CounterTrackedState`.\n        let tracked cts = CounterTrackedState { x_perm, oneshot0_inv_half, oneshot1_inv_half };\n        // Create the invariant.\n        let ghost c = CounterInvariantConstants {\n            x_id: x.id(),\n            oneshot0_id: oneshot0_inv_half.id(),\n            oneshot1_id: oneshot1_inv_half.id(),\n        };\n        assert(CounterInvariantPredicate::inv(c, cts));  // This is obvious, so no proof is needed.\n        let inv = Tracked(AtomicInvariant::new(c, cts, 888));\n        // Create the shared state to be shared among the threads\n        // using Arcs.\n        Arc::new(CounterSharedState { x, inv })\n    }\n\n    // This function reads the value of `x` from the `PAtomicU32`\n    // that's part of this `CounterSharedState`. It requires, as\n    // input, two `OneShotResource`s, one showing that thread 0's\n    // one-shot is complete and the other showing that thread 1's\n    // one-shot is complete. Because of these, it can ensure that the\n    // value it reads is 2.\n    pub fn read_x(\n        self: &Arc<Self>,\n        Tracked(oneshot0_complete): Tracked<OneShotResource>,\n        Tracked(oneshot1_complete): Tracked<OneShotResource>,\n    ) -> (x: u32)\n        requires\n            self.wf(),\n            oneshot0_complete.id() == self.get_oneshot_id(0),\n            oneshot1_complete.id() == self.get_oneshot_id(1),\n            oneshot0_complete@ is Complete,\n            oneshot1_complete@ is Complete,\n        ensures\n            x == 2,\n    {\n        let x_value: u32;\n        open_atomic_invariant!(self.inv.borrow() => inner => {\n            proof {\n                // Since `oneshot0_complete` reflects thread 0's\n                // one-shot having completed, we can conclude that the\n                // invariant's `oneshot0_inv_half` is also\n                // `Completed`. After all, it's not possible for a\n                // `HalfRightToComplete` and `Completed` resource to\n                // co-exist for the same one-shot ID. We use\n                // `lemma_is_complete_if_other_is` to show this.\n\n                inner.oneshot0_inv_half.lemma_is_complete_if_other_is(&oneshot0_complete);\n\n                // Similarly for `oneshot1_complete` and thread 1's\n                // one-shot.\n\n                inner.oneshot1_inv_half.lemma_is_complete_if_other_is(&oneshot1_complete);\n\n                // The invariant says that the value of `x` is equal to\n                //\n                // ```\n                // (if cts.oneshot0_inv_half@ is Complete { 1int } else { 0int }) +\n                // (if cts.oneshot1_inv_half@ is Complete { 1int } else { 0int })\n                // ```\n                //\n                // Since we know both have completed, we know `x == 2`. So,\n                // when we load its value, that's what we'll get.\n            }\n            x_value = self.x.load(Tracked(&inner.x_perm));\n            assert(x_value == 2); // This is the key assertion we needed to prove.\n        });\n        x_value\n    }\n}\n\n// This is the routine that each thread will execute when forked. It\n// increments the counter atomically with performing the one-shot.\n//\n// `shared_state` -- an Arc pointing to the state shared between\n// threads\n//\n// `oneshot_thread_half` -- permission granting half of the\n// authority to this thread's one-shot resource\n//\n// `which_thread` -- which thread this is, 0 or 1\npub fn thread_routine(\n    shared_state: Arc<CounterSharedState>,\n    Tracked(oneshot_thread_half): Tracked<OneShotResource>,\n    Ghost(which_thread): Ghost<int>,\n) -> (return_permission: Tracked<OneShotResource>)\n    requires\n        which_thread == 0 || which_thread == 1,\n        oneshot_thread_half@ is HalfRightToComplete,\n        shared_state.wf(),\n        oneshot_thread_half.id() == shared_state.get_oneshot_id(which_thread),\n    ensures\n        return_permission@.id() == shared_state.get_oneshot_id(which_thread),\n        return_permission@@ is Complete,\n{\n    let tracked mut oneshot_thread_half = oneshot_thread_half;\n    open_atomic_invariant!(shared_state.inv.borrow() => inner => {\n        // Increment the shared `x` by 1.\n        shared_state.x.fetch_add_wrapping(Tracked(&mut inner.x_perm), 1);\n        proof {\n            // Atomically with that increment, perform the one-shot.\n            // This requires providing two half authorities. One was\n            // passed to this function as `oneshot_thread_half` and\n            // the other is in this invariant.\n            //\n            // Technically, the invariant just tells us that either\n            // the one-shot is complete *or* we have half authority to\n            // it. Fortunately, `perform_using_two_halves` only\n            // requires that one of the resources be known to be a\n            // half authority. (It can deduce that the other one must\n            // be, since a `HalfRightToComplete` resource can't\n            // co-exist with a `Completed` resource of the same ID.)\n            if which_thread == 0 {\n                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot0_inv_half);\n            }\n            else {\n                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot1_inv_half);\n            }\n            assert(oneshot_thread_half@ is Complete);\n        }\n    });\n    // Return the updated permission. It's been updated from (a)\n    // half the authority to complete the one-shot to (b)\n    // knowledge that the one-shot is complete.\n    Tracked(oneshot_thread_half)\n}\n\n// This function counts to two by forking two threads, each tasked\n// with incrementing `x` and then returning knowledge that that\n// thread has performed its increment. In this way, it's able to\n// guarantee that when it reads `x` after joining those two\n// threads, the result is 2.\npub fn count_to_two() -> (result: Result<u32, ()>)\n    ensures\n        result is Ok ==> result.unwrap() == 2,\n{\n    // Create two one-shots, one for each thread we're going to\n    // fork. Calling `create_oneshot` provides two permissions to\n    // the one-shot resource, each granting half authority to\n    // perform the one-shot. We'll stash one half in our invariant\n    // and pass the other half to the appropriate thread. It's\n    // necessary to have both halves to perform any one-shot, so\n    // each thread will have to combine its half with the\n    // corresponding one in the invariant.\n    let tracked (mut oneshot0_inv_half, mut oneshot0_thread_half) =\n        OneShotResource::alloc().split();\n    let tracked (mut oneshot1_inv_half, mut oneshot1_thread_half) =\n        OneShotResource::alloc().split();\n    // Create the shared state that includes a new `PAtomicU32` and\n    // an invariant that starts out holding `oneshot0_inv_half` and\n    // `oneshot1_inv_half1.\n    let shared_state = CounterSharedState::new(\n        Tracked(oneshot0_inv_half),\n        Tracked(oneshot1_inv_half),\n    );\n    // For each thread, clone the shared-state Arc and use this to\n    // fork the thread. Also pass each thread a tracked permission\n    // providing half the authority to update its one-shot.\n    let shared_state_clone = shared_state.clone();\n    let join_handle0 = vstd::thread::spawn(\n        move || -> (return_value: Tracked<OneShotResource>)\n            ensures\n                return_value@.id() == shared_state.get_oneshot_id(0),\n                return_value@@ is Complete,\n            {\n                thread_routine(shared_state_clone, Tracked(oneshot0_thread_half), Ghost(0))\n            }\n    );\n    let shared_state_clone = shared_state.clone();\n    let join_handle1 = vstd::thread::spawn(\n        move || -> (return_value: Tracked<OneShotResource>)\n            ensures\n                return_value@.id() == shared_state.get_oneshot_id(1),\n                return_value@@ is Complete,\n            {\n                thread_routine(shared_state_clone, Tracked(oneshot1_thread_half), Ghost(1))\n            }\n    );\n    // Let the threads run in parallel, then join them both when\n    // they're done.\n    if let (Ok(oneshot0_complete), Ok(oneshot1_complete)) = (\n        join_handle0.join(),\n        join_handle1.join(),\n    ) {\n        // If both joins succeeded, we can now read the shared\n        // `PAtomicU32`'s value `x` by opening the invariant.\n        Ok(shared_state.read_x(oneshot0_complete, oneshot1_complete))\n    } else {\n        // If either of the joins failed, we can't proceed.\n        Err(())\n    }\n}\n\npub fn main() {\n    if let Ok(x) = count_to_two() {\n        assert(x == 2);\n    }\n}\n\n} // verus!\n", "minimized_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\n\npub mod oneshot;\n\nuse crate::oneshot::*;\nuse std::sync::Arc;\nuse vstd::atomic::*;\nuse vstd::atomic_ghost::*;\nuse vstd::invariant::*;\n\nverus! {\n\n// This struct holds all the ghost tracked state that the counter\n// will keep in an invariant.\n//\n// `x_perm` -- permission to write to the shared atomic variable `x`\n//\n// `oneshot0_inv_half` -- the invariant's resource for thread 0's\n// one-shot, which contains either half the authority to complete that\n// one-shot or knowledge that that one-shot has been performed\n//\n// `oneshot1_inv_half` -- as above, but for thread 1's one-shot\npub struct CounterTrackedState {\n    pub x_perm: PermissionU32,\n    pub oneshot0_inv_half: OneShotResource,\n    pub oneshot1_inv_half: OneShotResource,\n}\n\n// This struct describes what's constant in the counter invariant.\n//\n// `x_id` -- the identity of the shared atomic variable `x`, which\n// links the permission to write it with the actual atomic\n// variable.\n//\n// `oneshot0_id` -- the ID of thread 0's one-shot\n//\n// `oneshot1_id` -- the ID of thread 1's one-shot\npub struct CounterInvariantConstants {\n    pub x_id: int,\n    pub oneshot0_id: int,\n    pub oneshot1_id: int,\n}\n\n// This is the invariant predicate that will be maintained for the\n// `CounterTrackedState`.\npub struct CounterInvariantPredicate {}\n\nimpl InvariantPredicate<\n    CounterInvariantConstants,\n    CounterTrackedState,\n> for CounterInvariantPredicate {\n    open spec fn inv(c: CounterInvariantConstants, cts: CounterTrackedState) -> bool {\n        // The IDs of the resources held match those in the constants\n        &&& cts.x_perm@.patomic == c.x_id\n        &&& cts.oneshot0_inv_half.id() == c.oneshot0_id\n        &&& cts.oneshot1_inv_half.id()\n            == c.oneshot1_id\n        // For each thread's one-shot, the invariant holds a resource that's either\n        // (1) half authority to complete that one-shot or (2) knowledge that that\n        // one-shot is complete.\n\n        &&& cts.oneshot0_inv_half@ is HalfRightToComplete || cts.oneshot0_inv_half@ is Complete\n        &&& cts.oneshot1_inv_half@ is HalfRightToComplete\n            || cts.oneshot1_inv_half@ is Complete\n        // The key invariant is that the value of `x` is the count\n        // of how many threads' one-shots have completed.\n\n        &&& cts.x_perm@.value == (if cts.oneshot0_inv_half@ is Complete {\n            1int\n        } else {\n            0int\n        }) + (if cts.oneshot1_inv_half@ is Complete {\n            1int\n        } else {\n            0int\n        })\n    }\n}\n\n// This `CounterSharedState` struct is shared among the threads, using\n// an atomic reference counter (Arc).\n//\n// `x` -- the actual counter implemented as an atomic u32\n// `inv` -- the invariant holding the shared counter tracked state\npub struct CounterSharedState {\n    pub x: PAtomicU32,\n    pub inv: Tracked<\n        AtomicInvariant<CounterInvariantConstants, CounterTrackedState, CounterInvariantPredicate>,\n    >,\n}\n\nimpl CounterSharedState {\n    // This is the well-formedness predicate for a `CounterSharedState`.\n    pub open spec fn wf(self) -> bool {\n        &&& self.x.id() == self.inv@.constant().x_id\n        &&& self.inv@.namespace() == 888\n    }\n\n    // This function gets, from the shared state's constants, the ID\n    // of the one-shot associated with the given thread.\n    pub open spec fn get_oneshot_id(self, which_thread: int) -> int\n        recommends\n            which_thread == 0 || which_thread == 1,\n    {\n        let c = self.inv@.constant();\n        if which_thread == 0 {\n            c.oneshot0_id\n        } else {\n            c.oneshot1_id\n        }\n    }\n\n    // This function creates a new `CounterSharedState`.\n    pub fn new(\n        Tracked(oneshot0_inv_half): Tracked<OneShotResource>,\n        Tracked(oneshot1_inv_half): Tracked<OneShotResource>,\n    ) -> (result: Arc<Self>)\n        requires\n            oneshot0_inv_half@ is HalfRightToComplete,\n            oneshot1_inv_half@ is HalfRightToComplete,\n        ensures\n            result.wf(),\n            result.get_oneshot_id(0) == oneshot0_inv_half.id(),\n            result.get_oneshot_id(1) == oneshot1_inv_half.id(),\n    {\n        // Create the atomic variable to be shared among threads.\n        let (x, Tracked(x_perm)): (PAtomicU32, Tracked<PermissionU32>) = PAtomicU32::new(0);\n        // Create the `CounterTrackedState`.\n        let tracked cts = CounterTrackedState { x_perm, oneshot0_inv_half, oneshot1_inv_half };\n        // Create the invariant.\n        let ghost c = CounterInvariantConstants {\n            x_id: x.id(),\n            oneshot0_id: oneshot0_inv_half.id(),\n            oneshot1_id: oneshot1_inv_half.id(),\n        };\n        assert(CounterInvariantPredicate::inv(c, cts));  // This is obvious, so no proof is needed.\n        let inv = Tracked(AtomicInvariant::new(c, cts, 888));\n        // Create the shared state to be shared among the threads\n        // using Arcs.\n        Arc::new(CounterSharedState { x, inv })\n    }\n\n    // This function reads the value of `x` from the `PAtomicU32`\n    // that's part of this `CounterSharedState`. It requires, as\n    // input, two `OneShotResource`s, one showing that thread 0's\n    // one-shot is complete and the other showing that thread 1's\n    // one-shot is complete. Because of these, it can ensure that the\n    // value it reads is 2.\n    pub fn read_x(\n        self: &Arc<Self>,\n        Tracked(oneshot0_complete): Tracked<OneShotResource>,\n        Tracked(oneshot1_complete): Tracked<OneShotResource>,\n    ) -> (x: u32)\n        requires\n            self.wf(),\n            oneshot0_complete.id() == self.get_oneshot_id(0),\n            oneshot1_complete.id() == self.get_oneshot_id(1),\n            oneshot0_complete@ is Complete,\n            oneshot1_complete@ is Complete,\n        ensures\n            x == 2,\n    {\n        let x_value: u32;\n        open_atomic_invariant!(self.inv.borrow() => inner => {\n            proof {\n                // Since `oneshot0_complete` reflects thread 0's\n                // one-shot having completed, we can conclude that the\n                // invariant's `oneshot0_inv_half` is also\n                // `Completed`. After all, it's not possible for a\n                // `HalfRightToComplete` and `Completed` resource to\n                // co-exist for the same one-shot ID. We use\n                // `lemma_is_complete_if_other_is` to show this.\n\n                inner.oneshot0_inv_half.lemma_is_complete_if_other_is(&oneshot0_complete);\n\n                // Similarly for `oneshot1_complete` and thread 1's\n                // one-shot.\n\n                inner.oneshot1_inv_half.lemma_is_complete_if_other_is(&oneshot1_complete);\n\n                // The invariant says that the value of `x` is equal to\n                //\n                // ```\n                // (if cts.oneshot0_inv_half@ is Complete { 1int } else { 0int }) +\n                // (if cts.oneshot1_inv_half@ is Complete { 1int } else { 0int })\n                // ```\n                //\n                // Since we know both have completed, we know `x == 2`. So,\n                // when we load its value, that's what we'll get.\n            }\n            x_value = self.x.load(Tracked(&inner.x_perm));\n            assert(x_value == 2); // This is the key assertion we needed to prove.\n        });\n        x_value\n    }\n}\n\n// This is the routine that each thread will execute when forked. It\n// increments the counter atomically with performing the one-shot.\n//\n// `shared_state` -- an Arc pointing to the state shared between\n// threads\n//\n// `oneshot_thread_half` -- permission granting half of the\n// authority to this thread's one-shot resource\n//\n// `which_thread` -- which thread this is, 0 or 1\npub fn thread_routine(\n    shared_state: Arc<CounterSharedState>,\n    Tracked(oneshot_thread_half): Tracked<OneShotResource>,\n    Ghost(which_thread): Ghost<int>,\n) -> (return_permission: Tracked<OneShotResource>)\n    requires\n        which_thread == 0 || which_thread == 1,\n        oneshot_thread_half@ is HalfRightToComplete,\n        shared_state.wf(),\n        oneshot_thread_half.id() == shared_state.get_oneshot_id(which_thread),\n    ensures\n        return_permission@.id() == shared_state.get_oneshot_id(which_thread),\n        return_permission@@ is Complete,\n{\n    let tracked mut oneshot_thread_half = oneshot_thread_half;\n    open_atomic_invariant!(shared_state.inv.borrow() => inner => {\n        // Increment the shared `x` by 1.\n        shared_state.x.fetch_add_wrapping(Tracked(&mut inner.x_perm), 1);\n        proof {\n            // Atomically with that increment, perform the one-shot.\n            // This requires providing two half authorities. One was\n            // passed to this function as `oneshot_thread_half` and\n            // the other is in this invariant.\n            //\n            // Technically, the invariant just tells us that either\n            // the one-shot is complete *or* we have half authority to\n            // it. Fortunately, `perform_using_two_halves` only\n            // requires that one of the resources be known to be a\n            // half authority. (It can deduce that the other one must\n            // be, since a `HalfRightToComplete` resource can't\n            // co-exist with a `Completed` resource of the same ID.)\n            if which_thread == 0 {\n                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot0_inv_half);\n            }\n            else {\n                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot1_inv_half);\n            }\n            assert(oneshot_thread_half@ is Complete);\n        }\n    });\n    // Return the updated permission. It's been updated from (a)\n    // half the authority to complete the one-shot to (b)\n    // knowledge that the one-shot is complete.\n    Tracked(oneshot_thread_half)\n}\n\n// This function counts to two by forking two threads, each tasked\n// with incrementing `x` and then returning knowledge that that\n// thread has performed its increment. In this way, it's able to\n// guarantee that when it reads `x` after joining those two\n// threads, the result is 2.\npub fn count_to_two() -> (result: Result<u32, ()>)\n    ensures\n        result is Ok ==> result.unwrap() == 2,\n{\n    // Create two one-shots, one for each thread we're going to\n    // fork. Calling `create_oneshot` provides two permissions to\n    // the one-shot resource, each granting half authority to\n    // perform the one-shot. We'll stash one half in our invariant\n    // and pass the other half to the appropriate thread. It's\n    // necessary to have both halves to perform any one-shot, so\n    // each thread will have to combine its half with the\n    // corresponding one in the invariant.\n    let tracked (mut oneshot0_inv_half, mut oneshot0_thread_half) =\n        OneShotResource::alloc().split();\n    let tracked (mut oneshot1_inv_half, mut oneshot1_thread_half) =\n        OneShotResource::alloc().split();\n    // Create the shared state that includes a new `PAtomicU32` and\n    // an invariant that starts out holding `oneshot0_inv_half` and\n    // `oneshot1_inv_half1.\n    let shared_state = CounterSharedState::new(\n        Tracked(oneshot0_inv_half),\n        Tracked(oneshot1_inv_half),\n    );\n    // For each thread, clone the shared-state Arc and use this to\n    // fork the thread. Also pass each thread a tracked permission\n    // providing half the authority to update its one-shot.\n    let shared_state_clone = shared_state.clone();\n    let join_handle0 = vstd::thread::spawn(\n        move || -> (return_value: Tracked<OneShotResource>)\n            ensures\n                return_value@.id() == shared_state.get_oneshot_id(0),\n                return_value@@ is Complete,\n            {\n                thread_routine(shared_state_clone, Tracked(oneshot0_thread_half), Ghost(0))\n            }\n    );\n    let shared_state_clone = shared_state.clone();\n    let join_handle1 = vstd::thread::spawn(\n        move || -> (return_value: Tracked<OneShotResource>)\n            ensures\n                return_value@.id() == shared_state.get_oneshot_id(1),\n                return_value@@ is Complete,\n            {\n                thread_routine(shared_state_clone, Tracked(oneshot1_thread_half), Ghost(1))\n            }\n    );\n    // Let the threads run in parallel, then join them both when\n    // they're done.\n    if let (Ok(oneshot0_complete), Ok(oneshot1_complete)) = (\n        join_handle0.join(),\n        join_handle1.join(),\n    ) {\n        // If both joins succeeded, we can now read the shared\n        // `PAtomicU32`'s value `x` by opening the invariant.\n        Ok(shared_state.read_x(oneshot0_complete, oneshot1_complete))\n    } else {\n        // If either of the joins failed, we can't proceed.\n        Err(())\n    }\n}\n\npub fn main() {\n    if let Ok(x) = count_to_two() {\n        assert(x == 2);\n    }\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/pcm/count_to_two.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 409, "verus_errors": [{"error_type": "Other", "error_text": "file not found for module `oneshot` ()", "message": "VerusErrorType.Other: file not found for module `oneshot` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [6, 6], "label": null, "text": [{"text": "pub mod oneshot;", "highlight_start": 1, "highlight_end": 17}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [28, 28], "label": "not found in this scope", "text": [{"text": "    pub oneshot0_inv_half: OneShotResource,", "highlight_start": 28, "highlight_end": 43}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [29, 29], "label": "not found in this scope", "text": [{"text": "    pub oneshot1_inv_half: OneShotResource,", "highlight_start": 28, "highlight_end": 43}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [118, 118], "label": "not found in this scope", "text": [{"text": "        Tracked(oneshot0_inv_half): Tracked<OneShotResource>,", "highlight_start": 45, "highlight_end": 60}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [119, 119], "label": "not found in this scope", "text": [{"text": "        Tracked(oneshot1_inv_half): Tracked<OneShotResource>,", "highlight_start": 45, "highlight_end": 60}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [154, 154], "label": "not found in this scope", "text": [{"text": "        Tracked(oneshot0_complete): Tracked<OneShotResource>,", "highlight_start": 45, "highlight_end": 60}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [155, 155], "label": "not found in this scope", "text": [{"text": "        Tracked(oneshot1_complete): Tracked<OneShotResource>,", "highlight_start": 45, "highlight_end": 60}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [213, 213], "label": "not found in this scope", "text": [{"text": "    Tracked(oneshot_thread_half): Tracked<OneShotResource>,", "highlight_start": 43, "highlight_end": 58}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [215, 215], "label": "not found in this scope", "text": [{"text": ") -> (return_permission: Tracked<OneShotResource>)", "highlight_start": 34, "highlight_end": 49}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [290, 290], "label": "not found in this scope", "text": [{"text": "        move || -> (return_value: Tracked<OneShotResource>)", "highlight_start": 43, "highlight_end": 58}]}]}, {"error_type": "Other", "error_text": "cannot find type `OneShotResource` in this scope (not found in this scope)", "message": "VerusErrorType.Other: cannot find type `OneShotResource` in this scope (not found in this scope)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [300, 300], "label": "not found in this scope", "text": [{"text": "        move || -> (return_value: Tracked<OneShotResource>)", "highlight_start": 43, "highlight_end": 58}]}]}, {"error_type": "Other", "error_text": "failed to resolve: use of undeclared type `OneShotResource` (use of undeclared type `OneShotResource`)", "message": "VerusErrorType.Other: failed to resolve: use of undeclared type `OneShotResource` (use of undeclared type `OneShotResource`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [275, 275], "label": "use of undeclared type `OneShotResource`", "text": [{"text": "        OneShotResource::alloc().split();", "highlight_start": 9, "highlight_end": 24}]}]}, {"error_type": "Other", "error_text": "failed to resolve: use of undeclared type `OneShotResource` (use of undeclared type `OneShotResource`)", "message": "VerusErrorType.Other: failed to resolve: use of undeclared type `OneShotResource` (use of undeclared type `OneShotResource`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3amc4aev", "lines": [277, 277], "label": "use of undeclared type `OneShotResource`", "text": [{"text": "        OneShotResource::alloc().split();", "highlight_start": 9, "highlight_end": 24}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 329, "minimized_LOC": 329, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::prelude::", "crate::oneshot::", "std::sync::Arc", "vstd::atomic::", "vstd::atomic_ghost::", "vstd::invariant::"], "complexity_verus_tokens": 43, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn new(\n        Tracked(oneshot0_inv_half): Tracked<OneShotResource>,\n        Tracked(oneshot1_inv_half): Tracked<OneShotResource>,\n    ) -> (result: Arc<Self>)\n        requires\n            oneshot0_inv_half@ is HalfRightToComplete,\n            oneshot1_inv_half@ is HalfRightToComplete,\n        ensures\n            result.wf(),\n            result.get_oneshot_id(0) == oneshot0_inv_half.id(),\n            result.get_oneshot_id(1) == oneshot1_inv_half.id(),\n    {\n\n pub fn read_x(\n        self: &Arc<Self>,\n        Tracked(oneshot0_complete): Tracked<OneShotResource>,\n        Tracked(oneshot1_complete): Tracked<OneShotResource>,\n    ) -> (x: u32)\n        requires\n            self.wf(),\n            oneshot0_complete.id() == self.get_oneshot_id(0),\n            oneshot1_complete.id() == self.get_oneshot_id(1),\n            oneshot0_complete@ is Complete,\n            oneshot1_complete@ is Complete,\n        ensures\n            x == 2,\n    {\n\n\npub fn thread_routine(\n    shared_state: Arc<CounterSharedState>,\n    Tracked(oneshot_thread_half): Tracked<OneShotResource>,\n    Ghost(which_thread): Ghost<int>,\n) -> (return_permission: Tracked<OneShotResource>)\n    requires\n        which_thread == 0 || which_thread == 1,\n        oneshot_thread_half@ is HalfRightToComplete,\n        shared_state.wf(),\n        oneshot_thread_half.id() == shared_state.get_oneshot_id(which_thread),\n    ensures\n        return_permission@.id() == shared_state.get_oneshot_id(which_thread),\n        return_permission@@ is Complete,\n{\n\n\npub fn count_to_two() -> (result: Result<u32, ()>)\n    ensures\n        result is Ok ==> result.unwrap() == 2,\n{\n\n\npub fn main() {", "spec": "spec fn inv(c: CounterInvariantConstants, cts: CounterTrackedState) -> bool {\n\nspec fn wf(self) -> bool {\n\nspec fn get_oneshot_id(self, which_thread: int) -> int\n        recommends\n            which_thread == 0 || which_thread == 1,\n    {\n\nuse vstd::invariant::*;\n\n// will keep in an invariant.\n\n// `oneshot0_inv_half` -- the invariant's resource for thread 0's\n\n// This struct describes what's constant in the counter invariant.\n\n// This is the invariant predicate that will be maintained for the\n\n        // For each thread's one-shot, the invariant holds a resource that's either\n\n        // The key invariant is that the value of `x` is the count\n\n// `inv` -- the invariant holding the shared counter tracked state\n\n        requires\n\n        ensures\n\n        // Create the invariant.\n\n    // that's part of this `CounterSharedState`. It requires, as\n\n        requires\n\n        ensures\n\n                // invariant's `oneshot0_inv_half` is also\n\n                // The invariant says that the value of `x` is equal to\n\n    requires\n\n    ensures\n\n            // This requires providing two half authorities. One was\n\n            // the other is in this invariant.\n\n            // Technically, the invariant just tells us that either\n\n            // requires that one of the resources be known to be a\n\n    ensures\n\n    // perform the one-shot. We'll stash one half in our invariant\n\n    // corresponding one in the invariant.\n\n    // an invariant that starts out holding `oneshot0_inv_half` and\n\n            ensures\n\n            ensures\n\n        // `PAtomicU32`'s value `x` by opening the invariant.", "proof": "proof {\n                // Since `oneshot0_complete` reflects thread 0's\n                // one-shot having completed, we can conclude that the\n                // invariant's `oneshot0_inv_half` is also\n                // `Completed`. After all, it's not possible for a\n                // `HalfRightToComplete` and `Completed` resource to\n                // co-exist for the same one-shot ID. We use\n                // `lemma_is_complete_if_other_is` to show this.\n\n                inner.oneshot0_inv_half.lemma_is_complete_if_other_is(&oneshot0_complete);\n\n                // Similarly for `oneshot1_complete` and thread 1's\n                // one-shot.\n\n                inner.oneshot1_inv_half.lemma_is_complete_if_other_is(&oneshot1_complete);\n\n                // The invariant says that the value of `x` is equal to\n                //\n                // ```\n                // (if cts.oneshot0_inv_half@ is Complete { 1int } else { 0int }) +\n                // (if cts.oneshot1_inv_half@ is Complete { 1int } else { 0int })\n                // ```\n                //\n                // Since we know both have completed, we know `x == 2`. So,\n                // when we load its value, that's what we'll get.\n            }\n\nproof {\n            // Atomically with that increment, perform the one-shot.\n            // This requires providing two half authorities. One was\n            // passed to this function as `oneshot_thread_half` and\n            // the other is in this invariant.\n            //\n            // Technically, the invariant just tells us that either\n            // the one-shot is complete *or* we have half authority to\n            // it. Fortunately, `perform_using_two_halves` only\n            // requires that one of the resources be known to be a\n            // half authority. (It can deduce that the other one must\n            // be, since a `HalfRightToComplete` resource can't\n            // co-exist with a `Completed` resource of the same ID.)\n            if which_thread == 0 {\n                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot0_inv_half);\n            }\n            else {\n                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot1_inv_half);\n            }\n            assert(oneshot_thread_half@ is Complete);\n        }"}}}, "all_snapshots": []}
{"id": "log_cc0b9f7d", "original_code": "//! This file implements logs with entries of type `T` using a custom\n//! resource algebra.\n//!\n//! To use it, use LogResource::<T>::alloc(), which will create a\n//! fresh log and return a `LogResource<T>` representing full\n//! authority to append to the log. Here's example code for this:\n//!\n//! ```\n//! let tracked full_auth = LogResource::<int>::alloc();\n//! assert(full_auth@ is FullAuthority);\n//! assert(full_auth@.log().len() == 0);\n//! ```\n//!\n//! You can use the full authority you obtain via `alloc()` to append\n//! to the log, as in the following example:\n//!\n//! ```\n//! proof { full_auth.append(42); }\n//! proof { full_auth.append(86); }\n//! assert(full_auth@.log().len() == 2);\n//! assert(full_auth@.log()[0] == 42);\n//! assert(full_auth@.log()[1] == 86);\n//! ```\n//!\n//! If desired, you can split a `LogResource` representing full\n//! authority into two half authorities using `split`. You may want to\n//! do this if you're stashing half the authority in an invariant.\n//! Here's an example use of `LogResource::split()`; note that it\n//! consumes the resource.\n//!\n//! ```\n//! let tracked (half_auth1, half_auth2) = full_auth.split();\n//! assert(half_auth1@ == half_auth2@);\n//! assert(half_auth1@ is HalfAuthority);\n//! ```\n//!\n//! You can use two half authorities to append to the log using\n//! `append_using_two_halves` as in the following example:\n//!\n//! ```\n//! proof { half_auth1.append_using_two_halves(&mut half_auth2, 17); }\n//! assert(half_auth1@.log().len() == 3);\n//! assert(half_auth1@.log()[2] == 17);\n//! assert(half_auth2@ == half_auth1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum LogResourceValue<T> {\n    PrefixKnowledge { prefix: Seq<T> },\n    HalfAuthority { log: Seq<T> },\n    FullAuthority { log: Seq<T> },\n    Invalid,\n}\n\npub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    &&& s1.len() <= s2.len()\n    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]\n}\n\nimpl<T> PCM for LogResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        &&& !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (\n                Self::PrefixKnowledge { prefix: prefix1 },\n                Self::PrefixKnowledge { prefix: prefix2 },\n            ) => if is_prefix(prefix1, prefix2) {\n                other\n            } else {\n                if is_prefix(prefix2, prefix1) {\n                    self\n                } else {\n                    Self::Invalid\n                }\n            },\n            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1\n                == log2 {\n                Self::FullAuthority { log: log1 }\n            } else {\n                Self::Invalid\n            },\n            (_, _) => Self::Invalid,\n        }\n    }\n\n    open spec fn unit() -> Self {\n        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl<T> LogResourceValue<T> {\n    pub open spec fn log(self) -> Seq<T> {\n        match self {\n            LogResourceValue::PrefixKnowledge { prefix } => prefix,\n            LogResourceValue::HalfAuthority { log } => log,\n            LogResourceValue::FullAuthority { log } => log,\n            LogResourceValue::Invalid => Seq::<T>::empty(),\n        }\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct LogResource<T> {\n    r: Resource<LogResourceValue<T>>,\n}\n\nimpl<T> LogResource<T> {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> LogResourceValue<T> {\n        self.r.value()\n    }\n\n    pub proof fn alloc() -> (tracked result: LogResource<T>)\n        ensures\n            result@ is FullAuthority,\n            result@.log() == Seq::<T>::empty(),\n    {\n        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };\n        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);\n        Self { r }\n    }\n\n    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))\n        requires\n            self@ is FullAuthority,\n        ensures\n            ({\n                let (half1, half2) = halves;\n                &&& half1@ is HalfAuthority\n                &&& half2@ is HalfAuthority\n                &&& half1.id() == half2.id() == self.id()\n                &&& half1@.log() == self@.log()\n                &&& half2@ == half1@\n            }),\n    {\n        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n        let tracked (half1, half2) = self.r.split(half_value, half_value);\n        (Self { r: half1 }, Self { r: half2 })\n    }\n\n    pub proof fn append(tracked &mut self, v: T)\n        requires\n            old(self)@ is FullAuthority,\n        ensures\n            self@ is FullAuthority,\n            self.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n    {\n        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };\n        update_mut(&mut self.r, value);\n    }\n\n    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)\n        requires\n            old(self)@ is HalfAuthority,\n            old(other)@ is HalfAuthority,\n            old(self).id() == old(other).id(),\n        ensures\n            self@ is HalfAuthority,\n            self.id() == other.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n            other@ == self@,\n    {\n        self.r.validate_2(&other.r);\n        let new_log = self@.log() + seq![v];\n        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };\n        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);\n    }\n\n    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is PrefixKnowledge,\n            out.id() == self.id(),\n            out@.log() == self@.log(),\n    {\n        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            is_prefix(self@.log(), other@.log()) || is_prefix(other@.log(), self@.log()),\n            self@ is HalfAuthority ==> is_prefix(other@.log(), self@.log()),\n            self@ is FullAuthority ==> is_prefix(other@.log(), self@.log()),\n            other@ is HalfAuthority ==> is_prefix(self@.log(), other@.log()),\n            other@ is FullAuthority ==> is_prefix(self@.log(), other@.log()),\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\npub fn main() {\n    let tracked full_auth = LogResource::<int>::alloc();\n    assert(full_auth@ is FullAuthority);\n    assert(full_auth@.log().len() == 0);\n    proof {\n        full_auth.append(42);\n    }\n    proof {\n        full_auth.append(86);\n    }\n    assert(full_auth@.log().len() == 2);\n    assert(full_auth@.log()[0] == 42);\n    assert(full_auth@.log()[1] == 86);\n    let tracked (half_auth1, half_auth2) = full_auth.split();\n    assert(half_auth1@ == half_auth2@);\n    assert(half_auth1@ is HalfAuthority);\n    proof {\n        half_auth1.append_using_two_halves(&mut half_auth2, 17);\n    }\n    assert(half_auth1@.log().len() == 3);\n    assert(half_auth1@.log()[2] == 17);\n    assert(half_auth2@ == half_auth1@);\n}\n\n} // verus!\n", "minimized_code": " use vstd::pcm::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum LogResourceValue<T> {\n          PrefixKnowledge {\n     prefix: Seq<T> }\n     ,     HalfAuthority {\n     log: Seq<T> }\n     ,     FullAuthority {\n     log: Seq<T> }\n     ,     Invalid, }\n       pub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n          &&& s1.len() <= s2.len()     &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i] }\n       impl<T> PCM for LogResourceValue<T> {\n          open spec fn valid(self) -> bool {\n             &&& !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (                 Self::PrefixKnowledge {\n   prefix: prefix1 }\n   ,                 Self::PrefixKnowledge {\n   prefix: prefix2 }\n   ,             ) => if is_prefix(prefix1, prefix2) {\n                   other             }\n    else {\n                   if is_prefix(prefix2, prefix1) {\n                       self                 }\n   else {\n                       Self::Invalid                 }\n               }\n   ,             (Self::PrefixKnowledge {\n   prefix }\n   , Self::HalfAuthority {\n   log }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   other             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::HalfAuthority {\n   log }\n   , Self::PrefixKnowledge {\n   prefix }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   self             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::PrefixKnowledge {\n   prefix }\n   , Self::FullAuthority {\n   log }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   other             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::FullAuthority {\n   log }\n   , Self::PrefixKnowledge {\n   prefix }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   self             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::HalfAuthority {\n   log: log1 }\n   , Self::HalfAuthority {\n   log: log2 }\n   ) => if log1                 == log2 {\n                   Self::FullAuthority {\n   log: log1 }\n               }\n    else {\n                   Self::Invalid             }\n   ,             (_, _) => Self::Invalid,         }\n         }\n          open spec fn unit() -> Self {\n             Self::PrefixKnowledge {\n    prefix: Seq::<>::empty() }\n         }\n          proof fn closed_under_incl(a: Self, b: Self) {}\n          proof fn commutative(a: Self, b: Self) {\n             assert(forall|log1: Seq<T>, log2: Seq<T>|             is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n         }\n          proof fn associative(a: Self, b: Self, c: Self) {}\n          proof fn op_unit(a: Self) {\n             assert(forall|log| is_prefix(log, Seq::<>::empty()) ==> log =~= Seq::<T>::empty());\n         }\n          proof fn unit_valid() {}\n      }\n       impl<T> LogResourceValue<T> {\n          pub open spec fn log(self) -> Seq<T> {\n             match self {\n                LogResourceValue::PrefixKnowledge {\n   prefix }\n    => prefix,             LogResourceValue::HalfAuthority {\n   log }\n    => log,             LogResourceValue::FullAuthority {\n   log }\n    => log,             LogResourceValue::Invalid => Seq::<>::empty(),         }\n         }\n      }\n       pub struct LogResource<T> {\n          r: Resource<LogResourceValue<T>>, }\n       impl<T> LogResource<T> {}\n       pub fn main() ;\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/pcm/log.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 2077, "minimize_time_ms": 338472, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 293, "minimized_LOC": 105, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "std::result::", "vstd::pcm::", "vstd::pcm_lib::", "vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 0.3583617747440273}, "labeling": {"segments": {"spec": "spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n\nspec fn valid(self) -> bool {\n\nspec fn op(self, other: Self) -> Self {\n\nspec fn unit() -> Self {\n\nspec fn log(self) -> Seq<T> {", "proof": "proof fn closed_under_incl(a: Self, b: Self) {\n\nproof fn commutative(a: Self, b: Self) {\n\nproof fn associative(a: Self, b: Self, c: Self) {\n\nproof fn op_unit(a: Self) {\n\nproof fn unit_valid() {"}}}, "all_snapshots": ["//! This file implements logs with entries of type `T` using a custom\n//! resource algebra.\n//!\n//! To use it, use LogResource::<T>::alloc(), which will create a\n//! fresh log and return a `LogResource<T>` representing full\n//! authority to append to the log. Here's example code for this:\n//!\n//! ```\n//! let tracked full_auth = LogResource::<int>::alloc();\n//! assert(full_auth@ is FullAuthority);\n//! assert(full_auth@.log().len() == 0);\n//! ```\n//!\n//! You can use the full authority you obtain via `alloc()` to append\n//! to the log, as in the following example:\n//!\n//! ```\n//! proof { full_auth.append(42); }\n//! proof { full_auth.append(86); }\n//! assert(full_auth@.log().len() == 2);\n//! assert(full_auth@.log()[0] == 42);\n//! assert(full_auth@.log()[1] == 86);\n//! ```\n//!\n//! If desired, you can split a `LogResource` representing full\n//! authority into two half authorities using `split`. You may want to\n//! do this if you're stashing half the authority in an invariant.\n//! Here's an example use of `LogResource::split()`; note that it\n//! consumes the resource.\n//!\n//! ```\n//! let tracked (half_auth1, half_auth2) = full_auth.split();\n//! assert(half_auth1@ == half_auth2@);\n//! assert(half_auth1@ is HalfAuthority);\n//! ```\n//!\n//! You can use two half authorities to append to the log using\n//! `append_using_two_halves` as in the following example:\n//!\n//! ```\n//! proof { half_auth1.append_using_two_halves(&mut half_auth2, 17); }\n//! assert(half_auth1@.log().len() == 3);\n//! assert(half_auth1@.log()[2] == 17);\n//! assert(half_auth2@ == half_auth1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum LogResourceValue<T> {\n    PrefixKnowledge { prefix: Seq<T> },\n    HalfAuthority { log: Seq<T> },\n    FullAuthority { log: Seq<T> },\n    Invalid,\n}\n\npub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    &&& s1.len() <= s2.len()\n    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]\n}\n\nimpl<T> PCM for LogResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        &&& !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (\n                Self::PrefixKnowledge { prefix: prefix1 },\n                Self::PrefixKnowledge { prefix: prefix2 },\n            ) => if is_prefix(prefix1, prefix2) {\n                other\n            } else {\n                if is_prefix(prefix2, prefix1) {\n                    self\n                } else {\n                    Self::Invalid\n                }\n            },\n            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1\n                == log2 {\n                Self::FullAuthority { log: log1 }\n            } else {\n                Self::Invalid\n            },\n            (_, _) => Self::Invalid,\n        }\n    }\n\n    open spec fn unit() -> Self {\n        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl<T> LogResourceValue<T> {\n    pub open spec fn log(self) -> Seq<T> {\n        match self {\n            LogResourceValue::PrefixKnowledge { prefix } => prefix,\n            LogResourceValue::HalfAuthority { log } => log,\n            LogResourceValue::FullAuthority { log } => log,\n            LogResourceValue::Invalid => Seq::<T>::empty(),\n        }\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct LogResource<T> {\n    r: Resource<LogResourceValue<T>>,\n}\n\nimpl<T> LogResource<T> {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> LogResourceValue<T> {\n        self.r.value()\n    }\n\n    pub proof fn alloc() -> (tracked result: LogResource<T>)\n        ensures\n            result@ is FullAuthority,\n            result@.log() == Seq::<T>::empty(),\n    {\n        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };\n        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);\n        Self { r }\n    }\n\n    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))\n        requires\n            self@ is FullAuthority,\n        ensures\n            ({\n                let (half1, half2) = halves;\n                &&& half1@ is HalfAuthority\n                &&& half2@ is HalfAuthority\n                &&& half1.id() == half2.id() == self.id()\n                &&& half1@.log() == self@.log()\n                &&& half2@ == half1@\n            }),\n    {\n        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n        let tracked (half1, half2) = self.r.split(half_value, half_value);\n        (Self { r: half1 }, Self { r: half2 })\n    }\n\n    pub proof fn append(tracked &mut self, v: T)\n        requires\n            old(self)@ is FullAuthority,\n        ensures\n            self@ is FullAuthority,\n            self.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n    {\n        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };\n        update_mut(&mut self.r, value);\n    }\n\n    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)\n        requires\n            old(self)@ is HalfAuthority,\n            old(other)@ is HalfAuthority,\n            old(self).id() == old(other).id(),\n        ensures\n            self@ is HalfAuthority,\n            self.id() == other.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n            other@ == self@,\n    {\n        self.r.validate_2(&other.r);\n        let new_log = self@.log() + seq![v];\n        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };\n        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);\n    }\n\n    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is PrefixKnowledge,\n            out.id() == self.id(),\n            out@.log() == self@.log(),\n    {\n        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            is_prefix(self@.log(), other@.log()) || is_prefix(other@.log(), self@.log()),\n            self@ is HalfAuthority ==> is_prefix(other@.log(), self@.log()),\n            self@ is FullAuthority ==> is_prefix(other@.log(), self@.log()),\n            other@ is HalfAuthority ==> is_prefix(self@.log(), other@.log()),\n            other@ is FullAuthority ==> is_prefix(self@.log(), other@.log()),\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\npub fn main() {\n    let tracked full_auth = LogResource::<int>::alloc();\n    assert(full_auth@ is FullAuthority);\n    assert(full_auth@.log().len() == 0);\n    proof {\n        full_auth.append(42);\n    }\n    proof {\n        full_auth.append(86);\n    }\n    assert(full_auth@.log().len() == 2);\n    assert(full_auth@.log()[0] == 42);\n    assert(full_auth@.log()[1] == 86);\n    let tracked (half_auth1, half_auth2) = full_auth.split();\n    assert(half_auth1@ == half_auth2@);\n    assert(half_auth1@ is HalfAuthority);\n    proof {\n        half_auth1.append_using_two_halves(&mut half_auth2, 17);\n    }\n    assert(half_auth1@.log().len() == 3);\n    assert(half_auth1@.log()[2] == 17);\n    assert(half_auth2@ == half_auth1@);\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use vstd::pcm::*;\n    use vstd::prelude::*;\n    verus! {\n   pub enum LogResourceValue<T> {\n      PrefixKnowledge {\n prefix: Seq<T> }\n ,     HalfAuthority {\n log: Seq<T> }\n ,     FullAuthority {\n log: Seq<T> }\n ,     Invalid, }\n   pub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n      &&& s1.len() <= s2.len()     &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i] }\n   impl<T> PCM for LogResourceValue<T> {\n      open spec fn valid(self) -> bool {\n         &&& !(self is Invalid)     }\n      open spec fn op(self, other: Self) -> Self {\n         match (self, other) {             (                 Self::PrefixKnowledge { prefix: prefix1 },                 Self::PrefixKnowledge { prefix: prefix2 },             ) => if is_prefix(prefix1, prefix2) {                 other             } else {                 if is_prefix(prefix2, prefix1) {                     self                 } else {                     Self::Invalid                 }             },             (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(                 prefix,                 log,             ) {                 other             } else {                 Self::Invalid             },             (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(                 prefix,                 log,             ) {                 self             } else {                 Self::Invalid             },             (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(                 prefix,                 log,             ) {                 other             } else {                 Self::Invalid             },             (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(                 prefix,                 log,             ) {                 self             } else {                 Self::Invalid             },             (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1                 == log2 {                 Self::FullAuthority { log: log1 }             } else {                 Self::Invalid             },             (_, _) => Self::Invalid,         }\n     }\n      open spec fn unit() -> Self {\n         Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n     }\n      proof fn closed_under_incl(a: Self, b: Self) {\n     }\n      proof fn commutative(a: Self, b: Self) {\n         assert(forall|log1: Seq<T>, log2: Seq<T>|             is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n     }\n      proof fn associative(a: Self, b: Self, c: Self) {\n         assert(forall|log1: Seq<T>, log2: Seq<T>|             is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n         assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n     }\n      proof fn op_unit(a: Self) {\n         assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n     }\n      proof fn unit_valid() {\n     }\n  }\n   impl<T> LogResourceValue<T> {\n      pub open spec fn log(self) -> Seq<T> {\n         match self {             LogResourceValue::PrefixKnowledge { prefix } => prefix,             LogResourceValue::HalfAuthority { log } => log,             LogResourceValue::FullAuthority { log } => log,             LogResourceValue::Invalid => Seq::<T>::empty(),         }\n     }\n  }\n   pub struct LogResource<T> {\n      r: Resource<LogResourceValue<T>>, }\n   impl<T> LogResource<T> {\n      pub closed spec fn id(self) -> Loc {\n         self.r.loc()     }\n      pub closed spec fn view(self) -> LogResourceValue<T> {\n         self.r.value()     }\n      pub proof fn split(tracked self) -> (tracked halves: (Self, Self))         requires             self@ is FullAuthority,         ensures             ({\n                 let (half1, half2) = halves;\n                 &&& half1@ is HalfAuthority                 &&& half2@ is HalfAuthority                 &&& half1.id() == half2.id() == self.id()                 &&& half1@.log() == self@.log()                 &&& half2@ == half1@             }\n ),     {\n         let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n         let tracked (half1, half2) = self.r.split(half_value, half_value);\n         (Self { r: half1 }\n, Self { r: half2 }\n)     }\n  }\n   pub fn main() {\n  }\n   }\n", " use vstd::pcm::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum LogResourceValue<T> {\n          PrefixKnowledge {\n     prefix: Seq<T> }\n     ,     HalfAuthority {\n     log: Seq<T> }\n     ,     FullAuthority {\n     log: Seq<T> }\n     ,     Invalid, }\n       pub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n          &&& s1.len() <= s2.len()     &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i] }\n       impl<T> PCM for LogResourceValue<T> {\n          open spec fn valid(self) -> bool {\n             &&& !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (                 Self::PrefixKnowledge {\n   prefix: prefix1 }\n   ,                 Self::PrefixKnowledge {\n   prefix: prefix2 }\n   ,             ) => if is_prefix(prefix1, prefix2) {\n                   other             }\n    else {\n                   if is_prefix(prefix2, prefix1) {\n                       self                 }\n   else {\n                       Self::Invalid                 }\n               }\n   ,             (Self::PrefixKnowledge {\n   prefix }\n   , Self::HalfAuthority {\n   log }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   other             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::HalfAuthority {\n   log }\n   , Self::PrefixKnowledge {\n   prefix }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   self             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::PrefixKnowledge {\n   prefix }\n   , Self::FullAuthority {\n   log }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   other             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::FullAuthority {\n   log }\n   , Self::PrefixKnowledge {\n   prefix }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   self             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::HalfAuthority {\n   log: log1 }\n   , Self::HalfAuthority {\n   log: log2 }\n   ) => if log1                 == log2 {\n                   Self::FullAuthority {\n   log: log1 }\n               }\n    else {\n                   Self::Invalid             }\n   ,             (_, _) => Self::Invalid,         }\n         }\n          open spec fn unit() -> Self {\n             Self::PrefixKnowledge {\n    prefix: Seq::<>::empty() }\n         }\n          proof fn closed_under_incl(a: Self, b: Self) {}\n          proof fn commutative(a: Self, b: Self) {\n             assert(forall|log1: Seq<T>, log2: Seq<T>|             is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n         }\n          proof fn associative(a: Self, b: Self, c: Self) {}\n          proof fn op_unit(a: Self) {\n             assert(forall|log| is_prefix(log, Seq::<>::empty()) ==> log =~= Seq::<T>::empty());\n         }\n          proof fn unit_valid() {}\n      }\n       impl<T> LogResourceValue<T> {\n          pub open spec fn log(self) -> Seq<T> {\n             match self {\n                LogResourceValue::PrefixKnowledge {\n   prefix }\n    => prefix,             LogResourceValue::HalfAuthority {\n   log }\n    => log,             LogResourceValue::FullAuthority {\n   log }\n    => log,             LogResourceValue::Invalid => Seq::<>::empty(),         }\n         }\n      }\n       pub struct LogResource<T> {\n          r: Resource<LogResourceValue<T>>, }\n       impl<T> LogResource<T> {}\n       pub fn main() ;\n       }\n", "          use vstd::prelude::*;\n            verus! {\n          pub fn main() ;\n          }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "monotonic_counter_cc0b9f7d", "original_code": "//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! proof { full.increment(); }\n//! assert(full@.n() == 1);\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//! invariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof { half1.increment_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id());\n//! assert(half1@ == half2@);\n//! assert(half1@.n() == half2@.n() == v1 + 1);\n//! ```\n//!\n//! From any `MonotonicCounterResource`, one can use\n//! `extract_lower_bound()` to extract a `MonotonicCounterResource`\n//! that represents knowledge of a lower bound on the current value of\n//! the monotonic counter. You can also duplicate a\n//! `MonotonicCounterResource` using this function. Here are examples:\n//!\n//! ```\n//! let tracked mut lower_bound = half1.extract_lower_bound();\n//! assert(lower_bound@.n() == 1);\n//! let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n//! assert(lower_bound_duplicate@.n() == 1);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n        ensures\n            result@ == (MonotonicCounterResourceValue::FullRightToAdvance { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n        requires\n            self.id() == other.id(),\n            self@.n() == other@.n()\n        ensures\n            r.id() == self.id(),\n            r@.n() == self@.op(other@).n(),\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToAdvance,\n        ensures\n            ({\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n        requires\n            old(self)@ is FullRightToAdvance,\n        ensures\n            self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance,\n        ensures\n            old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n(),\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n    proof {\n        full.increment();\n    }\n    assert(full@.n() == 1);\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n    assert(half1.id() == half2.id());\n    assert(half1@.n() == 0);\n    assert(half2@.n() == 0);\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n    assert(v1 == v2);\n    proof {\n        half1.increment_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@.n() == half2@.n() == v1 + 1);\n    assert(half1@.n() == 1);\n    let tracked mut lower_bound = half1.extract_lower_bound();\n    assert(lower_bound@.n() == 1);\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n    assert(lower_bound_duplicate@.n() == 1);\n\n\n    proof {\n        let tracked reconstructed_full = half1.join(half2);\n        zero_lower_bound.lemma_lower_bound(&reconstructed_full);\n        assert(zero_lower_bound@.n() <= reconstructed_full@.n());\n    }\n}\n\n} // verus!\n", "minimized_code": " use vstd::pcm::*;\n     use vstd::pcm_lib::*;\n     use vstd::prelude::*;\n     verus! {\n    pub enum MonotonicCounterResourceValue {\n       LowerBound {\n  lower_bound: nat }\n  ,     HalfRightToAdvance {\n  value: nat }\n  ,     FullRightToAdvance {\n  value: nat }\n  ,     Invalid, }\n    impl PCM for MonotonicCounterResourceValue {\n       open spec fn valid(self) -> bool {\n          !(self is Invalid)     }\n       open spec fn op(self, other: Self) -> Self {\n          match (self, other) {\n             (                 MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 }\n,             ) => {                 let max_lower_bound = if lower_bound1 > lower_bound2 {                     lower_bound1                 } else {                     lower_bound2                 };                 MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }             }\n,             (                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,                 MonotonicCounterResourceValue::FullRightToAdvance { value }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::FullRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::FullRightToAdvance { value }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::FullRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,                 MonotonicCounterResourceValue::HalfRightToAdvance { value }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::HalfRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::HalfRightToAdvance { value }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::HalfRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 }\n,                 MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 }\n,             ) => if value1 == value2 {                 MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (_, _) => MonotonicCounterResourceValue::Invalid {  }\n,         }\n      }\n       open spec fn unit() -> Self {\n          MonotonicCounterResourceValue::LowerBound {\n lower_bound: 0 }\n      }\n       proof fn closed_under_incl(a: Self, b: Self) {\n      }\n       proof fn commutative(a: Self, b: Self) {\n      }\n       proof fn associative(a: Self, b: Self, c: Self) {\n      }\n       proof fn op_unit(a: Self) {\n      }\n       proof fn unit_valid() {\n      }\n   }\n    impl MonotonicCounterResourceValue {\n       pub open spec fn n(self) -> nat {\n          match self {\n             MonotonicCounterResourceValue::LowerBound { lower_bound }\n => lower_bound,             MonotonicCounterResourceValue::HalfRightToAdvance { value }\n => value,             MonotonicCounterResourceValue::FullRightToAdvance { value }\n => value,             MonotonicCounterResourceValue::Invalid => 0,         }\n      }\n   }\n    pub struct MonotonicCounterResource {\n       r: Resource<MonotonicCounterResourceValue>, }\n    impl MonotonicCounterResource {\n       pub closed spec fn id(self) -> Loc {\n          self.r.loc()     }\n       pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n          self.r.value()     }\n       pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToAdvance,         ensures             ({\n                  let (r1, r2) = return_value;\n                  let value = self@->FullRightToAdvance_value;\n                  &&& r1.id() == r2.id() == self.id()                 &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n value }\n )                 &&& r2@ == r1@             }\n  ),     {\n          let value = self@->FullRightToAdvance_value;\n          let v_half = MonotonicCounterResourceValue::HalfRightToAdvance {\n value };\n          let tracked (r1, r2) = self.r.split(v_half, v_half);\n          (Self {\n r: r1 }\n , Self {\n r: r2 }\n )     }\n       pub proof fn increment(tracked &mut self)         requires             old(self)@ is FullRightToAdvance,         ensures             self.id() == old(self).id(),             self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                  value: old(self)@->FullRightToAdvance_value + 1,             }\n  ),     {\n          let v = self@->FullRightToAdvance_value;\n          let r = MonotonicCounterResourceValue::FullRightToAdvance {\n value: v + 1 };\n          update_mut(&mut self.r, r);\n      }\n       pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)         requires             old(self).id() == old(other).id(),             old(self)@ is HalfRightToAdvance,             old(other)@ is HalfRightToAdvance,         ensures             old(self)@ == old(other)@,             self.id() == other.id() == old(self).id(),             other@ == self@,             self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                  value: old(self)@->HalfRightToAdvance_value + 1,             }\n  ),     {\n          self.r.validate_2(&other.r);\n          let v = self@->HalfRightToAdvance_value;\n          let r = MonotonicCounterResourceValue::HalfRightToAdvance {\n value: v + 1 };\n          update_and_redistribute(&mut self.r, &mut other.r, r, r);\n      }\n       pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)         ensures             out@ is LowerBound,             out.id() == self.id(),             out@ == (MonotonicCounterResourceValue::LowerBound {\n  lower_bound: self@.n() }\n  ),     {\n          let v = MonotonicCounterResourceValue::LowerBound {\n lower_bound: self@.n() };\n          let tracked r = copy_duplicable_part(&self.r, v);\n          Self {\n r }\n      }\n   }\n    fn main() {\n   }\n    }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/pcm/monotonic_counter.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 994, "minimize_time_ms": 368067, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 356, "minimized_LOC": 120, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "std::result::", "vstd::pcm::", "vstd::pcm_lib::", "vstd::prelude::"], "complexity_verus_tokens": 23, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 0.33707865168539325}, "labeling": {"ensures_count": 1, "segments": {"exec": " fn main() {", "spec": "spec fn valid(self) -> bool {\n\nspec fn op(self, other: Self) -> Self {\n\nspec fn unit() -> Self {\n\nspec fn n(self) -> nat {\n\nspec fn id(self) -> Loc {\n\nspec fn view(self) -> MonotonicCounterResourceValue {\n\n       pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToAdvance,         ensures             ({\n\n       pub proof fn increment(tracked &mut self)         requires             old(self)@ is FullRightToAdvance,         ensures             self.id() == old(self).id(),             self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n\n       pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)         requires             old(self).id() == old(other).id(),             old(self)@ is HalfRightToAdvance,             old(other)@ is HalfRightToAdvance,         ensures             old(self)@ == old(other)@,             self.id() == other.id() == old(self).id(),             other@ == self@,             self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n\n       pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)         ensures             out@ is LowerBound,             out.id() == self.id(),             out@ == (MonotonicCounterResourceValue::LowerBound {", "proof": "proof fn closed_under_incl(a: Self, b: Self) {\n\nproof fn commutative(a: Self, b: Self) {\n\nproof fn associative(a: Self, b: Self, c: Self) {\n\nproof fn op_unit(a: Self) {\n\nproof fn unit_valid() {\n\nproof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToAdvance,         ensures             ({\n\nproof fn increment(tracked &mut self)         requires             old(self)@ is FullRightToAdvance,         ensures             self.id() == old(self).id(),             self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n\nproof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)         requires             old(self).id() == old(other).id(),             old(self)@ is HalfRightToAdvance,             old(other)@ is HalfRightToAdvance,         ensures             old(self)@ == old(other)@,             self.id() == other.id() == old(self).id(),             other@ == self@,             self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n\nproof fn extract_lower_bound(tracked &self) -> (tracked out: Self)         ensures             out@ is LowerBound,             out.id() == self.id(),             out@ == (MonotonicCounterResourceValue::LowerBound {"}}}, "all_snapshots": ["//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! proof { full.increment(); }\n//! assert(full@.n() == 1);\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//! invariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof { half1.increment_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id());\n//! assert(half1@ == half2@);\n//! assert(half1@.n() == half2@.n() == v1 + 1);\n//! ```\n//!\n//! From any `MonotonicCounterResource`, one can use\n//! `extract_lower_bound()` to extract a `MonotonicCounterResource`\n//! that represents knowledge of a lower bound on the current value of\n//! the monotonic counter. You can also duplicate a\n//! `MonotonicCounterResource` using this function. Here are examples:\n//!\n//! ```\n//! let tracked mut lower_bound = half1.extract_lower_bound();\n//! assert(lower_bound@.n() == 1);\n//! let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n//! assert(lower_bound_duplicate@.n() == 1);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n        ensures\n            result@ == (MonotonicCounterResourceValue::FullRightToAdvance { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n        requires\n            self.id() == other.id(),\n            self@.n() == other@.n()\n        ensures\n            r.id() == self.id(),\n            r@.n() == self@.op(other@).n(),\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToAdvance,\n        ensures\n            ({\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n        requires\n            old(self)@ is FullRightToAdvance,\n        ensures\n            self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance,\n        ensures\n            old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n(),\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n    proof {\n        full.increment();\n    }\n    assert(full@.n() == 1);\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n    assert(half1.id() == half2.id());\n    assert(half1@.n() == 0);\n    assert(half2@.n() == 0);\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n    assert(v1 == v2);\n    proof {\n        half1.increment_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@.n() == half2@.n() == v1 + 1);\n    assert(half1@.n() == 1);\n    let tracked mut lower_bound = half1.extract_lower_bound();\n    assert(lower_bound@.n() == 1);\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n    assert(lower_bound_duplicate@.n() == 1);\n\n\n    proof {\n        let tracked reconstructed_full = half1.join(half2);\n        zero_lower_bound.lemma_lower_bound(&reconstructed_full);\n        assert(zero_lower_bound@.n() <= reconstructed_full@.n());\n    }\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use vstd::pcm::*;\n     use vstd::pcm_lib::*;\n     use vstd::prelude::*;\n     verus! {\n    pub enum MonotonicCounterResourceValue {\n       LowerBound {\n  lower_bound: nat }\n  ,     HalfRightToAdvance {\n  value: nat }\n  ,     FullRightToAdvance {\n  value: nat }\n  ,     Invalid, }\n    impl PCM for MonotonicCounterResourceValue {\n       open spec fn valid(self) -> bool {\n          !(self is Invalid)     }\n       open spec fn op(self, other: Self) -> Self {\n          match (self, other) {\n             (                 MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 }\n,             ) => {                 let max_lower_bound = if lower_bound1 > lower_bound2 {                     lower_bound1                 } else {                     lower_bound2                 };                 MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }             }\n,             (                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,                 MonotonicCounterResourceValue::FullRightToAdvance { value }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::FullRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::FullRightToAdvance { value }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::FullRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,                 MonotonicCounterResourceValue::HalfRightToAdvance { value }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::HalfRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::HalfRightToAdvance { value }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::HalfRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 }\n,                 MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 }\n,             ) => if value1 == value2 {                 MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (_, _) => MonotonicCounterResourceValue::Invalid {  }\n,         }\n      }\n       open spec fn unit() -> Self {\n          MonotonicCounterResourceValue::LowerBound {\n lower_bound: 0 }\n      }\n       proof fn closed_under_incl(a: Self, b: Self) {\n      }\n       proof fn commutative(a: Self, b: Self) {\n      }\n       proof fn associative(a: Self, b: Self, c: Self) {\n      }\n       proof fn op_unit(a: Self) {\n      }\n       proof fn unit_valid() {\n      }\n   }\n    impl MonotonicCounterResourceValue {\n       pub open spec fn n(self) -> nat {\n          match self {\n             MonotonicCounterResourceValue::LowerBound { lower_bound }\n => lower_bound,             MonotonicCounterResourceValue::HalfRightToAdvance { value }\n => value,             MonotonicCounterResourceValue::FullRightToAdvance { value }\n => value,             MonotonicCounterResourceValue::Invalid => 0,         }\n      }\n   }\n    pub struct MonotonicCounterResource {\n       r: Resource<MonotonicCounterResourceValue>, }\n    impl MonotonicCounterResource {\n       pub closed spec fn id(self) -> Loc {\n          self.r.loc()     }\n       pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n          self.r.value()     }\n       pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToAdvance,         ensures             ({\n                  let (r1, r2) = return_value;\n                  let value = self@->FullRightToAdvance_value;\n                  &&& r1.id() == r2.id() == self.id()                 &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n value }\n )                 &&& r2@ == r1@             }\n  ),     {\n          let value = self@->FullRightToAdvance_value;\n          let v_half = MonotonicCounterResourceValue::HalfRightToAdvance {\n value };\n          let tracked (r1, r2) = self.r.split(v_half, v_half);\n          (Self {\n r: r1 }\n , Self {\n r: r2 }\n )     }\n       pub proof fn increment(tracked &mut self)         requires             old(self)@ is FullRightToAdvance,         ensures             self.id() == old(self).id(),             self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                  value: old(self)@->FullRightToAdvance_value + 1,             }\n  ),     {\n          let v = self@->FullRightToAdvance_value;\n          let r = MonotonicCounterResourceValue::FullRightToAdvance {\n value: v + 1 };\n          update_mut(&mut self.r, r);\n      }\n       pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)         requires             old(self).id() == old(other).id(),             old(self)@ is HalfRightToAdvance,             old(other)@ is HalfRightToAdvance,         ensures             old(self)@ == old(other)@,             self.id() == other.id() == old(self).id(),             other@ == self@,             self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                  value: old(self)@->HalfRightToAdvance_value + 1,             }\n  ),     {\n          self.r.validate_2(&other.r);\n          let v = self@->HalfRightToAdvance_value;\n          let r = MonotonicCounterResourceValue::HalfRightToAdvance {\n value: v + 1 };\n          update_and_redistribute(&mut self.r, &mut other.r, r, r);\n      }\n       pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)         ensures             out@ is LowerBound,             out.id() == self.id(),             out@ == (MonotonicCounterResourceValue::LowerBound {\n  lower_bound: self@.n() }\n  ),     {\n          let v = MonotonicCounterResourceValue::LowerBound {\n lower_bound: self@.n() };\n          let tracked r = copy_duplicable_part(&self.r, v);\n          Self {\n r }\n      }\n   }\n    fn main() {\n   }\n    }\n", " use vstd::pcm::*;\n        use vstd::pcm_lib::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum MonotonicCounterResourceValue {\n          LowerBound {\n     lower_bound: nat }\n     ,     HalfRightToAdvance {\n     value: nat }\n     ,     FullRightToAdvance {\n     value: nat }\n     ,     Invalid, }\n       impl PCM for MonotonicCounterResourceValue {\n          open spec fn valid(self) -> bool {\n             !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound: lower_bound1 }\n   ,                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound: lower_bound2 }\n   ,             ) => {\n                   let max_lower_bound = if lower_bound1 > lower_bound2 {\n                       lower_bound1                 }\n   else {\n                       lower_bound2                 };\n                   MonotonicCounterResourceValue::LowerBound {\n   lower_bound: max_lower_bound }\n               }\n   ,             (                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n   ,                 MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n   ,             ) => if lower_bound <= value {\n                   MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (                 MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n   ,                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n   ,             ) => if lower_bound <= value {\n                   MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n   ,                 MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n   ,             ) => if lower_bound <= value {\n                   MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (                 MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n   ,                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n   ,             ) => if lower_bound <= value {\n                   MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (                 MonotonicCounterResourceValue::HalfRightToAdvance {\n   value: value1 }\n   ,                 MonotonicCounterResourceValue::HalfRightToAdvance {\n   value: value2 }\n   ,             ) => if value1 == value2 {\n                   MonotonicCounterResourceValue::FullRightToAdvance {\n   value: value1 }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (_, _) => MonotonicCounterResourceValue::Invalid \n   ,         }\n         }\n          open spec fn unit() -> Self {\n             MonotonicCounterResourceValue::LowerBound {\n    lower_bound: 0 }\n         }\n          proof fn closed_under_incl(a: Self, b: Self) {}\n          proof fn commutative(a: Self, b: Self) {}\n          proof fn associative(a: Self, b: Self, c: Self) {}\n          proof fn op_unit(a: Self) {}\n          proof fn unit_valid() {}\n      }\n       impl MonotonicCounterResourceValue {\n          pub open spec fn n(self) -> nat {\n             match self {\n                MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n    => lower_bound,             MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n    => value,             MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n    => value,             MonotonicCounterResourceValue::Invalid => 0,         }\n         }\n      }\n       pub struct MonotonicCounterResource {\n          r: Resource<MonotonicCounterResourceValue>, }\n       impl MonotonicCounterResource {}\n       fn main() ;\n       }\n", "          use vstd::prelude::*;\n           verus! {\n         fn main() ;\n         }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "oneshot_cc0b9f7d", "original_code": "//! This file implements one-shot permissions using a custom resource\n//! algebra.\n//!\n//! A one-shot allows an operation to be performed exactly once. If\n//! you have two resources each granting half authority to perform it,\n//! you can combine them and perform the one-shot. Performing it\n//! grants duplicable knowledge that it has been performed.\n//!\n//! To create a one-shot, call `OneShotResource::alloc()`. This will\n//! return a resource granting full authority to perform the created\n//! one-shot. You can then call `perform` to perform that one-shot.\n//! Here's an example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! proof { full.perform(); }\n//! assert(full@ is Complete);\n//! ```\n//!\n//! Often, you will first split the full authority into two halves,\n//! each granting half the authority to perform the created one-shot.\n//! This way, you can stash one in an invariant. Both halves will have\n//! the same `id()`, meaning they belong to the same one-shot\n//! instance. For example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@ is HalfRightToComplete);\n//! assert(half2@ is HalfRightToComplete);\n//! ```\n//!\n//! To perform a one-shot using two halves, use\n//! `perform_using_two_halves`. This function takes two resources, the\n//! first of which must provide half authority to perform the\n//! one-shot. On return, the passed-in resources will have both been\n//! changed to `Complete`, i.e., knowledge that the one-shot has\n//! complete.\n//!\n//! ```\n//! let ghost id = half1.id();\n//! proof { half1.perform_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id() == id);\n//! assert(half1@ is Complete);\n//! assert(half2@ is Complete);\n//! ```\n//!\n//! Note that only *one* of the two parameters to `perform` has to be\n//! `HalfRightToComplete`. This is useful so you can stash half the\n//! authority in an invariant and call `perform` even if the invariant\n//! predicate allows the stashed permission to change later.\n//!\n//! Knowledge that the one-shot has completed is freely duplicable\n//! because that's the nature of one-shots. If you want to duplicate\n//! it, you can call `duplicate`, but you can only call this if you\n//! know the permission passed in is `Complete`. Here's an example of\n//! its usage:\n//!\n//! ```\n//! let tracked knowledge = half1.duplicate();\n//! assert(knowledge.id() == half1.id());\n//! assert(knowledge@ is Complete);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A one-shot resource represents one of the following four resources:\n//\n// `FullRightToComplete` -- the authority to complete the one-shot;\n//\n// `HalfRightToComplete` -- half of the authority to complete the\n// one-shot, which can be combined with another half to make a full\n// authority; or\n//\n// `Complete` -- knowledge that the one-shot has completed.\n//\n// `Empty` - no permission at all.\npub enum OneShotResourceValue {\n    FullRightToComplete,\n    HalfRightToComplete,\n    Complete,\n    Empty,\n    Invalid,\n}\n\n// To use `OneShotResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for OneShotResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (OneShotResourceValue::Empty, _) => other,\n            (_, OneShotResourceValue::Empty) => self,\n            (\n                OneShotResourceValue::HalfRightToComplete,\n                OneShotResourceValue::HalfRightToComplete,\n            ) => OneShotResourceValue::FullRightToComplete {  },\n            (\n                OneShotResourceValue::Complete,\n                OneShotResourceValue::Complete,\n            ) => OneShotResourceValue::Complete {  },\n            (_, _) => OneShotResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        OneShotResourceValue::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct OneShotResource {\n    r: Resource<OneShotResourceValue>,\n}\n\nimpl OneShotResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> OneShotResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a one-shot and returns a resource\n    // granting the full authority to perform the created\n    // one-shot.\n    pub proof fn alloc() -> (tracked resource: Self)\n        ensures\n            resource@ is FullRightToComplete,\n    {\n        let v = OneShotResourceValue::FullRightToComplete {  };\n        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);\n        OneShotResource { r }\n    }\n\n    // This function splits full authority to perform a one-shot\n    // into two half authorities to perform it.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToComplete,\n        ensures\n            ({\n                let (half1, half2) = return_value;\n                &&& half1@ is HalfRightToComplete\n                &&& half2@ is HalfRightToComplete\n                &&& half2.id() == half1.id() == self.id()\n            }),\n    {\n        let half = OneShotResourceValue::HalfRightToComplete {  };\n        let tracked (r1, r2) = self.r.split(half, half);\n        (OneShotResource { r: r1 }, OneShotResource { r: r2 })\n    }\n\n    // This function performs a one-shot given a resource representing\n    // full authority to complete the one-shot.\n    //\n    // Upon return, the passed-in resource will have been transformed\n    // into knowledge that the one-shot has been performed.\n    pub proof fn perform(tracked &mut self)\n        requires\n            old(self)@ is FullRightToComplete,\n        ensures\n            self@ is Complete,\n    {\n        let v = OneShotResourceValue::Complete {  };\n        update_mut(&mut self.r, v);\n    }\n\n    // This function performs a one-shot given two resources, the\n    // first of which represents an incomplete one-shot (and half the\n    // authority needed to perform it). The resources must have the\n    // same `id()`, meaning they're talking about the same one-shot.\n    //\n    // Upon return, the passed-in resources will have both been\n    // transformed into knowledge that the one-shot has been\n    // performed.\n    //\n    // The caller of this function only needs to know that `self`\n    // provides half authority and that `other` isn't `Empty`. Upon\n    // return the caller will learn that *both* the resources had\n    // provided half authority at call time. However, those resources\n    // were transformed so they don't provide that authority anymore.\n    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(other).id() == old(self).id(),\n            old(self)@ is HalfRightToComplete,\n            !(old(other)@ is Empty),\n        ensures\n            old(other)@ is HalfRightToComplete,\n            self@ is Complete,\n            other@ is Complete,\n            other.id() == self.id() == old(self).id(),\n    {\n        self.r.validate();\n        other.r.validate();\n        // A `HalfRightToComplete` doesn't combine validly with a\n        // `Complete`, so validating them together proves that\n        // `other.r.value()` is `HalfRightToComplete`.\n        self.r.validate_2(&other.r);\n        assert(other@ is HalfRightToComplete);\n        // Knowing they're both `HalfRightToComplete` allows them to\n        // be combined and transformed into `Complete` resources.\n        let v = OneShotResourceValue::Complete {  };\n        update_and_redistribute(&mut self.r, &mut other.r, v, v);\n    }\n\n    // This function duplicates a one-shot resource representing\n    // knowledge of completion.\n    pub proof fn duplicate(tracked &self) -> (tracked other: Self)\n        requires\n            self@ is Complete,\n        ensures\n            other.id() == self.id(),\n            other@ is Complete,\n    {\n        let tracked r = duplicate(&self.r);\n        Self { r }\n    }\n\n    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)\n        requires\n            other.id() == old(self).id(),\n            other@ is Complete,\n            !(old(self)@ is Empty),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ is Complete,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\n// This example illustrates some uses of the one-shot functions.\nfn main() {\n    let tracked full = OneShotResource::alloc();\n    proof {\n        full.perform();\n    }\n    assert(full@ is Complete);\n    let tracked different_oneshot = OneShotResource::alloc();\n    let tracked (mut half1, mut half2) = different_oneshot.split();\n    let ghost id = half1.id();\n    assert(half1.id() == half2.id());\n    assert(half1@ is HalfRightToComplete);\n    assert(half2@ is HalfRightToComplete);\n    proof {\n        half1.perform_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@ is Complete);\n    assert(half2@ is Complete);\n    let tracked knowledge = half1.duplicate();\n    assert(knowledge.id() == half1.id() == id);\n    assert(knowledge@ is Complete);\n}\n\n} // verus!\n", "minimized_code": " use vstd::pcm::*;\n      use vstd::prelude::*;\n      verus! {\n     pub enum OneShotResourceValue {\n        FullRightToComplete,     HalfRightToComplete,     Complete,     Empty,     Invalid, }\n     impl PCM for OneShotResourceValue {\n        open spec fn valid(self) -> bool {\n           !(self is Invalid)     }\n        open spec fn op(self, other: Self) -> Self {\n           match (self, other) {\n              (OneShotResourceValue::Empty, _) => other,             (_, OneShotResourceValue::Empty) => self,             (                 OneShotResourceValue::HalfRightToComplete,                 OneShotResourceValue::HalfRightToComplete,             ) => OneShotResourceValue::FullRightToComplete {\n  }\n ,             (_, _) => OneShotResourceValue::Invalid {\n  }\n ,         }\n       }\n        open spec fn unit() -> Self {\n           OneShotResourceValue::Empty {\n   }\n       }\n        proof fn closed_under_incl(a: Self, b: Self) {\n       }\n        proof fn commutative(a: Self, b: Self) {\n       }\n        proof fn associative(a: Self, b: Self, c: Self) {\n       }\n        proof fn op_unit(a: Self) {\n       }\n        proof fn unit_valid() {\n       }\n    }\n     pub struct OneShotResource {\n        r: Resource<OneShotResourceValue>, }\n     impl OneShotResource {\n        pub closed spec fn id(self) -> Loc {\n           self.r.loc()     }\n        pub closed spec fn view(self) -> OneShotResourceValue {\n           self.r.value()     }\n        pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToComplete,         ensures             ({\n                   let (half1, half2) = return_value;\n                   &&& half1@ is HalfRightToComplete                 &&& half2@ is HalfRightToComplete                 &&& half2.id() == half1.id() == self.id()             }\n   ),     {\n           let half = OneShotResourceValue::HalfRightToComplete {\n   };\n           let tracked (r1, r2) = self.r.split(half, half);\n           (OneShotResource {\n  r: r1 }\n  , OneShotResource {\n  r: r2 }\n  )     }\n    }\n     fn main() {\n    }\n     }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/pcm/oneshot.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1026, "minimize_time_ms": 246830, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 284, "minimized_LOC": 54, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "std::result::", "vstd::pcm::", "vstd::pcm_lib::", "vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 0.19014084507042253}, "labeling": {"ensures_count": 1, "segments": {"exec": " fn main() {", "spec": "spec fn valid(self) -> bool {\n\nspec fn op(self, other: Self) -> Self {\n\nspec fn unit() -> Self {\n\nspec fn id(self) -> Loc {\n\nspec fn view(self) -> OneShotResourceValue {\n\n        pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToComplete,         ensures             ({", "proof": "proof fn closed_under_incl(a: Self, b: Self) {\n\nproof fn commutative(a: Self, b: Self) {\n\nproof fn associative(a: Self, b: Self, c: Self) {\n\nproof fn op_unit(a: Self) {\n\nproof fn unit_valid() {\n\nproof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToComplete,         ensures             ({"}}}, "all_snapshots": ["//! This file implements one-shot permissions using a custom resource\n//! algebra.\n//!\n//! A one-shot allows an operation to be performed exactly once. If\n//! you have two resources each granting half authority to perform it,\n//! you can combine them and perform the one-shot. Performing it\n//! grants duplicable knowledge that it has been performed.\n//!\n//! To create a one-shot, call `OneShotResource::alloc()`. This will\n//! return a resource granting full authority to perform the created\n//! one-shot. You can then call `perform` to perform that one-shot.\n//! Here's an example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! proof { full.perform(); }\n//! assert(full@ is Complete);\n//! ```\n//!\n//! Often, you will first split the full authority into two halves,\n//! each granting half the authority to perform the created one-shot.\n//! This way, you can stash one in an invariant. Both halves will have\n//! the same `id()`, meaning they belong to the same one-shot\n//! instance. For example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@ is HalfRightToComplete);\n//! assert(half2@ is HalfRightToComplete);\n//! ```\n//!\n//! To perform a one-shot using two halves, use\n//! `perform_using_two_halves`. This function takes two resources, the\n//! first of which must provide half authority to perform the\n//! one-shot. On return, the passed-in resources will have both been\n//! changed to `Complete`, i.e., knowledge that the one-shot has\n//! complete.\n//!\n//! ```\n//! let ghost id = half1.id();\n//! proof { half1.perform_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id() == id);\n//! assert(half1@ is Complete);\n//! assert(half2@ is Complete);\n//! ```\n//!\n//! Note that only *one* of the two parameters to `perform` has to be\n//! `HalfRightToComplete`. This is useful so you can stash half the\n//! authority in an invariant and call `perform` even if the invariant\n//! predicate allows the stashed permission to change later.\n//!\n//! Knowledge that the one-shot has completed is freely duplicable\n//! because that's the nature of one-shots. If you want to duplicate\n//! it, you can call `duplicate`, but you can only call this if you\n//! know the permission passed in is `Complete`. Here's an example of\n//! its usage:\n//!\n//! ```\n//! let tracked knowledge = half1.duplicate();\n//! assert(knowledge.id() == half1.id());\n//! assert(knowledge@ is Complete);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A one-shot resource represents one of the following four resources:\n//\n// `FullRightToComplete` -- the authority to complete the one-shot;\n//\n// `HalfRightToComplete` -- half of the authority to complete the\n// one-shot, which can be combined with another half to make a full\n// authority; or\n//\n// `Complete` -- knowledge that the one-shot has completed.\n//\n// `Empty` - no permission at all.\npub enum OneShotResourceValue {\n    FullRightToComplete,\n    HalfRightToComplete,\n    Complete,\n    Empty,\n    Invalid,\n}\n\n// To use `OneShotResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for OneShotResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (OneShotResourceValue::Empty, _) => other,\n            (_, OneShotResourceValue::Empty) => self,\n            (\n                OneShotResourceValue::HalfRightToComplete,\n                OneShotResourceValue::HalfRightToComplete,\n            ) => OneShotResourceValue::FullRightToComplete {  },\n            (\n                OneShotResourceValue::Complete,\n                OneShotResourceValue::Complete,\n            ) => OneShotResourceValue::Complete {  },\n            (_, _) => OneShotResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        OneShotResourceValue::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct OneShotResource {\n    r: Resource<OneShotResourceValue>,\n}\n\nimpl OneShotResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> OneShotResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a one-shot and returns a resource\n    // granting the full authority to perform the created\n    // one-shot.\n    pub proof fn alloc() -> (tracked resource: Self)\n        ensures\n            resource@ is FullRightToComplete,\n    {\n        let v = OneShotResourceValue::FullRightToComplete {  };\n        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);\n        OneShotResource { r }\n    }\n\n    // This function splits full authority to perform a one-shot\n    // into two half authorities to perform it.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToComplete,\n        ensures\n            ({\n                let (half1, half2) = return_value;\n                &&& half1@ is HalfRightToComplete\n                &&& half2@ is HalfRightToComplete\n                &&& half2.id() == half1.id() == self.id()\n            }),\n    {\n        let half = OneShotResourceValue::HalfRightToComplete {  };\n        let tracked (r1, r2) = self.r.split(half, half);\n        (OneShotResource { r: r1 }, OneShotResource { r: r2 })\n    }\n\n    // This function performs a one-shot given a resource representing\n    // full authority to complete the one-shot.\n    //\n    // Upon return, the passed-in resource will have been transformed\n    // into knowledge that the one-shot has been performed.\n    pub proof fn perform(tracked &mut self)\n        requires\n            old(self)@ is FullRightToComplete,\n        ensures\n            self@ is Complete,\n    {\n        let v = OneShotResourceValue::Complete {  };\n        update_mut(&mut self.r, v);\n    }\n\n    // This function performs a one-shot given two resources, the\n    // first of which represents an incomplete one-shot (and half the\n    // authority needed to perform it). The resources must have the\n    // same `id()`, meaning they're talking about the same one-shot.\n    //\n    // Upon return, the passed-in resources will have both been\n    // transformed into knowledge that the one-shot has been\n    // performed.\n    //\n    // The caller of this function only needs to know that `self`\n    // provides half authority and that `other` isn't `Empty`. Upon\n    // return the caller will learn that *both* the resources had\n    // provided half authority at call time. However, those resources\n    // were transformed so they don't provide that authority anymore.\n    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(other).id() == old(self).id(),\n            old(self)@ is HalfRightToComplete,\n            !(old(other)@ is Empty),\n        ensures\n            old(other)@ is HalfRightToComplete,\n            self@ is Complete,\n            other@ is Complete,\n            other.id() == self.id() == old(self).id(),\n    {\n        self.r.validate();\n        other.r.validate();\n        // A `HalfRightToComplete` doesn't combine validly with a\n        // `Complete`, so validating them together proves that\n        // `other.r.value()` is `HalfRightToComplete`.\n        self.r.validate_2(&other.r);\n        assert(other@ is HalfRightToComplete);\n        // Knowing they're both `HalfRightToComplete` allows them to\n        // be combined and transformed into `Complete` resources.\n        let v = OneShotResourceValue::Complete {  };\n        update_and_redistribute(&mut self.r, &mut other.r, v, v);\n    }\n\n    // This function duplicates a one-shot resource representing\n    // knowledge of completion.\n    pub proof fn duplicate(tracked &self) -> (tracked other: Self)\n        requires\n            self@ is Complete,\n        ensures\n            other.id() == self.id(),\n            other@ is Complete,\n    {\n        let tracked r = duplicate(&self.r);\n        Self { r }\n    }\n\n    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)\n        requires\n            other.id() == old(self).id(),\n            other@ is Complete,\n            !(old(self)@ is Empty),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ is Complete,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\n// This example illustrates some uses of the one-shot functions.\nfn main() {\n    let tracked full = OneShotResource::alloc();\n    proof {\n        full.perform();\n    }\n    assert(full@ is Complete);\n    let tracked different_oneshot = OneShotResource::alloc();\n    let tracked (mut half1, mut half2) = different_oneshot.split();\n    let ghost id = half1.id();\n    assert(half1.id() == half2.id());\n    assert(half1@ is HalfRightToComplete);\n    assert(half2@ is HalfRightToComplete);\n    proof {\n        half1.perform_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@ is Complete);\n    assert(half2@ is Complete);\n    let tracked knowledge = half1.duplicate();\n    assert(knowledge.id() == half1.id() == id);\n    assert(knowledge@ is Complete);\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use vstd::pcm::*;\n      use vstd::prelude::*;\n      verus! {\n     pub enum OneShotResourceValue {\n        FullRightToComplete,     HalfRightToComplete,     Complete,     Empty,     Invalid, }\n     impl PCM for OneShotResourceValue {\n        open spec fn valid(self) -> bool {\n           !(self is Invalid)     }\n        open spec fn op(self, other: Self) -> Self {\n           match (self, other) {\n              (OneShotResourceValue::Empty, _) => other,             (_, OneShotResourceValue::Empty) => self,             (                 OneShotResourceValue::HalfRightToComplete,                 OneShotResourceValue::HalfRightToComplete,             ) => OneShotResourceValue::FullRightToComplete {\n  }\n ,             (_, _) => OneShotResourceValue::Invalid {\n  }\n ,         }\n       }\n        open spec fn unit() -> Self {\n           OneShotResourceValue::Empty {\n   }\n       }\n        proof fn closed_under_incl(a: Self, b: Self) {\n       }\n        proof fn commutative(a: Self, b: Self) {\n       }\n        proof fn associative(a: Self, b: Self, c: Self) {\n       }\n        proof fn op_unit(a: Self) {\n       }\n        proof fn unit_valid() {\n       }\n    }\n     pub struct OneShotResource {\n        r: Resource<OneShotResourceValue>, }\n     impl OneShotResource {\n        pub closed spec fn id(self) -> Loc {\n           self.r.loc()     }\n        pub closed spec fn view(self) -> OneShotResourceValue {\n           self.r.value()     }\n        pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToComplete,         ensures             ({\n                   let (half1, half2) = return_value;\n                   &&& half1@ is HalfRightToComplete                 &&& half2@ is HalfRightToComplete                 &&& half2.id() == half1.id() == self.id()             }\n   ),     {\n           let half = OneShotResourceValue::HalfRightToComplete {\n   };\n           let tracked (r1, r2) = self.r.split(half, half);\n           (OneShotResource {\n  r: r1 }\n  , OneShotResource {\n  r: r2 }\n  )     }\n    }\n     fn main() {\n    }\n     }\n", " use vstd::pcm::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum OneShotResourceValue {\n          FullRightToComplete,     HalfRightToComplete,     Complete,     Empty,     Invalid, }\n       impl PCM for OneShotResourceValue {\n          open spec fn valid(self) -> bool {\n             !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (OneShotResourceValue::Empty, _) => other,             (_, OneShotResourceValue::Empty) => self,             (                 OneShotResourceValue::HalfRightToComplete,                 OneShotResourceValue::HalfRightToComplete,             ) => OneShotResourceValue::FullRightToComplete \n   ,             (_, _) => OneShotResourceValue::Invalid \n   ,         }\n         }\n          open spec fn unit() -> Self {\n             OneShotResourceValue::Empty \n         }\n          proof fn closed_under_incl(a: Self, b: Self) {\n         }\n          proof fn commutative(a: Self, b: Self) {\n         }\n          proof fn associative(a: Self, b: Self, c: Self) {\n         }\n          proof fn op_unit(a: Self) {\n         }\n          proof fn unit_valid() {\n         }\n      }\n       pub struct OneShotResource {\n          r: Resource<OneShotResourceValue>, }\n       impl OneShotResource {\n          pub closed spec fn id(self) -> Loc {\n             self.r.loc()     }\n          pub closed spec fn view(self) -> OneShotResourceValue {\n             self.r.value()     }\n          pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToComplete,         ensures             ({\n                     let (half1, half2) = return_value;\n                     &&& half1@ is HalfRightToComplete                 &&& half2@ is HalfRightToComplete                 &&& half2.id() == half1.id() == self.id()             }\n     ),     {\n             let half = OneShotResourceValue::HalfRightToComplete ;\n             let tracked (r1, r2) = self.r.split(half, half);\n             (OneShotResource {\n    r: r1 }\n    , OneShotResource {\n    r: r2 }\n    )     }\n      }\n       fn main() ;\n       }\n", " use vstd::pcm::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum OneShotResourceValue {\n          FullRightToComplete,     HalfRightToComplete,     Complete,     Empty,     Invalid, }\n       impl PCM for OneShotResourceValue {\n          open spec fn valid(self) -> bool {\n             !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (OneShotResourceValue::Empty, _) => other,             (_, OneShotResourceValue::Empty) => self,             (                 OneShotResourceValue::HalfRightToComplete,                 OneShotResourceValue::HalfRightToComplete,             ) => OneShotResourceValue::FullRightToComplete \n   ,             (_, _) => OneShotResourceValue::Invalid \n   ,         }\n         }\n          open spec fn unit() -> Self {\n             OneShotResourceValue::Empty \n         }\n          proof fn closed_under_incl(a: Self, b: Self) {}\n          proof fn commutative(a: Self, b: Self) {}\n          proof fn associative(a: Self, b: Self, c: Self) {}\n          proof fn op_unit(a: Self) {}\n          proof fn unit_valid() {}\n      }\n       pub struct OneShotResource {\n          r: Resource<OneShotResourceValue>, }\n       impl OneShotResource {}\n       fn main() ;\n       }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "power_of_2_cc0b9f7d", "original_code": "// Some of the lemmas are ported from the following:\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power2.dfy\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power.dfy\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n    ensures\n        bv << e == (bv << sub(e, 1)) << 1u32,\n    decreases e,\n{\n    // REVIEW:                 ^^^^^^^^^^ expected `u32`, found struct `verus_builtin::int`\n    // get this error when updated to new syntax. Type casting (i.e. `(e - 1u32) as u32`) does not make this error disappear\n}\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one_is_mul2(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n        bv << e == (bv << sub(e, 1)) << 1,\n    ensures\n        (bv << e) == mul(2, bv << sub(e, 1)),\n{\n}\n\nspec fn pow2(e: nat) -> nat\n    decreases (e),\n{\n    if e == 0 {\n        1\n    } else {\n        2 * pow2((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_0()\n    ensures\n        pow2(0) == 1,\n{\n}\n\nproof fn lemma_pow2_unfold3(e: nat)\n    requires\n        e > 3,\n    ensures\n        pow2(e) == pow2((e - 3) as nat) * 8,\n{\n    reveal_with_fuel(pow2, 3);\n}\n\n// (2^e - 1) / 2 = 2^(e - 1) - 1\nproof fn lemma_pow2_make_div(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_make_div((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_2e(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),\n    decreases e,\n{\n    reveal_with_fuel(pow2, 3);\n    if e == 1 {\n        assert(pow2(2) == 4);\n    } else {\n        lemma_pow2_2e((e - 1) as nat)\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_pow2_two_e(e: nat)\n    requires\n        e >= 0,\n    ensures\n        pow2(e) * pow2(e) == pow2(2 * e),\n    decreases e,\n{\n    if e != 0 {\n        lemma_pow2_two_e((e - 1) as nat);\n        lemma_pow2_2e(e);\n    }\n}\n\nproof fn lemma_pow2_increase(e: nat)\n    requires\n        e > 0,\n    ensures\n        pow2(e) > pow2((e - 1) as nat),\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_increase((e - 1) as nat);\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)\n    requires\n        x < y,\n    ensures\n        z * x <= z * y,\n{\n}\n\nproof fn left_shift_is_pow2(bv: u32, e: u32)\n    requires\n        e <= 32,\n        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n    ensures\n        (bv << e) as nat == (bv as nat) * pow2(e as nat),\n    decreases e,\n{\n    if e == 0 {\n        // assert(bv << 0 == bv * 1u32) by(bit_vector);\n        // REVIEW:           ^^^^^^^^^\n        //        error: cannot use bit-vector arithmetic on type Int(Int)\n        assume(bv << 0 == bv * 1);\n        assert((bv << 0) as nat == (bv as nat) * pow2(0)) by (nonlinear_arith)\n            requires\n                pow2(0) == 1,\n                bv << 0 == bv * 1,\n        {}\n    } else {\n        lemma_pow2_increase(e as nat);\n        // assert(pow2((e-1) as nat) < pow2(e as nat));\n        lemma_mul_upper_bound(pow2((e - 1) as nat), pow2(e as nat), bv as nat);\n        // assert((bv as nat) * pow2( (e-1) as nat) <= (bv as nat) * pow2(e as nat));\n        // assert((bv as nat) * pow2( (e-1) as nat) < (0x1_0000_0000 as nat));\n        left_shift_is_pow2(bv, (e - 1) as u32);\n        // assert( (bv << (e-1) as u32) as nat == (bv as nat) * pow2((e-1) as nat));        // we get this from above recursive call\n        // assert(bv == bv as nat);\n        assert((bv as nat) * pow2((e - 1) as nat) == bv * pow2((e - 1) as nat)) by (nonlinear_arith)\n            requires\n                (bv == bv as nat),\n        {}// assert((bv << (e-1) as u32) as nat == bv* pow2((e-1) as nat));\n        // need the above nonlinear fact to make this pass\n\n        assert(pow2(e as nat) == 2 * pow2((e - 1) as nat)) by {\n            reveal_with_fuel(pow2, 1);\n        }\n        assert((bv as nat) * pow2(e as nat) == (bv as nat) * 2 * pow2((e - 1) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n        {}\n        assert((2 * (bv << ((e - 1) as u32))) as nat == 2 * ((bv << ((e - 1) as u32)) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n        {}\n        left_shift_by_one(bv, e);\n        // assert( (bv << e) == (bv << ((e-1) as u32)) << 1);\n        left_shift_by_one_is_mul2(bv, e);\n        // cannot get the `ensures` clause from this lemma directly\n        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't\n        assert(bv << ((e - 1) as u32) < 0x8000_0000) by (nonlinear_arith)\n            requires\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            // assert( (bv as nat) * pow2((e-1) as nat) * 2 == (bv as nat) * pow2(e as nat));\n            // assert( (bv as nat) * pow2((e-1) as nat) < 0x8000_0000);\n            // assert(bv * pow2((e-1) as nat) < 0x8000_0000);\n        }\n        assert(2 * (bv << ((e - 1) as u32)) < 0x1_0000_0000) by (nonlinear_arith)\n            requires\n                bv << ((e - 1) as u32) < 0x8000_0000,\n        {}\n        // assert( (bv << e)  == 2 * (bv << ((e-1) as u32)));\n\n        assert((bv << e) as nat == (bv as nat) * pow2(e as nat)) by (nonlinear_arith)\n            requires\n                e > 0,\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv << e) as nat == 2 * (bv << ((e - 1) as u32)) as nat,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            assert((bv << e) as nat == 2 * ((bv << ((e - 1) as u32)) as nat));\n            assert(2 * ((bv << ((e - 1) as u32)) as nat) == (bv as nat) * 2 * pow2((e - 1) as nat));\n            assert((bv as nat) * 2 * pow2((e - 1) as nat) == (bv as nat) * pow2(e as nat));\n        }\n        // assert((bv << e) as nat == (bv as nat) * pow2(e as nat));\n\n    }\n}\n\n} // verus!\nfn main() {}\n", "minimized_code": "// Some of the lemmas are ported from the following:\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power2.dfy\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power.dfy\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n    ensures\n        bv << e == (bv << sub(e, 1)) << 1u32,\n    decreases e,\n{\n    // REVIEW:                 ^^^^^^^^^^ expected `u32`, found struct `verus_builtin::int`\n    // get this error when updated to new syntax. Type casting (i.e. `(e - 1u32) as u32`) does not make this error disappear\n}\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one_is_mul2(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n        bv << e == (bv << sub(e, 1)) << 1,\n    ensures\n        (bv << e) == mul(2, bv << sub(e, 1)),\n{\n}\n\nspec fn pow2(e: nat) -> nat\n    decreases (e),\n{\n    if e == 0 {\n        1\n    } else {\n        2 * pow2((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_0()\n    ensures\n        pow2(0) == 1,\n{\n}\n\nproof fn lemma_pow2_unfold3(e: nat)\n    requires\n        e > 3,\n    ensures\n        pow2(e) == pow2((e - 3) as nat) * 8,\n{\n    reveal_with_fuel(pow2, 3);\n}\n\n// (2^e - 1) / 2 = 2^(e - 1) - 1\nproof fn lemma_pow2_make_div(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_make_div((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_2e(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),\n    decreases e,\n{\n    reveal_with_fuel(pow2, 3);\n    if e == 1 {\n        assert(pow2(2) == 4);\n    } else {\n        lemma_pow2_2e((e - 1) as nat)\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_pow2_two_e(e: nat)\n    requires\n        e >= 0,\n    ensures\n        pow2(e) * pow2(e) == pow2(2 * e),\n    decreases e,\n{\n    if e != 0 {\n        lemma_pow2_two_e((e - 1) as nat);\n        lemma_pow2_2e(e);\n    }\n}\n\nproof fn lemma_pow2_increase(e: nat)\n    requires\n        e > 0,\n    ensures\n        pow2(e) > pow2((e - 1) as nat),\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_increase((e - 1) as nat);\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)\n    requires\n        x < y,\n    ensures\n        z * x <= z * y,\n{\n}\n\nproof fn left_shift_is_pow2(bv: u32, e: u32)\n    requires\n        e <= 32,\n        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n    ensures\n        (bv << e) as nat == (bv as nat) * pow2(e as nat),\n    decreases e,\n{\n    if e == 0 {\n        // assert(bv << 0 == bv * 1u32) by(bit_vector);\n        // REVIEW:           ^^^^^^^^^\n        //        error: cannot use bit-vector arithmetic on type Int(Int)\n        assume(bv << 0 == bv * 1);\n        assert((bv << 0) as nat == (bv as nat) * pow2(0)) by (nonlinear_arith)\n            requires\n                pow2(0) == 1,\n                bv << 0 == bv * 1,\n        {}\n    } else {\n        lemma_pow2_increase(e as nat);\n        // assert(pow2((e-1) as nat) < pow2(e as nat));\n        lemma_mul_upper_bound(pow2((e - 1) as nat), pow2(e as nat), bv as nat);\n        // assert((bv as nat) * pow2( (e-1) as nat) <= (bv as nat) * pow2(e as nat));\n        // assert((bv as nat) * pow2( (e-1) as nat) < (0x1_0000_0000 as nat));\n        left_shift_is_pow2(bv, (e - 1) as u32);\n        // assert( (bv << (e-1) as u32) as nat == (bv as nat) * pow2((e-1) as nat));        // we get this from above recursive call\n        // assert(bv == bv as nat);\n        assert((bv as nat) * pow2((e - 1) as nat) == bv * pow2((e - 1) as nat)) by (nonlinear_arith)\n            requires\n                (bv == bv as nat),\n        {}// assert((bv << (e-1) as u32) as nat == bv* pow2((e-1) as nat));\n        // need the above nonlinear fact to make this pass\n\n        assert(pow2(e as nat) == 2 * pow2((e - 1) as nat)) by {\n            reveal_with_fuel(pow2, 1);\n        }\n        assert((bv as nat) * pow2(e as nat) == (bv as nat) * 2 * pow2((e - 1) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n        {}\n        assert((2 * (bv << ((e - 1) as u32))) as nat == 2 * ((bv << ((e - 1) as u32)) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n        {}\n        left_shift_by_one(bv, e);\n        // assert( (bv << e) == (bv << ((e-1) as u32)) << 1);\n        left_shift_by_one_is_mul2(bv, e);\n        // cannot get the `ensures` clause from this lemma directly\n        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't\n        assert(bv << ((e - 1) as u32) < 0x8000_0000) by (nonlinear_arith)\n            requires\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            // assert( (bv as nat) * pow2((e-1) as nat) * 2 == (bv as nat) * pow2(e as nat));\n            // assert( (bv as nat) * pow2((e-1) as nat) < 0x8000_0000);\n            // assert(bv * pow2((e-1) as nat) < 0x8000_0000);\n        }\n        assert(2 * (bv << ((e - 1) as u32)) < 0x1_0000_0000) by (nonlinear_arith)\n            requires\n                bv << ((e - 1) as u32) < 0x8000_0000,\n        {}\n        // assert( (bv << e)  == 2 * (bv << ((e-1) as u32)));\n\n        assert((bv << e) as nat == (bv as nat) * pow2(e as nat)) by (nonlinear_arith)\n            requires\n                e > 0,\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv << e) as nat == 2 * (bv << ((e - 1) as u32)) as nat,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            assert((bv << e) as nat == 2 * ((bv << ((e - 1) as u32)) as nat));\n            assert(2 * ((bv << ((e - 1) as u32)) as nat) == (bv as nat) * 2 * pow2((e - 1) as nat));\n            assert((bv as nat) * 2 * pow2((e - 1) as nat) == (bv as nat) * pow2(e as nat));\n        }\n        // assert((bv << e) as nat == (bv as nat) * pow2(e as nat));\n\n    }\n}\n\n} // verus!\nfn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/power_of_2.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 2842, "minimize_time_ms": 156526, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 212, "minimized_LOC": 212, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 51, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"requires_count": 2, "ensures_count": 4, "segments": {"exec": "\nfn main() {", "spec": "spec fn pow2(e: nat) -> nat\n    decreases (e),\n{\n\n    requires\n\n    ensures\n\n    decreases e,\n\n    requires\n\n    ensures\n\n    decreases (e),\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    decreases e,\n\n    requires\n\n    ensures\n\n    decreases e,\n\n    requires\n\n    ensures\n\n    decreases e,\n\n    requires\n\n    ensures\n\n    decreases e,\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    decreases e,\n\n            requires\n\n            requires\n\n            requires\n\n            requires\n\n        // cannot get the `ensures` clause from this lemma directly\n\n        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't\n\n            requires\n\n            requires\n\n            requires", "proof": "proof fn left_shift_by_one(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n    ensures\n        bv << e == (bv << sub(e, 1)) << 1u32,\n    decreases e,\n{\n\nproof fn left_shift_by_one_is_mul2(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n        bv << e == (bv << sub(e, 1)) << 1,\n    ensures\n        (bv << e) == mul(2, bv << sub(e, 1)),\n{\n\nproof fn lemma_pow2_0()\n    ensures\n        pow2(0) == 1,\n{\n\nproof fn lemma_pow2_unfold3(e: nat)\n    requires\n        e > 3,\n    ensures\n        pow2(e) == pow2((e - 3) as nat) * 8,\n{\n\nproof fn lemma_pow2_make_div(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,\n    decreases e,\n{\n\nproof fn lemma_pow2_2e(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),\n    decreases e,\n{\n\nproof fn lemma_pow2_two_e(e: nat)\n    requires\n        e >= 0,\n    ensures\n        pow2(e) * pow2(e) == pow2(2 * e),\n    decreases e,\n{\n\nproof fn lemma_pow2_increase(e: nat)\n    requires\n        e > 0,\n    ensures\n        pow2(e) > pow2((e - 1) as nat),\n    decreases e,\n{\n\nproof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)\n    requires\n        x < y,\n    ensures\n        z * x <= z * y,\n{\n\nproof fn left_shift_is_pow2(bv: u32, e: u32)\n    requires\n        e <= 32,\n        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n    ensures\n        (bv << e) as nat == (bv as nat) * pow2(e as nat),\n    decreases e,\n{"}}}, "all_snapshots": ["// Some of the lemmas are ported from the following:\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power2.dfy\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power.dfy\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n    ensures\n        bv << e == (bv << sub(e, 1)) << 1u32,\n    decreases e,\n{\n    // REVIEW:                 ^^^^^^^^^^ expected `u32`, found struct `verus_builtin::int`\n    // get this error when updated to new syntax. Type casting (i.e. `(e - 1u32) as u32`) does not make this error disappear\n}\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one_is_mul2(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n        bv << e == (bv << sub(e, 1)) << 1,\n    ensures\n        (bv << e) == mul(2, bv << sub(e, 1)),\n{\n}\n\nspec fn pow2(e: nat) -> nat\n    decreases (e),\n{\n    if e == 0 {\n        1\n    } else {\n        2 * pow2((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_0()\n    ensures\n        pow2(0) == 1,\n{\n}\n\nproof fn lemma_pow2_unfold3(e: nat)\n    requires\n        e > 3,\n    ensures\n        pow2(e) == pow2((e - 3) as nat) * 8,\n{\n    reveal_with_fuel(pow2, 3);\n}\n\n// (2^e - 1) / 2 = 2^(e - 1) - 1\nproof fn lemma_pow2_make_div(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_make_div((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_2e(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),\n    decreases e,\n{\n    reveal_with_fuel(pow2, 3);\n    if e == 1 {\n        assert(pow2(2) == 4);\n    } else {\n        lemma_pow2_2e((e - 1) as nat)\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_pow2_two_e(e: nat)\n    requires\n        e >= 0,\n    ensures\n        pow2(e) * pow2(e) == pow2(2 * e),\n    decreases e,\n{\n    if e != 0 {\n        lemma_pow2_two_e((e - 1) as nat);\n        lemma_pow2_2e(e);\n    }\n}\n\nproof fn lemma_pow2_increase(e: nat)\n    requires\n        e > 0,\n    ensures\n        pow2(e) > pow2((e - 1) as nat),\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_increase((e - 1) as nat);\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)\n    requires\n        x < y,\n    ensures\n        z * x <= z * y,\n{\n}\n\nproof fn left_shift_is_pow2(bv: u32, e: u32)\n    requires\n        e <= 32,\n        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n    ensures\n        (bv << e) as nat == (bv as nat) * pow2(e as nat),\n    decreases e,\n{\n    if e == 0 {\n        // assert(bv << 0 == bv * 1u32) by(bit_vector);\n        // REVIEW:           ^^^^^^^^^\n        //        error: cannot use bit-vector arithmetic on type Int(Int)\n        assume(bv << 0 == bv * 1);\n        assert((bv << 0) as nat == (bv as nat) * pow2(0)) by (nonlinear_arith)\n            requires\n                pow2(0) == 1,\n                bv << 0 == bv * 1,\n        {}\n    } else {\n        lemma_pow2_increase(e as nat);\n        // assert(pow2((e-1) as nat) < pow2(e as nat));\n        lemma_mul_upper_bound(pow2((e - 1) as nat), pow2(e as nat), bv as nat);\n        // assert((bv as nat) * pow2( (e-1) as nat) <= (bv as nat) * pow2(e as nat));\n        // assert((bv as nat) * pow2( (e-1) as nat) < (0x1_0000_0000 as nat));\n        left_shift_is_pow2(bv, (e - 1) as u32);\n        // assert( (bv << (e-1) as u32) as nat == (bv as nat) * pow2((e-1) as nat));        // we get this from above recursive call\n        // assert(bv == bv as nat);\n        assert((bv as nat) * pow2((e - 1) as nat) == bv * pow2((e - 1) as nat)) by (nonlinear_arith)\n            requires\n                (bv == bv as nat),\n        {}// assert((bv << (e-1) as u32) as nat == bv* pow2((e-1) as nat));\n        // need the above nonlinear fact to make this pass\n\n        assert(pow2(e as nat) == 2 * pow2((e - 1) as nat)) by {\n            reveal_with_fuel(pow2, 1);\n        }\n        assert((bv as nat) * pow2(e as nat) == (bv as nat) * 2 * pow2((e - 1) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n        {}\n        assert((2 * (bv << ((e - 1) as u32))) as nat == 2 * ((bv << ((e - 1) as u32)) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n        {}\n        left_shift_by_one(bv, e);\n        // assert( (bv << e) == (bv << ((e-1) as u32)) << 1);\n        left_shift_by_one_is_mul2(bv, e);\n        // cannot get the `ensures` clause from this lemma directly\n        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't\n        assert(bv << ((e - 1) as u32) < 0x8000_0000) by (nonlinear_arith)\n            requires\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            // assert( (bv as nat) * pow2((e-1) as nat) * 2 == (bv as nat) * pow2(e as nat));\n            // assert( (bv as nat) * pow2((e-1) as nat) < 0x8000_0000);\n            // assert(bv * pow2((e-1) as nat) < 0x8000_0000);\n        }\n        assert(2 * (bv << ((e - 1) as u32)) < 0x1_0000_0000) by (nonlinear_arith)\n            requires\n                bv << ((e - 1) as u32) < 0x8000_0000,\n        {}\n        // assert( (bv << e)  == 2 * (bv << ((e-1) as u32)));\n\n        assert((bv << e) as nat == (bv as nat) * pow2(e as nat)) by (nonlinear_arith)\n            requires\n                e > 0,\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv << e) as nat == 2 * (bv << ((e - 1) as u32)) as nat,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            assert((bv << e) as nat == 2 * ((bv << ((e - 1) as u32)) as nat));\n            assert(2 * ((bv << ((e - 1) as u32)) as nat) == (bv as nat) * 2 * pow2((e - 1) as nat));\n            assert((bv as nat) * 2 * pow2((e - 1) as nat) == (bv as nat) * pow2(e as nat));\n        }\n        // assert((bv << e) as nat == (bv as nat) * pow2(e as nat));\n\n    }\n}\n\n} // verus!\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n       use verus_builtin_macros::*;\n        verus! {}\n         fn main() {}\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "proposal-rw2022_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/proposal-rw2022.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 770, "minimize_time_ms": 152552, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 75, "minimized_LOC": 75, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 17, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n\n\nfn main() {", "spec": "spec fn fibo(n: nat) -> nat\n    decreases n,\n{\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n\n    decreases n,\n\n    requires\n\n    ensures\n\n    decreases j - i,\n\n    requires\n\n    ensures\n\n        invariant", "proof": "proof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n\nproof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "quantifiers_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\nfn main() {}\n\nverus! {\n\nspec fn f1(i: int, j: int) -> bool {\n    i <= j\n}\n\nspec fn f2(i: int, j: int) -> bool {\n    i >= j\n}\n\nspec fn g1(i: int) -> int {\n    i + 1\n}\n\nspec fn g2(i: int) -> int {\n    i + 2\n}\n\nspec fn g3(i: int) -> int {\n    i + 3\n}\n\n// Automatically chosen triggers\nfn test_auto() {\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j));\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) && f1(i, j));\n    // :pattern ((f1. j@ i@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, i));\n    // :pattern ((f1. i@ j@))\n    // note: f1(i, j) is preferred over splitting i, j among g1(i), g2(j)\n    assert(forall|i: int, j: int| f1(i, j) ==> g1(i) <= g2(j));\n    // :pattern ((g1. i@))\n    // note: g1(i) is preferred over the more deeply nested g3(i)\n    assert(forall|i: int| #![auto] g1(i) >= i || g2(g3(i)) >= i);\n    // :pattern ((f1. i@ j@))\n    // note: f1(i, j) is preferred over the larger f2(j, g1(i))\n    assert(forall|i: int, j: int| #![auto] i == j ==> f1(i, j) || f2(j, g1(i)));\n    // :pattern ((f1. j@ (g1. i@)))\n    // note: f1(i, j) is excluded due to a potential matching loop\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, g1(i)));\n    // matching loop, no trigger\n    // assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, i + 1));\n    // :pattern ((f2. j@ i@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| f2(j, i) ==> f1(i, j));\n    // :pattern ((g1. j@) (g1. i@))\n    assert(forall|i: int, j: int| g1(i) >= i && g1(j) >= j);\n    // :pattern ((g1. i@) (g2. j@))\n    assert(g1(3) == g2(2));\n    assert(exists|i: int, j: int| g1(i) == g2(j));\n}\n\n// Manually chosen triggers\nfn test_manual() {\n    //\n    // For single triggers, use #[trigger]\n    //\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| f2(j, i) ==> #[trigger] f1(i, j));\n    // :pattern ((g1. i@) (g2. j@))\n    assert(forall|i: int, j: int| f1(i, j) ==> f1(#[trigger] g1(i), #[trigger] g2(j)));\n    //\n    // For multiple triggers, use\n    //   with_triggers!([...trigger 1 terms...], ..., [...trigger n terms...] => body)\n    //\n    // :pattern ((g1. i@) (g2. j@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int|\n        #![trigger g1(i), g2(j)]\n        #![trigger f1(i, j)]\n        f1(i, j) ==> f1(g1(i), g2(j)));\n    // :pattern ((g1. i@) (g2. j@))\n    // :pattern ((f1. i@ j@) (g1. i@))\n    assert(forall|i: int, j: int|\n        #![trigger g1(i), g2(j)]\n        #![trigger f1(i, j), g1(i)]\n        f1(i, j) ==> f1(g1(i), g2(j)));\n}\n\nspec fn tr(i: int) -> bool {\n    true\n}\n\nfn test_nat() {\n    assert(forall|i: nat| i >= 0 && tr(i as int));\n    assert(tr(300));\n    assert(exists|i: nat| i >= 0 && tr(i as int));\n    assert(exists|i: u16| i >= 300 && tr(i as int));\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\n       use verus_builtin_macros::*;\n       fn main() {\n     }\n       verus! {\n      spec fn f1(i: int, j: int) -> bool {\n         i >= j }\n      spec fn g1(i: int) -> int {\n         i + 2 }\n      fn test_auto() {\n    }\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/quantifiers.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 822, "minimize_time_ms": 185856, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 100, "minimized_LOC": 12, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 3, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.12}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn f1(i: int, j: int) -> bool {\n\nspec fn g1(i: int) -> int {"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\nfn main() {}\n\nverus! {\n\nspec fn f1(i: int, j: int) -> bool {\n    i <= j\n}\n\nspec fn f2(i: int, j: int) -> bool {\n    i >= j\n}\n\nspec fn g1(i: int) -> int {\n    i + 1\n}\n\nspec fn g2(i: int) -> int {\n    i + 2\n}\n\nspec fn g3(i: int) -> int {\n    i + 3\n}\n\n// Automatically chosen triggers\nfn test_auto() {\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j));\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) && f1(i, j));\n    // :pattern ((f1. j@ i@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, i));\n    // :pattern ((f1. i@ j@))\n    // note: f1(i, j) is preferred over splitting i, j among g1(i), g2(j)\n    assert(forall|i: int, j: int| f1(i, j) ==> g1(i) <= g2(j));\n    // :pattern ((g1. i@))\n    // note: g1(i) is preferred over the more deeply nested g3(i)\n    assert(forall|i: int| #![auto] g1(i) >= i || g2(g3(i)) >= i);\n    // :pattern ((f1. i@ j@))\n    // note: f1(i, j) is preferred over the larger f2(j, g1(i))\n    assert(forall|i: int, j: int| #![auto] i == j ==> f1(i, j) || f2(j, g1(i)));\n    // :pattern ((f1. j@ (g1. i@)))\n    // note: f1(i, j) is excluded due to a potential matching loop\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, g1(i)));\n    // matching loop, no trigger\n    // assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, i + 1));\n    // :pattern ((f2. j@ i@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| f2(j, i) ==> f1(i, j));\n    // :pattern ((g1. j@) (g1. i@))\n    assert(forall|i: int, j: int| g1(i) >= i && g1(j) >= j);\n    // :pattern ((g1. i@) (g2. j@))\n    assert(g1(3) == g2(2));\n    assert(exists|i: int, j: int| g1(i) == g2(j));\n}\n\n// Manually chosen triggers\nfn test_manual() {\n    //\n    // For single triggers, use #[trigger]\n    //\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| f2(j, i) ==> #[trigger] f1(i, j));\n    // :pattern ((g1. i@) (g2. j@))\n    assert(forall|i: int, j: int| f1(i, j) ==> f1(#[trigger] g1(i), #[trigger] g2(j)));\n    //\n    // For multiple triggers, use\n    //   with_triggers!([...trigger 1 terms...], ..., [...trigger n terms...] => body)\n    //\n    // :pattern ((g1. i@) (g2. j@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int|\n        #![trigger g1(i), g2(j)]\n        #![trigger f1(i, j)]\n        f1(i, j) ==> f1(g1(i), g2(j)));\n    // :pattern ((g1. i@) (g2. j@))\n    // :pattern ((f1. i@ j@) (g1. i@))\n    assert(forall|i: int, j: int|\n        #![trigger g1(i), g2(j)]\n        #![trigger f1(i, j), g1(i)]\n        f1(i, j) ==> f1(g1(i), g2(j)));\n}\n\nspec fn tr(i: int) -> bool {\n    true\n}\n\nfn test_nat() {\n    assert(forall|i: nat| i >= 0 && tr(i as int));\n    assert(tr(300));\n    assert(exists|i: nat| i >= 0 && tr(i as int));\n    assert(exists|i: u16| i >= 300 && tr(i as int));\n}\n\n} // verus!\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n       use verus_builtin_macros::*;\n       fn main() {\n     }\n       verus! {\n      spec fn f1(i: int, j: int) -> bool {\n         i >= j }\n      spec fn g1(i: int) -> int {\n         i + 2 }\n      fn test_auto() {\n    }\n      }\n", "use verus_builtin::*;\n         use verus_builtin_macros::*;\n         fn main() {}\n         verus! {}\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "recommends_cc0b9f7d", "original_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, seq::*, seq_lib::*};\n\nverus! {\n\nspec fn max_int(x: int, y: int) -> int {\n    if x > y {\n        x\n    } else {\n        y\n    }\n}\n\n// To enable recommends checking, use: spec(checked) instead of spec\nspec fn seq_max_int(s: Seq<int>) -> int\n    recommends\n        s.len()\n            > 0,  // without this, spec(checked) generates a recommends warning below\n\n    decreases s.len(),\n{\n    let m = s[s.len() - 1];\n    if s.len() <= 1 {\n        m\n    } else {\n        max_int(m, seq_max_int(s.drop_last()))\n    }\n}\n\nproof fn test(s: Seq<int>)\n    requires\n        seq_max_int(s)\n            >= 0,  // without this, the assertion fails and there's a recommends note\n{\n    assert(seq_max_int(s) >= 0);\n}\n\nfn main() {\n    proof {\n        let s = seq![10, 20, 30, 25];\n        reveal_with_fuel(seq_max_int, 4);\n        assert(seq_max_int(s) == 30);\n    }\n}\n\n// Usage of `spec_affirm`\nspec fn some_predicate(a: nat) -> bool\n    recommends\n        a < 100,\n{\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here\n        a < 25\n    }\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::{\n      pervasive::*, seq::*, seq_lib::*};\n        verus! {\n       spec fn max_int() -> int ;\n       spec fn seq_max_int(s: Seq<int>) -> int     recommends         s.len()             > 0,       decreases s.len(), ;\n       fn main() ;\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/recommends.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 894, "minimize_time_ms": 216090, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 63, "minimized_LOC": 9, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 4, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.14285714285714285}, "labeling": {"segments": {"exec": "use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::{\n      pervasive::*, seq::*, seq_lib::*};\n        verus! {\n       spec fn max_int() -> int ;\n       spec fn seq_max_int(s: Seq<int>) -> int     recommends         s.len()             > 0,       decreases s.len(), ;\n       fn main() ;\n       }\n", "spec": "       spec fn seq_max_int(s: Seq<int>) -> int     recommends         s.len()             > 0,       decreases s.len(), ;"}}}, "all_snapshots": ["#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, seq::*, seq_lib::*};\n\nverus! {\n\nspec fn max_int(x: int, y: int) -> int {\n    if x > y {\n        x\n    } else {\n        y\n    }\n}\n\n// To enable recommends checking, use: spec(checked) instead of spec\nspec fn seq_max_int(s: Seq<int>) -> int\n    recommends\n        s.len()\n            > 0,  // without this, spec(checked) generates a recommends warning below\n\n    decreases s.len(),\n{\n    let m = s[s.len() - 1];\n    if s.len() <= 1 {\n        m\n    } else {\n        max_int(m, seq_max_int(s.drop_last()))\n    }\n}\n\nproof fn test(s: Seq<int>)\n    requires\n        seq_max_int(s)\n            >= 0,  // without this, the assertion fails and there's a recommends note\n{\n    assert(seq_max_int(s) >= 0);\n}\n\nfn main() {\n    proof {\n        let s = seq![10, 20, 30, 25];\n        reveal_with_fuel(seq_max_int, 4);\n        assert(seq_max_int(s) == 30);\n    }\n}\n\n// Usage of `spec_affirm`\nspec fn some_predicate(a: nat) -> bool\n    recommends\n        a < 100,\n{\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here\n        a < 25\n    }\n}\n\n} // verus!\n", "use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n", "use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::{\n      pervasive::*, seq::*, seq_lib::*};\n        verus! {\n       spec fn max_int() -> int ;\n       spec fn seq_max_int(s: Seq<int>) -> int     recommends         s.len()             > 0,       decreases s.len(), ;\n       fn main() ;\n       }\n", "          use verus_builtin_macros::*;\n               use vstd::{\n            pervasive::*, seq::*, seq_lib::*};\n               verus! {\n             fn main() ;\n             }\n", "use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n"]}
{"id": "recursion_cc0b9f7d", "original_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "minimized_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/recursion.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1193, "minimize_time_ms": 156085, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 116, "minimized_LOC": 116, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 26, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n\n\nfn run_arith_sum(n: u64) -> u64 {\n\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n\n\nfn main() {", "spec": "spec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n\n    decreases i,\n\n    decreases i,\n\n    ensures\n\n    decreases i,\n\n    requires\n\n    ensures\n\n    decreases j,\n\n    requires\n\n    ensures\n\n        invariant\n\n    decreases 100 - n,", "proof": "proof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n\nproof fn arith_sum_test1() {\n\nproof fn arith_sum_test2() {\n\nproof fn arith_sum_test3() {\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{"}}}, "all_snapshots": ["use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "use vstd;\nfn main() {}\n", " use vstd::{\n        modes::*, prelude::*, seq::*, *};\n            fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "recursive_types_cc0b9f7d", "original_code": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/recursive_types.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1264, "minimize_time_ms": 184249, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 133, "minimized_LOC": 133, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n\n    ensures false\n\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\n\n    decreases list  // decreases can be used on values of type List<A> ,\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n\n// For this, Verus requires that struct and enum datatypes have a non-recursive", "proof": "proof fn bad()\n    ensures false\n{"}}}, "all_snapshots": ["use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "rfmig_script_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n// #![allow(unused_imports, unused_macros, non_camel_case_types)] #![feature(fmt_internals)]\nuse vstd::prelude::verus;\n\nfn main() {}\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\npub struct Account {\n    pub balance: u64,\n}\n\npub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)\n    requires\n        old(orig).balance >= amount,\n        old(dest).balance + amount < u64::MAX,\n    ensures\n        dest.balance == old(dest).balance + amount,\n        orig.balance == old(orig).balance - amount,\n{\n    /*+*/\n    let accounts_pre: Ghost<(Account, Account)> = Ghost((*orig, *dest));\n    orig.balance = orig.balance - amount;\n    dest.balance = dest.balance + amount;\n    /*+*/\n    assert(orig.balance + dest.balance == accounts_pre@.0.balance + accounts_pre@.1.balance);\n}\n\n//- fn cmain(account: Account)\n//-     requires account.balance >= 100\n//- {\n//-     let mut account = account;\n//-     transfer(&mut account, &mut account, 100);\n//- }\n// ## C2(e) -- C2-linearity.rs\nuse vstd::prelude::*;\n\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// ## D -- D-recommends.rs\nspec fn divide(x: nat, y: nat) -> nat\n    recommends\n        y != 0,\n{\n    x / y\n}\n\n// E -- E-solvers.rs\nproof fn div_is_smaller(x: nat, y: nat)/*+*/\n\n    by (nonlinear_arith)\n    requires\n        y != 0,\n    ensures\n        divide(x, y) <= x,\n{\n}\n\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n// F0 -- F-linear-ghost\nstruct State1 {\n    s: nat,\n}\n\nstruct State2 {\n    s: nat,\n}\n\n#[verifier::external_body]\nproof fn exchange(tracked s1: State1) -> (tracked s2: State2)\n    ensures\n        s1.s == s2.s,\n{\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise1(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise2(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\nproof fn p(tracked s1: State1) {\n    //+ let tracked s2 = exchange(s1);\n    exercise1(&s1);\n    //+ exercise(&s2);\n}\n\n// F1 -- F-linear-proof\nmod F1 {\n    use vstd::{prelude::*, simple_pptr::*};\n\n    #[verifier::external_body]\n    fn send_pointer(ptr: PPtr<u64>) {\n        todo!()\n    }\n\n    #[verifier::external_body]\n    proof fn transfer_permission(tracked perm: PointsTo<u64>) {\n        todo!()\n    }\n\n    fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)\n        requires\n            counter == old(perm).pptr(),\n            old(perm).is_init() && old(perm).value() < 100,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64),\n    {\n        // pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)\n        let cur_i: u64 = *counter.borrow(Tracked(&*perm));\n        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)\n        counter.replace(Tracked(perm), cur_i + 1);\n    }\n\n    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n        requires\n            counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit,\n    {\n        send_pointer(counter);\n        let tracked mut perm: PointsTo<u64> = perm;\n        // pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)\n        counter.put(Tracked(&mut perm), 5);\n        assert(perm.opt_value() === MemContents::Init(5));\n        //+ proof { transfer_permission(perm) };\n        increment(counter, Tracked(&mut perm));\n        assert(perm.opt_value() === MemContents::Init(6));\n    }\n\n}\n\n// F1\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n// #![allow(unused_imports, unused_macros, non_camel_case_types)] #![feature(fmt_internals)]\nuse vstd::prelude::verus;\n\nfn main() {}\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\npub struct Account {\n    pub balance: u64,\n}\n\npub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)\n    requires\n        old(orig).balance >= amount,\n        old(dest).balance + amount < u64::MAX,\n    ensures\n        dest.balance == old(dest).balance + amount,\n        orig.balance == old(orig).balance - amount,\n{\n    /*+*/\n    let accounts_pre: Ghost<(Account, Account)> = Ghost((*orig, *dest));\n    orig.balance = orig.balance - amount;\n    dest.balance = dest.balance + amount;\n    /*+*/\n    assert(orig.balance + dest.balance == accounts_pre@.0.balance + accounts_pre@.1.balance);\n}\n\n//- fn cmain(account: Account)\n//-     requires account.balance >= 100\n//- {\n//-     let mut account = account;\n//-     transfer(&mut account, &mut account, 100);\n//- }\n// ## C2(e) -- C2-linearity.rs\nuse vstd::prelude::*;\n\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// ## D -- D-recommends.rs\nspec fn divide(x: nat, y: nat) -> nat\n    recommends\n        y != 0,\n{\n    x / y\n}\n\n// E -- E-solvers.rs\nproof fn div_is_smaller(x: nat, y: nat)/*+*/\n\n    by (nonlinear_arith)\n    requires\n        y != 0,\n    ensures\n        divide(x, y) <= x,\n{\n}\n\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n// F0 -- F-linear-ghost\nstruct State1 {\n    s: nat,\n}\n\nstruct State2 {\n    s: nat,\n}\n\n#[verifier::external_body]\nproof fn exchange(tracked s1: State1) -> (tracked s2: State2)\n    ensures\n        s1.s == s2.s,\n{\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise1(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise2(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\nproof fn p(tracked s1: State1) {\n    //+ let tracked s2 = exchange(s1);\n    exercise1(&s1);\n    //+ exercise(&s2);\n}\n\n// F1 -- F-linear-proof\nmod F1 {\n    use vstd::{prelude::*, simple_pptr::*};\n\n    #[verifier::external_body]\n    fn send_pointer(ptr: PPtr<u64>) {\n        todo!()\n    }\n\n    #[verifier::external_body]\n    proof fn transfer_permission(tracked perm: PointsTo<u64>) {\n        todo!()\n    }\n\n    fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)\n        requires\n            counter == old(perm).pptr(),\n            old(perm).is_init() && old(perm).value() < 100,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64),\n    {\n        // pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)\n        let cur_i: u64 = *counter.borrow(Tracked(&*perm));\n        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)\n        counter.replace(Tracked(perm), cur_i + 1);\n    }\n\n    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n        requires\n            counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit,\n    {\n        send_pointer(counter);\n        let tracked mut perm: PointsTo<u64> = perm;\n        // pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)\n        counter.put(Tracked(&mut perm), 5);\n        assert(perm.opt_value() === MemContents::Init(5));\n        //+ proof { transfer_permission(perm) };\n        increment(counter, Tracked(&mut perm));\n        assert(perm.opt_value() === MemContents::Init(6));\n    }\n\n}\n\n// F1\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/rfmig_script.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1020, "minimize_time_ms": 185030, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 255, "minimized_LOC": 255, "self_contained": true, "dependencies": ["vstd::prelude::verus", "vstd::prelude::"], "complexity_verus_tokens": 43, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n\n fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n\n\npub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)\n    requires\n        old(orig).balance >= amount,\n        old(dest).balance + amount < u64::MAX,\n    ensures\n        dest.balance == old(dest).balance + amount,\n        orig.balance == old(orig).balance - amount,\n{\n\n fn cmain(account: Account)\n//-     requires account.balance >= 100\n//- {\n\n fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n\n fn f(v: Vec<u64>) {\n\n fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n\n\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n\n fn send_pointer(ptr: PPtr<u64>) {\n\n fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)\n        requires\n            counter == old(perm).pptr(),\n            old(perm).is_init() && old(perm).value() < 100,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64),\n    {\n\n pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)\n        let cur_i: u64 = *counter.borrow(Tracked(&*perm));\n        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)\n        counter.replace(Tracked(perm), cur_i + 1);\n    }\n\n    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n        requires\n            counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit,\n    {\n\n pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)\n        counter.replace(Tracked(perm), cur_i + 1);\n    }\n\n    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n        requires\n            counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit,\n    {\n\n fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n        requires\n            counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit,\n    {\n\n pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)\n        counter.put(Tracked(&mut perm), 5);\n        assert(perm.opt_value() === MemContents::Init(5));\n        //+ proof {", "spec": "spec fn fibo(n: nat) -> nat\n    decreases n,\n{\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n\nspec fn divide(x: nat, y: nat) -> nat\n    recommends\n        y != 0,\n{\n\n    ensures\n\n    decreases n,\n\n    requires\n\n    ensures\n\n    decreases j - i,\n\n    requires\n\n    ensures\n\n        invariant\n\n    requires\n\n    ensures\n\n//-     requires account.balance >= 100\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    ensures\n\n    ensures\n\n        requires\n\n        ensures\n\n        requires", "proof": "proof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n\nproof fn div_is_smaller(x: nat, y: nat)/*+*/\n\n    by (nonlinear_arith)\n    requires\n        y != 0,\n    ensures\n        divide(x, y) <= x,\n{\n\nproof fn exchange(tracked s1: State1) -> (tracked s2: State2)\n    ensures\n        s1.s == s2.s,\n{\n\nproof fn exercise1(tracked s1: &State1) -> (result: bool) {\n\nproof fn exercise2(tracked s1: &State1) -> (result: bool) {\n\nproof fn p(tracked s1: State1) {\n\nproof fn transfer_permission(tracked perm: PointsTo<u64>) {\n\nproof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n\nproof { transfer_permission(perm) }"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n// #![allow(unused_imports, unused_macros, non_camel_case_types)] #![feature(fmt_internals)]\nuse vstd::prelude::verus;\n\nfn main() {}\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\npub struct Account {\n    pub balance: u64,\n}\n\npub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)\n    requires\n        old(orig).balance >= amount,\n        old(dest).balance + amount < u64::MAX,\n    ensures\n        dest.balance == old(dest).balance + amount,\n        orig.balance == old(orig).balance - amount,\n{\n    /*+*/\n    let accounts_pre: Ghost<(Account, Account)> = Ghost((*orig, *dest));\n    orig.balance = orig.balance - amount;\n    dest.balance = dest.balance + amount;\n    /*+*/\n    assert(orig.balance + dest.balance == accounts_pre@.0.balance + accounts_pre@.1.balance);\n}\n\n//- fn cmain(account: Account)\n//-     requires account.balance >= 100\n//- {\n//-     let mut account = account;\n//-     transfer(&mut account, &mut account, 100);\n//- }\n// ## C2(e) -- C2-linearity.rs\nuse vstd::prelude::*;\n\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// ## D -- D-recommends.rs\nspec fn divide(x: nat, y: nat) -> nat\n    recommends\n        y != 0,\n{\n    x / y\n}\n\n// E -- E-solvers.rs\nproof fn div_is_smaller(x: nat, y: nat)/*+*/\n\n    by (nonlinear_arith)\n    requires\n        y != 0,\n    ensures\n        divide(x, y) <= x,\n{\n}\n\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n// F0 -- F-linear-ghost\nstruct State1 {\n    s: nat,\n}\n\nstruct State2 {\n    s: nat,\n}\n\n#[verifier::external_body]\nproof fn exchange(tracked s1: State1) -> (tracked s2: State2)\n    ensures\n        s1.s == s2.s,\n{\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise1(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise2(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\nproof fn p(tracked s1: State1) {\n    //+ let tracked s2 = exchange(s1);\n    exercise1(&s1);\n    //+ exercise(&s2);\n}\n\n// F1 -- F-linear-proof\nmod F1 {\n    use vstd::{prelude::*, simple_pptr::*};\n\n    #[verifier::external_body]\n    fn send_pointer(ptr: PPtr<u64>) {\n        todo!()\n    }\n\n    #[verifier::external_body]\n    proof fn transfer_permission(tracked perm: PointsTo<u64>) {\n        todo!()\n    }\n\n    fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)\n        requires\n            counter == old(perm).pptr(),\n            old(perm).is_init() && old(perm).value() < 100,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64),\n    {\n        // pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)\n        let cur_i: u64 = *counter.borrow(Tracked(&*perm));\n        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)\n        counter.replace(Tracked(perm), cur_i + 1);\n    }\n\n    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n        requires\n            counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit,\n    {\n        send_pointer(counter);\n        let tracked mut perm: PointsTo<u64> = perm;\n        // pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)\n        counter.put(Tracked(&mut perm), 5);\n        assert(perm.opt_value() === MemContents::Init(5));\n        //+ proof { transfer_permission(perm) };\n        increment(counter, Tracked(&mut perm));\n        assert(perm.opt_value() === MemContents::Init(6));\n    }\n\n}\n\n// F1\n\n} // verus!\n", "use vstd;\nfn main() {}\n", "use vstd::prelude::verus;\n        fn main() {}\n        verus! {}\n", "use vstd::prelude::verus;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "rw2022_script_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\nfn max_test2() {\n    let x = 3;\n    let y = 4;\n    let ret = max(x, y);\n    assert(ret == 4);\n}\n\n// ## B -- B-program.rs\nfn main_1() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n// ## B -- B-program.rs.smt sat\n// ## C -- C-prime.rs\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor <= candidate,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            assert(!is_prime(candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn assertions() {\n    assert(divides(3, 6));\n    assert(divides(12, 24));\n    assert(is_prime(2));\n    assert(is_prime(3));\n    assert(!divides(4, 5));\n    assert(is_prime(5));\n}\n\n// ## D -- D-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    // ----\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\n// ## D/2 -- D-fibo.rs\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    // ----\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[verifier::spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\nfn max_test2() {\n    let x = 3;\n    let y = 4;\n    let ret = max(x, y);\n    assert(ret == 4);\n}\n\n// ## B -- B-program.rs\nfn main_1() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n// ## B -- B-program.rs.smt sat\n// ## C -- C-prime.rs\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor <= candidate,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            assert(!is_prime(candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn assertions() {\n    assert(divides(3, 6));\n    assert(divides(12, 24));\n    assert(is_prime(2));\n    assert(is_prime(3));\n    assert(!divides(4, 5));\n    assert(is_prime(5));\n}\n\n// ## D -- D-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    // ----\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\n// ## D/2 -- D-fibo.rs\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    // ----\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[verifier::spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/rw2022_script.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 945, "minimize_time_ms": 183715, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 189, "minimized_LOC": 189, "self_contained": true, "complexity_verus_tokens": 29, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_invariant": true, "has_proof_block": true, "ensures_count": 1, "segments": {"exec": "\nfn main() {\n\n\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n\n\nfn max_test2() {\n\n\nfn main_1() {\n\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n\n\nfn assertions() {\n\n fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n\n\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{", "spec": "spec fn divides(factor: nat, candidate: nat) -> bool {\n\nspec fn is_prime(candidate: nat) -> bool {\n\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n\n    ensures\n\n    requires\n\n    ensures\n\n        invariant\n\n    decreases n,\n\n    requires\n\n    ensures\n\n    decreases j - i,\n\n    requires\n\n    ensures\n\n        invariant\n\n    ensures([\n\n        invariant([\n\n    ensures", "proof": "proof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n\nproof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\nfn max_test2() {\n    let x = 3;\n    let y = 4;\n    let ret = max(x, y);\n    assert(ret == 4);\n}\n\n// ## B -- B-program.rs\nfn main_1() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n// ## B -- B-program.rs.smt sat\n// ## C -- C-prime.rs\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor <= candidate,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            assert(!is_prime(candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn assertions() {\n    assert(divides(3, 6));\n    assert(divides(12, 24));\n    assert(is_prime(2));\n    assert(is_prime(3));\n    assert(!divides(4, 5));\n    assert(is_prime(5));\n}\n\n// ## D -- D-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    // ----\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\n// ## D/2 -- D-fibo.rs\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    // ----\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[verifier::spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "fn main() {}\nuse{vstd};\n", "fn main() {}\nuse{verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n", "fn main() {}\nuse{vstd};\n"]}
{"id": "rwlock_vstd_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::prelude::*;\nuse vstd::rwlock::*;\n\nverus!{\n\nfn example1() {\n    // We can create a lock with an invariant: `v == 5 || v == 13`.\n    // Thus only 5 or 13 can be stored in the lock.\n    let lock = RwLock::<u64, spec_fn(u64) -> bool>::new(5, Ghost(|v| v == 5 || v == 13));\n\n    let (val, write_handle) = lock.acquire_write();\n    assert(val == 5 || val == 13);\n    write_handle.release_write(13);\n\n    let read_handle1 = lock.acquire_read();\n    let read_handle2 = lock.acquire_read();\n\n    // We can take multiple read handles at the same time:\n\n    let val1 = read_handle1.borrow();\n    let val2 = read_handle2.borrow();\n\n    // RwLock has a lemma that both read handles have the same value:\n\n    proof { ReadHandle::lemma_readers_match(&read_handle1, &read_handle2); }\n    assert(*val1 == *val2);\n\n    read_handle1.release_read();\n    read_handle2.release_read();\n}\n\n// Using higher-order functions is often cumbersome, we can use traits instead.\n\npub struct FixedParity {\n    pub parity: int,\n}\n\nimpl RwLockPredicate<u64> for FixedParity {\n    open spec fn inv(self, v: u64) -> bool {\n        v % 2 == self.parity\n    }\n}\n\nfn example2() {\n    let lock_even = RwLock::<u64, FixedParity>::new(20, Ghost(FixedParity { parity: 0 }));\n    let lock_odd = RwLock::<u64, FixedParity>::new(23, Ghost(FixedParity { parity: 1 }));\n\n    let read_handle_even = lock_even.acquire_read();\n    let val_even = *read_handle_even.borrow();\n    assert(val_even % 2 == 0);\n\n    let read_handle_odd = lock_odd.acquire_read();\n    let val_odd = *read_handle_odd.borrow();\n    assert(val_odd % 2 == 1);\n}\n\npub fn main() {\n    example1();\n    example2();\n}\n\n}\n", "minimized_code": "use vstd::prelude::*;\n        use vstd::rwlock::*;\n        verus!{\n       fn example1() ;\n       pub struct FixedParity ;\n       impl RwLockPredicate<u64> for FixedParity {\n          open spec fn inv(self, v: u64) -> bool ;\n      }\n       pub fn main() ;\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/rwlock_vstd.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 731, "minimize_time_ms": 185071, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 65, "minimized_LOC": 10, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::rwlock::"], "complexity_verus_tokens": 2, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.15384615384615385}, "labeling": {"segments": {"exec": " fn example1() ;\n       pub struct FixedParity ;\n       impl RwLockPredicate<u64> for FixedParity {"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::prelude::*;\nuse vstd::rwlock::*;\n\nverus!{\n\nfn example1() {\n    // We can create a lock with an invariant: `v == 5 || v == 13`.\n    // Thus only 5 or 13 can be stored in the lock.\n    let lock = RwLock::<u64, spec_fn(u64) -> bool>::new(5, Ghost(|v| v == 5 || v == 13));\n\n    let (val, write_handle) = lock.acquire_write();\n    assert(val == 5 || val == 13);\n    write_handle.release_write(13);\n\n    let read_handle1 = lock.acquire_read();\n    let read_handle2 = lock.acquire_read();\n\n    // We can take multiple read handles at the same time:\n\n    let val1 = read_handle1.borrow();\n    let val2 = read_handle2.borrow();\n\n    // RwLock has a lemma that both read handles have the same value:\n\n    proof { ReadHandle::lemma_readers_match(&read_handle1, &read_handle2); }\n    assert(*val1 == *val2);\n\n    read_handle1.release_read();\n    read_handle2.release_read();\n}\n\n// Using higher-order functions is often cumbersome, we can use traits instead.\n\npub struct FixedParity {\n    pub parity: int,\n}\n\nimpl RwLockPredicate<u64> for FixedParity {\n    open spec fn inv(self, v: u64) -> bool {\n        v % 2 == self.parity\n    }\n}\n\nfn example2() {\n    let lock_even = RwLock::<u64, FixedParity>::new(20, Ghost(FixedParity { parity: 0 }));\n    let lock_odd = RwLock::<u64, FixedParity>::new(23, Ghost(FixedParity { parity: 1 }));\n\n    let read_handle_even = lock_even.acquire_read();\n    let val_even = *read_handle_even.borrow();\n    assert(val_even % 2 == 0);\n\n    let read_handle_odd = lock_odd.acquire_read();\n    let val_odd = *read_handle_odd.borrow();\n    assert(val_odd % 2 == 1);\n}\n\npub fn main() {\n    example1();\n    example2();\n}\n\n}\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\n        use vstd::rwlock::*;\n        verus!{\n       fn example1() ;\n       pub struct FixedParity ;\n       impl RwLockPredicate<u64> for FixedParity {\n          open spec fn inv(self, v: u64) -> bool ;\n      }\n       pub fn main() ;\n       }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "set_from_vec_cc0b9f7d", "original_code": "use vstd::prelude::*;\n\nverus! {\n\nstruct VecSet {\n    vt: Vec<u64>,\n}\n\nimpl VecSet {\n    pub closed spec fn view(&self) -> Set<u64> {\n        self.vt@.to_set()\n    }\n\n    pub fn new() -> (s: Self)\n        ensures\n            s@ =~= Set::<u64>::empty(),\n    {\n        VecSet { vt: Vec::new() }\n    }\n\n    pub fn insert(&mut self, v: u64)\n        ensures\n            self@ =~= old(self)@.insert(v),\n    {\n        self.vt.push(v);\n        proof {\n            broadcast use vstd::seq_lib::group_seq_properties;\n        }\n        assert(self.vt@ =~= old(self).vt@ + seq![v]);\n    }\n\n    pub fn contains(&self, v: u64) -> (contained: bool)\n        ensures\n            contained == self@.contains(v),\n    {\n        for i in iter: 0..self.vt.len()\n            invariant\n                forall|j: nat| j < i ==> self.vt[j as int] != v,\n        {\n            if self.vt[i] == v {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn main() {\n    let mut vs: VecSet = VecSet::new();\n    assert(vs@ =~= set![]);\n    vs.insert(3);\n    vs.insert(5);\n    let contains2 = vs.contains(2);\n    assert(!contains2);\n    assert(vs@ =~= set![3, 5]);\n}\n\n} // verus!\n", "minimized_code": "use vstd::prelude::*;\n\nverus! {\n\nstruct VecSet {\n    vt: Vec<u64>,\n}\n\nimpl VecSet {\n    pub closed spec fn view(&self) -> Set<u64> {\n        self.vt@.to_set()\n    }\n\n    pub fn new() -> (s: Self)\n        ensures\n            s@ =~= Set::<u64>::empty(),\n    {\n        VecSet { vt: Vec::new() }\n    }\n\n    pub fn insert(&mut self, v: u64)\n        ensures\n            self@ =~= old(self)@.insert(v),\n    {\n        self.vt.push(v);\n        proof {\n            broadcast use vstd::seq_lib::group_seq_properties;\n        }\n        assert(self.vt@ =~= old(self).vt@ + seq![v]);\n    }\n\n    pub fn contains(&self, v: u64) -> (contained: bool)\n        ensures\n            contained == self@.contains(v),\n    {\n        for i in iter: 0..self.vt.len()\n            invariant\n                forall|j: nat| j < i ==> self.vt[j as int] != v,\n        {\n            if self.vt[i] == v {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn main() {\n    let mut vs: VecSet = VecSet::new();\n    assert(vs@ =~= set![]);\n    vs.insert(3);\n    vs.insert(5);\n    let contains2 = vs.contains(2);\n    assert(!contains2);\n    assert(vs@ =~= set![3, 5]);\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/set_from_vec.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1321, "minimize_time_ms": 153024, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn new() -> (s: Self)\n        ensures\n            s@ =~= Set::<u64>::empty(),\n    {\n\n pub fn insert(&mut self, v: u64)\n        ensures\n            self@ =~= old(self)@.insert(v),\n    {\n\n pub fn contains(&self, v: u64) -> (contained: bool)\n        ensures\n            contained == self@.contains(v),\n    {\n\n\nfn main() {", "spec": "spec fn view(&self) -> Set<u64> {\n\n        ensures\n\n        ensures\n\n        ensures\n\n            invariant", "proof": "proof {\n            broadcast use vstd::seq_lib::group_seq_properties;\n        }"}}}, "all_snapshots": ["use vstd::prelude::*;\n\nverus! {\n\nstruct VecSet {\n    vt: Vec<u64>,\n}\n\nimpl VecSet {\n    pub closed spec fn view(&self) -> Set<u64> {\n        self.vt@.to_set()\n    }\n\n    pub fn new() -> (s: Self)\n        ensures\n            s@ =~= Set::<u64>::empty(),\n    {\n        VecSet { vt: Vec::new() }\n    }\n\n    pub fn insert(&mut self, v: u64)\n        ensures\n            self@ =~= old(self)@.insert(v),\n    {\n        self.vt.push(v);\n        proof {\n            broadcast use vstd::seq_lib::group_seq_properties;\n        }\n        assert(self.vt@ =~= old(self).vt@ + seq![v]);\n    }\n\n    pub fn contains(&self, v: u64) -> (contained: bool)\n        ensures\n            contained == self@.contains(v),\n    {\n        for i in iter: 0..self.vt.len()\n            invariant\n                forall|j: nat| j < i ==> self.vt[j as int] != v,\n        {\n            if self.vt[i] == v {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn main() {\n    let mut vs: VecSet = VecSet::new();\n    assert(vs@ =~= set![]);\n    vs.insert(3);\n    vs.insert(5);\n    let contains2 = vs.contains(2);\n    assert(!contains2);\n    assert(vs@ =~= set![3, 5]);\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "adder_with_max_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {\n    AdderWithMax {\n        fields {\n            #[sharding(constant)]\n            pub maximum: int,\n\n            #[sharding(variable)]\n            pub number: int,\n\n            #[sharding(not_tokenized)]\n            pub minimum: int,\n        }\n\n        init!{\n            initialize(m: int) {\n                require(m >= 0);\n                init number = 0;\n                init minimum = 0;\n                init maximum = m;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                require(n >= 0);\n                require(pre.number + n <= pre.maximum);\n                update number = pre.number + n;\n            }\n        }\n\n        transition!{\n            change_to_minimum() {\n                birds_eye let min = pre.minimum;\n                update number = min;\n            }\n        }\n\n        #[invariant]\n        pub fn is_bounded_below(&self) -> bool {\n            self.number >= self.minimum\n        }\n\n        #[invariant]\n        pub fn is_bounded_above(&self) -> bool {\n            self.number <= self.maximum\n        }\n\n        #[inductive(initialize)]\n        fn init_preserves(post: Self, m: int) {\n        }\n\n        #[inductive(add)]\n        fn add_preserves(pre: Self, post: Self, n: int) {\n        }\n\n        #[inductive(change_to_minimum)]\n        fn change_to_minimum_inductive(pre: Self, post: Self) { }\n    }\n}\n\nfn main() {}\n", "minimized_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {\n    AdderWithMax {\n        fields {\n            #[sharding(constant)]\n            pub maximum: int,\n\n            #[sharding(variable)]\n            pub number: int,\n\n            #[sharding(not_tokenized)]\n            pub minimum: int,\n        }\n\n        init!{\n            initialize(m: int) {\n                require(m >= 0);\n                init number = 0;\n                init minimum = 0;\n                init maximum = m;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                require(n >= 0);\n                require(pre.number + n <= pre.maximum);\n                update number = pre.number + n;\n            }\n        }\n\n        transition!{\n            change_to_minimum() {\n                birds_eye let min = pre.minimum;\n                update number = min;\n            }\n        }\n\n        #[invariant]\n        pub fn is_bounded_below(&self) -> bool {\n            self.number >= self.minimum\n        }\n\n        #[invariant]\n        pub fn is_bounded_above(&self) -> bool {\n            self.number <= self.maximum\n        }\n\n        #[inductive(initialize)]\n        fn init_preserves(post: Self, m: int) {\n        }\n\n        #[inductive(add)]\n        fn add_preserves(pre: Self, post: Self, n: int) {\n        }\n\n        #[inductive(change_to_minimum)]\n        fn change_to_minimum_inductive(pre: Self, post: Self) { }\n    }\n}\n\nfn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/adder_with_max.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 841, "minimize_time_ms": 153392, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": false, "dependencies": ["verus_builtin::", "vstd::", "verus_state_machines_macros::tokenized_state_machine"], "complexity_verus_tokens": 2, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": " pub fn is_bounded_below(&self) -> bool {\n\n pub fn is_bounded_above(&self) -> bool {\n\n fn init_preserves(post: Self, m: int) {\n\n fn add_preserves(pre: Self, post: Self, n: int) {\n\n fn change_to_minimum_inductive(pre: Self, post: Self) {\n\n\nfn main() {", "spec": "        #[invariant]\n\n        #[invariant]"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {\n    AdderWithMax {\n        fields {\n            #[sharding(constant)]\n            pub maximum: int,\n\n            #[sharding(variable)]\n            pub number: int,\n\n            #[sharding(not_tokenized)]\n            pub minimum: int,\n        }\n\n        init!{\n            initialize(m: int) {\n                require(m >= 0);\n                init number = 0;\n                init minimum = 0;\n                init maximum = m;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                require(n >= 0);\n                require(pre.number + n <= pre.maximum);\n                update number = pre.number + n;\n            }\n        }\n\n        transition!{\n            change_to_minimum() {\n                birds_eye let min = pre.minimum;\n                update number = min;\n            }\n        }\n\n        #[invariant]\n        pub fn is_bounded_below(&self) -> bool {\n            self.number >= self.minimum\n        }\n\n        #[invariant]\n        pub fn is_bounded_above(&self) -> bool {\n            self.number <= self.maximum\n        }\n\n        #[inductive(initialize)]\n        fn init_preserves(post: Self, m: int) {\n        }\n\n        #[inductive(add)]\n        fn add_preserves(pre: Self, post: Self, n: int) {\n        }\n\n        #[inductive(change_to_minimum)]\n        fn change_to_minimum_inductive(pre: Self, post: Self) { }\n    }\n}\n\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n           fn main() {\n }\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "arc_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{atomic::*, pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n        assert(pre.counter > 0);\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n            assert(pre.counter == 1);\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerArc<S> {\n    pub rc_cell: PAtomicU64,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: PermissionU64,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n        &&& self.rc_perm@.patomic == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm@.value as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerArc<S> {\n    spec fn wf(self, cell: PAtomicU64) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyArc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerArc<S>>,\n\n        pub rc_cell: Ghost< PAtomicU64 >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyArc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n        ensures\n            rc.wf(),\n            rc@ == s,\n    {\n        let (rc_cell, Tracked(rc_perm)) = PAtomicU64::new(1);\n        let inner_rc = InnerArc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = AtomicInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyArc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n        ensures\n            s.wf() && s@ == self@,\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked inst = self.inst.borrow();\n            let tracked reader = self.reader.borrow();\n            let tracked perm = inst.reader_guard(reader.element(), &reader);\n            let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n            let count: u64;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));\n\n                proof { g = GhostStuff { rc_perm, rc_token }; }\n            });\n            assume(count < 100000000);\n            let tracked mut new_reader = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);\n\n                proof {\n                    if res.is_ok() {\n                        new_reader = Some(self.inst.borrow().do_clone(\n                            reader.element(),\n                            &mut rc_token,\n                            &reader));\n                    }\n                }\n\n                proof { g = GhostStuff { rc_perm, rc_token }; }\n            });\n            if res.is_ok() {\n                return MyArc {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    inv: Tracked(self.inv.borrow().clone()),\n                    reader: Tracked(new_reader.tracked_unwrap()),\n                    ptr: self.ptr,\n                    rc_cell: Ghost(self.rc_cell@),\n                };\n            }\n        }\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyArc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_atomic_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);\n\n            proof {\n                if rc_token.value() < 2 {\n                    let tracked inner_rc_perm = inst.dec_to_zero(\n                        reader.element(), &mut rc_token, reader);\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                } else {\n                    inst.dec_basic(reader.element(), &mut rc_token, reader);\n                }\n\n                g = GhostStuff { rc_perm, rc_token };\n            }\n        });\n        if count == 1 {\n            let tracked mut inner_rc_perm = inner_rc_perm_opt.tracked_unwrap();\n            let _inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n            ptr.free(Tracked(inner_rc_perm));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyArc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyArc::new(Sequence::Nil);\n    let a5 = MyArc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyArc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyArc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use verus_state_machines_macros::tokenized_state_machine;\n    use vstd::invariant::*;\n    use vstd::multiset::*;\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::{\n  atomic::*, pervasive::*, *};\n    use vstd::shared::*;\n    verus! {\n   tokenized_state_machine!(RefCounter<Perm> {\n      fields {\n#[sharding(variable)]\n        pub counter: nat,            \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,            \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n         forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n         self.counter == 0 ==> self.storage is None     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n         self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n      init!{\n         initialize_empty() {             init counter = 0;             init storage = Option::None;             init reader = Multiset::empty();         }\n     }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n }\n      transition!{\n         do_deposit(x: Perm) {             require(pre.counter == 0);             update counter = 1;             deposit storage += Some(x);             add reader += {x};         }\n     }\n#[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) {\n }\n      property!{\n         reader_guard(x: Perm) {             have reader >= {x};             guard storage >= Some(x);         }\n     }\n      transition!{\n         do_clone(x: Perm) {             have reader >= {x};             add reader += {x};             update counter = pre.counter + 1;         }\n     }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n         assert(pre.storage is Some);\n         assert(pre.counter > 0);\n     }\n      transition!{\n         dec_basic(x: Perm) {             require(pre.counter >= 2);             remove reader -= {x};             update counter = (pre.counter - 1) as nat;         }\n     }\n      transition!{\n         dec_to_zero(x: Perm) {             remove reader -= {x};             require(pre.counter < 2);             assert(pre.counter == 1);             update counter = 0;             withdraw storage -= Some(x);         }\n     }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n     }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n }\n  }\n  );\n   pub struct InnerArc<S> {\n      pub rc_cell: PAtomicU64,     pub s: S, }\n   pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n   pub tracked struct GhostStuff<S> {\n      pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n   impl<S> GhostStuff<S> {\n      pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n         &&& self.rc_perm@.patomic == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm@.value as nat == self.rc_token.value()     }\n  }\n   struct_with_invariants!{\n      struct MyArc<S> {\n         pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n      spec fn wf(self) -> bool {\n         predicate {             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }\n     }\n  }\n   impl<S> MyArc<S> {\n     fn clone(&self) -> (s: Self)         requires             self.wf(),     {\n         loop             invariant                 self.wf(),         {             let tracked inst = self.inst.borrow();             let tracked reader = self.reader.borrow();             let tracked perm = inst.reader_guard(reader.element(), &reader);             let inner_rc_ref = self.ptr.borrow(Tracked(perm));             let count: u64;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             assume(count < 100000000);             let tracked mut new_reader = None;             let res;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);                 proof {                     if res.is_ok() {                         new_reader = Some(self.inst.borrow().do_clone(                             reader.element(),                             &mut rc_token,                             &reader));                     }                 }                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             if res.is_ok() {                 return MyArc {                     inst: Tracked(self.inst.borrow().clone()),                     inv: Tracked(self.inv.borrow().clone()),                     reader: Tracked(new_reader.tracked_unwrap()),                     ptr: self.ptr,                     rc_cell: Ghost(self.rc_cell@),                 };             }         }\n     }\n     fn dispose(self)         requires             self.wf(),     {\n         let MyArc {             inst: Tracked(inst),             inv: Tracked(inv),             reader: Tracked(reader),             ptr,             rc_cell: _,         }\n = self;\n         let tracked perm = inst.reader_guard(reader.element(), &reader);\n         let inner_rc_ref = &ptr.borrow(Tracked(perm));\n         let count;\n         let tracked mut inner_rc_perm_opt = None;\n         open_atomic_invariant!(inv.borrow() => g => {             let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;             count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);             proof {                 if rc_token.value() < 2 {                     let tracked inner_rc_perm = inst.dec_to_zero(                         reader.element(), &mut rc_token, reader);                     inner_rc_perm_opt = Some(inner_rc_perm);                 } else {                     inst.dec_basic(reader.element(), &mut rc_token, reader);                 }                 g = GhostStuff { rc_perm, rc_token };             }         }\n);\n         if count == 1 {         }\n     }\n }\n fn main() {\n }\n }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/arc.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1820, "minimize_time_ms": 1017350, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 331, "minimized_LOC": 104, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "verus_state_machines_macros::tokenized_state_machine", "vstd::cell::", "vstd::invariant::", "vstd::modes::", "vstd::multiset::", "vstd::prelude::", "vstd::simple_pptr::", "vstd::", "vstd::shared::"], "complexity_verus_tokens": 23, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 0.31419939577039274}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn reader_agrees_storage(&self) -> bool {\n\n pub fn counter_agrees_storage(&self) -> bool {\n\n pub fn counter_agrees_reader_count(&self) -> bool {\n\n fn initialize_empty_inductive(post: Self) {\n\n fn do_deposit_inductive(pre: Self, post: Self, x: Perm) {\n\n fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n\n fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n\n fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n\n fn clone(&self) -> (s: Self)         requires             self.wf(),     {\n\n fn dispose(self)         requires             self.wf(),     {\n\n fn main() {", "spec": "spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n\nspec fn wf(self) -> bool {\n\n    use vstd::invariant::*;\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }\n\n     fn clone(&self) -> (s: Self)         requires             self.wf(),     {\n\n         loop             invariant                 self.wf(),         {             let tracked inst = self.inst.borrow();             let tracked reader = self.reader.borrow();             let tracked perm = inst.reader_guard(reader.element(), &reader);             let inner_rc_ref = self.ptr.borrow(Tracked(perm));             let count: u64;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             assume(count < 100000000);             let tracked mut new_reader = None;             let res;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);                 proof {                     if res.is_ok() {                         new_reader = Some(self.inst.borrow().do_clone(                             reader.element(),                             &mut rc_token,                             &reader));                     }                 }                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             if res.is_ok() {                 return MyArc {                     inst: Tracked(self.inst.borrow().clone()),                     inv: Tracked(self.inv.borrow().clone()),                     reader: Tracked(new_reader.tracked_unwrap()),                     ptr: self.ptr,                     rc_cell: Ghost(self.rc_cell@),                 };             }         }\n\n     fn dispose(self)         requires             self.wf(),     {", "proof": "proof { g = GhostStuff { rc_perm, rc_token }; }\n\nproof {                     if res.is_ok() {                         new_reader = Some(self.inst.borrow().do_clone(                             reader.element(),                             &mut rc_token,                             &reader));                     }                 }\n\nproof { g = GhostStuff { rc_perm, rc_token }; }\n\nproof {                 if rc_token.value() < 2 {                     let tracked inner_rc_perm = inst.dec_to_zero(                         reader.element(), &mut rc_token, reader);                     inner_rc_perm_opt = Some(inner_rc_perm);                 } else {                     inst.dec_basic(reader.element(), &mut rc_token, reader);                 }                 g = GhostStuff { rc_perm, rc_token };             }"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{atomic::*, pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n        assert(pre.counter > 0);\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n            assert(pre.counter == 1);\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerArc<S> {\n    pub rc_cell: PAtomicU64,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: PermissionU64,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n        &&& self.rc_perm@.patomic == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm@.value as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerArc<S> {\n    spec fn wf(self, cell: PAtomicU64) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyArc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerArc<S>>,\n\n        pub rc_cell: Ghost< PAtomicU64 >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyArc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n        ensures\n            rc.wf(),\n            rc@ == s,\n    {\n        let (rc_cell, Tracked(rc_perm)) = PAtomicU64::new(1);\n        let inner_rc = InnerArc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = AtomicInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyArc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n        ensures\n            s.wf() && s@ == self@,\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked inst = self.inst.borrow();\n            let tracked reader = self.reader.borrow();\n            let tracked perm = inst.reader_guard(reader.element(), &reader);\n            let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n            let count: u64;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));\n\n                proof { g = GhostStuff { rc_perm, rc_token }; }\n            });\n            assume(count < 100000000);\n            let tracked mut new_reader = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);\n\n                proof {\n                    if res.is_ok() {\n                        new_reader = Some(self.inst.borrow().do_clone(\n                            reader.element(),\n                            &mut rc_token,\n                            &reader));\n                    }\n                }\n\n                proof { g = GhostStuff { rc_perm, rc_token }; }\n            });\n            if res.is_ok() {\n                return MyArc {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    inv: Tracked(self.inv.borrow().clone()),\n                    reader: Tracked(new_reader.tracked_unwrap()),\n                    ptr: self.ptr,\n                    rc_cell: Ghost(self.rc_cell@),\n                };\n            }\n        }\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyArc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_atomic_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);\n\n            proof {\n                if rc_token.value() < 2 {\n                    let tracked inner_rc_perm = inst.dec_to_zero(\n                        reader.element(), &mut rc_token, reader);\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                } else {\n                    inst.dec_basic(reader.element(), &mut rc_token, reader);\n                }\n\n                g = GhostStuff { rc_perm, rc_token };\n            }\n        });\n        if count == 1 {\n            let tracked mut inner_rc_perm = inner_rc_perm_opt.tracked_unwrap();\n            let _inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n            ptr.free(Tracked(inner_rc_perm));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyArc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyArc::new(Sequence::Nil);\n    let a5 = MyArc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyArc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyArc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a<b>{fields{\n#[sharding(storage_option)]\n    pub c : Option<b>\n  }});\n  fn main();\n}\n", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use verus_state_machines_macros::tokenized_state_machine;\n    use vstd::invariant::*;\n    use vstd::multiset::*;\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::{\n  atomic::*, pervasive::*, *};\n    use vstd::shared::*;\n    verus! {\n   tokenized_state_machine!(RefCounter<Perm> {\n      fields {\n#[sharding(variable)]\n        pub counter: nat,            \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,            \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n         forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n         self.counter == 0 ==> self.storage is None     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n         self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n      init!{\n         initialize_empty() {             init counter = 0;             init storage = Option::None;             init reader = Multiset::empty();         }\n     }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n }\n      transition!{\n         do_deposit(x: Perm) {             require(pre.counter == 0);             update counter = 1;             deposit storage += Some(x);             add reader += {x};         }\n     }\n#[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) {\n }\n      property!{\n         reader_guard(x: Perm) {             have reader >= {x};             guard storage >= Some(x);         }\n     }\n      transition!{\n         do_clone(x: Perm) {             have reader >= {x};             add reader += {x};             update counter = pre.counter + 1;         }\n     }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n         assert(pre.storage is Some);\n         assert(pre.counter > 0);\n     }\n      transition!{\n         dec_basic(x: Perm) {             require(pre.counter >= 2);             remove reader -= {x};             update counter = (pre.counter - 1) as nat;         }\n     }\n      transition!{\n         dec_to_zero(x: Perm) {             remove reader -= {x};             require(pre.counter < 2);             assert(pre.counter == 1);             update counter = 0;             withdraw storage -= Some(x);         }\n     }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n     }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n }\n  }\n  );\n   pub struct InnerArc<S> {\n      pub rc_cell: PAtomicU64,     pub s: S, }\n   pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n   pub tracked struct GhostStuff<S> {\n      pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n   impl<S> GhostStuff<S> {\n      pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n         &&& self.rc_perm@.patomic == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm@.value as nat == self.rc_token.value()     }\n  }\n   struct_with_invariants!{\n      struct MyArc<S> {\n         pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n      spec fn wf(self) -> bool {\n         predicate {             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }\n     }\n  }\n   impl<S> MyArc<S> {\n     fn clone(&self) -> (s: Self)         requires             self.wf(),     {\n         loop             invariant                 self.wf(),         {             let tracked inst = self.inst.borrow();             let tracked reader = self.reader.borrow();             let tracked perm = inst.reader_guard(reader.element(), &reader);             let inner_rc_ref = self.ptr.borrow(Tracked(perm));             let count: u64;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             assume(count < 100000000);             let tracked mut new_reader = None;             let res;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);                 proof {                     if res.is_ok() {                         new_reader = Some(self.inst.borrow().do_clone(                             reader.element(),                             &mut rc_token,                             &reader));                     }                 }                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             if res.is_ok() {                 return MyArc {                     inst: Tracked(self.inst.borrow().clone()),                     inv: Tracked(self.inv.borrow().clone()),                     reader: Tracked(new_reader.tracked_unwrap()),                     ptr: self.ptr,                     rc_cell: Ghost(self.rc_cell@),                 };             }         }\n     }\n     fn dispose(self)         requires             self.wf(),     {\n         let MyArc {             inst: Tracked(inst),             inv: Tracked(inv),             reader: Tracked(reader),             ptr,             rc_cell: _,         }\n = self;\n         let tracked perm = inst.reader_guard(reader.element(), &reader);\n         let inner_rc_ref = &ptr.borrow(Tracked(perm));\n         let count;\n         let tracked mut inner_rc_perm_opt = None;\n         open_atomic_invariant!(inv.borrow() => g => {             let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;             count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);             proof {                 if rc_token.value() < 2 {                     let tracked inner_rc_perm = inst.dec_to_zero(                         reader.element(), &mut rc_token, reader);                     inner_rc_perm_opt = Some(inner_rc_perm);                 } else {                     inst.dec_basic(reader.element(), &mut rc_token, reader);                 }                 g = GhostStuff { rc_perm, rc_token };             }         }\n);\n         if count == 1 {         }\n     }\n }\n fn main() {\n }\n }\n", " use verus_state_machines_macros::tokenized_state_machine;\n     use vstd::invariant::*;\n     use vstd::multiset::*;\n     use vstd::prelude::*;\n     use vstd::simple_pptr::*;\n     use vstd::{\n   atomic::*, pervasive::*, *};\n     use vstd::shared::*;\n     verus! {\n    tokenized_state_machine!(RefCounter<Perm> {\n       fields {\n#[sharding(variable)]\n        pub counter: nat,             \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,             \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n          forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n          self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n       init!{\n          initialize_empty() {\n             init counter = 0;\n             init storage = Option::None;\n             init reader = Multiset::empty();\n         }\n      }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n  }\n       property!{\n          reader_guard(x: Perm) {\n             have reader >= {x};\n             guard storage >= Some(x);\n         }\n      }\n       transition!{\n          do_clone(x: Perm) {\n         }\n      }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n      }\n       transition!{\n          dec_basic(x: Perm) {\n             require(pre.counter >= 2);\n             remove reader -= {x};\n             update counter = (pre.counter - 1) as nat;\n         }\n      }\n       transition!{\n          dec_to_zero(x: Perm) {\n             remove reader -= {x};\n             require(pre.counter < 2);\n             assert(pre.counter == 1);\n             update counter = 0;\n             withdraw storage -= Some(x);\n         }\n      }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n      }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n  }\n   }\n   );\n    pub struct InnerArc<S> {\n       pub rc_cell: PAtomicU64,     pub s: S, }\n    pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n    pub tracked struct GhostStuff<S> {\n       pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n    impl<S> GhostStuff<S> {\n       pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n          &&& self.rc_perm@.patomic == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm@.value as nat == self.rc_token.value()     }\n   }\n    struct_with_invariants!{\n       struct MyArc<S> {\n          pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n       spec fn wf(self) -> bool {\n          predicate {\n             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n          invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n             v.wf(inst@, rc_cell@)         }\n      }\n   }\n    impl<S> MyArc<S> {\n      fn dispose(self)         requires             self.wf(),     {\n          let MyArc {\n             inst: Tracked(inst),             inv: Tracked(inv),             reader: Tracked(reader),             ptr,             rc_cell: _,         }\n  = self;\n          let tracked perm = inst.reader_guard(reader.element(), &reader);\n          let inner_rc_ref = &ptr.borrow(Tracked(perm));\n          let count;\n          let tracked mut inner_rc_perm_opt = None;\n          open_atomic_invariant!(inv.borrow() => g => {\n             let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token }\n = g;\n             count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);\n             proof {                 if rc_token.value() < 2 {                     let tracked inner_rc_perm = inst.dec_to_zero(                         reader.element(), &mut rc_token, reader);                     inner_rc_perm_opt = Some(inner_rc_perm);                 } else {                     inst.dec_basic(reader.element(), &mut rc_token, reader);                 }                 g = GhostStuff { rc_perm, rc_token };             }\n         }\n );\n      }\n  }\n  fn main() {\n  }\n  }\n", " use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      atomic::*, pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n     }\n          property!{\n             reader_guard(x: Perm) {\n                have reader >= {\n  x};\n                guard storage >= Some(x);\n            }\n         }\n          transition!{\n             do_clone(x: Perm) {\n            }\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         }\n          transition!{\n             dec_basic(x: Perm) {\n                remove reader -= {\n  x};\n                update counter = (pre.counter - 1) as nat;\n            }\n         }\n          transition!{\n             dec_to_zero(x: Perm) {\n                remove reader -= {\n  x};\n                require(pre.counter < 2);\n                assert(pre.counter == 1);\n                update counter = 0;\n            }\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n     }\n      }\n      );\n       pub struct InnerArc<S> {\n          pub rc_cell: PAtomicU64,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n             &&& self.rc_perm@.patomic == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm@.value as nat == self.rc_token.value()     }\n      }\n       struct_with_invariants!{\n          struct MyArc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyArc<S> {\n         fn dispose(self)         requires             self.wf(),     ;\n     }\n     fn main() ;\n     }\n", " use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      atomic::*, pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n          property!{\n             reader_guard(x: Perm) {}\n         }\n          transition!{\n             do_clone(x: Perm) {}\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n          transition!{\n             dec_basic(x: Perm) {}\n         }\n          transition!{\n             dec_to_zero(x: Perm) {\n                remove reader -= {\n  x};\n                require(pre.counter < 2);\n                assert(pre.counter == 1);\n                update counter = 0;\n            }\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n     }\n      }\n      );\n       pub struct InnerArc<S> {\n          pub rc_cell: PAtomicU64,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool ;\n      }\n       struct_with_invariants!{\n          struct MyArc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyArc<S> {\n         fn dispose(self)         requires             self.wf(),     ;\n     }\n     fn main() ;\n     }\n", " use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      atomic::*, pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n          property!{\n             reader_guard() {}\n         }\n          transition!{\n             do_clone(x: Perm) {}\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n          transition!{\n             dec_basic(x: Perm) {}\n         }\n          transition!{\n             dec_to_zero(x: Perm) {}\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}\n      }\n      );\n       pub struct InnerArc<S> {\n          pub rc_cell: PAtomicU64,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool ;\n      }\n       struct_with_invariants!{\n          struct MyArc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyArc<S> {}\n     fn main() ;\n     }\n", " use verus_state_machines_macros::tokenized_state_machine;\n           use vstd::multiset::*;\n           use vstd::prelude::*;\n           verus! {\n         tokenized_state_machine!(RefCounter<Perm> {\n           fields {   \n#[sharding(variable)]\n        pub counter: nat,                   \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                   \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n           init!{              initialize_empty() {                 init counter = 0;                 init storage = Option::None;                 init reader = Multiset::empty();             }          }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n           transition!{              do_clone(x: Perm) {}          }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n           transition!{              dec_basic(x: Perm) {}          }\n           transition!{              dec_to_zero(x: Perm) {}          }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}\n       }\n        );\n       fn main() ;\n       }\n", " use verus_state_machines_macros::tokenized_state_machine;\n              use vstd::multiset::*;\n              use vstd::prelude::*;\n              verus! {\n            tokenized_state_machine!(RefCounter<Perm> {\n              fields {\n#[sharding(variable)]\n        pub counter: nat,                      \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                      \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n              init!{\n                initialize_empty() {\n                  init counter = 0;\n                  init storage = Option::None;\n                  init reader = Multiset::empty();\n              }\n            }\n          }\n           );\n          fn main() ;\n          }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(RefCounter<Perm> {\n                fields {\n#[sharding(variable)]\n        pub counter: nat,\n#[sharding(storage_option)]\n        pub storage: Option<Perm>,\n#[sharding(multiset)]\n        pub reader: Multiset<Perm>}\n                init!{\n                  initialize_empty() {\n                    init counter = 0;\n                    init storage = Option::None;\n                    init reader = Multiset::empty();\n}\n}\n}\n             );\n             fn main();\n             }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(a<b> {\n                fields {\n#[sharding(variable)]\n        pub c: nat,\n#[sharding(storage_option)]\n        pub d: Option<b>,\n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                init!{\n                  f() {\n                    init c = 0;\n                    init d = None;\n                    init e = Multiset::empty();\n}\n}\n}\n             );\n             fn main();\n             }\n", "use verus_state_machines_macros::tokenized_state_machine;\n     use vstd::prelude::*;\n     verus !{\n                  tokenized_state_machine!(a<b> {\n                   fields {\n#[sharding(variable)]\n        pub c: nat,     \n#[sharding(storage_option)]\n        pub d: Option<b>,     \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n   }\n                 );\n                 fn main();\n                 }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(variable)]\n    pub c : nat,\n#[sharding(storage_option)]\n    pub d : Option< b >,\n#[sharding(multiset)]\n    pub e : Multiset< b >\n  }});\n  fn main();\n}\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(storage_option)]\n    pub d : Option< b >,\n#[sharding(multiset)]\n    pub e : Multiset< b >\n  }});\n  fn main();\n}\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(storage_option)]\n    pub d : Option< b >,\n}});\n  fn main();\n}\n"]}
{"id": "conditional_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n#[verifier::spec]\npub enum Foo {\n    Bar(int),\n    Qax(int),\n    Duck(int),\n}\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub a: int,\n\n            #[sharding(variable)]\n            pub b: int,\n\n            #[sharding(variable)]\n            pub c: int,\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init a = 0;\n                init b = 1;\n                if cond {\n                    init c = 2;\n                } else if cond {\n                    init c = 3;\n                } else {\n                    init c = 4;\n                }\n            }\n        }\n\n        init!{\n            initialize2(foo: Foo) {\n                init a = 0;\n                init b = 1;\n                match foo {\n                    Foo::Bar(x) => {\n                        init c = 2;\n                    }\n                    Foo::Qax(y) => {\n                        init c = 3;\n                    }\n                    Foo::Duck(z) => {\n                        init c = 4;\n                    }\n                }\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                update a = 0;\n                if n >= 0 {\n                    update b = pre.b + n;\n                } else {\n                    update b = pre.b - n;\n                    update c = 15;\n                }\n            }\n        }\n\n        transition!{\n            add2(n: int) {\n                update a = 0;\n                if n >= 0 {\n                    update c = 15;\n                    update b = pre.b + n;\n                } else {\n                    update b = pre.b - n;\n                }\n            }\n        }\n\n        transition!{\n            foo(n: int) {\n                require(n >= 1);\n                assert(n >= 1);\n                let x: int = n + 2;\n                if n >= 5 {\n                    require(n < 10);\n                    assert(x != 4);\n                } else {\n                    update c = 12;\n                }\n                require(n != 1001);\n            }\n        }\n\n        #[inductive(foo)]\n        fn foo_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(add2)]\n        fn add2_inductive(pre: Self, post: Self, n: int) { }\n\n    }\n);\n\nfn main() {}\n", "minimized_code": "use verus_builtin::*;\n         use verus_state_machines_macros::tokenized_state_machine;\n       pub enum Foo {}\n         tokenized_state_machine!(     X {                fields {}            }\n         );\n         fn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/conditional.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1218, "minimize_time_ms": 186132, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 114, "minimized_LOC": 6, "self_contained": false, "dependencies": ["verus_builtin::", "vstd::", "verus_state_machines_macros::tokenized_state_machine"], "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.05263157894736842}, "labeling": {"segments": {"exec": " fn main() {"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n#[verifier::spec]\npub enum Foo {\n    Bar(int),\n    Qax(int),\n    Duck(int),\n}\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub a: int,\n\n            #[sharding(variable)]\n            pub b: int,\n\n            #[sharding(variable)]\n            pub c: int,\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init a = 0;\n                init b = 1;\n                if cond {\n                    init c = 2;\n                } else if cond {\n                    init c = 3;\n                } else {\n                    init c = 4;\n                }\n            }\n        }\n\n        init!{\n            initialize2(foo: Foo) {\n                init a = 0;\n                init b = 1;\n                match foo {\n                    Foo::Bar(x) => {\n                        init c = 2;\n                    }\n                    Foo::Qax(y) => {\n                        init c = 3;\n                    }\n                    Foo::Duck(z) => {\n                        init c = 4;\n                    }\n                }\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                update a = 0;\n                if n >= 0 {\n                    update b = pre.b + n;\n                } else {\n                    update b = pre.b - n;\n                    update c = 15;\n                }\n            }\n        }\n\n        transition!{\n            add2(n: int) {\n                update a = 0;\n                if n >= 0 {\n                    update c = 15;\n                    update b = pre.b + n;\n                } else {\n                    update b = pre.b - n;\n                }\n            }\n        }\n\n        transition!{\n            foo(n: int) {\n                require(n >= 1);\n                assert(n >= 1);\n                let x: int = n + 2;\n                if n >= 5 {\n                    require(n < 10);\n                    assert(x != 4);\n                } else {\n                    update c = 12;\n                }\n                require(n != 1001);\n            }\n        }\n\n        #[inductive(foo)]\n        fn foo_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(add2)]\n        fn add2_inductive(pre: Self, post: Self, n: int) { }\n\n    }\n);\n\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n         use verus_state_machines_macros::tokenized_state_machine;\n       pub enum Foo {}\n         tokenized_state_machine!(     X {                fields {}            }\n         );\n         fn main() {}\n", "use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(X{fields{}});\nfn main() {}\n", "use verus_builtin;\nuse verus_state_machines_macros;\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "counting_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine!{ CountingPermissions<T> {\n    fields {\n        #[sharding(storage_option)]\n        pub stored: Option<T>,\n\n        #[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,\n\n        #[sharding(multiset)]\n        pub read_ref: Multiset<T>,\n    }\n\n    init!{\n        new() {\n            init stored = None;\n            init main_counter = None;\n            init read_ref = Multiset::empty();\n        }\n    }\n\n    transition!{\n        writeable_to_readable(t: T) {\n            require pre.main_counter.is_none();\n            update main_counter = Some((0, t));\n            deposit stored += Some(t);\n        }\n    }\n\n    transition!{\n        readable_to_writeable() {\n            require let Some((count, t)) = pre.main_counter;\n            require count == 0;\n            update main_counter = None;\n            withdraw stored -= Some(t);\n        }\n    }\n\n    transition!{\n        new_ref() {\n            require let Some((count, t)) = pre.main_counter;\n            update main_counter = Some((count + 1, t));\n            add read_ref += { t };\n        }\n    }\n\n    transition!{\n        delete_ref(t1: T) {\n            remove read_ref -= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n            update main_counter = Some(((count - 1) as nat, t1));\n        }\n    }\n\n    property!{\n        compare_refs(t1: T, t2: T) {\n            have read_ref >= { t1 };\n            have read_ref >= { t2 };\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        compare_ref_and_counter(t1: T) {\n            have read_ref >= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        read_ref_guards(t: T) {\n            have read_ref >= { t };\n            guard stored >= Some(t);\n        }\n    }\n\n    property!{\n        counter_guards() {\n            require let Some((count, t)) = pre.main_counter;\n            guard stored >= Some(t);\n        }\n    }\n\n    #[invariant]\n    pub spec fn main_inv(&self) -> bool {\n        match self.stored {\n            None => {\n                &&& self.main_counter.is_none()\n                &&& self.read_ref =~= Multiset::empty()\n            }\n            Some(t) => {\n                match self.main_counter {\n                    Some((count, t1)) => {\n                        &&& t == t1\n                        &&& self.read_ref.count(t) == count\n                        &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)\n                    }\n                    None => false,\n                }\n            }\n        }\n    }\n\n    #[inductive(new)]\n    fn new_inductive(post: Self) { }\n   \n    #[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) { }\n   \n    #[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) { }\n   \n    #[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) { }\n   \n    #[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) { }\n}}\n\nverus!{\n\ntracked struct Instance<T> {\n    tracked instance: CountingPermissions::Instance<T>,\n}\n\ntracked struct MainCounter<T> {\n    tracked token: CountingPermissions::main_counter<T>,\n}\n\ntracked struct ReadRef<T> {\n    tracked token: CountingPermissions::read_ref<T>\n}\n\nimpl<T> MainCounter<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> Option<(nat, T)> {\n        self.token.value()\n    }\n}\n\nimpl<T> ReadRef<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> T {\n        self.token.element()\n    }\n}\n\nimpl<T> Instance<T> {\n    pub closed spec fn id(self) -> InstanceId {\n      self.instance.id()\n    }\n\n    proof fn new() -> (tracked res: (Instance<T>, MainCounter<T>))\n        ensures\n            res.1.instance_id() == res.0.id(),\n            res.1.value() === None\n    {\n        let tracked (Tracked(inst), Tracked(c), Tracked(_r)) =\n            CountingPermissions::Instance::new(None);\n        (Instance { instance: inst }, MainCounter { token: c })\n    }\n\n    proof fn writeable_to_readable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked t: T\n    )\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value() === None,\n        ensures\n            counter.instance_id() == self.id(),\n            counter.value() === Some((0, t)),\n    {\n        self.instance.writeable_to_readable(t, t, &mut counter.token);\n    }\n\n    proof fn readable_to_writeable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked t: T)\n        requires\n            old(counter).instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, _)) => count == 0,\n            }\n        ensures\n            counter.instance_id() == self.id(),\n            counter.value() === None,\n            t == old(counter).value().unwrap().1,\n    {\n        self.instance.readable_to_writeable(&mut counter.token)\n    }\n\n    proof fn new_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked read_ref: ReadRef<T>)\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value().is_some()\n        ensures\n            counter.instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, t)) =>\n                    counter.value() == Some((count + 1, t))\n                      && read_ref.value() == t\n            },\n    {\n        ReadRef { token: self.instance.new_ref(&mut counter.token) }\n    }\n\n    proof fn delete_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked read_ref: ReadRef<T>,\n    )\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value().is_some(),\n            read_ref.instance_id() == self.id(),\n        ensures\n            counter.instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, t)) =>\n                    count >= 1\n                      && counter.value() == Some(((count - 1) as nat, t))\n            },\n    {\n        self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)\n    }\n\n    proof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,\n    ) -> (tracked borrowed_t: &'a T)\n        requires\n            read_ref.instance_id() == self.id(),\n        ensures\n            borrowed_t == read_ref.value()\n    {\n        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)\n    }\n}\n\n}\n\nfn main() { }\n", "minimized_code": " use vstd::prelude::*;\n     use vstd::multiset::*;\n     use verus_state_machines_macros::tokenized_state_machine;\n     tokenized_state_machine!{\n    CountingPermissions<T> {\n       fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,             \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,             \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n       init!{\n          new() {\n             init stored = None;\n             init main_counter = None;\n             init read_ref = Multiset::empty();\n         }\n      }\n       transition!{\n          writeable_to_readable(t: T) {\n             require pre.main_counter.is_none();\n             update main_counter = Some((0, t));\n             deposit stored += Some(t);\n         }\n      }\n       transition!{\n          readable_to_writeable() {\n             require let Some((count, t)) = pre.main_counter;\n             require count == 0;\n             update main_counter = None;\n             withdraw stored -= Some(t);\n         }\n      }\n       transition!{\n          new_ref() {\n             require let Some((count, t)) = pre.main_counter;\n             update main_counter = Some((count + 1, t));\n             add read_ref += { t };\n         }\n      }\n       transition!{\n          delete_ref(t1: T) {\n             remove read_ref -= { t1 };\n             require let Some((count, t2)) = pre.main_counter;\n             assert count >= 1;\n             assert t1 == t2;\n             update main_counter = Some(((count - 1) as nat, t1));\n         }\n      }\n       property!{\n          read_ref_guards(t: T) {\n             have read_ref >= { t };\n             guard stored >= Some(t);\n         }\n      }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n          match self.stored {\n             None => {                 &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }\n             Some(t) => {                 match self.main_counter {                     Some((count, t1)) => {                         &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }                     None => false,                 }             }\n         }\n      }\n#[inductive(new)]\n    fn new_inductive(post: Self) {\n  }\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {\n  }\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n  }\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n  }\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {\n  }\n   }\n   }\n     verus!{\n    tracked struct Instance<T> {\n       tracked instance: CountingPermissions::Instance<T>, }\n    tracked struct MainCounter<T> {\n       tracked token: CountingPermissions::main_counter<T>, }\n    tracked struct ReadRef<T> {\n       tracked token: CountingPermissions::read_ref<T> }\n    impl<T> MainCounter<T> {\n       pub closed spec fn instance_id(self) -> InstanceId {\n          self.token.instance_id()     }\n       pub closed spec fn value(self) -> Option<(nat, T)> {\n          self.token.value()     }\n   }\n    impl<T> ReadRef<T> {\n       pub closed spec fn instance_id(self) -> InstanceId {\n          self.token.instance_id()     }\n       pub closed spec fn value(self) -> T {\n          self.token.element()     }\n   }\n    impl<T> Instance<T> {\n       pub closed spec fn id(self) -> InstanceId {\n        self.instance.id()     }\n       proof fn readable_to_writeable(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked t: T)         requires             old(counter).instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, _)) => count == 0,             }\n           ensures             counter.instance_id() == self.id(),             counter.value() === None,             t == old(counter).value().unwrap().1,     {\n          self.instance.readable_to_writeable(&mut counter.token)     }\n       proof fn new_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked read_ref: ReadRef<T>)         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some()         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, t)) =>                     counter.value() == Some((count + 1, t))                       && read_ref.value() == t             }\n  ,     {\n          ReadRef {\n token: self.instance.new_ref(&mut counter.token) }\n      }\n       proof fn delete_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,         tracked read_ref: ReadRef<T>,     )         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some(),             read_ref.instance_id() == self.id(),         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, t)) =>                     count >= 1                       && counter.value() == Some(((count - 1) as nat, t))             }\n  ,     {\n          self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)     }\n       proof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,     ) -> (tracked borrowed_t: &'a T)\n        requires\n            read_ref.instance_id() == self.id(),\n    {\n        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)\n    }\n}\n}\nfn main() { }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/counting.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1158, "minimize_time_ms": 1308465, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 267, "minimized_LOC": 127, "self_contained": false, "dependencies": ["verus_builtin::", "vstd::prelude::", "vstd::multiset::", "verus_state_machines_macros::tokenized_state_machine"], "complexity_verus_tokens": 19, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 0.4756554307116105}, "labeling": {"segments": {"exec": " fn new_inductive(post: Self) {\n\n fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {\n\n fn readable_to_writeable_inductive(pre: Self, post: Self) {\n\n fn new_ref_inductive(pre: Self, post: Self) {\n\n fn delete_ref_inductive(pre: Self, post: Self, t1: T) {\n\n\nfn main() {", "spec": "spec fn main_inv(&self) -> bool {\n\nspec fn instance_id(self) -> InstanceId {\n\nspec fn value(self) -> Option<(nat, T)> {\n\nspec fn instance_id(self) -> InstanceId {\n\nspec fn value(self) -> T {\n\nspec fn id(self) -> InstanceId {\n\n#[invariant]\n\n       proof fn readable_to_writeable(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked t: T)         requires             old(counter).instance_id() == self.id(),             match old(counter).value() {\n\n           ensures             counter.instance_id() == self.id(),             counter.value() === None,             t == old(counter).value().unwrap().1,     {\n\n       proof fn new_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked read_ref: ReadRef<T>)         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some()         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n\n       proof fn delete_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,         tracked read_ref: ReadRef<T>,     )         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some(),             read_ref.instance_id() == self.id(),         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n\n        requires", "proof": "proof fn readable_to_writeable(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked t: T)         requires             old(counter).instance_id() == self.id(),             match old(counter).value() {\n\nproof fn new_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked read_ref: ReadRef<T>)         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some()         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n\nproof fn delete_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,         tracked read_ref: ReadRef<T>,     )         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some(),             read_ref.instance_id() == self.id(),         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n\nproof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,     ) -> (tracked borrowed_t: &'a T)\n        requires\n            read_ref.instance_id() == self.id(),\n    {"}}}, "all_snapshots": ["#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine!{ CountingPermissions<T> {\n    fields {\n        #[sharding(storage_option)]\n        pub stored: Option<T>,\n\n        #[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,\n\n        #[sharding(multiset)]\n        pub read_ref: Multiset<T>,\n    }\n\n    init!{\n        new() {\n            init stored = None;\n            init main_counter = None;\n            init read_ref = Multiset::empty();\n        }\n    }\n\n    transition!{\n        writeable_to_readable(t: T) {\n            require pre.main_counter.is_none();\n            update main_counter = Some((0, t));\n            deposit stored += Some(t);\n        }\n    }\n\n    transition!{\n        readable_to_writeable() {\n            require let Some((count, t)) = pre.main_counter;\n            require count == 0;\n            update main_counter = None;\n            withdraw stored -= Some(t);\n        }\n    }\n\n    transition!{\n        new_ref() {\n            require let Some((count, t)) = pre.main_counter;\n            update main_counter = Some((count + 1, t));\n            add read_ref += { t };\n        }\n    }\n\n    transition!{\n        delete_ref(t1: T) {\n            remove read_ref -= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n            update main_counter = Some(((count - 1) as nat, t1));\n        }\n    }\n\n    property!{\n        compare_refs(t1: T, t2: T) {\n            have read_ref >= { t1 };\n            have read_ref >= { t2 };\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        compare_ref_and_counter(t1: T) {\n            have read_ref >= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        read_ref_guards(t: T) {\n            have read_ref >= { t };\n            guard stored >= Some(t);\n        }\n    }\n\n    property!{\n        counter_guards() {\n            require let Some((count, t)) = pre.main_counter;\n            guard stored >= Some(t);\n        }\n    }\n\n    #[invariant]\n    pub spec fn main_inv(&self) -> bool {\n        match self.stored {\n            None => {\n                &&& self.main_counter.is_none()\n                &&& self.read_ref =~= Multiset::empty()\n            }\n            Some(t) => {\n                match self.main_counter {\n                    Some((count, t1)) => {\n                        &&& t == t1\n                        &&& self.read_ref.count(t) == count\n                        &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)\n                    }\n                    None => false,\n                }\n            }\n        }\n    }\n\n    #[inductive(new)]\n    fn new_inductive(post: Self) { }\n   \n    #[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) { }\n   \n    #[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) { }\n   \n    #[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) { }\n   \n    #[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) { }\n}}\n\nverus!{\n\ntracked struct Instance<T> {\n    tracked instance: CountingPermissions::Instance<T>,\n}\n\ntracked struct MainCounter<T> {\n    tracked token: CountingPermissions::main_counter<T>,\n}\n\ntracked struct ReadRef<T> {\n    tracked token: CountingPermissions::read_ref<T>\n}\n\nimpl<T> MainCounter<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> Option<(nat, T)> {\n        self.token.value()\n    }\n}\n\nimpl<T> ReadRef<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> T {\n        self.token.element()\n    }\n}\n\nimpl<T> Instance<T> {\n    pub closed spec fn id(self) -> InstanceId {\n      self.instance.id()\n    }\n\n    proof fn new() -> (tracked res: (Instance<T>, MainCounter<T>))\n        ensures\n            res.1.instance_id() == res.0.id(),\n            res.1.value() === None\n    {\n        let tracked (Tracked(inst), Tracked(c), Tracked(_r)) =\n            CountingPermissions::Instance::new(None);\n        (Instance { instance: inst }, MainCounter { token: c })\n    }\n\n    proof fn writeable_to_readable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked t: T\n    )\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value() === None,\n        ensures\n            counter.instance_id() == self.id(),\n            counter.value() === Some((0, t)),\n    {\n        self.instance.writeable_to_readable(t, t, &mut counter.token);\n    }\n\n    proof fn readable_to_writeable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked t: T)\n        requires\n            old(counter).instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, _)) => count == 0,\n            }\n        ensures\n            counter.instance_id() == self.id(),\n            counter.value() === None,\n            t == old(counter).value().unwrap().1,\n    {\n        self.instance.readable_to_writeable(&mut counter.token)\n    }\n\n    proof fn new_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked read_ref: ReadRef<T>)\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value().is_some()\n        ensures\n            counter.instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, t)) =>\n                    counter.value() == Some((count + 1, t))\n                      && read_ref.value() == t\n            },\n    {\n        ReadRef { token: self.instance.new_ref(&mut counter.token) }\n    }\n\n    proof fn delete_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked read_ref: ReadRef<T>,\n    )\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value().is_some(),\n            read_ref.instance_id() == self.id(),\n        ensures\n            counter.instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, t)) =>\n                    count >= 1\n                      && counter.value() == Some(((count - 1) as nat, t))\n            },\n    {\n        self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)\n    }\n\n    proof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,\n    ) -> (tracked borrowed_t: &'a T)\n        requires\n            read_ref.instance_id() == self.id(),\n        ensures\n            borrowed_t == read_ref.value()\n    {\n        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)\n    }\n}\n\n}\n\nfn main() { }\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a<b> {\n    fields {\n#[sharding(storage_option)]\n      pub c : Option<b>\n    }\n  }\n}\nfn main() {}\n", " use vstd::prelude::*;\n     use vstd::multiset::*;\n     use verus_state_machines_macros::tokenized_state_machine;\n     tokenized_state_machine!{\n    CountingPermissions<T> {\n       fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,             \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,             \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n       init!{\n          new() {\n             init stored = None;\n             init main_counter = None;\n             init read_ref = Multiset::empty();\n         }\n      }\n       transition!{\n          writeable_to_readable(t: T) {\n             require pre.main_counter.is_none();\n             update main_counter = Some((0, t));\n             deposit stored += Some(t);\n         }\n      }\n       transition!{\n          readable_to_writeable() {\n             require let Some((count, t)) = pre.main_counter;\n             require count == 0;\n             update main_counter = None;\n             withdraw stored -= Some(t);\n         }\n      }\n       transition!{\n          new_ref() {\n             require let Some((count, t)) = pre.main_counter;\n             update main_counter = Some((count + 1, t));\n             add read_ref += { t };\n         }\n      }\n       transition!{\n          delete_ref(t1: T) {\n             remove read_ref -= { t1 };\n             require let Some((count, t2)) = pre.main_counter;\n             assert count >= 1;\n             assert t1 == t2;\n             update main_counter = Some(((count - 1) as nat, t1));\n         }\n      }\n       property!{\n          read_ref_guards(t: T) {\n             have read_ref >= { t };\n             guard stored >= Some(t);\n         }\n      }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n          match self.stored {\n             None => {                 &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }\n             Some(t) => {                 match self.main_counter {                     Some((count, t1)) => {                         &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }                     None => false,                 }             }\n         }\n      }\n#[inductive(new)]\n    fn new_inductive(post: Self) {\n  }\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {\n  }\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n  }\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n  }\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {\n  }\n   }\n   }\n     verus!{\n    tracked struct Instance<T> {\n       tracked instance: CountingPermissions::Instance<T>, }\n    tracked struct MainCounter<T> {\n       tracked token: CountingPermissions::main_counter<T>, }\n    tracked struct ReadRef<T> {\n       tracked token: CountingPermissions::read_ref<T> }\n    impl<T> MainCounter<T> {\n       pub closed spec fn instance_id(self) -> InstanceId {\n          self.token.instance_id()     }\n       pub closed spec fn value(self) -> Option<(nat, T)> {\n          self.token.value()     }\n   }\n    impl<T> ReadRef<T> {\n       pub closed spec fn instance_id(self) -> InstanceId {\n          self.token.instance_id()     }\n       pub closed spec fn value(self) -> T {\n          self.token.element()     }\n   }\n    impl<T> Instance<T> {\n       pub closed spec fn id(self) -> InstanceId {\n        self.instance.id()     }\n       proof fn readable_to_writeable(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked t: T)         requires             old(counter).instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, _)) => count == 0,             }\n           ensures             counter.instance_id() == self.id(),             counter.value() === None,             t == old(counter).value().unwrap().1,     {\n          self.instance.readable_to_writeable(&mut counter.token)     }\n       proof fn new_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked read_ref: ReadRef<T>)         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some()         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, t)) =>                     counter.value() == Some((count + 1, t))                       && read_ref.value() == t             }\n  ,     {\n          ReadRef {\n token: self.instance.new_ref(&mut counter.token) }\n      }\n       proof fn delete_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,         tracked read_ref: ReadRef<T>,     )         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some(),             read_ref.instance_id() == self.id(),         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, t)) =>                     count >= 1                       && counter.value() == Some(((count - 1) as nat, t))             }\n  ,     {\n          self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)     }\n       proof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,     ) -> (tracked borrowed_t: &'a T)\n        requires\n            read_ref.instance_id() == self.id(),\n    {\n        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)\n    }\n}\n}\nfn main() { }\n", " use vstd::prelude::*;\n        use vstd::multiset::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n        tokenized_state_machine!{\n       CountingPermissions<T> {\n          fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,                \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,                \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n          init!{\n             new() {\n                init stored = None;\n                init main_counter = None;\n                init read_ref = Multiset::empty();\n            }\n         }\n          transition!{\n             writeable_to_readable(t: T) {}\n         }\n          transition!{\n             readable_to_writeable() {\n                require let Some((count, t)) = pre.main_counter;\n                require count == 0;\n                update main_counter = None;\n                withdraw stored -= Some(t);\n            }\n         }\n          transition!{\n             new_ref() {\n                require let Some((count, t)) = pre.main_counter;\n                update main_counter = Some((count + 1, t));\n                add read_ref += {\n   t };\n            }\n         }\n          transition!{\n             delete_ref(t1: T) {\n                remove read_ref -= {\n   t1 };\n                require let Some((count, t2)) = pre.main_counter;\n                assert count >= 1;\n                assert t1 == t2;\n                update main_counter = Some(((count - 1) as nat, t1));\n            }\n         }\n          property!{\n             read_ref_guards(t: T) {\n                have read_ref >= {\n   t };\n                guard stored >= Some(t);\n            }\n         }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n             match self.stored {\n                None => {\n                   &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }\n                Some(t) => \n                   match self.main_counter {\n                       Some((count, t1)) => {\n                          &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }\n                       None => false,                 }\n               \n            }\n         }\n#[inductive(new)]\n    fn new_inductive(post: Self) {}\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {}\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {}\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {}\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {}\n      }\n      }\n        verus!{}\nfn main() {}\n", " use vstd::prelude::*;\n            use vstd::multiset::*;\n            use verus_state_machines_macros::tokenized_state_machine;\n            tokenized_state_machine!{\n          CountingPermissions<T> {\n            fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,                    \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,                    \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n            init!{\n              new() {                 init stored = None;                 init main_counter = None;                 init read_ref = Multiset::empty();             }\n          }\n            transition!{\n              writeable_to_readable(t: T) {}\n          }\n            transition!{\n              readable_to_writeable() {                 require let Some((count, t)) = pre.main_counter;                 require count == 0;                 update main_counter = None;                 withdraw stored -= Some(t);             }\n          }\n            transition!{\n              new_ref() {                 require let Some((count, t)) = pre.main_counter;                 update main_counter = Some((count + 1, t));                 add read_ref += {    t };             }\n          }\n            transition!{\n              delete_ref(t1: T) {                 remove read_ref -= {    t1 };                 require let Some((count, t2)) = pre.main_counter;                 assert count >= 1;                 assert t1 == t2;                 update main_counter = Some(((count - 1) as nat, t1));             }\n          }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n              match self.stored {                 None => {                    &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }                 Some(t) =>                     match self.main_counter {                        Some((count, t1)) => {                           &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }                        None => false,                 }                             }\n          }\n#[inductive(new)]\n    fn new_inductive(post: Self) {\n}\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {\n}\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n}\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n}\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {\n}\n        }\n         }\n    fn main() {\n  }\n", " use vstd::prelude::*;\n              use vstd::multiset::*;\n              use verus_state_machines_macros::tokenized_state_machine;\n              tokenized_state_machine!{\n            CountingPermissions<T> {\n              fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,                      \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,                      \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n              init!{\n                new() {\n                  init stored = None;\n                  init main_counter = None;\n                  init read_ref = Multiset::empty();\n              }\n            }\n              transition!{\n                writeable_to_readable(t: T) {\n }\n            }\n              transition!{\n                readable_to_writeable() {\n              }\n            }\n              transition!{\n                new_ref() {\n              }\n            }\n              transition!{\n                delete_ref(t1: T) {\n              }\n            }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n                match self.stored {\n                  None => {\n                    &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }\n                  Some(t) =>                     match self.main_counter {\n                        Some((count, t1)) => {\n                           &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }\n                        None => false,                 }\n                              }\n            }\n#[inductive(new)]\n    fn new_inductive(post: Self) {\n  }\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {\n  }\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n  }\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n  }\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {\n  }\n          }\n           }\n      fn main() {\n    }\n", " use vstd::prelude::*;\n                use vstd::multiset::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                tokenized_state_machine!{\n              a<b> {\n                fields {\n#[sharding(storage_option)]\n        pub c: Option<b>,                        \n#[sharding(variable)]\n        pub d: Option<(nat, b)>,                        \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                init!{\n                  f() {\n                    init c = None;\n                    init d = None;\n                    init e = Multiset::empty();\n                }\n              }\n                transition!{\n                  g(h: b) {\n   }\n              }\n                transition!{\n                  i() {\n                }\n              }\n                transition!{\n                  new_ref() {\n                }\n              }\n                transition!{\n                  j(k: b) {\n                }\n              }\n#[invariant]\n    pub fn main_inv(self) -> bool {\n                  match self.c {\n                    None => {\n                      self.e =~= Multiset::empty()             }\n                    h =>                     match self.d {\n                          Some( k) => {\n                             forall |t0| self.e.count(t0) == 0                     }\n                          None => false}\n                                }\n              }\n#[inductive(f)]\n    fn new_inductive(post: Self) {\n    }\n#[inductive(g)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, h: b) {\n    }\n#[inductive(i)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n    }\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n    }\n#[inductive(j)]\n    fn delete_ref_inductive(pre: Self, post: Self, k: b) {\n    }\n            }\n             }\n        fn main() {\n      }\n", " use vstd::prelude::*;\n                use vstd::multiset::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                tokenized_state_machine!{\n              a<b> {\n                fields {\n#[sharding(storage_option)]\n        pub c: Option<b>,                        \n#[sharding(variable)]\n        pub d: Option<()>,                        \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                init!{\n                  f() {\n                    init c = None;\n                    init d = None;\n                    init e = Multiset::empty();\n                }\n              }\n                transition!{\n                  g(h: b) {}\n              }\n                transition!{\n                  i() {}\n              }\n                transition!{\n                  new_ref() {}\n              }\n                transition!{\n                  j(k: b) {}\n              }\n#[invariant]\n    pub fn l(self) -> bool {\n                  match self.c {\n                    None => {\n                      self.e =~= Multiset::empty()             }\n                    h =>                     match self.d {\n                          Some( k) => {\n                             forall |m| self.e.count(m) == 0                     }\n                          None => false}\n                                }\n              }\n#[inductive(f)]\n    fn new_inductive(post: Self) {}\n#[inductive(g)]\n    fn n(pre: Self, post: Self, h: b) {}\n#[inductive(i)]\n    fn o(pre: Self, post: Self) {}\n#[inductive(new_ref)]\n    fn p(pre: Self, post: Self) {}\n#[inductive(j)]\n    fn delete_ref_inductive(pre: Self, post: Self, k: b) {}\n            }\n             }\n        fn main() {}\n", " use vstd::prelude::*;\n                   use vstd::multiset::*;\n                   use verus_state_machines_macros::tokenized_state_machine;\n                   tokenized_state_machine!{\n                a<b> {\n                 fields {   \n#[sharding(storage_option)]\n        pub c: Option<b>,                           \n#[sharding(variable)]\n        pub d: Option<()>,                           \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                 init!{                   f() {                     init c = None;                     init d = None;                     init e = Multiset::empty();                 }               }\n                 transition!{                   g(h: b) {}               }\n                 transition!{                   i() {}               }\n                 transition!{                   new_ref() {}               }\n                 transition!{                   j(k: b) {}               }\n       fn delete_ref_inductive(pre: Self, post: Self, k: b) {}\n             }\n               }\n           fn main() {\n }\n", "use vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a< b > {\n    fields {\n#[sharding(storage_option)]\n      pub c : Option< b >,\n#[sharding(variable)]\n              pub e : Multiset< b >\n    }\n  }\n}\nfn main() {}\n", "use vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a< b > {\n    fields {\n#[sharding(storage_option)]\n      pub c : Option< b >,\n}\n  }\n}\nfn main() {}\n"]}
{"id": "disk_example_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs ignore --- old experimental example\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::option::*;\nuse vstd::pervasive::*;\n\nverus! {\n\n// Create the \"authoritative-fragmentary\" API for manipulating heap-like things\n// (In this case, a disk.)\ntokenized_state_machine!{ AuthFrag<#[verifier::reject_recursive_types] K, V> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Map<K, V>,\n\n        #[sharding(map)]\n        pub fragments: Map<K, V>,\n    }\n\n    #[invariant]\n    pub fn the_inv(&self) -> bool {\n        self.fragments === self.auth\n    }\n\n    init!{\n        initialize(m: Map<K, V>) {\n            init auth = m;\n            init fragments = m;\n        }\n    }\n\n    transition!{\n        update_key(key: K, new_value: V) {\n            update auth = pre.auth.insert(key, new_value);\n\n            remove fragments -= [ key => let _ ];\n            add fragments += [ key => new_value ];\n        }\n    }\n\n    property!{\n        values_agree(key: K) {\n            have fragments >= [ key => let frag_value ];\n            assert(pre.auth.dom().contains(key)\n                && frag_value === pre.auth.index(key));\n        }\n    }\n\n\n    #[inductive(initialize)]\n    fn init_inductive(post: Self, m: Map<K, V>) { }\n\n    #[inductive(update_key)]\n    fn update_key_inductive(pre: Self, post: Self, key: K, new_value: V) {\n        assert_maps_equal!(post.fragments, post.auth);\n    }\n}}\n// We want to show refinement between 2 systems.\n// First system: a disk represented by a map from indices to blocks\n\n\n#[is_variant]\npub enum Block {\n    Leaf(u64),\n    Node(nat, nat),\n}\n\nstate_machine!{ DiskSM {\n    fields {\n        pub disk: Map<nat, Block>,      // root is 0\n    }\n\n    // update one of the children of the root\n\n    transition!{\n        update_child(left: bool, new_val: u64) {\n            // Require that the root block is a node with 2 children.\n\n            require(pre.disk.dom().contains(0));\n            require let Block::Node(left_child, right_child) = pre.disk.index(0);\n\n            // Get the address of the left or right child.\n            let child = if left { left_child } else { right_child };\n\n            // Require the child to be a leaf.\n            require(pre.disk.dom().contains(child));\n            require let Block::Leaf(val) = pre.disk.index(child);\n\n            // Update the value at the leaf to a new value.\n            update disk[child] = Block::Leaf(new_val);\n        }\n    }\n}}\n// state machine 2: tree\n\n\n#[is_variant]\npub enum Tree {\n    Leaf(u64),\n    Node(Box<Tree>, Box<Tree>),\n}\n\nstate_machine!{ TreeSM {\n    fields {\n        pub tree: Tree,\n    }\n\n    // update one of the children of the root\n\n    transition!{\n        update_child(left: bool, new_val: u64) {\n            require let Tree::Node(left_child, right_child) = pre.tree;\n            if left {\n                require let Tree::Leaf(old_val_l) = *left_child;\n                update tree = Tree::Node(Box::new(Tree::Leaf(new_val), right_child));\n            } else {\n                require let Tree::Leaf(old_val_r) = *right_child;\n                update tree = Tree::Node(left_child, Box::new(Tree::Leaf(new_val)));\n            }\n        }\n    }\n}}\n// We create the relationship with some intermediary ghost state:\n//\n// DiskSM::State   -->   DiskInterp   -->   LinearTree   -->   TreeSM::State\n//   (spec)                (tracked)          (tracked)           (spec)\n// We will devise an explicit function DiskSM::State -> DiskInterp\n// and an explicit relation LinearTree -> TreeSM::State\n//\n// However, the relationship between DiskInterp and LinearTree will be implicit\n// via ghost rules.\n// First define an \"interpretation\" of the disk state as a linear (tracked) object DiskInterp\n// This object uses the \"auth\" token\n\n\ntype DiskInterp = AuthFrag::auth<nat, Block>;\n\nspec fn state_interp_fn(inst: AuthFrag::Instance<nat, Block>, state: DiskSM::State) -> DiskInterp {\n    AuthFrag![ inst => auth => state.disk ]\n}\n\n// Define the LinearTree type\n// This object uses the \"fragment\" tokens. This forces it to be related to the Disk.\npub enum LinearTree {\n    Leaf(tracked AuthFrag::fragments<nat, Block>),\n    Node(tracked AuthFrag::fragments<nat, Block>, Box<LinearTree>, Box<LinearTree>),\n}\n\n// Define the relation between LinearTree and TreeSM::State\nspec fn tree_relation_rec(\n    inst: AuthFrag::Instance<nat, Block>,\n    lt: LinearTree,\n    tree: Tree,\n    addr: nat,\n) -> bool\n    decreases lt,\n{\n    match lt {\n        LinearTree::Leaf(frag) => {\n            match tree {\n                Tree::Leaf(val) => {\n                    frag === AuthFrag![ inst => fragments => addr => Block::Leaf(val) ]\n                },\n                Tree::Node(_, _) => false,\n            }\n        },\n        LinearTree::Node(frag, lt_left, lt_right) => {\n            match tree {\n                Tree::Leaf(val) => false,\n                Tree::Node(tree_left, tree_right) => {\n                    &&& frag.instance === inst\n                    &&& frag.key === addr\n                    &&& frag.value.is_Node()\n                    &&& tree_relation_rec(inst, *lt_left, *tree_left, frag.value.get_Node_0())\n                    &&& tree_relation_rec(inst, *lt_right, *tree_right, frag.value.get_Node_1())\n                },\n            }\n        },\n    }\n}\n\nspec fn tree_relation(\n    inst: AuthFrag::Instance<nat, Block>,\n    lt: LinearTree,\n    tree: TreeSM::State,\n) -> bool {\n    tree_relation_rec(inst, lt, tree.tree, 0)  // root is at 0\n\n}\n\n} // verus!\n// refinement proof\n// TODO this should return proof, but having trouble with mode-checking\n#[verifier::proof]\nfn take_step(\n    state1: DiskSM::State,\n    state2: DiskSM::State,\n    is_left: bool,\n    new_val: u64,\n    #[verifier::proof] inst: AuthFrag::Instance<nat, Block>,\n    #[verifier::proof] interp1: AuthFrag::auth<nat, Block>,\n    #[verifier::proof] lt1: LinearTree,\n    tree1_state: TreeSM::State,\n) -> (Tracked<AuthFrag::auth<nat, Block>>, Tracked<LinearTree>, Gho<TreeSM::State>) {\n    requires([\n        DiskSM::State::update_child(state1, state2, is_left, new_val),\n        equal(interp1, state_interp_fn(inst, state1)),\n        tree_relation(inst, lt1, tree1_state),\n    ]);\n    ensures(\n        |ret: (Tracked<AuthFrag::auth<nat, Block>>, Tracked<LinearTree>, Gho<TreeSM::State>)| {\n            let (Tracked(interp2), Tracked(lt2), Gho(tree2)) = ret;\n            equal(interp2, state_interp_fn(inst, state2))\n                && TreeSM::State::update_child(tree1_state, tree2, is_left, new_val)\n                && tree_relation(inst, lt2, tree2)\n        },\n    );\n    #[verifier::proof]\n    let mut interp = interp1;\n\n    let tree1 = tree1_state.tree;\n\n    match lt1 {\n        LinearTree::Node(lt_root_fragment, lt_left, lt_right) => {\n            inst.values_agree(0, &interp, &lt_root_fragment);\n\n            if is_left {\n                let left_address = lt_root_fragment.value.get_Node_0();\n                assert(tree_relation_rec(inst, *lt_left, *tree1.get_Node_0(), left_address));\n\n                match *lt_left {\n                    LinearTree::Leaf(lt_leaf_fragment) => {\n                        inst.values_agree(left_address, &interp, &lt_leaf_fragment);\n\n                        let lt_leaf_fragment_new = inst.update_key(\n                            lt_leaf_fragment.key,\n                            Block::Leaf(new_val),\n                            &mut interp,\n                            lt_leaf_fragment,\n                        );\n                        let lt2 = LinearTree::Node(\n                            lt_root_fragment,\n                            Box::new(LinearTree::Leaf(lt_leaf_fragment_new)),\n                            lt_right,\n                        );\n                        let interp2 = interp;\n                        let tree2 = TreeSM::State {\n                            tree: Tree::Node(Box::new(Tree::Leaf(new_val)), tree1.get_Node_1()),\n                        };\n\n                        assert(equal(interp2, state_interp_fn(inst, state2)));\n                        assert(TreeSM::State::update_child(tree1_state, tree2, is_left, new_val));\n\n                        assert(tree_relation_rec(\n                            inst,\n                            LinearTree::Leaf(lt_leaf_fragment_new),\n                            Tree::Leaf(new_val),\n                            left_address,\n                        ));\n                        assert(tree_relation_rec(inst, lt2, tree2.tree, 0));\n\n                        assert(tree_relation(inst, lt2, tree2));\n\n                        (Tracked(interp2), Tracked(lt2), Gho(tree2))\n                    }\n                    LinearTree::Node(lt_node_fragment, _, _) => {\n                        inst.values_agree(left_address, &interp, &lt_node_fragment);\n\n                        // by assumption, the node should be a leaf\n                        proof_from_false()\n                    }\n                }\n            } else {\n                // This case should be symmetric to above\n                assume(false);\n                proof_from_false()\n            }\n        }\n        LinearTree::Leaf(lt_root_fragment) => {\n            inst.values_agree(0, &interp, &lt_root_fragment);\n\n            // by assumption, root node should be a Node\n            proof_from_false()\n        }\n    }\n}\n\nfn main() {}\n", "minimized_code": "// rust_verify/tests/example.rs ignore --- old experimental example\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::option::*;\nuse vstd::pervasive::*;\n\nverus! {\n\n// Create the \"authoritative-fragmentary\" API for manipulating heap-like things\n// (In this case, a disk.)\ntokenized_state_machine!{ AuthFrag<#[verifier::reject_recursive_types] K, V> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Map<K, V>,\n\n        #[sharding(map)]\n        pub fragments: Map<K, V>,\n    }\n\n    #[invariant]\n    pub fn the_inv(&self) -> bool {\n        self.fragments === self.auth\n    }\n\n    init!{\n        initialize(m: Map<K, V>) {\n            init auth = m;\n            init fragments = m;\n        }\n    }\n\n    transition!{\n        update_key(key: K, new_value: V) {\n            update auth = pre.auth.insert(key, new_value);\n\n            remove fragments -= [ key => let _ ];\n            add fragments += [ key => new_value ];\n        }\n    }\n\n    property!{\n        values_agree(key: K) {\n            have fragments >= [ key => let frag_value ];\n            assert(pre.auth.dom().contains(key)\n                && frag_value === pre.auth.index(key));\n        }\n    }\n\n\n    #[inductive(initialize)]\n    fn init_inductive(post: Self, m: Map<K, V>) { }\n\n    #[inductive(update_key)]\n    fn update_key_inductive(pre: Self, post: Self, key: K, new_value: V) {\n        assert_maps_equal!(post.fragments, post.auth);\n    }\n}}\n// We want to show refinement between 2 systems.\n// First system: a disk represented by a map from indices to blocks\n\n\n#[is_variant]\npub enum Block {\n    Leaf(u64),\n    Node(nat, nat),\n}\n\nstate_machine!{ DiskSM {\n    fields {\n        pub disk: Map<nat, Block>,      // root is 0\n    }\n\n    // update one of the children of the root\n\n    transition!{\n        update_child(left: bool, new_val: u64) {\n            // Require that the root block is a node with 2 children.\n\n            require(pre.disk.dom().contains(0));\n            require let Block::Node(left_child, right_child) = pre.disk.index(0);\n\n            // Get the address of the left or right child.\n            let child = if left { left_child } else { right_child };\n\n            // Require the child to be a leaf.\n            require(pre.disk.dom().contains(child));\n            require let Block::Leaf(val) = pre.disk.index(child);\n\n            // Update the value at the leaf to a new value.\n            update disk[child] = Block::Leaf(new_val);\n        }\n    }\n}}\n// state machine 2: tree\n\n\n#[is_variant]\npub enum Tree {\n    Leaf(u64),\n    Node(Box<Tree>, Box<Tree>),\n}\n\nstate_machine!{ TreeSM {\n    fields {\n        pub tree: Tree,\n    }\n\n    // update one of the children of the root\n\n    transition!{\n        update_child(left: bool, new_val: u64) {\n            require let Tree::Node(left_child, right_child) = pre.tree;\n            if left {\n                require let Tree::Leaf(old_val_l) = *left_child;\n                update tree = Tree::Node(Box::new(Tree::Leaf(new_val), right_child));\n            } else {\n                require let Tree::Leaf(old_val_r) = *right_child;\n                update tree = Tree::Node(left_child, Box::new(Tree::Leaf(new_val)));\n            }\n        }\n    }\n}}\n// We create the relationship with some intermediary ghost state:\n//\n// DiskSM::State   -->   DiskInterp   -->   LinearTree   -->   TreeSM::State\n//   (spec)                (tracked)          (tracked)           (spec)\n// We will devise an explicit function DiskSM::State -> DiskInterp\n// and an explicit relation LinearTree -> TreeSM::State\n//\n// However, the relationship between DiskInterp and LinearTree will be implicit\n// via ghost rules.\n// First define an \"interpretation\" of the disk state as a linear (tracked) object DiskInterp\n// This object uses the \"auth\" token\n\n\ntype DiskInterp = AuthFrag::auth<nat, Block>;\n\nspec fn state_interp_fn(inst: AuthFrag::Instance<nat, Block>, state: DiskSM::State) -> DiskInterp {\n    AuthFrag![ inst => auth => state.disk ]\n}\n\n// Define the LinearTree type\n// This object uses the \"fragment\" tokens. This forces it to be related to the Disk.\npub enum LinearTree {\n    Leaf(tracked AuthFrag::fragments<nat, Block>),\n    Node(tracked AuthFrag::fragments<nat, Block>, Box<LinearTree>, Box<LinearTree>),\n}\n\n// Define the relation between LinearTree and TreeSM::State\nspec fn tree_relation_rec(\n    inst: AuthFrag::Instance<nat, Block>,\n    lt: LinearTree,\n    tree: Tree,\n    addr: nat,\n) -> bool\n    decreases lt,\n{\n    match lt {\n        LinearTree::Leaf(frag) => {\n            match tree {\n                Tree::Leaf(val) => {\n                    frag === AuthFrag![ inst => fragments => addr => Block::Leaf(val) ]\n                },\n                Tree::Node(_, _) => false,\n            }\n        },\n        LinearTree::Node(frag, lt_left, lt_right) => {\n            match tree {\n                Tree::Leaf(val) => false,\n                Tree::Node(tree_left, tree_right) => {\n                    &&& frag.instance === inst\n                    &&& frag.key === addr\n                    &&& frag.value.is_Node()\n                    &&& tree_relation_rec(inst, *lt_left, *tree_left, frag.value.get_Node_0())\n                    &&& tree_relation_rec(inst, *lt_right, *tree_right, frag.value.get_Node_1())\n                },\n            }\n        },\n    }\n}\n\nspec fn tree_relation(\n    inst: AuthFrag::Instance<nat, Block>,\n    lt: LinearTree,\n    tree: TreeSM::State,\n) -> bool {\n    tree_relation_rec(inst, lt, tree.tree, 0)  // root is at 0\n\n}\n\n} // verus!\n// refinement proof\n// TODO this should return proof, but having trouble with mode-checking\n#[verifier::proof]\nfn take_step(\n    state1: DiskSM::State,\n    state2: DiskSM::State,\n    is_left: bool,\n    new_val: u64,\n    #[verifier::proof] inst: AuthFrag::Instance<nat, Block>,\n    #[verifier::proof] interp1: AuthFrag::auth<nat, Block>,\n    #[verifier::proof] lt1: LinearTree,\n    tree1_state: TreeSM::State,\n) -> (Tracked<AuthFrag::auth<nat, Block>>, Tracked<LinearTree>, Gho<TreeSM::State>) {\n    requires([\n        DiskSM::State::update_child(state1, state2, is_left, new_val),\n        equal(interp1, state_interp_fn(inst, state1)),\n        tree_relation(inst, lt1, tree1_state),\n    ]);\n    ensures(\n        |ret: (Tracked<AuthFrag::auth<nat, Block>>, Tracked<LinearTree>, Gho<TreeSM::State>)| {\n            let (Tracked(interp2), Tracked(lt2), Gho(tree2)) = ret;\n            equal(interp2, state_interp_fn(inst, state2))\n                && TreeSM::State::update_child(tree1_state, tree2, is_left, new_val)\n                && tree_relation(inst, lt2, tree2)\n        },\n    );\n    #[verifier::proof]\n    let mut interp = interp1;\n\n    let tree1 = tree1_state.tree;\n\n    match lt1 {\n        LinearTree::Node(lt_root_fragment, lt_left, lt_right) => {\n            inst.values_agree(0, &interp, &lt_root_fragment);\n\n            if is_left {\n                let left_address = lt_root_fragment.value.get_Node_0();\n                assert(tree_relation_rec(inst, *lt_left, *tree1.get_Node_0(), left_address));\n\n                match *lt_left {\n                    LinearTree::Leaf(lt_leaf_fragment) => {\n                        inst.values_agree(left_address, &interp, &lt_leaf_fragment);\n\n                        let lt_leaf_fragment_new = inst.update_key(\n                            lt_leaf_fragment.key,\n                            Block::Leaf(new_val),\n                            &mut interp,\n                            lt_leaf_fragment,\n                        );\n                        let lt2 = LinearTree::Node(\n                            lt_root_fragment,\n                            Box::new(LinearTree::Leaf(lt_leaf_fragment_new)),\n                            lt_right,\n                        );\n                        let interp2 = interp;\n                        let tree2 = TreeSM::State {\n                            tree: Tree::Node(Box::new(Tree::Leaf(new_val)), tree1.get_Node_1()),\n                        };\n\n                        assert(equal(interp2, state_interp_fn(inst, state2)));\n                        assert(TreeSM::State::update_child(tree1_state, tree2, is_left, new_val));\n\n                        assert(tree_relation_rec(\n                            inst,\n                            LinearTree::Leaf(lt_leaf_fragment_new),\n                            Tree::Leaf(new_val),\n                            left_address,\n                        ));\n                        assert(tree_relation_rec(inst, lt2, tree2.tree, 0));\n\n                        assert(tree_relation(inst, lt2, tree2));\n\n                        (Tracked(interp2), Tracked(lt2), Gho(tree2))\n                    }\n                    LinearTree::Node(lt_node_fragment, _, _) => {\n                        inst.values_agree(left_address, &interp, &lt_node_fragment);\n\n                        // by assumption, the node should be a leaf\n                        proof_from_false()\n                    }\n                }\n            } else {\n                // This case should be symmetric to above\n                assume(false);\n                proof_from_false()\n            }\n        }\n        LinearTree::Leaf(lt_root_fragment) => {\n            inst.values_agree(0, &interp, &lt_root_fragment);\n\n            // by assumption, root node should be a Node\n            proof_from_false()\n        }\n    }\n}\n\nfn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/disk_example.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 483, "verus_errors": [{"error_type": "Other", "error_text": "unresolved import `vstd::option` (could not find `option` in `vstd`)", "message": "VerusErrorType.Other: unresolved import `vstd::option` (could not find `option` in `vstd`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpoor3_pwb", "lines": [10, 10], "label": "could not find `option` in `vstd`", "text": [{"text": "use vstd::option::*;", "highlight_start": 11, "highlight_end": 17}]}]}, {"error_type": "Other", "error_text": "cannot find macro `AuthFrag` in this scope ()", "message": "VerusErrorType.Other: cannot find macro `AuthFrag` in this scope ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpoor3_pwb", "lines": [168, 168], "label": null, "text": [{"text": "                    frag === AuthFrag![ inst => fragments => addr => Block::Leaf(val) ]", "highlight_start": 30, "highlight_end": 38}]}]}, {"error_type": "Other", "error_text": "cannot find macro `AuthFrag` in this scope ()", "message": "VerusErrorType.Other: cannot find macro `AuthFrag` in this scope ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpoor3_pwb", "lines": [145, 145], "label": null, "text": [{"text": "    AuthFrag![ inst => auth => state.disk ]", "highlight_start": 5, "highlight_end": 13}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 294, "minimized_LOC": 294, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "verus_state_machines_macros::", "vstd::map::", "vstd::modes::", "vstd::multiset::", "vstd::option::", "vstd::pervasive::"], "complexity_verus_tokens": 23, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"requires_count": 1, "ensures_count": 1, "segments": {"exec": " pub fn the_inv(&self) -> bool {\n\n fn init_inductive(post: Self, m: Map<K, V>) {\n\n fn update_key_inductive(pre: Self, post: Self, key: K, new_value: V) {", "spec": "spec fn state_interp_fn(inst: AuthFrag::Instance<nat, Block>, state: DiskSM::State) -> DiskInterp {\n\nspec fn tree_relation_rec(\n    inst: AuthFrag::Instance<nat, Block>,\n    lt: LinearTree,\n    tree: Tree,\n    addr: nat,\n) -> bool\n    decreases lt,\n{\n\nspec fn tree_relation(\n    inst: AuthFrag::Instance<nat, Block>,\n    lt: LinearTree,\n    tree: TreeSM::State,\n) -> bool {\n\n    #[invariant]\n\n    decreases lt,\n\n    requires([\n\n    ensures("}}}, "all_snapshots": []}
{"id": "dist_rwlock_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::map::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\nverus! {\n\ntokenized_state_machine!{\n    DistRwLock<T> {\n        fields {\n            #[sharding(constant)]\n            pub rc_width: int,\n\n            #[sharding(storage_option)]\n            pub storage: Option<T>,\n\n            #[sharding(variable)]\n            pub exc_locked: bool,\n\n            #[sharding(map)]\n            pub ref_counts: Map<int, int>,\n\n            #[sharding(option)]\n            pub exc_pending: Option<int>,\n\n            #[sharding(option)]\n            pub exc_guard: Option<()>,\n\n            #[sharding(multiset)]\n            pub shared_pending: Multiset<int>,\n\n            #[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,\n        }\n\n        init!{\n            initialize(rc_width: int, init_t: T) {\n                require(0 < rc_width);\n                init rc_width = rc_width;\n                init storage = Option::Some(init_t);\n                init exc_locked = false;\n                init ref_counts = Map::new(\n                    |i| 0 <= i < rc_width,\n                    |i| 0,\n                );\n                init exc_pending = Option::None;\n                init exc_guard = Option::None;\n                init shared_pending = Multiset::empty();\n                init shared_guard = Multiset::empty();\n            }\n        }\n\n        transition!{\n            exc_start() {\n                require(!pre.exc_locked);\n                update exc_locked = true;\n                add exc_pending += Some(0);\n            }\n        }\n\n        transition!{\n            exc_check_count() {\n                remove exc_pending -= Some(let r);\n                have ref_counts >= [r => 0];\n\n                add exc_pending += Some(r + 1);\n            }\n        }\n\n        transition!{\n            exc_finish() {\n                remove exc_pending -= Some(pre.rc_width);\n                add exc_guard += Some(());\n                withdraw storage -= Some(let _);\n            }\n        }\n\n        transition!{\n            exc_release(t: T) {\n                update exc_locked = false;\n                remove exc_guard -= Some(());\n                deposit storage += Some(t);\n            }\n        }\n\n        transition!{\n            shared_start(r: int) {\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc + 1];\n                add shared_pending += {r};\n            }\n        }\n\n        transition!{\n            shared_finish(r: int) {\n                require(!pre.exc_locked);\n                remove shared_pending -= {r};\n\n                birds_eye let t = pre.storage->0;\n                add shared_guard += {(r, t)};\n            }\n        }\n\n        transition!{\n            shared_release(val: (int, T)) {\n                remove shared_guard -= {val};\n\n                let r = val.0;\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc - 1];\n\n                assert(rc > 0) by {\n                    assert(0 <= r < pre.rc_width);\n                    assert(pre.shared_guard.count(val) > 0);\n                    assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                    assert(Self::filter_r(pre.shared_guard, r).len() > 0);\n                    assert(pre.ref_counts.index(r) > 0);\n                };\n            }\n        }\n\n        property!{\n            do_guard(val: (int, T)) {\n                have shared_guard >= {val};\n                guard storage >= Some(val.1);\n            }\n        }\n\n        ///// Invariants and proofs\n\n        #[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n            &&& 0 < self.rc_width\n            &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn exc_inv(&self) -> bool {\n            &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)\n            &&& self.storage is Some <==> self.exc_guard is None\n            &&& if let Option::Some(cur_r) = self.exc_pending {\n                &&& 0 <= cur_r <= self.rc_width\n                &&& self.exc_guard is None\n                &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)\n            } else {\n                true\n            }\n        }\n\n        #[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n            forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n            forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n            forall |v| #[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)\n        }\n\n        pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n            shared_guard.filter(|val: (int, T)| val.0 == r)\n        }\n\n        #[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n            forall |r| 0 <= r < self.rc_width ==>\n                #[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +\n                        Self::filter_r(self.shared_guard, r).len() as int\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n            assert forall |r| 0 <= r < post.rc_width implies\n                #[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +\n                        Self::filter_r(post.shared_guard, r).len() as int\n            by {\n                assert(post.ref_counts.index(r) == 0);\n                assert(post.shared_pending.count(r) == 0);\n                assert_multisets_equal!(\n                    Self::filter_r(post.shared_guard, r),\n                    Multiset::empty(),\n                );\n                assert(Self::filter_r(post.shared_guard, r).len() == 0);\n            }\n            assert(post.shared_counts_agree());\n        }\n\n        #[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n\n        }\n\n        #[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n            let prev_r = pre.exc_pending->0;\n            assert forall |x| #[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false\n            by {\n                assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n            }\n        }\n\n        #[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n        }\n\n        #[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n\n        }\n\n        #[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) { }\n\n        #[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n            let t = pre.storage->0;\n\n            assert forall |r0| 0 <= r0 < post.rc_width implies\n                #[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +\n                        Self::filter_r(post.shared_guard, r0).len() as int\n            by {\n                if r == r0 {\n                    assert_multisets_equal!(\n                        pre.shared_pending,\n                        post.shared_pending.add(Multiset::singleton(r))\n                    );\n                    assert_multisets_equal!(\n                        Self::filter_r(post.shared_guard, r),\n                        Self::filter_r(pre.shared_guard, r).add(\n                            Multiset::singleton((r, t)))\n                    );\n                    assert(post.ref_counts.index(r0) ==\n                        post.shared_pending.count(r0) as int +\n                            Self::filter_r(post.shared_guard, r0).len() as int);\n                } else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                    assert(post.ref_counts.index(r0) ==\n                        post.shared_pending.count(r0) as int +\n                            Self::filter_r(post.shared_guard, r0).len() as int);\n                }\n            }\n        }\n\n        #[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n            let r = val.0;\n            assert forall |r0| 0 <= r0 < post.rc_width implies\n                #[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +\n                        Self::filter_r(post.shared_guard, r0).len() as int\n            by {\n                if r0 == r {\n                    assert_multisets_equal!(\n                        Self::filter_r(pre.shared_guard, r),\n                        Self::filter_r(post.shared_guard, r).add(\n                            Multiset::singleton(val))\n                    );\n                } else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                }\n            }\n        }\n    }\n}\n\nstruct_with_invariants!{\n    struct RwLock<T> {\n        inst: Tracked<DistRwLock::Instance<T>>,\n        exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,\n        ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,\n    }\n\n    spec fn wf(&self) -> bool {\n\n        predicate {\n            &&& self.inst@.rc_width() == self.ref_counts@.len()\n\n            &&& forall |i: int| (0 <= i && i < self.ref_counts@.len()) ==>\n                #[trigger] self.ref_counts@.index(i).well_formed()\n                && self.ref_counts@.index(i).constant() === (self.inst, i)\n        }\n\n        invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n            g.instance_id() == inst@.id()\n            && g.value() == b\n        }\n\n        invariant on ref_counts with (inst)\n            forall |i: int|\n            where (0 <= i < self.ref_counts@.len())\n            specifically (self.ref_counts@[i])\n            is (v: u64, g: DistRwLock::ref_counts<T>)\n        {\n            g.instance_id() == inst@.id()\n            && g.key() == i\n            && g.value() == v as int\n        }\n    }\n}\n\nimpl<T> RwLock<T> {\n    #[verifier::spinoff_prover]\n    fn new(rc_width: usize, t: T) -> (s: Self)\n        requires\n            0 < rc_width,\n        ensures\n            s.wf(),\n    {\n        let tracked inst;\n        let tracked exc_locked_token;\n        let tracked mut ref_counts_tokens;\n        proof {\n            let tracked (\n                Tracked(inst0),\n                Tracked(exc_locked_token0),\n                Tracked(ref_counts_tokens0),\n                _,\n                _,\n                _,\n                _,\n            ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n            inst = inst0;\n            exc_locked_token = exc_locked_token0;\n            ref_counts_tokens = ref_counts_tokens0;\n        }\n        let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n        let exc_locked_atomic = AtomicBool::new(\n            Ghost(tracked_inst),\n            false,\n            Tracked(exc_locked_token),\n        );\n        let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n        let mut i: usize = 0;\n        assert forall|j: int|\n            i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)\n        by {\n            assert(ref_counts_tokens.dom().contains(j));\n            assert(equal(ref_counts_tokens.index(j), 0));\n        }\n        assert(forall|j: int|\n            #![trigger( ref_counts_tokens.dom().contains(j) )]\n            #![trigger( ref_counts_tokens.index(j) )]\n            i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)));\n        while i < rc_width\n            invariant\n                i <= rc_width,\n                v@.len() == i as int,\n                forall|j: int|\n                    0 <= j && j < i ==> #[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),\n                tracked_inst@ == inst,\n                ref_counts_tokens.instance_id() == inst.id(),\n                forall|j: int|\n                    #![trigger( ref_counts_tokens.dom().contains(j) )]\n                    #![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n                      && equal(ref_counts_tokens.index(j), 0)),\n        {\n            assert(ref_counts_tokens.dom().contains(i as int));\n            let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n            let rc_atomic = AtomicU64::new(\n                Ghost((tracked_inst, i as int)),\n                0,\n                Tracked(ref_count_token),\n            );\n            v.push(rc_atomic);\n            i = i + 1;\n            assert forall|j: int|\n                i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)\n            by {\n                assert(ref_counts_tokens.dom().contains(j));\n                assert(equal(ref_counts_tokens.index(j), 0));\n            }\n        }\n        let s = RwLock { inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n        assert(s.inst@.rc_width() == s.ref_counts@.len());\n        s\n    }\n}\n\n} // verus!\nfn main() {}\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::atomic_ghost::*;\n      use vstd::multiset::*;\n      use vstd::prelude::*;\n      use verus_state_machines_macros::tokenized_state_machine;\n      verus! {\n     tokenized_state_machine!{\n        DistRwLock<T> {\n           fields {\n#[sharding(constant)]\n            pub rc_width: int,                  \n#[sharding(storage_option)]\n            pub storage: Option<T>,                  \n#[sharding(variable)]\n            pub exc_locked: bool,                  \n#[sharding(map)]\n            pub ref_counts: Map<int, int>,                  \n#[sharding(option)]\n            pub exc_pending: Option<int>,                  \n#[sharding(option)]\n            pub exc_guard: Option<()>,                  \n#[sharding(multiset)]\n            pub shared_pending: Multiset<int>,                  \n#[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,         }\n           init!{\n              initialize(rc_width: int, init_t: T) {\n                 require(0 < rc_width);\n                 init rc_width = rc_width;\n                 init storage = Option::Some(init_t);\n                 init exc_locked = false;\n                 init ref_counts = Map::new(                     |i| 0 <= i < rc_width,                     |i| 0,                 );\n                 init exc_pending = Option::None;\n                 init exc_guard = Option::None;\n                 init shared_pending = Multiset::empty();\n                 init shared_guard = Multiset::empty();\n             }\n          }\n           transition!{\n              exc_start() {\n                 require(!pre.exc_locked);\n                 update exc_locked = true;\n                 add exc_pending += Some(0);\n             }\n          }\n           transition!{\n              exc_check_count() {\n                 remove exc_pending -= Some(let r);\n                 have ref_counts >= [r => 0];\n                 add exc_pending += Some(r + 1);\n             }\n          }\n           transition!{\n              exc_finish() {\n             }\n          }\n           transition!{\n              exc_release(t: T) {\n                 update exc_locked = false;\n                 remove exc_guard -= Some(());\n                 deposit storage += Some(t);\n             }\n          }\n           transition!{\n              shared_start(r: int) {\n                 remove ref_counts -= [r => let rc];\n                 add ref_counts += [r => rc + 1];\n                 add shared_pending += {\nr};\n             }\n          }\n           transition!{\n              shared_finish(r: int) {\n                 require(!pre.exc_locked);\n                 remove shared_pending -= {\nr};\n                 birds_eye let t = pre.storage->0;\n                 add shared_guard += {\n(r, t)};\n             }\n          }\n           transition!{\n              shared_release(val: (int, T)) {\n                 remove shared_guard -= {\nval};\n                 let r = val.0;\n                 remove ref_counts -= [r => let rc];\n                 add ref_counts += [r => rc - 1];\n                 assert(rc > 0) by {\n                     assert(0 <= r < pre.rc_width);\n                     assert(pre.shared_guard.count(val) > 0);\n                     assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                     assert(Self::filter_r(pre.shared_guard, r).len() > 0);\n                     assert(pre.ref_counts.index(r) > 0);\n                 };\n             }\n          }\n#[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n              &&& 0 < self.rc_width             &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)         }\n#[invariant]\n        pub fn exc_inv(&self) -> bool {\n              &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)             &&& self.storage is Some <==> self.exc_guard is None             &&& if let Option::Some(cur_r) = self.exc_pending {\n                 &&& 0 <= cur_r <= self.rc_width                 &&& self.exc_guard is None                 &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)             }\n  else {\n                 true             }\n          }\n#[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n              forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)         }\n#[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n              forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)         }\n#[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n              forall |v|      \n#[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)         }\n           pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n              shared_guard.filter(|val: (int, T)| val.0 == r)         }\n#[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n              forall |r| 0 <= r < self.rc_width ==>                      \n#[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +                         Self::filter_r(self.shared_guard, r).len() as int         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n              assert forall |r| 0 <= r < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +                         Self::filter_r(post.shared_guard, r).len() as int             by {\n                 assert(post.ref_counts.index(r) == 0);\n                 assert_multisets_equal!(                     Self::filter_r(post.shared_guard, r),                     Multiset::empty(),                 );\n             }\n          }\n#[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n          }\n#[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n              let prev_r = pre.exc_pending->0;\n              assert forall |x|      \n#[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false             by {\n                 assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n             }\n          }\n#[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n          }\n#[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n          }\n#[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) {\n  }\n#[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n              let t = pre.storage->0;\n              assert forall |r0| 0 <= r0 < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                 if r == r0 {\n                     assert_multisets_equal!(                         Self::filter_r(post.shared_guard, r),                         Self::filter_r(pre.shared_guard, r).add(                             Multiset::singleton((r, t)))                     );\n                 }\n else {\n                     assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                 }\n             }\n          }\n#[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n              let r = val.0;\n              assert forall |r0| 0 <= r0 < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                 if r0 == r {\n                     assert_multisets_equal!(                         Self::filter_r(pre.shared_guard, r),                         Self::filter_r(post.shared_guard, r).add(                             Multiset::singleton(val))                     );\n                 }\n else {\n                     assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                 }\n             }\n          }\n       }\n    }\n     struct_with_invariants!{\n        struct RwLock<T> {\n           inst: Tracked<DistRwLock::Instance<T>>,         exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,         ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,     }\n        spec fn wf(&self) -> bool {\n           invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n              g.instance_id() == inst@.id()             && g.value() == b         }\n           invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {\n              g.instance_id() == inst@.id()             && g.key() == i             && g.value() == v as int         }\n       }\n    }\n     impl<T> RwLock<T> {\n             fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n           let tracked inst;\n           let tracked exc_locked_token;\n           let tracked mut ref_counts_tokens;\n           proof {\n              let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n              inst = inst0;\n              exc_locked_token = exc_locked_token0;\n              ref_counts_tokens = ref_counts_tokens0;\n          }\n           let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n           let exc_locked_atomic = AtomicBool::new(             Ghost(tracked_inst),             false,             Tracked(exc_locked_token),         );\n           let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n           let mut i: usize = 0;\n           assert forall|j: int|             i <= j && j < rc_width implies      \n#[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)         by {\n          }\n           while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>      \n#[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),                 tracked_inst@ == inst,                 ref_counts_tokens.instance_id() == inst.id(),                 forall|j: int|                          \n#![trigger( ref_counts_tokens.dom().contains(j) )]\n#![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)                       && equal(ref_counts_tokens.index(j), 0)),         {\n              let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n              let rc_atomic = AtomicU64::new(                 Ghost((tracked_inst, i as int)),                 0,                 Tracked(ref_count_token),             );\n              v.push(rc_atomic);\n              i = i + 1;\n              assert forall|j: int|                 i <= j && j < rc_width implies      \n#[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)             by {\n             }\n          }\n           let s = RwLock {\n  inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n           s     }\n    }\n     }\n       fn main() {\n    }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/dist_rwlock.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1775, "minimize_time_ms": 523723, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 407, "minimized_LOC": 236, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::atomic_ghost::", "vstd::map::", "vstd::multiset::", "vstd::prelude::", "verus_state_machines_macros::tokenized_state_machine"], "complexity_verus_tokens": 21, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 0.5798525798525799}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn ref_counts_domain(&self) -> bool {\n\n pub fn exc_inv(&self) -> bool {\n\n pub fn shared_pending_in_range(&self) -> bool {\n\n pub fn shared_guard_in_range(&self) -> bool {\n\n pub fn shared_inv_agree(&self) -> bool {\n\n pub fn shared_counts_agree(&self) -> bool {\n\n fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n\n fn exc_start_inductive(pre: Self, post: Self) {\n\n fn exc_check_count_inductive(pre: Self, post: Self) {\n\n fn exc_finish_inductive(pre: Self, post: Self) {\n\n fn exc_release_inductive(pre: Self, post: Self, t: T) {\n\n fn shared_start_inductive(pre: Self, post: Self, r: int) {\n\n fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n\n fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n\n fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n\n fn main() {", "spec": "spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n\nspec fn wf(&self) -> bool {\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n           invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n\n           invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {\n\n             fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n\n           while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>      ", "proof": "proof {\n              let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n              inst = inst0;\n              exc_locked_token = exc_locked_token0;\n              ref_counts_tokens = ref_counts_tokens0;\n          }"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::map::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\nverus! {\n\ntokenized_state_machine!{\n    DistRwLock<T> {\n        fields {\n            #[sharding(constant)]\n            pub rc_width: int,\n\n            #[sharding(storage_option)]\n            pub storage: Option<T>,\n\n            #[sharding(variable)]\n            pub exc_locked: bool,\n\n            #[sharding(map)]\n            pub ref_counts: Map<int, int>,\n\n            #[sharding(option)]\n            pub exc_pending: Option<int>,\n\n            #[sharding(option)]\n            pub exc_guard: Option<()>,\n\n            #[sharding(multiset)]\n            pub shared_pending: Multiset<int>,\n\n            #[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,\n        }\n\n        init!{\n            initialize(rc_width: int, init_t: T) {\n                require(0 < rc_width);\n                init rc_width = rc_width;\n                init storage = Option::Some(init_t);\n                init exc_locked = false;\n                init ref_counts = Map::new(\n                    |i| 0 <= i < rc_width,\n                    |i| 0,\n                );\n                init exc_pending = Option::None;\n                init exc_guard = Option::None;\n                init shared_pending = Multiset::empty();\n                init shared_guard = Multiset::empty();\n            }\n        }\n\n        transition!{\n            exc_start() {\n                require(!pre.exc_locked);\n                update exc_locked = true;\n                add exc_pending += Some(0);\n            }\n        }\n\n        transition!{\n            exc_check_count() {\n                remove exc_pending -= Some(let r);\n                have ref_counts >= [r => 0];\n\n                add exc_pending += Some(r + 1);\n            }\n        }\n\n        transition!{\n            exc_finish() {\n                remove exc_pending -= Some(pre.rc_width);\n                add exc_guard += Some(());\n                withdraw storage -= Some(let _);\n            }\n        }\n\n        transition!{\n            exc_release(t: T) {\n                update exc_locked = false;\n                remove exc_guard -= Some(());\n                deposit storage += Some(t);\n            }\n        }\n\n        transition!{\n            shared_start(r: int) {\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc + 1];\n                add shared_pending += {r};\n            }\n        }\n\n        transition!{\n            shared_finish(r: int) {\n                require(!pre.exc_locked);\n                remove shared_pending -= {r};\n\n                birds_eye let t = pre.storage->0;\n                add shared_guard += {(r, t)};\n            }\n        }\n\n        transition!{\n            shared_release(val: (int, T)) {\n                remove shared_guard -= {val};\n\n                let r = val.0;\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc - 1];\n\n                assert(rc > 0) by {\n                    assert(0 <= r < pre.rc_width);\n                    assert(pre.shared_guard.count(val) > 0);\n                    assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                    assert(Self::filter_r(pre.shared_guard, r).len() > 0);\n                    assert(pre.ref_counts.index(r) > 0);\n                };\n            }\n        }\n\n        property!{\n            do_guard(val: (int, T)) {\n                have shared_guard >= {val};\n                guard storage >= Some(val.1);\n            }\n        }\n\n        ///// Invariants and proofs\n\n        #[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n            &&& 0 < self.rc_width\n            &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn exc_inv(&self) -> bool {\n            &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)\n            &&& self.storage is Some <==> self.exc_guard is None\n            &&& if let Option::Some(cur_r) = self.exc_pending {\n                &&& 0 <= cur_r <= self.rc_width\n                &&& self.exc_guard is None\n                &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)\n            } else {\n                true\n            }\n        }\n\n        #[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n            forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n            forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n            forall |v| #[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)\n        }\n\n        pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n            shared_guard.filter(|val: (int, T)| val.0 == r)\n        }\n\n        #[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n            forall |r| 0 <= r < self.rc_width ==>\n                #[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +\n                        Self::filter_r(self.shared_guard, r).len() as int\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n            assert forall |r| 0 <= r < post.rc_width implies\n                #[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +\n                        Self::filter_r(post.shared_guard, r).len() as int\n            by {\n                assert(post.ref_counts.index(r) == 0);\n                assert(post.shared_pending.count(r) == 0);\n                assert_multisets_equal!(\n                    Self::filter_r(post.shared_guard, r),\n                    Multiset::empty(),\n                );\n                assert(Self::filter_r(post.shared_guard, r).len() == 0);\n            }\n            assert(post.shared_counts_agree());\n        }\n\n        #[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n\n        }\n\n        #[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n            let prev_r = pre.exc_pending->0;\n            assert forall |x| #[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false\n            by {\n                assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n            }\n        }\n\n        #[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n        }\n\n        #[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n\n        }\n\n        #[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) { }\n\n        #[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n            let t = pre.storage->0;\n\n            assert forall |r0| 0 <= r0 < post.rc_width implies\n                #[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +\n                        Self::filter_r(post.shared_guard, r0).len() as int\n            by {\n                if r == r0 {\n                    assert_multisets_equal!(\n                        pre.shared_pending,\n                        post.shared_pending.add(Multiset::singleton(r))\n                    );\n                    assert_multisets_equal!(\n                        Self::filter_r(post.shared_guard, r),\n                        Self::filter_r(pre.shared_guard, r).add(\n                            Multiset::singleton((r, t)))\n                    );\n                    assert(post.ref_counts.index(r0) ==\n                        post.shared_pending.count(r0) as int +\n                            Self::filter_r(post.shared_guard, r0).len() as int);\n                } else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                    assert(post.ref_counts.index(r0) ==\n                        post.shared_pending.count(r0) as int +\n                            Self::filter_r(post.shared_guard, r0).len() as int);\n                }\n            }\n        }\n\n        #[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n            let r = val.0;\n            assert forall |r0| 0 <= r0 < post.rc_width implies\n                #[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +\n                        Self::filter_r(post.shared_guard, r0).len() as int\n            by {\n                if r0 == r {\n                    assert_multisets_equal!(\n                        Self::filter_r(pre.shared_guard, r),\n                        Self::filter_r(post.shared_guard, r).add(\n                            Multiset::singleton(val))\n                    );\n                } else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                }\n            }\n        }\n    }\n}\n\nstruct_with_invariants!{\n    struct RwLock<T> {\n        inst: Tracked<DistRwLock::Instance<T>>,\n        exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,\n        ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,\n    }\n\n    spec fn wf(&self) -> bool {\n\n        predicate {\n            &&& self.inst@.rc_width() == self.ref_counts@.len()\n\n            &&& forall |i: int| (0 <= i && i < self.ref_counts@.len()) ==>\n                #[trigger] self.ref_counts@.index(i).well_formed()\n                && self.ref_counts@.index(i).constant() === (self.inst, i)\n        }\n\n        invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n            g.instance_id() == inst@.id()\n            && g.value() == b\n        }\n\n        invariant on ref_counts with (inst)\n            forall |i: int|\n            where (0 <= i < self.ref_counts@.len())\n            specifically (self.ref_counts@[i])\n            is (v: u64, g: DistRwLock::ref_counts<T>)\n        {\n            g.instance_id() == inst@.id()\n            && g.key() == i\n            && g.value() == v as int\n        }\n    }\n}\n\nimpl<T> RwLock<T> {\n    #[verifier::spinoff_prover]\n    fn new(rc_width: usize, t: T) -> (s: Self)\n        requires\n            0 < rc_width,\n        ensures\n            s.wf(),\n    {\n        let tracked inst;\n        let tracked exc_locked_token;\n        let tracked mut ref_counts_tokens;\n        proof {\n            let tracked (\n                Tracked(inst0),\n                Tracked(exc_locked_token0),\n                Tracked(ref_counts_tokens0),\n                _,\n                _,\n                _,\n                _,\n            ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n            inst = inst0;\n            exc_locked_token = exc_locked_token0;\n            ref_counts_tokens = ref_counts_tokens0;\n        }\n        let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n        let exc_locked_atomic = AtomicBool::new(\n            Ghost(tracked_inst),\n            false,\n            Tracked(exc_locked_token),\n        );\n        let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n        let mut i: usize = 0;\n        assert forall|j: int|\n            i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)\n        by {\n            assert(ref_counts_tokens.dom().contains(j));\n            assert(equal(ref_counts_tokens.index(j), 0));\n        }\n        assert(forall|j: int|\n            #![trigger( ref_counts_tokens.dom().contains(j) )]\n            #![trigger( ref_counts_tokens.index(j) )]\n            i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)));\n        while i < rc_width\n            invariant\n                i <= rc_width,\n                v@.len() == i as int,\n                forall|j: int|\n                    0 <= j && j < i ==> #[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),\n                tracked_inst@ == inst,\n                ref_counts_tokens.instance_id() == inst.id(),\n                forall|j: int|\n                    #![trigger( ref_counts_tokens.dom().contains(j) )]\n                    #![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n                      && equal(ref_counts_tokens.index(j), 0)),\n        {\n            assert(ref_counts_tokens.dom().contains(i as int));\n            let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n            let rc_atomic = AtomicU64::new(\n                Ghost((tracked_inst, i as int)),\n                0,\n                Tracked(ref_count_token),\n            );\n            v.push(rc_atomic);\n            i = i + 1;\n            assert forall|j: int|\n                i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)\n            by {\n                assert(ref_counts_tokens.dom().contains(j));\n                assert(equal(ref_counts_tokens.index(j), 0));\n            }\n        }\n        let s = RwLock { inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n        assert(s.inst@.rc_width() == s.ref_counts@.len());\n        s\n    }\n}\n\n} // verus!\nfn main() {}\n", "use vstd;\nfn main() {}\n", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::atomic_ghost::*;\n      use vstd::multiset::*;\n      use vstd::prelude::*;\n      use verus_state_machines_macros::tokenized_state_machine;\n      verus! {\n     tokenized_state_machine!{\n        DistRwLock<T> {\n           fields {\n#[sharding(constant)]\n            pub rc_width: int,                  \n#[sharding(storage_option)]\n            pub storage: Option<T>,                  \n#[sharding(variable)]\n            pub exc_locked: bool,                  \n#[sharding(map)]\n            pub ref_counts: Map<int, int>,                  \n#[sharding(option)]\n            pub exc_pending: Option<int>,                  \n#[sharding(option)]\n            pub exc_guard: Option<()>,                  \n#[sharding(multiset)]\n            pub shared_pending: Multiset<int>,                  \n#[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,         }\n           init!{\n              initialize(rc_width: int, init_t: T) {\n                 require(0 < rc_width);\n                 init rc_width = rc_width;\n                 init storage = Option::Some(init_t);\n                 init exc_locked = false;\n                 init ref_counts = Map::new(                     |i| 0 <= i < rc_width,                     |i| 0,                 );\n                 init exc_pending = Option::None;\n                 init exc_guard = Option::None;\n                 init shared_pending = Multiset::empty();\n                 init shared_guard = Multiset::empty();\n             }\n          }\n           transition!{\n              exc_start() {\n                 require(!pre.exc_locked);\n                 update exc_locked = true;\n                 add exc_pending += Some(0);\n             }\n          }\n           transition!{\n              exc_check_count() {\n                 remove exc_pending -= Some(let r);\n                 have ref_counts >= [r => 0];\n                 add exc_pending += Some(r + 1);\n             }\n          }\n           transition!{\n              exc_finish() {\n             }\n          }\n           transition!{\n              exc_release(t: T) {\n                 update exc_locked = false;\n                 remove exc_guard -= Some(());\n                 deposit storage += Some(t);\n             }\n          }\n           transition!{\n              shared_start(r: int) {\n                 remove ref_counts -= [r => let rc];\n                 add ref_counts += [r => rc + 1];\n                 add shared_pending += {\nr};\n             }\n          }\n           transition!{\n              shared_finish(r: int) {\n                 require(!pre.exc_locked);\n                 remove shared_pending -= {\nr};\n                 birds_eye let t = pre.storage->0;\n                 add shared_guard += {\n(r, t)};\n             }\n          }\n           transition!{\n              shared_release(val: (int, T)) {\n                 remove shared_guard -= {\nval};\n                 let r = val.0;\n                 remove ref_counts -= [r => let rc];\n                 add ref_counts += [r => rc - 1];\n                 assert(rc > 0) by {\n                     assert(0 <= r < pre.rc_width);\n                     assert(pre.shared_guard.count(val) > 0);\n                     assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                     assert(Self::filter_r(pre.shared_guard, r).len() > 0);\n                     assert(pre.ref_counts.index(r) > 0);\n                 };\n             }\n          }\n#[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n              &&& 0 < self.rc_width             &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)         }\n#[invariant]\n        pub fn exc_inv(&self) -> bool {\n              &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)             &&& self.storage is Some <==> self.exc_guard is None             &&& if let Option::Some(cur_r) = self.exc_pending {\n                 &&& 0 <= cur_r <= self.rc_width                 &&& self.exc_guard is None                 &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)             }\n  else {\n                 true             }\n          }\n#[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n              forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)         }\n#[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n              forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)         }\n#[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n              forall |v|      \n#[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)         }\n           pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n              shared_guard.filter(|val: (int, T)| val.0 == r)         }\n#[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n              forall |r| 0 <= r < self.rc_width ==>                      \n#[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +                         Self::filter_r(self.shared_guard, r).len() as int         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n              assert forall |r| 0 <= r < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +                         Self::filter_r(post.shared_guard, r).len() as int             by {\n                 assert(post.ref_counts.index(r) == 0);\n                 assert_multisets_equal!(                     Self::filter_r(post.shared_guard, r),                     Multiset::empty(),                 );\n             }\n          }\n#[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n          }\n#[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n              let prev_r = pre.exc_pending->0;\n              assert forall |x|      \n#[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false             by {\n                 assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n             }\n          }\n#[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n          }\n#[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n          }\n#[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) {\n  }\n#[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n              let t = pre.storage->0;\n              assert forall |r0| 0 <= r0 < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                 if r == r0 {\n                     assert_multisets_equal!(                         Self::filter_r(post.shared_guard, r),                         Self::filter_r(pre.shared_guard, r).add(                             Multiset::singleton((r, t)))                     );\n                 }\n else {\n                     assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                 }\n             }\n          }\n#[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n              let r = val.0;\n              assert forall |r0| 0 <= r0 < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                 if r0 == r {\n                     assert_multisets_equal!(                         Self::filter_r(pre.shared_guard, r),                         Self::filter_r(post.shared_guard, r).add(                             Multiset::singleton(val))                     );\n                 }\n else {\n                     assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                 }\n             }\n          }\n       }\n    }\n     struct_with_invariants!{\n        struct RwLock<T> {\n           inst: Tracked<DistRwLock::Instance<T>>,         exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,         ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,     }\n        spec fn wf(&self) -> bool {\n           invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n              g.instance_id() == inst@.id()             && g.value() == b         }\n           invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {\n              g.instance_id() == inst@.id()             && g.key() == i             && g.value() == v as int         }\n       }\n    }\n     impl<T> RwLock<T> {\n             fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n           let tracked inst;\n           let tracked exc_locked_token;\n           let tracked mut ref_counts_tokens;\n           proof {\n              let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n              inst = inst0;\n              exc_locked_token = exc_locked_token0;\n              ref_counts_tokens = ref_counts_tokens0;\n          }\n           let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n           let exc_locked_atomic = AtomicBool::new(             Ghost(tracked_inst),             false,             Tracked(exc_locked_token),         );\n           let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n           let mut i: usize = 0;\n           assert forall|j: int|             i <= j && j < rc_width implies      \n#[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)         by {\n          }\n           while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>      \n#[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),                 tracked_inst@ == inst,                 ref_counts_tokens.instance_id() == inst.id(),                 forall|j: int|                          \n#![trigger( ref_counts_tokens.dom().contains(j) )]\n#![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)                       && equal(ref_counts_tokens.index(j), 0)),         {\n              let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n              let rc_atomic = AtomicU64::new(                 Ghost((tracked_inst, i as int)),                 0,                 Tracked(ref_count_token),             );\n              v.push(rc_atomic);\n              i = i + 1;\n              assert forall|j: int|                 i <= j && j < rc_width implies      \n#[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)             by {\n             }\n          }\n           let s = RwLock {\n  inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n           s     }\n    }\n     }\n       fn main() {\n    }\n", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::atomic_ghost::*;\n       use vstd::multiset::*;\n       use vstd::prelude::*;\n       use verus_state_machines_macros::tokenized_state_machine;\n       verus! {\n      tokenized_state_machine!{\n         DistRwLock<T> {\n            fields {\n#[sharding(constant)]\n            pub rc_width: int,                   \n#[sharding(storage_option)]\n            pub storage: Option<T>,                   \n#[sharding(variable)]\n            pub exc_locked: bool,                   \n#[sharding(map)]\n            pub ref_counts: Map<int, int>,                   \n#[sharding(option)]\n            pub exc_pending: Option<int>,                   \n#[sharding(option)]\n            pub exc_guard: Option<()>,                   \n#[sharding(multiset)]\n            pub shared_pending: Multiset<int>,                   \n#[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,         }\n            init!{\n               initialize(rc_width: int, init_t: T) {\n                  require(0 < rc_width);\n                  init rc_width = rc_width;\n                  init storage = Option::Some(init_t);\n                  init exc_locked = false;\n                  init ref_counts = Map::new(                     |i| 0 <= i < rc_width,                     |i| 0,                 );\n                  init exc_pending = Option::None;\n                  init exc_guard = Option::None;\n                  init shared_pending = Multiset::empty();\n                  init shared_guard = Multiset::empty();\n              }\n           }\n            transition!{\n               exc_start() {\n                  require(!pre.exc_locked);\n                  update exc_locked = true;\n                  add exc_pending += Some(0);\n              }\n           }\n            transition!{\n               exc_check_count() {\n                  remove exc_pending -= Some(let r);\n                  have ref_counts >= [r => 0];\n                  add exc_pending += Some(r + 1);\n              }\n           }\n            transition!{\n               exc_finish() {\n              }\n           }\n            transition!{\n               exc_release(t: T) {\n                  update exc_locked = false;\n                  remove exc_guard -= Some(());\n                  deposit storage += Some(t);\n              }\n           }\n            transition!{\n               shared_start(r: int) {\n                  remove ref_counts -= [r => let rc];\n                  add ref_counts += [r => rc + 1];\n                  add shared_pending += {\n r};\n              }\n           }\n            transition!{\n               shared_finish(r: int) {\n                  require(!pre.exc_locked);\n                  remove shared_pending -= {\n r};\n                  birds_eye let t = pre.storage->0;\n                  add shared_guard += {\n (r, t)};\n              }\n           }\n            transition!{\n               shared_release(val: (int, T)) {\n                  remove shared_guard -= {\n val};\n                  let r = val.0;\n                  remove ref_counts -= [r => let rc];\n                  add ref_counts += [r => rc - 1];\n                  assert(rc > 0) by {\n                      assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                  };\n              }\n           }\n#[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n               &&& 0 < self.rc_width             &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)         }\n#[invariant]\n        pub fn exc_inv(&self) -> bool {\n               &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)             &&& self.storage is Some <==> self.exc_guard is None             &&& if let Option::Some(cur_r) = self.exc_pending {\n                  &&& 0 <= cur_r <= self.rc_width                 &&& self.exc_guard is None                 &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)             }\n   else {\n                  true             }\n           }\n#[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n               forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)         }\n#[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n               forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)         }\n#[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n               forall |v|       \n#[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)         }\n            pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n               shared_guard.filter(|val: (int, T)| val.0 == r)         }\n#[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n               forall |r| 0 <= r < self.rc_width ==>                       \n#[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +                         Self::filter_r(self.shared_guard, r).len() as int         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n               assert forall |r| 0 <= r < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +                         Self::filter_r(post.shared_guard, r).len() as int             by {\n                  assert_multisets_equal!(                     Self::filter_r(post.shared_guard, r),                     Multiset::empty(),                 );\n              }\n           }\n#[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n           }\n#[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n               let prev_r = pre.exc_pending->0;\n               assert forall |x|       \n#[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false             by {\n                  assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n              }\n           }\n#[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n           }\n#[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n           }\n#[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) {\n   }\n#[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n               let t = pre.storage->0;\n               assert forall |r0| 0 <= r0 < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                  if r == r0 {\n                      assert_multisets_equal!(                         Self::filter_r(post.shared_guard, r),                         Self::filter_r(pre.shared_guard, r).add(                             Multiset::singleton((r, t)))                     );\n                  }\n  else {\n                      assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                  }\n              }\n           }\n#[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n               let r = val.0;\n               assert forall |r0| 0 <= r0 < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                  if r0 == r {\n                      assert_multisets_equal!(                         Self::filter_r(pre.shared_guard, r),                         Self::filter_r(post.shared_guard, r).add(                             Multiset::singleton(val))                     );\n                  }\n  else {\n                      assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                  }\n              }\n           }\n        }\n     }\n      struct_with_invariants!{\n         struct RwLock<T> {\n            inst: Tracked<DistRwLock::Instance<T>>,         exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,         ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,     }\n         spec fn wf(&self) -> bool {\n            invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n               g.instance_id() == inst@.id()             && g.value() == b         }\n            invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {\n               g.instance_id() == inst@.id()             && g.key() == i             && g.value() == v as int         }\n        }\n     }\n      impl<T> RwLock<T> {\n              fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n            let tracked inst;\n            let tracked exc_locked_token;\n            let tracked mut ref_counts_tokens;\n            proof {\n               let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n               inst = inst0;\n               exc_locked_token = exc_locked_token0;\n               ref_counts_tokens = ref_counts_tokens0;\n           }\n            let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n            let exc_locked_atomic = AtomicBool::new(             Ghost(tracked_inst),             false,             Tracked(exc_locked_token),         );\n            let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n            let mut i: usize = 0;\n            assert forall|j: int|             i <= j && j < rc_width implies       \n#[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)         by {\n           }\n            while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>       \n#[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),                 tracked_inst@ == inst,                 ref_counts_tokens.instance_id() == inst.id(),                 forall|j: int|                           \n#![trigger( ref_counts_tokens.dom().contains(j) )]\n#![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)                       && equal(ref_counts_tokens.index(j), 0)),         {\n               let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n               let rc_atomic = AtomicU64::new(                 Ghost((tracked_inst, i as int)),                 0,                 Tracked(ref_count_token),             );\n               v.push(rc_atomic);\n               i = i + 1;\n               assert forall|j: int|                 i <= j && j < rc_width implies       \n#[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)             by {\n              }\n           }\n            let s = RwLock {\n   inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n            s     }\n     }\n      }\n        fn main() {\n     }\n", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::atomic_ghost::*;\n       use vstd::multiset::*;\n       use vstd::prelude::*;\n       use verus_state_machines_macros::tokenized_state_machine;\n       verus! {\n      tokenized_state_machine!{\n         DistRwLock<T> {\n            fields {\n#[sharding(constant)]\n            pub rc_width: int,                   \n#[sharding(storage_option)]\n            pub storage: Option<T>,                   \n#[sharding(variable)]\n            pub exc_locked: bool,                   \n#[sharding(map)]\n            pub ref_counts: Map<int, int>,                   \n#[sharding(option)]\n            pub exc_pending: Option<int>,                   \n#[sharding(option)]\n            pub exc_guard: Option<()>,                   \n#[sharding(multiset)]\n            pub shared_pending: Multiset<int>,                   \n#[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,         }\n            init!{\n               initialize(rc_width: int, init_t: T) {\n                  require(0 < rc_width);\n                  init rc_width = rc_width;\n                  init storage = Option::Some(init_t);\n                  init exc_locked = false;\n                  init ref_counts = Map::new(                     |i| 0 <= i < rc_width,                     |i| 0,                 );\n                  init exc_pending = Option::None;\n                  init exc_guard = Option::None;\n                  init shared_pending = Multiset::empty();\n                  init shared_guard = Multiset::empty();\n              }\n           }\n            transition!{\n               exc_start() {\n                  require(!pre.exc_locked);\n                  update exc_locked = true;\n                  add exc_pending += Some(0);\n              }\n           }\n            transition!{\n               exc_check_count() {\n                  remove exc_pending -= Some(let r);\n                  have ref_counts >= [r => 0];\n                  add exc_pending += Some(r + 1);\n              }\n           }\n            transition!{\n               exc_finish() {\n              }\n           }\n            transition!{\n               exc_release(t: T) {\n                  update exc_locked = false;\n                  remove exc_guard -= Some(());\n                  deposit storage += Some(t);\n              }\n           }\n            transition!{\n               shared_start(r: int) {\n                  remove ref_counts -= [r => let rc];\n                  add ref_counts += [r => rc + 1];\n                  add shared_pending += {\n r};\n              }\n           }\n            transition!{\n               shared_finish(r: int) {\n                  require(!pre.exc_locked);\n                  remove shared_pending -= {\n r};\n                  birds_eye let t = pre.storage->0;\n                  add shared_guard += {\n (r, t)};\n              }\n           }\n            transition!{\n               shared_release(val: (int, T)) {\n                  remove shared_guard -= {\n val};\n                  let r = val.0;\n                  remove ref_counts -= [r => let rc];\n                  add ref_counts += [r => rc - 1];\n                  assert(rc > 0) by {\n                      assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                  };\n              }\n           }\n#[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n               &&& 0 < self.rc_width             &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)         }\n#[invariant]\n        pub fn exc_inv(&self) -> bool {\n               &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)             &&& self.storage is Some <==> self.exc_guard is None             &&& if let Option::Some(cur_r) = self.exc_pending {\n                  &&& 0 <= cur_r <= self.rc_width                 &&& self.exc_guard is None                 &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)             }\n   else {\n                  true             }\n           }\n#[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n               forall |v|       \n#[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)         }\n            pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n               shared_guard.filter(|val: (int, T)| val.0 == r)         }\n#[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n               forall |r| 0 <= r < self.rc_width ==>                       \n#[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +                         Self::filter_r(self.shared_guard, r).len() as int         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n               assert forall |r| 0 <= r < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +                         Self::filter_r(post.shared_guard, r).len() as int             by {\n                  assert_multisets_equal!(                     Self::filter_r(post.shared_guard, r),                     Multiset::empty(),                 );\n              }\n           }\n#[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n           }\n#[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n               let prev_r = pre.exc_pending->0;\n               assert forall |x|       \n#[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false             by {\n                  assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n              }\n           }\n#[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n           }\n#[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n           }\n#[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) {\n   }\n#[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n               let t = pre.storage->0;\n               assert forall |r0| 0 <= r0 < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                  if r == r0 {\n                      assert_multisets_equal!(                         Self::filter_r(post.shared_guard, r),                         Self::filter_r(pre.shared_guard, r).add(                             Multiset::singleton((r, t)))                     );\n                  }\n  else {\n                      assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                  }\n              }\n           }\n#[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n               let r = val.0;\n               assert forall |r0| 0 <= r0 < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                  if r0 == r {\n                      assert_multisets_equal!(                         Self::filter_r(pre.shared_guard, r),                         Self::filter_r(post.shared_guard, r).add(                             Multiset::singleton(val))                     );\n                  }\n  else {\n                      assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                  }\n              }\n           }\n        }\n     }\n      struct_with_invariants!{\n         struct RwLock<T> {\n            inst: Tracked<DistRwLock::Instance<T>>,         exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,         ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,     }\n         spec fn wf(&self) -> bool {\n            invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n               g.instance_id() == inst@.id()             && g.value() == b         }\n            invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {\n               g.instance_id() == inst@.id()             && g.key() == i             && g.value() == v as int         }\n        }\n     }\n      impl<T> RwLock<T> {\n              fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n            let tracked inst;\n            let tracked exc_locked_token;\n            let tracked mut ref_counts_tokens;\n            proof {\n               let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n               inst = inst0;\n               exc_locked_token = exc_locked_token0;\n               ref_counts_tokens = ref_counts_tokens0;\n           }\n            let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n            let exc_locked_atomic = AtomicBool::new(             Ghost(tracked_inst),             false,             Tracked(exc_locked_token),         );\n            let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n            let mut i: usize = 0;\n            assert forall|j: int|             i <= j && j < rc_width implies       \n#[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)         by {\n           }\n            while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>       \n#[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),                 tracked_inst@ == inst,                 ref_counts_tokens.instance_id() == inst.id(),                 forall|j: int|                           \n#![trigger( ref_counts_tokens.dom().contains(j) )]\n#![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)                       && equal(ref_counts_tokens.index(j), 0)),         {\n               let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n               let rc_atomic = AtomicU64::new(                 Ghost((tracked_inst, i as int)),                 0,                 Tracked(ref_count_token),             );\n               v.push(rc_atomic);\n               i = i + 1;\n               assert forall|j: int|                 i <= j && j < rc_width implies       \n#[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)             by {\n              }\n           }\n            let s = RwLock {\n   inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n            s     }\n     }\n      }\n        fn main() {\n     }\n", "         use vstd::prelude::*;\n                fn main() {\n     }\n", "use vstd;\nfn main() {}\n"]}
{"id": "flat_combine_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// Based off of the FlatCombine system from Seagull-NR.\n// A major difference is that one didn't make any use of storage, because storage was\n// rather complicated to use, and it wasn't necessary.\n// Now, I expect storage to be a lot easier to use, easier than the alternative.\n\nverus! {\n\npub struct Request {\n    pub rid: int,\n    pub req: int,\n}\n\npub struct Response {\n    pub rid: int,\n    pub resp: int,\n}\n\n#[is_variant]\npub enum Client {\n    Idle,\n    Waiting { rid: int },\n}\n\n#[is_variant]\npub enum Combiner {\n    Collecting { elems: Seq<Option<int>> },\n    Responding { elems: Seq<Option<int>>, idx: nat },\n}\n\n} // verus!\ntokenized_state_machine! {\n    FlatCombiner {\n        fields {\n            #[sharding(constant)]\n            pub num_clients: nat,\n\n            #[sharding(map)]\n            pub clients: Map<nat, Client>,\n\n            #[sharding(map)]\n            pub slots: Map<nat, bool>,\n\n            #[sharding(variable)]\n            pub combiner: Combiner,\n\n            #[sharding(storage_map)]\n            pub requests: Map<nat, Request>,\n\n            #[sharding(storage_map)]\n            pub responses: Map<nat, Response>,\n        }\n\n        pub open spec fn valid_idx(self, i: nat) -> bool {\n            0 <= i && i < self.num_clients\n        }\n\n        #[invariant]\n        pub fn clients_complete(self) -> bool {\n            forall |i: nat| (0 <= i && i < self.num_clients) ==\n                self.clients.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn slots_complete(self) -> bool {\n            forall |i: nat| (0 <= i && i < self.num_clients) ==\n                self.slots.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn clients_size(self) -> bool {\n            match self.combiner {\n                Combiner::Collecting{elems} => elems.len() <= self.num_clients,\n                Combiner::Responding{elems, idx} => elems.len() == self.num_clients &&\n                    0 <= idx && idx <= self.num_clients,\n            }\n        }\n\n        /*\n        #[verifier::spec]\n        fn should_have_req_stored(self, i: nat) -> bool {\n            0 <= i\n            && i < self.slots\n            && self.slots.index(i)\n            && match self.combiner {\n                Combiner::Collecting{elems} => elems.len() < i || elems.index(i).is_None()\n                Combiner::Responding{elems, idx} => idx >= i || elems.index(i).is_None()\n            }\n        }\n        */\n\n        pub open spec fn client_waiting(self, i: nat) -> bool {\n            self.valid_idx(i)\n            && self.clients.index(i).is_Waiting()\n        }\n\n        pub open spec fn combiner_has(self, i: nat) -> bool {\n            self.valid_idx(i)\n            && match self.combiner {\n                Combiner::Collecting{elems} => i < elems.len() && elems.index(i as int).is_Some(),\n                Combiner::Responding{elems, idx} => i >= idx && elems.index(i as int).is_Some(),\n            }\n        }\n\n        pub open spec fn combiner_rid(self, i: nat) -> int {\n            match self.combiner {\n                Combiner::Collecting{elems} => elems.index(i as int).get_Some_0(),\n                Combiner::Responding{elems, idx} => elems.index(i as int).get_Some_0(),\n            }\n        }\n\n        pub open spec fn request_stored(self, i: nat) -> bool {\n            self.requests.dom().contains(i)\n        }\n\n        pub open spec fn response_stored(self, i: nat) -> bool {\n            self.responses.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)\n        }\n\n        #[invariant]\n        pub fn waiting_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)\n        }\n\n        #[invariant]\n        pub fn request_stored_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)\n                && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()\n                && self.slots.index(i)\n        }\n\n        #[invariant]\n        pub fn response_stored_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)\n                && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()\n                && !self.slots.index(i)\n        }\n\n\n        #[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)\n                && self.slots.index(i)\n                && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()\n                && !self.request_stored(i)\n        }\n\n        init!{\n            initialize(num_clients: nat) {\n                init num_clients = num_clients;\n                init clients = Map::new(\n                    |i: nat| 0 <= i && i < num_clients,\n                    |i: nat| Client::Idle);\n                init slots = Map::new(\n                    |i: nat| 0 <= i && i < num_clients,\n                    |i: nat| false);\n                init combiner = Combiner::Collecting { elems: Seq::empty() };\n                init requests = Map::empty();\n                init responses = Map::empty();\n            }\n        }\n\n        #[inductive(initialize)]\n        fn init_inductive(post: Self, num_clients: nat) { }\n\n        ///// Client transitions\n\n        transition!{\n            client_send(j: nat, request: Request, cur_slot: bool) {\n                require(0 <= j && j < pre.num_clients);\n\n                // Move client to 'waiting' state\n                remove clients -= [j => Client::Idle];\n                add    clients += [j => Client::Waiting{rid: request.rid}];\n\n                // Set the slot\n                remove slots -= [j => cur_slot];\n                add    slots += [j => true];\n\n                // deposit the request\n                deposit requests += [j => request] by {\n                    assert(!pre.request_stored(j));\n                };\n            }\n        }\n\n        #[inductive(client_send)]\n        fn client_send_inductive(pre: Self,\n            post: Self, j: nat, request: Request, cur_slot: bool)\n        {\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(pre.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(post.request_stored(j));\n            assert(post.client_waiting(j));\n\n            /*assert_forall_by(|i: nat| {\n                requires(post.client_waiting(i));\n                ensures(post.request_stored(i) || post.response_stored(i) || post.combiner_has(i));\n                if i == j {\n                    assert(post.request_stored(i));\n                } else {\n                    assert(pre.client_waiting(i));\n                    assert(post.request_stored(i) || post.response_stored(i) || post.combiner_has(i));\n                }\n            });*/\n        }\n\n        transition!{\n            client_recv(j: nat) {\n                require(0 <= j && j < pre.num_clients);\n\n                // Move client to 'idle' state\n                remove clients -= [j => let Client::Waiting{rid}];\n                add    clients += [j => Client::Idle];\n\n                // Check that the slot has been set back to 'false'\n                have slots >= [j => false];\n\n                // withdraw the response\n                withdraw responses -= [j => let response] by {\n                    assert(pre.client_waiting(j));\n                    //assert(!pre.request_stored(j));\n                    //assert(!pre.combiner_has(j));\n                    //assert(pre.response_stored(j));\n                };\n\n                // make sure we get back the response for the correct request id:\n                assert(response.rid == rid) by {\n                    assert(pre.client_waiting(j));\n                };\n            }\n        }\n\n        #[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(pre.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n\n            assert(!post.client_waiting(j));\n        }\n\n        ///// Combiner transitions\n\n        transition!{\n            combiner_recv() {\n                require(pre.combiner.is_Collecting());\n                let j = pre.combiner.get_Collecting_elems().len();\n                require(0 <= j && j < pre.num_clients);\n\n                // Observe that the slot has been set to 'true'\n                have slots >= [j => true];\n\n                // Withdraw a request\n                withdraw requests -= [j => let request] by {\n                    assert(pre.valid_idx(j));\n                    assert(pre.client_waiting(j));\n                    assert(pre.request_stored(j));\n                };\n\n                // Update combiner's local state to remember we withdrew a request with this ID\n                update combiner = Combiner::Collecting{\n                    elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),\n                };\n            }\n        }\n\n        #[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Collecting_elems().len();\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(pre.client_waiting(j));\n            assert(pre.request_stored(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_skip() {\n                require(pre.combiner.is_Collecting());\n                let j = pre.combiner.get_Collecting_elems().len();\n                require(0 <= j && j < pre.num_clients);\n\n                // In practice, this happens when slot j is set to false, so we could add this:\n                //    have slots >= [j => false];\n                // but it's not necessary\n\n                // Update combiner's local state to remember that we didn't withdraw\n                // anything here.\n                update combiner = Combiner::Collecting{\n                    elems: pre.combiner.get_Collecting_elems().push(Option::None),\n                };\n            }\n        }\n\n        #[inductive(combiner_skip)]\n        fn combiner_skip_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Collecting_elems().len();\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(!post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_go_to_responding() {\n                require(pre.combiner.is_Collecting());\n                require(pre.combiner.get_Collecting_elems().len() == pre.num_clients);\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Collecting_elems(),\n                    idx: 0,\n                };\n            }\n        }\n\n        transition!{\n            combiner_send(response: Response, cur_slot: bool) {\n                require(pre.combiner.is_Responding());\n                let j = pre.combiner.get_Responding_idx();\n                require(0 <= j && j < pre.num_clients);\n                let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n\n                // The response we return has to have the right request ID\n                require(response_opt === Option::Some(response.rid));\n\n                // Set the slot back to false\n                remove slots -= [j => cur_slot];\n                add    slots += [j => false];\n\n                // Update the combiner's local state\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Responding_elems(),\n                    idx: j + 1,\n                };\n\n                deposit responses += [j => response] by {\n                    assert(pre.valid_idx(j));\n                    assert(pre.combiner_has(j));\n                    assert(!pre.response_stored(j));\n                };\n            }\n        }\n\n        #[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n            let j = pre.combiner.get_Responding_idx();\n\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n\n            assert(pre.valid_idx(j));\n            assert(pre.combiner_has(j));\n            assert(pre.client_waiting(j));\n\n            assert(!post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_send_skip() {\n                require(pre.combiner.is_Responding());\n                let j = pre.combiner.get_Responding_idx();\n                require(0 <= j && j < pre.num_clients);\n                let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n\n                // The response we return has to have the right request ID\n                require(equal(response_opt, Option::None));\n\n                // Update the combiner's local state\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Responding_elems(),\n                    idx: j + 1,\n                };\n            }\n        }\n\n        #[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Responding_idx();\n\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(!post.combiner_has(j));\n        }\n\n        #[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_responding_inductive(pre: Self, post: Self) {\n            assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n            assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n        }\n\n        transition!{\n            combiner_go_to_collecting() {\n                require(pre.combiner.is_Responding());\n                require(pre.combiner.get_Responding_idx() == pre.num_clients);\n                update combiner = Combiner::Collecting{ elems: Seq::empty() };\n            }\n        }\n\n        #[inductive(combiner_go_to_collecting)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n            assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n            assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n        }\n\n    }\n}\n\nfn main() {}\n", "minimized_code": " use vstd::prelude::*;\n     use verus_state_machines_macros::tokenized_state_machine;\n     verus! {\n    pub struct Request {\n       pub rid: int,     pub req: int, }\n    pub struct Response {\n       pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n       Idle,     Waiting {\n  rid: int }\n  , }\n#[is_variant]\npub enum Combiner {\n       Collecting {\n  elems: Seq<Option<int>> }\n  ,     Responding {\n  elems: Seq<Option<int>>, idx: nat }\n  , }\n    }\n      tokenized_state_machine! {\n        FlatCombiner {\n           fields {\n#[sharding(constant)]\n            pub num_clients: nat,                 \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                 \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                 \n#[sharding(variable)]\n            pub combiner: Combiner,                 \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                 \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n           pub open spec fn valid_idx(self, i: nat) -> bool {\n              0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.len() <= self.num_clients,                 Combiner::Responding{elems, idx}\n => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n          }\n           pub open spec fn client_waiting(self, i: nat) -> bool {\n              self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n           pub open spec fn combiner_has(self, i: nat) -> bool {\n              self.valid_idx(i)             && match self.combiner {\n                 Combiner::Collecting{elems}\n => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{elems, idx}\n => i >= idx && elems.index(i as int).is_Some(),             }\n          }\n           pub open spec fn combiner_rid(self, i: nat) -> int {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.index(i as int).get_Some_0(),                 Combiner::Responding{elems, idx}\n => elems.index(i as int).get_Some_0(),             }\n          }\n           pub open spec fn request_stored(self, i: nat) -> bool {\n              self.requests.dom().contains(i)         }\n           pub open spec fn response_stored(self, i: nat) -> bool {\n              self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         }\n#[invariant]\n        pub fn request_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         }\n#[invariant]\n        pub fn response_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n           transition!{\n              client_send(j: nat, request: Request, cur_slot: bool) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => Client::Idle];\n                 add    clients += [j => Client::Waiting{rid: request.rid}\n];\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => true];\n                 deposit requests += [j => request] by {                     assert(!pre.request_stored(j));                 };\n             }\n          }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              client_recv(j: nat) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => let Client::Waiting{rid}\n];\n                 add    clients += [j => Client::Idle];\n                 have slots >= [j => false];\n                 withdraw responses -= [j => let response] by {                     assert(pre.client_waiting(j));                 };\n                 assert(response.rid == rid) by {                     assert(pre.client_waiting(j));                 };\n             }\n          }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_recv() {\n                 require(pre.combiner.is_Collecting());\n                 let j = pre.combiner.get_Collecting_elems().len();\n                 require(0 <= j && j < pre.num_clients);\n                 have slots >= [j => true];\n                 withdraw requests -= [j => let request] by {                     assert(pre.valid_idx(j));                     assert(pre.client_waiting(j));                     assert(pre.request_stored(j));                 };\n                 update combiner = Combiner::Collecting{                     elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n             }\n          }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n              let j = pre.combiner.get_Collecting_elems().len();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_go_to_responding() {\n                 require(pre.combiner.is_Collecting());\n                 require(pre.combiner.get_Collecting_elems().len() == pre.num_clients);\n                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Collecting_elems(),                     idx: 0,                 };\n             }\n          }\n           transition!{\n              combiner_send(response: Response, cur_slot: bool) {\n                 require(pre.combiner.is_Responding());\n                 let j = pre.combiner.get_Responding_idx();\n                 require(0 <= j && j < pre.num_clients);\n                 let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                 require(response_opt === Option::Some(response.rid));\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => false];\n                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };\n                 deposit responses += [j => response] by {                     assert(pre.valid_idx(j));                     assert(pre.combiner_has(j));                     assert(!pre.response_stored(j));                 };\n             }\n          }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n              let j = pre.combiner.get_Responding_idx();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n              assert(!post.combiner_has(j));\n          }\n           transition!{\n              combiner_send_skip() {\n                 require(pre.combiner.is_Responding());\n             }\n          }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n          }\n       }\n    }\n     fn main() {\n   }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/flat_combine.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1652, "minimize_time_ms": 2099910, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 461, "minimized_LOC": 200, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::map::", "vstd::multiset::", "vstd::prelude::", "vstd::seq::", "vstd::", "verus_state_machines_macros::tokenized_state_machine"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.43383947939262474}, "labeling": {"segments": {"exec": " pub fn clients_size(self) -> bool {\n\n pub fn not_waiting_inv(self) -> bool {\n\n pub fn waiting_inv(self) -> bool {\n\n pub fn request_stored_inv(self) -> bool {\n\n pub fn response_stored_inv(self) -> bool {\n\n pub fn combiner_has_inv(self) -> bool {\n\n fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n\n fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n\n fn combiner_recv_inductive(pre: Self, post: Self) {\n\n fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n\n fn combiner_send_skip_inductive(pre: Self, post: Self) {\n\n fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n\n fn main() {", "spec": "spec fn valid_idx(self, i: nat) -> bool {\n\nspec fn client_waiting(self, i: nat) -> bool {\n\nspec fn combiner_has(self, i: nat) -> bool {\n\nspec fn combiner_rid(self, i: nat) -> int {\n\nspec fn request_stored(self, i: nat) -> bool {\n\nspec fn response_stored(self, i: nat) -> bool {\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]"}}}, "all_snapshots": ["// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// Based off of the FlatCombine system from Seagull-NR.\n// A major difference is that one didn't make any use of storage, because storage was\n// rather complicated to use, and it wasn't necessary.\n// Now, I expect storage to be a lot easier to use, easier than the alternative.\n\nverus! {\n\npub struct Request {\n    pub rid: int,\n    pub req: int,\n}\n\npub struct Response {\n    pub rid: int,\n    pub resp: int,\n}\n\n#[is_variant]\npub enum Client {\n    Idle,\n    Waiting { rid: int },\n}\n\n#[is_variant]\npub enum Combiner {\n    Collecting { elems: Seq<Option<int>> },\n    Responding { elems: Seq<Option<int>>, idx: nat },\n}\n\n} // verus!\ntokenized_state_machine! {\n    FlatCombiner {\n        fields {\n            #[sharding(constant)]\n            pub num_clients: nat,\n\n            #[sharding(map)]\n            pub clients: Map<nat, Client>,\n\n            #[sharding(map)]\n            pub slots: Map<nat, bool>,\n\n            #[sharding(variable)]\n            pub combiner: Combiner,\n\n            #[sharding(storage_map)]\n            pub requests: Map<nat, Request>,\n\n            #[sharding(storage_map)]\n            pub responses: Map<nat, Response>,\n        }\n\n        pub open spec fn valid_idx(self, i: nat) -> bool {\n            0 <= i && i < self.num_clients\n        }\n\n        #[invariant]\n        pub fn clients_complete(self) -> bool {\n            forall |i: nat| (0 <= i && i < self.num_clients) ==\n                self.clients.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn slots_complete(self) -> bool {\n            forall |i: nat| (0 <= i && i < self.num_clients) ==\n                self.slots.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn clients_size(self) -> bool {\n            match self.combiner {\n                Combiner::Collecting{elems} => elems.len() <= self.num_clients,\n                Combiner::Responding{elems, idx} => elems.len() == self.num_clients &&\n                    0 <= idx && idx <= self.num_clients,\n            }\n        }\n\n        /*\n        #[verifier::spec]\n        fn should_have_req_stored(self, i: nat) -> bool {\n            0 <= i\n            && i < self.slots\n            && self.slots.index(i)\n            && match self.combiner {\n                Combiner::Collecting{elems} => elems.len() < i || elems.index(i).is_None()\n                Combiner::Responding{elems, idx} => idx >= i || elems.index(i).is_None()\n            }\n        }\n        */\n\n        pub open spec fn client_waiting(self, i: nat) -> bool {\n            self.valid_idx(i)\n            && self.clients.index(i).is_Waiting()\n        }\n\n        pub open spec fn combiner_has(self, i: nat) -> bool {\n            self.valid_idx(i)\n            && match self.combiner {\n                Combiner::Collecting{elems} => i < elems.len() && elems.index(i as int).is_Some(),\n                Combiner::Responding{elems, idx} => i >= idx && elems.index(i as int).is_Some(),\n            }\n        }\n\n        pub open spec fn combiner_rid(self, i: nat) -> int {\n            match self.combiner {\n                Combiner::Collecting{elems} => elems.index(i as int).get_Some_0(),\n                Combiner::Responding{elems, idx} => elems.index(i as int).get_Some_0(),\n            }\n        }\n\n        pub open spec fn request_stored(self, i: nat) -> bool {\n            self.requests.dom().contains(i)\n        }\n\n        pub open spec fn response_stored(self, i: nat) -> bool {\n            self.responses.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)\n        }\n\n        #[invariant]\n        pub fn waiting_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)\n        }\n\n        #[invariant]\n        pub fn request_stored_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)\n                && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()\n                && self.slots.index(i)\n        }\n\n        #[invariant]\n        pub fn response_stored_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)\n                && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()\n                && !self.slots.index(i)\n        }\n\n\n        #[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)\n                && self.slots.index(i)\n                && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()\n                && !self.request_stored(i)\n        }\n\n        init!{\n            initialize(num_clients: nat) {\n                init num_clients = num_clients;\n                init clients = Map::new(\n                    |i: nat| 0 <= i && i < num_clients,\n                    |i: nat| Client::Idle);\n                init slots = Map::new(\n                    |i: nat| 0 <= i && i < num_clients,\n                    |i: nat| false);\n                init combiner = Combiner::Collecting { elems: Seq::empty() };\n                init requests = Map::empty();\n                init responses = Map::empty();\n            }\n        }\n\n        #[inductive(initialize)]\n        fn init_inductive(post: Self, num_clients: nat) { }\n\n        ///// Client transitions\n\n        transition!{\n            client_send(j: nat, request: Request, cur_slot: bool) {\n                require(0 <= j && j < pre.num_clients);\n\n                // Move client to 'waiting' state\n                remove clients -= [j => Client::Idle];\n                add    clients += [j => Client::Waiting{rid: request.rid}];\n\n                // Set the slot\n                remove slots -= [j => cur_slot];\n                add    slots += [j => true];\n\n                // deposit the request\n                deposit requests += [j => request] by {\n                    assert(!pre.request_stored(j));\n                };\n            }\n        }\n\n        #[inductive(client_send)]\n        fn client_send_inductive(pre: Self,\n            post: Self, j: nat, request: Request, cur_slot: bool)\n        {\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(pre.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(post.request_stored(j));\n            assert(post.client_waiting(j));\n\n            /*assert_forall_by(|i: nat| {\n                requires(post.client_waiting(i));\n                ensures(post.request_stored(i) || post.response_stored(i) || post.combiner_has(i));\n                if i == j {\n                    assert(post.request_stored(i));\n                } else {\n                    assert(pre.client_waiting(i));\n                    assert(post.request_stored(i) || post.response_stored(i) || post.combiner_has(i));\n                }\n            });*/\n        }\n\n        transition!{\n            client_recv(j: nat) {\n                require(0 <= j && j < pre.num_clients);\n\n                // Move client to 'idle' state\n                remove clients -= [j => let Client::Waiting{rid}];\n                add    clients += [j => Client::Idle];\n\n                // Check that the slot has been set back to 'false'\n                have slots >= [j => false];\n\n                // withdraw the response\n                withdraw responses -= [j => let response] by {\n                    assert(pre.client_waiting(j));\n                    //assert(!pre.request_stored(j));\n                    //assert(!pre.combiner_has(j));\n                    //assert(pre.response_stored(j));\n                };\n\n                // make sure we get back the response for the correct request id:\n                assert(response.rid == rid) by {\n                    assert(pre.client_waiting(j));\n                };\n            }\n        }\n\n        #[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(pre.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n\n            assert(!post.client_waiting(j));\n        }\n\n        ///// Combiner transitions\n\n        transition!{\n            combiner_recv() {\n                require(pre.combiner.is_Collecting());\n                let j = pre.combiner.get_Collecting_elems().len();\n                require(0 <= j && j < pre.num_clients);\n\n                // Observe that the slot has been set to 'true'\n                have slots >= [j => true];\n\n                // Withdraw a request\n                withdraw requests -= [j => let request] by {\n                    assert(pre.valid_idx(j));\n                    assert(pre.client_waiting(j));\n                    assert(pre.request_stored(j));\n                };\n\n                // Update combiner's local state to remember we withdrew a request with this ID\n                update combiner = Combiner::Collecting{\n                    elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),\n                };\n            }\n        }\n\n        #[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Collecting_elems().len();\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(pre.client_waiting(j));\n            assert(pre.request_stored(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_skip() {\n                require(pre.combiner.is_Collecting());\n                let j = pre.combiner.get_Collecting_elems().len();\n                require(0 <= j && j < pre.num_clients);\n\n                // In practice, this happens when slot j is set to false, so we could add this:\n                //    have slots >= [j => false];\n                // but it's not necessary\n\n                // Update combiner's local state to remember that we didn't withdraw\n                // anything here.\n                update combiner = Combiner::Collecting{\n                    elems: pre.combiner.get_Collecting_elems().push(Option::None),\n                };\n            }\n        }\n\n        #[inductive(combiner_skip)]\n        fn combiner_skip_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Collecting_elems().len();\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(!post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_go_to_responding() {\n                require(pre.combiner.is_Collecting());\n                require(pre.combiner.get_Collecting_elems().len() == pre.num_clients);\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Collecting_elems(),\n                    idx: 0,\n                };\n            }\n        }\n\n        transition!{\n            combiner_send(response: Response, cur_slot: bool) {\n                require(pre.combiner.is_Responding());\n                let j = pre.combiner.get_Responding_idx();\n                require(0 <= j && j < pre.num_clients);\n                let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n\n                // The response we return has to have the right request ID\n                require(response_opt === Option::Some(response.rid));\n\n                // Set the slot back to false\n                remove slots -= [j => cur_slot];\n                add    slots += [j => false];\n\n                // Update the combiner's local state\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Responding_elems(),\n                    idx: j + 1,\n                };\n\n                deposit responses += [j => response] by {\n                    assert(pre.valid_idx(j));\n                    assert(pre.combiner_has(j));\n                    assert(!pre.response_stored(j));\n                };\n            }\n        }\n\n        #[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n            let j = pre.combiner.get_Responding_idx();\n\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n\n            assert(pre.valid_idx(j));\n            assert(pre.combiner_has(j));\n            assert(pre.client_waiting(j));\n\n            assert(!post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_send_skip() {\n                require(pre.combiner.is_Responding());\n                let j = pre.combiner.get_Responding_idx();\n                require(0 <= j && j < pre.num_clients);\n                let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n\n                // The response we return has to have the right request ID\n                require(equal(response_opt, Option::None));\n\n                // Update the combiner's local state\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Responding_elems(),\n                    idx: j + 1,\n                };\n            }\n        }\n\n        #[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Responding_idx();\n\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(!post.combiner_has(j));\n        }\n\n        #[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_responding_inductive(pre: Self, post: Self) {\n            assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n            assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n        }\n\n        transition!{\n            combiner_go_to_collecting() {\n                require(pre.combiner.is_Responding());\n                require(pre.combiner.get_Responding_idx() == pre.num_clients);\n                update combiner = Combiner::Collecting{ elems: Seq::empty() };\n            }\n        }\n\n        #[inductive(combiner_go_to_collecting)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n            assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n            assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n        }\n\n    }\n}\n\nfn main() {}\n", "use vstd;\nfn main() {}\n", " use vstd::prelude::*;\n     use verus_state_machines_macros::tokenized_state_machine;\n     verus! {\n    pub struct Request {\n       pub rid: int,     pub req: int, }\n    pub struct Response {\n       pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n       Idle,     Waiting {\n  rid: int }\n  , }\n#[is_variant]\npub enum Combiner {\n       Collecting {\n  elems: Seq<Option<int>> }\n  ,     Responding {\n  elems: Seq<Option<int>>, idx: nat }\n  , }\n    }\n      tokenized_state_machine! {\n        FlatCombiner {\n           fields {\n#[sharding(constant)]\n            pub num_clients: nat,                 \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                 \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                 \n#[sharding(variable)]\n            pub combiner: Combiner,                 \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                 \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n           pub open spec fn valid_idx(self, i: nat) -> bool {\n              0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.len() <= self.num_clients,                 Combiner::Responding{elems, idx}\n => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n          }\n           pub open spec fn client_waiting(self, i: nat) -> bool {\n              self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n           pub open spec fn combiner_has(self, i: nat) -> bool {\n              self.valid_idx(i)             && match self.combiner {\n                 Combiner::Collecting{elems}\n => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{elems, idx}\n => i >= idx && elems.index(i as int).is_Some(),             }\n          }\n           pub open spec fn combiner_rid(self, i: nat) -> int {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.index(i as int).get_Some_0(),                 Combiner::Responding{elems, idx}\n => elems.index(i as int).get_Some_0(),             }\n          }\n           pub open spec fn request_stored(self, i: nat) -> bool {\n              self.requests.dom().contains(i)         }\n           pub open spec fn response_stored(self, i: nat) -> bool {\n              self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         }\n#[invariant]\n        pub fn request_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         }\n#[invariant]\n        pub fn response_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n           transition!{\n              client_send(j: nat, request: Request, cur_slot: bool) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => Client::Idle];\n                 add    clients += [j => Client::Waiting{rid: request.rid}\n];\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => true];\n                 deposit requests += [j => request] by {                     assert(!pre.request_stored(j));                 };\n             }\n          }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              client_recv(j: nat) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => let Client::Waiting{rid}\n];\n                 add    clients += [j => Client::Idle];\n                 have slots >= [j => false];\n                 withdraw responses -= [j => let response] by {                     assert(pre.client_waiting(j));                 };\n                 assert(response.rid == rid) by {                     assert(pre.client_waiting(j));                 };\n             }\n          }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_recv() {\n                 require(pre.combiner.is_Collecting());\n                 let j = pre.combiner.get_Collecting_elems().len();\n                 require(0 <= j && j < pre.num_clients);\n                 have slots >= [j => true];\n                 withdraw requests -= [j => let request] by {                     assert(pre.valid_idx(j));                     assert(pre.client_waiting(j));                     assert(pre.request_stored(j));                 };\n                 update combiner = Combiner::Collecting{                     elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n             }\n          }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n              let j = pre.combiner.get_Collecting_elems().len();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_go_to_responding() {\n                 require(pre.combiner.is_Collecting());\n                 require(pre.combiner.get_Collecting_elems().len() == pre.num_clients);\n                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Collecting_elems(),                     idx: 0,                 };\n             }\n          }\n           transition!{\n              combiner_send(response: Response, cur_slot: bool) {\n                 require(pre.combiner.is_Responding());\n                 let j = pre.combiner.get_Responding_idx();\n                 require(0 <= j && j < pre.num_clients);\n                 let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                 require(response_opt === Option::Some(response.rid));\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => false];\n                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };\n                 deposit responses += [j => response] by {                     assert(pre.valid_idx(j));                     assert(pre.combiner_has(j));                     assert(!pre.response_stored(j));                 };\n             }\n          }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n              let j = pre.combiner.get_Responding_idx();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n              assert(!post.combiner_has(j));\n          }\n           transition!{\n              combiner_send_skip() {\n                 require(pre.combiner.is_Responding());\n             }\n          }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n          }\n       }\n    }\n     fn main() {\n   }\n", " use vstd::prelude::*;\n     use verus_state_machines_macros::tokenized_state_machine;\n     verus! {\n    pub struct Request {\n       pub rid: int,     pub req: int, }\n    pub struct Response {\n       pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n       Idle,     Waiting {\n  rid: int }\n  , }\n#[is_variant]\npub enum Combiner {\n       Collecting {\n  elems: Seq<Option<int>> }\n  ,     Responding {\n  elems: Seq<Option<int>>, idx: nat }\n  , }\n    }\n      tokenized_state_machine! {\n        FlatCombiner {\n           fields {\n#[sharding(constant)]\n            pub num_clients: nat,                 \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                 \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                 \n#[sharding(variable)]\n            pub combiner: Combiner,                 \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                 \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n           pub open spec fn valid_idx(self, i: nat) -> bool {\n              0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.len() <= self.num_clients,                 Combiner::Responding{elems, idx}\n => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n          }\n           pub open spec fn client_waiting(self, i: nat) -> bool {\n              self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n           pub open spec fn combiner_has(self, i: nat) -> bool {\n              self.valid_idx(i)             && match self.combiner {\n                 Combiner::Collecting{elems}\n => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{elems, idx}\n => i >= idx && elems.index(i as int).is_Some(),             }\n          }\n           pub open spec fn combiner_rid(self, i: nat) -> int {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.index(i as int).get_Some_0(),                 Combiner::Responding{elems, idx}\n => elems.index(i as int).get_Some_0(),             }\n          }\n           pub open spec fn request_stored(self, i: nat) -> bool {\n              self.requests.dom().contains(i)         }\n           pub open spec fn response_stored(self, i: nat) -> bool {\n              self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         }\n#[invariant]\n        pub fn request_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         }\n#[invariant]\n        pub fn response_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n           transition!{\n              client_send(j: nat, request: Request, cur_slot: bool) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => Client::Idle];\n                 add    clients += [j => Client::Waiting{rid: request.rid}\n];\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => true];\n                 deposit requests += [j => request] by {                     assert(!pre.request_stored(j));                 };\n             }\n          }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              client_recv(j: nat) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => let Client::Waiting{rid}\n];\n                 add    clients += [j => Client::Idle];\n                 have slots >= [j => false];\n                 withdraw responses -= [j => let response] by {                     assert(pre.client_waiting(j));                 };\n             }\n          }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_recv() {\n                 require(pre.combiner.is_Collecting());\n                 let j = pre.combiner.get_Collecting_elems().len();\n                 require(0 <= j && j < pre.num_clients);\n                 have slots >= [j => true];\n                 withdraw requests -= [j => let request] by {                     assert(pre.valid_idx(j));                     assert(pre.client_waiting(j));                     assert(pre.request_stored(j));                 };\n                 update combiner = Combiner::Collecting{                     elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n             }\n          }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n              let j = pre.combiner.get_Collecting_elems().len();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_go_to_responding() {\n             }\n          }\n           transition!{\n              combiner_send(response: Response, cur_slot: bool) {\n                 require(pre.combiner.is_Responding());\n                 let j = pre.combiner.get_Responding_idx();\n                 require(0 <= j && j < pre.num_clients);\n                 let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                 require(response_opt === Option::Some(response.rid));\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => false];\n                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };\n                 deposit responses += [j => response] by {                     assert(pre.valid_idx(j));                     assert(pre.combiner_has(j));                     assert(!pre.response_stored(j));                 };\n             }\n          }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n              let j = pre.combiner.get_Responding_idx();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n              assert(!post.combiner_has(j));\n          }\n           transition!{\n              combiner_send_skip() {\n             }\n          }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n          }\n       }\n    }\n     fn main() {\n   }\n", " use vstd::prelude::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n        verus! {\n       pub struct Request {\n          pub rid: int,     pub req: int, }\n       pub struct Response {\n          pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n          Idle,     Waiting {\n     rid: int }\n     , }\n#[is_variant]\npub enum Combiner {\n          Collecting {\n     elems: Seq<Option<int>> }\n     ,     Responding {\n     elems: Seq<Option<int>>, idx: nat }\n     , }\n       }\n         tokenized_state_machine! {\n           FlatCombiner {\n              fields {\n#[sharding(constant)]\n            pub num_clients: nat,                    \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                    \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                    \n#[sharding(variable)]\n            pub combiner: Combiner,                    \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                    \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n              pub open spec fn valid_idx(self, i: nat) -> bool {\n                 0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                 match self.combiner {\n                    Combiner::Collecting{\n  elems}\n    => elems.len() <= self.num_clients,                 Combiner::Responding{\n  elems, idx}\n    => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n             }\n              pub open spec fn client_waiting(self, i: nat) -> bool {\n                 self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n              pub open spec fn combiner_has(self, i: nat) -> bool {\n                 self.valid_idx(i)             && match self.combiner {\n                    Combiner::Collecting{\n  elems}\n    => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{\n  elems, idx}\n    => i >= idx && elems.index(i as int).is_Some(),             }\n             }\n              pub open spec fn combiner_rid(self, i: nat) -> int {\n                 match self.combiner {\n                    Combiner::Collecting{\n  elems}\n    => elems.index(i as int).get_Some_0(),                 Combiner::Responding{\n  elems, idx}\n    => elems.index(i as int).get_Some_0(),             }\n             }\n              pub open spec fn request_stored(self, i: nat) -> bool {\n                 self.requests.dom().contains(i)         }\n              pub open spec fn response_stored(self, i: nat) -> bool {\n                 self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         }\n#[invariant]\n        pub fn request_stored_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         }\n#[invariant]\n        pub fn response_stored_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n              transition!{\n                 client_send(j: nat, request: Request, cur_slot: bool) {}\n             }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {}\n              transition!{\n                 client_recv(j: nat) {}\n             }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {}\n              transition!{\n                 combiner_recv() {\n                    require(pre.combiner.is_Collecting());\n                    let j = pre.combiner.get_Collecting_elems().len();\n                    require(0 <= j && j < pre.num_clients);\n                    have slots >= [j => true];\n                    withdraw requests -= [j => let request] by {\n                       assert(pre.valid_idx(j));\n                       assert(pre.client_waiting(j));\n                   };\n                    update combiner = Combiner::Collecting{\n                       elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n                }\n             }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n                 let j = pre.combiner.get_Collecting_elems().len();\n                 assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n                 assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n                 assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n                 assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n                 assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n             }\n              transition!{\n                 combiner_go_to_responding() {}\n             }\n              transition!{\n                 combiner_send(response: Response, cur_slot: bool) {\n                    require(pre.combiner.is_Responding());\n                    let j = pre.combiner.get_Responding_idx();\n                    require(0 <= j && j < pre.num_clients);\n                    let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                    require(response_opt === Option::Some(response.rid));\n                    remove slots -= [j => cur_slot];\n                    add    slots += [j => false];\n                    update combiner = Combiner::Responding{\n                       elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };\n                    deposit responses += [j => response] by {\n                       assert(pre.combiner_has(j));\n                       assert(!pre.response_stored(j));\n                   };\n                }\n             }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n                 let j = pre.combiner.get_Responding_idx();\n                 assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n                 assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n                 assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n                 assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n                 assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n                 assert(!post.combiner_has(j));\n             }\n              transition!{\n                 combiner_send_skip() {}\n             }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {}\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {}\n          }\n       }\n        fn main() {}\n", " use vstd::prelude::*;\n         use verus_state_machines_macros::tokenized_state_machine;\n         verus! {        pub struct Request {           pub rid: int,     pub req: int, }        pub struct Response {           pub rid: int,     pub resp: int, } \n#[is_variant]\npub enum Client {           Idle,     Waiting {      rid: int }      , } \n#[is_variant]\npub enum Combiner {           Collecting {      elems: Seq<Option<int>> }      ,     Responding {      elems: Seq<Option<int>>, idx: nat }      , }        }\n          tokenized_state_machine! {            FlatCombiner {               fields { \n#[sharding(constant)]\n            pub num_clients: nat,                     \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                     \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                     \n#[sharding(variable)]\n            pub combiner: Combiner,                     \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                     \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }               pub open spec fn valid_idx(self, i: nat) -> bool {                  0 <= i && i < self.num_clients         } \n#[invariant]\n        pub fn clients_size(self) -> bool {                  match self.combiner {                     Combiner::Collecting{   elems}     => elems.len() <= self.num_clients,                 Combiner::Responding{   elems, idx}     => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }              }               pub open spec fn client_waiting(self, i: nat) -> bool {                  self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }               pub open spec fn combiner_has(self, i: nat) -> bool {                  self.valid_idx(i)             && match self.combiner {                     Combiner::Collecting{   elems}     => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{   elems, idx}     => i >= idx && elems.index(i as int).is_Some(),             }              }               pub open spec fn combiner_rid(self, i: nat) -> int {                  match self.combiner {                     Combiner::Collecting{   elems}     => elems.index(i as int).get_Some_0(),                 Combiner::Responding{   elems, idx}     => elems.index(i as int).get_Some_0(),             }              }               pub open spec fn request_stored(self, i: nat) -> bool {                  self.requests.dom().contains(i)         }               pub open spec fn response_stored(self, i: nat) -> bool {                  self.responses.dom().contains(i)         } \n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         } \n#[invariant]\n        pub fn waiting_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         } \n#[invariant]\n        pub fn request_stored_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         } \n#[invariant]\n        pub fn response_stored_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         } \n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }               transition!{                  client_send(j: nat, request: Request, cur_slot: bool) {}              } \n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {}               transition!{                  client_recv(j: nat) {}              } \n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {}               transition!{                  combiner_recv() {                     require(pre.combiner.is_Collecting());                     let j = pre.combiner.get_Collecting_elems().len();                     require(0 <= j && j < pre.num_clients);                     have slots >= [j => true];                     withdraw requests -= [j => let request] by {                        assert(pre.valid_idx(j));                        assert(pre.client_waiting(j));                    };                     update combiner = Combiner::Collecting{                        elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };                 }              } \n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {                  let j = pre.combiner.get_Collecting_elems().len();                  assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));                  assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));                  assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));                  assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));                  assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));              }               transition!{                  combiner_go_to_responding() {}              }               transition!{                  combiner_send(response: Response, cur_slot: bool) {                     require(pre.combiner.is_Responding());                     let j = pre.combiner.get_Responding_idx();                     require(0 <= j && j < pre.num_clients);                     let response_opt = pre.combiner.get_Responding_elems().index(j as int);                     require(response_opt === Option::Some(response.rid));                     remove slots -= [j => cur_slot];                     add    slots += [j => false];                     update combiner = Combiner::Responding{                        elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };                     deposit responses += [j => response] by {                        assert(pre.combiner_has(j));                        assert(!pre.response_stored(j));                    };                 }              } \n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {                  let j = pre.combiner.get_Responding_idx();                  assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));                  assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));                  assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));                  assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));                  assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));                  assert(!post.combiner_has(j));              }               transition!{                  combiner_send_skip() {}              } \n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {} \n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {}           }        }\n         fn main() {}\n", " use vstd::prelude::*;\n             use verus_state_machines_macros::tokenized_state_machine;\n             verus! {\n           pub struct Request {\n             pub rid: int,     pub req: int, }\n           pub struct Response {\n             pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n             Idle,     Waiting {\n       rid: int }\n        , }\n#[is_variant]\npub enum Combiner {\n             Collecting {\n       elems: Seq<Option<int>> }\n        ,     Responding {\n       elems: Seq<Option<int>>, idx: nat }\n        , }\n           }\n              tokenized_state_machine! {\n               FlatCombiner {\n                 fields {\n#[sharding(constant)]\n            pub num_clients: nat,                         \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                         \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                         \n#[sharding(variable)]\n            pub combiner: Combiner,                         \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                         \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n                 pub open spec fn valid_idx(self, i: nat) -> bool {\n                   0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                   match self.combiner {\n                     Combiner::Collecting{   elems}\n     => elems.len() <= self.num_clients,                 Combiner::Responding{   elems, idx}\n     => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n               }\n                 pub open spec fn client_waiting(self, i: nat) -> bool {\n                   self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n                 pub open spec fn combiner_has(self, i: nat) -> bool {\n                   self.valid_idx(i)             && match self.combiner {\n                     Combiner::Collecting{   elems}\n     => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{   elems, idx}\n     => i >= idx && elems.index(i as int).is_Some(),             }\n               }\n                 pub open spec fn combiner_rid(self, i: nat) -> int {\n                   match self.combiner {\n                     Combiner::Collecting{   elems}\n     => elems.index(i as int).get_Some_0(),                 Combiner::Responding{   elems, idx}\n     => elems.index(i as int).get_Some_0(),             }\n               }\n                 pub open spec fn request_stored(self, i: nat) -> bool {\n                   self.requests.dom().contains(i)         }\n                 pub open spec fn response_stored(self, i: nat) -> bool {\n                   self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.client_waiting(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n                 transition!{\n                   client_send(j: nat, request: Request, cur_slot: bool) {\n}\n               }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n }\n                 transition!{\n                   client_recv(j: nat) {\n}\n               }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n }\n                 transition!{\n                   combiner_recv() {\n                     require(pre.combiner.is_Collecting());\n                     let j = pre.combiner.get_Collecting_elems().len();\n                     require(0 <= j && j < pre.num_clients);\n                     have slots >= [j => true];\n                     withdraw requests -= [j => let request] by {                        assert(pre.valid_idx(j));                        assert(pre.client_waiting(j));                    };\n                     update combiner = Combiner::Collecting{                        elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n                 }\n               }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n                   let j = pre.combiner.get_Collecting_elems().len();\n                   assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n                   assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n                   assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n                   assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n                   assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n               }\n                 transition!{\n                   combiner_go_to_responding() {\n}\n               }\n                 transition!{\n                   combiner_send(response: Response, cur_slot: bool) {\n                     require(pre.combiner.is_Responding());\n                     let j = pre.combiner.get_Responding_idx();\n                     require(0 <= j && j < pre.num_clients);\n                     let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                     require(response_opt === Option::Some(response.rid));\n                 }\n               }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n                   let j = pre.combiner.get_Responding_idx();\n                   assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n                   assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n                   assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n                   assert(!post.combiner_has(j));\n               }\n                 transition!{\n                   combiner_send_skip() {\n}\n               }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n }\n             }\n           }\n             fn main() {\n   }\n", " use vstd::prelude::*;\n             use verus_state_machines_macros::tokenized_state_machine;\n             verus! {\n           pub struct Request {\n             pub rid: int,     pub req: int, }\n           pub struct Response {\n             pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n             Idle,     Waiting {\n       rid: int }\n        , }\n#[is_variant]\npub enum Combiner {\n             Collecting {\n       elems: Seq<Option<int>> }\n        ,     Responding {\n       elems: Seq<Option<int>>, idx: nat }\n        , }\n           }\n              tokenized_state_machine! {\n               FlatCombiner {\n                 fields {\n#[sharding(constant)]\n            pub num_clients: nat,                         \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                         \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                         \n#[sharding(variable)]\n            pub combiner: Combiner,                         \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n                 pub open spec fn valid_idx(self, i: nat) -> bool {\n                   0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                   match self.combiner {\n                     Combiner::Collecting{   elems}\n     => elems.len() <= self.num_clients,                 Combiner::Responding{   elems, idx}\n     => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n               }\n                 pub open spec fn client_waiting(self, i: nat) -> bool {\n                   self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n                 pub open spec fn combiner_has(self, i: nat) -> bool {\n                   self.valid_idx(i)             && match self.combiner {\n                     Combiner::Collecting{   elems}\n     => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{   elems, idx}\n     => i >= idx && elems.index(i as int).is_Some(),             }\n               }\n                 pub open spec fn combiner_rid(self, i: nat) -> int {\n                   match self.combiner {\n                     Combiner::Collecting{   elems}\n     => elems.index(i as int).get_Some_0(),                 Combiner::Responding{   elems, idx}\n     => elems.index(i as int).get_Some_0(),             }\n               }\n                 pub open spec fn request_stored(self, i: nat) -> bool {\n                   self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.client_waiting(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n                 transition!{\n                   client_send(j: nat, request: Request, cur_slot: bool) {\n}\n               }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n }\n                 transition!{\n                   client_recv(j: nat) {\n}\n               }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n }\n                 transition!{\n                   combiner_recv() {\n                 }\n               }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n                   let j = pre.combiner.get_Collecting_elems().len();\n                   assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n               }\n                 transition!{\n                   combiner_go_to_responding() {\n}\n               }\n                 transition!{\n                   combiner_send(response: Response, cur_slot: bool) {\n                 }\n               }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n               }\n                 transition!{\n                   combiner_send_skip() {\n}\n               }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n }\n             }\n           }\n             fn main() {\n   }\n", " use vstd::prelude::*;\n              use verus_state_machines_macros::tokenized_state_machine;\n              verus! {\n            pub struct Request {\n              pub rid: int,     pub req: int, }\n            pub struct Response {\n              pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n              Idle,     Waiting {\n        rid: int }\n         , }\n pub enum Combiner {\n              Collecting {\n        elems: Seq<Option<int>> }\n         ,     Responding {\n        elems: Seq<Option<int>>, idx: nat }\n         , }\n            }\n               tokenized_state_machine! {\n                FlatCombiner {\n                  fields {\n#[sharding(constant)]\n            pub num_clients: nat,                          \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                          \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                          \n#[sharding(variable)]\n            pub combiner: Combiner,                          \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n                  pub open spec fn valid_idx(self, i: nat) -> bool {\n                    0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                    match self.combiner {\n                      Combiner::Collecting{\n   elems}\n      => elems.len() <= self.num_clients,                 Combiner::Responding{\n   elems, idx}\n      => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n                }\n                  pub open spec fn client_waiting(self, i: nat) -> bool {\n                    self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n                  pub open spec fn combiner_has(self, i: nat) -> bool {\n                    self.valid_idx(i)             && match self.combiner {\n                      Combiner::Collecting{\n   elems}\n      => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{\n   elems, idx}\n      => i >= idx && elems.index(i as int).is_Some(),             }\n                }\n                  pub open spec fn combiner_rid(self, i: nat) -> int {\n                    match self.combiner {\n                      Combiner::Collecting{\n   elems}\n      => elems.index(i as int).get_Some_0(),                 Combiner::Responding{\n   elems, idx}\n      => elems.index(i as int).get_Some_0(),             }\n                }\n                  pub open spec fn request_stored(self, i: nat) -> bool {\n                    self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                    forall |i: nat|                              self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n                  transition!{\n                    client_send(j: nat, request: Request, cur_slot: bool) {\n }\n                }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n  }\n                  transition!{\n                    client_recv(j: nat) {\n }\n                }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n  }\n                  transition!{\n                    combiner_recv() {\n                  }\n                }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n                }\n                  transition!{\n                    combiner_go_to_responding() {\n }\n                }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n  }\n              }\n            }\n              fn main() {\n    }\n", " use vstd::prelude::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                verus! {\n              struct Request {\n                ridreq: int}\n              struct Response {\n                ridresp: int}\n#[is_variant]\npub enum Client {\n                Waiting {\n          rid: int }\n           }\n   pub enum Combiner {\n                Collecting {\n          elems: Seq<Option<int>> }\n           ,     Responding {\n          elems: Seq<Option<int>>, idx: nat }\n           }\n              }\n                 tokenized_state_machine! {\n                  FlatCombiner {\n                    fields {\n#[sharding(constant)]\n            pub num_clients: nat,                            \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                            \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                            \n#[sharding(variable)]\n            pub combiner: Combiner,                            \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>}\n                    pub open spec fn valid_idx(self, i: nat) -> bool {\n                      0 <= self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                      match self.combiner {\n                        Combiner::Collecting{\n     elems}\n        => elems.len() <= self.num_clients,                 Combiner::Responding{\n     elems, idx}\n        => elems.len() <= self.num_clients}\n                  }\n                    pub open spec fn client_waiting(self, i: nat) -> bool {\n                      self.clients.index(i).is_Waiting()         }\n                    spec fn combiner_has(self, i: nat) -> bool {\n                      match self.combiner {\n                        Combiner::Collecting{\n     elems}\n        => elems.index(i as int).is_Some(),                 Combiner::Responding{\n     elems, idx}\n        => elems.index(i as int).is_Some()}\n                  }\n                    pub open spec fn combiner_rid(self, i: nat) -> int {\n                      match self.combiner {\n                        Combiner::Collecting{\n     elems}\n        => elems.index(i as int).get_Some_0(),                 Combiner::Responding{\n     elems, idx}\n        => elems.index(i as int).get_Some_0()}\n                  }\n                    pub open spec fn request_stored(self, i: nat) -> bool {\n                      self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                      forall |i|                              && (i) == self.clients.index(i).get_Waiting_rid()         }\n                    transition!{\n                      client_send(j: nat, request: Request, cur_slot: bool) {\n   }\n                  }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n    }\n                    transition!{\n                      client_recv(j: nat) {\n   }\n                  }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n    }\n                    fn combiner_recv_inductive(pre: Self, post: Self) {\n                  }\n                    fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n    }\n                }\n              }\n                fn main() {\n      }\n", " use vstd::prelude::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                verus! {\n              struct a {\n                 }\n              struct b {\n                 }\n#[is_variant]\npub enum c {\n                Waiting {\n          rid: int }\n           }\n   pub enum d {\n                e {\n          elems: Seq<Option<int>> }\n           ,     f {\n          elems: Seq<Option<int>>, g: nat }\n           }\n              }\n                 tokenized_state_machine! {\n                  h {\n                    fields {\n#[sharding(constant)]\n            pub k: nat,                            \n#[sharding(map)]\n            pub clients: Map<nat, c>,                            \n#[sharding(map)]\n            pub l: Map<nat, bool>,                            \n#[sharding(variable)]\n            pub combiner: d,                            \n#[sharding(storage_map)]\n            pub m: Map<nat, b>}\n                      spec fn n(self  ) -> bool {\n                      0 <= self.k         }\n#[invariant]\n        pub fn o(self) -> bool {\n                      match self.combiner {\n                        d::e{\n     elems}\n        => elems.len() <= self.k,                 d::f{\n     elems, g}\n        => elems.len() <= self.k}\n                  }\n                      spec fn p(self, i: nat) -> bool {\n                      self.clients.index(i).is_Waiting()         }\n                    spec fn combiner_has(self, i: nat) -> bool {\n                      match self.combiner {\n                        d::e{\n     elems}\n        => elems.index(i as int).is_Some(),                 d::f{\n     elems, g}\n        => elems.index(i as int).is_Some()}\n                  }\n                      spec fn q(self, i: nat) -> int {\n                      match self.combiner {\n                        d::e{\n     elems}\n        => elems.index(i as int).get_Some_0(),                 d::f{\n     elems, g}\n        => elems.index(i as int).get_Some_0()}\n                  }\n                      spec fn r(self, i: nat) -> bool {\n                      self.m.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                      forall |i|                               i == self.clients.index(i).get_Waiting_rid()         }\n                    transition!{\n                      s(j: nat, request: a, cur_slot: bool) {\n   }\n                  }\n#[inductive(s)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: a, cur_slot: bool)         {\n    }\n                    transition!{\n                      t(j: nat) {\n   }\n                  }\n#[inductive(t)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n    }\n                    fn u(  post: Self) {\n                  }\n                    fn combiner_go_to_collecting_inductive(  post: Self) {\n    }\n                }\n              }\n                fn main() {\n      }\n", " use vstd::prelude::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                verus! {\n              struct a ;\n              struct b ;\n#[is_variant]\npub enum c {\n                Waiting {}\n           }\n   pub enum d {\n                e {}\n           ,     f {}\n           }\n              }\n                 tokenized_state_machine! {\n                  h {\n                    fields {}\n                      spec fn n(self  ) -> bool ;\n#[invariant]\n        pub fn o(self) -> bool ;\n                      spec fn p(self, i: nat) -> bool ;\n                    spec fn combiner_has(self, i: nat) -> bool ;\n                      spec fn q(self, i: nat) -> int ;\n                      spec fn r(self, i: nat) -> bool ;\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool ;\n                    transition!{\n                      s(j: nat, request: a, cur_slot: bool) {}\n                  }\n#[inductive(s)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: a, cur_slot: bool)         {}\n                    transition!{\n                      t(j: nat) {}\n                  }\n#[inductive(t)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {}\n                    fn u(  post: Self) ;\n                    fn combiner_go_to_collecting_inductive(  post: Self) ;\n                }\n              }\n                fn main() {}\n", " use vstd::prelude::*;\n                  use verus_state_machines_macros::tokenized_state_machine;\n                  verus! {\n               struct a ;\n               struct b ;\n               }\n                   tokenized_state_machine! {\n                   h {                     fields {}                       spec fn n() -> bool ;  \n#[invariant]\n        pub fn not_waiting_inv(self) -> bool ;                     transition!{                       s(j: nat, request: a, cur_slot: bool) {}                   }  \n#[inductive(s)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: a, cur_slot: bool)         {}                     transition!{                       t(j: nat) {}                   }  \n#[inductive(t)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {}                     fn u() ;                     fn combiner_go_to_collecting_inductive() ;                 }\n               }\n                  fn main() {\n}\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  h {\n    fields {}\n  }\n}\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "interner_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "minimized_code": " use vstd::{\n pervasive::*, prelude::*, *};\n   use verus_state_machines_macros::tokenized_state_machine;\n   tokenized_state_machine! {\n InternSystem<T> {\n     fields {           \n#[sharding(variable)]\n        pub auth: Seq<T>,           \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }\n     init!{         empty() {             init auth = Seq::empty();             init frag = Map::empty();         }     }\n     transition!{         insert(val: T) {             require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);             update auth = pre.auth.push(val);         }     }\n     transition!{         get_frag(idx: int) {             require(0 <= idx && idx < pre.auth.len());             let val = pre.auth.index(idx);             add frag (union)= [idx => val];         }     }\n     property!{         get_value(i: int) {             have frag >= [i => let val];             assert(i < pre.auth.len() && pre.auth.index(i) === val);         }     }\n     property!{         compute_equality(idx1: int, val1: T, idx2: int, val2: T) {             have frag >= [idx1 => val1];             have frag >= [idx2 => val2];             assert((idx1 == idx2) <==> (val1 === val2));         }     }\n#[invariant]\n    pub fn agreement(&self) -> bool {         forall |k|   \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     }\n#[invariant]\n    pub fn distinct(&self) -> bool {         forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }\n#[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {     }\n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n }\n }\n   verus! {\n  struct Interner<T> {\n     inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }\n  struct Interned<T> {\n     inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, }\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {\n     unimplemented!();\n }\n  impl<T> Interner<T> {\n     spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {         &&& self.inst@ == inst         &&& self.auth@.instance_id() == inst.id()         &&& self.auth@.value() === self.store@     }\n     fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))         ensures             ({                 let s = x.0;                 let inst = x.1@;                 s.wf(inst)             }\n),     {         let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();         let store = Vec::new();         (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))     }\n     fn get<'a>(\n        &'a self,         interned: &Interned<T>,         Ghost(inst): Ghost<InternSystem::Instance<T>>,     ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\nfn main() {\n}\n} \n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/interner.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1161, "minimize_time_ms": 1157734, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 293, "minimized_LOC": 94, "self_contained": false, "dependencies": ["vstd::cell::", "vstd::invariant::", "vstd::map::", "vstd::modes::", "vstd::multiset::", "vstd::prelude::", "vstd::seq::", "vstd::", "verus_state_machines_macros::tokenized_state_machine"], "complexity_verus_tokens": 12, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 0.32081911262798635}, "labeling": {"has_proof_block": true, "ensures_count": 1, "segments": {"exec": " pub fn agreement(&self) -> bool {\n\n pub fn distinct(&self) -> bool {\n\n fn empty_inductive(post: Self) {\n\n fn insert_inductive(pre: Self, post: Self, val: T) {\n\n fn get_frag_inductive(pre: Self, post: Self, idx: int) {\n\n\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {\n\n fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))         ensures             ({\n\n fn get<'a>(\n        &'a self,         interned: &Interned<T>,         Ghost(inst): Ghost<InternSystem::Instance<T>>,     ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n    {\n\n fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n    {\n\n fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n    {\n\n\nfn main() {", "spec": "spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n\nspec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n\nspec fn view(&self) -> T {\n\n#[invariant]\n\n#[invariant]\n\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {\n\n     fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))         ensures             ({                 let s = x.0;                 let inst = x.1@;                 s.wf(inst)             }\n\n        requires\n\n        requires", "proof": "proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n\nproof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a<b> {\n    fields {\n#[sharding(persistent_map)]\n      pub c : Map<int, b>\n    }\n  }\n}\nverus !{ fn main(); }\n", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::{\npervasive::*, prelude::*, *};\n  use verus_state_machines_macros::tokenized_state_machine;\n  tokenized_state_machine! {\nInternSystem<T> {     fields {          \n#[sharding(variable)]\n        pub auth: Seq<T>,          \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }     init!{         empty() {             init auth = Seq::empty();             init frag = Map::empty();         }     }     transition!{         insert(val: T) {             require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);             update auth = pre.auth.push(val);         }     }     transition!{         get_frag(idx: int) {             require(0 <= idx && idx < pre.auth.len());             let val = pre.auth.index(idx);             add frag (union)= [idx => val];         }     }     property!{         get_value(i: int) {             have frag >= [i => let val];             assert(i < pre.auth.len() && pre.auth.index(i) === val);         }     }     property!{         compute_equality(idx1: int, val1: T, idx2: int, val2: T) {             have frag >= [idx1 => val1];             have frag >= [idx2 => val2];             assert((idx1 == idx2) <==> (val1 === val2));         }     }      \n#[invariant]\n    pub fn agreement(&self) -> bool {         forall |k|  \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     }      \n#[invariant]\n    pub fn distinct(&self) -> bool {         forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }      \n#[inductive(empty)]\n    fn empty_inductive(post: Self) { }      \n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {     }      \n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { } }\n}\n  verus! {\n struct Interner<T> {     inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }\n struct Interned<T> {     inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, }\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {     unimplemented!(); }\n impl<T> Interner<T> {     spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {         &&& self.inst@ == inst         &&& self.auth@.instance_id() == inst.id()         &&& self.auth@.value() === self.store@     }     fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))         ensures             ({                 let s = x.0;                 let inst = x.1@;                 s.wf(inst)             }),     {         let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();         let store = Vec::new();         (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))     }     fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)         requires             old(self).wf(inst),         ensures             self.wf(inst) && st.wf(inst) && st@ === val,     {         let idx: usize = 0;         while idx < self.store.len()             invariant                 0 <= idx && idx <= self.store@.len(),                 self.wf(inst),         {             let eq = compute_eq(&val, &self.store[idx]);             if eq {                 let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());                 return Interned {                     inst: Tracked(self.inst.borrow().clone()),                     frag: Tracked(frag),                     id: idx,                 };             }         }         let idx: usize = self.store.len();         self.store.push(val);         proof {             self.inst.borrow().insert(val, self.auth.borrow_mut());         }         let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());         Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }     }     fn get<'a>(\n        &'a self,         interned: &Interned<T>,         Ghost(inst): Ghost<InternSystem::Instance<T>>,     ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\nfn main() {\n}\n} \n", " use vstd::{\n pervasive::*, prelude::*, *};\n   use verus_state_machines_macros::tokenized_state_machine;\n   tokenized_state_machine! {\n InternSystem<T> {\n     fields {           \n#[sharding(variable)]\n        pub auth: Seq<T>,           \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }\n     init!{         empty() {             init auth = Seq::empty();             init frag = Map::empty();         }     }\n     transition!{         insert(val: T) {             require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);             update auth = pre.auth.push(val);         }     }\n     transition!{         get_frag(idx: int) {             require(0 <= idx && idx < pre.auth.len());             let val = pre.auth.index(idx);             add frag (union)= [idx => val];         }     }\n     property!{         get_value(i: int) {             have frag >= [i => let val];             assert(i < pre.auth.len() && pre.auth.index(i) === val);         }     }\n     property!{         compute_equality(idx1: int, val1: T, idx2: int, val2: T) {             have frag >= [idx1 => val1];             have frag >= [idx2 => val2];             assert((idx1 == idx2) <==> (val1 === val2));         }     }\n#[invariant]\n    pub fn agreement(&self) -> bool {         forall |k|   \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     }\n#[invariant]\n    pub fn distinct(&self) -> bool {         forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }\n#[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {     }\n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n }\n }\n   verus! {\n  struct Interner<T> {\n     inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }\n  struct Interned<T> {\n     inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, }\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {\n     unimplemented!();\n }\n  impl<T> Interner<T> {\n     spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {         &&& self.inst@ == inst         &&& self.auth@.instance_id() == inst.id()         &&& self.auth@.value() === self.store@     }\n     fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))         ensures             ({                 let s = x.0;                 let inst = x.1@;                 s.wf(inst)             }\n),     {         let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();         let store = Vec::new();         (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))     }\n     fn get<'a>(\n        &'a self,         interned: &Interned<T>,         Ghost(inst): Ghost<InternSystem::Instance<T>>,     ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\nfn main() {\n}\n} \n", " use vstd::{\n      pervasive::*, prelude::*, *};\n        use verus_state_machines_macros::tokenized_state_machine;\n        tokenized_state_machine! {\n      InternSystem<T> {\n          fields {\n#[sharding(variable)]\n        pub auth: Seq<T>,                \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }\n          init!{\n             empty() {\n                init auth = Seq::empty();\n                init frag = Map::empty();\n            }\n         }\n          transition!{\n             insert(val: T) {}\n         }\n          transition!{\n             get_frag(idx: int) {}\n         }\n          property!{\n             get_value(i: int) {\n                have frag >= [i => let val];\n                assert(i < pre.auth.len() && pre.auth.index(i) === val);\n            }\n         }\n          property!{\n             compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n                have frag >= [idx1 => val1];\n                have frag >= [idx2 => val2];\n            }\n         }\n#[invariant]\n    pub fn agreement(&self) -> bool {\n             forall |k|        \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     }\n#[invariant]\n    pub fn distinct(&self) -> bool {\n             forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }\n#[inductive(empty)]\n    fn empty_inductive(post: Self) {}\n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {}\n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) {}\n      }\n      }\n        verus! {\n       struct Interner<T> {\n          inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }\n       struct Interned<T> {\n          inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, }\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {\n          unimplemented!();\n      }\n       impl<T> Interner<T> {}\nimpl<T> Interned<T> {}\nfn main() ;\n} \n", " use vstd::{       pervasive::*, prelude::*, *};\n         use verus_state_machines_macros::tokenized_state_machine;\n         tokenized_state_machine! {       InternSystem<T> {           fields { \n#[sharding(variable)]\n        pub auth: Seq<T>,                 \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }           init!{              empty() {                 init auth = Seq::empty();                 init frag = Map::empty();             }          }           transition!{              insert(val: T) {}          }           transition!{              get_frag(idx: int) {}          }           property!{              get_value(i: int) {                 have frag >= [i => let val];                 assert(i < pre.auth.len() && pre.auth.index(i) === val);             }          }           property!{              compute_equality(idx1: int, val1: T, idx2: int, val2: T) {                 have frag >= [idx1 => val1];                 have frag >= [idx2 => val2];             }          } \n#[invariant]\n    pub fn agreement(&self) -> bool {              forall |k|         \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     } \n#[invariant]\n    pub fn distinct(&self) -> bool {              forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     } \n#[inductive(empty)]\n    fn empty_inductive(post: Self) {} \n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {} \n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) {}       }       }\n         verus! {        struct Interner<T> {           inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }        struct Interned<T> {           inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, } \n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res == (a === b), {           unimplemented!();       }        impl<T> Interner<T> {} impl<T> Interned<T> {} fn main() ; }\n", " use vstd::{\n          pervasive::*, prelude::*, *};\n             use verus_state_machines_macros::tokenized_state_machine;\n             tokenized_state_machine! {\n          InternSystem<T> {\n             fields {\n#[sharding(variable)]\n        pub auth: Seq<T>,                     \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }\n             init!{\n               empty() {\n                 init auth = Seq::empty();\n                 init frag = Map::empty();\n             }\n           }\n             transition!{\n               insert(val: T) {\n}\n           }\n             transition!{\n               get_frag(idx: int) {\n}\n           }\n#[invariant]\n    pub fn agreement(&self) -> bool {\n               forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }\n#[inductive(empty)]\n    fn empty_inductive(post: Self) {\n }\n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n }\n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) {\n }\n         }\n          }\n             verus! {\n    fn main() ;\n    }\n", " use vstd::\n              prelude::* ;\n                use verus_state_machines_macros::tokenized_state_machine;\n                tokenized_state_machine! {\n             a<b> {\n                fields {\n#[sharding(variable)]\n        pub auth: Seq<b>,                        \n#[sharding(persistent_map)]\n        pub c: Map<int, b>}\n                init!{\n                  empty() {\n                    init auth = Seq::empty();\n                    init c = Map::empty();\n                }\n              }\n                transition!{\n                  d(e: b) {}\n              }\n                transition!{\n                  get_frag(f: int) {}\n              }\n#[invariant]\n    pub fn agreement(self) -> bool {\n                  forall |g , h |             0   < self.auth.len() ==>             self.auth.index(g) !=self.auth.index(h)     }\n#[inductive(empty)]\n    fn i(post: Self) {}\n#[inductive(d)]\n    fn insert_inductive(pre: Self, post: Self, e: b) {}\n#[inductive(get_frag)]\n    fn j(pre: Self, post: Self, f: int) {}\n            }\n             }\n                verus! {\n       fn main() ;\n       }\n", " use vstd::               prelude::* ;\n                    use verus_state_machines_macros::tokenized_state_machine;\n                    tokenized_state_machine! {\n                a<b> {\n                  fields {\n#[sharding(variable)]\n        pub auth: Seq<b>,                            \n#[sharding(persistent_map)]\n        pub c: Map<int, b>}\n              }\n                }\n                    verus! {\n          fn main() ;\n          }\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a< b > {\n    fields {\n#[sharding(variable)]\n      pub auth : Seq< b >,\n#[sharding(persistent_map)]\n                 pub c : Map< int, b >\n    }\n  }\n}\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a< b > {\n    fields {\n#[sharding(persistent_map)]\n                 pub c : Map< int, b >\n    }\n  }\n}\nverus !{ fn main(); }\n", "use vstd::prelude::*;\n use verus_state_machines_macros::tokenized_state_machine;\n tokenized_state_machine !{   a< b > {     fields { \n#[sharding(persistent_map)]\n      pub c : Map< int, b >     }   } }\n verus !{ fn main(); }\n"]}
{"id": "leader_election_complete_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::state_machine;\n\nverus! {\n\npub open spec fn ids_distinct(ids: Seq<int>) -> bool {\n    forall|i: int, j: int|\n        i != j && 0 <= i && i < ids.len() && 0 <= j && j < ids.len() ==> ids.index(i) != ids.index(\n            j,\n        )\n}\n\npub open spec fn between(start: int, node: int, end: int) -> bool {\n    if start < end {\n        start < node && node < end\n    } else {\n        node < end || start < node\n    }\n}\n\npub open spec fn max(a: int, b: int) -> int {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n\n} // verus!\nstate_machine!(\n    X {\n        fields {\n            pub ids: Seq<int>, // constant\n            pub highest_heard: Seq<int>,\n        }\n\n        init!{\n            ini(ids: Seq<int>) {\n                require(ids_distinct(ids));\n                require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                init ids = ids;\n                init highest_heard = Seq::new(ids.len(), |i: int| -1);\n            }\n        }\n\n        transition!{\n            transmission(srcidx: int) {\n                require(0 <= srcidx && srcidx < pre.ids.len());\n\n                let dstidx = if srcidx + 1 == pre.ids.len() { 0 } else { srcidx + 1 };\n                let message = max(pre.highest_heard.index(srcidx), pre  .ids.index(srcidx));\n                let dst_new_max = max(pre.highest_heard.index(dstidx), message);\n\n                update highest_heard = pre.highest_heard.update(dstidx, dst_new_max);\n            }\n        }\n\n        #[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n            self.ids.len() == self.highest_heard.len()\n        }\n\n        #[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n            ids_distinct(self.ids)\n        }\n\n        pub open spec fn is_leader(self, i: int) -> bool {\n            0 <= i && i < self.ids.len() &&\n                self.highest_heard.index(i) == self.ids.index(i)\n        }\n\n        #[invariant]\n        pub fn safety_condition(self) -> bool {\n            forall |i: int, j: int|\n                self.is_leader(i) && self.is_leader(j) ==> i == j\n        }\n\n        pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {\n            forall |node: int| between(start, node, end) && self.valid_idx(node)\n                ==> self.highest_heard.index(node) > self.ids.index(node)\n        }\n\n        pub open spec fn valid_idx(self, i: int) -> bool {\n            0 <= i && i < self.ids.len()\n        }\n\n        pub open spec fn is_chord(self, start: int, end: int) -> bool {\n               self.valid_idx(start)\n            && self.valid_idx(end)\n            && self.ids.index(start) == self.highest_heard.index(end)\n        }\n\n        #[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n            forall |start: int, end: int|\n                self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)\n        }\n\n        #[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n            // XXX(travis): this sort of copy-paste is extremely common, we could have\n            // a language feature to let us skip it\n            let dstidx = if srcidx + 1 == pre.ids.len() { 0 } else { srcidx + 1 };\n            let message = max(pre.highest_heard.index(srcidx), pre.ids.index(srcidx));\n            let dst_new_max = max(pre.highest_heard.index(dstidx), message);\n\n            assert_by(post.on_chord_heard_dominates_id_inv(), {\n              assert forall |start: int, end: int| post.is_chord(start, end)\n                implies post.OnChordHeardDominatesId(start, end)\n              by {\n                assert forall |node: int|\n                  between(start, node, end) && post.valid_idx(node)\n                  implies post.highest_heard.index(node) > post.ids.index(node)\n                by {\n                  if dstidx == end {\n                    // maybe this chord just sprung into existence\n                    if post.highest_heard.index(end) == pre.highest_heard.index(end) {\n                      // no change --\n                      assert(pre.highest_heard =~= post.highest_heard);\n                      assert(equal(pre.highest_heard, post.highest_heard));\n                      assert(equal(pre, post));\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    } else if post.highest_heard.index(end) == pre.ids.index(srcidx) {\n                      assert(false); // proof by contradiction\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    } else if post.highest_heard.index(end) == pre.highest_heard.index(srcidx) {\n                      assert(pre.is_chord(start, srcidx));  // trigger\n                      assert(pre.valid_idx(node));\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    }\n                  } else {\n                    // this chord was already here\n                    assert(pre.is_chord(start, end)); // trigger\n                    assert(pre.valid_idx(node)); // trigger\n                    assert(post.highest_heard.index(node) > post.ids.index(node));\n                  }\n                }\n              }\n            });\n\n            assert_by(post.safety_condition(), {\n                assert forall |i: int, j: int|\n                    post.is_leader(i) && post.is_leader(j) implies i == j\n                by {\n\n                    if i != j {\n                        if pre.is_leader(i) {\n                            assert(pre.is_chord(i, i));\n                            //assert(pre.OnChordHeardDominatesId(i, i));\n                            //assert(between(i, j, i));\n                            assert(pre.valid_idx(j));\n                            //assert(pre.highest_heard.index(j) > pre.ids.index(j));\n                            assert(!post.is_leader(j));\n                            assert(false);\n                        }\n\n                        if pre.is_leader(j) {\n                            assert(pre.is_chord(j, j));\n                            assert(pre.valid_idx(i));\n                            assert(!post.is_leader(i));\n                            assert(false);\n                        }\n                    }\n                }\n            });\n        }\n\n        #[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n            assert(post.on_chord_heard_dominates_id_inv());\n        }\n    }\n);\n\nfn main() {}\n", "minimized_code": "use verus_builtin::*;\n     use verus_builtin_macros::*;\n     use vstd::seq::*;\n     use verus_state_machines_macros::state_machine;\n     verus! {\n    pub open spec fn ids_distinct(ids: Seq<int>) -> bool {\n       forall|i: int, j: int|         i != j && 0 <= i && i < ids.len() && 0 <= j && j < ids.len() ==> ids.index(i) != ids.index(             j,         ) }\n    pub open spec fn between(start: int, node: int, end: int) -> bool {\n       if start < end {\n          start < node && node < end     }\n   else {\n          node < end || start < node     }\n   }\n    pub open spec fn max(a: int, b: int) -> int {\n       if a > b {\n          a     }\n   else {\n          b     }\n   }\n    }\n      state_machine!(     X {\n            fields {\n               pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n            init!{\n               ini(ids: Seq<int>) {\n                  require(ids_distinct(ids));\n                  require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                  init ids = ids;\n                  init highest_heard = Seq::new(ids.len(), |i: int| -1);\n              }\n           }\n            transition!{\n               transmission(srcidx: int) {\n                  let dstidx = if srcidx + 1 == pre.ids.len() {\n 0 }\n  else {\n srcidx + 1 };\n              }\n           }\n#[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n               self.ids.len() == self.highest_heard.len()         }\n#[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n               ids_distinct(self.ids)         }\n            pub open spec fn is_leader(self, i: int) -> bool {\n               0 <= i && i < self.ids.len() &&                 self.highest_heard.index(i) == self.ids.index(i)         }\n#[invariant]\n        pub fn safety_condition(self) -> bool {\n               forall |i: int, j: int|                 self.is_leader(i) && self.is_leader(j) ==> i == j         }\n            pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {\n               forall |node: int| between(start, node, end) && self.valid_idx(node)                 ==> self.highest_heard.index(node) > self.ids.index(node)         }\n            pub open spec fn valid_idx(self, i: int) -> bool {\n               0 <= i && i < self.ids.len()         }\n            pub open spec fn is_chord(self, start: int, end: int) -> bool {\n                  self.valid_idx(start)             && self.valid_idx(end)             && self.ids.index(start) == self.highest_heard.index(end)         }\n#[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n               forall |start: int, end: int|                 self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)         }\n#[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n               let dstidx = if srcidx + 1 == pre.ids.len() {\n  0 }\n   else {\n  srcidx + 1 };\n               assert_by(post.on_chord_heard_dominates_id_inv(), {\n              }\n  );\n               assert_by(post.safety_condition(), {\n              }\n  );\n           }\n#[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n           }\n        }\n     );\n     fn main() {\n   }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/leader_election_complete.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 858, "minimize_time_ms": 308913, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 182, "minimized_LOC": 79, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::seq::", "vstd::", "verus_state_machines_macros::state_machine"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.4340659340659341}, "labeling": {"segments": {"exec": " pub fn inv_lengths_match(self) -> bool {\n\n pub fn inv_ids_distinct(self) -> bool {\n\n pub fn safety_condition(self) -> bool {\n\n pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n\n pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n\n pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n\n fn main() {", "spec": "spec fn ids_distinct(ids: Seq<int>) -> bool {\n\nspec fn between(start: int, node: int, end: int) -> bool {\n\nspec fn max(a: int, b: int) -> int {\n\nspec fn is_leader(self, i: int) -> bool {\n\nspec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {\n\nspec fn valid_idx(self, i: int) -> bool {\n\nspec fn is_chord(self, start: int, end: int) -> bool {\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]"}}}, "all_snapshots": ["#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::state_machine;\n\nverus! {\n\npub open spec fn ids_distinct(ids: Seq<int>) -> bool {\n    forall|i: int, j: int|\n        i != j && 0 <= i && i < ids.len() && 0 <= j && j < ids.len() ==> ids.index(i) != ids.index(\n            j,\n        )\n}\n\npub open spec fn between(start: int, node: int, end: int) -> bool {\n    if start < end {\n        start < node && node < end\n    } else {\n        node < end || start < node\n    }\n}\n\npub open spec fn max(a: int, b: int) -> int {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n\n} // verus!\nstate_machine!(\n    X {\n        fields {\n            pub ids: Seq<int>, // constant\n            pub highest_heard: Seq<int>,\n        }\n\n        init!{\n            ini(ids: Seq<int>) {\n                require(ids_distinct(ids));\n                require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                init ids = ids;\n                init highest_heard = Seq::new(ids.len(), |i: int| -1);\n            }\n        }\n\n        transition!{\n            transmission(srcidx: int) {\n                require(0 <= srcidx && srcidx < pre.ids.len());\n\n                let dstidx = if srcidx + 1 == pre.ids.len() { 0 } else { srcidx + 1 };\n                let message = max(pre.highest_heard.index(srcidx), pre  .ids.index(srcidx));\n                let dst_new_max = max(pre.highest_heard.index(dstidx), message);\n\n                update highest_heard = pre.highest_heard.update(dstidx, dst_new_max);\n            }\n        }\n\n        #[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n            self.ids.len() == self.highest_heard.len()\n        }\n\n        #[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n            ids_distinct(self.ids)\n        }\n\n        pub open spec fn is_leader(self, i: int) -> bool {\n            0 <= i && i < self.ids.len() &&\n                self.highest_heard.index(i) == self.ids.index(i)\n        }\n\n        #[invariant]\n        pub fn safety_condition(self) -> bool {\n            forall |i: int, j: int|\n                self.is_leader(i) && self.is_leader(j) ==> i == j\n        }\n\n        pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {\n            forall |node: int| between(start, node, end) && self.valid_idx(node)\n                ==> self.highest_heard.index(node) > self.ids.index(node)\n        }\n\n        pub open spec fn valid_idx(self, i: int) -> bool {\n            0 <= i && i < self.ids.len()\n        }\n\n        pub open spec fn is_chord(self, start: int, end: int) -> bool {\n               self.valid_idx(start)\n            && self.valid_idx(end)\n            && self.ids.index(start) == self.highest_heard.index(end)\n        }\n\n        #[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n            forall |start: int, end: int|\n                self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)\n        }\n\n        #[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n            // XXX(travis): this sort of copy-paste is extremely common, we could have\n            // a language feature to let us skip it\n            let dstidx = if srcidx + 1 == pre.ids.len() { 0 } else { srcidx + 1 };\n            let message = max(pre.highest_heard.index(srcidx), pre.ids.index(srcidx));\n            let dst_new_max = max(pre.highest_heard.index(dstidx), message);\n\n            assert_by(post.on_chord_heard_dominates_id_inv(), {\n              assert forall |start: int, end: int| post.is_chord(start, end)\n                implies post.OnChordHeardDominatesId(start, end)\n              by {\n                assert forall |node: int|\n                  between(start, node, end) && post.valid_idx(node)\n                  implies post.highest_heard.index(node) > post.ids.index(node)\n                by {\n                  if dstidx == end {\n                    // maybe this chord just sprung into existence\n                    if post.highest_heard.index(end) == pre.highest_heard.index(end) {\n                      // no change --\n                      assert(pre.highest_heard =~= post.highest_heard);\n                      assert(equal(pre.highest_heard, post.highest_heard));\n                      assert(equal(pre, post));\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    } else if post.highest_heard.index(end) == pre.ids.index(srcidx) {\n                      assert(false); // proof by contradiction\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    } else if post.highest_heard.index(end) == pre.highest_heard.index(srcidx) {\n                      assert(pre.is_chord(start, srcidx));  // trigger\n                      assert(pre.valid_idx(node));\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    }\n                  } else {\n                    // this chord was already here\n                    assert(pre.is_chord(start, end)); // trigger\n                    assert(pre.valid_idx(node)); // trigger\n                    assert(post.highest_heard.index(node) > post.ids.index(node));\n                  }\n                }\n              }\n            });\n\n            assert_by(post.safety_condition(), {\n                assert forall |i: int, j: int|\n                    post.is_leader(i) && post.is_leader(j) implies i == j\n                by {\n\n                    if i != j {\n                        if pre.is_leader(i) {\n                            assert(pre.is_chord(i, i));\n                            //assert(pre.OnChordHeardDominatesId(i, i));\n                            //assert(between(i, j, i));\n                            assert(pre.valid_idx(j));\n                            //assert(pre.highest_heard.index(j) > pre.ids.index(j));\n                            assert(!post.is_leader(j));\n                            assert(false);\n                        }\n\n                        if pre.is_leader(j) {\n                            assert(pre.is_chord(j, j));\n                            assert(pre.valid_idx(i));\n                            assert(!post.is_leader(i));\n                            assert(false);\n                        }\n                    }\n                }\n            });\n        }\n\n        #[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n            assert(post.on_chord_heard_dominates_id_inv());\n        }\n    }\n);\n\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n     use verus_builtin_macros::*;\n     use vstd::seq::*;\n     use verus_state_machines_macros::state_machine;\n     verus! {\n    pub open spec fn ids_distinct(ids: Seq<int>) -> bool {\n       forall|i: int, j: int|         i != j && 0 <= i && i < ids.len() && 0 <= j && j < ids.len() ==> ids.index(i) != ids.index(             j,         ) }\n    pub open spec fn between(start: int, node: int, end: int) -> bool {\n       if start < end {\n          start < node && node < end     }\n   else {\n          node < end || start < node     }\n   }\n    pub open spec fn max(a: int, b: int) -> int {\n       if a > b {\n          a     }\n   else {\n          b     }\n   }\n    }\n      state_machine!(     X {\n            fields {\n               pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n            init!{\n               ini(ids: Seq<int>) {\n                  require(ids_distinct(ids));\n                  require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                  init ids = ids;\n                  init highest_heard = Seq::new(ids.len(), |i: int| -1);\n              }\n           }\n            transition!{\n               transmission(srcidx: int) {\n                  let dstidx = if srcidx + 1 == pre.ids.len() {\n 0 }\n  else {\n srcidx + 1 };\n              }\n           }\n#[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n               self.ids.len() == self.highest_heard.len()         }\n#[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n               ids_distinct(self.ids)         }\n            pub open spec fn is_leader(self, i: int) -> bool {\n               0 <= i && i < self.ids.len() &&                 self.highest_heard.index(i) == self.ids.index(i)         }\n#[invariant]\n        pub fn safety_condition(self) -> bool {\n               forall |i: int, j: int|                 self.is_leader(i) && self.is_leader(j) ==> i == j         }\n            pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {\n               forall |node: int| between(start, node, end) && self.valid_idx(node)                 ==> self.highest_heard.index(node) > self.ids.index(node)         }\n            pub open spec fn valid_idx(self, i: int) -> bool {\n               0 <= i && i < self.ids.len()         }\n            pub open spec fn is_chord(self, start: int, end: int) -> bool {\n                  self.valid_idx(start)             && self.valid_idx(end)             && self.ids.index(start) == self.highest_heard.index(end)         }\n#[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n               forall |start: int, end: int|                 self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)         }\n#[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n               let dstidx = if srcidx + 1 == pre.ids.len() {\n  0 }\n   else {\n  srcidx + 1 };\n               assert_by(post.on_chord_heard_dominates_id_inv(), {\n              }\n  );\n               assert_by(post.safety_condition(), {\n              }\n  );\n           }\n#[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n           }\n        }\n     );\n     fn main() {\n   }\n", "use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::seq::*;\n        use verus_state_machines_macros::state_machine;\n        verus! {\n       pub open spec fn ids_distinct(ids: Seq<int>) -> bool ;\n       pub open spec fn between(start: int, node: int, end: int) -> bool ;\n       pub open spec fn max(a: int, b: int) -> int ;\n       }\n         state_machine!(     X {\n               fields {\n                  pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n               init!{\n                  ini(ids: Seq<int>) {\n                     require(ids_distinct(ids));\n                     require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                     init ids = ids;\n                     init highest_heard = Seq::new(ids.len(), |i: int| -1);\n                 }\n              }\n               transition!{\n                  transmission(srcidx: int) {\n                     let dstidx = if srcidx + 1 == pre.ids.len0 {\n    0 }\n     else {\n    srcidx + 1 };\n                 }\n              }\n#[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n                  self.ids.len() == self.highest_heard.len()         }\n#[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n                  ids_distinct(self.ids)         }\n               pub open spec fn is_leader(self, i: int) -> bool {\n                  0 <= i && i < self.ids.len() &&                 self.highest_heard.index(i) == self.ids.index(i)         }\n#[invariant]\n        pub fn safety_condition(self) -> bool {\n                  forall |i: int, j: int|                 self.is_leader(i) && self.is_leader(j) ==> i == j         }\n               pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool ;\n               pub open spec fn valid_idx(self, i: int) -> bool {\n                  0 <= i && i < self.ids.len()         }\n               pub open spec fn is_chord(self, start: int, end: int) -> bool {\n                     self.valid_idx(start)             && self.valid_idx(end)             && self.ids.index(start) == self.highest_heard.index(end)         }\n#[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n                  forall |start: int, end: int|                 self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)         }\n#[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n                  let dstidx = if srcidx + 1 == pre.ids.len() {\n     0 }\n      else {\n     srcidx + 1 };\n                  assert_by(post.on_chord_heard_dominates_id_inv(), {\n                 }\n     );\n                  assert_by(post.safety_condition(), {\n                 }\n     );\n              }\n#[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n              }\n           }\n        );\n        fn main() {\n      }\n", "use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::seq::*;\n        use verus_state_machines_macros::state_machine;\n        verus! {\n       pub open spec fn ids_distinct(ids: Seq<int>) -> bool ;\n       pub open spec fn between() -> bool ;\n       pub open spec fn max() -> int ;\n       }\n         state_machine!(     X {\n               fields {\n                  pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n               init!{\n                  ini(ids: Seq<int>) {\n                     require(ids_distinct(ids));\n                     require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                     init ids = ids;\n                     init highest_heard = Seq::new(ids.len(), |i: int| -1);\n                 }\n              }\n               transition!{\n                  transmission(srcidx: int) {}\n              }\n#[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n                  self.ids.len() == self.highest_heard.len()         }\n#[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n                  ids_distinct(self.ids)         }\n               pub open spec fn is_leader(self, i: int) -> bool {\n                  0 <= i && i < self.ids.len() &&                 self.highest_heard.index(i) == self.ids.index(i)         }\n#[invariant]\n        pub fn safety_condition(self) -> bool {\n                  forall |i: int, j: int|                 self.is_leader(i) && self.is_leader(j) ==> i == j         }\n               pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool ;\n               pub open spec fn valid_idx(self, i: int) -> bool {\n                  0 <= i && i < self.ids.len()         }\n               pub open spec fn is_chord(self, start: int, end: int) -> bool {\n                     self.valid_idx(start)             && self.valid_idx(end)             && self.ids.index(start) == self.highest_heard.index(end)         }\n#[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n                  forall |start: int, end: int|                 self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)         }\n#[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {}\n#[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {}\n           }\n        );\n        fn main() {}\n", "use verus_builtin::*;\n               use verus_builtin_macros::*;\n               use vstd::seq::*;\n               use verus_state_machines_macros::state_machine;\n               verus! {\n             }\n                state_machine!(     X {\n                     fields {\n                       pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n                 }\n               );\n               fn main() {\n     }\n", "use verus_builtin::*;\nuse vstd::seq::*;\nuse verus_state_machines_macros::state_machine;\nstate_machine !(X{fields{\n  pub ids : Seq< int >,\n  pub highest_heard : Seq< int >}});\nfn main() {}\n", "use verus_builtin;\nuse verus_state_machines_macros;\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "maps_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::map::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(map)]\n            pub bool_map: Map<int, bool>,\n\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init bool_map = Map::empty().insert(5, true);\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                remove bool_map -= [n => true];\n                add bool_map += [n => true];\n            }\n        }\n\n        transition!{\n            add_have(n: int) {\n                remove bool_map -= [n => false];\n                have bool_map >= [19 => false];\n                add bool_map += [n => true];\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(add_have)]\n        fn add_have_inductive(pre: Self, post: Self, n: int) { }\n    }\n);\n\ntokenized_state_machine!(\n    Fancy {\n        fields {\n            #[sharding(variable)]\n            pub m: int,\n\n            #[sharding(map)]\n            pub map: Map<int, bool>,\n\n            #[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,\n        }\n\n        #[invariant]\n        pub fn inv1(self) -> bool {\n            forall |i: int|\n              self.storage_map.dom().contains(i) ==> (0 <= i && i < self.m)\n        }\n\n        #[invariant]\n        pub fn inv2(self) -> bool {\n            forall |i: int|\n              (0 <= i && i < self.m) ==> self.storage_map.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn inv3(self) -> bool {\n            self.m >= 0 &&\n            equal(self.storage_map, self.map)\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init m = 0;\n                init storage_map = Map::empty();\n                init map = Map::empty();\n            }\n        }\n\n        transition!{\n            do_deposit(b: bool) {\n                update m = pre.m + 1;\n                add map += [pre.m => b];\n                deposit storage_map += [pre.m => b];\n            }\n        }\n\n        transition! {\n            do_withdraw(b: bool) {\n                require(pre.m >= 1);\n                update m = pre.m - 1;\n                remove map -= [pre.m => b];\n                withdraw storage_map -= [pre.m => b];\n            }\n        }\n\n        property! {\n            do_guard(i: int, b: bool) {\n                have map >= [i => b];\n                guard storage_map >= [i => b];\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(do_deposit)]\n        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {\n            /*\n            assert_forall_by(|i: int| {\n              requires(post.storage_map.dom().contains(i));\n              ensures(0 <= i && i < post.m);\n              if pre.storage_map.dom().contains(i) {\n                  assert(0 <= i && i < post.m);\n              } else {\n                  assert(i == pre.m);\n                  assert(0 <= i && i < post.m);\n              }\n            });\n            */\n        }\n\n        #[inductive(do_withdraw)]\n        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) { }\n    }\n);\n\nfn main() {}\n", "minimized_code": "use verus_builtin::*;\n        use vstd::map::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n        tokenized_state_machine!(     X {\n               fields {}\n           }\n        );\n        tokenized_state_machine!(     Fancy {\n               fields {\n#[sharding(variable)]\n            pub m: int,                    \n#[sharding(map)]\n            pub map: Map<int, bool>,                    \n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,         }\n#[invariant]\n        pub fn inv1(self) -> bool {\n                  forall |i: int|               self.storage_map.dom().contains(i) ==> (0 <= i && i < self.m)         }\n#[invariant]\n        pub fn inv3(self) -> bool {\n                  self.m >= 0 &&             equal(self.storage_map, self.map)         }\n               init!{\n                  initialize(cond: bool) {\n                     init m = 0;\n                     init storage_map = Map::empty();\n                     init map = Map::empty();\n                 }\n              }\n               transition!{\n                  do_deposit(b: bool) {}\n              }\n               transition! {\n                  do_withdraw(b: bool) {}\n              }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) {\n      }\n#[inductive(do_deposit)]\n        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {\n              }\n#[inductive(do_withdraw)]\n        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) {\n      }\n           }\n        );\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/maps.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1016, "minimize_time_ms": 643519, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 136, "minimized_LOC": 47, "self_contained": false, "dependencies": ["verus_builtin::", "vstd::map::", "vstd::", "verus_state_machines_macros::tokenized_state_machine"], "complexity_verus_tokens": 2, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.34558823529411764}, "labeling": {"segments": {"exec": " pub fn inv1(self) -> bool {\n\n pub fn inv3(self) -> bool {\n\n fn initialize_inductive(post: Self, cond: bool) {\n\n fn do_deposit_inductive(pre: Self, post: Self, b: bool) {\n\n fn do_withdraw_inductive(pre: Self, post: Self, b: bool) {\n\n fn main() {", "spec": "#[invariant]\n\n#[invariant]"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::map::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(map)]\n            pub bool_map: Map<int, bool>,\n\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init bool_map = Map::empty().insert(5, true);\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                remove bool_map -= [n => true];\n                add bool_map += [n => true];\n            }\n        }\n\n        transition!{\n            add_have(n: int) {\n                remove bool_map -= [n => false];\n                have bool_map >= [19 => false];\n                add bool_map += [n => true];\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(add_have)]\n        fn add_have_inductive(pre: Self, post: Self, n: int) { }\n    }\n);\n\ntokenized_state_machine!(\n    Fancy {\n        fields {\n            #[sharding(variable)]\n            pub m: int,\n\n            #[sharding(map)]\n            pub map: Map<int, bool>,\n\n            #[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,\n        }\n\n        #[invariant]\n        pub fn inv1(self) -> bool {\n            forall |i: int|\n              self.storage_map.dom().contains(i) ==> (0 <= i && i < self.m)\n        }\n\n        #[invariant]\n        pub fn inv2(self) -> bool {\n            forall |i: int|\n              (0 <= i && i < self.m) ==> self.storage_map.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn inv3(self) -> bool {\n            self.m >= 0 &&\n            equal(self.storage_map, self.map)\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init m = 0;\n                init storage_map = Map::empty();\n                init map = Map::empty();\n            }\n        }\n\n        transition!{\n            do_deposit(b: bool) {\n                update m = pre.m + 1;\n                add map += [pre.m => b];\n                deposit storage_map += [pre.m => b];\n            }\n        }\n\n        transition! {\n            do_withdraw(b: bool) {\n                require(pre.m >= 1);\n                update m = pre.m - 1;\n                remove map -= [pre.m => b];\n                withdraw storage_map -= [pre.m => b];\n            }\n        }\n\n        property! {\n            do_guard(i: int, b: bool) {\n                have map >= [i => b];\n                guard storage_map >= [i => b];\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(do_deposit)]\n        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {\n            /*\n            assert_forall_by(|i: int| {\n              requires(post.storage_map.dom().contains(i));\n              ensures(0 <= i && i < post.m);\n              if pre.storage_map.dom().contains(i) {\n                  assert(0 <= i && i < post.m);\n              } else {\n                  assert(i == pre.m);\n                  assert(0 <= i && i < post.m);\n              }\n            });\n            */\n        }\n\n        #[inductive(do_withdraw)]\n        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) { }\n    }\n);\n\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n        use vstd::map::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n        tokenized_state_machine!(     X {\n               fields {}\n           }\n        );\n        tokenized_state_machine!(     Fancy {\n               fields {\n#[sharding(variable)]\n            pub m: int,                    \n#[sharding(map)]\n            pub map: Map<int, bool>,                    \n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,         }\n#[invariant]\n        pub fn inv1(self) -> bool {\n                  forall |i: int|               self.storage_map.dom().contains(i) ==> (0 <= i && i < self.m)         }\n#[invariant]\n        pub fn inv3(self) -> bool {\n                  self.m >= 0 &&             equal(self.storage_map, self.map)         }\n               init!{\n                  initialize(cond: bool) {\n                     init m = 0;\n                     init storage_map = Map::empty();\n                     init map = Map::empty();\n                 }\n              }\n               transition!{\n                  do_deposit(b: bool) {}\n              }\n               transition! {\n                  do_withdraw(b: bool) {}\n              }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) {\n      }\n#[inductive(do_deposit)]\n        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {\n              }\n#[inductive(do_withdraw)]\n        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) {\n      }\n           }\n        );\n        fn main() {\n      }\n", "use verus_builtin::*;\n          use vstd::map::*;\n          use verus_state_machines_macros::tokenized_state_machine;\n          tokenized_state_machine!(     X {\n                fields {  \n#[sharding(variable)]\n            pub m: int,                      \n#[sharding(map)]\n            pub map: Map<int, bool>,                      \n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,         }\n#[invariant]\n        pub fn inv3(self) -> bool {                   self.m >= 0 &&             equal(self.storage_map, self.map)         }\n                init!{                   initialize(cond: bool) {                      init m = 0;                      init storage_map = Map::empty();                      init map = Map::empty();                  }               }\n                transition!{                   do_deposit(b: bool) {}               }\n                transition! {                   do_withdraw(b: bool) {}               }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) {}\n#[inductive(do_deposit)]\n        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {}\n#[inductive(do_withdraw)]\n        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) {}\n            }\n          );\n          fn main() {\n}\n", "use verus_builtin::*;\n               use vstd::map::*;\n               use verus_state_machines_macros::tokenized_state_machine;\n               tokenized_state_machine!(     X {\n                     fields {\n#[sharding(variable)]\n            pub m: int,                           \n#[sharding(map)]\n            pub map: Map<int, bool>,                           \n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,         }\n                     init!{\n                       initialize(cond: bool) {\n                         init m = 0;\n                         init storage_map = Map::empty();\n                         init map = Map::empty();\n   }\n                   }\n                 }\n               );\n               fn main() {\n     }\n", "use verus_builtin::*;\nuse vstd::map::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n                tokenized_state_machine!(     X {\n                      fields {\n#[sharding(variable)]\n            pub m: int,\n#[sharding(map)]\n            pub map: Map<int, bool>,\n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>}\n                      init!{\n                        initialize() {\n                          init m = 0;\n                          init storage_map = Map::empty();\n                          init map = Map::empty();\n                }\n                }\n                }\n                );\n                fn main() {}\n", "use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(a{fields{\n#[sharding(variable)]\n  pub b : int,\n#[sharding(map)]\n  pub map : Map< int, bool >,\n#[sharding(storage_map)]\n  pub storage_map : Map< int, bool >\n}});\nfn main() {}\n", "use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(a{fields{\n#[sharding(map)]\n  pub map : Map< int, bool >,\n#[sharding(storage_map)]\n  pub storage_map : Map< int, bool >\n}});\nfn main() {}\n", "use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(a{fields{\n#[sharding(map)]\n  pub map : Map< int, bool >\n}});\nfn main() {}\n", "use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nfn main() {}\n", "use verus_builtin;\n   fn main() {\n }\n"]}
{"id": "petersons_algorithm_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-warnings\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::*;\nuse vstd::prelude::*;\n\n#[verifier::verify]\npub enum ThreadState {\n    Idle,\n    SetFlag,\n    Waiting,\n    Critical,\n}\n\ntokenized_state_machine! { Petersons<T> {\n    fields {\n        #[sharding(variable)] pub flag_0: bool,\n        #[sharding(variable)] pub flag_1: bool,\n        #[sharding(variable)] pub turn: int,\n\n        #[sharding(variable)] pub thread_0: ThreadState,\n        #[sharding(variable)] pub thread_1: ThreadState,\n\n        #[sharding(storage_option)] pub storage: Option<T>,\n    }\n\n    #[invariant]\n    pub spec fn the_inv(&self) -> bool {\n        &&& (self.thread_0 === ThreadState::Idle) <==> !self.flag_0\n        &&& (self.thread_1 === ThreadState::Idle) <==> !self.flag_1\n        &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)\n        &&& self.storage.is_Some() <==>\n            (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)\n        &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag\n        &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag\n        &&& self.turn == 0 || self.turn == 1\n    }\n\n    init!{\n        initialize(t: T) {\n            init flag_0 = false;\n            init flag_1 = false;\n            init turn = 0;\n            init thread_0 = ThreadState::Idle;\n            init thread_1 = ThreadState::Idle;\n            init storage = Option::Some(t);\n        }\n    }\n\n    //// Thread 0 transitions\n\n    transition!{\n        t0_set_flag() {\n            require pre.thread_0 === ThreadState::Idle;\n            update thread_0 = ThreadState::SetFlag;\n\n            update flag_0 = true;\n        }\n    }\n\n    transition!{\n        t0_set_turn() {\n            require pre.thread_0 === ThreadState::SetFlag;\n            update thread_0 = ThreadState::Waiting;\n            update turn = 1;\n        }\n    }\n\n    transition!{\n        t0_enter_via_flag() {\n            require pre.thread_0 === ThreadState::Waiting;\n            require pre.flag_1 == false;\n            update thread_0 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t0_enter_via_turn() {\n            require pre.thread_0 === ThreadState::Waiting;\n            require pre.turn != 1;\n            update thread_0 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t0_done(t: T) {\n            require pre.thread_0 === ThreadState::Critical;\n            update thread_0 = ThreadState::Idle;\n            update flag_0 = false;\n            deposit storage += Some(t);\n        }\n    }\n\n    //// Thread 1 transitions\n\n    transition!{\n        t1_set_flag() {\n            require pre.thread_1 === ThreadState::Idle;\n            update thread_1 = ThreadState::SetFlag;\n\n            update flag_1 = true;\n        }\n    }\n\n    transition!{\n        t1_set_turn() {\n            require pre.thread_1 === ThreadState::SetFlag;\n            update thread_1 = ThreadState::Waiting;\n            update turn = 0;\n        }\n    }\n\n    transition!{\n        t1_enter_via_flag() {\n            require pre.thread_1 === ThreadState::Waiting;\n            require pre.flag_0 == false;\n            update thread_1 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t1_enter_via_turn() {\n            require pre.thread_1 === ThreadState::Waiting;\n            require pre.turn != 0;\n            update thread_1 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t1_done(t: T) {\n            require pre.thread_1 === ThreadState::Critical;\n            update thread_1 = ThreadState::Idle;\n            update flag_1 = false;\n            deposit storage += Some(t);\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) { }\n\n    #[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_enter_via_turn)]\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_done)]\n    fn t0_done_inductive(pre: Self, post: Self, t: T) { }\n\n    #[inductive(t1_set_flag)]\n    fn t1_set_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_set_turn)]\n    fn t1_set_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_enter_via_flag)]\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_enter_via_turn)]\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_done)]\n    fn t1_done_inductive(pre: Self, post: Self, t: T) { }\n}}\n\nfn main() {}\n", "minimized_code": " use verus_state_machines_macros::*;\n        use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n           Idle,     SetFlag,     Waiting,     Critical, }\n        tokenized_state_machine! {\n       Petersons<T> {\n          fields {\n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }\n#[invariant]\n    pub spec fn the_inv(&self) -> bool {\n             &&& (self.thread_0 === ThreadState::Idle) <==> !self.flag_0         &&& (self.thread_1 === ThreadState::Idle) <==> !self.flag_1         &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)         &&& self.storage.is_Some() <==>             (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)         &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag         &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag         &&& self.turn == 0 || self.turn == 1     }\n          init!{\n             initialize(t: T) {\n                init flag_0 = false;\n                init flag_1 = false;\n                init turn = 0;\n                init thread_0 = ThreadState::Idle;\n                init thread_1 = ThreadState::Idle;\n                init storage = Option::Some(t);\n            }\n         }\n          transition!{\n             t0_set_flag() {}\n         }\n          transition!{\n             t0_set_turn() {}\n         }\n          transition!{\n             t0_enter_via_flag() {}\n         }\n          transition!{\n             t0_enter_via_turn() {}\n         }\n          transition!{\n             t0_done(t: T) {}\n         }\n          transition!{\n             t1_set_flag() {}\n         }\n          transition!{\n             t1_set_turn() {}\n         }\n          transition!{\n             t1_enter_via_flag() {}\n         }\n          transition!{\n             t1_enter_via_turn() {}\n         }\n          transition!{\n             t1_done(t: T) {}\n         }\n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) {}\n#[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t0_enter_via_turn)]\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t0_done)]\n    fn t0_done_inductive(pre: Self, post: Self, t: T) {}\n#[inductive(t1_set_flag)]\n    fn t1_set_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t1_set_turn)]\n    fn t1_set_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t1_enter_via_flag)]\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t1_enter_via_turn)]\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t1_done)]\n    fn t1_done_inductive(pre: Self, post: Self, t: T) {}\n      }\n      }\n        fn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/petersons_algorithm.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1180, "minimize_time_ms": 886784, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 176, "minimized_LOC": 83, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "verus_state_machines_macros::", "vstd::prelude::"], "complexity_verus_tokens": 2, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.4715909090909091}, "labeling": {"segments": {"exec": " fn initialize_inductive(post: Self, t: T) {\n\n fn t0_set_flag_inductive(pre: Self, post: Self) {\n\n fn t0_set_turn_inductive(pre: Self, post: Self) {\n\n fn t0_enter_via_flag_inductive(pre: Self, post: Self) {\n\n fn t0_enter_via_turn_inductive(pre: Self, post: Self) {\n\n fn t0_done_inductive(pre: Self, post: Self, t: T) {\n\n fn t1_set_flag_inductive(pre: Self, post: Self) {\n\n fn t1_set_turn_inductive(pre: Self, post: Self) {\n\n fn t1_enter_via_flag_inductive(pre: Self, post: Self) {\n\n fn t1_enter_via_turn_inductive(pre: Self, post: Self) {\n\n fn t1_done_inductive(pre: Self, post: Self, t: T) {\n\n fn main() {", "spec": "spec fn the_inv(&self) -> bool {\n\n#[invariant]"}}}, "all_snapshots": ["// rust_verify/tests/example.rs expect-warnings\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::*;\nuse vstd::prelude::*;\n\n#[verifier::verify]\npub enum ThreadState {\n    Idle,\n    SetFlag,\n    Waiting,\n    Critical,\n}\n\ntokenized_state_machine! { Petersons<T> {\n    fields {\n        #[sharding(variable)] pub flag_0: bool,\n        #[sharding(variable)] pub flag_1: bool,\n        #[sharding(variable)] pub turn: int,\n\n        #[sharding(variable)] pub thread_0: ThreadState,\n        #[sharding(variable)] pub thread_1: ThreadState,\n\n        #[sharding(storage_option)] pub storage: Option<T>,\n    }\n\n    #[invariant]\n    pub spec fn the_inv(&self) -> bool {\n        &&& (self.thread_0 === ThreadState::Idle) <==> !self.flag_0\n        &&& (self.thread_1 === ThreadState::Idle) <==> !self.flag_1\n        &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)\n        &&& self.storage.is_Some() <==>\n            (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)\n        &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag\n        &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag\n        &&& self.turn == 0 || self.turn == 1\n    }\n\n    init!{\n        initialize(t: T) {\n            init flag_0 = false;\n            init flag_1 = false;\n            init turn = 0;\n            init thread_0 = ThreadState::Idle;\n            init thread_1 = ThreadState::Idle;\n            init storage = Option::Some(t);\n        }\n    }\n\n    //// Thread 0 transitions\n\n    transition!{\n        t0_set_flag() {\n            require pre.thread_0 === ThreadState::Idle;\n            update thread_0 = ThreadState::SetFlag;\n\n            update flag_0 = true;\n        }\n    }\n\n    transition!{\n        t0_set_turn() {\n            require pre.thread_0 === ThreadState::SetFlag;\n            update thread_0 = ThreadState::Waiting;\n            update turn = 1;\n        }\n    }\n\n    transition!{\n        t0_enter_via_flag() {\n            require pre.thread_0 === ThreadState::Waiting;\n            require pre.flag_1 == false;\n            update thread_0 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t0_enter_via_turn() {\n            require pre.thread_0 === ThreadState::Waiting;\n            require pre.turn != 1;\n            update thread_0 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t0_done(t: T) {\n            require pre.thread_0 === ThreadState::Critical;\n            update thread_0 = ThreadState::Idle;\n            update flag_0 = false;\n            deposit storage += Some(t);\n        }\n    }\n\n    //// Thread 1 transitions\n\n    transition!{\n        t1_set_flag() {\n            require pre.thread_1 === ThreadState::Idle;\n            update thread_1 = ThreadState::SetFlag;\n\n            update flag_1 = true;\n        }\n    }\n\n    transition!{\n        t1_set_turn() {\n            require pre.thread_1 === ThreadState::SetFlag;\n            update thread_1 = ThreadState::Waiting;\n            update turn = 0;\n        }\n    }\n\n    transition!{\n        t1_enter_via_flag() {\n            require pre.thread_1 === ThreadState::Waiting;\n            require pre.flag_0 == false;\n            update thread_1 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t1_enter_via_turn() {\n            require pre.thread_1 === ThreadState::Waiting;\n            require pre.turn != 0;\n            update thread_1 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t1_done(t: T) {\n            require pre.thread_1 === ThreadState::Critical;\n            update thread_1 = ThreadState::Idle;\n            update flag_1 = false;\n            deposit storage += Some(t);\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) { }\n\n    #[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_enter_via_turn)]\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_done)]\n    fn t0_done_inductive(pre: Self, post: Self, t: T) { }\n\n    #[inductive(t1_set_flag)]\n    fn t1_set_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_set_turn)]\n    fn t1_set_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_enter_via_flag)]\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_enter_via_turn)]\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_done)]\n    fn t1_done_inductive(pre: Self, post: Self, t: T) { }\n}}\n\nfn main() {}\n", "use verus_state_machines_macros::*;\nuse vstd::prelude::*;\ntokenized_state_machine !{\n  a<b> {\n    fields {\n#[sharding(storage_option)] pub c : Option<b> }\n    }\n  }\n  fn main() {}", " use verus_state_machines_macros::*;\n        use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n           Idle,     SetFlag,     Waiting,     Critical, }\n        tokenized_state_machine! {\n       Petersons<T> {\n          fields {\n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }\n#[invariant]\n    pub spec fn the_inv(&self) -> bool {\n             &&& (self.thread_0 === ThreadState::Idle) <==> !self.flag_0         &&& (self.thread_1 === ThreadState::Idle) <==> !self.flag_1         &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)         &&& self.storage.is_Some() <==>             (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)         &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag         &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag         &&& self.turn == 0 || self.turn == 1     }\n          init!{\n             initialize(t: T) {\n                init flag_0 = false;\n                init flag_1 = false;\n                init turn = 0;\n                init thread_0 = ThreadState::Idle;\n                init thread_1 = ThreadState::Idle;\n                init storage = Option::Some(t);\n            }\n         }\n          transition!{\n             t0_set_flag() {}\n         }\n          transition!{\n             t0_set_turn() {}\n         }\n          transition!{\n             t0_enter_via_flag() {}\n         }\n          transition!{\n             t0_enter_via_turn() {}\n         }\n          transition!{\n             t0_done(t: T) {}\n         }\n          transition!{\n             t1_set_flag() {}\n         }\n          transition!{\n             t1_set_turn() {}\n         }\n          transition!{\n             t1_enter_via_flag() {}\n         }\n          transition!{\n             t1_enter_via_turn() {}\n         }\n          transition!{\n             t1_done(t: T) {}\n         }\n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) {}\n#[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t0_enter_via_turn)]\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t0_done)]\n    fn t0_done_inductive(pre: Self, post: Self, t: T) {}\n#[inductive(t1_set_flag)]\n    fn t1_set_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t1_set_turn)]\n    fn t1_set_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t1_enter_via_flag)]\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t1_enter_via_turn)]\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t1_done)]\n    fn t1_done_inductive(pre: Self, post: Self, t: T) {}\n      }\n      }\n        fn main() {}\n", " use verus_state_machines_macros::*;\n          use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n            Idle,     SetFlag,     Waiting,     Critical, }\n          tokenized_state_machine! {\n        Petersons<T> {           fields {  \n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }  \n#[invariant]\n    pub spec fn the_inv(&self) -> bool {              &&& (self.thread_0 === ThreadState::Idle) == !self.flag_0         &&& (self.thread_1 === ThreadState::Idle) == !self.flag_1         &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)         &&& self.storage.is_Some() ==             (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)         &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag         &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag         &&& self.turn == 0 || self.turn == 1     }           init!{              initialize(t: T) {                 init flag_0 = false;                 init flag_1 = false;                 init turn = 0;                 init thread_0 = ThreadState::Idle;                 init thread_1 = ThreadState::Idle;                 init storage = Option::Some(t);             }          }           transition!{              t0_set_flag() {}          }           transition!{              t0_set_turn() {}          }           transition!{              t0_enter_via_flag() {}          }           transition!{              t0_enter_via_turn() {}          }           transition!{              t0_done(t: T) {}          }           transition!{              t1_set_flag() {}          }           transition!{              t1_set_turn() {}          }           transition!{              t1_enter_via_flag() {}          }           transition!{              t1_enter_via_turn() {}          }           transition!{              t1_done(t: T) {}          }  \n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) {}  \n#[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) {}  \n#[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) {}  \n#[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) {}  \n#[inductive(t0_enter_via_turn)]\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) {}  \n#[inductive(t0_done)]\n    fn t0_done_inductive(pre: Self, post: Self, t: T) {}  \n#[inductive(t1_set_flag)]\n    fn t1_set_flag_inductive(pre: Self, post: Self) {}  \n#[inductive(t1_set_turn)]\n    fn t1_set_turn_inductive(pre: Self, post: Self) {}  \n#[inductive(t1_enter_via_flag)]\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) {}  \n#[inductive(t1_enter_via_turn)]\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) {}  \n#[inductive(t1_done)]\n    fn t1_done_inductive(pre: Self, post: Self, t: T) {}       }\n       }\n          fn main() {\n}\n", " use verus_state_machines_macros::*;\n            use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n              Idle,     SetFlag,     Waiting,     Critical, }\n            tokenized_state_machine! {\n          Petersons<T> {\n            fields {\n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }\n            init!{\n              initialize(t: T) {                 init flag_0 = false;                 init flag_1 = false;                 init turn = 0;                 init thread_0 = ThreadState::Idle;                 init thread_1 = ThreadState::Idle;                 init storage = Option::Some(t);             }\n          }\n            transition!{\n              t0_set_flag() {}\n          }\n            transition!{\n              t0_set_turn() {}\n          }\n            transition!{\n              t0_enter_via_flag() {}\n          }\n            transition!{\n              t0_enter_via_turn() {}\n          }\n            transition!{\n              t0_done(t: T) {}\n          }\n            transition!{\n              t1_set_flag() {}\n          }\n            transition!{\n              t1_set_turn() {}\n          }\n            transition!{\n              t1_enter_via_flag() {}\n          }\n            transition!{\n              t1_enter_via_turn() {}\n          }\n            transition!{\n              t1_done(t: T) {}\n          }\n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) {\n}\n#[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) {\n}\n#[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) {\n}\n#[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) {\n}\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) {\n}\n    fn t0_done_inductive(pre: Self, post: Self, t: T) {\n}\n    fn t1_set_flag_inductive(pre: Self, post: Self) {\n}\n    fn t1_set_turn_inductive(pre: Self, post: Self) {\n}\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) {\n}\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) {\n}\n    fn t1_done_inductive(pre: Self, post: Self, t: T) {\n}\n        }\n         }\n            fn main() {\n  }\n", " use verus_state_machines_macros::*;\n             use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n               Idle,     SetFlag,     Waiting,     Critical, }\n             tokenized_state_machine! {\n           Petersons<T> {\n             fields {\n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }\n             init!{\n               initialize(t: T) {\n                 init flag_0 = false;\n                 init flag_1 = false;\n                 init turn = 0;\n                 init thread_0 = ThreadState::Idle;\n                 init thread_1 = ThreadState::Idle;\n                 init storage = Option::Some(t);\n             }\n           }\n             transition!{\n               t0_set_flag() {\n}\n           }\n             transition!{\n               t0_set_turn() {\n}\n           }\n             transition!{\n               t0_enter_via_flag() {\n}\n           }\n             transition!{\n               t0_enter_via_turn() {\n}\n           }\n             transition!{\n               t0_done(t: T) {\n}\n           }\n             transition!{\n               t1_set_flag() {\n}\n           }\n             transition!{\n               t1_set_turn() {\n}\n           }\n             transition!{\n               t1_enter_via_flag() {\n}\n           }\n             transition!{\n               t1_enter_via_turn() {\n}\n           }\n             transition!{\n               t1_done(t: T) {\n}\n           }\n         }\n          }\n             fn main() {\n   }\n", "use verus_state_machines_macros::*;\nuse vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n  Idle,\n  SetFlagWaitingCritical} tokenized_state_machine !{\n  Petersons< T > {\n    fields {\n#[sharding(variable)] pub flag_0 : bool,\n#[sharding(variable)] pub flag_1 : bool,\n#[sharding(variable)] pub turn : int,\n#[sharding(variable)] pub thread_0 : ThreadState,\n#[sharding(variable)] pub thread_1 : ThreadState,\n#[sharding(storage_option)] pub storage : Option<T>,\n    }\n    init !{\n      initialize(t : T) {\n        init flag_0 = false;\n        init flag_1 = false;\n        init turn = 0;\n        init thread_0 = ThreadState::Idle;\n        init thread_1 = ThreadState::Idle;\n        init storage = Option::Some(t);\n      }\n    }\n  }\n}\nfn main() {}\n", "use verus_state_machines_macros::*;\nuse vstd::prelude::*;\n#[verifier::verify]\npub enum a {\n  b} tokenized_state_machine !{\n  c< d > {\n    fields {\n#[sharding(variable)] pub e : bool,\n#[sharding(variable)] pub f : bool,\n#[sharding(variable)] pub turn : int,\n#[sharding(variable)] pub thread_0 : a,\n#[sharding(variable)] pub thread_1 : a,\n#[sharding(storage_option)] pub storage : Option<d>}\n    init !{\n      initialize(t : d) {\n        init e = false;\n        init f = false;\n        init turn = 0;\n        init thread_0 = a::b;\n        init thread_1 = a::b;\n        init storage = Some(t);\n      }\n    }\n  }\n}\nfn main() {}\n", "use verus_state_machines_macros::*;\n   use vstd::prelude::*;\n#[verifier::verify]\npub enum a {\n    b}\n   tokenized_state_machine !{\n    c< d > {\n     fields {   \n#[sharding(variable)] pub e : bool,\n#[sharding(variable)] pub f : bool,\n#[sharding(variable)] pub turn : int,\n#[sharding(variable)] pub g : a,\n#[sharding(variable)] pub h : a,\n#[sharding(storage_option)] pub i : Option<d>}\n    init !{       initialize(j : d) {         init e = false;         init f = false;         init turn = 0;         init g = a::b;         init h = a::b;         init i = Some(j);       }     }   }\n }\n  fn main() {\n}\n", "use verus_state_machines_macros::*;\nuse vstd::prelude::*;\nenum a { } tokenized_state_machine !{\n  c< d > {\n    fields {\n#[sharding(storage_option)] pub i : Option<d> }\n    }\n  }\n  fn main() {}\n", "use verus_state_machines_macros::*;\n use vstd::prelude::*;\n tokenized_state_machine !{   a< b > {     fields { \n#[sharding(storage_option)] pub c : Option<b> }\n    }   }   fn main() {} "]}
{"id": "strategy_option_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\nuse vstd::prelude::*;\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\nverus! {\n\n// ANCHOR: full\ntokenized_state_machine!{ State {\n    fields {\n        #[sharding(variable)]\n        pub token_exists: bool,\n\n        #[sharding(option)]\n        pub field: Option<int>,\n    }\n\n    #[invariant]\n    pub fn token_exists_correct(&self) -> bool {\n        self.token_exists <==> self.field is Some\n    }\n\n    init!{\n        initialize(v: int) {\n            init field = Option::Some(v);\n            init token_exists = true;\n        }\n    }\n\n    transition!{\n        add_token(v: int) {\n            require !pre.token_exists;\n            update token_exists = true;\n\n            add field += Some(v);\n        }\n    }\n\n    transition!{\n        remove_token() {\n            remove field -= Some(let _);\n\n            assert pre.token_exists;\n            update token_exists = false;\n        }\n    }\n\n    transition!{\n        have_token() {\n            have field >= Some(let _);\n\n            assert pre.token_exists;\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, v: int) { }\n\n    #[inductive(add_token)]\n    fn add_token_inductive(pre: Self, post: Self, v: int) { }\n\n    #[inductive(remove_token)]\n    fn remove_token_inductive(pre: Self, post: Self) { }\n\n    #[inductive(have_token)]\n    fn have_token_inductive(pre: Self, post: Self) { }\n}}\n\nproof fn option_example() {\n    let tracked (Tracked(instance), Tracked(mut token_exists), Tracked(token_opt)) =\n        State::Instance::initialize(5);\n\n    let tracked token = token_opt.tracked_unwrap();\n    assert(token.value() == 5);\n\n    instance.have_token(&token_exists, &token);\n    assert(token_exists.value() == true);\n\n    instance.remove_token(&mut token_exists, token);  // consumes token\n    assert(token_exists.value() == false);            // updates token_exists to `false`\n\n    let tracked token = instance.add_token(19, &mut token_exists);\n    assert(token_exists.value() == true);  // updates token_exists to `true`\n    assert(token.value() == 19);           // new token has value 19\n}\n\n// ANCHOR_END: full\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "use vstd::prelude::*;\n          use verus_state_machines_macros::tokenized_state_machine;\n          verus! {\n        tokenized_state_machine!{       State {          fields {  \n#[sharding(variable)]\n        pub token_exists: bool,                  \n#[sharding(option)]\n        pub field: Option<int>,     }  \n#[invariant]\n    pub fn token_exists_correct(&self) -> bool {             self.token_exists == self.field is Some     }          init!{             initialize(v: int) {                init field = Option::Some(v);                init token_exists = true;            }         }          transition!{             add_token(v: int) {}         }          transition!{             remove_token() {}         }          transition!{             have_token() {}         }  \n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, v: int) {}  \n#[inductive(add_token)]\n    fn add_token_inductive(pre: Self, post: Self, v: int) {}  \n#[inductive(remove_token)]\n    fn remove_token_inductive(pre: Self, post: Self) {}  \n#[inductive(have_token)]\n    fn have_token_inductive(pre: Self, post: Self) {}      }      }\n        fn main() ;\n        }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/reference-examples/strategy_option.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 786, "minimize_time_ms": 491041, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 92, "minimized_LOC": 20, "self_contained": false, "dependencies": ["vstd::prelude::", "verus_state_machines_macros::tokenized_state_machine"], "complexity_verus_tokens": 2, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.21739130434782608}, "labeling": {"segments": {"exec": " pub fn token_exists_correct(&self) -> bool {\n\n fn initialize_inductive(post: Self, v: int) {\n\n fn add_token_inductive(pre: Self, post: Self, v: int) {\n\n fn remove_token_inductive(pre: Self, post: Self) {\n\n fn have_token_inductive(pre: Self, post: Self) {", "spec": "#[invariant]"}}}, "all_snapshots": ["#![allow(unused_imports)]\n\nuse vstd::prelude::*;\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\nverus! {\n\n// ANCHOR: full\ntokenized_state_machine!{ State {\n    fields {\n        #[sharding(variable)]\n        pub token_exists: bool,\n\n        #[sharding(option)]\n        pub field: Option<int>,\n    }\n\n    #[invariant]\n    pub fn token_exists_correct(&self) -> bool {\n        self.token_exists <==> self.field is Some\n    }\n\n    init!{\n        initialize(v: int) {\n            init field = Option::Some(v);\n            init token_exists = true;\n        }\n    }\n\n    transition!{\n        add_token(v: int) {\n            require !pre.token_exists;\n            update token_exists = true;\n\n            add field += Some(v);\n        }\n    }\n\n    transition!{\n        remove_token() {\n            remove field -= Some(let _);\n\n            assert pre.token_exists;\n            update token_exists = false;\n        }\n    }\n\n    transition!{\n        have_token() {\n            have field >= Some(let _);\n\n            assert pre.token_exists;\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, v: int) { }\n\n    #[inductive(add_token)]\n    fn add_token_inductive(pre: Self, post: Self, v: int) { }\n\n    #[inductive(remove_token)]\n    fn remove_token_inductive(pre: Self, post: Self) { }\n\n    #[inductive(have_token)]\n    fn have_token_inductive(pre: Self, post: Self) { }\n}}\n\nproof fn option_example() {\n    let tracked (Tracked(instance), Tracked(mut token_exists), Tracked(token_opt)) =\n        State::Instance::initialize(5);\n\n    let tracked token = token_opt.tracked_unwrap();\n    assert(token.value() == 5);\n\n    instance.have_token(&token_exists, &token);\n    assert(token_exists.value() == true);\n\n    instance.remove_token(&mut token_exists, token);  // consumes token\n    assert(token_exists.value() == false);            // updates token_exists to `false`\n\n    let tracked token = instance.add_token(19, &mut token_exists);\n    assert(token_exists.value() == true);  // updates token_exists to `true`\n    assert(token.value() == 19);           // new token has value 19\n}\n\n// ANCHOR_END: full\nfn main() {\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\n          use verus_state_machines_macros::tokenized_state_machine;\n          verus! {\n        tokenized_state_machine!{       State {          fields {  \n#[sharding(variable)]\n        pub token_exists: bool,                  \n#[sharding(option)]\n        pub field: Option<int>,     }  \n#[invariant]\n    pub fn token_exists_correct(&self) -> bool {             self.token_exists == self.field is Some     }          init!{             initialize(v: int) {                init field = Option::Some(v);                init token_exists = true;            }         }          transition!{             add_token(v: int) {}         }          transition!{             remove_token() {}         }          transition!{             have_token() {}         }  \n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, v: int) {}  \n#[inductive(add_token)]\n    fn add_token_inductive(pre: Self, post: Self, v: int) {}  \n#[inductive(remove_token)]\n    fn remove_token_inductive(pre: Self, post: Self) {}  \n#[inductive(have_token)]\n    fn have_token_inductive(pre: Self, post: Self) {}      }      }\n        fn main() ;\n        }\n", "use vstd::prelude::*;\n               use verus_state_machines_macros::tokenized_state_machine;\n               verus! {\n             tokenized_state_machine!{\n           State {\n             fields {\n#[sharding(variable)]\n        pub token_exists: bool,                       \n#[sharding(option)]\n        pub field: Option<int>,     }\n             init!{\n               initialize(v: int) {\n                 init field = Option::Some(v);\n                 init token_exists = true;\n             }\n           }\n         }\n          }\n             fn main() ;\n             }\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nverus !{\n  tokenized_state_machine !{\n    State {\n      fields{\n#[sharding(variable)]\n        pub token_exists : bool,\n#[sharding(option)]\n        pub field : Option< int >} init !{\n        initialize(v : int) {\n          init field = Some(v);\n          init token_exists = true;\n        }\n      }\n    }\n  }\n  fn main();\n}\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nverus !{\n  tokenized_state_machine !{\n    a {\n      fields{\n#[sharding(variable)]\n        pub b : bool,\n#[sharding(option)]\n        pub c : Option< int >} init !{\n        d(e : int) {\n          init c = Some(e);\n          init b = true;\n        }\n      }\n    }\n  }\n  fn main();\n}\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nverus !{\n  tokenized_state_machine !{\n    a {\n      fields {\n#[sharding(variable)]\n        pub b : bool,\n#[sharding(option)]\n                pub c : Option< int >\n      }\n    }\n  }\n  fn main();\n}\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nverus !{\n  tokenized_state_machine !{\n    a {\n      fields {\n}\n    }\n  }\n  fn main();\n}\n", "use vstd::prelude::*;\n   verus !{\n    fn main();\n  }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "refinement_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nstate_machine! {\n    B {\n        fields {\n            pub number: int,\n        }\n\n        init!{\n            initialize() {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                require(n % 2 == 0);\n                update number = pre.number + n;\n            }\n        }\n\n        #[invariant]\n        pub fn is_even(&self) -> bool {\n            self.number % 2 == 0\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n    }\n}\n\nstate_machine! {\n    A {\n        fields {\n            pub number: int,\n        }\n\n        init!{\n            initialize() {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                update number = pre.number + n;\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n    }\n}\n\nverus! {\n\nspec fn interp(a: A::State) -> B::State {\n    B::State { number: a.number * 2 }\n}\n\nproof fn next_refines_next(pre: A::State, post: A::State) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n    );\n    ensures(B::State::next(interp(pre), interp(post)));\n    reveal(A::State::next);\n    match choose|step: A::Step| A::State::next_by(pre, post, step) {\n        A::Step::add(n) => {\n            assert_by(\n                A::State::add(pre, post, n),\n                {\n                    reveal(A::State::next_by);\n                },\n            );\n            B::show::add(interp(pre), interp(post), 2 * n);\n        },\n        A::Step::dummy_to_use_type_params(_) => {\n            assume(false);  // TODO\n        },\n    }\n}\n\nproof fn next_refines_next_with_macro(pre: A::State, post: A::State) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n    );\n    ensures(B::State::next(interp(pre), interp(post)));\n    case_on_next!{pre, post, A => {\n        add(n) => {\n            assert(0u32 === 0u32); // test verus syntax\n            B::show::add(interp(pre), interp(post), 2 * n);\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: A::State) {\n    requires(post.invariant() && A::State::init(post));\n    ensures(B::State::init(interp(post)));\n    case_on_init!{post, A => {\n        initialize() => {\n            B::show::initialize(interp(post));\n        }\n    }}\n}\n\n} // verus!\nfn main() {}\n", "minimized_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nstate_machine! {\n    B {\n        fields {\n            pub number: int,\n        }\n\n        init!{\n            initialize() {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                require(n % 2 == 0);\n                update number = pre.number + n;\n            }\n        }\n\n        #[invariant]\n        pub fn is_even(&self) -> bool {\n            self.number % 2 == 0\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n    }\n}\n\nstate_machine! {\n    A {\n        fields {\n            pub number: int,\n        }\n\n        init!{\n            initialize() {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                update number = pre.number + n;\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n    }\n}\n\nverus! {\n\nspec fn interp(a: A::State) -> B::State {\n    B::State { number: a.number * 2 }\n}\n\nproof fn next_refines_next(pre: A::State, post: A::State) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n    );\n    ensures(B::State::next(interp(pre), interp(post)));\n    reveal(A::State::next);\n    match choose|step: A::Step| A::State::next_by(pre, post, step) {\n        A::Step::add(n) => {\n            assert_by(\n                A::State::add(pre, post, n),\n                {\n                    reveal(A::State::next_by);\n                },\n            );\n            B::show::add(interp(pre), interp(post), 2 * n);\n        },\n        A::Step::dummy_to_use_type_params(_) => {\n            assume(false);  // TODO\n        },\n    }\n}\n\nproof fn next_refines_next_with_macro(pre: A::State, post: A::State) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n    );\n    ensures(B::State::next(interp(pre), interp(post)));\n    case_on_next!{pre, post, A => {\n        add(n) => {\n            assert(0u32 === 0u32); // test verus syntax\n            B::show::add(interp(pre), interp(post), 2 * n);\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: A::State) {\n    requires(post.invariant() && A::State::init(post));\n    ensures(B::State::init(interp(post)));\n    case_on_init!{post, A => {\n        initialize() => {\n            B::show::initialize(interp(post));\n        }\n    }}\n}\n\n} // verus!\nfn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/refinement.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 804, "minimize_time_ms": 153584, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 121, "minimized_LOC": 121, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::", "verus_state_machines_macros::case_on_init", "verus_state_machines_macros::case_on_next", "verus_state_machines_macros::state_machine"], "complexity_verus_tokens": 22, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_invariant": true, "requires_count": 3, "ensures_count": 3, "segments": {"exec": " pub fn is_even(&self) -> bool {\n\n fn initialize_inductive(post: Self) {\n\n fn add_inductive(pre: Self, post: Self, n: int) {\n\n fn initialize_inductive(post: Self) {\n\n fn add_inductive(pre: Self, post: Self, n: int) {\n\n\nfn main() {", "spec": "spec fn interp(a: A::State) -> B::State {\n\n        #[invariant]\n\n    requires(\n\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n\n    ensures(B::State::next(interp(pre), interp(post)));\n\n    requires(\n\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n\n    ensures(B::State::next(interp(pre), interp(post)));\n\n    requires(post.invariant() && A::State::init(post));\n\n    ensures(B::State::init(interp(post)));", "proof": "proof fn next_refines_next(pre: A::State, post: A::State) {\n\nproof fn next_refines_next_with_macro(pre: A::State, post: A::State) {\n\nproof fn init_refines_init_with_macro(post: A::State) {"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nstate_machine! {\n    B {\n        fields {\n            pub number: int,\n        }\n\n        init!{\n            initialize() {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                require(n % 2 == 0);\n                update number = pre.number + n;\n            }\n        }\n\n        #[invariant]\n        pub fn is_even(&self) -> bool {\n            self.number % 2 == 0\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n    }\n}\n\nstate_machine! {\n    A {\n        fields {\n            pub number: int,\n        }\n\n        init!{\n            initialize() {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                update number = pre.number + n;\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n    }\n}\n\nverus! {\n\nspec fn interp(a: A::State) -> B::State {\n    B::State { number: a.number * 2 }\n}\n\nproof fn next_refines_next(pre: A::State, post: A::State) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n    );\n    ensures(B::State::next(interp(pre), interp(post)));\n    reveal(A::State::next);\n    match choose|step: A::Step| A::State::next_by(pre, post, step) {\n        A::Step::add(n) => {\n            assert_by(\n                A::State::add(pre, post, n),\n                {\n                    reveal(A::State::next_by);\n                },\n            );\n            B::show::add(interp(pre), interp(post), 2 * n);\n        },\n        A::Step::dummy_to_use_type_params(_) => {\n            assume(false);  // TODO\n        },\n    }\n}\n\nproof fn next_refines_next_with_macro(pre: A::State, post: A::State) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n    );\n    ensures(B::State::next(interp(pre), interp(post)));\n    case_on_next!{pre, post, A => {\n        add(n) => {\n            assert(0u32 === 0u32); // test verus syntax\n            B::show::add(interp(pre), interp(post), 2 * n);\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: A::State) {\n    requires(post.invariant() && A::State::init(post));\n    ensures(B::State::init(interp(post)));\n    case_on_init!{post, A => {\n        initialize() => {\n            B::show::initialize(interp(post));\n        }\n    }}\n}\n\n} // verus!\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n         use verus_state_machines_macros::state_machine;\n         state_machine! {            B {               fields {}           }        }\n         state_machine! {            A {               fields {}           }        }\n          fn main() {}\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "refinement_labels_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nstate_machine! {\n    B {\n        fields {\n            pub number: int,\n        }\n\n        pub struct InitLabel { }\n        pub struct Label { }\n\n        init!{\n            initialize(label: InitLabel) {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(label: Label, n: int) {\n                require(n % 2 == 0);\n                update number = pre.number + n;\n            }\n        }\n\n        #[invariant]\n        pub fn is_even(&self) -> bool {\n            self.number % 2 == 0\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, label: InitLabel) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, label: Label, n: int) { }\n    }\n}\n\nstate_machine! {\n    A {\n        fields {\n            pub number: int,\n        }\n\n        pub type Label = B::Label;\n        pub type InitLabel = B::InitLabel;\n\n        init!{\n            initialize(label: InitLabel) {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(label: Label, n: int) {\n                update number = pre.number + n;\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, label: InitLabel) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, label: Label, n: int) { }\n    }\n}\n\nverus! {\n\nspec fn interp(a: A::State) -> B::State {\n    B::State { number: a.number * 2 }\n}\n\nproof fn next_refines_next(pre: A::State, post: A::State, label: B::Label) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(\n            pre,\n            post,\n            label,\n        ),\n    );\n    ensures(B::State::next(interp(pre), interp(post), label));\n    reveal(A::State::next);\n    match choose|step: A::Step| A::State::next_by(pre, post, label, step) {\n        A::Step::add(n) => {\n            assert_by(\n                A::State::add(pre, post, label, n),\n                {\n                    reveal(A::State::next_by);\n                },\n            );\n            B::show::add(interp(pre), interp(post), label, 2 * n);\n        },\n        A::Step::dummy_to_use_type_params(_) => {\n            assume(false);  // TODO\n        },\n    }\n}\n\nproof fn next_refines_next_with_macro(pre: A::State, post: A::State, label: B::Label) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(\n            pre,\n            post,\n            label,\n        ),\n    );\n    ensures(B::State::next(interp(pre), interp(post), label));\n    case_on_next!{pre, post, label, A => {\n        add(n) => {\n            assert(0u32 === 0u32); // test verus syntax\n            B::show::add(interp(pre), interp(post), label, 2 * n);\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: A::State, label: B::InitLabel) {\n    requires(post.invariant() && A::State::init(post, label));\n    ensures(B::State::init(interp(post), label));\n    case_on_init!{post, label, A => {\n        initialize() => {\n            B::show::initialize(interp(post), label);\n        }\n    }}\n}\n\n} // verus!\nfn main() {}\n", "minimized_code": "use verus_builtin::*;\n        use verus_state_machines_macros::state_machine;\n        state_machine! {\n           B {\n              fields {\n                 pub number: int,         }\n          }\n       }\n        state_machine! {\n           A {\n              fields {\n                 pub number: int,         }\n          }\n       }\n         fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/refinement_labels.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 927, "minimize_time_ms": 154549, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 135, "minimized_LOC": 16, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::", "verus_state_machines_macros::case_on_init", "verus_state_machines_macros::case_on_next", "verus_state_machines_macros::state_machine"], "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.11851851851851852}, "labeling": {"segments": {"exec": " fn main() {"}}}, "all_snapshots": ["#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nstate_machine! {\n    B {\n        fields {\n            pub number: int,\n        }\n\n        pub struct InitLabel { }\n        pub struct Label { }\n\n        init!{\n            initialize(label: InitLabel) {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(label: Label, n: int) {\n                require(n % 2 == 0);\n                update number = pre.number + n;\n            }\n        }\n\n        #[invariant]\n        pub fn is_even(&self) -> bool {\n            self.number % 2 == 0\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, label: InitLabel) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, label: Label, n: int) { }\n    }\n}\n\nstate_machine! {\n    A {\n        fields {\n            pub number: int,\n        }\n\n        pub type Label = B::Label;\n        pub type InitLabel = B::InitLabel;\n\n        init!{\n            initialize(label: InitLabel) {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(label: Label, n: int) {\n                update number = pre.number + n;\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, label: InitLabel) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, label: Label, n: int) { }\n    }\n}\n\nverus! {\n\nspec fn interp(a: A::State) -> B::State {\n    B::State { number: a.number * 2 }\n}\n\nproof fn next_refines_next(pre: A::State, post: A::State, label: B::Label) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(\n            pre,\n            post,\n            label,\n        ),\n    );\n    ensures(B::State::next(interp(pre), interp(post), label));\n    reveal(A::State::next);\n    match choose|step: A::Step| A::State::next_by(pre, post, label, step) {\n        A::Step::add(n) => {\n            assert_by(\n                A::State::add(pre, post, label, n),\n                {\n                    reveal(A::State::next_by);\n                },\n            );\n            B::show::add(interp(pre), interp(post), label, 2 * n);\n        },\n        A::Step::dummy_to_use_type_params(_) => {\n            assume(false);  // TODO\n        },\n    }\n}\n\nproof fn next_refines_next_with_macro(pre: A::State, post: A::State, label: B::Label) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(\n            pre,\n            post,\n            label,\n        ),\n    );\n    ensures(B::State::next(interp(pre), interp(post), label));\n    case_on_next!{pre, post, label, A => {\n        add(n) => {\n            assert(0u32 === 0u32); // test verus syntax\n            B::show::add(interp(pre), interp(post), label, 2 * n);\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: A::State, label: B::InitLabel) {\n    requires(post.invariant() && A::State::init(post, label));\n    ensures(B::State::init(interp(post), label));\n    case_on_init!{post, label, A => {\n        initialize() => {\n            B::show::initialize(interp(post), label);\n        }\n    }}\n}\n\n} // verus!\nfn main() {}\n", "use verus_builtin;\nfn main() {}\n", "use verus_builtin::*;\n        use verus_state_machines_macros::state_machine;\n        state_machine! {\n           B {\n              fields {\n                 pub number: int,         }\n          }\n       }\n        state_machine! {\n           A {\n              fields {\n                 pub number: int,         }\n          }\n       }\n         fn main() {\n      }\n", "use verus_builtin::*;\n                 fn main() {\n      }\n", "use verus_builtin;\nfn main() {}\n"]}
{"id": "rwlock_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::cell::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// TODO make T generic\n#[verifier::verify]\npub struct T {\n    t: u8,\n}\n\ntokenized_state_machine!(RwLock {\n    fields {\n        #[sharding(variable)]\n        pub flags: (bool, nat),\n\n        #[sharding(storage_option)]\n        pub storage: Option<T>,\n\n        #[sharding(option)]\n        pub pending_writer: Option<()>,\n\n        #[sharding(option)]\n        pub writer: Option<()>,\n\n        #[sharding(multiset)]\n        pub pending_reader: Multiset<()>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<T>,\n    }\n\n    init!{\n        initialize_empty() {\n            init flags = (true, 0);\n            init storage = Option::None;\n            init pending_writer = Option::None;\n            init writer = Option::Some(());\n            init pending_reader = Multiset::empty();\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    /// Increment the 'rc' counter, obtain a pending_reader\n    transition!{\n        acquire_read_start() {\n            update flags = (pre.flags.0, pre.flags.1 + 1);\n            add pending_reader += {()};\n        }\n    }\n\n    /// Exchange the pending_reader for a reader by checking\n    /// that the 'exc' bit is 0\n    transition!{\n        acquire_read_end() {\n            require(pre.flags.0 == false);\n\n            remove pending_reader -= {()};\n\n            birds_eye let x: T = pre.storage.get_Some_0();\n            add reader += {x};\n        }\n    }\n\n    /// Decrement the 'rc' counter, abandon the attempt to gain\n    /// the 'read' lock.\n    transition!{\n        acquire_read_abandon() {\n            remove pending_reader -= {()};\n            assert(pre.flags.1 >= 1);\n            update flags = (pre.flags.0, (pre.flags.1 - 1) as nat);\n        }\n    }\n\n    /// Atomically set 'exc' bit from 'false' to 'true'\n    /// Obtain a pending_writer\n    transition!{\n        acquire_exc_start() {\n            require(pre.flags.0 == false);\n            update flags = (true, pre.flags.1);\n            add pending_writer += Some(());\n        }\n    }\n\n    /// Finish obtaining the write lock by checking that 'rc' is 0.\n    /// Exchange the pending_writer for a writer and withdraw the\n    /// stored object.\n    transition!{\n        acquire_exc_end() {\n            require(pre.flags.1 == 0);\n\n            remove pending_writer -= Some(());\n\n            add writer += Some(());\n\n            birds_eye let x = pre.storage.get_Some_0();\n            withdraw storage -= Some(x);\n        }\n    }\n\n    /// Release the write-lock. Update the 'exc' bit back to 'false'.\n    /// Return the 'writer' and also deposit an object back into storage.\n    transition!{\n        release_exc(x: T) {\n            remove writer -= Some(());\n\n            update flags = (false, pre.flags.1);\n\n            deposit storage += Some(x);\n        }\n    }\n\n    /// Check that the 'reader' is actually a guard for the given object.\n    property!{\n        read_guard(x: T) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    /// Release the reader-lock. Decrement 'rc' and return the 'reader' object.\n    #[transition]\n    transition!{\n        release_shared(x: T) {\n            remove reader -= {x};\n\n            assert(pre.flags.1 >= 1) by {\n                //assert(pre.reader.count(x) >= 1);\n                assert(equal(pre.storage, Option::Some(x)));\n                //assert(equal(x, pre.storage.get_Some_0()));\n            };\n            update flags = (pre.flags.0, (pre.flags.1 - 1) as nat);\n        }\n    }\n\n    #[invariant]\n    pub fn exc_bit_matches(&self) -> bool {\n        (if self.flags.0 { 1 } else { 0 as int }) ==\n            (if self.pending_writer.is_Some() { 1 } else { 0 as int }) as int\n            + (if self.writer.is_Some() { 1 } else { 0 as int }) as int\n    }\n\n    #[invariant]\n    pub fn count_matches(&self) -> bool {\n        self.flags.1 == self.pending_reader.count(())\n            + self.reader.count(self.storage.get_Some_0())\n    }\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: T| self.reader.count(t) > 0 ==>\n            equal(self.storage, Option::Some(t))\n    }\n\n    #[invariant]\n    pub fn writer_agrees_storage(&self) -> bool {\n        self.writer.is_Some() ==> self.storage.is_None()\n    }\n\n    #[invariant]\n    pub fn writer_agrees_storage_rev(&self) -> bool {\n        self.storage.is_None() ==> self.writer.is_Some()\n    }\n\n    #[inductive(acquire_read_start)]\n    fn acquire_read_start_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_read_end)]\n    fn acquire_read_end_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_read_abandon)]\n    fn acquire_read_abandon_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_exc_start)]\n    fn acquire_exc_start_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_exc_end)]\n    fn acquire_exc_end_inductive(pre: Self, post: Self) { }\n\n    #[inductive(release_exc)]\n    fn release_exc_inductive(pre: Self, post: Self, x: T) { }\n\n    #[inductive(release_shared)]\n    fn release_shared_inductive(pre: Self, post: Self, x: T) {\n        assert(equal(pre.storage, Option::Some(x)));\n    }\n});\n\nfn main() {}\n", "minimized_code": "  use vstd::prelude::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\npub struct T ;\n        tokenized_state_machine!(RwLock {\n           fields {\n#[sharding(variable)]\n        pub flags: (bool, nat),                \n#[sharding(storage_option)]\n        pub storage: Option<T>,                \n#[sharding(option)]\n        pub pending_writer: Option<()>,                \n#[sharding(option)]\n        pub writer: Option<()>,                \n#[sharding(multiset)]\n        pub pending_reader: Multiset<()>,                \n#[sharding(multiset)]\n        pub reader: Multiset<T>,     }\n           transition!{\n              acquire_read_start() {}\n          }\n           transition!{\n              acquire_read_end() {}\n          }\n           transition!{\n              acquire_read_abandon() {}\n          }\n           transition!{\n              acquire_exc_start() {}\n          }\n           transition!{\n              acquire_exc_end() {}\n          }\n           transition!{\n              release_exc(x: T) {}\n          }\n                transition!{\n              release_shared(x: T) {}\n          }\n#[invariant]\n    pub fn exc_bit_matches(&self) -> bool {\n              (if self.flags.0 {\n     1 }\n      else {\n     0 as int }\n     ) ==             (if self.pending_writer.is_Some() {\n     1 }\n      else {\n     0 as int }\n     ) as int             + (if self.writer.is_Some() {\n     1 }\n      else {\n     0 as int }\n     ) as int     }\n#[invariant]\n    pub fn count_matches(&self) -> bool {\n              self.flags.1 == self.pending_reader.count(())             + self.reader.count(self.storage.get_Some_0())     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n              forall |t: T| self.reader.count(t) > 0 ==>             equal(self.storage, Option::Some(t))     }\n#[invariant]\n    pub fn writer_agrees_storage(&self) -> bool {\n              self.writer.is_Some() ==> self.storage.is_None()     }\n#[invariant]\n    pub fn writer_agrees_storage_rev(&self) -> bool {\n              self.storage.is_None() ==> self.writer.is_Some()     }\n#[inductive(acquire_read_start)]\n    fn acquire_read_start_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_read_end)]\n    fn acquire_read_end_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_read_abandon)]\n    fn acquire_read_abandon_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_exc_start)]\n    fn acquire_exc_start_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_exc_end)]\n    fn acquire_exc_end_inductive(pre: Self, post: Self) {}\n#[inductive(release_exc)]\n    fn release_exc_inductive(pre: Self, post: Self, x: T) {}\n#[inductive(release_shared)]\n    fn release_shared_inductive(pre: Self, post: Self, x: T) {}\n       }\n       );\n        fn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/rwlock.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1439, "minimize_time_ms": 490506, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 197, "minimized_LOC": 83, "self_contained": false, "dependencies": ["verus_builtin::", "vstd::cell::", "vstd::multiset::", "vstd::prelude::", "vstd::", "verus_state_machines_macros::tokenized_state_machine"], "complexity_verus_tokens": 5, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.4213197969543147}, "labeling": {"segments": {"exec": " pub fn exc_bit_matches(&self) -> bool {\n\n pub fn count_matches(&self) -> bool {\n\n pub fn reader_agrees_storage(&self) -> bool {\n\n pub fn writer_agrees_storage(&self) -> bool {\n\n pub fn writer_agrees_storage_rev(&self) -> bool {\n\n fn acquire_read_start_inductive(pre: Self, post: Self) {\n\n fn acquire_read_end_inductive(pre: Self, post: Self) {\n\n fn acquire_read_abandon_inductive(pre: Self, post: Self) {\n\n fn acquire_exc_start_inductive(pre: Self, post: Self) {\n\n fn acquire_exc_end_inductive(pre: Self, post: Self) {\n\n fn release_exc_inductive(pre: Self, post: Self, x: T) {\n\n fn release_shared_inductive(pre: Self, post: Self, x: T) {\n\n fn main() {", "spec": "#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]\n\n#[invariant]"}}}, "all_snapshots": ["// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::cell::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// TODO make T generic\n#[verifier::verify]\npub struct T {\n    t: u8,\n}\n\ntokenized_state_machine!(RwLock {\n    fields {\n        #[sharding(variable)]\n        pub flags: (bool, nat),\n\n        #[sharding(storage_option)]\n        pub storage: Option<T>,\n\n        #[sharding(option)]\n        pub pending_writer: Option<()>,\n\n        #[sharding(option)]\n        pub writer: Option<()>,\n\n        #[sharding(multiset)]\n        pub pending_reader: Multiset<()>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<T>,\n    }\n\n    init!{\n        initialize_empty() {\n            init flags = (true, 0);\n            init storage = Option::None;\n            init pending_writer = Option::None;\n            init writer = Option::Some(());\n            init pending_reader = Multiset::empty();\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    /// Increment the 'rc' counter, obtain a pending_reader\n    transition!{\n        acquire_read_start() {\n            update flags = (pre.flags.0, pre.flags.1 + 1);\n            add pending_reader += {()};\n        }\n    }\n\n    /// Exchange the pending_reader for a reader by checking\n    /// that the 'exc' bit is 0\n    transition!{\n        acquire_read_end() {\n            require(pre.flags.0 == false);\n\n            remove pending_reader -= {()};\n\n            birds_eye let x: T = pre.storage.get_Some_0();\n            add reader += {x};\n        }\n    }\n\n    /// Decrement the 'rc' counter, abandon the attempt to gain\n    /// the 'read' lock.\n    transition!{\n        acquire_read_abandon() {\n            remove pending_reader -= {()};\n            assert(pre.flags.1 >= 1);\n            update flags = (pre.flags.0, (pre.flags.1 - 1) as nat);\n        }\n    }\n\n    /// Atomically set 'exc' bit from 'false' to 'true'\n    /// Obtain a pending_writer\n    transition!{\n        acquire_exc_start() {\n            require(pre.flags.0 == false);\n            update flags = (true, pre.flags.1);\n            add pending_writer += Some(());\n        }\n    }\n\n    /// Finish obtaining the write lock by checking that 'rc' is 0.\n    /// Exchange the pending_writer for a writer and withdraw the\n    /// stored object.\n    transition!{\n        acquire_exc_end() {\n            require(pre.flags.1 == 0);\n\n            remove pending_writer -= Some(());\n\n            add writer += Some(());\n\n            birds_eye let x = pre.storage.get_Some_0();\n            withdraw storage -= Some(x);\n        }\n    }\n\n    /// Release the write-lock. Update the 'exc' bit back to 'false'.\n    /// Return the 'writer' and also deposit an object back into storage.\n    transition!{\n        release_exc(x: T) {\n            remove writer -= Some(());\n\n            update flags = (false, pre.flags.1);\n\n            deposit storage += Some(x);\n        }\n    }\n\n    /// Check that the 'reader' is actually a guard for the given object.\n    property!{\n        read_guard(x: T) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    /// Release the reader-lock. Decrement 'rc' and return the 'reader' object.\n    #[transition]\n    transition!{\n        release_shared(x: T) {\n            remove reader -= {x};\n\n            assert(pre.flags.1 >= 1) by {\n                //assert(pre.reader.count(x) >= 1);\n                assert(equal(pre.storage, Option::Some(x)));\n                //assert(equal(x, pre.storage.get_Some_0()));\n            };\n            update flags = (pre.flags.0, (pre.flags.1 - 1) as nat);\n        }\n    }\n\n    #[invariant]\n    pub fn exc_bit_matches(&self) -> bool {\n        (if self.flags.0 { 1 } else { 0 as int }) ==\n            (if self.pending_writer.is_Some() { 1 } else { 0 as int }) as int\n            + (if self.writer.is_Some() { 1 } else { 0 as int }) as int\n    }\n\n    #[invariant]\n    pub fn count_matches(&self) -> bool {\n        self.flags.1 == self.pending_reader.count(())\n            + self.reader.count(self.storage.get_Some_0())\n    }\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: T| self.reader.count(t) > 0 ==>\n            equal(self.storage, Option::Some(t))\n    }\n\n    #[invariant]\n    pub fn writer_agrees_storage(&self) -> bool {\n        self.writer.is_Some() ==> self.storage.is_None()\n    }\n\n    #[invariant]\n    pub fn writer_agrees_storage_rev(&self) -> bool {\n        self.storage.is_None() ==> self.writer.is_Some()\n    }\n\n    #[inductive(acquire_read_start)]\n    fn acquire_read_start_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_read_end)]\n    fn acquire_read_end_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_read_abandon)]\n    fn acquire_read_abandon_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_exc_start)]\n    fn acquire_exc_start_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_exc_end)]\n    fn acquire_exc_end_inductive(pre: Self, post: Self) { }\n\n    #[inductive(release_exc)]\n    fn release_exc_inductive(pre: Self, post: Self, x: T) { }\n\n    #[inductive(release_shared)]\n    fn release_shared_inductive(pre: Self, post: Self, x: T) {\n        assert(equal(pre.storage, Option::Some(x)));\n    }\n});\n\nfn main() {}\n", "use vstd;\nfn main() {}\n", "  use vstd::prelude::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\npub struct T ;\n        tokenized_state_machine!(RwLock {\n           fields {\n#[sharding(variable)]\n        pub flags: (bool, nat),                \n#[sharding(storage_option)]\n        pub storage: Option<T>,                \n#[sharding(option)]\n        pub pending_writer: Option<()>,                \n#[sharding(option)]\n        pub writer: Option<()>,                \n#[sharding(multiset)]\n        pub pending_reader: Multiset<()>,                \n#[sharding(multiset)]\n        pub reader: Multiset<T>,     }\n           transition!{\n              acquire_read_start() {}\n          }\n           transition!{\n              acquire_read_end() {}\n          }\n           transition!{\n              acquire_read_abandon() {}\n          }\n           transition!{\n              acquire_exc_start() {}\n          }\n           transition!{\n              acquire_exc_end() {}\n          }\n           transition!{\n              release_exc(x: T) {}\n          }\n                transition!{\n              release_shared(x: T) {}\n          }\n#[invariant]\n    pub fn exc_bit_matches(&self) -> bool {\n              (if self.flags.0 {\n     1 }\n      else {\n     0 as int }\n     ) ==             (if self.pending_writer.is_Some() {\n     1 }\n      else {\n     0 as int }\n     ) as int             + (if self.writer.is_Some() {\n     1 }\n      else {\n     0 as int }\n     ) as int     }\n#[invariant]\n    pub fn count_matches(&self) -> bool {\n              self.flags.1 == self.pending_reader.count(())             + self.reader.count(self.storage.get_Some_0())     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n              forall |t: T| self.reader.count(t) > 0 ==>             equal(self.storage, Option::Some(t))     }\n#[invariant]\n    pub fn writer_agrees_storage(&self) -> bool {\n              self.writer.is_Some() ==> self.storage.is_None()     }\n#[invariant]\n    pub fn writer_agrees_storage_rev(&self) -> bool {\n              self.storage.is_None() ==> self.writer.is_Some()     }\n#[inductive(acquire_read_start)]\n    fn acquire_read_start_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_read_end)]\n    fn acquire_read_end_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_read_abandon)]\n    fn acquire_read_abandon_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_exc_start)]\n    fn acquire_exc_start_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_exc_end)]\n    fn acquire_exc_end_inductive(pre: Self, post: Self) {}\n#[inductive(release_exc)]\n    fn release_exc_inductive(pre: Self, post: Self, x: T) {}\n#[inductive(release_shared)]\n    fn release_shared_inductive(pre: Self, post: Self, x: T) {}\n       }\n       );\n        fn main() {}\n", "  use vstd::prelude::*;\n         use verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\npub struct T ;\n         tokenized_state_machine!(RwLock {            fields { \n#[sharding(multiset)]\n        pub reader: Multiset<T>,     }            transition!{               acquire_read_start() {}           }            transition!{               acquire_read_end() {}           }            transition!{               acquire_read_abandon() {}           }            transition!{               acquire_exc_start() {}           }            transition!{               acquire_exc_end() {}           }            transition!{               release_exc(x: T) {}           }                 transition!{               release_shared(x: T) {}           } \n    fn release_shared_inductive(pre: Self, post: Self, x: T) {}        }\n        );\n         fn main() {}\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\nstruct T;\ntokenized_state_machine !(RwLock{fields{\n#[sharding(multiset)]\n  pub reader : Multiset< T >}});\nfn main() {}\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\nstruct T;\ntokenized_state_machine !(RwLock{fields{\n}});\nfn main() {}\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n#[verifier::a]\n \ntokenized_state_machine !(b{fields{}});\nfn main() {}\n", "use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(b{fields{}});\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "counting_to_2_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        // ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n        // ANCHOR_END: inv\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        // ANCHOR: inv_proof\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n        // ANCHOR_END: inv_proof\n    }\n);\n\n// ANCHOR: global_struct\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the invariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: global_struct\n\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_a_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_b_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n    assert(x == 2);\n}\n\n} // verus!\n// ANCHOR_END: full\n", "minimized_code": " use verus_state_machines_macros::tokenized_state_machine;\n        use std::sync::Arc;\n        use vstd::atomic_ghost::*;\n        use vstd::prelude::*;\n        use vstd::thread::*;\n        verus! {\n       tokenized_state_machine!(     X {\n              fields {\n#[sharding(variable)]\n            pub counter: int,                    \n#[sharding(variable)]\n            pub inc_a: bool,                    \n#[sharding(variable)]\n            pub inc_b: bool,         }\n#[invariant]\n        pub fn main_inv(&self) -> bool {\n                 self.counter == (if self.inc_a {\n    1 as int }\n     else {\n    0 }\n    ) + (if self.inc_b {\n    1 as int }\n     else {\n    0 }\n    )         }\n              init!{\n                 initialize() {\n                    init counter = 0;\n                    init inc_a = false;\n                    init inc_b = false;\n                }\n             }\n              transition!{\n                 tr_inc_a() {}\n             }\n              transition!{\n                 tr_inc_b() {}\n             }\n              property!{\n                 increment_will_not_overflow_u32() {}\n             }\n              property!{\n                 finalize() {}\n             }\n#[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {}\n#[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {}\n#[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n             }\n          }\n       );\n       struct_with_invariants!{\n          pub struct Global {\n             pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }\n          spec fn wf(&self) -> bool {\n             invariant on atomic with (instance) is (v: u32, g: X::counter) {\n                g.instance_id() == instance@.id()             && g.value() == v as int         }\n         }\n      }\n       fn main() ;\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/counting_to_2.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 990, "minimize_time_ms": 675662, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 209, "minimized_LOC": 63, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "verus_state_machines_macros::tokenized_state_machine", "std::sync::Arc", "vstd::atomic_ghost::", "vstd::modes::", "vstd::prelude::", "vstd::thread::", "vstd::"], "complexity_verus_tokens": 6, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.3014354066985646}, "labeling": {"segments": {"exec": " pub fn main_inv(&self) -> bool {\n\n fn tr_inc_a_preserves(pre: Self, post: Self) {\n\n fn tr_inc_b_preserves(pre: Self, post: Self) {\n\n fn initialize_inv(post: Self) {", "spec": "spec fn wf(&self) -> bool {\n\n#[invariant]\n\n             invariant on atomic with (instance) is (v: u32, g: X::counter) {"}}}, "all_snapshots": ["#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        // ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n        // ANCHOR_END: inv\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        // ANCHOR: inv_proof\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n        // ANCHOR_END: inv_proof\n    }\n);\n\n// ANCHOR: global_struct\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the invariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: global_struct\n\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_a_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_b_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n    assert(x == 2);\n}\n\n} // verus!\n// ANCHOR_END: full\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", " use verus_state_machines_macros::tokenized_state_machine;\n        use std::sync::Arc;\n        use vstd::atomic_ghost::*;\n        use vstd::prelude::*;\n        use vstd::thread::*;\n        verus! {\n       tokenized_state_machine!(     X {\n              fields {\n#[sharding(variable)]\n            pub counter: int,                    \n#[sharding(variable)]\n            pub inc_a: bool,                    \n#[sharding(variable)]\n            pub inc_b: bool,         }\n#[invariant]\n        pub fn main_inv(&self) -> bool {\n                 self.counter == (if self.inc_a {\n    1 as int }\n     else {\n    0 }\n    ) + (if self.inc_b {\n    1 as int }\n     else {\n    0 }\n    )         }\n              init!{\n                 initialize() {\n                    init counter = 0;\n                    init inc_a = false;\n                    init inc_b = false;\n                }\n             }\n              transition!{\n                 tr_inc_a() {}\n             }\n              transition!{\n                 tr_inc_b() {}\n             }\n              property!{\n                 increment_will_not_overflow_u32() {}\n             }\n              property!{\n                 finalize() {}\n             }\n#[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {}\n#[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {}\n#[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n             }\n          }\n       );\n       struct_with_invariants!{\n          pub struct Global {\n             pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }\n          spec fn wf(&self) -> bool {\n             invariant on atomic with (instance) is (v: u32, g: X::counter) {\n                g.instance_id() == instance@.id()             && g.value() == v as int         }\n         }\n      }\n       fn main() ;\n       }\n", " use verus_state_machines_macros::tokenized_state_machine;\n          use vstd::prelude::*;\n          verus! {\n        tokenized_state_machine!(     X {               fields {  \n#[sharding(variable)]\n            pub counter: int,                      \n#[sharding(variable)]\n            pub inc_a: bool,                      \n#[sharding(variable)]\n            pub inc_b: bool,         }  \n#[invariant]\n        pub fn main_inv(&self) -> bool {                  self.counter == (if self.inc_a {     1 as int }      else {     0 }     ) + (if self.inc_b {     1 as int }      else {     0 }     )         }               init!{                  initialize() {                     init counter = 0;                     init inc_a = false;                     init inc_b = false;                 }              }               transition!{                  tr_inc_a() {}              }               transition!{                  tr_inc_b() {}              }               property!{                  increment_will_not_overflow_u32() {}              }               property!{                  finalize() {}              }  \n#[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {}  \n#[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {}  \n#[inductive(initialize)]\n        fn initialize_inv(post: Self) {}           }\n        );\n        fn main() ;\n        }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(     X {\n                    fields {\n#[sharding(variable)]\n            pub counter: int,\n#[sharding(variable)]\n            pub inc_a: bool,\n#[sharding(variable)]\n            pub inc_b: bool,         }\n                    init!{\n                      initialize() {\n                        init counter = 0;\n                        init inc_a = false;\n                        init inc_b = false;\n}\n}\nfn initialize_inv(post : Self) {}\n}\n              );\n              fn main();\n              }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(     a {\n                    fields {\n#[sharding(variable)]\n            pub b: int,\n#[sharding(variable)]\n            pub c: bool,\n#[sharding(variable)]\n            pub d: bool}\n                    init!{\n                      initialize() {\n                        init b = 0;\n                        init c = false;\n                        init d = false;\n}\n}\n}\n              );\n              fn main();\n              }\n", "use verus_state_machines_macros::tokenized_state_machine;\n     use vstd::prelude::*;\n     verus !{\n                  tokenized_state_machine!(     a {\n                       fields {\n#[sharding(variable)]\n            pub b: int,     \n#[sharding(variable)]\n            pub c: bool,     \n#[sharding(variable)]\n            pub d: bool}\n   }\n                  );\n                  fn main();\n                  }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a{fields{\n#[sharding(variable)]\n    pub b : int,\n#[sharding(variable)]\n    pub c : bool,\n#[sharding(variable)]\n    pub d : bool\n  }});\n  fn main();\n}\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a{fields{\n}});\n  fn main();\n}\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a{fields{}});\n  fn main();\n}\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  fn main();\n}\n", "use verus_state_machines_macros;\n use vstd::prelude::*;\n verus !{   fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "counting_to_n_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!{\n    X {\n        fields {\n            #[sharding(constant)]\n            pub num_threads: nat,\n\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(count)]\n            pub unstamped_tickets: nat,\n\n            #[sharding(count)]\n            pub stamped_tickets: nat,\n        }\n// ANCHOR_END: fields\n\n// ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == self.stamped_tickets\n            && self.stamped_tickets + self.unstamped_tickets == self.num_threads\n        }\n// ANCHOR_END: inv\n\n// ANCHOR: init\n        init!{\n            initialize(num_threads: nat) {\n                init num_threads = num_threads;\n                init counter = 0;\n                init unstamped_tickets = num_threads;\n                init stamped_tickets = 0;\n            }\n        }\n// ANCHOR_END: init\n\n// ANCHOR: tr_inc\n        transition!{\n            tr_inc() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= 1);\n                //    update unstampted_tickets = pre.unstamped_tickets - 1\n                // (In any `remove` statement, the `>=` condition is always implicit.)\n                remove unstamped_tickets -= (1);\n\n                // Equivalent to:\n                //    update stamped_tickets = pre.stamped_tickets + 1\n                add stamped_tickets += (1);\n\n                // These still use ordinary 'update' syntax, because `pre.counter`\n                // uses the `variable` sharding strategy.\n                assert(pre.counter < pre.num_threads);\n                update counter = pre.counter + 1;\n            }\n        }\n// ANCHOR_END: tr_inc\n\n// ANCHOR: finalize\n        property!{\n            finalize() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= pre.num_threads);\n                have stamped_tickets >= (pre.num_threads);\n\n                assert(pre.counter == pre.num_threads);\n            }\n        }\n// ANCHOR_END: finalize\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) { }\n\n        #[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct Global {\n        pub atomic: AtomicU32<_, X::counter, _>,\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n\n        predicate {\n            self.instance@.num_threads() < 0x100000000\n        }\n    }\n}\n\nfn do_count(num_threads: u32) {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(unstamped_tokens),\n        Tracked(stamped_tokens),\n    ) = X::Instance::initialize(num_threads as nat);\n    // Initialize the counter\n    let tracked_instance = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: tracked_instance };\n    let global_arc = Arc::new(global);\n\n    // ANCHOR: loop_spawn\n    // Spawn threads\n    let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();\n    let mut i = 0;\n    while i < num_threads\n        invariant\n            0 <= i,\n            i <= num_threads,\n            unstamped_tokens.count() + i == num_threads,\n            unstamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() == i as int,\n            forall|j: int, ret|\n                0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>\n                    ret@.instance_id() == instance.id()\n                    && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance,\n    {\n        let tracked unstamped_token;\n        proof {\n            unstamped_token = unstamped_tokens.split(1 as nat);\n        }\n        let global_arc = global_arc.clone();\n        let join_handle = spawn(\n            (move || -> (new_token: Tracked<X::stamped_tickets>)\n                ensures\n                    new_token@.instance_id() == instance.id(),\n                    new_token@.count() == 1,\n                {\n                    let tracked unstamped_token = unstamped_token;\n                    let globals = &*global_arc;\n                    let tracked stamped_token;\n                    let _ =\n                        atomic_with_ghost!(\n                            &global_arc.atomic => fetch_add(1);\n                            update prev -> next;\n                            returning ret;\n                            ghost c => {\n                                stamped_token =\n                                    global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);\n                            }\n                        );\n                    Tracked(stamped_token)\n                }),\n        );\n        join_handles.push(join_handle);\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_spawn\n    // ANCHOR: loop_join\n    // Join threads\n\n    let mut i = 0;\n    while i < num_threads\n        invariant\n            0 <= i,\n            i <= num_threads,\n            stamped_tokens.count() == i,\n            stamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() as int + i as int == num_threads,\n            forall|j: int, ret|\n                0 <= j && j < join_handles@.len() ==>\n                    #[trigger] join_handles@.index(j).predicate(ret) ==>\n                        ret@.instance_id() == instance.id()\n                        && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance,\n    {\n        let join_handle = join_handles.pop().unwrap();\n        match join_handle.join() {\n            Result::Ok(token) => {\n                proof {\n                    stamped_tokens.join(token.get());\n                }\n            },\n            _ => {\n                return ;\n            },\n        };\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_join\n\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &stamped_tokens);\n        }\n    );\n    assert(x == num_threads);\n}\n\nfn main() {\n    do_count(20);\n}\n\n} // verus!\n// ANCHOR_END: full\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_state_machines_macros::tokenized_state_machine;\n     use std::sync::Arc;\n     use vstd::atomic_ghost::*;\n     use vstd::prelude::*;\n     use vstd::thread::*;\n     verus! {\n    tokenized_state_machine!{\n       X {\n          fields {\n#[sharding(constant)]\n            pub num_threads: nat,                 \n#[sharding(variable)]\n            pub counter: int,                 \n#[sharding(count)]\n            pub unstamped_tickets: nat,                 \n#[sharding(count)]\n            pub stamped_tickets: nat,         }\n#[invariant]\n        pub fn main_inv(&self) -> bool {\n             self.counter == self.stamped_tickets             && self.stamped_tickets + self.unstamped_tickets == self.num_threads         }\n          init!{\n             initialize(num_threads: nat) {                 init num_threads = num_threads;                 init counter = 0;                 init unstamped_tickets = num_threads;                 init stamped_tickets = 0;             }\n         }\n          transition!{\n             tr_inc() {                 remove unstamped_tickets -= (1);                 add stamped_tickets += (1);                 assert(pre.counter < pre.num_threads);                 update counter = pre.counter + 1;             }\n         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) {\n }\n#[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n         }\n      }\n   }\n    struct_with_invariants!{\n       pub struct Global {\n          pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }\n       spec fn wf(&self) -> bool {\n          invariant on atomic with (instance) is (v: u32, g: X::counter) {\n             g.instance_id() == instance@.id()             && g.value() == v as int         }\n          predicate {\n             self.instance@.num_threads() < 0x100000000         }\n      }\n   }\n    fn do_count(num_threads: u32) {\n       let tracked (         Tracked(instance),         Tracked(counter_token),         Tracked(unstamped_tokens),         Tracked(stamped_tokens),     ) = X::Instance::initialize(num_threads as nat);\n       let tracked_instance = Tracked(instance.clone());\n       let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));\n       let global = Global {\n  atomic, instance: tracked_instance };\n       let global_arc = Arc::new(global);\n       let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();\n       let mut i = 0;\n       while i < num_threads         invariant             0 <= i,             i <= num_threads,             unstamped_tokens.count() + i == num_threads,             unstamped_tokens.instance_id() == instance.id(),             join_handles@.len() == i as int,             forall|j: int, ret|                 0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>                     ret@.instance_id() == instance.id()                     && ret@.count() == 1,             (*global_arc).wf(),             (*global_arc).instance@ === instance,     {\n          let tracked unstamped_token;\n          proof {\n             unstamped_token = unstamped_tokens.split(1 as nat);\n         }\n          let global_arc = global_arc.clone();\n          let join_handle = spawn(             (move || -> (new_token: Tracked<X::stamped_tickets>)                 ensures                     new_token@.instance_id() == instance.id(),                     new_token@.count() == 1,                 {\n                     let tracked stamped_token;\n                     let _ =                         atomic_with_ghost!(                             &global_arc.atomic => fetch_add(1);\n                             ghost c => {                                 stamped_token =                                     global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);                             }\n                         );\n                     Tracked(stamped_token)                 }\n ),         );\n          join_handles.push(join_handle);\n          i = i + 1;\n      }\n       let global = &*global_arc;\n       let x =         atomic_with_ghost!(&global.atomic => load();\n           ghost c => {\n          }\n       );\n   }\n    fn main() {\n   }\n    }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/counting_to_n.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1002, "minimize_time_ms": 370960, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 224, "minimized_LOC": 79, "self_contained": false, "dependencies": ["verus_state_machines_macros::tokenized_state_machine", "std::sync::Arc", "vstd::atomic_ghost::", "vstd::modes::", "vstd::prelude::", "vstd::thread::", "vstd::"], "complexity_verus_tokens": 16, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 0.35267857142857145}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn main_inv(&self) -> bool {\n\n fn initialize_inductive(post: Self, num_threads: nat) {\n\n fn tr_inc_preserves(pre: Self, post: Self) {\n\n fn do_count(num_threads: u32) {\n\n fn main() {", "spec": "spec fn wf(&self) -> bool {\n\n#[invariant]\n\n          invariant on atomic with (instance) is (v: u32, g: X::counter) {\n\n       while i < num_threads         invariant             0 <= i,             i <= num_threads,             unstamped_tokens.count() + i == num_threads,             unstamped_tokens.instance_id() == instance.id(),             join_handles@.len() == i as int,             forall|j: int, ret|                 0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>                     ret@.instance_id() == instance.id()                     && ret@.count() == 1,             (*global_arc).wf(),             (*global_arc).instance@ === instance,     {\n\n          let join_handle = spawn(             (move || -> (new_token: Tracked<X::stamped_tickets>)                 ensures                     new_token@.instance_id() == instance.id(),                     new_token@.count() == 1,                 {", "proof": "proof {\n             unstamped_token = unstamped_tokens.split(1 as nat);\n         }"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!{\n    X {\n        fields {\n            #[sharding(constant)]\n            pub num_threads: nat,\n\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(count)]\n            pub unstamped_tickets: nat,\n\n            #[sharding(count)]\n            pub stamped_tickets: nat,\n        }\n// ANCHOR_END: fields\n\n// ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == self.stamped_tickets\n            && self.stamped_tickets + self.unstamped_tickets == self.num_threads\n        }\n// ANCHOR_END: inv\n\n// ANCHOR: init\n        init!{\n            initialize(num_threads: nat) {\n                init num_threads = num_threads;\n                init counter = 0;\n                init unstamped_tickets = num_threads;\n                init stamped_tickets = 0;\n            }\n        }\n// ANCHOR_END: init\n\n// ANCHOR: tr_inc\n        transition!{\n            tr_inc() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= 1);\n                //    update unstampted_tickets = pre.unstamped_tickets - 1\n                // (In any `remove` statement, the `>=` condition is always implicit.)\n                remove unstamped_tickets -= (1);\n\n                // Equivalent to:\n                //    update stamped_tickets = pre.stamped_tickets + 1\n                add stamped_tickets += (1);\n\n                // These still use ordinary 'update' syntax, because `pre.counter`\n                // uses the `variable` sharding strategy.\n                assert(pre.counter < pre.num_threads);\n                update counter = pre.counter + 1;\n            }\n        }\n// ANCHOR_END: tr_inc\n\n// ANCHOR: finalize\n        property!{\n            finalize() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= pre.num_threads);\n                have stamped_tickets >= (pre.num_threads);\n\n                assert(pre.counter == pre.num_threads);\n            }\n        }\n// ANCHOR_END: finalize\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) { }\n\n        #[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct Global {\n        pub atomic: AtomicU32<_, X::counter, _>,\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n\n        predicate {\n            self.instance@.num_threads() < 0x100000000\n        }\n    }\n}\n\nfn do_count(num_threads: u32) {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(unstamped_tokens),\n        Tracked(stamped_tokens),\n    ) = X::Instance::initialize(num_threads as nat);\n    // Initialize the counter\n    let tracked_instance = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: tracked_instance };\n    let global_arc = Arc::new(global);\n\n    // ANCHOR: loop_spawn\n    // Spawn threads\n    let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();\n    let mut i = 0;\n    while i < num_threads\n        invariant\n            0 <= i,\n            i <= num_threads,\n            unstamped_tokens.count() + i == num_threads,\n            unstamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() == i as int,\n            forall|j: int, ret|\n                0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>\n                    ret@.instance_id() == instance.id()\n                    && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance,\n    {\n        let tracked unstamped_token;\n        proof {\n            unstamped_token = unstamped_tokens.split(1 as nat);\n        }\n        let global_arc = global_arc.clone();\n        let join_handle = spawn(\n            (move || -> (new_token: Tracked<X::stamped_tickets>)\n                ensures\n                    new_token@.instance_id() == instance.id(),\n                    new_token@.count() == 1,\n                {\n                    let tracked unstamped_token = unstamped_token;\n                    let globals = &*global_arc;\n                    let tracked stamped_token;\n                    let _ =\n                        atomic_with_ghost!(\n                            &global_arc.atomic => fetch_add(1);\n                            update prev -> next;\n                            returning ret;\n                            ghost c => {\n                                stamped_token =\n                                    global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);\n                            }\n                        );\n                    Tracked(stamped_token)\n                }),\n        );\n        join_handles.push(join_handle);\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_spawn\n    // ANCHOR: loop_join\n    // Join threads\n\n    let mut i = 0;\n    while i < num_threads\n        invariant\n            0 <= i,\n            i <= num_threads,\n            stamped_tokens.count() == i,\n            stamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() as int + i as int == num_threads,\n            forall|j: int, ret|\n                0 <= j && j < join_handles@.len() ==>\n                    #[trigger] join_handles@.index(j).predicate(ret) ==>\n                        ret@.instance_id() == instance.id()\n                        && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance,\n    {\n        let join_handle = join_handles.pop().unwrap();\n        match join_handle.join() {\n            Result::Ok(token) => {\n                proof {\n                    stamped_tokens.join(token.get());\n                }\n            },\n            _ => {\n                return ;\n            },\n        };\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_join\n\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &stamped_tokens);\n        }\n    );\n    assert(x == num_threads);\n}\n\nfn main() {\n    do_count(20);\n}\n\n} // verus!\n// ANCHOR_END: full\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_state_machines_macros::tokenized_state_machine;\n     use std::sync::Arc;\n     use vstd::atomic_ghost::*;\n     use vstd::prelude::*;\n     use vstd::thread::*;\n     verus! {\n    tokenized_state_machine!{\n       X {\n          fields {\n#[sharding(constant)]\n            pub num_threads: nat,                 \n#[sharding(variable)]\n            pub counter: int,                 \n#[sharding(count)]\n            pub unstamped_tickets: nat,                 \n#[sharding(count)]\n            pub stamped_tickets: nat,         }\n#[invariant]\n        pub fn main_inv(&self) -> bool {\n             self.counter == self.stamped_tickets             && self.stamped_tickets + self.unstamped_tickets == self.num_threads         }\n          init!{\n             initialize(num_threads: nat) {                 init num_threads = num_threads;                 init counter = 0;                 init unstamped_tickets = num_threads;                 init stamped_tickets = 0;             }\n         }\n          transition!{\n             tr_inc() {                 remove unstamped_tickets -= (1);                 add stamped_tickets += (1);                 assert(pre.counter < pre.num_threads);                 update counter = pre.counter + 1;             }\n         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) {\n }\n#[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n         }\n      }\n   }\n    struct_with_invariants!{\n       pub struct Global {\n          pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }\n       spec fn wf(&self) -> bool {\n          invariant on atomic with (instance) is (v: u32, g: X::counter) {\n             g.instance_id() == instance@.id()             && g.value() == v as int         }\n          predicate {\n             self.instance@.num_threads() < 0x100000000         }\n      }\n   }\n    fn do_count(num_threads: u32) {\n       let tracked (         Tracked(instance),         Tracked(counter_token),         Tracked(unstamped_tokens),         Tracked(stamped_tokens),     ) = X::Instance::initialize(num_threads as nat);\n       let tracked_instance = Tracked(instance.clone());\n       let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));\n       let global = Global {\n  atomic, instance: tracked_instance };\n       let global_arc = Arc::new(global);\n       let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();\n       let mut i = 0;\n       while i < num_threads         invariant             0 <= i,             i <= num_threads,             unstamped_tokens.count() + i == num_threads,             unstamped_tokens.instance_id() == instance.id(),             join_handles@.len() == i as int,             forall|j: int, ret|                 0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>                     ret@.instance_id() == instance.id()                     && ret@.count() == 1,             (*global_arc).wf(),             (*global_arc).instance@ === instance,     {\n          let tracked unstamped_token;\n          proof {\n             unstamped_token = unstamped_tokens.split(1 as nat);\n         }\n          let global_arc = global_arc.clone();\n          let join_handle = spawn(             (move || -> (new_token: Tracked<X::stamped_tickets>)                 ensures                     new_token@.instance_id() == instance.id(),                     new_token@.count() == 1,                 {\n                     let tracked stamped_token;\n                     let _ =                         atomic_with_ghost!(                             &global_arc.atomic => fetch_add(1);\n                             ghost c => {                                 stamped_token =                                     global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);                             }\n                         );\n                     Tracked(stamped_token)                 }\n ),         );\n          join_handles.push(join_handle);\n          i = i + 1;\n      }\n       let global = &*global_arc;\n       let x =         atomic_with_ghost!(&global.atomic => load();\n           ghost c => {\n          }\n       );\n   }\n    fn main() {\n   }\n    }\n", "#!\nuse verus_state_machines_macros::tokenized_state_machine;\n        use std::sync::Arc;\n        use vstd::atomic_ghost::*;\n        use vstd::prelude::*;\n        use vstd::thread::*;\n        verus! {\n       tokenized_state_machine!{\n          X {\n             fields {\n#[sharding(constant)]\n            pub num_threads: nat,                    \n#[sharding(variable)]\n            pub counter: int,                    \n#[sharding(count)]\n            pub unstamped_tickets: nat,                    \n#[sharding(count)]\n            pub stamped_tickets: nat,         }\n#[invariant]\n        pub fn main_inv(&self) -> bool {\n                self.counter == self.stamped_tickets             && self.stamped_tickets + self.unstamped_tickets == self.num_threads         }\n             init!{\n                initialize(num_threads: nat) {\n                   init num_threads = num_threads;\n                   init counter = 0;\n                   init unstamped_tickets = num_threads;\n                   init stamped_tickets = 0;\n               }\n            }\n             transition!{\n                tr_inc() {}\n            }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) {}\n#[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {}\n         }\n      }\n       struct_with_invariants!{\n          pub struct Global {\n             pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }\n          spec fn wf(&self) -> bool {\n             invariant on atomic with (instance) is (v: u32, g: X::counter) {\n                g.instance_id() == instance@.id()             && g.value() == v as int         }\n             predicate {\n                self.instance@.num_threads() < 0x100000000         }\n         }\n      }\n       fn do_count() ;\n       fn main() ;\n       }\n", "use verus_state_machines_macros::tokenized_state_machine;\n             use vstd::prelude::*;\n             verus! {\n           tokenized_state_machine!{\n             X {\n               fields {\n#[sharding(constant)]\n            pub stamped_tickets: nat,         }\n           }\n         }\n           fn main() ;\n           }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !{\n    X {\n      fields {\n#[sharding(constant)]\n        pub stamped_tickets : nat}\n    }\n  }\n  fn main();\n}\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !{\n    X {\n      fields {\n}\n    }\n  }\n  fn main();\n}\n", "  use vstd::prelude::*;\n    verus !{\n     fn main();\n   }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "counting_to_n_atomic_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::state_machine;\nuse vstd::{pervasive::*, *};\n\n// ANCHOR: main\nstate_machine! {\n    X {\n        fields {\n            pub num_threads: nat,\n            pub counter: int,\n            pub unstamped_tickets: nat,\n            pub stamped_tickets: nat,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == self.stamped_tickets\n            && self.stamped_tickets + self.unstamped_tickets == self.num_threads\n        }\n\n        init!{\n            initialize(num_threads: nat) {\n                init num_threads = num_threads;\n                init counter = 0;\n                init unstamped_tickets = num_threads;\n                init stamped_tickets = 0;\n            }\n        }\n\n        transition!{\n            tr_inc() {\n                // Replace a single unstamped ticket with a stamped ticket\n                require(pre.unstamped_tickets >= 1);\n                update unstamped_tickets = (pre.unstamped_tickets - 1) as nat;\n                update stamped_tickets = pre.stamped_tickets + 1;\n\n                assert(pre.counter < pre.num_threads);\n                update counter = pre.counter + 1;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.stamped_tickets >= pre.num_threads);\n                assert(pre.counter == pre.num_threads);\n            }\n        }\n// ANCHOR_END: main\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) { }\n\n        #[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n        }\n    }\n}\n\nfn main() {}\n", "minimized_code": "use verus_builtin::*;\nuse verus_state_machines_macros::state_machine;\nstate_machine !{\n  X {\n    fields {\n      pub num_threads : nat,\n                        pub counter : int,\n                                      pub unstamped_tickets\n          : nat,\n            pub stamped_tickets : nat,\n    }\n  }\n}\nfn main() {}\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/counting_to_n_atomic.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1002, "minimize_time_ms": 215145, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 14, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "verus_state_machines_macros::state_machine", "vstd::"], "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.22580645161290322}, "labeling": {"segments": {"exec": "\nfn main() {"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::state_machine;\nuse vstd::{pervasive::*, *};\n\n// ANCHOR: main\nstate_machine! {\n    X {\n        fields {\n            pub num_threads: nat,\n            pub counter: int,\n            pub unstamped_tickets: nat,\n            pub stamped_tickets: nat,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == self.stamped_tickets\n            && self.stamped_tickets + self.unstamped_tickets == self.num_threads\n        }\n\n        init!{\n            initialize(num_threads: nat) {\n                init num_threads = num_threads;\n                init counter = 0;\n                init unstamped_tickets = num_threads;\n                init stamped_tickets = 0;\n            }\n        }\n\n        transition!{\n            tr_inc() {\n                // Replace a single unstamped ticket with a stamped ticket\n                require(pre.unstamped_tickets >= 1);\n                update unstamped_tickets = (pre.unstamped_tickets - 1) as nat;\n                update stamped_tickets = pre.stamped_tickets + 1;\n\n                assert(pre.counter < pre.num_threads);\n                update counter = pre.counter + 1;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.stamped_tickets >= pre.num_threads);\n                assert(pre.counter == pre.num_threads);\n            }\n        }\n// ANCHOR_END: main\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) { }\n\n        #[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n        }\n    }\n}\n\nfn main() {}\n", "use verus_state_machines_macros::state_machine;\nstate_machine !{\n  a {\n    fields {}\n  }\n}\nfn main() {}\n", "use verus_builtin::*;\nuse verus_state_machines_macros::state_machine;\nstate_machine !{\n  X {\n    fields {\n      pub num_threads : nat,\n                        pub counter : int,\n                                      pub unstamped_tickets\n          : nat,\n            pub stamped_tickets : nat,\n    }\n  }\n}\nfn main() {}\n", "use verus_state_machines_macros::state_machine;\nstate_machine !{\n  X {\n    fields {\n      }\n  }\n}\nfn main() {}\n"]}
{"id": "pcell_example_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::{cell::*, pervasive::*};\n\nverus! {\n\n// ANCHOR: example\nfn main() {\n    // Construct a new pcell and obtain the permission for it.\n    let (pcell, Tracked(mut perm)) = PCell::<u64>::empty();\n\n    // Initially, cell is unitialized, and the `perm` token\n    // represents that as the value `MemContents::Uninit`.\n    // The meaning of the permission token is given by its _view_, here `perm@`.\n    //\n    // The expression `pcell_opt![ pcell.id() => MemContents::Uninit ]` can be read as roughly,\n    // \"the cell with value pcell.id() is uninitialized\".\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);\n\n    // The above could also be written by accessing the fields of the\n    // `PointsToData` struct:\n    assert(perm.id() === pcell.id());\n    assert(perm.mem_contents() === MemContents::Uninit);\n\n    // We can write a value to the pcell (thus initializing it).\n    // This only requires an `&` reference to the PCell, but it does\n    // mutate the `perm` token.\n    pcell.put(Tracked(&mut perm), 5);\n\n    // Having written the value, this is reflected in the token:\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Init(5) ]);\n\n    // We can take the value back out:\n    let x = pcell.take(Tracked(&mut perm));\n\n    // Which leaves it uninitialized again:\n    assert(x == 5);\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);\n}\n// ANCHOR_END: example\n\n} // verus!\n/*\n// After erasure, this looks more like:\n\n// ANCHOR: erased\nfn main() {\n  let pcell = PCell::<u64>::empty();\n  pcell.put(5);\n  let x = pcell.take();\n}\n// ANCHOR_END: erased\n*/\n", "minimized_code": "// rust_verify/tests/example.rs\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::{cell::*, pervasive::*};\n\nverus! {\n\n// ANCHOR: example\nfn main() {\n    // Construct a new pcell and obtain the permission for it.\n    let (pcell, Tracked(mut perm)) = PCell::<u64>::empty();\n\n    // Initially, cell is unitialized, and the `perm` token\n    // represents that as the value `MemContents::Uninit`.\n    // The meaning of the permission token is given by its _view_, here `perm@`.\n    //\n    // The expression `pcell_opt![ pcell.id() => MemContents::Uninit ]` can be read as roughly,\n    // \"the cell with value pcell.id() is uninitialized\".\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);\n\n    // The above could also be written by accessing the fields of the\n    // `PointsToData` struct:\n    assert(perm.id() === pcell.id());\n    assert(perm.mem_contents() === MemContents::Uninit);\n\n    // We can write a value to the pcell (thus initializing it).\n    // This only requires an `&` reference to the PCell, but it does\n    // mutate the `perm` token.\n    pcell.put(Tracked(&mut perm), 5);\n\n    // Having written the value, this is reflected in the token:\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Init(5) ]);\n\n    // We can take the value back out:\n    let x = pcell.take(Tracked(&mut perm));\n\n    // Which leaves it uninitialized again:\n    assert(x == 5);\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);\n}\n// ANCHOR_END: example\n\n} // verus!\n/*\n// After erasure, this looks more like:\n\n// ANCHOR: erased\nfn main() {\n  let pcell = PCell::<u64>::empty();\n  pcell.put(5);\n  let x = pcell.take();\n}\n// ANCHOR_END: erased\n*/\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/pcell_example.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 642, "minimize_time_ms": 122557, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::modes::", "vstd::prelude::", "vstd::"], "complexity_verus_tokens": 3, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {\n\n\nfn main() {", "spec": "    // This only requires an `&` reference to the PCell, but it does"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::{cell::*, pervasive::*};\n\nverus! {\n\n// ANCHOR: example\nfn main() {\n    // Construct a new pcell and obtain the permission for it.\n    let (pcell, Tracked(mut perm)) = PCell::<u64>::empty();\n\n    // Initially, cell is unitialized, and the `perm` token\n    // represents that as the value `MemContents::Uninit`.\n    // The meaning of the permission token is given by its _view_, here `perm@`.\n    //\n    // The expression `pcell_opt![ pcell.id() => MemContents::Uninit ]` can be read as roughly,\n    // \"the cell with value pcell.id() is uninitialized\".\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);\n\n    // The above could also be written by accessing the fields of the\n    // `PointsToData` struct:\n    assert(perm.id() === pcell.id());\n    assert(perm.mem_contents() === MemContents::Uninit);\n\n    // We can write a value to the pcell (thus initializing it).\n    // This only requires an `&` reference to the PCell, but it does\n    // mutate the `perm` token.\n    pcell.put(Tracked(&mut perm), 5);\n\n    // Having written the value, this is reflected in the token:\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Init(5) ]);\n\n    // We can take the value back out:\n    let x = pcell.take(Tracked(&mut perm));\n\n    // Which leaves it uninitialized again:\n    assert(x == 5);\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);\n}\n// ANCHOR_END: example\n\n} // verus!\n/*\n// After erasure, this looks more like:\n\n// ANCHOR: erased\nfn main() {\n  let pcell = PCell::<u64>::empty();\n  pcell.put(5);\n  let x = pcell.take();\n}\n// ANCHOR_END: erased\n*/\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "rc_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n        assert(pre.counter > 0);\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n            assert(pre.counter == 1);\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerRc<S> {\n    pub rc_cell: PCell<u64>,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: cell::PointsTo<u64>,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n        &&& self.rc_perm@.pcell == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerRc<S> {\n    spec fn wf(self, cell: PCell<u64>) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyRc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerRc<S>>,\n\n        pub rc_cell: Ghost< PCell<u64> >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyRc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n        ensures\n            rc.wf(),\n            rc@ == s,\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(1);\n        let inner_rc = InnerRc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = LocalInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyRc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n        ensures\n            s.wf() && s@ == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n\n            assume(count < 100000000);\n\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n\n                // we still have to write back to the `inner_rc` to restore the invariant\n                // even though inner_rc has been moved onto the stack here.\n                // so this will probably get optimized out\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n\n        if count < 2 {\n            ptr.free(Tracked(inner_rc_perm_opt.tracked_unwrap()));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyRc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyRc::new(Sequence::Nil);\n    let a5 = MyRc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyRc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyRc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n", "minimized_code": " use verus_state_machines_macros::tokenized_state_machine;\n    use vstd::cell::*;\n    use vstd::invariant::*;\n    use vstd::multiset::*;\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::{\n  pervasive::*, *};\n    use vstd::shared::*;\n    verus! {\n   tokenized_state_machine!(RefCounter<Perm> {\n      fields {\n#[sharding(variable)]\n        pub counter: nat,            \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,            \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n         forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n         self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n      init!{\n         initialize_empty() {             init counter = 0;             init storage = Option::None;             init reader = Multiset::empty();         }\n     }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n }\n      property!{\n         reader_guard(x: Perm) {             have reader >= {x};             guard storage >= Some(x);         }\n     }\n      transition!{\n         do_clone(x: Perm) {             have reader >= {x};             add reader += {x};             update counter = pre.counter + 1;         }\n     }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n         assert(pre.storage is Some);\n         assert(pre.counter > 0);\n     }\n      transition!{\n         dec_basic(x: Perm) {             require(pre.counter >= 2);             remove reader -= {x};             update counter = (pre.counter - 1) as nat;         }\n     }\n      transition!{\n         dec_to_zero(x: Perm) {             remove reader -= {x};             require(pre.counter < 2);             assert(pre.counter == 1);             update counter = 0;             withdraw storage -= Some(x);         }\n     }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n     }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n }\n  }\n  );\n   pub struct InnerRc<S> {\n      pub rc_cell: PCell<u64>,     pub s: S, }\n   pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n   pub tracked struct GhostStuff<S> {\n      pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n   impl<S> GhostStuff<S> {\n      pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n         &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n  }\n   struct_with_invariants!{\n      struct MyRc<S> {\n         pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n      spec fn wf(self) -> bool {\n         predicate {             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }\n     }\n  }\n   impl<S> MyRc<S> {\n      fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        if count < 2 {\n        }\n    }\n}\nfn main() {\n}\n} \n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/rc.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1316, "minimize_time_ms": 1653371, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 335, "minimized_LOC": 165, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "verus_state_machines_macros::tokenized_state_machine", "vstd::cell::", "vstd::invariant::", "vstd::modes::", "vstd::multiset::", "vstd::prelude::", "vstd::simple_pptr::", "vstd::", "vstd::shared::"], "complexity_verus_tokens": 19, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 0.4925373134328358}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn reader_agrees_storage(&self) -> bool {\n\n pub fn counter_agrees_reader_count(&self) -> bool {\n\n fn initialize_empty_inductive(post: Self) {\n\n fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n\n fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n\n fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n\n fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n\n fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n\n fn dispose(self)\n        requires\n            self.wf(),\n    {\n\n\nfn main() {", "spec": "spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n\nspec fn wf(self) -> bool {\n\n    use vstd::invariant::*;\n\n#[invariant]\n\n#[invariant]\n\n         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }\n\n        requires\n\n        requires\n\n        requires", "proof": "proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n\nproof { g = GhostStuff { rc_perm, rc_token }; }\n\nproof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n\nproof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n\nproof { g = GhostStuff { rc_perm, rc_token }; }"}}}, "all_snapshots": ["#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n        assert(pre.counter > 0);\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n            assert(pre.counter == 1);\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerRc<S> {\n    pub rc_cell: PCell<u64>,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: cell::PointsTo<u64>,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n        &&& self.rc_perm@.pcell == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerRc<S> {\n    spec fn wf(self, cell: PCell<u64>) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyRc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerRc<S>>,\n\n        pub rc_cell: Ghost< PCell<u64> >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyRc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n        ensures\n            rc.wf(),\n            rc@ == s,\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(1);\n        let inner_rc = InnerRc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = LocalInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyRc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n        ensures\n            s.wf() && s@ == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n\n            assume(count < 100000000);\n\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n\n                // we still have to write back to the `inner_rc` to restore the invariant\n                // even though inner_rc has been moved onto the stack here.\n                // so this will probably get optimized out\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n\n        if count < 2 {\n            ptr.free(Tracked(inner_rc_perm_opt.tracked_unwrap()));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyRc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyRc::new(Sequence::Nil);\n    let a5 = MyRc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyRc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyRc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a<b>{fields{\n#[sharding(storage_option)]\n    pub c : Option<b>\n  }});\n  fn main();\n}\n", " use verus_state_machines_macros::tokenized_state_machine;\n    use vstd::cell::*;\n    use vstd::invariant::*;\n    use vstd::multiset::*;\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::{\n  pervasive::*, *};\n    use vstd::shared::*;\n    verus! {\n   tokenized_state_machine!(RefCounter<Perm> {\n      fields {\n#[sharding(variable)]\n        pub counter: nat,            \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,            \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n         forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n         self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n      init!{\n         initialize_empty() {             init counter = 0;             init storage = Option::None;             init reader = Multiset::empty();         }\n     }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n }\n      property!{\n         reader_guard(x: Perm) {             have reader >= {x};             guard storage >= Some(x);         }\n     }\n      transition!{\n         do_clone(x: Perm) {             have reader >= {x};             add reader += {x};             update counter = pre.counter + 1;         }\n     }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n         assert(pre.storage is Some);\n         assert(pre.counter > 0);\n     }\n      transition!{\n         dec_basic(x: Perm) {             require(pre.counter >= 2);             remove reader -= {x};             update counter = (pre.counter - 1) as nat;         }\n     }\n      transition!{\n         dec_to_zero(x: Perm) {             remove reader -= {x};             require(pre.counter < 2);             assert(pre.counter == 1);             update counter = 0;             withdraw storage -= Some(x);         }\n     }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n     }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n }\n  }\n  );\n   pub struct InnerRc<S> {\n      pub rc_cell: PCell<u64>,     pub s: S, }\n   pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n   pub tracked struct GhostStuff<S> {\n      pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n   impl<S> GhostStuff<S> {\n      pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n         &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n  }\n   struct_with_invariants!{\n      struct MyRc<S> {\n         pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n      spec fn wf(self) -> bool {\n         predicate {             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }\n     }\n  }\n   impl<S> MyRc<S> {\n      fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        if count < 2 {\n        }\n    }\n}\nfn main() {\n}\n} \n", " use verus_state_machines_macros::tokenized_state_machine;\n     use vstd::cell::*;\n     use vstd::invariant::*;\n     use vstd::multiset::*;\n     use vstd::prelude::*;\n     use vstd::simple_pptr::*;\n     use vstd::{\n   pervasive::*, *};\n     use vstd::shared::*;\n     verus! {\n    tokenized_state_machine!(RefCounter<Perm> {\n       fields {\n#[sharding(variable)]\n        pub counter: nat,             \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,             \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n          forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n          self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n       init!{\n          initialize_empty() {\n             init counter = 0;\n             init storage = Option::None;\n             init reader = Multiset::empty();\n         }\n      }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n  }\n       property!{\n          reader_guard(x: Perm) {\n             have reader >= {x};\n             guard storage >= Some(x);\n         }\n      }\n       transition!{\n          do_clone(x: Perm) {\n             have reader >= {x};\n             add reader += {x};\n             update counter = pre.counter + 1;\n         }\n      }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n      }\n       transition!{\n          dec_basic(x: Perm) {\n             require(pre.counter >= 2);\n             remove reader -= {x};\n             update counter = (pre.counter - 1) as nat;\n         }\n      }\n       transition!{\n          dec_to_zero(x: Perm) {\n             remove reader -= {x};\n             require(pre.counter < 2);\n             assert(pre.counter == 1);\n             update counter = 0;\n             withdraw storage -= Some(x);\n         }\n      }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n      }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n  }\n   }\n   );\n    pub struct InnerRc<S> {\n       pub rc_cell: PCell<u64>,     pub s: S, }\n    pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n    pub tracked struct GhostStuff<S> {\n       pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n    impl<S> GhostStuff<S> {\n       pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n          &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n   }\n    struct_with_invariants!{\n       struct MyRc<S> {\n          pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n       spec fn wf(self) -> bool {\n          predicate {\n             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n          invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n             v.wf(inst@, rc_cell@)         }\n      }\n   }\n    impl<S> MyRc<S> {\n       fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        if count < 2 {\n        }\n    }\n}\nfn main() {\n}\n} \n", " use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::cell::*;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n     }\n          property!{\n             reader_guard(x: Perm) {\n                have reader >= {\n  x};\n                guard storage >= Some(x);\n            }\n         }\n          transition!{\n             do_clone(x: Perm) {\n                have reader >= {\n  x};\n                add reader += {\n  x};\n                update counter = pre.counter + 1;\n            }\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         }\n          transition!{\n             dec_basic(x: Perm) {\n                remove reader -= {\n  x};\n                update counter = (pre.counter - 1) as nat;\n            }\n         }\n          transition!{\n             dec_to_zero(x: Perm) {\n                remove reader -= {\n  x};\n                require(pre.counter < 2);\n                assert(pre.counter == 1);\n                update counter = 0;\n                withdraw storage -= Some(x);\n            }\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n     }\n      }\n      );\n       pub struct InnerRc<S> {\n          pub rc_cell: PCell<u64>,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n             &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n      }\n       struct_with_invariants!{\n          struct MyRc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyRc<S> {\n          fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    ;\n}\nfn main() ;\n} \n", " use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::cell::*;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n          property!{\n             reader_guard(x: Perm) {\n                have reader >= {\n  x};\n                guard storage >= Some(x);\n            }\n         }\n          transition!{\n             do_clone(x: Perm) {\n                have reader >= {\n  x};\n                add reader += {\n  x};\n                update counter = pre.counter + 1;\n            }\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n          transition!{\n             dec_basic(x: Perm) {}\n         }\n          transition!{\n             dec_to_zero(x: Perm) {}\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n     }\n      }\n      );\n       pub struct InnerRc<S> {\n          pub rc_cell: PCell<u64>,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n             &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n      }\n       struct_with_invariants!{\n          struct MyRc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyRc<S> {\n          fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    ;\n}\nfn main() ;\n} \n", " use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::cell::*;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n          property!{\n             reader_guard(x: Perm) {\n                have reader >= {\n  x};\n                guard storage >= Some(x);\n            }\n         }\n          transition!{\n             do_clone(x: Perm) {\n                have reader >= {\n  x};\n                add reader += {\n  x};\n                update counter = pre.counter + 1;\n            }\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n          transition!{\n             dec_basic(x: Perm) {}\n         }\n          transition!{\n             dec_to_zero(x: Perm) {}\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}\n      }\n      );\n       pub struct InnerRc<S> {\n          pub rc_cell: PCell<u64>,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n             &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n      }\n       struct_with_invariants!{\n          struct MyRc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyRc<S> {}\nfn main() ;\n} \n", " use verus_state_machines_macros::tokenized_state_machine;\n          use vstd::cell::*;\n          use vstd::invariant::*;\n          use vstd::multiset::*;\n          use vstd::prelude::*;\n          use vstd::simple_pptr::*;\n          use vstd::{\n       pervasive::*, *};\n          use vstd::shared::*;\n          verus! {\n        tokenized_state_machine!(RefCounter<Perm> {           fields {  \n#[sharding(variable)]\n        pub counter: nat,                  \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                  \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }  \n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {              forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }  \n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {              self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }           init!{              initialize_empty() {                 init counter = 0;                 init storage = Option::None;                 init reader = Multiset::empty();             }          }  \n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}           property!{              reader_guard(x: Perm) {                 have reader >= {   x};                 guard storage >= Some(x);             }          }           transition!{              do_clone(x: Perm) {                 have reader >= {   x};                 add reader += {   x};                 update counter = pre.counter + 1;             }          }  \n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}           transition!{              dec_basic(x: Perm) {}          }           transition!{              dec_to_zero(x: Perm) {}          }  \n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}  \n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}       }\n       );\n fn main() ;\n }\n", " use verus_state_machines_macros::tokenized_state_machine;\n           use vstd::multiset::*;\n           use vstd::prelude::*;\n           verus! {\n         tokenized_state_machine!(RefCounter<Perm> {\n           fields {   \n#[sharding(variable)]\n        pub counter: nat,                   \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                   \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n           init!{              initialize_empty() {                 init counter = 0;                 init storage = Option::None;                 init reader = Multiset::empty();             }          }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n           transition!{              do_clone(x: Perm) {                 have reader >= {   x};                 add reader += {   x};                 update counter = pre.counter + 1;             }          }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n           transition!{              dec_basic(x: Perm) {}          }\n           transition!{              dec_to_zero(x: Perm) {}          }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}\n       }\n        );\n  fn main() ;\n  }\n", " use verus_state_machines_macros::tokenized_state_machine;\n            use vstd::multiset::*;\n            use vstd::prelude::*;\n            verus! {\n          tokenized_state_machine!(RefCounter<Perm> {\n            fields {\n#[sharding(variable)]\n        pub counter: nat,                    \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                    \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n            init!{\n              initialize_empty() {                 init counter = 0;                 init storage = Option::None;                 init reader = Multiset::empty();             }\n          }\n            transition!{\n              do_clone(x: Perm) {                 have reader >= {   x};                 add reader += {   x};                 update counter = pre.counter + 1;             }\n          }\n            transition!{\n              dec_basic(x: Perm) {}\n          }\n            transition!{\n              dec_to_zero(x: Perm) {}\n          }\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n}\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n}\n        }\n         );\n   fn main() ;\n   }\n", " use verus_state_machines_macros::tokenized_state_machine;\n               use vstd::multiset::*;\n               use vstd::prelude::*;\n               verus! {\n             tokenized_state_machine!(RefCounter<Perm> {\n               fields {\n#[sharding(variable)]\n        pub counter: nat,                       \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                       \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n               init!{\n                 initialize_empty() {\n                   init counter = 0;\n                   init storage = Option::None;\n                   init reader = Multiset::empty();\n  }\n             }\n           }\n            );\n      fn main() ;\n      }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(RefCounter<Perm> {\n                fields {\n#[sharding(variable)]\n        pub counter: nat,\n#[sharding(storage_option)]\n        pub storage: Option<Perm>,\n#[sharding(multiset)]\n        pub reader: Multiset<Perm>}\n                init!{\n                  initialize_empty() {\n                    init counter = 0;\n                    init storage = Option::None;\n                    init reader = Multiset::empty();\n}\n}\n}\n             );\n             fn main();\n             }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(a<b> {\n                fields {\n#[sharding(variable)]\n        pub c: nat,\n#[sharding(storage_option)]\n        pub d: Option<b>,\n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                init!{\n                  f() {\n                    init c = 0;\n                    init d = None;\n                    init e = Multiset::empty();\n}\n}\n}\n             );\n             fn main();\n             }\n", "use verus_state_machines_macros::tokenized_state_machine;\n   use vstd::prelude::*;\n   verus !{\n                tokenized_state_machine!(a<b> {\n                 fields {   \n#[sharding(variable)]\n        pub c: nat,   \n#[sharding(storage_option)]\n        pub d: Option<b>,   \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n }\n               );\n               fn main();\n               }\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(variable)]\n    pub c : nat,\n#[sharding(storage_option)]\n    pub d : Option< b >,\n#[sharding(multiset)]\n    pub e : Multiset< b >\n  }});\n  fn main();\n}\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(storage_option)]\n    pub d : Option< b >,\n#[sharding(multiset)]\n    pub e : Multiset< b >\n  }});\n  fn main();\n}\n", "use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(storage_option)]\n    pub d : Option< b >,\n}});\n  fn main();\n}\n"]}
{"id": "ref_cell_cc0b9f7d", "original_code": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::multiset::*;\nuse vstd::pervasive::*;\nuse vstd::prelude::*;\nuse vstd::shared::*;\n\nverus! {\n\n//////////////////////////////////////////////////////////////////////////////\npub enum BorrowFlag {\n    MutBorrow,\n    ReadBorrow(nat),  // 0 if there are no borrows\n}\n\ntype Perm<S> = cell::PointsTo<S>;\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<S> {\n    fields {\n        #[sharding(constant)]\n        pub pcell_loc: CellId,\n\n        #[sharding(variable)]\n        pub flag: BorrowFlag,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm<S>>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm<S>>,\n\n        #[sharding(bool)]\n        pub writer: bool,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm<S>| #[trigger] self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn flag_inv(&self) -> bool {\n        match self.flag {\n            BorrowFlag::MutBorrow => {\n                self.writer && self.reader == Multiset::<Perm<S>>::empty()\n                  && self.storage is None\n            }\n            BorrowFlag::ReadBorrow(n) => {\n                !self.writer\n                  && self.storage is Some\n                  && self.reader.count(self.storage->0) == n\n            }\n        }\n    }\n\n    #[invariant]\n    pub fn storage_inv(&self) -> bool {\n        match self.storage {\n            Some(x) => x@.pcell == self.pcell_loc && x.is_init(),\n            None => true,\n        }\n    }\n\n    init!{\n        initialize_empty(loc: CellId) {\n            init pcell_loc = loc;\n            init flag = BorrowFlag::MutBorrow;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n            init writer = true;\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self, loc: CellId) { }\n\n    transition!{\n        do_deposit(x: Perm<S>) {\n            require(x@.pcell == pre.pcell_loc && x.is_init());\n            remove writer -= true;\n            assert(pre.flag == BorrowFlag::MutBorrow);\n            update flag = BorrowFlag::ReadBorrow(0);\n\n            deposit storage += Some(x);\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm<S>) { }\n\n    transition!{\n        do_withdraw() {\n            require(pre.flag == BorrowFlag::ReadBorrow(0));\n            update flag = BorrowFlag::MutBorrow;\n\n            add writer += true;\n\n            withdraw storage -= Some(let x);\n            assert(x@.pcell == pre.pcell_loc && x.is_init());\n        }\n    }\n\n    #[inductive(do_withdraw)]\n    fn do_withdraw_inductive(pre: Self, post: Self) {\n        assert_multisets_equal!(post.reader, Multiset::<Perm<S>>::empty());\n    }\n\n    property!{\n        reader_guard(x: Perm<S>) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        new_reader() {\n            require let BorrowFlag::ReadBorrow(n) = pre.flag;\n            update flag = BorrowFlag::ReadBorrow(n + 1);\n\n            birds_eye let x = pre.storage->0;\n            add reader += { x };\n            assert(x@.pcell == pre.pcell_loc && x.is_init());\n        }\n    }\n\n    #[inductive(new_reader)]\n    fn new_reader_inductive(pre: Self, post: Self) { }\n\n    transition!{\n        drop_reader(x: Perm<S>) {\n            remove reader -= { x };\n            assert let BorrowFlag::ReadBorrow(n) = pre.flag;\n            assert n >= 1;\n            update flag = BorrowFlag::ReadBorrow((n - 1) as nat);\n        }\n    }\n\n    #[inductive(drop_reader)]\n    fn drop_reader_inductive(pre: Self, post: Self, x: Perm<S>) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n    }\n});\n\npub tracked struct GhostStuff<S> {\n    tracked rc_perm: cell::PointsTo<isize>,\n    tracked flag_token: RefCounter::flag<S>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub closed spec fn wf(self, inst: RefCounter::Instance<S>, rc_cell: PCell<isize>) -> bool {\n        &&& self.rc_perm@.pcell == rc_cell.id()\n        &&& self.flag_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as int == match self.flag_token.value() {\n            BorrowFlag::MutBorrow => 1,\n            BorrowFlag::ReadBorrow(n) => -n,\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct RefCell<S> {\n        // 0: no reference taken\n        // 1: mut reference taken\n        // -n: n non-mut references taken\n        rc_cell: PCell<isize>,\n        value_cell: PCell<S>,\n\n        inst: Tracked< RefCounter::Instance<S> >,\n        inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        predicate {\n            &&& self.inst@.pcell_loc() == self.value_cell.id()\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell)\n        }\n    }\n}\n\npub struct Ref<'a, S> {\n    ref_cell: &'a RefCell<S>,\n    reader: Tracked<RefCounter::reader<S>>,\n}\n\nimpl<'a, S> Ref<'a, S> {\n    pub closed spec fn wf(&self) -> bool {\n        self.ref_cell.wf()\n            && self.reader@.instance_id() == self.ref_cell.inst@.id()\n            && self.reader@.element()@.pcell == self.ref_cell.value_cell.id()\n            && self.reader@.element().is_init()\n    }\n\n    pub closed spec fn value(&self) -> S {\n        self.reader@.element().value()\n    }\n}\n\npub struct RefMut<'a, S> {\n    ref_cell: &'a RefCell<S>,\n    writer: Tracked<RefCounter::writer<S>>,\n    perm: Tracked<Perm<S>>,\n}\n\nimpl<'a, S> RefMut<'a, S> {\n    pub closed spec fn wf(&self) -> bool {\n        self.ref_cell.wf()\n          && self.writer@.instance_id() == self.ref_cell.inst@.id()\n          && self.perm@@.pcell == self.ref_cell.value_cell.id()\n          && self.perm@.is_init()\n    }\n\n    pub closed spec fn value(&self) -> S {\n        self.perm@.value()\n    }\n}\n\nimpl<S> RefCell<S> {\n    fn new(s: S) -> (ref_cell: Self)\n        ensures\n            ref_cell.wf(),\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(0);\n        let (value_cell, Tracked(value_perm)) = PCell::new(s);\n        let tracked (Tracked(inst), Tracked(flag), _, Tracked(writer)) = RefCounter::Instance::<\n            S,\n        >::initialize_empty(value_cell.id(), None);\n        proof {\n            inst.do_deposit(value_perm, &mut flag, value_perm, writer.tracked_unwrap());\n        }\n        let tracked_inst = Tracked(inst);\n        let tracked inv = LocalInvariant::new(\n            (tracked_inst, rc_cell),\n            GhostStuff { rc_perm, flag_token: flag },\n            0,\n        );\n        RefCell::<S> { rc_cell, value_cell, inst: tracked_inst, inv: Tracked(Shared::new(inv)) }\n    }\n\n    fn try_borrow<'a>(&'a self) -> (opt_ref: Option<Ref<'a, S>>)\n        requires\n            self.wf(),\n        ensures\n            match opt_ref {\n                Some(read_ref) => read_ref.wf(),\n                None => true,\n            },\n    {\n        let return_value;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));\n\n            if cur_rc <= 0 && cur_rc > isize::MIN {\n                let new_rc = cur_rc - 1;\n                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n                let tracked (_, Tracked(reader_token)) =\n                    self.inst.borrow().new_reader(&mut flag_token);\n                return_value = Some(Ref {\n                    ref_cell: self,\n                    reader: Tracked(reader_token),\n                });\n            } else {\n                return_value = None;\n            }\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n        return_value\n    }\n\n    fn try_borrow_mut<'a>(&'a self) -> (opt_ref_mut: Option<RefMut<'a, S>>)\n        requires\n            self.wf(),\n        ensures\n            match opt_ref_mut {\n                Some(write_ref) => write_ref.wf(),\n                None => true,\n            },\n    {\n        let return_value;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));\n\n            if cur_rc == 0 {\n                let new_rc = 1;\n                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n                let tracked (Tracked(perm), Tracked(writer_token)) =\n                    self.inst.borrow().do_withdraw(&mut flag_token);\n                return_value = Some(RefMut {\n                    ref_cell: self,\n                    writer: Tracked(writer_token),\n                    perm: Tracked(perm),\n                });\n            } else {\n                return_value = None;\n            }\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n        return_value\n    }\n}\n\nimpl<'a, S> Ref<'a, S> {\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self.value(),\n    {\n        self.ref_cell.value_cell.borrow(\n            Tracked(\n                self.ref_cell.inst.borrow().reader_guard(self.reader@.element(), self.reader.borrow()),\n            ),\n        )\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let Ref { ref_cell, reader: Tracked(reader) } = self;\n        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            proof {\n                ref_cell.inst.borrow().drop_reader(reader.element(), &mut flag_token, reader);\n            }\n\n            let cur_rc = *ref_cell.rc_cell.borrow(Tracked(&rc_perm));\n            let new_rc = cur_rc + 1;\n            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n    }\n}\n\nimpl<'a, S> RefMut<'a, S> {\n    fn replace(&mut self, in_s: S) -> (out_s: S)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            out_s == old(self).value(),\n            in_s == self.value(),\n    {\n        self.ref_cell.value_cell.replace(Tracked(self.perm.borrow_mut()), in_s)\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let RefMut { ref_cell, writer: Tracked(writer), perm: Tracked(perm) } = self;\n        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            proof {\n                ref_cell.inst.borrow().do_deposit(perm, &mut flag_token, perm, writer);\n            }\n\n            let new_rc = 0;\n            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n    }\n}\n\nfn main() {\n    let rf = RefCell::new(5);\n    let read_ref1 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let read_ref2 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let x = *read_ref1.borrow();\n    let y = *read_ref2.borrow();\n    print_u64(x);\n    print_u64(y);\n    read_ref1.dispose();\n    read_ref2.dispose();\n    let mut write_ref = match rf.try_borrow_mut() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let t = write_ref.replace(20);\n    print_u64(t);\n    write_ref.dispose();\n    let read_ref3 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let z = *read_ref3.borrow();\n    print_u64(z);\n    read_ref3.dispose();\n}\n\n} // verus!\n", "minimized_code": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::multiset::*;\nuse vstd::pervasive::*;\nuse vstd::prelude::*;\nuse vstd::shared::*;\n\nverus! {\n\n//////////////////////////////////////////////////////////////////////////////\npub enum BorrowFlag {\n    MutBorrow,\n    ReadBorrow(nat),  // 0 if there are no borrows\n}\n\ntype Perm<S> = cell::PointsTo<S>;\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<S> {\n    fields {\n        #[sharding(constant)]\n        pub pcell_loc: CellId,\n\n        #[sharding(variable)]\n        pub flag: BorrowFlag,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm<S>>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm<S>>,\n\n        #[sharding(bool)]\n        pub writer: bool,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm<S>| #[trigger] self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn flag_inv(&self) -> bool {\n        match self.flag {\n            BorrowFlag::MutBorrow => {\n                self.writer && self.reader == Multiset::<Perm<S>>::empty()\n                  && self.storage is None\n            }\n            BorrowFlag::ReadBorrow(n) => {\n                !self.writer\n                  && self.storage is Some\n                  && self.reader.count(self.storage->0) == n\n            }\n        }\n    }\n\n    #[invariant]\n    pub fn storage_inv(&self) -> bool {\n        match self.storage {\n            Some(x) => x@.pcell == self.pcell_loc && x.is_init(),\n            None => true,\n        }\n    }\n\n    init!{\n        initialize_empty(loc: CellId) {\n            init pcell_loc = loc;\n            init flag = BorrowFlag::MutBorrow;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n            init writer = true;\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self, loc: CellId) { }\n\n    transition!{\n        do_deposit(x: Perm<S>) {\n            require(x@.pcell == pre.pcell_loc && x.is_init());\n            remove writer -= true;\n            assert(pre.flag == BorrowFlag::MutBorrow);\n            update flag = BorrowFlag::ReadBorrow(0);\n\n            deposit storage += Some(x);\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm<S>) { }\n\n    transition!{\n        do_withdraw() {\n            require(pre.flag == BorrowFlag::ReadBorrow(0));\n            update flag = BorrowFlag::MutBorrow;\n\n            add writer += true;\n\n            withdraw storage -= Some(let x);\n            assert(x@.pcell == pre.pcell_loc && x.is_init());\n        }\n    }\n\n    #[inductive(do_withdraw)]\n    fn do_withdraw_inductive(pre: Self, post: Self) {\n        assert_multisets_equal!(post.reader, Multiset::<Perm<S>>::empty());\n    }\n\n    property!{\n        reader_guard(x: Perm<S>) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        new_reader() {\n            require let BorrowFlag::ReadBorrow(n) = pre.flag;\n            update flag = BorrowFlag::ReadBorrow(n + 1);\n\n            birds_eye let x = pre.storage->0;\n            add reader += { x };\n            assert(x@.pcell == pre.pcell_loc && x.is_init());\n        }\n    }\n\n    #[inductive(new_reader)]\n    fn new_reader_inductive(pre: Self, post: Self) { }\n\n    transition!{\n        drop_reader(x: Perm<S>) {\n            remove reader -= { x };\n            assert let BorrowFlag::ReadBorrow(n) = pre.flag;\n            assert n >= 1;\n            update flag = BorrowFlag::ReadBorrow((n - 1) as nat);\n        }\n    }\n\n    #[inductive(drop_reader)]\n    fn drop_reader_inductive(pre: Self, post: Self, x: Perm<S>) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n    }\n});\n\npub tracked struct GhostStuff<S> {\n    tracked rc_perm: cell::PointsTo<isize>,\n    tracked flag_token: RefCounter::flag<S>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub closed spec fn wf(self, inst: RefCounter::Instance<S>, rc_cell: PCell<isize>) -> bool {\n        &&& self.rc_perm@.pcell == rc_cell.id()\n        &&& self.flag_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as int == match self.flag_token.value() {\n            BorrowFlag::MutBorrow => 1,\n            BorrowFlag::ReadBorrow(n) => -n,\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct RefCell<S> {\n        // 0: no reference taken\n        // 1: mut reference taken\n        // -n: n non-mut references taken\n        rc_cell: PCell<isize>,\n        value_cell: PCell<S>,\n\n        inst: Tracked< RefCounter::Instance<S> >,\n        inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        predicate {\n            &&& self.inst@.pcell_loc() == self.value_cell.id()\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell)\n        }\n    }\n}\n\npub struct Ref<'a, S> {\n    ref_cell: &'a RefCell<S>,\n    reader: Tracked<RefCounter::reader<S>>,\n}\n\nimpl<'a, S> Ref<'a, S> {\n    pub closed spec fn wf(&self) -> bool {\n        self.ref_cell.wf()\n            && self.reader@.instance_id() == self.ref_cell.inst@.id()\n            && self.reader@.element()@.pcell == self.ref_cell.value_cell.id()\n            && self.reader@.element().is_init()\n    }\n\n    pub closed spec fn value(&self) -> S {\n        self.reader@.element().value()\n    }\n}\n\npub struct RefMut<'a, S> {\n    ref_cell: &'a RefCell<S>,\n    writer: Tracked<RefCounter::writer<S>>,\n    perm: Tracked<Perm<S>>,\n}\n\nimpl<'a, S> RefMut<'a, S> {\n    pub closed spec fn wf(&self) -> bool {\n        self.ref_cell.wf()\n          && self.writer@.instance_id() == self.ref_cell.inst@.id()\n          && self.perm@@.pcell == self.ref_cell.value_cell.id()\n          && self.perm@.is_init()\n    }\n\n    pub closed spec fn value(&self) -> S {\n        self.perm@.value()\n    }\n}\n\nimpl<S> RefCell<S> {\n    fn new(s: S) -> (ref_cell: Self)\n        ensures\n            ref_cell.wf(),\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(0);\n        let (value_cell, Tracked(value_perm)) = PCell::new(s);\n        let tracked (Tracked(inst), Tracked(flag), _, Tracked(writer)) = RefCounter::Instance::<\n            S,\n        >::initialize_empty(value_cell.id(), None);\n        proof {\n            inst.do_deposit(value_perm, &mut flag, value_perm, writer.tracked_unwrap());\n        }\n        let tracked_inst = Tracked(inst);\n        let tracked inv = LocalInvariant::new(\n            (tracked_inst, rc_cell),\n            GhostStuff { rc_perm, flag_token: flag },\n            0,\n        );\n        RefCell::<S> { rc_cell, value_cell, inst: tracked_inst, inv: Tracked(Shared::new(inv)) }\n    }\n\n    fn try_borrow<'a>(&'a self) -> (opt_ref: Option<Ref<'a, S>>)\n        requires\n            self.wf(),\n        ensures\n            match opt_ref {\n                Some(read_ref) => read_ref.wf(),\n                None => true,\n            },\n    {\n        let return_value;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));\n\n            if cur_rc <= 0 && cur_rc > isize::MIN {\n                let new_rc = cur_rc - 1;\n                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n                let tracked (_, Tracked(reader_token)) =\n                    self.inst.borrow().new_reader(&mut flag_token);\n                return_value = Some(Ref {\n                    ref_cell: self,\n                    reader: Tracked(reader_token),\n                });\n            } else {\n                return_value = None;\n            }\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n        return_value\n    }\n\n    fn try_borrow_mut<'a>(&'a self) -> (opt_ref_mut: Option<RefMut<'a, S>>)\n        requires\n            self.wf(),\n        ensures\n            match opt_ref_mut {\n                Some(write_ref) => write_ref.wf(),\n                None => true,\n            },\n    {\n        let return_value;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));\n\n            if cur_rc == 0 {\n                let new_rc = 1;\n                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n                let tracked (Tracked(perm), Tracked(writer_token)) =\n                    self.inst.borrow().do_withdraw(&mut flag_token);\n                return_value = Some(RefMut {\n                    ref_cell: self,\n                    writer: Tracked(writer_token),\n                    perm: Tracked(perm),\n                });\n            } else {\n                return_value = None;\n            }\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n        return_value\n    }\n}\n\nimpl<'a, S> Ref<'a, S> {\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self.value(),\n    {\n        self.ref_cell.value_cell.borrow(\n            Tracked(\n                self.ref_cell.inst.borrow().reader_guard(self.reader@.element(), self.reader.borrow()),\n            ),\n        )\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let Ref { ref_cell, reader: Tracked(reader) } = self;\n        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            proof {\n                ref_cell.inst.borrow().drop_reader(reader.element(), &mut flag_token, reader);\n            }\n\n            let cur_rc = *ref_cell.rc_cell.borrow(Tracked(&rc_perm));\n            let new_rc = cur_rc + 1;\n            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n    }\n}\n\nimpl<'a, S> RefMut<'a, S> {\n    fn replace(&mut self, in_s: S) -> (out_s: S)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            out_s == old(self).value(),\n            in_s == self.value(),\n    {\n        self.ref_cell.value_cell.replace(Tracked(self.perm.borrow_mut()), in_s)\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let RefMut { ref_cell, writer: Tracked(writer), perm: Tracked(perm) } = self;\n        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            proof {\n                ref_cell.inst.borrow().do_deposit(perm, &mut flag_token, perm, writer);\n            }\n\n            let new_rc = 0;\n            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n    }\n}\n\nfn main() {\n    let rf = RefCell::new(5);\n    let read_ref1 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let read_ref2 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let x = *read_ref1.borrow();\n    let y = *read_ref2.borrow();\n    print_u64(x);\n    print_u64(y);\n    read_ref1.dispose();\n    read_ref2.dispose();\n    let mut write_ref = match rf.try_borrow_mut() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let t = write_ref.replace(20);\n    print_u64(t);\n    write_ref.dispose();\n    let read_ref3 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let z = *read_ref3.borrow();\n    print_u64(z);\n    read_ref3.dispose();\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/ref_cell.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 2068, "minimize_time_ms": 3600029, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 435, "minimized_LOC": 435, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "verus_state_machines_macros::tokenized_state_machine", "vstd::cell", "vstd::cell::", "vstd::invariant::", "vstd::multiset::", "vstd::pervasive::", "vstd::prelude::", "vstd::shared::"], "complexity_verus_tokens": 37, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn reader_agrees_storage(&self) -> bool {\n\n pub fn flag_inv(&self) -> bool {\n\n pub fn storage_inv(&self) -> bool {\n\n fn initialize_empty_inductive(post: Self, loc: CellId) {\n\n fn do_deposit_inductive(pre: Self, post: Self, x: Perm<S>) {\n\n fn do_withdraw_inductive(pre: Self, post: Self) {\n\n fn new_reader_inductive(pre: Self, post: Self) {\n\n fn drop_reader_inductive(pre: Self, post: Self, x: Perm<S>) {\n\n fn new(s: S) -> (ref_cell: Self)\n        ensures\n            ref_cell.wf(),\n    {\n\n fn try_borrow<'a>(&'a self) -> (opt_ref: Option<Ref<'a, S>>)\n        requires\n            self.wf(),\n        ensures\n            match opt_ref {\n\n fn try_borrow_mut<'a>(&'a self) -> (opt_ref_mut: Option<RefMut<'a, S>>)\n        requires\n            self.wf(),\n        ensures\n            match opt_ref_mut {\n\n fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self.value(),\n    {\n\n fn dispose(self)\n        requires\n            self.wf(),\n    {\n\n fn replace(&mut self, in_s: S) -> (out_s: S)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            out_s == old(self).value(),\n            in_s == self.value(),\n    {\n\n fn dispose(self)\n        requires\n            self.wf(),\n    {\n\n\nfn main() {", "spec": "spec fn wf(self, inst: RefCounter::Instance<S>, rc_cell: PCell<isize>) -> bool {\n\nspec fn wf(self) -> bool {\n\nspec fn wf(&self) -> bool {\n\nspec fn value(&self) -> S {\n\nspec fn wf(&self) -> bool {\n\nspec fn value(&self) -> S {\n\nuse vstd::invariant::*;\n\n    #[invariant]\n\n    #[invariant]\n\n    #[invariant]\n\n        invariant on inv with (inst, rc_cell)\n\n        ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        requires\n\n        ensures\n\n        requires", "proof": "proof {\n            inst.do_deposit(value_perm, &mut flag, value_perm, writer.tracked_unwrap());\n        }\n\nproof { g = GhostStuff { rc_perm, flag_token }; }\n\nproof { g = GhostStuff { rc_perm, flag_token }; }\n\nproof {\n                ref_cell.inst.borrow().drop_reader(reader.element(), &mut flag_token, reader);\n            }\n\nproof { g = GhostStuff { rc_perm, flag_token }; }\n\nproof {\n                ref_cell.inst.borrow().do_deposit(perm, &mut flag_token, perm, writer);\n            }\n\nproof { g = GhostStuff { rc_perm, flag_token }; }"}}}, "all_snapshots": []}
{"id": "unverified_counting_to_2_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs ignore --- ordinary rust, not verus\n\n// ANCHOR: full\n// Ordinary Rust code, not Verus\n\nuse std::sync::atomic::{AtomicU32, Ordering};\nuse std::sync::Arc;\nuse std::thread::spawn;\n\nfn main() {\n    // Initialize an atomic variable\n\n    let atomic = AtomicU32::new(0);\n\n    // Put it in an Arc so it can be shared by multiple threads.\n\n    let shared_atomic = Arc::new(atomic);\n\n    // Spawn a thread to increment the atomic once.\n\n    let handle1 = {\n        let shared_atomic = shared_atomic.clone();\n        spawn(move || {\n            shared_atomic.fetch_add(1, Ordering::SeqCst);\n        })\n    };\n\n    // Spawn another thread to increment the atomic once.\n\n    let handle2 = {\n        let shared_atomic = shared_atomic.clone();\n        spawn(move || {\n            shared_atomic.fetch_add(1, Ordering::SeqCst);\n        })\n    };\n\n    // Wait on both threads. Exit if an unexpected condition occurs.\n\n    match handle1.join() {\n        Result::Ok(()) => {}\n        _ => {\n            return;\n        }\n    };\n\n    match handle2.join() {\n        Result::Ok(()) => {}\n        _ => {\n            return;\n        }\n    };\n\n    // Load the value, and assert that it should now be 2.\n\n    let val = shared_atomic.load(Ordering::SeqCst);\n    assert!(val == 2);\n}\n// ANCHOR_END: full\n", "minimized_code": "// rust_verify/tests/example.rs ignore --- ordinary rust, not verus\n\n// ANCHOR: full\n// Ordinary Rust code, not Verus\n\nuse std::sync::atomic::{AtomicU32, Ordering};\nuse std::sync::Arc;\nuse std::thread::spawn;\n\nfn main() {\n    // Initialize an atomic variable\n\n    let atomic = AtomicU32::new(0);\n\n    // Put it in an Arc so it can be shared by multiple threads.\n\n    let shared_atomic = Arc::new(atomic);\n\n    // Spawn a thread to increment the atomic once.\n\n    let handle1 = {\n        let shared_atomic = shared_atomic.clone();\n        spawn(move || {\n            shared_atomic.fetch_add(1, Ordering::SeqCst);\n        })\n    };\n\n    // Spawn another thread to increment the atomic once.\n\n    let handle2 = {\n        let shared_atomic = shared_atomic.clone();\n        spawn(move || {\n            shared_atomic.fetch_add(1, Ordering::SeqCst);\n        })\n    };\n\n    // Wait on both threads. Exit if an unexpected condition occurs.\n\n    match handle1.join() {\n        Result::Ok(()) => {}\n        _ => {\n            return;\n        }\n    };\n\n    match handle2.join() {\n        Result::Ok(()) => {}\n        _ => {\n            return;\n        }\n    };\n\n    // Load the value, and assert that it should now be 2.\n\n    let val = shared_atomic.load(Ordering::SeqCst);\n    assert!(val == 2);\n}\n// ANCHOR_END: full\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/unverified_counting_to_2.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "skipped", "error_type": "unknown", "minimum_verifiable": null, "minimized_status": null}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "reduction_ratio": 0.0}, "labeling": {"segments": {"exec": "\nfn main() {"}}}, "all_snapshots": []}
{"id": "unverified_counting_to_n_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs ignore --- ordinary rust, not verus\n\n// ANCHOR: full\n// Ordinary Rust code, not Verus\n\nuse std::sync::atomic::{AtomicU32, Ordering};\nuse std::sync::Arc;\nuse std::thread::spawn;\n\nfn do_count(num_threads: u32) {\n    // Initialize an atomic variable\n\n    let atomic = AtomicU32::new(0);\n\n    // Put it in an Arc so it can be shared by multiple threads.\n\n    let shared_atomic = Arc::new(atomic);\n\n    // Spawn `num_threads` threads to increment the atomic once.\n\n    let mut handles = Vec::new();\n\n    for _i in 0..num_threads {\n        let handle = {\n            let shared_atomic = shared_atomic.clone();\n            spawn(move || {\n                shared_atomic.fetch_add(1, Ordering::SeqCst);\n            })\n        };\n        handles.push(handle);\n    }\n\n    // Wait on all threads. Exit if an unexpected condition occurs.\n\n    for handle in handles.into_iter() {\n        match handle.join() {\n            Result::Ok(()) => {}\n            _ => {\n                return;\n            }\n        };\n    }\n\n    // Load the value, and assert that it should now be `num_threads`.\n\n    let val = shared_atomic.load(Ordering::SeqCst);\n    assert!(val == num_threads);\n}\n\nfn main() {\n    do_count(20);\n}\n// ANCHOR_END: full\n", "minimized_code": "// rust_verify/tests/example.rs ignore --- ordinary rust, not verus\n\n// ANCHOR: full\n// Ordinary Rust code, not Verus\n\nuse std::sync::atomic::{AtomicU32, Ordering};\nuse std::sync::Arc;\nuse std::thread::spawn;\n\nfn do_count(num_threads: u32) {\n    // Initialize an atomic variable\n\n    let atomic = AtomicU32::new(0);\n\n    // Put it in an Arc so it can be shared by multiple threads.\n\n    let shared_atomic = Arc::new(atomic);\n\n    // Spawn `num_threads` threads to increment the atomic once.\n\n    let mut handles = Vec::new();\n\n    for _i in 0..num_threads {\n        let handle = {\n            let shared_atomic = shared_atomic.clone();\n            spawn(move || {\n                shared_atomic.fetch_add(1, Ordering::SeqCst);\n            })\n        };\n        handles.push(handle);\n    }\n\n    // Wait on all threads. Exit if an unexpected condition occurs.\n\n    for handle in handles.into_iter() {\n        match handle.join() {\n            Result::Ok(()) => {}\n            _ => {\n                return;\n            }\n        };\n    }\n\n    // Load the value, and assert that it should now be `num_threads`.\n\n    let val = shared_atomic.load(Ordering::SeqCst);\n    assert!(val == num_threads);\n}\n\nfn main() {\n    do_count(20);\n}\n// ANCHOR_END: full\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/unverified_counting_to_n.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "skipped", "error_type": "unknown", "minimum_verifiable": null, "minimized_status": null}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "reduction_ratio": 0.0}, "labeling": {"segments": {"exec": "\nfn do_count(num_threads: u32) {\n\n\nfn main() {"}}}, "all_snapshots": []}
{"id": "unverified_fifo_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs ignore --- ordianary rust, not verus\n\n// ANCHOR: full\n// Ordinary Rust code, not Verus\n\nuse std::cell::UnsafeCell;\nuse std::mem::MaybeUninit;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\n\n// ANCHOR: queue\nstruct Queue<T> {\n    buffer: Vec<UnsafeCell<MaybeUninit<T>>>,\n    head: AtomicU64,\n    tail: AtomicU64,\n}\n// ANCHOR_END: queue\n\n// ANCHOR: producer_consumer\npub struct Producer<T> {\n    queue: Arc<Queue<T>>,\n    tail: usize,\n}\n\npub struct Consumer<T> {\n    queue: Arc<Queue<T>>,\n    head: usize,\n}\n// ANCHOR_END: producer_consumer\n\n// ANCHOR: impl\npub fn new_queue<T>(len: usize) -> (Producer<T>, Consumer<T>) {\n    // Create a vector of UnsafeCells to serve as the ring buffer\n\n    let mut backing_cells_vec = Vec::<UnsafeCell<MaybeUninit<T>>>::new();\n    while backing_cells_vec.len() < len {\n        let cell = UnsafeCell::new(MaybeUninit::uninit());\n        backing_cells_vec.push(cell);\n    }\n\n    // Initialize head and tail to 0 (empty)\n    let head_atomic = AtomicU64::new(0);\n    let tail_atomic = AtomicU64::new(0);\n\n    // Package it all into a queue object, and make a reference-counted pointer to it\n    // so it can be shared by the Producer and the Consumer.\n    let queue = Queue::<T> { head: head_atomic, tail: tail_atomic, buffer: backing_cells_vec };\n    let queue_arc = Arc::new(queue);\n\n    let prod = Producer::<T> { queue: queue_arc.clone(), tail: 0 };\n    let cons = Consumer::<T> { queue: queue_arc, head: 0 };\n    (prod, cons)\n}\n\nimpl<T> Producer<T> {\n    pub fn enqueue(&mut self, t: T) {\n        // Loop: if the queue is full, then block until it is not.\n        loop {\n            let len = self.queue.buffer.len();\n\n            // Calculate the index of the slot right after `tail`, wrapping around\n            // if necessary. If the enqueue is successful, then we will be updating\n            // the `tail` to this value.\n            let next_tail = if self.tail + 1 == len { 0 } else { self.tail + 1 };\n\n            // Get the current `head` value from the shared atomic.\n            let head = self.queue.head.load(Ordering::SeqCst);\n\n            // Check to make sure there is room. (We can't advance the `tail` pointer\n            // if it would become equal to the head, since `tail == head` denotes\n            // an empty state.)\n            // If there's no room, we'll just loop and try again.\n            if head != next_tail as u64 {\n                // Here's the unsafe part: writing the given `t` value into the `UnsafeCell`.\n                unsafe {\n                    (*self.queue.buffer[self.tail].get()).write(t);\n                }\n\n                // Update the `tail` (both the shared atomic and our local copy).\n                self.queue.tail.store(next_tail as u64, Ordering::SeqCst);\n                self.tail = next_tail;\n\n                // Done.\n                return;\n            }\n        }\n    }\n}\n\nimpl<T> Consumer<T> {\n    pub fn dequeue(&mut self) -> T {\n        // Loop: if the queue is empty, then block until it is not.\n        loop {\n            let len = self.queue.buffer.len();\n\n            // Calculate the index of the slot right after `head`, wrapping around\n            // if necessary. If the enqueue is successful, then we will be updating\n            // the `head` to this value.\n            let next_head = if self.head + 1 == len { 0 } else { self.head + 1 };\n\n            // Get the current `tail` value from the shared atomic.\n            let tail = self.queue.tail.load(Ordering::SeqCst);\n\n            // Check to see if the queue is nonempty.\n            // If it's empty, we'll just loop and try again.\n            if self.head as u64 != tail {\n                // Load the stored message from the UnsafeCell\n                // (replacing it with \"uninitialized\" memory).\n                let t = unsafe {\n                    let mut tmp = MaybeUninit::uninit();\n                    std::mem::swap(&mut *self.queue.buffer[self.head].get(), &mut tmp);\n                    tmp.assume_init()\n                };\n\n                // Update the `head` (both the shared atomic and our local copy).\n                self.queue.head.store(next_head as u64, Ordering::SeqCst);\n                self.head = next_head;\n\n                // Done. Return the value we loaded out of the buffer.\n                return t;\n            }\n        }\n    }\n}\n// ANCHOR_END: impl\n\nfn main() {\n    let (mut producer, mut consumer) = new_queue(20);\n    producer.enqueue(5);\n    let _x = consumer.dequeue();\n}\n// ANCHOR_END: full\n", "minimized_code": "// rust_verify/tests/example.rs ignore --- ordianary rust, not verus\n\n// ANCHOR: full\n// Ordinary Rust code, not Verus\n\nuse std::cell::UnsafeCell;\nuse std::mem::MaybeUninit;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\n\n// ANCHOR: queue\nstruct Queue<T> {\n    buffer: Vec<UnsafeCell<MaybeUninit<T>>>,\n    head: AtomicU64,\n    tail: AtomicU64,\n}\n// ANCHOR_END: queue\n\n// ANCHOR: producer_consumer\npub struct Producer<T> {\n    queue: Arc<Queue<T>>,\n    tail: usize,\n}\n\npub struct Consumer<T> {\n    queue: Arc<Queue<T>>,\n    head: usize,\n}\n// ANCHOR_END: producer_consumer\n\n// ANCHOR: impl\npub fn new_queue<T>(len: usize) -> (Producer<T>, Consumer<T>) {\n    // Create a vector of UnsafeCells to serve as the ring buffer\n\n    let mut backing_cells_vec = Vec::<UnsafeCell<MaybeUninit<T>>>::new();\n    while backing_cells_vec.len() < len {\n        let cell = UnsafeCell::new(MaybeUninit::uninit());\n        backing_cells_vec.push(cell);\n    }\n\n    // Initialize head and tail to 0 (empty)\n    let head_atomic = AtomicU64::new(0);\n    let tail_atomic = AtomicU64::new(0);\n\n    // Package it all into a queue object, and make a reference-counted pointer to it\n    // so it can be shared by the Producer and the Consumer.\n    let queue = Queue::<T> { head: head_atomic, tail: tail_atomic, buffer: backing_cells_vec };\n    let queue_arc = Arc::new(queue);\n\n    let prod = Producer::<T> { queue: queue_arc.clone(), tail: 0 };\n    let cons = Consumer::<T> { queue: queue_arc, head: 0 };\n    (prod, cons)\n}\n\nimpl<T> Producer<T> {\n    pub fn enqueue(&mut self, t: T) {\n        // Loop: if the queue is full, then block until it is not.\n        loop {\n            let len = self.queue.buffer.len();\n\n            // Calculate the index of the slot right after `tail`, wrapping around\n            // if necessary. If the enqueue is successful, then we will be updating\n            // the `tail` to this value.\n            let next_tail = if self.tail + 1 == len { 0 } else { self.tail + 1 };\n\n            // Get the current `head` value from the shared atomic.\n            let head = self.queue.head.load(Ordering::SeqCst);\n\n            // Check to make sure there is room. (We can't advance the `tail` pointer\n            // if it would become equal to the head, since `tail == head` denotes\n            // an empty state.)\n            // If there's no room, we'll just loop and try again.\n            if head != next_tail as u64 {\n                // Here's the unsafe part: writing the given `t` value into the `UnsafeCell`.\n                unsafe {\n                    (*self.queue.buffer[self.tail].get()).write(t);\n                }\n\n                // Update the `tail` (both the shared atomic and our local copy).\n                self.queue.tail.store(next_tail as u64, Ordering::SeqCst);\n                self.tail = next_tail;\n\n                // Done.\n                return;\n            }\n        }\n    }\n}\n\nimpl<T> Consumer<T> {\n    pub fn dequeue(&mut self) -> T {\n        // Loop: if the queue is empty, then block until it is not.\n        loop {\n            let len = self.queue.buffer.len();\n\n            // Calculate the index of the slot right after `head`, wrapping around\n            // if necessary. If the enqueue is successful, then we will be updating\n            // the `head` to this value.\n            let next_head = if self.head + 1 == len { 0 } else { self.head + 1 };\n\n            // Get the current `tail` value from the shared atomic.\n            let tail = self.queue.tail.load(Ordering::SeqCst);\n\n            // Check to see if the queue is nonempty.\n            // If it's empty, we'll just loop and try again.\n            if self.head as u64 != tail {\n                // Load the stored message from the UnsafeCell\n                // (replacing it with \"uninitialized\" memory).\n                let t = unsafe {\n                    let mut tmp = MaybeUninit::uninit();\n                    std::mem::swap(&mut *self.queue.buffer[self.head].get(), &mut tmp);\n                    tmp.assume_init()\n                };\n\n                // Update the `head` (both the shared atomic and our local copy).\n                self.queue.head.store(next_head as u64, Ordering::SeqCst);\n                self.head = next_head;\n\n                // Done. Return the value we loaded out of the buffer.\n                return t;\n            }\n        }\n    }\n}\n// ANCHOR_END: impl\n\nfn main() {\n    let (mut producer, mut consumer) = new_queue(20);\n    producer.enqueue(5);\n    let _x = consumer.dequeue();\n}\n// ANCHOR_END: full\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/unverified_fifo.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "skipped", "error_type": "unknown", "minimum_verifiable": null, "minimized_status": null}, "quality": {"original_LOC": 132, "minimized_LOC": 132, "reduction_ratio": 0.0}, "labeling": {"segments": {"exec": "\npub fn new_queue<T>(len: usize) -> (Producer<T>, Consumer<T>) {\n\n pub fn enqueue(&mut self, t: T) {\n\n pub fn dequeue(&mut self) -> T {\n\n\nfn main() {"}}}, "all_snapshots": []}
{"id": "unverified_rc_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs ignore --- ordinary rust, not verus\n\n// ANCHOR: full\n// Ordinary Rust code, not Verus\n\nstruct InnerRc<T> {\n    rc_cell: std::cell::UnsafeCell<u64>,\n    t: T,\n}\n\nstruct Rc<T> {\n    ptr: *mut InnerRc<T>,\n}\n\nimpl<T> Rc<T> {\n    fn new(t: T) -> Self {\n        // Allocate a new InnerRc object, initialize the counter to 1,\n        // and return a pointer to it.\n        let rc_cell = std::cell::UnsafeCell::new(1);\n        let inner_rc = InnerRc { rc_cell, t };\n        let ptr = Box::leak(Box::new(inner_rc));\n        Rc { ptr }\n    }\n\n    fn clone(&self) -> Self {\n        unsafe {\n            // Increment the counter.\n            // If incrementing the counter would lead to overflow, then abort.\n            let inner_rc = &*self.ptr;\n            let count = *inner_rc.rc_cell.get();\n            if count == 0xffffffffffffffff {\n                std::process::abort();\n            }\n            *inner_rc.rc_cell.get() = count + 1;\n        }\n\n        // Return a new Rc object with the same pointer.\n        Rc { ptr: self.ptr }\n    }\n\n    fn drop(self) {\n        unsafe {\n            // Decrement the counter.\n            let inner_rc = &*self.ptr;\n            let count = *inner_rc.rc_cell.get() - 1;\n            *inner_rc.rc_cell.get() = count;\n\n            // If the counter hits 0, drop the `T` and deallocate the memory.\n            if count == 0 {\n                std::ptr::drop_in_place(&mut (*self.ptr).t);\n                std::alloc::dealloc(self.ptr as *mut u8, std::alloc::Layout::for_value(&*self.ptr));\n            }\n        }\n    }\n\n    fn borrow(&self) -> &T {\n        unsafe { &(*self.ptr).t }\n    }\n}\n\n// Example usage\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, Rc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = Rc::new(Sequence::Nil);\n    let nil_clone = nil.clone();\n    let a5 = Rc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = Rc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = Rc::new(Sequence::Cons(6, a7.clone()));\n\n    let x1 = nil.borrow();\n    let x2 = nil_clone.borrow();\n    match x1 {\n        Sequence::Nil => {}\n        Sequence::Cons(_, _) => {\n            assert!(false);\n        }\n    }\n    match x2 {\n        Sequence::Nil => {}\n        Sequence::Cons(_, _) => {\n            assert!(false);\n        }\n    }\n\n    nil.drop();\n    nil_clone.drop();\n    a5.drop();\n    a7.drop();\n    a67.drop();\n}\n// ANCHOR_END: full\n", "minimized_code": "// rust_verify/tests/example.rs ignore --- ordinary rust, not verus\n\n// ANCHOR: full\n// Ordinary Rust code, not Verus\n\nstruct InnerRc<T> {\n    rc_cell: std::cell::UnsafeCell<u64>,\n    t: T,\n}\n\nstruct Rc<T> {\n    ptr: *mut InnerRc<T>,\n}\n\nimpl<T> Rc<T> {\n    fn new(t: T) -> Self {\n        // Allocate a new InnerRc object, initialize the counter to 1,\n        // and return a pointer to it.\n        let rc_cell = std::cell::UnsafeCell::new(1);\n        let inner_rc = InnerRc { rc_cell, t };\n        let ptr = Box::leak(Box::new(inner_rc));\n        Rc { ptr }\n    }\n\n    fn clone(&self) -> Self {\n        unsafe {\n            // Increment the counter.\n            // If incrementing the counter would lead to overflow, then abort.\n            let inner_rc = &*self.ptr;\n            let count = *inner_rc.rc_cell.get();\n            if count == 0xffffffffffffffff {\n                std::process::abort();\n            }\n            *inner_rc.rc_cell.get() = count + 1;\n        }\n\n        // Return a new Rc object with the same pointer.\n        Rc { ptr: self.ptr }\n    }\n\n    fn drop(self) {\n        unsafe {\n            // Decrement the counter.\n            let inner_rc = &*self.ptr;\n            let count = *inner_rc.rc_cell.get() - 1;\n            *inner_rc.rc_cell.get() = count;\n\n            // If the counter hits 0, drop the `T` and deallocate the memory.\n            if count == 0 {\n                std::ptr::drop_in_place(&mut (*self.ptr).t);\n                std::alloc::dealloc(self.ptr as *mut u8, std::alloc::Layout::for_value(&*self.ptr));\n            }\n        }\n    }\n\n    fn borrow(&self) -> &T {\n        unsafe { &(*self.ptr).t }\n    }\n}\n\n// Example usage\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, Rc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = Rc::new(Sequence::Nil);\n    let nil_clone = nil.clone();\n    let a5 = Rc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = Rc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = Rc::new(Sequence::Cons(6, a7.clone()));\n\n    let x1 = nil.borrow();\n    let x2 = nil_clone.borrow();\n    match x1 {\n        Sequence::Nil => {}\n        Sequence::Cons(_, _) => {\n            assert!(false);\n        }\n    }\n    match x2 {\n        Sequence::Nil => {}\n        Sequence::Cons(_, _) => {\n            assert!(false);\n        }\n    }\n\n    nil.drop();\n    nil_clone.drop();\n    a5.drop();\n    a7.drop();\n    a67.drop();\n}\n// ANCHOR_END: full\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/unverified_rc.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "skipped", "error_type": "unknown", "minimum_verifiable": null, "minimized_status": null}, "quality": {"original_LOC": 96, "minimized_LOC": 96, "reduction_ratio": 0.0}, "labeling": {"segments": {"exec": " fn new(t: T) -> Self {\n\n fn clone(&self) -> Self {\n\n fn drop(self) {\n\n fn borrow(&self) -> &T {\n\n\nfn main() {"}}}, "all_snapshots": []}
{"id": "statements_cc0b9f7d", "original_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nfn test_if(b: bool) {\n    let mut x: u32 = 0;\n    if b {\n        x = 10;\n    }\n    assert(b ==> x == 10);\n    if b {\n        x = x + 3;\n        x = x + 4;\n    } else {\n        x = x + 2;\n    }\n    assert(b ==> x == 17);\n    assert(!b ==> x == 2);\n    assert(x == if b {\n        17int\n    } else {\n        2\n    });\n    if x == 0 {\n        assert(false);\n    } else if x == 1 {\n        assert(false);\n    } else if x == 2 {\n        assert(!b);\n    } else {\n        assert(x == 17);\n    }\n}\n\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;\n    while i < 100\n        invariant\n            10 <= i,\n            i <= 100,\n            b1 == i * 2,\n        decreases 100 - i,\n    {\n        assert(b2 <= 255);\n        i = i + 1;\n        b1 = b1 + 2;\n        b2 = b2 / 2;\n    }\n    assert(b1 == 200);\n    assert(b3 == 30);\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nfn test_if(b: bool) {\n    let mut x: u32 = 0;\n    if b {\n        x = 10;\n    }\n    assert(b ==> x == 10);\n    if b {\n        x = x + 3;\n        x = x + 4;\n    } else {\n        x = x + 2;\n    }\n    assert(b ==> x == 17);\n    assert(!b ==> x == 2);\n    assert(x == if b {\n        17int\n    } else {\n        2\n    });\n    if x == 0 {\n        assert(false);\n    } else if x == 1 {\n        assert(false);\n    } else if x == 2 {\n        assert(!b);\n    } else {\n        assert(x == 17);\n    }\n}\n\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;\n    while i < 100\n        invariant\n            10 <= i,\n            i <= 100,\n            b1 == i * 2,\n        decreases 100 - i,\n    {\n        assert(b2 <= 255);\n        i = i + 1;\n        b1 = b1 + 2;\n        b2 = b2 / 2;\n    }\n    assert(b1 == 200);\n    assert(b3 == 30);\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/statements.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1972, "minimize_time_ms": 247744, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::"], "complexity_verus_tokens": 4, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {\n\n\nfn test_if(b: bool) {\n\n\nfn test_loop() {", "spec": "        invariant\n\n        decreases 100 - i,"}}}, "all_snapshots": ["use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nfn test_if(b: bool) {\n    let mut x: u32 = 0;\n    if b {\n        x = 10;\n    }\n    assert(b ==> x == 10);\n    if b {\n        x = x + 3;\n        x = x + 4;\n    } else {\n        x = x + 2;\n    }\n    assert(b ==> x == 17);\n    assert(!b ==> x == 2);\n    assert(x == if b {\n        17int\n    } else {\n        2\n    });\n    if x == 0 {\n        assert(false);\n    } else if x == 1 {\n        assert(false);\n    } else if x == 2 {\n        assert(!b);\n    } else {\n        assert(x == 17);\n    }\n}\n\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;\n    while i < 100\n        invariant\n            10 <= i,\n            i <= 100,\n            b1 == i * 2,\n        decreases 100 - i,\n    {\n        assert(b2 <= 255);\n        i = i + 1;\n        b1 = b1 + 2;\n        b2 = b2 / 2;\n    }\n    assert(b1 == 200);\n    assert(b3 == 30);\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nfn test_if(b: bool) {\n    let mut x: u32 = 0;\n    if b {\n        x = 10;\n    }\n    assert(b ==> x == 10);\n    if b {\n        x = x + 3;\n        x = x + 4;\n    } else {\n        x = x + 2;\n    }\n    assert(b ==> x == 17);\n    assert(!b ==> x == 2);\n    assert(x == if b {\n        17int\n    } else {\n        2\n    });\n    if x == 0 {\n        assert(false);\n    } else if x == 1 {\n        assert(false);\n    } else if x == 2 {\n        assert(!b);\n    } else {\n        assert(x == 17);\n    }\n}\n\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;\n    while i < 100\n        invariant\n            10 <= i,\n            i <= 100,\n            b1 == i * 2,\n        decreases 100 - i,\n    {\n        assert(b2 <= 255);\n        i = i + 1;\n        b1 = b1 + 2;\n        b2 = b2 / 2;\n    }\n    assert(b1 == 200);\n    assert(b3 == 30);\n}\n\n} // verus!\n"]}
{"id": "statics_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::prelude::*;\nuse vstd::*;\nuse vstd::raw_ptr::MemContents;\n\nuse std::sync::atomic::*;\n\nverus! {\n\n// A simple counter, albeit with nothing verified about it.\nexec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n\nfn increment_counter() {\n    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);\n}\n\n// Thread-safe lazy initialization\npub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>),\n}\n\nstruct_with_invariants!{\n    struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            // State = 0: Uninitialized\n            // State = 1: currently initializing\n            // State = 2: is initialized\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() === MemContents::Init(None))\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                    v == 2\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\n\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\n\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n\n    fn get<'a>(&'a self) -> &'a T\n        requires\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                // Already initialized.\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n            } else {\n                // Initialization is required. Try to take the lock if initialization\n                // isn't already in progress.\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        // don't initialize after all\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    // Do initialization\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();\n                } else {\n                    // Wait for initialization to complete by a different thread\n                    // (Try again in the next iteration of the loop.)\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nstruct X {}\n\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\n\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\n\nfn get_lazy_x() -> &'static X {\n    LAZY_X.get()\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n  use vstd::prelude::*;\n  use vstd::*;\n  use std::sync::atomic::*;\n  verus! {\n exec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n fn increment_counter() {     GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed); }\n pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n  struct_with_invariants!{\n     struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {         loop             invariant                 self.wf(),         {             let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                }\n            }\n        }\n    }\n}\nstruct X {}\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\nfn get_lazy_x() -> &'static X {     LAZY_X.get() } fn main() { } }  ", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/statics.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1254, "minimize_time_ms": 2525930, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 173, "minimized_LOC": 116, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::atomic_ghost::", "vstd::cell::", "vstd::prelude::", "vstd::", "vstd::raw_ptr::MemContents", "std::sync::atomic::"], "complexity_verus_tokens": 21, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.6705202312138728}, "labeling": {"segments": {"exec": " fn increment_counter() {\n\n fn initialize() -> Self;\n}\nimpl<T: Initializable> Lazy<T> {\n\n fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n\n fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {\n\n fn initialize() -> Self {\n\n\nfn get_lazy_x() -> &'static X {\n\n fn main() {", "spec": "spec fn wf(&self) -> bool {\n\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n\n        ensures\n\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {         loop             invariant                 self.wf(),         {             let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n\n    ensures"}}}, "all_snapshots": ["#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::prelude::*;\nuse vstd::*;\nuse vstd::raw_ptr::MemContents;\n\nuse std::sync::atomic::*;\n\nverus! {\n\n// A simple counter, albeit with nothing verified about it.\nexec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n\nfn increment_counter() {\n    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);\n}\n\n// Thread-safe lazy initialization\npub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>),\n}\n\nstruct_with_invariants!{\n    struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            // State = 0: Uninitialized\n            // State = 1: currently initializing\n            // State = 2: is initialized\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() === MemContents::Init(None))\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                    v == 2\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\n\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\n\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n\n    fn get<'a>(&'a self) -> &'a T\n        requires\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                // Already initialized.\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n            } else {\n                // Initialization is required. Try to take the lock if initialization\n                // isn't already in progress.\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        // don't initialize after all\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    // Do initialization\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();\n                } else {\n                    // Wait for initialization to complete by a different thread\n                    // (Try again in the next iteration of the loop.)\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nstruct X {}\n\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\n\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\n\nfn get_lazy_x() -> &'static X {\n    LAZY_X.get()\n}\n\nfn main() {\n}\n\n} // verus!\n", " use cell::*;\n                                 use prelude::*;\n                                 use vstd::*;\n                                 verus! {                             pub enum a<h: 'static> {\n    Initialized(&'static PointsTo<Option<h>>)}\n                                 struct_with_invariants!{                                 struct b<h: 'static> {\n        cell: PCell<Option<h>>,\n        c:atomic_ghost::AtomicU64<_, a<h>, _>\n    }\n    spec fn d(self) -> bool {\n        invariant c with (cell) (e: u64, f: a<h>) {\n            match f {\n                a::Initialized(g) => \n                      g.id() == cell.id()\n            }\n        }\n    }\n}\n   fn main() ;\n   }\n", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n  use vstd::prelude::*;\n  use vstd::*;\n  use std::sync::atomic::*;\n  verus! {\n exec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n fn increment_counter() {     GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed); }\n pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n  struct_with_invariants!{\n     struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {         loop             invariant                 self.wf(),         {             let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                }\n            }\n        }\n    }\n}\nstruct X {}\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\nfn get_lazy_x() -> &'static X {     LAZY_X.get() } fn main() { } }  ", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n  use vstd::prelude::*;\n  use vstd::*;\n  use std::sync::atomic::*;\n  verus! {\n exec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n fn increment_counter() {     GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed); }\n pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n  struct_with_invariants!{\n     struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {         loop             invariant                 self.wf(),         {             let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n                let mut do_initialization = (cur_state == 0);\n                if do_initialization {\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                }\n            }\n        }\n    }\n}\nstruct X {}\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\nfn get_lazy_x() -> &'static X {     LAZY_X.get() } fn main() { } }  ", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n        use vstd::prelude::*;\n        use vstd::*;\n        verus! {\n       pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n        struct_with_invariants!{\n           struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {\n              loop             invariant                 self.wf(),         {}\n    }\n}\nstruct X ;\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X \n    }\n}\nexec static LAZY_X: Lazy<X>\n    ensures\n{\n    Lazy::<X>::new()\n}\n fn main() ;\n }\n", "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n          use vstd::prelude::*;\n          use vstd::*;\n          verus! {\n        pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n          struct_with_invariants!{\n            struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => \n                      && points_to.id() == cell.id()\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {               loop             invariant                 self.wf(),         {}     }\n }\n   fn main() ;\n   }\n", " use vstd::cell::*;\n            use vstd::prelude::*;\n            use vstd::*;\n            verus! {\n          pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n            struct_with_invariants!{\n              struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => \n                      && points_to.id() == cell.id()\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n }\n   fn main() ;\n   }\n", " use cell::*;\n                use prelude::*;\n                use vstd::*;\n                verus! {\n              pub enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static PointsTo<Option<T>>)}\n                struct_with_invariants!{\n                  struct Lazy<T: 'static> {\n        cell: PCell<Option<T>>,\n        state:atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(self) -> bool {\n        invariant state with (cell) (v: u64, g: GhostState<T>) {\n            match g {\n                (points_to) => {\n                    v == 0\n                }\n                GhostStateInitializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => \n                      points_to.id() == cell.id()\n            }\n        }\n    }\n}\nimpl<T: > Lazy<T> {\n    fn new() -> (Self)\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state:atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)))}\n    }\n }\n   fn main() ;\n   }\n", " use cell::*;\n                use prelude::*;\n                use vstd::*;\n                verus! {\n              pub enum a<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static PointsTo<Option<T>>)}\n                struct_with_invariants!{\n                  struct b<T: 'static> {\n        cell: PCell<Option<T>>,\n        c:atomic_ghost::AtomicU64<_, a<T>, _>\n    }\n    spec fn d(self) -> bool {\n        invariant c with (cell) (e: u64, f: a<T>) {\n            match f {\n                points_to => {\n                    e == 0\n                }\n                a::Initialized(points_to) => \n                      points_to.id() == cell.id()\n            }\n        }\n    }\n}\nimpl<T > b<T> {\n    fn new() -> Self\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        b {\n            cell: pcell,\n            c:atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(a::Uninitialized(points_to)))}\n    }\n }\n   fn main() ;\n   }\n", " use cell::*;\n                use prelude::*;\n                use vstd::*;\n                verus! {\n              pub enum a<T: 'static> {\n    Uninitialized(),\n    Initializing,\n    Initialized(&'static PointsTo<Option<T>>)}\n                struct_with_invariants!{\n                  struct b<T: 'static> {\n        cell: PCell<Option<T>>,\n        c:atomic_ghost::AtomicU64<_, a<T>, _>\n    }\n    spec fn d(self) -> bool {\n        invariant c with (cell) (e: u64, f: a<T>) {\n            match f {\n                g => {\n                    e == 0\n                }\n                a::Initialized(g) => \n                      g.id() == cell.id()\n            }\n        }\n    }\n}\nimpl<T > b<T> {}\n   fn main() ;\n   }\n", " use cell::*;\n                 use prelude::*;\n                 use vstd::*;\n                 verus! {               pub enum a<T: 'static> {\n    Initialized(&'static PointsTo<Option<T>>)}\n                 struct_with_invariants!{                   struct b<T: 'static> {\n        cell: PCell<Option<T>>,\n        c:atomic_ghost::AtomicU64<_, a<T>, _>\n    }\n    spec fn d(self) -> bool {\n        invariant c with (cell) (e: u64, f: a<T>) {\n            match f {\n                g => {\n                    e == 0\n                }\n                a::Initialized(g) => \n                      g.id() == cell.id()\n            }\n        }\n    }\n}\n   fn main() ;\n   }\n"]}
{"id": "num_cc0b9f7d", "original_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn test_u32_checked_add() {\n    runtime_assert(u32::MAX.checked_add(1).is_none());\n    runtime_assert((u32::MAX - 1).checked_add(1).unwrap() == u32::MAX);\n    runtime_assert(5u32.checked_add(10).unwrap() == 15);\n}\n\nfn test_u32_checked_add_signed() {\n    runtime_assert(1u32.checked_add_signed(-2).is_none());\n    runtime_assert(1u32.checked_add_signed(-1).unwrap() == 0);\n    runtime_assert(5u32.checked_add_signed(10).unwrap() == 15);\n}\n\nfn test_u32_checked_sub() {\n    runtime_assert(1u32.checked_sub(2).is_none());\n    runtime_assert(1u32.checked_sub(1).unwrap() == 0);\n    runtime_assert(u32::MAX.checked_sub(u32::MAX).unwrap() == 0);\n    runtime_assert(10u32.checked_sub(5).unwrap() == 5);\n}\n\nfn test_u32_checked_mul() {\n    runtime_assert(u32::MAX.checked_mul(2).is_none());\n    runtime_assert(u32::MAX.checked_mul(1).unwrap() == u32::MAX);\n    runtime_assert(u32::MAX.checked_mul(0).unwrap() == 0);\n    runtime_assert((u32::MAX / 2).checked_mul(4).is_none());\n    runtime_assert(5u32.checked_mul(10).unwrap() == 50);\n}\n\nfn test_u32_checked_div() {\n    runtime_assert(u32::MAX.checked_div(0).is_none());\n    runtime_assert(u32::MAX.checked_div(1).unwrap() == u32::MAX);\n    runtime_assert(10u32.checked_div(5).unwrap() == 2);\n}\n\nfn test_u32_checked_div_euclid() {\n    runtime_assert(u32::MAX.checked_div_euclid(0).is_none());\n    runtime_assert(u32::MAX.checked_div_euclid(1).unwrap() == u32::MAX);\n    runtime_assert(10u32.checked_div_euclid(5).unwrap() == 2);\n}\n\nfn test_u32_checked_rem() {\n    runtime_assert(u32::MAX.checked_rem(0).is_none());\n    runtime_assert(0u32.checked_rem(0).is_none());\n    runtime_assert(0u32.checked_rem(1).unwrap() == 0);\n    runtime_assert(7u32.checked_rem(2).unwrap() == 1);\n}\n\nfn test_u32_checked_rem_euclid() {\n    runtime_assert(u32::MAX.checked_rem_euclid(0).is_none());\n    runtime_assert(0u32.checked_rem_euclid(0).is_none());\n    runtime_assert(0u32.checked_rem_euclid(1).unwrap() == 0);\n    runtime_assert(7u32.checked_rem_euclid(2).unwrap() == 1);\n}\n\nfn test_i32_checked_add() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MAX.checked_add(1).is_none());\n    runtime_assert((i32::MAX - 2).checked_add(1).unwrap() == i32::MAX - 1);\n    runtime_assert(i32::MIN.checked_add(-1).is_none());\n    runtime_assert(i32::MIN.checked_add(1).unwrap() == i32::MIN + 1);\n    runtime_assert(neg_ten.checked_add(5).unwrap() == -5);\n    runtime_assert(10i32.checked_add(5).unwrap() == 15);\n    runtime_assert(10i32.checked_add(-5).unwrap() == 5);\n    runtime_assert(neg_ten.checked_add(-5).unwrap() == -15);\n}\n\nfn test_i32_checked_add_unsigned() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MAX.checked_add_unsigned(1).is_none());\n    runtime_assert((i32::MAX - 1).checked_add_unsigned(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_add_unsigned(10).unwrap() == i32::MIN + 10);\n    runtime_assert(i32::MIN.checked_add_unsigned(u32::MAX).unwrap() == i32::MAX);\n    runtime_assert(neg_ten.checked_add_unsigned(5).unwrap() == -5);\n}\n\nfn test_i32_checked_sub() {\n    runtime_assert((i32::MIN + 2).checked_sub(1).unwrap() == i32::MIN + 1);\n    runtime_assert((i32::MIN + 2).checked_sub(3).is_none());\n    runtime_assert(i32::MIN.checked_sub(i32::MIN).unwrap() == 0);\n    runtime_assert(i32::MIN.checked_sub(i32::MAX).is_none());\n    runtime_assert(0i32.checked_sub(i32::MIN).is_none());\n    runtime_assert(0i32.checked_sub(i32::MAX).unwrap() == i32::MIN + 1);\n}\n\nfn test_i32_checked_sub_unsigned() {\n    let neg_five: i32 = -5;\n    runtime_assert(i32::MIN.checked_sub_unsigned(1).is_none());\n    runtime_assert((i32::MIN + 1).checked_sub_unsigned(1).unwrap() == i32::MIN);\n    runtime_assert(0i32.checked_sub_unsigned(2147483647u32).unwrap() == i32::MIN + 1);\n    runtime_assert(neg_five.checked_sub_unsigned(5).unwrap() == -10);\n}\n\nfn test_i32_checked_mul() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MIN.checked_mul(1).unwrap() == i32::MIN);\n    runtime_assert(i32::MIN.checked_mul(-1).is_none());\n    runtime_assert(i32::MAX.checked_mul(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MAX.checked_mul(-1).unwrap() == i32::MIN + 1);\n    runtime_assert(i32::MAX.checked_mul(2).is_none());\n    runtime_assert(neg_ten.checked_mul(-5).unwrap() == 50);\n}\n\nfn test_i32_checked_div() {\n    let neg_ten: i32 = -10;\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_div(0).is_none());\n    runtime_assert(i32::MIN.checked_div(1).unwrap() == i32::MIN);\n    runtime_assert(i32::MAX.checked_div(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div(-1).is_none());\n    runtime_assert(i32::MAX.checked_div(-1).unwrap() == i32::MIN + 1);\n    runtime_assert(10i32.checked_div(-5).unwrap() == -2);\n    runtime_assert(10i32.checked_div(5).unwrap() == 2);\n    runtime_assert(neg_ten.checked_div(-5).unwrap() == 2);\n    runtime_assert(neg_ten.checked_div(5).unwrap() == -2);\n    runtime_assert(97i32.checked_div(-7).unwrap() == -13);\n    runtime_assert(97i32.checked_div(7).unwrap() == 13);\n    runtime_assert(lhs.checked_div(-7).unwrap() == 13);\n    runtime_assert(lhs.checked_div(7).unwrap() == -13);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_div(-7).unwrap() == -6);\n    runtime_assert(47i32.checked_div(7).unwrap() == 6);\n    runtime_assert(lhs.checked_div(-7).unwrap() == 6);\n    runtime_assert(lhs.checked_div(7).unwrap() == -6);\n    runtime_assert(47i32.checked_div(-2).unwrap() == -23);\n    runtime_assert(47i32.checked_div(2).unwrap() == 23);\n    runtime_assert(lhs.checked_div(-2).unwrap() == 23);\n    runtime_assert(lhs.checked_div(2).unwrap() == -23);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_div(-5).unwrap() == -14);\n    runtime_assert(73i32.checked_div(5).unwrap() == 14);\n    runtime_assert(lhs.checked_div(-5).unwrap() == 14);\n    runtime_assert(lhs.checked_div(5).unwrap() == -14);\n    runtime_assert(73i32.checked_div(-47).unwrap() == -1);\n    runtime_assert(73i32.checked_div(47).unwrap() == 1);\n    runtime_assert(lhs.checked_div(-47).unwrap() == 1);\n    runtime_assert(lhs.checked_div(47).unwrap() == -1);\n}\n\nfn test_i32_checked_div_euclid() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_div_euclid(0).is_none());\n    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div_euclid(-1).is_none());\n    runtime_assert(i32::MAX.checked_div_euclid(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div_euclid(1).unwrap() == i32::MIN);\n    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);\n    runtime_assert(97i32.checked_div_euclid(-7).unwrap() == -13);\n    runtime_assert(97i32.checked_div_euclid(7).unwrap() == 13);\n    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 14);\n    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -14);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_div_euclid(-7).unwrap() == -6);\n    runtime_assert(47i32.checked_div_euclid(7).unwrap() == 6);\n    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 7);\n    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -7);\n    runtime_assert(47i32.checked_div_euclid(-2).unwrap() == -23);\n    runtime_assert(47i32.checked_div_euclid(2).unwrap() == 23);\n    runtime_assert(lhs.checked_div_euclid(-2).unwrap() == 24);\n    runtime_assert(lhs.checked_div_euclid(2).unwrap() == -24);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_div_euclid(-5).unwrap() == -14);\n    runtime_assert(73i32.checked_div_euclid(5).unwrap() == 14);\n    runtime_assert(lhs.checked_div_euclid(-5).unwrap() == 15);\n    runtime_assert(lhs.checked_div_euclid(5).unwrap() == -15);\n    runtime_assert(73i32.checked_div_euclid(-47).unwrap() == -1);\n    runtime_assert(73i32.checked_div_euclid(47).unwrap() == 1);\n    runtime_assert(lhs.checked_div_euclid(-47).unwrap() == 2);\n    runtime_assert(lhs.checked_div_euclid(47).unwrap() == -2);\n}\n\nfn test_i32_checked_rem() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_rem(0).is_none());\n    runtime_assert(lhs.checked_rem(1).unwrap() == 0);\n    runtime_assert(97i32.checked_rem(7).unwrap() == 6);\n    runtime_assert(97i32.checked_rem(-7).unwrap() == 6);\n    runtime_assert(lhs.checked_rem(7).unwrap() == -6);\n    runtime_assert(lhs.checked_rem(-7).unwrap() == -6);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_rem(-7).unwrap() == 5);\n    runtime_assert(47i32.checked_rem(7).unwrap() == 5);\n    runtime_assert(lhs.checked_rem(-7).unwrap() == -5);\n    runtime_assert(lhs.checked_rem(7).unwrap() == -5);\n    runtime_assert(47i32.checked_rem(-2).unwrap() == 1);\n    runtime_assert(47i32.checked_rem(2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem(-2).unwrap() == -1);\n    runtime_assert(lhs.checked_rem(2).unwrap() == -1);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_rem(-5).unwrap() == 3);\n    runtime_assert(73i32.checked_rem(5).unwrap() == 3);\n    runtime_assert(lhs.checked_rem(-5).unwrap() == -3);\n    runtime_assert(lhs.checked_rem(5).unwrap() == -3);\n    runtime_assert(73i32.checked_rem(-47).unwrap() == 26);\n    runtime_assert(73i32.checked_rem(47).unwrap() == 26);\n    runtime_assert(lhs.checked_rem(-47).unwrap() == -26);\n    runtime_assert(lhs.checked_rem(47).unwrap() == -26);\n}\n\nfn test_i32_checked_rem_euclid() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_rem_euclid(0).is_none());\n    runtime_assert(lhs.checked_rem_euclid(1).unwrap() == 0);\n    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 1);\n    runtime_assert(97i32.checked_rem_euclid(7).unwrap() == 6);\n    runtime_assert(97i32.checked_rem_euclid(-7).unwrap() == 6);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_rem_euclid(-7).unwrap() == 5);\n    runtime_assert(47i32.checked_rem_euclid(7).unwrap() == 5);\n    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 2);\n    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 2);\n    runtime_assert(47i32.checked_rem_euclid(-2).unwrap() == 1);\n    runtime_assert(47i32.checked_rem_euclid(2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(-2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(2).unwrap() == 1);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_rem_euclid(-5).unwrap() == 3);\n    runtime_assert(73i32.checked_rem_euclid(5).unwrap() == 3);\n    runtime_assert(lhs.checked_rem_euclid(-5).unwrap() == 2);\n    runtime_assert(lhs.checked_rem_euclid(5).unwrap() == 2);\n    runtime_assert(73i32.checked_rem_euclid(-47).unwrap() == 26);\n    runtime_assert(73i32.checked_rem_euclid(47).unwrap() == 26);\n    runtime_assert(lhs.checked_rem_euclid(-47).unwrap() == 21);\n    runtime_assert(lhs.checked_rem_euclid(47).unwrap() == 21);\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn test_u32_checked_add() {\n    runtime_assert(u32::MAX.checked_add(1).is_none());\n    runtime_assert((u32::MAX - 1).checked_add(1).unwrap() == u32::MAX);\n    runtime_assert(5u32.checked_add(10).unwrap() == 15);\n}\n\nfn test_u32_checked_add_signed() {\n    runtime_assert(1u32.checked_add_signed(-2).is_none());\n    runtime_assert(1u32.checked_add_signed(-1).unwrap() == 0);\n    runtime_assert(5u32.checked_add_signed(10).unwrap() == 15);\n}\n\nfn test_u32_checked_sub() {\n    runtime_assert(1u32.checked_sub(2).is_none());\n    runtime_assert(1u32.checked_sub(1).unwrap() == 0);\n    runtime_assert(u32::MAX.checked_sub(u32::MAX).unwrap() == 0);\n    runtime_assert(10u32.checked_sub(5).unwrap() == 5);\n}\n\nfn test_u32_checked_mul() {\n    runtime_assert(u32::MAX.checked_mul(2).is_none());\n    runtime_assert(u32::MAX.checked_mul(1).unwrap() == u32::MAX);\n    runtime_assert(u32::MAX.checked_mul(0).unwrap() == 0);\n    runtime_assert((u32::MAX / 2).checked_mul(4).is_none());\n    runtime_assert(5u32.checked_mul(10).unwrap() == 50);\n}\n\nfn test_u32_checked_div() {\n    runtime_assert(u32::MAX.checked_div(0).is_none());\n    runtime_assert(u32::MAX.checked_div(1).unwrap() == u32::MAX);\n    runtime_assert(10u32.checked_div(5).unwrap() == 2);\n}\n\nfn test_u32_checked_div_euclid() {\n    runtime_assert(u32::MAX.checked_div_euclid(0).is_none());\n    runtime_assert(u32::MAX.checked_div_euclid(1).unwrap() == u32::MAX);\n    runtime_assert(10u32.checked_div_euclid(5).unwrap() == 2);\n}\n\nfn test_u32_checked_rem() {\n    runtime_assert(u32::MAX.checked_rem(0).is_none());\n    runtime_assert(0u32.checked_rem(0).is_none());\n    runtime_assert(0u32.checked_rem(1).unwrap() == 0);\n    runtime_assert(7u32.checked_rem(2).unwrap() == 1);\n}\n\nfn test_u32_checked_rem_euclid() {\n    runtime_assert(u32::MAX.checked_rem_euclid(0).is_none());\n    runtime_assert(0u32.checked_rem_euclid(0).is_none());\n    runtime_assert(0u32.checked_rem_euclid(1).unwrap() == 0);\n    runtime_assert(7u32.checked_rem_euclid(2).unwrap() == 1);\n}\n\nfn test_i32_checked_add() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MAX.checked_add(1).is_none());\n    runtime_assert((i32::MAX - 2).checked_add(1).unwrap() == i32::MAX - 1);\n    runtime_assert(i32::MIN.checked_add(-1).is_none());\n    runtime_assert(i32::MIN.checked_add(1).unwrap() == i32::MIN + 1);\n    runtime_assert(neg_ten.checked_add(5).unwrap() == -5);\n    runtime_assert(10i32.checked_add(5).unwrap() == 15);\n    runtime_assert(10i32.checked_add(-5).unwrap() == 5);\n    runtime_assert(neg_ten.checked_add(-5).unwrap() == -15);\n}\n\nfn test_i32_checked_add_unsigned() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MAX.checked_add_unsigned(1).is_none());\n    runtime_assert((i32::MAX - 1).checked_add_unsigned(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_add_unsigned(10).unwrap() == i32::MIN + 10);\n    runtime_assert(i32::MIN.checked_add_unsigned(u32::MAX).unwrap() == i32::MAX);\n    runtime_assert(neg_ten.checked_add_unsigned(5).unwrap() == -5);\n}\n\nfn test_i32_checked_sub() {\n    runtime_assert((i32::MIN + 2).checked_sub(1).unwrap() == i32::MIN + 1);\n    runtime_assert((i32::MIN + 2).checked_sub(3).is_none());\n    runtime_assert(i32::MIN.checked_sub(i32::MIN).unwrap() == 0);\n    runtime_assert(i32::MIN.checked_sub(i32::MAX).is_none());\n    runtime_assert(0i32.checked_sub(i32::MIN).is_none());\n    runtime_assert(0i32.checked_sub(i32::MAX).unwrap() == i32::MIN + 1);\n}\n\nfn test_i32_checked_sub_unsigned() {\n    let neg_five: i32 = -5;\n    runtime_assert(i32::MIN.checked_sub_unsigned(1).is_none());\n    runtime_assert((i32::MIN + 1).checked_sub_unsigned(1).unwrap() == i32::MIN);\n    runtime_assert(0i32.checked_sub_unsigned(2147483647u32).unwrap() == i32::MIN + 1);\n    runtime_assert(neg_five.checked_sub_unsigned(5).unwrap() == -10);\n}\n\nfn test_i32_checked_mul() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MIN.checked_mul(1).unwrap() == i32::MIN);\n    runtime_assert(i32::MIN.checked_mul(-1).is_none());\n    runtime_assert(i32::MAX.checked_mul(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MAX.checked_mul(-1).unwrap() == i32::MIN + 1);\n    runtime_assert(i32::MAX.checked_mul(2).is_none());\n    runtime_assert(neg_ten.checked_mul(-5).unwrap() == 50);\n}\n\nfn test_i32_checked_div() {\n    let neg_ten: i32 = -10;\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_div(0).is_none());\n    runtime_assert(i32::MIN.checked_div(1).unwrap() == i32::MIN);\n    runtime_assert(i32::MAX.checked_div(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div(-1).is_none());\n    runtime_assert(i32::MAX.checked_div(-1).unwrap() == i32::MIN + 1);\n    runtime_assert(10i32.checked_div(-5).unwrap() == -2);\n    runtime_assert(10i32.checked_div(5).unwrap() == 2);\n    runtime_assert(neg_ten.checked_div(-5).unwrap() == 2);\n    runtime_assert(neg_ten.checked_div(5).unwrap() == -2);\n    runtime_assert(97i32.checked_div(-7).unwrap() == -13);\n    runtime_assert(97i32.checked_div(7).unwrap() == 13);\n    runtime_assert(lhs.checked_div(-7).unwrap() == 13);\n    runtime_assert(lhs.checked_div(7).unwrap() == -13);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_div(-7).unwrap() == -6);\n    runtime_assert(47i32.checked_div(7).unwrap() == 6);\n    runtime_assert(lhs.checked_div(-7).unwrap() == 6);\n    runtime_assert(lhs.checked_div(7).unwrap() == -6);\n    runtime_assert(47i32.checked_div(-2).unwrap() == -23);\n    runtime_assert(47i32.checked_div(2).unwrap() == 23);\n    runtime_assert(lhs.checked_div(-2).unwrap() == 23);\n    runtime_assert(lhs.checked_div(2).unwrap() == -23);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_div(-5).unwrap() == -14);\n    runtime_assert(73i32.checked_div(5).unwrap() == 14);\n    runtime_assert(lhs.checked_div(-5).unwrap() == 14);\n    runtime_assert(lhs.checked_div(5).unwrap() == -14);\n    runtime_assert(73i32.checked_div(-47).unwrap() == -1);\n    runtime_assert(73i32.checked_div(47).unwrap() == 1);\n    runtime_assert(lhs.checked_div(-47).unwrap() == 1);\n    runtime_assert(lhs.checked_div(47).unwrap() == -1);\n}\n\nfn test_i32_checked_div_euclid() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_div_euclid(0).is_none());\n    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div_euclid(-1).is_none());\n    runtime_assert(i32::MAX.checked_div_euclid(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div_euclid(1).unwrap() == i32::MIN);\n    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);\n    runtime_assert(97i32.checked_div_euclid(-7).unwrap() == -13);\n    runtime_assert(97i32.checked_div_euclid(7).unwrap() == 13);\n    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 14);\n    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -14);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_div_euclid(-7).unwrap() == -6);\n    runtime_assert(47i32.checked_div_euclid(7).unwrap() == 6);\n    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 7);\n    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -7);\n    runtime_assert(47i32.checked_div_euclid(-2).unwrap() == -23);\n    runtime_assert(47i32.checked_div_euclid(2).unwrap() == 23);\n    runtime_assert(lhs.checked_div_euclid(-2).unwrap() == 24);\n    runtime_assert(lhs.checked_div_euclid(2).unwrap() == -24);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_div_euclid(-5).unwrap() == -14);\n    runtime_assert(73i32.checked_div_euclid(5).unwrap() == 14);\n    runtime_assert(lhs.checked_div_euclid(-5).unwrap() == 15);\n    runtime_assert(lhs.checked_div_euclid(5).unwrap() == -15);\n    runtime_assert(73i32.checked_div_euclid(-47).unwrap() == -1);\n    runtime_assert(73i32.checked_div_euclid(47).unwrap() == 1);\n    runtime_assert(lhs.checked_div_euclid(-47).unwrap() == 2);\n    runtime_assert(lhs.checked_div_euclid(47).unwrap() == -2);\n}\n\nfn test_i32_checked_rem() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_rem(0).is_none());\n    runtime_assert(lhs.checked_rem(1).unwrap() == 0);\n    runtime_assert(97i32.checked_rem(7).unwrap() == 6);\n    runtime_assert(97i32.checked_rem(-7).unwrap() == 6);\n    runtime_assert(lhs.checked_rem(7).unwrap() == -6);\n    runtime_assert(lhs.checked_rem(-7).unwrap() == -6);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_rem(-7).unwrap() == 5);\n    runtime_assert(47i32.checked_rem(7).unwrap() == 5);\n    runtime_assert(lhs.checked_rem(-7).unwrap() == -5);\n    runtime_assert(lhs.checked_rem(7).unwrap() == -5);\n    runtime_assert(47i32.checked_rem(-2).unwrap() == 1);\n    runtime_assert(47i32.checked_rem(2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem(-2).unwrap() == -1);\n    runtime_assert(lhs.checked_rem(2).unwrap() == -1);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_rem(-5).unwrap() == 3);\n    runtime_assert(73i32.checked_rem(5).unwrap() == 3);\n    runtime_assert(lhs.checked_rem(-5).unwrap() == -3);\n    runtime_assert(lhs.checked_rem(5).unwrap() == -3);\n    runtime_assert(73i32.checked_rem(-47).unwrap() == 26);\n    runtime_assert(73i32.checked_rem(47).unwrap() == 26);\n    runtime_assert(lhs.checked_rem(-47).unwrap() == -26);\n    runtime_assert(lhs.checked_rem(47).unwrap() == -26);\n}\n\nfn test_i32_checked_rem_euclid() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_rem_euclid(0).is_none());\n    runtime_assert(lhs.checked_rem_euclid(1).unwrap() == 0);\n    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 1);\n    runtime_assert(97i32.checked_rem_euclid(7).unwrap() == 6);\n    runtime_assert(97i32.checked_rem_euclid(-7).unwrap() == 6);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_rem_euclid(-7).unwrap() == 5);\n    runtime_assert(47i32.checked_rem_euclid(7).unwrap() == 5);\n    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 2);\n    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 2);\n    runtime_assert(47i32.checked_rem_euclid(-2).unwrap() == 1);\n    runtime_assert(47i32.checked_rem_euclid(2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(-2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(2).unwrap() == 1);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_rem_euclid(-5).unwrap() == 3);\n    runtime_assert(73i32.checked_rem_euclid(5).unwrap() == 3);\n    runtime_assert(lhs.checked_rem_euclid(-5).unwrap() == 2);\n    runtime_assert(lhs.checked_rem_euclid(5).unwrap() == 2);\n    runtime_assert(73i32.checked_rem_euclid(-47).unwrap() == 26);\n    runtime_assert(73i32.checked_rem_euclid(47).unwrap() == 26);\n    runtime_assert(lhs.checked_rem_euclid(-47).unwrap() == 21);\n    runtime_assert(lhs.checked_rem_euclid(47).unwrap() == 21);\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/std_test/num.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1874, "minimize_time_ms": 311191, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 237, "minimized_LOC": 237, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::pervasive::runtime_assert", "vstd::prelude::"], "complexity_verus_tokens": 2, "has_meaningful_spec": false, "readability_score": 0.6499999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn test_u32_checked_add() {\n\n\nfn test_u32_checked_add_signed() {\n\n\nfn test_u32_checked_sub() {\n\n\nfn test_u32_checked_mul() {\n\n\nfn test_u32_checked_div() {\n\n\nfn test_u32_checked_div_euclid() {\n\n\nfn test_u32_checked_rem() {\n\n\nfn test_u32_checked_rem_euclid() {\n\n\nfn test_i32_checked_add() {\n\n\nfn test_i32_checked_add_unsigned() {\n\n\nfn test_i32_checked_sub() {\n\n\nfn test_i32_checked_sub_unsigned() {\n\n\nfn test_i32_checked_mul() {\n\n\nfn test_i32_checked_div() {\n\n\nfn test_i32_checked_div_euclid() {\n\n\nfn test_i32_checked_rem() {\n\n\nfn test_i32_checked_rem_euclid() {\n\n\nfn main() {"}}}, "all_snapshots": ["#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn test_u32_checked_add() {\n    runtime_assert(u32::MAX.checked_add(1).is_none());\n    runtime_assert((u32::MAX - 1).checked_add(1).unwrap() == u32::MAX);\n    runtime_assert(5u32.checked_add(10).unwrap() == 15);\n}\n\nfn test_u32_checked_add_signed() {\n    runtime_assert(1u32.checked_add_signed(-2).is_none());\n    runtime_assert(1u32.checked_add_signed(-1).unwrap() == 0);\n    runtime_assert(5u32.checked_add_signed(10).unwrap() == 15);\n}\n\nfn test_u32_checked_sub() {\n    runtime_assert(1u32.checked_sub(2).is_none());\n    runtime_assert(1u32.checked_sub(1).unwrap() == 0);\n    runtime_assert(u32::MAX.checked_sub(u32::MAX).unwrap() == 0);\n    runtime_assert(10u32.checked_sub(5).unwrap() == 5);\n}\n\nfn test_u32_checked_mul() {\n    runtime_assert(u32::MAX.checked_mul(2).is_none());\n    runtime_assert(u32::MAX.checked_mul(1).unwrap() == u32::MAX);\n    runtime_assert(u32::MAX.checked_mul(0).unwrap() == 0);\n    runtime_assert((u32::MAX / 2).checked_mul(4).is_none());\n    runtime_assert(5u32.checked_mul(10).unwrap() == 50);\n}\n\nfn test_u32_checked_div() {\n    runtime_assert(u32::MAX.checked_div(0).is_none());\n    runtime_assert(u32::MAX.checked_div(1).unwrap() == u32::MAX);\n    runtime_assert(10u32.checked_div(5).unwrap() == 2);\n}\n\nfn test_u32_checked_div_euclid() {\n    runtime_assert(u32::MAX.checked_div_euclid(0).is_none());\n    runtime_assert(u32::MAX.checked_div_euclid(1).unwrap() == u32::MAX);\n    runtime_assert(10u32.checked_div_euclid(5).unwrap() == 2);\n}\n\nfn test_u32_checked_rem() {\n    runtime_assert(u32::MAX.checked_rem(0).is_none());\n    runtime_assert(0u32.checked_rem(0).is_none());\n    runtime_assert(0u32.checked_rem(1).unwrap() == 0);\n    runtime_assert(7u32.checked_rem(2).unwrap() == 1);\n}\n\nfn test_u32_checked_rem_euclid() {\n    runtime_assert(u32::MAX.checked_rem_euclid(0).is_none());\n    runtime_assert(0u32.checked_rem_euclid(0).is_none());\n    runtime_assert(0u32.checked_rem_euclid(1).unwrap() == 0);\n    runtime_assert(7u32.checked_rem_euclid(2).unwrap() == 1);\n}\n\nfn test_i32_checked_add() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MAX.checked_add(1).is_none());\n    runtime_assert((i32::MAX - 2).checked_add(1).unwrap() == i32::MAX - 1);\n    runtime_assert(i32::MIN.checked_add(-1).is_none());\n    runtime_assert(i32::MIN.checked_add(1).unwrap() == i32::MIN + 1);\n    runtime_assert(neg_ten.checked_add(5).unwrap() == -5);\n    runtime_assert(10i32.checked_add(5).unwrap() == 15);\n    runtime_assert(10i32.checked_add(-5).unwrap() == 5);\n    runtime_assert(neg_ten.checked_add(-5).unwrap() == -15);\n}\n\nfn test_i32_checked_add_unsigned() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MAX.checked_add_unsigned(1).is_none());\n    runtime_assert((i32::MAX - 1).checked_add_unsigned(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_add_unsigned(10).unwrap() == i32::MIN + 10);\n    runtime_assert(i32::MIN.checked_add_unsigned(u32::MAX).unwrap() == i32::MAX);\n    runtime_assert(neg_ten.checked_add_unsigned(5).unwrap() == -5);\n}\n\nfn test_i32_checked_sub() {\n    runtime_assert((i32::MIN + 2).checked_sub(1).unwrap() == i32::MIN + 1);\n    runtime_assert((i32::MIN + 2).checked_sub(3).is_none());\n    runtime_assert(i32::MIN.checked_sub(i32::MIN).unwrap() == 0);\n    runtime_assert(i32::MIN.checked_sub(i32::MAX).is_none());\n    runtime_assert(0i32.checked_sub(i32::MIN).is_none());\n    runtime_assert(0i32.checked_sub(i32::MAX).unwrap() == i32::MIN + 1);\n}\n\nfn test_i32_checked_sub_unsigned() {\n    let neg_five: i32 = -5;\n    runtime_assert(i32::MIN.checked_sub_unsigned(1).is_none());\n    runtime_assert((i32::MIN + 1).checked_sub_unsigned(1).unwrap() == i32::MIN);\n    runtime_assert(0i32.checked_sub_unsigned(2147483647u32).unwrap() == i32::MIN + 1);\n    runtime_assert(neg_five.checked_sub_unsigned(5).unwrap() == -10);\n}\n\nfn test_i32_checked_mul() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MIN.checked_mul(1).unwrap() == i32::MIN);\n    runtime_assert(i32::MIN.checked_mul(-1).is_none());\n    runtime_assert(i32::MAX.checked_mul(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MAX.checked_mul(-1).unwrap() == i32::MIN + 1);\n    runtime_assert(i32::MAX.checked_mul(2).is_none());\n    runtime_assert(neg_ten.checked_mul(-5).unwrap() == 50);\n}\n\nfn test_i32_checked_div() {\n    let neg_ten: i32 = -10;\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_div(0).is_none());\n    runtime_assert(i32::MIN.checked_div(1).unwrap() == i32::MIN);\n    runtime_assert(i32::MAX.checked_div(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div(-1).is_none());\n    runtime_assert(i32::MAX.checked_div(-1).unwrap() == i32::MIN + 1);\n    runtime_assert(10i32.checked_div(-5).unwrap() == -2);\n    runtime_assert(10i32.checked_div(5).unwrap() == 2);\n    runtime_assert(neg_ten.checked_div(-5).unwrap() == 2);\n    runtime_assert(neg_ten.checked_div(5).unwrap() == -2);\n    runtime_assert(97i32.checked_div(-7).unwrap() == -13);\n    runtime_assert(97i32.checked_div(7).unwrap() == 13);\n    runtime_assert(lhs.checked_div(-7).unwrap() == 13);\n    runtime_assert(lhs.checked_div(7).unwrap() == -13);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_div(-7).unwrap() == -6);\n    runtime_assert(47i32.checked_div(7).unwrap() == 6);\n    runtime_assert(lhs.checked_div(-7).unwrap() == 6);\n    runtime_assert(lhs.checked_div(7).unwrap() == -6);\n    runtime_assert(47i32.checked_div(-2).unwrap() == -23);\n    runtime_assert(47i32.checked_div(2).unwrap() == 23);\n    runtime_assert(lhs.checked_div(-2).unwrap() == 23);\n    runtime_assert(lhs.checked_div(2).unwrap() == -23);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_div(-5).unwrap() == -14);\n    runtime_assert(73i32.checked_div(5).unwrap() == 14);\n    runtime_assert(lhs.checked_div(-5).unwrap() == 14);\n    runtime_assert(lhs.checked_div(5).unwrap() == -14);\n    runtime_assert(73i32.checked_div(-47).unwrap() == -1);\n    runtime_assert(73i32.checked_div(47).unwrap() == 1);\n    runtime_assert(lhs.checked_div(-47).unwrap() == 1);\n    runtime_assert(lhs.checked_div(47).unwrap() == -1);\n}\n\nfn test_i32_checked_div_euclid() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_div_euclid(0).is_none());\n    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div_euclid(-1).is_none());\n    runtime_assert(i32::MAX.checked_div_euclid(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div_euclid(1).unwrap() == i32::MIN);\n    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);\n    runtime_assert(97i32.checked_div_euclid(-7).unwrap() == -13);\n    runtime_assert(97i32.checked_div_euclid(7).unwrap() == 13);\n    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 14);\n    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -14);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_div_euclid(-7).unwrap() == -6);\n    runtime_assert(47i32.checked_div_euclid(7).unwrap() == 6);\n    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 7);\n    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -7);\n    runtime_assert(47i32.checked_div_euclid(-2).unwrap() == -23);\n    runtime_assert(47i32.checked_div_euclid(2).unwrap() == 23);\n    runtime_assert(lhs.checked_div_euclid(-2).unwrap() == 24);\n    runtime_assert(lhs.checked_div_euclid(2).unwrap() == -24);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_div_euclid(-5).unwrap() == -14);\n    runtime_assert(73i32.checked_div_euclid(5).unwrap() == 14);\n    runtime_assert(lhs.checked_div_euclid(-5).unwrap() == 15);\n    runtime_assert(lhs.checked_div_euclid(5).unwrap() == -15);\n    runtime_assert(73i32.checked_div_euclid(-47).unwrap() == -1);\n    runtime_assert(73i32.checked_div_euclid(47).unwrap() == 1);\n    runtime_assert(lhs.checked_div_euclid(-47).unwrap() == 2);\n    runtime_assert(lhs.checked_div_euclid(47).unwrap() == -2);\n}\n\nfn test_i32_checked_rem() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_rem(0).is_none());\n    runtime_assert(lhs.checked_rem(1).unwrap() == 0);\n    runtime_assert(97i32.checked_rem(7).unwrap() == 6);\n    runtime_assert(97i32.checked_rem(-7).unwrap() == 6);\n    runtime_assert(lhs.checked_rem(7).unwrap() == -6);\n    runtime_assert(lhs.checked_rem(-7).unwrap() == -6);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_rem(-7).unwrap() == 5);\n    runtime_assert(47i32.checked_rem(7).unwrap() == 5);\n    runtime_assert(lhs.checked_rem(-7).unwrap() == -5);\n    runtime_assert(lhs.checked_rem(7).unwrap() == -5);\n    runtime_assert(47i32.checked_rem(-2).unwrap() == 1);\n    runtime_assert(47i32.checked_rem(2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem(-2).unwrap() == -1);\n    runtime_assert(lhs.checked_rem(2).unwrap() == -1);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_rem(-5).unwrap() == 3);\n    runtime_assert(73i32.checked_rem(5).unwrap() == 3);\n    runtime_assert(lhs.checked_rem(-5).unwrap() == -3);\n    runtime_assert(lhs.checked_rem(5).unwrap() == -3);\n    runtime_assert(73i32.checked_rem(-47).unwrap() == 26);\n    runtime_assert(73i32.checked_rem(47).unwrap() == 26);\n    runtime_assert(lhs.checked_rem(-47).unwrap() == -26);\n    runtime_assert(lhs.checked_rem(47).unwrap() == -26);\n}\n\nfn test_i32_checked_rem_euclid() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_rem_euclid(0).is_none());\n    runtime_assert(lhs.checked_rem_euclid(1).unwrap() == 0);\n    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 1);\n    runtime_assert(97i32.checked_rem_euclid(7).unwrap() == 6);\n    runtime_assert(97i32.checked_rem_euclid(-7).unwrap() == 6);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_rem_euclid(-7).unwrap() == 5);\n    runtime_assert(47i32.checked_rem_euclid(7).unwrap() == 5);\n    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 2);\n    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 2);\n    runtime_assert(47i32.checked_rem_euclid(-2).unwrap() == 1);\n    runtime_assert(47i32.checked_rem_euclid(2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(-2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(2).unwrap() == 1);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_rem_euclid(-5).unwrap() == 3);\n    runtime_assert(73i32.checked_rem_euclid(5).unwrap() == 3);\n    runtime_assert(lhs.checked_rem_euclid(-5).unwrap() == 2);\n    runtime_assert(lhs.checked_rem_euclid(5).unwrap() == 2);\n    runtime_assert(73i32.checked_rem_euclid(-47).unwrap() == 26);\n    runtime_assert(73i32.checked_rem_euclid(47).unwrap() == 26);\n    runtime_assert(lhs.checked_rem_euclid(-47).unwrap() == 21);\n    runtime_assert(lhs.checked_rem_euclid(47).unwrap() == 21);\n}\n\nfn main() {\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "  use vstd::prelude::*;\n        verus! {\n       fn main() {\n      }\n       }\n", "  use vstd::prelude::*;\n        verus! {\n       fn main() ;\n       }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n"]}
{"id": "option_test_cc0b9f7d", "original_code": "use std::option::Option::{None, Some};\n\nuse vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_some_test() {\n    let a: Option<i32> = None;\n    let b = Some(2);\n    runtime_assert(!a.is_some());\n    runtime_assert(b.is_some());\n}\n\nfn is_none_test() {\n    let a: Option<i32> = None;\n    let b = Some(2);\n    runtime_assert(a.is_none());\n    runtime_assert(!b.is_none());\n}\n\nfn as_ref_test() {\n    let a = Option::Some(2);\n    if let Some(ref_val) = a.as_ref() {\n        runtime_assert(*ref_val == 2);\n    } else {\n        runtime_assert(false);\n    }\n}\n\nfn unwrap_test() {\n    let a = Option::Some(2);\n    let b = Option::Some(4);\n    runtime_assert(a.unwrap() == 2);\n    runtime_assert(a.unwrap() != b.unwrap());\n}\n\nfn expect_test() {\n    let a = Option::Some(2);\n    let b = Option::Some(4);\n    runtime_assert(a.expect(\"is some\") == 2);\n    runtime_assert(a.expect(\"is some\") != b.expect(\"is some\"));\n}\n\nfn unwrap_or_test() {\n    let a = Option::Some(2);\n    let b = Option::None;\n    runtime_assert(a.unwrap_or(3) == 2);\n    runtime_assert(b.unwrap_or(3) == 3);\n}\n\nfn ok_or_test() {\n    let a: Option<i32> = Option::Some(2);\n    let b: Option<i32> = Option::None;\n    let ra: Result<i32, bool> = a.ok_or(false);\n    let rb: Result<i32, bool> = b.ok_or(false);\n    assert(ra.is_ok());\n    assert(ra.unwrap() == 2);\n    assert(rb.is_err());\n    assert(rb.unwrap_err() == false);\n}\n\n} // verus!\n", "minimized_code": "use std::option::Option::{None, Some};\n\nuse vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_some_test() {\n    let a: Option<i32> = None;\n    let b = Some(2);\n    runtime_assert(!a.is_some());\n    runtime_assert(b.is_some());\n}\n\nfn is_none_test() {\n    let a: Option<i32> = None;\n    let b = Some(2);\n    runtime_assert(a.is_none());\n    runtime_assert(!b.is_none());\n}\n\nfn as_ref_test() {\n    let a = Option::Some(2);\n    if let Some(ref_val) = a.as_ref() {\n        runtime_assert(*ref_val == 2);\n    } else {\n        runtime_assert(false);\n    }\n}\n\nfn unwrap_test() {\n    let a = Option::Some(2);\n    let b = Option::Some(4);\n    runtime_assert(a.unwrap() == 2);\n    runtime_assert(a.unwrap() != b.unwrap());\n}\n\nfn expect_test() {\n    let a = Option::Some(2);\n    let b = Option::Some(4);\n    runtime_assert(a.expect(\"is some\") == 2);\n    runtime_assert(a.expect(\"is some\") != b.expect(\"is some\"));\n}\n\nfn unwrap_or_test() {\n    let a = Option::Some(2);\n    let b = Option::None;\n    runtime_assert(a.unwrap_or(3) == 2);\n    runtime_assert(b.unwrap_or(3) == 3);\n}\n\nfn ok_or_test() {\n    let a: Option<i32> = Option::Some(2);\n    let b: Option<i32> = Option::None;\n    let ra: Result<i32, bool> = a.ok_or(false);\n    let rb: Result<i32, bool> = b.ok_or(false);\n    assert(ra.is_ok());\n    assert(ra.unwrap() == 2);\n    assert(rb.is_err());\n    assert(rb.unwrap_err() == false);\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/std_test/option_test.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1199, "minimize_time_ms": 971, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["std::option::Option::", "vstd::pervasive::runtime_assert", "vstd::prelude::"], "complexity_verus_tokens": 2, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn is_some_test() {\n\n\nfn is_none_test() {\n\n\nfn as_ref_test() {\n\n\nfn unwrap_test() {\n\n\nfn expect_test() {\n\n\nfn unwrap_or_test() {\n\n\nfn ok_or_test() {"}}}, "all_snapshots": []}
{"id": "result_cc0b9f7d", "original_code": "use vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.is_ok() == true);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.is_ok() == false);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.is_ok() == false);\n}\n\nfn map_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    let op = |x: i32| -> (y: i32)\n        requires\n            x < 100000,\n        ensures\n            y > x,\n        { x + 1 };\n    let r2 = r1.map(op);\n    runtime_assert(r2.unwrap() > 7);\n    let r3: Result<i32, i32> = Err(9);\n    let r4: Result<i32, i32> = r3.map(op);\n    runtime_assert(r4.unwrap_err() == 9);\n}\n\nfn ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().unwrap() == 7);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.ok().is_none());\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.ok().is_none());\n    let r4: Result<bool, i32> = Ok(false);\n    runtime_assert(r4.ok().is_some());\n    runtime_assert(r4.ok().unwrap() == false);\n}\n\nfn err_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.err().is_none());\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.err().is_some());\n    runtime_assert(r2.err().unwrap() == 7);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.err().is_some());\n    runtime_assert(r3.err().unwrap() == true);\n    let r4: Result<bool, i32> = Ok(true);\n    runtime_assert(r4.err().is_none());\n}\n\nfn expect_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().expect(\"is ok\") == 7);\n    let r2: Result<bool, i32> = Ok(false);\n    runtime_assert(r2.ok().is_some());\n    runtime_assert(r2.ok().expect(\"is ok\") == false);\n}\n\n} // verus!\n", "minimized_code": "use vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.is_ok() == true);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.is_ok() == false);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.is_ok() == false);\n}\n\nfn map_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    let op = |x: i32| -> (y: i32)\n        requires\n            x < 100000,\n        ensures\n            y > x,\n        { x + 1 };\n    let r2 = r1.map(op);\n    runtime_assert(r2.unwrap() > 7);\n    let r3: Result<i32, i32> = Err(9);\n    let r4: Result<i32, i32> = r3.map(op);\n    runtime_assert(r4.unwrap_err() == 9);\n}\n\nfn ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().unwrap() == 7);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.ok().is_none());\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.ok().is_none());\n    let r4: Result<bool, i32> = Ok(false);\n    runtime_assert(r4.ok().is_some());\n    runtime_assert(r4.ok().unwrap() == false);\n}\n\nfn err_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.err().is_none());\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.err().is_some());\n    runtime_assert(r2.err().unwrap() == 7);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.err().is_some());\n    runtime_assert(r3.err().unwrap() == true);\n    let r4: Result<bool, i32> = Ok(true);\n    runtime_assert(r4.err().is_none());\n}\n\nfn expect_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().expect(\"is ok\") == 7);\n    let r2: Result<bool, i32> = Ok(false);\n    runtime_assert(r2.ok().is_some());\n    runtime_assert(r2.ok().expect(\"is ok\") == false);\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/std_test/result.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1258, "minimize_time_ms": 954, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 65, "minimized_LOC": 65, "self_contained": true, "dependencies": ["vstd::pervasive::runtime_assert", "vstd::prelude::"], "complexity_verus_tokens": 4, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn is_ok_test() {\n\n\nfn map_test() {\n\n\nfn ok_test() {\n\n\nfn err_test() {\n\n\nfn expect_test() {", "spec": "        requires\n\n        ensures"}}}, "all_snapshots": []}
{"id": "vecdeque_test_cc0b9f7d", "original_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse std::collections::VecDeque;\nuse vstd::pervasive::runtime_assert;\n#[allow(unused_imports)]\nuse vstd::std_specs::vecdeque::*;\nuse vstd::prelude::*;\n\nverus! {\n\nfn vec_deque_test()\n{\n    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();\n    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();\n    v1.push_back(3);\n    v1.push_back(4);\n    let front = v1.pop_front();\n    runtime_assert(front.is_some());\n    runtime_assert(front.unwrap() == 3);\n    assert(v1@ == seq![4u32]);\n\n    v2.push_back(5);\n    assert(v2.len() == 1);\n    v2.push_back(7);\n    assert(v2@.len() == 2);\n    v2.insert(1, 6);\n    assert(v2@ == seq![5u32, 6u32, 7u32]);\n\n    v1.append(&mut v2);\n    assert(v2@.len() == 0);\n    assert(v1@.len() == 4);\n    assert(v1@ == seq![4u32, 5u32, 6u32, 7u32]);\n    v1.remove(2);\n    assert(v1@ == seq![4u32, 5u32, 7u32]);\n    \n    let mut x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 4);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 5);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 7);\n    x = v1.pop_front();\n    runtime_assert(x.is_none());\n\n    v1.push_back(10);\n    v1.push_back(11);\n    assert(v1@ == seq![10u32, 11u32]);\n\n    let mut i: usize = 0;\n    for x in it: v1.iter()\n        invariant\n            i == it.pos,\n            it.elements == seq![10u32, 11u32],\n    {\n        assert(x > 9);\n        assert(x < 12);\n        i = i + 1;\n    }\n}\n\n} // verus!\n", "minimized_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse std::collections::VecDeque;\nuse vstd::pervasive::runtime_assert;\n#[allow(unused_imports)]\nuse vstd::std_specs::vecdeque::*;\nuse vstd::prelude::*;\n\nverus! {\n\nfn vec_deque_test()\n{\n    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();\n    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();\n    v1.push_back(3);\n    v1.push_back(4);\n    let front = v1.pop_front();\n    runtime_assert(front.is_some());\n    runtime_assert(front.unwrap() == 3);\n    assert(v1@ == seq![4u32]);\n\n    v2.push_back(5);\n    assert(v2.len() == 1);\n    v2.push_back(7);\n    assert(v2@.len() == 2);\n    v2.insert(1, 6);\n    assert(v2@ == seq![5u32, 6u32, 7u32]);\n\n    v1.append(&mut v2);\n    assert(v2@.len() == 0);\n    assert(v1@.len() == 4);\n    assert(v1@ == seq![4u32, 5u32, 6u32, 7u32]);\n    v1.remove(2);\n    assert(v1@ == seq![4u32, 5u32, 7u32]);\n    \n    let mut x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 4);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 5);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 7);\n    x = v1.pop_front();\n    runtime_assert(x.is_none());\n\n    v1.push_back(10);\n    v1.push_back(11);\n    assert(v1@ == seq![10u32, 11u32]);\n\n    let mut i: usize = 0;\n    for x in it: v1.iter()\n        invariant\n            i == it.pos,\n            it.elements == seq![10u32, 11u32],\n    {\n        assert(x > 9);\n        assert(x < 12);\n        i = i + 1;\n    }\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/std_test/vecdeque_test.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1806, "minimize_time_ms": 1060, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["std::collections::VecDeque", "vstd::pervasive::runtime_assert", "vstd::std_specs::vecdeque::", "vstd::prelude::"], "complexity_verus_tokens": 7, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn vec_deque_test()\n{", "spec": "        invariant"}}}, "all_snapshots": []}
{"id": "chapter-1-22_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/summer_school/chapter-1-22.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1691, "minimize_time_ms": 3600025, "minimum_verifiable": true, "minimized_status": "failed"}, "quality": {"original_LOC": 240, "minimized_LOC": 240, "self_contained": false, "dependencies": ["prelude::", "seq::", "vstd::prelude::", "vstd::"], "complexity_verus_tokens": 29, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "requires_count": 1, "ensures_count": 1, "segments": {"exec": "\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n\n\nfn main() {", "spec": "spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n\nspec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n\n        decreases self,\n\n        decreases self,\n\n    requires\n\n    ensures\n\n    decreases tree  // guessed by Dafny ,\n\n    ensures\n\n    decreases tree,\n\n    requires\n\n    ensures\n\n    decreases tree,\n\n                    //                        requires(idx < tree@.len());\n\n                    //                        ensures(tree@.index(idx) != needle);", "proof": "proof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n\nproof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n\nproof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n\nproof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n\nproof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }"}}}, "all_snapshots": []}
{"id": "chapter-2-3_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{\n    if input.len() == 0 {\n        //assert(output == Multiset::empty());\n        assert(multiset_matches_seq(input, output));\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n        assert(multiset_matches_seq(input, output));\n        // show there's no other multiset that'll work.\n        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));\n        output\n        */\n        assume(false);\n        assert(multiset_matches_seq(input, output));\n        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n    assume(false);\n    input  // TODO(jonh): haven't actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{\n    if input.len() == 0 {\n        //assert(output == Multiset::empty());\n        assert(multiset_matches_seq(input, output));\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n        assert(multiset_matches_seq(input, output));\n        // show there's no other multiset that'll work.\n        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));\n        output\n        */\n        assume(false);\n        assert(multiset_matches_seq(input, output));\n        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n    assume(false);\n    input  // TODO(jonh): haven't actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/summer_school/chapter-2-3.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 989, "minimize_time_ms": 122981, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 110, "minimized_LOC": 110, "self_contained": false, "dependencies": ["multiset::", "prelude::", "seq::", "set::", "vstd::prelude::", "vstd::"], "complexity_verus_tokens": 18, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n\n\nfn main() {", "spec": "spec fn is_sorted(seqint: Seq<int>) -> bool {\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n\n    decreases a.len(),\n\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n\n    requires\n\n    ensures\n\n    ensures", "proof": "proof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{\n    if input.len() == 0 {\n        //assert(output == Multiset::empty());\n        assert(multiset_matches_seq(input, output));\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n        assert(multiset_matches_seq(input, output));\n        // show there's no other multiset that'll work.\n        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));\n        output\n        */\n        assume(false);\n        assert(multiset_matches_seq(input, output));\n        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n    assume(false);\n    input  // TODO(jonh): haven't actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "use vstd::prelude::*;\nverus !{ fn main(); }\n", "  use vstd::prelude::*;\n        verus! {\n       fn main() ;\n       }\n"]}
{"id": "chapter-6-1_cc0b9f7d", "original_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nverus! {\n\n#[verifier::external_body]  /* vattr */\npub struct Key {}\n\n#[verifier::external_body]  /* vattr */\npub struct Value {}\n\n#[verifier::external_body]  /* vattr */\n#[verifier::spec]\npub fn default() -> Value {\n    unimplemented!()\n}\n\nstate_machine!{\n    MapSpec {\n        fields {\n            pub map: Map<Key, Value>,\n        }\n\n        init!{\n            empty() {\n                init map = Map::total(|k| default());\n            }\n        }\n\n        transition!{\n            insert_op(key: Key, value: Value) {\n                update map = pre.map.insert(key, value);\n            }\n        }\n\n        transition!{\n            query_op(key: Key, value: Value) {\n                require(pre.map.contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            noop() {\n            }\n        }\n    }\n}\n\nstate_machine!{\n    ShardedKVProtocol {\n        fields {\n            // TODO have a way to annotate this as a constant outside of tokenized mode\n            pub map_count: int,\n\n            pub maps: Seq<Map<Key, Value>>,\n        }\n\n        init!{\n            initialize(map_count: int) {\n                require(0 < map_count);\n                init map_count = map_count;\n                init maps = Seq::new(map_count as nat, |i| {\n                    if i == 0 {\n                        Map::total(|k| default())\n                    } else {\n                        Map::empty()\n                    }\n                });\n            }\n        }\n\n        pub open spec fn valid_host(&self, i: int) -> bool {\n            0 <= i < self.map_count\n        }\n\n        transition!{\n            insert(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).dom().contains(key));\n                update maps[idx][key] = value;\n            }\n        }\n\n        transition!{\n            query(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {\n                require(pre.valid_host(send_idx));\n                require(pre.valid_host(recv_idx));\n                require(pre.maps.index(send_idx).contains_pair(key, value));\n                require(send_idx != recv_idx);\n                update maps[send_idx] = pre.maps.index(send_idx).remove(key);\n                update maps[recv_idx][key] = value;\n            }\n        }\n\n        pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n            self.valid_host(hostidx)\n            && self.maps.index(hostidx).dom().contains(key)\n        }\n\n        pub open spec fn key_holder(&self, key: Key) -> int {\n            choose|idx| self.host_has_key(idx, key)\n        }\n\n        pub open spec fn abstraction_one_key(&self, key: Key) -> Value {\n            if exists |idx| self.host_has_key(idx, key) {\n                self.maps.index(self.key_holder(key)).index(key)\n            } else {\n                default()\n            }\n        }\n\n        pub open spec fn interp_map(&self) -> Map<Key, Value> {\n            Map::total(|key| self.abstraction_one_key(key))\n        }\n\n        #[invariant]\n        pub open fn num_hosts(&self) -> bool {\n            self.maps.len() == self.map_count\n        }\n\n        #[invariant]\n        pub open fn inv_no_dupes(&self) -> bool {\n            forall |i: int, j: int, key: Key|\n                self.host_has_key(i, key) && self.host_has_key(j, key) ==> i == j\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, map_count: int) {\n        }\n\n        #[inductive(insert)]\n        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n            //assert(forall(|k: Key| pre.host_has_key(idx, k) ==> post.host_has_key(idx, k)));\n            //assert(forall(|k: Key| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k)));\n            //assert(forall(|k: Key| pre.host_has_key(idx, k) == post.host_has_key(idx, k)));\n            assert(forall |i: int, k: Key| pre.host_has_key(i, k) == post.host_has_key(i, k));\n        }\n\n        #[inductive(query)]\n        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) { }\n\n        #[inductive(transfer)]\n        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n            assert(forall |i: int, k: Key| !equal(k, key) ==> pre.host_has_key(i, k) == post.host_has_key(i, k));\n            assert(forall |i: int| i != send_idx && i != recv_idx ==> pre.host_has_key(i, key) == post.host_has_key(i, key));\n\n            assert(equal(post.maps.index(send_idx),\n                pre.maps.index(send_idx).remove(key)));\n\n            assert(!post.host_has_key(send_idx, key));\n            assert(pre.host_has_key(send_idx, key));\n\n            /*assert_forall_by(|i: int, j: int, k: Key| {\n                requires(post.host_has_key(i, k) && post.host_has_key(j, k));\n                ensures(i == j);\n                if equal(k, key) {\n                    assert(i != send_idx);\n                    assert(j != send_idx);\n                    if i != recv_idx {\n                        assert(pre.host_has_key(i, key));\n                    }\n                    if i != recv_idx && j != recv_idx {\n                        assert(pre.host_has_key(i, key));\n                        assert(pre.host_has_key(j, key));\n                        assert(pre.inv_no_dupes());\n                        assert(i == j);\n                    }\n                    assert(i == j);\n                } else {\n                    assert(i == j);\n                }\n            });*/\n        }\n    }\n}\n\nspec fn interp(a: ShardedKVProtocol::State) -> MapSpec::State {\n    MapSpec::State { map: a.interp_map() }\n}\n\nproof fn next_refines_next_with_macro(pre: ShardedKVProtocol::State, post: ShardedKVProtocol::State)\n    requires\n        pre.invariant(),\n        post.invariant(),\n        interp(pre).invariant(),\n        ShardedKVProtocol::State::next(pre, post),\n    ensures\n        MapSpec::State::next(interp(pre), interp(post)),\n{\n    case_on_next!{pre, post, ShardedKVProtocol => {\n        insert(idx, key, value) => {\n            assert_maps_equal!(pre.interp_map().insert(key, value), post.interp_map(), k => {\n                if equal(k, key) {\n                    assert(pre.host_has_key(idx, key));\n                    assert(post.host_has_key(idx, key));\n                } else {\n                    assert(pre.interp_map().dom().contains(k));\n                    assert(post.interp_map().dom().contains(k));\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n                        assert(pre.host_has_key(i, k));\n                        assert(post.host_has_key(i, k));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));\n                    } else {\n                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));\n                        /*assert(forall |idx| !post.host_has_key(idx, k));\n                        assert(!exists(|idx| post.host_has_key(idx, k)));\n                        assert(equal(pre.abstraction_one_key(k), default()));\n                        assert(equal(post.abstraction_one_key(k), default()));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));*/\n                    }\n\n                    /*assert(pre.interp_map().dom().contains(k) ==>\n                        post.interp_map().dom().contains(k)\n                        && equal(pre.interp_map().index(k), post.interp_map().index(k))\n                    );\n                    assert(post.interp_map().dom().contains(k) ==>\n                        pre.interp_map().dom().contains(k));*/\n                }\n            });\n            MapSpec::show::insert_op(interp(pre), interp(post), key, value);\n        }\n        query(idx, key, value) => {\n            //assert(interp(pre).map =~= interp(post).map);\n            //assert(equal(interp(pre).map, interp(post).map));\n\n            //assert(equal(Map::total(|key| pre.abstraction_one_key(key)).dom(),\n            //    Set::empty().complement()));\n            //assert(equal(pre.interp_map(),\n            //    Map::total(|key| pre.abstraction_one_key(key))));\n            //assert(equal(pre.interp_map().dom(), Set::empty().complement()));\n\n            //assert(equal(interp(pre).map.dom(), Set::empty().complement()));\n            //assert(interp(pre).map.dom().contains(key));\n            //assert(equal(interp(pre).map.index(key),\n            //    pre.abstraction_one_key(key)));\n\n            assert(pre.host_has_key(idx, key));\n            //assert(pre.host_has_key(pre.key_holder(key), key));\n            //assert(equal(pre.key_holder(key), idx));\n\n            //assert(equal(pre.abstraction_one_key(key), value));\n            //assert(equal(interp(pre).map.index(key), value));\n            MapSpec::show::query_op(interp(pre), interp(post), key, value);\n        }\n        transfer(send_idx, recv_idx, key, value) => {\n            assert_maps_equal!(pre.interp_map(), post.interp_map(), k: Key => {\n                if equal(k, key) {\n                    assert(pre.host_has_key(send_idx, key));\n                    assert(post.host_has_key(recv_idx, key));\n                } else {\n                    assert(pre.interp_map().dom().contains(k));\n                    assert(post.interp_map().dom().contains(k));\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n                        assert(pre.host_has_key(i, k));\n                        assert(post.host_has_key(i, k));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));\n                    } else {\n                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));\n                    }\n                }\n            });\n            MapSpec::show::noop(interp(pre), interp(post));\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: ShardedKVProtocol::State)\n    requires\n        post.invariant() && ShardedKVProtocol::State::init(post),\n    ensures\n        MapSpec::State::init(interp(post)),\n{\n    case_on_init!{post, ShardedKVProtocol => {\n        initialize(n) => {\n            assert_maps_equal!(interp(post).map, Map::total(|k| default()), k: Key => {\n                assert(interp(post).map.dom().contains(k));\n                assert(equal(interp(post).map.index(k), default()));\n            });\n\n            MapSpec::show::empty(interp(post));\n        }\n    }}\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\n     use verus_builtin_macros::*;\n     use vstd::map::*;\n     use vstd::seq::*;\n     use verus_state_machines_macros::state_machine;\n     verus! {\n     pub struct Key {\n  }\n     pub struct Value {\n  }\n#[verifier::external_body]  \n#[verifier::spec]\npub fn default() -> Value {\n       unimplemented!() }\n    state_machine!{\n       ShardedKVProtocol {\n          fields {\n             pub map_count: int,             pub maps: Seq<Map<Key, Value>>,         }\n          init!{\n             initialize(map_count: int) {                 require(0 < map_count);                 init map_count = map_count;                 init maps = Seq::new(map_count as nat, |i| {                     if i == 0 {                         Map::total(|k| default())                     } else {                         Map::empty()                     }                 });             }\n         }\n          pub open spec fn valid_host(&self, i: int) -> bool {\n             0 <= i < self.map_count         }\n          transition!{\n             insert(idx: int, key: Key, value: Value) {                 require(pre.valid_host(idx));                 require(pre.maps.index(idx).dom().contains(key));                 update maps[idx][key] = value;             }\n         }\n          transition!{\n             query(idx: int, key: Key, value: Value) {                 require(pre.valid_host(idx));                 require(pre.maps.index(idx).contains_pair(key, value));             }\n         }\n          transition!{\n             transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {                 require(pre.valid_host(send_idx));                 require(pre.valid_host(recv_idx));                 require(pre.maps.index(send_idx).contains_pair(key, value));                 require(send_idx != recv_idx);                 update maps[send_idx] = pre.maps.index(send_idx).remove(key);                 update maps[recv_idx][key] = value;             }\n         }\n          pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n             self.valid_host(hostidx)             && self.maps.index(hostidx).dom().contains(key)         }\n#[invariant]\n        pub open fn num_hosts(&self) -> bool {\n             self.maps.len() == self.map_count         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, map_count: int) {\n         }\n#[inductive(insert)]\n        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n         }\n#[inductive(query)]\n        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n }\n#[inductive(transfer)]\n        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n         }\n      }\n   }\n    fn main() {\n   }\n    }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/summer_school/chapter-6-1.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 1094, "minimize_time_ms": 247842, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 308, "minimized_LOC": 54, "self_contained": false, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::map::", "vstd::seq::", "vstd::set::", "vstd::", "verus_state_machines_macros::case_on_init", "verus_state_machines_macros::case_on_next", "verus_state_machines_macros::state_machine"], "complexity_verus_tokens": 5, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.17532467532467533}, "labeling": {"segments": {"exec": " fn num_hosts(&self) -> bool {\n\n fn initialize_inductive(post: Self, map_count: int) {\n\n fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n\n fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n\n fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n\n fn main() {", "spec": "spec fn valid_host(&self, i: int) -> bool {\n\nspec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n\n#[invariant]"}}}, "all_snapshots": ["#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nverus! {\n\n#[verifier::external_body]  /* vattr */\npub struct Key {}\n\n#[verifier::external_body]  /* vattr */\npub struct Value {}\n\n#[verifier::external_body]  /* vattr */\n#[verifier::spec]\npub fn default() -> Value {\n    unimplemented!()\n}\n\nstate_machine!{\n    MapSpec {\n        fields {\n            pub map: Map<Key, Value>,\n        }\n\n        init!{\n            empty() {\n                init map = Map::total(|k| default());\n            }\n        }\n\n        transition!{\n            insert_op(key: Key, value: Value) {\n                update map = pre.map.insert(key, value);\n            }\n        }\n\n        transition!{\n            query_op(key: Key, value: Value) {\n                require(pre.map.contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            noop() {\n            }\n        }\n    }\n}\n\nstate_machine!{\n    ShardedKVProtocol {\n        fields {\n            // TODO have a way to annotate this as a constant outside of tokenized mode\n            pub map_count: int,\n\n            pub maps: Seq<Map<Key, Value>>,\n        }\n\n        init!{\n            initialize(map_count: int) {\n                require(0 < map_count);\n                init map_count = map_count;\n                init maps = Seq::new(map_count as nat, |i| {\n                    if i == 0 {\n                        Map::total(|k| default())\n                    } else {\n                        Map::empty()\n                    }\n                });\n            }\n        }\n\n        pub open spec fn valid_host(&self, i: int) -> bool {\n            0 <= i < self.map_count\n        }\n\n        transition!{\n            insert(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).dom().contains(key));\n                update maps[idx][key] = value;\n            }\n        }\n\n        transition!{\n            query(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {\n                require(pre.valid_host(send_idx));\n                require(pre.valid_host(recv_idx));\n                require(pre.maps.index(send_idx).contains_pair(key, value));\n                require(send_idx != recv_idx);\n                update maps[send_idx] = pre.maps.index(send_idx).remove(key);\n                update maps[recv_idx][key] = value;\n            }\n        }\n\n        pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n            self.valid_host(hostidx)\n            && self.maps.index(hostidx).dom().contains(key)\n        }\n\n        pub open spec fn key_holder(&self, key: Key) -> int {\n            choose|idx| self.host_has_key(idx, key)\n        }\n\n        pub open spec fn abstraction_one_key(&self, key: Key) -> Value {\n            if exists |idx| self.host_has_key(idx, key) {\n                self.maps.index(self.key_holder(key)).index(key)\n            } else {\n                default()\n            }\n        }\n\n        pub open spec fn interp_map(&self) -> Map<Key, Value> {\n            Map::total(|key| self.abstraction_one_key(key))\n        }\n\n        #[invariant]\n        pub open fn num_hosts(&self) -> bool {\n            self.maps.len() == self.map_count\n        }\n\n        #[invariant]\n        pub open fn inv_no_dupes(&self) -> bool {\n            forall |i: int, j: int, key: Key|\n                self.host_has_key(i, key) && self.host_has_key(j, key) ==> i == j\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, map_count: int) {\n        }\n\n        #[inductive(insert)]\n        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n            //assert(forall(|k: Key| pre.host_has_key(idx, k) ==> post.host_has_key(idx, k)));\n            //assert(forall(|k: Key| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k)));\n            //assert(forall(|k: Key| pre.host_has_key(idx, k) == post.host_has_key(idx, k)));\n            assert(forall |i: int, k: Key| pre.host_has_key(i, k) == post.host_has_key(i, k));\n        }\n\n        #[inductive(query)]\n        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) { }\n\n        #[inductive(transfer)]\n        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n            assert(forall |i: int, k: Key| !equal(k, key) ==> pre.host_has_key(i, k) == post.host_has_key(i, k));\n            assert(forall |i: int| i != send_idx && i != recv_idx ==> pre.host_has_key(i, key) == post.host_has_key(i, key));\n\n            assert(equal(post.maps.index(send_idx),\n                pre.maps.index(send_idx).remove(key)));\n\n            assert(!post.host_has_key(send_idx, key));\n            assert(pre.host_has_key(send_idx, key));\n\n            /*assert_forall_by(|i: int, j: int, k: Key| {\n                requires(post.host_has_key(i, k) && post.host_has_key(j, k));\n                ensures(i == j);\n                if equal(k, key) {\n                    assert(i != send_idx);\n                    assert(j != send_idx);\n                    if i != recv_idx {\n                        assert(pre.host_has_key(i, key));\n                    }\n                    if i != recv_idx && j != recv_idx {\n                        assert(pre.host_has_key(i, key));\n                        assert(pre.host_has_key(j, key));\n                        assert(pre.inv_no_dupes());\n                        assert(i == j);\n                    }\n                    assert(i == j);\n                } else {\n                    assert(i == j);\n                }\n            });*/\n        }\n    }\n}\n\nspec fn interp(a: ShardedKVProtocol::State) -> MapSpec::State {\n    MapSpec::State { map: a.interp_map() }\n}\n\nproof fn next_refines_next_with_macro(pre: ShardedKVProtocol::State, post: ShardedKVProtocol::State)\n    requires\n        pre.invariant(),\n        post.invariant(),\n        interp(pre).invariant(),\n        ShardedKVProtocol::State::next(pre, post),\n    ensures\n        MapSpec::State::next(interp(pre), interp(post)),\n{\n    case_on_next!{pre, post, ShardedKVProtocol => {\n        insert(idx, key, value) => {\n            assert_maps_equal!(pre.interp_map().insert(key, value), post.interp_map(), k => {\n                if equal(k, key) {\n                    assert(pre.host_has_key(idx, key));\n                    assert(post.host_has_key(idx, key));\n                } else {\n                    assert(pre.interp_map().dom().contains(k));\n                    assert(post.interp_map().dom().contains(k));\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n                        assert(pre.host_has_key(i, k));\n                        assert(post.host_has_key(i, k));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));\n                    } else {\n                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));\n                        /*assert(forall |idx| !post.host_has_key(idx, k));\n                        assert(!exists(|idx| post.host_has_key(idx, k)));\n                        assert(equal(pre.abstraction_one_key(k), default()));\n                        assert(equal(post.abstraction_one_key(k), default()));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));*/\n                    }\n\n                    /*assert(pre.interp_map().dom().contains(k) ==>\n                        post.interp_map().dom().contains(k)\n                        && equal(pre.interp_map().index(k), post.interp_map().index(k))\n                    );\n                    assert(post.interp_map().dom().contains(k) ==>\n                        pre.interp_map().dom().contains(k));*/\n                }\n            });\n            MapSpec::show::insert_op(interp(pre), interp(post), key, value);\n        }\n        query(idx, key, value) => {\n            //assert(interp(pre).map =~= interp(post).map);\n            //assert(equal(interp(pre).map, interp(post).map));\n\n            //assert(equal(Map::total(|key| pre.abstraction_one_key(key)).dom(),\n            //    Set::empty().complement()));\n            //assert(equal(pre.interp_map(),\n            //    Map::total(|key| pre.abstraction_one_key(key))));\n            //assert(equal(pre.interp_map().dom(), Set::empty().complement()));\n\n            //assert(equal(interp(pre).map.dom(), Set::empty().complement()));\n            //assert(interp(pre).map.dom().contains(key));\n            //assert(equal(interp(pre).map.index(key),\n            //    pre.abstraction_one_key(key)));\n\n            assert(pre.host_has_key(idx, key));\n            //assert(pre.host_has_key(pre.key_holder(key), key));\n            //assert(equal(pre.key_holder(key), idx));\n\n            //assert(equal(pre.abstraction_one_key(key), value));\n            //assert(equal(interp(pre).map.index(key), value));\n            MapSpec::show::query_op(interp(pre), interp(post), key, value);\n        }\n        transfer(send_idx, recv_idx, key, value) => {\n            assert_maps_equal!(pre.interp_map(), post.interp_map(), k: Key => {\n                if equal(k, key) {\n                    assert(pre.host_has_key(send_idx, key));\n                    assert(post.host_has_key(recv_idx, key));\n                } else {\n                    assert(pre.interp_map().dom().contains(k));\n                    assert(post.interp_map().dom().contains(k));\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n                        assert(pre.host_has_key(i, k));\n                        assert(post.host_has_key(i, k));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));\n                    } else {\n                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));\n                    }\n                }\n            });\n            MapSpec::show::noop(interp(pre), interp(post));\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: ShardedKVProtocol::State)\n    requires\n        post.invariant() && ShardedKVProtocol::State::init(post),\n    ensures\n        MapSpec::State::init(interp(post)),\n{\n    case_on_init!{post, ShardedKVProtocol => {\n        initialize(n) => {\n            assert_maps_equal!(interp(post).map, Map::total(|k| default()), k: Key => {\n                assert(interp(post).map.dom().contains(k));\n                assert(equal(interp(post).map.index(k), default()));\n            });\n\n            MapSpec::show::empty(interp(post));\n        }\n    }}\n}\n\nfn main() {\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\n     use verus_builtin_macros::*;\n     use vstd::map::*;\n     use vstd::seq::*;\n     use verus_state_machines_macros::state_machine;\n     verus! {\n     pub struct Key {\n  }\n     pub struct Value {\n  }\n#[verifier::external_body]  \n#[verifier::spec]\npub fn default() -> Value {\n       unimplemented!() }\n    state_machine!{\n       ShardedKVProtocol {\n          fields {\n             pub map_count: int,             pub maps: Seq<Map<Key, Value>>,         }\n          init!{\n             initialize(map_count: int) {                 require(0 < map_count);                 init map_count = map_count;                 init maps = Seq::new(map_count as nat, |i| {                     if i == 0 {                         Map::total(|k| default())                     } else {                         Map::empty()                     }                 });             }\n         }\n          pub open spec fn valid_host(&self, i: int) -> bool {\n             0 <= i < self.map_count         }\n          transition!{\n             insert(idx: int, key: Key, value: Value) {                 require(pre.valid_host(idx));                 require(pre.maps.index(idx).dom().contains(key));                 update maps[idx][key] = value;             }\n         }\n          transition!{\n             query(idx: int, key: Key, value: Value) {                 require(pre.valid_host(idx));                 require(pre.maps.index(idx).contains_pair(key, value));             }\n         }\n          transition!{\n             transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {                 require(pre.valid_host(send_idx));                 require(pre.valid_host(recv_idx));                 require(pre.maps.index(send_idx).contains_pair(key, value));                 require(send_idx != recv_idx);                 update maps[send_idx] = pre.maps.index(send_idx).remove(key);                 update maps[recv_idx][key] = value;             }\n         }\n          pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n             self.valid_host(hostidx)             && self.maps.index(hostidx).dom().contains(key)         }\n#[invariant]\n        pub open fn num_hosts(&self) -> bool {\n             self.maps.len() == self.map_count         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, map_count: int) {\n         }\n#[inductive(insert)]\n        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n         }\n#[inductive(query)]\n        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n }\n#[inductive(transfer)]\n        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n         }\n      }\n   }\n    fn main() {\n   }\n    }\n", "use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::map::*;\n        use vstd::seq::*;\n        use verus_state_machines_macros::state_machine;\n        verus! {\n        pub struct Key {\n     }\n        pub struct Value {\n     }\n#[verifier::external_body]  \n#[verifier::spec]\npub fn default() -> Value {\n          unimplemented!() }\n       state_machine!{\n          ShardedKVProtocol {\n             fields {\n                pub map_count: int,             pub maps: Seq<Map<Key, Value>>,         }\n             init!{\n                initialize(map_count: int) {\n                   init map_count = map_count;\n                   init maps = Seq::new(map_count as nat, |i| {\n                       if i == 0 {\n                          Map::total(|k| default())                     }\n   else {\n                          Map::empty()                     }\n                   }\n  );\n               }\n            }\n             pub open spec fn valid_host(&self, i: int) -> bool {\n                0 <= i < self.map_count         }\n             transition!{\n                insert(idx: int, key: Key, value: Value) {\n               }\n            }\n             transition!{\n                query(idx: int, key: Key, value: Value) {\n               }\n            }\n             transition!{\n                transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {\n               }\n            }\n         }\n      }\n       fn main() {\n      }\n       }\n", "use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::map::*;\n        use vstd::seq::*;\n        use verus_state_machines_macros::state_machine;\n        verus! {\n        pub struct Key ;\n        pub struct Value ;\n#[verifier::external_body]  \n#[verifier::spec]\npub fn default() -> Value {\n          unimplemented!() }\n       state_machine!{\n          ShardedKVProtocol {\n             fields {\n                pub map_count: int,             pub maps: Seq<Map<Key, Value>>,         }\n             init!{\n                initialize(map_count: int) {\n                   init map_count = map_count;\n                   init maps = Seq::new(map_count as nat, |i| \n                       if i == 0 {\n                          Map::total(|k| default())                     }\n   else {\n                          Map::empty()                     }\n                   \n  );\n               }\n            }\n             pub open spec fn valid_host() -> bool ;\n             transition!{\n                insert() {}\n            }\n             transition!{\n                query() {}\n            }\n             transition!{\n                transfer() {}\n            }\n         }\n      }\n       fn main() ;\n       }\n", "use verus_builtin::*;\n               use verus_builtin_macros::*;\n               verus! {\n             fn main() ;\n             }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "syntax_attr_cc0b9f7d", "original_code": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "minimized_code": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/syntax_attr.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 910, "minimize_time_ms": 154699, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 339, "minimized_LOC": 339, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 169, "has_meaningful_spec": true, "readability_score": 0.85, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n\n\nfn test_my_funs(x: u32, y: u32)\n{\n\n\nfn test_rec(x: u64, y: u64)\n{\n\n\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n\n\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n\n\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n\n fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n\n\nfn test_mut_tracked(x: u32) -> u32 {", "spec": "spec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n\nspec fn my_pub_spec_fun1(x: int, y: int) -> int {\n\nspec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n\nspec fn my_pub_spec_fun3(x: int, y: int) -> int {\n\nspec fn my_pub_spec_fun4(x: int, y: int) -> int {\n\nspec fn my_pub_spec_fun5(x: int, y: int) -> int {\n\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n\nspec fn f1(i: int) -> int {\n\n///   - exec code: compiled, may have requires/ensures\n\n///   - proof code: erased before compilation, may have requires/ensures\n\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n\n    requires\n\n    decreases x,\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n\n    decreases x, y,\n\n    decreases x,\n\n///   - decreases .. \"when\" restricts the function definition to a condition\n\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n\n    decreases a,\n\n    requires\n\n/// \"let ghost\" currently requires the verus! macro\n\n    requires\n\n    requires\n\n        requires\n\n        ensures\n\n    requires\n\n    ensures", "proof": "proof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n\nproof fn add0_recommends(a: nat, b: nat) {\n\nproof fn dec0_decreases(a: int) {\n\nproof { ... }\n\nproof {\n            assert(x - 1 >= 0);\n        }\n\nproof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n\nproof {\n        v = v + 1;  // assign directly to ghost mut v\n    }"}}}, "all_snapshots": ["#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "use vstd;\nfn main() {}\n", " use vstd::{};\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "test_expand_errors_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs expand-errors\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::*;\n\nverus! {\n\nspec fn e() -> bool;\n\nspec fn f() -> bool;\n\nspec fn g() -> bool;\n\nspec fn h() -> bool;\n\nspec fn k(i: int) -> bool;\n\nspec fn z() -> bool {\n    (e() ==> h()) && (forall|i: int| k(i))\n}\n\nspec fn stuff() -> bool {\n    f() && g() && z()\n}\n\nproof fn test()\n    requires\n        f(),\n{\n    assert(stuff());\n}\n\nproof fn test_ret()\n    ensures\n        z(),\n{\n}\n\npub spec fn ai(i: int) -> bool;\n\npub spec fn bi(i: int) -> bool;\n\npub spec fn ci(i: int) -> bool;\n\npub open spec fn all_a() -> bool {\n    forall|i: int| ai(i)\n}\n\npub open spec fn all_b() -> bool {\n    forall|i: int| bi(i)\n}\n\npub open spec fn all_c() -> bool {\n    forall|i: int| ci(i)\n}\n\npub proof fn test2(j: int)\n    requires\n        forall|i: int| ai(i),\n        forall|i: int| (#[trigger] ai(i)) ==> bi(i),\n{\n    assert(ai(j) && bi(j) && ci(j));\n}\n\npub proof fn test_let(j: int)\n    requires\n        ai(j + 1),\n{\n    assert({\n        let k = j + 3;\n        let r = k - 2;\n        ai(r) && bi(r)\n    });\n}\n\npub proof fn test_match(m: Option<int>)\n    requires\n        m.is_some(),\n{\n    assert(match m {\n        Some(x) => x == 5,\n        None => false,\n    });\n}\n\npub proof fn test_match3(foo: Foo) {\n    assert(match foo {\n        Foo::Bar => false,\n        Foo::Qux(z) => z == 0,\n        Foo::Duck(w, y) => w == y,\n    });\n}\n\npub proof fn test3(a: bool, b: bool) {\n    assert(a <==> b);\n}\n\npub proof fn test_xor(a: bool, b: bool) {\n    assert(a ^ b);\n}\n\npub proof fn test4(a: Option<u8>, b: Option<u8>) {\n    assert(a == b);\n}\n\npub struct X {\n    pub a: u32,\n    pub b: bool,\n    pub c: u64,\n}\n\npub proof fn test5(a: X, b: X) {\n    assert(a == b);\n}\n\npub proof fn test6(a: Option<u64>, b: u64) {\n    assert(a == Some(b));\n}\n\npub proof fn test7(a: Option<u64>, b: u64) {\n    assert(Some(b) == a);\n}\n\npub proof fn test8(a: Option<u64>, b: u64) {\n    assert(a === None);\n}\n\npub proof fn test9(a: Option<u64>, b: u64) {\n    assert(None === a);\n}\n\npub proof fn test10(a: Option<u64>, b: u64) {\n    assert(None === Some(b));\n}\n\npub proof fn test11(a: u64, b: u64) {\n    assert(Some(a) == Some(b));\n}\n\n#[verifier::external_body]\npub struct OpaqueDT {\n    u: u64,\n}\n\npub proof fn test12(a: OpaqueDT, b: OpaqueDT) {\n    assert(a == b);\n}\n\npub enum Foo {\n    Bar,\n    Qux(u64),\n    Duck(u64, u64),\n}\n\npub proof fn test13(a: Foo, b: u64) {\n    assert(a == Foo::Qux(b));\n}\n\npub proof fn test14(a: Foo, b: u64, c: u64) {\n    assert(Foo::Duck(b, c) == a);\n}\n\npub proof fn test15(a: Foo) {\n    assert(a === Foo::Bar);\n}\n\npub proof fn test16(a: Foo, b: u64) {\n    assert(Foo::Bar === a);\n}\n\npub proof fn test17(a: u64, b: u64, c: u64) {\n    assert(Foo::Qux(a) === Foo::Duck(b, c));\n}\n\npub proof fn test18(b: u64, c: u64, e: u64, f: u64) {\n    assert(Foo::Duck(b, c) == Foo::Duck(e, f));\n}\n\n#[verifier::opaque]\nspec fn some_opaque() -> bool {\n    false\n}\n\nspec fn some_non_opaque() -> bool {\n    false\n}\n\nproof fn test_opaque1() {\n    assert(some_opaque());\n}\n\nproof fn test_opaque2() {\n    reveal(some_opaque);\n    assert(some_opaque());\n}\n\nproof fn test_opaque3() {\n    hide(some_non_opaque);\n    assert(some_non_opaque());\n}\n\nspec fn other(i: int) -> bool;\n\nspec fn recursive_function(i: int, base: bool) -> bool\n    decreases i,\n{\n    if i <= 0 {\n        base\n    } else {\n        recursive_function(i - 1, base)\n    }\n}\n\nproof fn test_rec() {\n    reveal_with_fuel(recursive_function, 3);\n    assert(recursive_function(3, true));  // should fail with \"reached fuel limit for recursion\"\n}\n\nproof fn test_rec2() {\n    reveal_with_fuel(recursive_function, 4);\n    assert(recursive_function(3, true));  // should pass\n}\n\nproof fn test_rec3() {\n    reveal_with_fuel(recursive_function, 4);\n    assert(recursive_function(3, false));\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs expand-errors\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::*;\n\nverus! {\n\nspec fn e() -> bool;\n\nspec fn f() -> bool;\n\nspec fn g() -> bool;\n\nspec fn h() -> bool;\n\nspec fn k(i: int) -> bool;\n\nspec fn z() -> bool {\n    (e() ==> h()) && (forall|i: int| k(i))\n}\n\nspec fn stuff() -> bool {\n    f() && g() && z()\n}\n\nproof fn test()\n    requires\n        f(),\n{\n    assert(stuff());\n}\n\nproof fn test_ret()\n    ensures\n        z(),\n{\n}\n\npub spec fn ai(i: int) -> bool;\n\npub spec fn bi(i: int) -> bool;\n\npub spec fn ci(i: int) -> bool;\n\npub open spec fn all_a() -> bool {\n    forall|i: int| ai(i)\n}\n\npub open spec fn all_b() -> bool {\n    forall|i: int| bi(i)\n}\n\npub open spec fn all_c() -> bool {\n    forall|i: int| ci(i)\n}\n\npub proof fn test2(j: int)\n    requires\n        forall|i: int| ai(i),\n        forall|i: int| (#[trigger] ai(i)) ==> bi(i),\n{\n    assert(ai(j) && bi(j) && ci(j));\n}\n\npub proof fn test_let(j: int)\n    requires\n        ai(j + 1),\n{\n    assert({\n        let k = j + 3;\n        let r = k - 2;\n        ai(r) && bi(r)\n    });\n}\n\npub proof fn test_match(m: Option<int>)\n    requires\n        m.is_some(),\n{\n    assert(match m {\n        Some(x) => x == 5,\n        None => false,\n    });\n}\n\npub proof fn test_match3(foo: Foo) {\n    assert(match foo {\n        Foo::Bar => false,\n        Foo::Qux(z) => z == 0,\n        Foo::Duck(w, y) => w == y,\n    });\n}\n\npub proof fn test3(a: bool, b: bool) {\n    assert(a <==> b);\n}\n\npub proof fn test_xor(a: bool, b: bool) {\n    assert(a ^ b);\n}\n\npub proof fn test4(a: Option<u8>, b: Option<u8>) {\n    assert(a == b);\n}\n\npub struct X {\n    pub a: u32,\n    pub b: bool,\n    pub c: u64,\n}\n\npub proof fn test5(a: X, b: X) {\n    assert(a == b);\n}\n\npub proof fn test6(a: Option<u64>, b: u64) {\n    assert(a == Some(b));\n}\n\npub proof fn test7(a: Option<u64>, b: u64) {\n    assert(Some(b) == a);\n}\n\npub proof fn test8(a: Option<u64>, b: u64) {\n    assert(a === None);\n}\n\npub proof fn test9(a: Option<u64>, b: u64) {\n    assert(None === a);\n}\n\npub proof fn test10(a: Option<u64>, b: u64) {\n    assert(None === Some(b));\n}\n\npub proof fn test11(a: u64, b: u64) {\n    assert(Some(a) == Some(b));\n}\n\n#[verifier::external_body]\npub struct OpaqueDT {\n    u: u64,\n}\n\npub proof fn test12(a: OpaqueDT, b: OpaqueDT) {\n    assert(a == b);\n}\n\npub enum Foo {\n    Bar,\n    Qux(u64),\n    Duck(u64, u64),\n}\n\npub proof fn test13(a: Foo, b: u64) {\n    assert(a == Foo::Qux(b));\n}\n\npub proof fn test14(a: Foo, b: u64, c: u64) {\n    assert(Foo::Duck(b, c) == a);\n}\n\npub proof fn test15(a: Foo) {\n    assert(a === Foo::Bar);\n}\n\npub proof fn test16(a: Foo, b: u64) {\n    assert(Foo::Bar === a);\n}\n\npub proof fn test17(a: u64, b: u64, c: u64) {\n    assert(Foo::Qux(a) === Foo::Duck(b, c));\n}\n\npub proof fn test18(b: u64, c: u64, e: u64, f: u64) {\n    assert(Foo::Duck(b, c) == Foo::Duck(e, f));\n}\n\n#[verifier::opaque]\nspec fn some_opaque() -> bool {\n    false\n}\n\nspec fn some_non_opaque() -> bool {\n    false\n}\n\nproof fn test_opaque1() {\n    assert(some_opaque());\n}\n\nproof fn test_opaque2() {\n    reveal(some_opaque);\n    assert(some_opaque());\n}\n\nproof fn test_opaque3() {\n    hide(some_non_opaque);\n    assert(some_non_opaque());\n}\n\nspec fn other(i: int) -> bool;\n\nspec fn recursive_function(i: int, base: bool) -> bool\n    decreases i,\n{\n    if i <= 0 {\n        base\n    } else {\n        recursive_function(i - 1, base)\n    }\n}\n\nproof fn test_rec() {\n    reveal_with_fuel(recursive_function, 3);\n    assert(recursive_function(3, true));  // should fail with \"reached fuel limit for recursion\"\n}\n\nproof fn test_rec2() {\n    reveal_with_fuel(recursive_function, 4);\n    assert(recursive_function(3, true));  // should pass\n}\n\nproof fn test_rec3() {\n    reveal_with_fuel(recursive_function, 4);\n    assert(recursive_function(3, false));\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/test_expand_errors.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "postcondition", "verify_time_ms": 892, "verus_errors": [{"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [36, 36], "label": "assertion failed", "text": [{"text": "    assert(stuff());", "highlight_start": 12, "highlight_end": 19}]}]}, {"error_type": "PostCondFail", "error_text": "postcondition not satisfied (at the end of the function body; failed this postcondition)", "message": "VerusErrorType.PostCondFail: postcondition not satisfied (at the end of the function body; failed this postcondition)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [39, 39], "label": "at the end of the function body", "text": [{"text": "proof fn test_ret()", "highlight_start": 7, "highlight_end": 20}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [41, 41], "label": "failed this postcondition", "text": [{"text": "        z(),", "highlight_start": 9, "highlight_end": 12}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [68, 68], "label": "assertion failed", "text": [{"text": "    assert(ai(j) && bi(j) && ci(j));", "highlight_start": 12, "highlight_end": 35}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [75, 79], "label": "assertion failed", "text": [{"text": "    assert({", "highlight_start": 12, "highlight_end": 13}, {"text": "        let k = j + 3;", "highlight_start": 1, "highlight_end": 23}, {"text": "        let r = k - 2;", "highlight_start": 1, "highlight_end": 23}, {"text": "        ai(r) && bi(r)", "highlight_start": 1, "highlight_end": 23}, {"text": "    });", "highlight_start": 1, "highlight_end": 6}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [87, 87], "label": "assertion failed", "text": [{"text": "        Some(x) => x == 5,", "highlight_start": 9, "highlight_end": 16}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [94, 94], "label": "assertion failed", "text": [{"text": "        Foo::Bar => false,", "highlight_start": 9, "highlight_end": 17}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [101, 101], "label": "assertion failed", "text": [{"text": "    assert(a <==> b);", "highlight_start": 12, "highlight_end": 20}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [105, 105], "label": "assertion failed", "text": [{"text": "    assert(a ^ b);", "highlight_start": 12, "highlight_end": 17}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [109, 109], "label": "assertion failed", "text": [{"text": "    assert(a == b);", "highlight_start": 12, "highlight_end": 18}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [119, 119], "label": "assertion failed", "text": [{"text": "    assert(a == b);", "highlight_start": 12, "highlight_end": 18}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [123, 123], "label": "assertion failed", "text": [{"text": "    assert(a == Some(b));", "highlight_start": 12, "highlight_end": 24}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [127, 127], "label": "assertion failed", "text": [{"text": "    assert(Some(b) == a);", "highlight_start": 12, "highlight_end": 24}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [131, 131], "label": "assertion failed", "text": [{"text": "    assert(a === None);", "highlight_start": 12, "highlight_end": 22}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [135, 135], "label": "assertion failed", "text": [{"text": "    assert(None === a);", "highlight_start": 12, "highlight_end": 22}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [139, 139], "label": "assertion failed", "text": [{"text": "    assert(None === Some(b));", "highlight_start": 12, "highlight_end": 28}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [143, 143], "label": "assertion failed", "text": [{"text": "    assert(Some(a) == Some(b));", "highlight_start": 12, "highlight_end": 30}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [152, 152], "label": "assertion failed", "text": [{"text": "    assert(a == b);", "highlight_start": 12, "highlight_end": 18}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [162, 162], "label": "assertion failed", "text": [{"text": "    assert(a == Foo::Qux(b));", "highlight_start": 12, "highlight_end": 28}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [166, 166], "label": "assertion failed", "text": [{"text": "    assert(Foo::Duck(b, c) == a);", "highlight_start": 12, "highlight_end": 32}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [170, 170], "label": "assertion failed", "text": [{"text": "    assert(a === Foo::Bar);", "highlight_start": 12, "highlight_end": 26}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [174, 174], "label": "assertion failed", "text": [{"text": "    assert(Foo::Bar === a);", "highlight_start": 12, "highlight_end": 26}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [178, 178], "label": "assertion failed", "text": [{"text": "    assert(Foo::Qux(a) === Foo::Duck(b, c));", "highlight_start": 12, "highlight_end": 43}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [182, 182], "label": "assertion failed", "text": [{"text": "    assert(Foo::Duck(b, c) == Foo::Duck(e, f));", "highlight_start": 12, "highlight_end": 46}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [195, 195], "label": "assertion failed", "text": [{"text": "    assert(some_opaque());", "highlight_start": 12, "highlight_end": 25}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [200, 200], "label": "assertion failed", "text": [{"text": "    assert(some_opaque());", "highlight_start": 12, "highlight_end": 25}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [205, 205], "label": "assertion failed", "text": [{"text": "    assert(some_non_opaque());", "highlight_start": 12, "highlight_end": 29}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [222, 222], "label": "assertion failed", "text": [{"text": "    assert(recursive_function(3, true));  // should fail with \"reached fuel limit for recursion\"", "highlight_start": 12, "highlight_end": 39}]}]}, {"error_type": "AssertFail", "error_text": "assertion failed (assertion failed)", "message": "VerusErrorType.AssertFail: assertion failed (assertion failed)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8wi22ef6", "lines": [232, 232], "label": "assertion failed", "text": [{"text": "    assert(recursive_function(3, false));", "highlight_start": 12, "highlight_end": 40}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 238, "minimized_LOC": 238, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::map::", "vstd::modes::", "vstd::prelude::", "vstd::seq::", "vstd::"], "complexity_verus_tokens": 58, "has_meaningful_spec": true, "readability_score": 0.75, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn e() -> bool;\n\nspec fn f() -> bool;\n\nspec fn g() -> bool;\n\nspec fn h() -> bool;\n\nspec fn k(i: int) -> bool;\n\nspec fn z() -> bool {\n\nspec fn f() -> bool;\n\nspec fn g() -> bool;\n\nspec fn h() -> bool;\n\nspec fn k(i: int) -> bool;\n\nspec fn z() -> bool {\n\nspec fn g() -> bool;\n\nspec fn h() -> bool;\n\nspec fn k(i: int) -> bool;\n\nspec fn z() -> bool {\n\nspec fn h() -> bool;\n\nspec fn k(i: int) -> bool;\n\nspec fn z() -> bool {\n\nspec fn k(i: int) -> bool;\n\nspec fn z() -> bool {\n\nspec fn z() -> bool {\n\nspec fn stuff() -> bool {\n\nspec fn ai(i: int) -> bool;\n\npub spec fn bi(i: int) -> bool;\n\npub spec fn ci(i: int) -> bool;\n\npub open spec fn all_a() -> bool {\n\nspec fn bi(i: int) -> bool;\n\npub spec fn ci(i: int) -> bool;\n\npub open spec fn all_a() -> bool {\n\nspec fn ci(i: int) -> bool;\n\npub open spec fn all_a() -> bool {\n\nspec fn all_a() -> bool {\n\nspec fn all_b() -> bool {\n\nspec fn all_c() -> bool {\n\nspec fn some_opaque() -> bool {\n\nspec fn some_non_opaque() -> bool {\n\nspec fn other(i: int) -> bool;\n\nspec fn recursive_function(i: int, base: bool) -> bool\n    decreases i,\n{\n\nspec fn recursive_function(i: int, base: bool) -> bool\n    decreases i,\n{\n\n    requires\n\n    ensures\n\n    requires\n\n    requires\n\n    requires\n\n    decreases i,", "proof": "proof fn test()\n    requires\n        f(),\n{\n\nproof fn test_ret()\n    ensures\n        z(),\n{\n\nproof fn test2(j: int)\n    requires\n        forall|i: int| ai(i),\n        forall|i: int| (#[trigger] ai(i)) ==> bi(i),\n{\n\nproof fn test_let(j: int)\n    requires\n        ai(j + 1),\n{\n\nproof fn test_match(m: Option<int>)\n    requires\n        m.is_some(),\n{\n\nproof fn test_match3(foo: Foo) {\n\nproof fn test3(a: bool, b: bool) {\n\nproof fn test_xor(a: bool, b: bool) {\n\nproof fn test4(a: Option<u8>, b: Option<u8>) {\n\nproof fn test5(a: X, b: X) {\n\nproof fn test6(a: Option<u64>, b: u64) {\n\nproof fn test7(a: Option<u64>, b: u64) {\n\nproof fn test8(a: Option<u64>, b: u64) {\n\nproof fn test9(a: Option<u64>, b: u64) {\n\nproof fn test10(a: Option<u64>, b: u64) {\n\nproof fn test11(a: u64, b: u64) {\n\nproof fn test12(a: OpaqueDT, b: OpaqueDT) {\n\nproof fn test13(a: Foo, b: u64) {\n\nproof fn test14(a: Foo, b: u64, c: u64) {\n\nproof fn test15(a: Foo) {\n\nproof fn test16(a: Foo, b: u64) {\n\nproof fn test17(a: u64, b: u64, c: u64) {\n\nproof fn test18(b: u64, c: u64, e: u64, f: u64) {\n\nproof fn test_opaque1() {\n\nproof fn test_opaque2() {\n\nproof fn test_opaque3() {\n\nproof fn test_rec() {\n\nproof fn test_rec2() {\n\nproof fn test_rec3() {"}}}, "all_snapshots": []}
{"id": "traits_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::pervasive::*;\n\nverus! {\n\ntrait T<A> {\n    spec fn req(&self, a: A) -> bool;\n\n    spec fn ens(&self, a: A, r: A) -> bool;\n\n    fn f(&self, a: &A) -> (ra: A)\n        requires\n            self.req(*a),\n        ensures\n            self.ens(*a, ra),\n    ;\n}\n\nstruct B {\n    x: bool,\n}\n\nstruct I {\n    x: u64,\n}\n\nimpl T<bool> for B {\n    spec fn req(&self, a: bool) -> bool {\n        a\n    }\n\n    spec fn ens(&self, a: bool, r: bool) -> bool {\n        r == (a && self.x)\n    }\n\n    fn f(&self, a: &bool) -> bool {\n        *a && self.x\n    }\n}\n\nimpl T<u64> for I {\n    spec fn req(&self, a: u64) -> bool {\n        self.x < a && a < 100\n    }\n\n    spec fn ens(&self, a: u64, r: u64) -> bool {\n        self.x <= r && r < 100\n    }\n\n    fn f(&self, a: &u64) -> u64 {\n        self.x / 2 + a / 2\n    }\n}\n\nfn p<A, Z: T<A>>(a: &A, z: &Z) -> (rz: A)\n    requires\n        z.req(*a),\n    ensures\n        z.ens(*a, rz),\n{\n    z.f(a)\n}\n\nfn test() -> bool {\n    let i = I { x: 30 };\n    print_u64(p(&70, &i));\n    let b = B { x: false };\n    b.f(&true) && p(&true, &b)\n}\n\n#[verifier::external_body]\nfn main() {\n    println!(\"{}\", test());\n}\n\n} // verus!\n", "minimized_code": "use verus_builtin::*;\n          use verus_builtin_macros::*;\n          verus! {\n        trait T<A> {           spec fn req(&self, a: A) -> bool;           spec fn ens(&self, a: A, r: A) -> bool;           fn f(&self, a: &A) -> (ra: A)         requires             self.req(*a),         ensures             self.ens(*a, ra),     ;       }\n        struct B {           x: bool, }\n        struct I {           x: u64, }\n      fn main() ;\n        }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/traits.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 754, "minimize_time_ms": 183981, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 79, "minimized_LOC": 8, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::pervasive::"], "complexity_verus_tokens": 5, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.10126582278481013}, "labeling": {"segments": {"spec": "spec fn req(&self, a: A) -> bool;           spec fn ens(&self, a: A, r: A) -> bool;           fn f(&self, a: &A) -> (ra: A)         requires             self.req(*a),         ensures             self.ens(*a, ra),     ;       }\n        struct B {\n\nspec fn ens(&self, a: A, r: A) -> bool;           fn f(&self, a: &A) -> (ra: A)         requires             self.req(*a),         ensures             self.ens(*a, ra),     ;       }\n        struct B {\n\n        trait T<A> {           spec fn req(&self, a: A) -> bool;           spec fn ens(&self, a: A, r: A) -> bool;           fn f(&self, a: &A) -> (ra: A)         requires             self.req(*a),         ensures             self.ens(*a, ra),     ;       }"}}}, "all_snapshots": ["// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::pervasive::*;\n\nverus! {\n\ntrait T<A> {\n    spec fn req(&self, a: A) -> bool;\n\n    spec fn ens(&self, a: A, r: A) -> bool;\n\n    fn f(&self, a: &A) -> (ra: A)\n        requires\n            self.req(*a),\n        ensures\n            self.ens(*a, ra),\n    ;\n}\n\nstruct B {\n    x: bool,\n}\n\nstruct I {\n    x: u64,\n}\n\nimpl T<bool> for B {\n    spec fn req(&self, a: bool) -> bool {\n        a\n    }\n\n    spec fn ens(&self, a: bool, r: bool) -> bool {\n        r == (a && self.x)\n    }\n\n    fn f(&self, a: &bool) -> bool {\n        *a && self.x\n    }\n}\n\nimpl T<u64> for I {\n    spec fn req(&self, a: u64) -> bool {\n        self.x < a && a < 100\n    }\n\n    spec fn ens(&self, a: u64, r: u64) -> bool {\n        self.x <= r && r < 100\n    }\n\n    fn f(&self, a: &u64) -> u64 {\n        self.x / 2 + a / 2\n    }\n}\n\nfn p<A, Z: T<A>>(a: &A, z: &Z) -> (rz: A)\n    requires\n        z.req(*a),\n    ensures\n        z.ens(*a, rz),\n{\n    z.f(a)\n}\n\nfn test() -> bool {\n    let i = I { x: 30 };\n    print_u64(p(&70, &i));\n    let b = B { x: false };\n    b.f(&true) && p(&true, &b)\n}\n\n#[verifier::external_body]\nfn main() {\n    println!(\"{}\", test());\n}\n\n} // verus!\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n", "use verus_builtin::*;\n          use verus_builtin_macros::*;\n          verus! {\n        trait T<A> {           spec fn req(&self, a: A) -> bool;           spec fn ens(&self, a: A, r: A) -> bool;           fn f(&self, a: &A) -> (ra: A)         requires             self.req(*a),         ensures             self.ens(*a, ra),     ;       }\n        struct B {           x: bool, }\n        struct I {           x: u64, }\n      fn main() ;\n        }\n", "use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n"]}
{"id": "trigger_loops_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs ignore --- these examples are expected to timeout to test the quantifier profiler (i.e., exceed their rlimit)\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n// ANCHOR: def_f_g\nuninterp spec fn f(x: nat, y: nat) -> bool;\n\nuninterp spec fn g(x: nat) -> bool;\n\nuninterp spec fn h(x: nat, y: nat) -> bool;\n// ANCHOR_END: def_f_g\n\nuninterp spec fn j(x: nat) -> bool;\n\nproof fn quantifier_example()\n    requires\n        forall|x| g(x),\n    ensures\n        exists|y| g(y),\n{\n    let w = choose|z| g(z);\n    assert(g(w));\n}\n\nproof fn choose_example()\n    requires\n        exists|x| g(x),\n{\n    let z = choose|y| g(y);\n    assert(g(z));\n}\n\nproof fn cost_example()\n    requires\n        f(1, 2),\n        forall|x, y| #[trigger] f(x, y) <==> g(x) && g(y),\n        forall|z| #[trigger] g(z) == j(z + 2),\n{\n    assert(j(3) && j(4));\n}\n\nproof fn cost_example2()\n    requires\n        g(1),\n        g(2),\n        forall|x, y| f(x, y) <==> #[trigger] g(x) && #[trigger] g(y),\n        forall|z| #[trigger] g(z) == j(z + 2),\n{\n    assert(j(3) && j(4));\n}\n\nproof fn trigger_forever()\n    requires\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n    ensures\n        forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y),\n{\n}\n\n// Split the triggering over two different quantifiers\n// ANCHOR: trigger_forever2\nproof fn trigger_forever2()\n    requires\n        forall|x: nat| g(x),\n        forall|x: nat, y: nat| h(x, y) == f(x, y),\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n    ensures\n        forall|x: nat, y: nat| x > 2318 && y < 100 ==> h(x, y),\n{\n    assert(g(4));\n}\n// ANCHOR_END: trigger_forever2\n\nfn simple_loop()\n    ensures\n        forall|x| 0 <= x < 10 ==> g(x),\n{\n    let mut x: u32 = 0;\n    while x < 10\n        invariant\n            0 <= x <= 10,\n            forall|i: u32| 0 <= i < x ==> g(i as nat)\n        decreases 10 - x\n    {\n        assume(g(x as nat));\n        x = x + 1;\n    }\n}\n\nfn bad_loop()\n    requires\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n{\n    let mut x = 10;\n    while x > 10\n        invariant\n            forall|x: nat, y: nat|\n                f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n        decreases x\n    {\n        x = x - 1;\n        assert(forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y));\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs ignore --- these examples are expected to timeout to test the quantifier profiler (i.e., exceed their rlimit)\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n// ANCHOR: def_f_g\nuninterp spec fn f(x: nat, y: nat) -> bool;\n\nuninterp spec fn g(x: nat) -> bool;\n\nuninterp spec fn h(x: nat, y: nat) -> bool;\n// ANCHOR_END: def_f_g\n\nuninterp spec fn j(x: nat) -> bool;\n\nproof fn quantifier_example()\n    requires\n        forall|x| g(x),\n    ensures\n        exists|y| g(y),\n{\n    let w = choose|z| g(z);\n    assert(g(w));\n}\n\nproof fn choose_example()\n    requires\n        exists|x| g(x),\n{\n    let z = choose|y| g(y);\n    assert(g(z));\n}\n\nproof fn cost_example()\n    requires\n        f(1, 2),\n        forall|x, y| #[trigger] f(x, y) <==> g(x) && g(y),\n        forall|z| #[trigger] g(z) == j(z + 2),\n{\n    assert(j(3) && j(4));\n}\n\nproof fn cost_example2()\n    requires\n        g(1),\n        g(2),\n        forall|x, y| f(x, y) <==> #[trigger] g(x) && #[trigger] g(y),\n        forall|z| #[trigger] g(z) == j(z + 2),\n{\n    assert(j(3) && j(4));\n}\n\nproof fn trigger_forever()\n    requires\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n    ensures\n        forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y),\n{\n}\n\n// Split the triggering over two different quantifiers\n// ANCHOR: trigger_forever2\nproof fn trigger_forever2()\n    requires\n        forall|x: nat| g(x),\n        forall|x: nat, y: nat| h(x, y) == f(x, y),\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n    ensures\n        forall|x: nat, y: nat| x > 2318 && y < 100 ==> h(x, y),\n{\n    assert(g(4));\n}\n// ANCHOR_END: trigger_forever2\n\nfn simple_loop()\n    ensures\n        forall|x| 0 <= x < 10 ==> g(x),\n{\n    let mut x: u32 = 0;\n    while x < 10\n        invariant\n            0 <= x <= 10,\n            forall|i: u32| 0 <= i < x ==> g(i as nat)\n        decreases 10 - x\n    {\n        assume(g(x as nat));\n        x = x + 1;\n    }\n}\n\nfn bad_loop()\n    requires\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n{\n    let mut x = 10;\n    while x > 10\n        invariant\n            forall|x: nat, y: nat|\n                f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n        decreases x\n    {\n        x = x - 1;\n        assert(forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y));\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/trigger_loops.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 51455, "verus_errors": [{"error_type": "Other", "error_text": "function body check: Resource limit (rlimit) exceeded; consider rerunning with --profile for more details ()", "message": "VerusErrorType.Other: function body check: Resource limit (rlimit) exceeded; consider rerunning with --profile for more details ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpv8h4og87", "lines": [56, 56], "label": null, "text": [{"text": "proof fn trigger_forever()", "highlight_start": 7, "highlight_end": 27}]}]}, {"error_type": "Other", "error_text": "function body check: Resource limit (rlimit) exceeded; consider rerunning with --profile for more details ()", "message": "VerusErrorType.Other: function body check: Resource limit (rlimit) exceeded; consider rerunning with --profile for more details ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpv8h4og87", "lines": [66, 66], "label": null, "text": [{"text": "proof fn trigger_forever2()", "highlight_start": 7, "highlight_end": 28}]}]}, {"error_type": "Other", "error_text": "while loop: Resource limit (rlimit) exceeded; consider rerunning with --profile for more details ()", "message": "VerusErrorType.Other: while loop: Resource limit (rlimit) exceeded; consider rerunning with --profile for more details ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpv8h4og87", "lines": [99, 99], "label": null, "text": [{"text": "    while x > 10", "highlight_start": 5, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 113, "minimized_LOC": 113, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::"], "complexity_verus_tokens": 27, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn simple_loop()\n    ensures\n        forall|x| 0 <= x < 10 ==> g(x),\n{\n\n\nfn bad_loop()\n    requires\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n{\n\n\nfn main() {", "spec": "spec fn f(x: nat, y: nat) -> bool;\n\nuninterp spec fn g(x: nat) -> bool;\n\nuninterp spec fn h(x: nat, y: nat) -> bool;\n// ANCHOR_END: def_f_g\n\nuninterp spec fn j(x: nat) -> bool;\n\nproof fn quantifier_example()\n    requires\n        forall|x| g(x),\n    ensures\n        exists|y| g(y),\n{\n\nspec fn g(x: nat) -> bool;\n\nuninterp spec fn h(x: nat, y: nat) -> bool;\n// ANCHOR_END: def_f_g\n\nuninterp spec fn j(x: nat) -> bool;\n\nproof fn quantifier_example()\n    requires\n        forall|x| g(x),\n    ensures\n        exists|y| g(y),\n{\n\nspec fn h(x: nat, y: nat) -> bool;\n// ANCHOR_END: def_f_g\n\nuninterp spec fn j(x: nat) -> bool;\n\nproof fn quantifier_example()\n    requires\n        forall|x| g(x),\n    ensures\n        exists|y| g(y),\n{\n\nspec fn j(x: nat) -> bool;\n\nproof fn quantifier_example()\n    requires\n        forall|x| g(x),\n    ensures\n        exists|y| g(y),\n{\n\n    requires\n\n    ensures\n\n    requires\n\n    requires\n\n    requires\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    ensures\n\n        invariant\n\n        decreases 10 - x\n\n    requires\n\n        invariant\n\n        decreases x", "proof": "proof fn quantifier_example()\n    requires\n        forall|x| g(x),\n    ensures\n        exists|y| g(y),\n{\n\nproof fn choose_example()\n    requires\n        exists|x| g(x),\n{\n\nproof fn cost_example()\n    requires\n        f(1, 2),\n        forall|x, y| #[trigger] f(x, y) <==> g(x) && g(y),\n        forall|z| #[trigger] g(z) == j(z + 2),\n{\n\nproof fn cost_example2()\n    requires\n        g(1),\n        g(2),\n        forall|x, y| f(x, y) <==> #[trigger] g(x) && #[trigger] g(y),\n        forall|z| #[trigger] g(z) == j(z + 2),\n{\n\nproof fn trigger_forever()\n    requires\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n    ensures\n        forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y),\n{\n\nproof fn trigger_forever2()\n    requires\n        forall|x: nat| g(x),\n        forall|x: nat, y: nat| h(x, y) == f(x, y),\n        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),\n    ensures\n        forall|x: nat, y: nat| x > 2318 && y < 100 ==> h(x, y),\n{"}}}, "all_snapshots": []}
{"id": "vectors_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn reverse(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n        invariant\n            length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\n#[verifier::loop_isolation(false)]\nfn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n        decreases i2 - i1,\n    {\n        let ghost d = i2 - i1;\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n        assert(i2 - i1 < d);\n    }\n    i1\n}\n\n#[verifier::loop_isolation(false)]\nfn reverse_no_spinoff(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n        invariant\n            length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\nfn pusher() -> Vec<u64> {\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(1);\n    v.push(2);\n    v.push(3);\n    v.push(4);\n    let ghost goal = Seq::new(5, |i: int| i as u64);\n    assert(v@ =~= goal);\n    assert(v[2] == 2);\n    v.pop();\n    v.push(4);\n    assert(v@ =~= goal);\n    v\n}\n\nuninterp spec fn uninterp_fn(x: u64) -> bool;\n\nfn pop_test(t: Vec<u64>)\n    requires\n        t.len() > 0,\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n{\n    let mut t = t;\n    let x = t.pop().unwrap();\n    assert(uninterp_fn(x));\n    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));\n}\n\nfn push_test(t: Vec<u64>, y: u64)\n    requires\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y),\n{\n    let mut t = t;\n    t.push(y);\n    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));\n}\n\n} // verus!\nfn main() {\n    let mut v = vec![0, 10, 20, 30, 40, 50, 60, 70, 80, 90];\n    println!(\"{}\", binary_search(&v, 70));\n    println!();\n    reverse(&mut v);\n    for x in v {\n        println!(\"{}\", x);\n    }\n\n    println!(\"Pushed 5 values:\");\n    for x in pusher() {\n        println!(\"{}\", x);\n    }\n}\n", "minimized_code": "use vstd::prelude::*;\n      verus! {\n     uninterp spec fn uninterp_fn(x: u64) -> bool;\n     fn pop_test(t: Vec<u64>)     requires         t.len() > 0,         forall|i: int|      \n#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n{\n   }\n     fn push_test(t: Vec<u64>, y: u64)     requires         forall|i: int|      \n#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y), {\n  }\n     }\n       fn main() {\n     }\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/vectors.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "verified", "verify_time_ms": 2074, "minimize_time_ms": 157954, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 158, "minimized_LOC": 14, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 4, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.08860759493670886}, "labeling": {"segments": {"exec": " fn push_test(t: Vec<u64>, y: u64)     requires         forall|i: int|      \n#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y), {\n\n fn main() {", "spec": "spec fn uninterp_fn(x: u64) -> bool;\n     fn pop_test(t: Vec<u64>)     requires         t.len() > 0,         forall|i: int|      \n#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n{\n\n     fn pop_test(t: Vec<u64>)     requires         t.len() > 0,         forall|i: int|      \n\n     fn push_test(t: Vec<u64>, y: u64)     requires         forall|i: int|      "}}}, "all_snapshots": ["// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn reverse(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n        invariant\n            length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\n#[verifier::loop_isolation(false)]\nfn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n        decreases i2 - i1,\n    {\n        let ghost d = i2 - i1;\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n        assert(i2 - i1 < d);\n    }\n    i1\n}\n\n#[verifier::loop_isolation(false)]\nfn reverse_no_spinoff(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n        invariant\n            length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\nfn pusher() -> Vec<u64> {\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(1);\n    v.push(2);\n    v.push(3);\n    v.push(4);\n    let ghost goal = Seq::new(5, |i: int| i as u64);\n    assert(v@ =~= goal);\n    assert(v[2] == 2);\n    v.pop();\n    v.push(4);\n    assert(v@ =~= goal);\n    v\n}\n\nuninterp spec fn uninterp_fn(x: u64) -> bool;\n\nfn pop_test(t: Vec<u64>)\n    requires\n        t.len() > 0,\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n{\n    let mut t = t;\n    let x = t.pop().unwrap();\n    assert(uninterp_fn(x));\n    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));\n}\n\nfn push_test(t: Vec<u64>, y: u64)\n    requires\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y),\n{\n    let mut t = t;\n    t.push(y);\n    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));\n}\n\n} // verus!\nfn main() {\n    let mut v = vec![0, 10, 20, 30, 40, 50, 60, 70, 80, 90];\n    println!(\"{}\", binary_search(&v, 70));\n    println!();\n    reverse(&mut v);\n    for x in v {\n        println!(\"{}\", x);\n    }\n\n    println!(\"Pushed 5 values:\");\n    for x in pusher() {\n        println!(\"{}\", x);\n    }\n}\n", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n      verus! {\n     uninterp spec fn uninterp_fn(x: u64) -> bool;\n     fn pop_test(t: Vec<u64>)     requires         t.len() > 0,         forall|i: int|      \n#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n{\n   }\n     fn push_test(t: Vec<u64>, y: u64)     requires         forall|i: int|      \n#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y), {\n  }\n     }\n       fn main() {\n     }\n", "use vstd::prelude::*;\n           fn main() {\n}\n", "use vstd;\nfn main() {}\n"]}
{"id": "verified_vec_cc0b9f7d", "original_code": "// rust_verify/tests/example.rs ignore --- intending to deprecate PPtr, should update this to raw_ptr\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::layout::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::ptr::*;\nuse vstd::*;\n\nverus! {\n\nstruct Vector<V> {\n    pub ptr: PPtr<V>,\n    pub len: usize,\n    pub capacity: usize,\n    pub elems: Tracked<Map<nat, PointsTo<V>>>,\n    pub rest: Tracked<PointsToRaw>,\n    pub dealloc: Tracked<DeallocRaw>,\n}\n\nimpl<V> Vector<V> {\n    pub closed spec fn well_formed(&self) -> bool {\n        &&& self.len <= self.capacity\n        &&& (forall|i: nat| 0 <= i < self.len ==> self.elems@.dom().contains(i))\n        &&& (forall|i: nat|\n            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.pptr == self.ptr.id()\n                + i as int * size_of::<V>())\n        &&& (forall|i: nat|\n            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.value.is_Some())\n        &&& self.rest@.is_range(\n            self.ptr.id() + self.len * size_of::<V>(),\n            (self.capacity - self.len) * size_of::<V>(),\n        )\n        &&& self.dealloc@@.pptr == self.ptr.id()\n        &&& self.dealloc@@.size == self.capacity * size_of::<V>()\n        &&& self.dealloc@@.align == align_of::<V>()\n        &&& is_sized::<V>()\n    }\n\n    pub closed spec fn view(&self) -> Seq<V> {\n        Seq::new(self.len as nat, |i: int| self.elems@.index(i as nat)@.value.get_Some_0())\n    }\n\n    pub fn empty() -> (vec: Self)\n        requires\n            is_sized::<V>(),\n        ensures\n            vec.well_formed(),\n    {\n        layout_for_type_is_valid::<V>();\n        let (p, Tracked(points_to), Tracked(dealloc)) = PPtr::<V>::alloc(\n            0,\n            std::mem::align_of::<V>(),\n        );\n        Vector {\n            ptr: p,\n            len: 0,\n            capacity: 0,\n            elems: Tracked(Map::tracked_empty()),\n            rest: Tracked(points_to),\n            dealloc: Tracked(dealloc),\n        }\n    }\n\n    pub fn index(&self, i: usize) -> (elem: &V)\n        requires\n            self.well_formed(),\n            0 <= i < self@.len(),\n        ensures\n            *elem === self@.index(i as int),\n    {\n        let ptr_usize = self.ptr.to_usize();\n        assume((i as int * size_of::<V>()) as usize as int == (i as int * size_of::<V>()));\n        assume((ptr_usize as int + i as int * size_of::<V>()) as usize as int == (ptr_usize as int\n            + i as int * size_of::<V>()));\n        let elem_ptr_usize = ptr_usize + i * std::mem::size_of::<V>();\n        let elem_ptr = PPtr::<V>::from_usize(elem_ptr_usize);\n        let tracked perm = self.elems.borrow().tracked_borrow(i as nat);\n        elem_ptr.borrow(Tracked(perm))\n    }\n\n    pub fn resize(&mut self, new_capacity: usize)\n        requires\n            old(self).well_formed(),\n            old(self).len <= new_capacity,\n        ensures\n            self.well_formed(),\n            old(self)@ === self@,\n            self.capacity === new_capacity,\n    {\n        // TODO implement\n        assume(false);\n    }\n\n    pub fn push(&mut self, v: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self@ === old(self)@.push(v),\n    {\n        if self.len == self.capacity {\n            assume((self.capacity as int * 2) as usize as int == (self.capacity as int * 2));\n            let new_cap = if self.capacity == 0 {\n                2\n            } else {\n                self.capacity * 2\n            };\n            self.resize(new_cap);\n            assert((if self.capacity == 0 {\n                2\n            } else {\n                self.capacity * 2\n            }) > self.capacity) by (nonlinear_arith);\n            assert(new_cap > old(self).capacity);\n            assert(self@.len() == old(self)@.len());\n            assert(self.len == old(self).len);\n            assert(self.len < self.capacity);\n        }\n        assert(self.len < self.capacity);\n        let tracked mut points_to;\n        proof {\n            let tracked mut rest = PointsToRaw::empty();\n            tracked_swap(&mut rest, self.rest.borrow_mut());\n            assert(size_of::<V>() as int <= (self.capacity - self.len) * size_of::<V>()) by {\n                assert((self.capacity - self.len) >= 1 ==> size_of::<V>() as int <= (self.capacity\n                    - self.len) * size_of::<V>()) by (nonlinear_arith);\n            }\n            assert(rest.is_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                (self.capacity - self.len) * size_of::<V>(),\n            ));\n            assert(rest@.dom() == crate::set_lib::set_int_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                self.ptr.id() + self.len * size_of::<V>() + (self.capacity - self.len) * size_of::<\n                    V,\n                >(),\n            ));\n            let item_range = crate::set_lib::set_int_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                self.ptr.id() + self.len * size_of::<V>() + size_of::<V>() as int,\n            );\n            assert(item_range.subset_of(rest@.dom()));\n            let tracked (points_to_raw, mut rest) = rest.split(item_range);\n            assume((self.ptr.id() + self.len * size_of::<V>()) % align_of::<V>() as int == 0);\n            points_to = points_to_raw.into_typed::<V>(self.ptr.id() + self.len * size_of::<V>());\n            tracked_swap(&mut rest, self.rest.borrow_mut());\n        }\n        let i = self.len;\n        let ptr_usize = self.ptr.to_usize();\n        assume((i as int * size_of::<V>()) as usize as int == (i as int * size_of::<V>()));\n        assume((ptr_usize as int + i as int * size_of::<V>()) as usize as int == (ptr_usize as int\n            + i as int * size_of::<V>()));\n        let elem_ptr_usize = ptr_usize + i * std::mem::size_of::<V>();\n        let elem_ptr = PPtr::<V>::from_usize(elem_ptr_usize);\n        elem_ptr.put(Tracked(&mut points_to), v);\n        proof {\n            self.elems.borrow_mut().tracked_insert(self.len as nat, points_to);\n        }\n        self.len = self.len + 1;\n        proof {\n            assert_seqs_equal!(self@, old(self)@.push(v));\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "minimized_code": "// rust_verify/tests/example.rs ignore --- intending to deprecate PPtr, should update this to raw_ptr\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::layout::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::ptr::*;\nuse vstd::*;\n\nverus! {\n\nstruct Vector<V> {\n    pub ptr: PPtr<V>,\n    pub len: usize,\n    pub capacity: usize,\n    pub elems: Tracked<Map<nat, PointsTo<V>>>,\n    pub rest: Tracked<PointsToRaw>,\n    pub dealloc: Tracked<DeallocRaw>,\n}\n\nimpl<V> Vector<V> {\n    pub closed spec fn well_formed(&self) -> bool {\n        &&& self.len <= self.capacity\n        &&& (forall|i: nat| 0 <= i < self.len ==> self.elems@.dom().contains(i))\n        &&& (forall|i: nat|\n            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.pptr == self.ptr.id()\n                + i as int * size_of::<V>())\n        &&& (forall|i: nat|\n            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.value.is_Some())\n        &&& self.rest@.is_range(\n            self.ptr.id() + self.len * size_of::<V>(),\n            (self.capacity - self.len) * size_of::<V>(),\n        )\n        &&& self.dealloc@@.pptr == self.ptr.id()\n        &&& self.dealloc@@.size == self.capacity * size_of::<V>()\n        &&& self.dealloc@@.align == align_of::<V>()\n        &&& is_sized::<V>()\n    }\n\n    pub closed spec fn view(&self) -> Seq<V> {\n        Seq::new(self.len as nat, |i: int| self.elems@.index(i as nat)@.value.get_Some_0())\n    }\n\n    pub fn empty() -> (vec: Self)\n        requires\n            is_sized::<V>(),\n        ensures\n            vec.well_formed(),\n    {\n        layout_for_type_is_valid::<V>();\n        let (p, Tracked(points_to), Tracked(dealloc)) = PPtr::<V>::alloc(\n            0,\n            std::mem::align_of::<V>(),\n        );\n        Vector {\n            ptr: p,\n            len: 0,\n            capacity: 0,\n            elems: Tracked(Map::tracked_empty()),\n            rest: Tracked(points_to),\n            dealloc: Tracked(dealloc),\n        }\n    }\n\n    pub fn index(&self, i: usize) -> (elem: &V)\n        requires\n            self.well_formed(),\n            0 <= i < self@.len(),\n        ensures\n            *elem === self@.index(i as int),\n    {\n        let ptr_usize = self.ptr.to_usize();\n        assume((i as int * size_of::<V>()) as usize as int == (i as int * size_of::<V>()));\n        assume((ptr_usize as int + i as int * size_of::<V>()) as usize as int == (ptr_usize as int\n            + i as int * size_of::<V>()));\n        let elem_ptr_usize = ptr_usize + i * std::mem::size_of::<V>();\n        let elem_ptr = PPtr::<V>::from_usize(elem_ptr_usize);\n        let tracked perm = self.elems.borrow().tracked_borrow(i as nat);\n        elem_ptr.borrow(Tracked(perm))\n    }\n\n    pub fn resize(&mut self, new_capacity: usize)\n        requires\n            old(self).well_formed(),\n            old(self).len <= new_capacity,\n        ensures\n            self.well_formed(),\n            old(self)@ === self@,\n            self.capacity === new_capacity,\n    {\n        // TODO implement\n        assume(false);\n    }\n\n    pub fn push(&mut self, v: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self@ === old(self)@.push(v),\n    {\n        if self.len == self.capacity {\n            assume((self.capacity as int * 2) as usize as int == (self.capacity as int * 2));\n            let new_cap = if self.capacity == 0 {\n                2\n            } else {\n                self.capacity * 2\n            };\n            self.resize(new_cap);\n            assert((if self.capacity == 0 {\n                2\n            } else {\n                self.capacity * 2\n            }) > self.capacity) by (nonlinear_arith);\n            assert(new_cap > old(self).capacity);\n            assert(self@.len() == old(self)@.len());\n            assert(self.len == old(self).len);\n            assert(self.len < self.capacity);\n        }\n        assert(self.len < self.capacity);\n        let tracked mut points_to;\n        proof {\n            let tracked mut rest = PointsToRaw::empty();\n            tracked_swap(&mut rest, self.rest.borrow_mut());\n            assert(size_of::<V>() as int <= (self.capacity - self.len) * size_of::<V>()) by {\n                assert((self.capacity - self.len) >= 1 ==> size_of::<V>() as int <= (self.capacity\n                    - self.len) * size_of::<V>()) by (nonlinear_arith);\n            }\n            assert(rest.is_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                (self.capacity - self.len) * size_of::<V>(),\n            ));\n            assert(rest@.dom() == crate::set_lib::set_int_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                self.ptr.id() + self.len * size_of::<V>() + (self.capacity - self.len) * size_of::<\n                    V,\n                >(),\n            ));\n            let item_range = crate::set_lib::set_int_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                self.ptr.id() + self.len * size_of::<V>() + size_of::<V>() as int,\n            );\n            assert(item_range.subset_of(rest@.dom()));\n            let tracked (points_to_raw, mut rest) = rest.split(item_range);\n            assume((self.ptr.id() + self.len * size_of::<V>()) % align_of::<V>() as int == 0);\n            points_to = points_to_raw.into_typed::<V>(self.ptr.id() + self.len * size_of::<V>());\n            tracked_swap(&mut rest, self.rest.borrow_mut());\n        }\n        let i = self.len;\n        let ptr_usize = self.ptr.to_usize();\n        assume((i as int * size_of::<V>()) as usize as int == (i as int * size_of::<V>()));\n        assume((ptr_usize as int + i as int * size_of::<V>()) as usize as int == (ptr_usize as int\n            + i as int * size_of::<V>()));\n        let elem_ptr_usize = ptr_usize + i * std::mem::size_of::<V>();\n        let elem_ptr = PPtr::<V>::from_usize(elem_ptr_usize);\n        elem_ptr.put(Tracked(&mut points_to), v);\n        proof {\n            self.elems.borrow_mut().tracked_insert(self.len as nat, points_to);\n        }\n        self.len = self.len + 1;\n        proof {\n            assert_seqs_equal!(self@, old(self)@.push(v));\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "metadata": {"provenance": {"source_repo": "https://github.com/verus-lang/verus.git", "file_path": "/Users/ameliakuang/Repos/dep_verus/examples/verified_vec.rs", "commit_sha": "cc0b9f7d9a715e7ccac4539d9838452dc29e8207"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 220, "verus_errors": [{"error_type": "Other", "error_text": "unresolved import `vstd::ptr` (could not find `ptr` in `vstd`)", "message": "VerusErrorType.Other: unresolved import `vstd::ptr` (could not find `ptr` in `vstd`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpc4b2xdxc", "lines": [9, 9], "label": "could not find `ptr` in `vstd`", "text": [{"text": "use vstd::ptr::*;", "highlight_start": 11, "highlight_end": 14}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 171, "minimized_LOC": 171, "self_contained": true, "dependencies": ["verus_builtin::", "verus_builtin_macros::", "vstd::layout::", "vstd::modes::", "vstd::prelude::", "vstd::ptr::", "vstd::"], "complexity_verus_tokens": 15, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": " pub fn empty() -> (vec: Self)\n        requires\n            is_sized::<V>(),\n        ensures\n            vec.well_formed(),\n    {\n\n pub fn index(&self, i: usize) -> (elem: &V)\n        requires\n            self.well_formed(),\n            0 <= i < self@.len(),\n        ensures\n            *elem === self@.index(i as int),\n    {\n\n pub fn resize(&mut self, new_capacity: usize)\n        requires\n            old(self).well_formed(),\n            old(self).len <= new_capacity,\n        ensures\n            self.well_formed(),\n            old(self)@ === self@,\n            self.capacity === new_capacity,\n    {\n\n pub fn push(&mut self, v: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self@ === old(self)@.push(v),\n    {\n\n\nfn main() {", "spec": "spec fn well_formed(&self) -> bool {\n\nspec fn view(&self) -> Seq<V> {\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures\n\n        requires\n\n        ensures", "proof": "proof {\n            let tracked mut rest = PointsToRaw::empty();\n            tracked_swap(&mut rest, self.rest.borrow_mut());\n            assert(size_of::<V>() as int <= (self.capacity - self.len) * size_of::<V>()) by {\n                assert((self.capacity - self.len) >= 1 ==> size_of::<V>() as int <= (self.capacity\n                    - self.len) * size_of::<V>()) by (nonlinear_arith);\n            }\n            assert(rest.is_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                (self.capacity - self.len) * size_of::<V>(),\n            ));\n            assert(rest@.dom() == crate::set_lib::set_int_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                self.ptr.id() + self.len * size_of::<V>() + (self.capacity - self.len) * size_of::<\n                    V,\n                >(),\n            ));\n            let item_range = crate::set_lib::set_int_range(\n                self.ptr.id() + self.len * size_of::<V>(),\n                self.ptr.id() + self.len * size_of::<V>() + size_of::<V>() as int,\n            );\n            assert(item_range.subset_of(rest@.dom()));\n            let tracked (points_to_raw, mut rest) = rest.split(item_range);\n            assume((self.ptr.id() + self.len * size_of::<V>()) % align_of::<V>() as int == 0);\n            points_to = points_to_raw.into_typed::<V>(self.ptr.id() + self.len * size_of::<V>());\n            tracked_swap(&mut rest, self.rest.borrow_mut());\n        }\n\nproof {\n            self.elems.borrow_mut().tracked_insert(self.len as nat, points_to);\n        }\n\nproof {\n            assert_seqs_equal!(self@, old(self)@.push(v));\n        }"}}}, "all_snapshots": []}
