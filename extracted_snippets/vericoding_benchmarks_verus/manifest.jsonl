{"id": "apps_test_1_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_digits(x: int) -> Seq<int>\n  recommends x >= 0\n{\n  if x == 0 { seq![0] }\n  else { int_to_digits_helper(x) }\n}\n\nspec fn int_to_digits_helper(x: int) -> Seq<int>\n  recommends x > 0\n  decreases x\n{\n  if x < 10 { seq![x] }\n  else { int_to_digits_helper(x / 10).add(seq![x % 10]) }\n}\n\nspec fn digit_sum(digits: Seq<int>) -> int\n  decreases digits.len()\n{\n  if digits.len() == 0 { 0 }\n  else { digits[0] + digit_sum(digits.subrange(1, digits.len() as int)) }\n}\n\nspec fn valid_input(x: int) -> bool\n{\n  x >= 1\n}\n\nspec fn valid_result(x: int, result: int) -> bool\n  recommends valid_input(x)\n{\n  result > 0 &&\n  result <= x &&\n  (forall|y: int| 1 <= y <= x ==> digit_sum(int_to_digits(y)) <= digit_sum(int_to_digits(result))) &&\n  (forall|y: int| 1 <= y <= x && digit_sum(int_to_digits(y)) == digit_sum(int_to_digits(result)) ==> y <= result)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8) -> (result: i8)\n  requires valid_input(x as int)\n  ensures valid_result(x as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_digits(x: int) -> Seq<int>\n  recommends x >= 0\n{\n  if x == 0 { seq![0] }\n  else { int_to_digits_helper(x) }\n}\n\nspec fn int_to_digits_helper(x: int) -> Seq<int>\n  recommends x > 0\n  decreases x\n{\n  if x < 10 { seq![x] }\n  else { int_to_digits_helper(x / 10).add(seq![x % 10]) }\n}\n\nspec fn digit_sum(digits: Seq<int>) -> int\n  decreases digits.len()\n{\n  if digits.len() == 0 { 0 }\n  else { digits[0] + digit_sum(digits.subrange(1, digits.len() as int)) }\n}\n\nspec fn valid_input(x: int) -> bool\n{\n  x >= 1\n}\n\nspec fn valid_result(x: int, result: int) -> bool\n  recommends valid_input(x)\n{\n  result > 0 &&\n  result <= x &&\n  (forall|y: int| 1 <= y <= x ==> digit_sum(int_to_digits(y)) <= digit_sum(int_to_digits(result))) &&\n  (forall|y: int| 1 <= y <= x && digit_sum(int_to_digits(y)) == digit_sum(int_to_digits(result)) ==> y <= result)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8) -> (result: i8)\n  requires valid_input(x as int)\n  ensures valid_result(x as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 952, "minimize_time_ms": 122551, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn int_to_digits(x: int) -> Seq<int>\n  recommends x >= 0\n{\n\nspec fn int_to_digits_helper(x: int) -> Seq<int>\n  recommends x > 0\n  decreases x\n{\n\nspec fn digit_sum(digits: Seq<int>) -> int\n  decreases digits.len()\n{\n\nspec fn valid_input(x: int) -> bool\n{\n\nspec fn valid_result(x: int, result: int) -> bool\n  recommends valid_input(x)\n{\n\n  decreases x\n\n  decreases digits.len()\n\n  requires valid_input(x as int)\n\n  ensures valid_result(x as int, result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_digits(x: int) -> Seq<int>\n  recommends x >= 0\n{\n  if x == 0 { seq![0] }\n  else { int_to_digits_helper(x) }\n}\n\nspec fn int_to_digits_helper(x: int) -> Seq<int>\n  recommends x > 0\n  decreases x\n{\n  if x < 10 { seq![x] }\n  else { int_to_digits_helper(x / 10).add(seq![x % 10]) }\n}\n\nspec fn digit_sum(digits: Seq<int>) -> int\n  decreases digits.len()\n{\n  if digits.len() == 0 { 0 }\n  else { digits[0] + digit_sum(digits.subrange(1, digits.len() as int)) }\n}\n\nspec fn valid_input(x: int) -> bool\n{\n  x >= 1\n}\n\nspec fn valid_result(x: int, result: int) -> bool\n  recommends valid_input(x)\n{\n  result > 0 &&\n  result <= x &&\n  (forall|y: int| 1 <= y <= x ==> digit_sum(int_to_digits(y)) <= digit_sum(int_to_digits(result))) &&\n  (forall|y: int| 1 <= y <= x && digit_sum(int_to_digits(y)) == digit_sum(int_to_digits(result)) ==> y <= result)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8) -> (result: i8)\n  requires valid_input(x as int)\n  ensures valid_result(x as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_10_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn min_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let min_additional = if remaining_days > 5 { remaining_days - 5 } else { 0 };\n  2 * complete_weeks + min_additional\n}\n\nspec fn max_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let max_additional = if remaining_days < 2 { remaining_days } else { 2 };\n  2 * complete_weeks + max_additional\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n  result.len() == 2 &&\n  result[0] >= 0 && result[1] >= 0 &&\n  result[0] <= result[1] &&\n  result[0] <= n && result[1] <= n &&\n  result[0] == min_days_off(n) &&\n  result[1] == max_days_off(n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn min_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let min_additional = if remaining_days > 5 { remaining_days - 5 } else { 0 };\n  2 * complete_weeks + min_additional\n}\n\nspec fn max_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let max_additional = if remaining_days < 2 { remaining_days } else { 2 };\n  2 * complete_weeks + max_additional\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n  result.len() == 2 &&\n  result[0] >= 0 && result[1] >= 0 &&\n  result[0] <= result[1] &&\n  result[0] <= n && result[1] <= n &&\n  result[0] == min_days_off(n) &&\n  result[1] == max_days_off(n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_10.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 974, "minimize_time_ms": 122709, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn min_days_off(n: int) -> int {\n\nspec fn max_days_off(n: int) -> int {\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n\n  requires valid_input(n as int)\n\n  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn min_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let min_additional = if remaining_days > 5 { remaining_days - 5 } else { 0 };\n  2 * complete_weeks + min_additional\n}\n\nspec fn max_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let max_additional = if remaining_days < 2 { remaining_days } else { 2 };\n  2 * complete_weeks + max_additional\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n  result.len() == 2 &&\n  result[0] >= 0 && result[1] >= 0 &&\n  result[0] <= result[1] &&\n  result[0] <= n && result[1] <= n &&\n  result[0] == min_days_off(n) &&\n  result[1] == max_days_off(n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1002_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {\n    1 <= n <= 100 && 1 <= d <= 10000 &&\n    t.len() == n &&\n    forall|i: int| 0 <= i < t.len() ==> #[trigger] t[i] >= 1 && #[trigger] t[i] <= 100\n}\n\nspec fn min_time_needed(n: int, t: Seq<int>) -> int {\n    sum_seq(t) + 10 * (n - 1)\n}\n\nspec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {\n    let song_sum = sum_seq(t);\n    let min_time = min_time_needed(n, t);\n    if min_time > d {\n        result == -1\n    } else {\n        result == (d - song_sum) / 5 && result >= 0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, t: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))\n    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {\n    1 <= n <= 100 && 1 <= d <= 10000 &&\n    t.len() == n &&\n    forall|i: int| 0 <= i < t.len() ==> #[trigger] t[i] >= 1 && #[trigger] t[i] <= 100\n}\n\nspec fn min_time_needed(n: int, t: Seq<int>) -> int {\n    sum_seq(t) + 10 * (n - 1)\n}\n\nspec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {\n    let song_sum = sum_seq(t);\n    let min_time = min_time_needed(n, t);\n    if min_time > d {\n        result == -1\n    } else {\n        result == (d - song_sum) / 5 && result >= 0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, t: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))\n    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1002.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 739, "minimize_time_ms": 122666, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {\n\nspec fn min_time_needed(n: int, t: Seq<int>) -> int {\n\nspec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {\n\n    decreases s.len()\n\n    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))\n\n    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {\n    1 <= n <= 100 && 1 <= d <= 10000 &&\n    t.len() == n &&\n    forall|i: int| 0 <= i < t.len() ==> #[trigger] t[i] >= 1 && #[trigger] t[i] <= 100\n}\n\nspec fn min_time_needed(n: int, t: Seq<int>) -> int {\n    sum_seq(t) + 10 * (n - 1)\n}\n\nspec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {\n    let song_sum = sum_seq(t);\n    let min_time = min_time_needed(n, t);\n    if min_time > d {\n        result == -1\n    } else {\n        result == (d - song_sum) / 5 && result >= 0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, t: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))\n    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1007_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]])\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn sum_of_palindromes(k: int) -> int\n    decreases k\n{\n    if k <= 0 {\n        0\n    } else if k == 1 {\n        let s = int_to_string(1);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome)\n    } else {\n        let s = int_to_string(k);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome) + sum_of_palindromes(k - 1)\n    }\n}\n\nspec fn valid_input(k: int, p: int) -> bool {\n    k >= 1 && p >= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, p: i8) -> (result: i8)\n    requires\n        valid_input(k as int, p as int),\n    ensures\n        0 <= result < p,\n        result as int == (sum_of_palindromes(k as int) % (p as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]])\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn sum_of_palindromes(k: int) -> int\n    decreases k\n{\n    if k <= 0 {\n        0\n    } else if k == 1 {\n        let s = int_to_string(1);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome)\n    } else {\n        let s = int_to_string(k);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome) + sum_of_palindromes(k - 1)\n    }\n}\n\nspec fn valid_input(k: int, p: int) -> bool {\n    k >= 1 && p >= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, p: i8) -> (result: i8)\n    requires\n        valid_input(k as int, p as int),\n    ensures\n        0 <= result < p,\n        result as int == (sum_of_palindromes(k as int) % (p as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1007.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 648, "minimize_time_ms": 122765, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 84, "minimized_LOC": 84, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn sum_of_palindromes(k: int) -> int\n    decreases k\n{\n\nspec fn valid_input(k: int, p: int) -> bool {\n\n    decreases n\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases k\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]])\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn sum_of_palindromes(k: int) -> int\n    decreases k\n{\n    if k <= 0 {\n        0\n    } else if k == 1 {\n        let s = int_to_string(1);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome)\n    } else {\n        let s = int_to_string(k);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome) + sum_of_palindromes(k - 1)\n    }\n}\n\nspec fn valid_input(k: int, p: int) -> bool {\n    k >= 1 && p >= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, p: i8) -> (result: i8)\n    requires\n        valid_input(k as int, p as int),\n    ensures\n        0 <= result < p,\n        result as int == (sum_of_palindromes(k as int) % (p as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1009_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && n <= 2*k &&\n    l.len() == n &&\n    forall|i: int, j: int| 0 <= i < l.len()-1 && j == i+1 ==> #[trigger] l[i] <= #[trigger] l[j] &&\n    (forall|i: int| 0 <= i < l.len() ==> #[trigger] l[i] >= 0)\n}\n\nspec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {\n    boxes.len() >= 1 &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] <= box_size) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] >= 0)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        s[0] \n    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) { \n        s[0] \n    } else { \n        max_seq(s.subrange(1, s.len() as int)) \n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && n <= 2*k &&\n    l.len() == n &&\n    forall|i: int, j: int| 0 <= i < l.len()-1 && j == i+1 ==> #[trigger] l[i] <= #[trigger] l[j] &&\n    (forall|i: int| 0 <= i < l.len() ==> #[trigger] l[i] >= 0)\n}\n\nspec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {\n    boxes.len() >= 1 &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] <= box_size) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] >= 0)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        s[0] \n    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) { \n        s[0] \n    } else { \n        max_seq(s.subrange(1, s.len() as int)) \n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1009.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 759, "minimize_time_ms": 123308, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {\n\nspec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn max_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))\n\n    ensures result >= 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && n <= 2*k &&\n    l.len() == n &&\n    forall|i: int, j: int| 0 <= i < l.len()-1 && j == i+1 ==> #[trigger] l[i] <= #[trigger] l[j] &&\n    (forall|i: int| 0 <= i < l.len() ==> #[trigger] l[i] >= 0)\n}\n\nspec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {\n    boxes.len() >= 1 &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] <= box_size) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] >= 0)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        s[0] \n    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) { \n        s[0] \n    } else { \n        max_seq(s.subrange(1, s.len() as int)) \n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1014_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 2\n}\n\nspec fn is_win_for_white(n: int) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_win_for_black(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn optimal_white_move(n: int) -> (int, int)\n    recommends valid_input(n) && is_win_for_white(n)\n{\n    (1, 2)\n}\n\nspec fn valid_result(n: int, result: String) -> bool\n    recommends valid_input(n)\n{\n    if is_win_for_black(n) {\n        result@ == \"black\\n\"@\n    } else {\n        result@ == \"white\\n1 2\\n\"@\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: String)\n    requires valid_input(n as int)\n    ensures valid_result(n as int, result)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 2\n}\n\nspec fn is_win_for_white(n: int) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_win_for_black(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn optimal_white_move(n: int) -> (int, int)\n    recommends valid_input(n) && is_win_for_white(n)\n{\n    (1, 2)\n}\n\nspec fn valid_result(n: int, result: String) -> bool\n    recommends valid_input(n)\n{\n    if is_win_for_black(n) {\n        result@ == \"black\\n\"@\n    } else {\n        result@ == \"white\\n1 2\\n\"@\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: String)\n    requires valid_input(n as int)\n    ensures valid_result(n as int, result)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1014.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 727, "minimize_time_ms": 122192, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::string::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn is_win_for_white(n: int) -> bool {\n\nspec fn is_win_for_black(n: int) -> bool {\n\nspec fn optimal_white_move(n: int) -> (int, int)\n    recommends valid_input(n) && is_win_for_white(n)\n{\n\nspec fn valid_result(n: int, result: String) -> bool\n    recommends valid_input(n)\n{\n\n    requires valid_input(n as int)\n\n    ensures valid_result(n as int, result)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 2\n}\n\nspec fn is_win_for_white(n: int) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_win_for_black(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn optimal_white_move(n: int) -> (int, int)\n    recommends valid_input(n) && is_win_for_white(n)\n{\n    (1, 2)\n}\n\nspec fn valid_result(n: int, result: String) -> bool\n    recommends valid_input(n)\n{\n    if is_win_for_black(n) {\n        result@ == \"black\\n\"@\n    } else {\n        result@ == \"white\\n1 2\\n\"@\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: String)\n    requires valid_input(n as int)\n    ensures valid_result(n as int, result)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_102_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    is_valid_integer_string(s) && \n    { let n = parse_integer(s); 0 <= n <= 99 }\n}\n\nspec fn correct_english_word(n: int) -> Seq<char> {\n    if n == 0 { seq!['z', 'e', 'r', 'o'] }\n    else if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else if n == 10 { seq!['t', 'e', 'n'] }\n    else if n == 11 { seq!['e', 'l', 'e', 'v', 'e', 'n'] }\n    else if n == 12 { seq!['t', 'w', 'e', 'l', 'v', 'e'] }\n    else if n == 13 { seq!['t', 'h', 'i', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 14 { seq!['f', 'o', 'u', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 15 { seq!['f', 'i', 'f', 't', 'e', 'e', 'n'] }\n    else if n == 16 { seq!['s', 'i', 'x', 't', 'e', 'e', 'n'] }\n    else if n == 17 { seq!['s', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n'] }\n    else if n == 18 { seq!['e', 'i', 'g', 'h', 't', 'e', 'e', 'n'] }\n    else if n == 19 { seq!['n', 'i', 'n', 'e', 't', 'e', 'e', 'n'] }\n    else if n == 20 { seq!['t', 'w', 'e', 'n', 't', 'y'] }\n    else if n == 30 { seq!['t', 'h', 'i', 'r', 't', 'y'] }\n    else if n == 40 { seq!['f', 'o', 'r', 't', 'y'] }\n    else if n == 50 { seq!['f', 'i', 'f', 't', 'y'] }\n    else if n == 60 { seq!['s', 'i', 'x', 't', 'y'] }\n    else if n == 70 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y'] }\n    else if n == 80 { seq!['e', 'i', 'g', 'h', 't', 'y'] }\n    else if n == 90 { seq!['n', 'i', 'n', 'e', 't', 'y'] }\n    else if 21 <= n <= 29 { seq!['t', 'w', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 31 <= n <= 39 { seq!['t', 'h', 'i', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 41 <= n <= 49 { seq!['f', 'o', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 51 <= n <= 59 { seq!['f', 'i', 'f', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 61 <= n <= 69 { seq!['s', 'i', 'x', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 71 <= n <= 79 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 81 <= n <= 89 { seq!['e', 'i', 'g', 'h', 't', 'y', '-'] + unit_word(n % 10) }\n    else { seq!['n', 'i', 'n', 'e', 't', 'y', '-'] + unit_word(n % 10) }\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    (s.len() >= 1 && s.len() <= 3 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9') ||\n    (s.len() >= 2 && s.len() <= 4 && s[s.len() - 1] == '\\n' && forall|i: int| 0 <= i < s.len() - 1 ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    if s[s.len() - 1] == '\\n' {\n        parse_integer_helper(s.subrange(0, s.len() - 1))\n    } else {\n        parse_integer_helper(s)\n    }\n}\n\nspec fn parse_integer_helper(s: Seq<char>) -> int {\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() == 2 {\n        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))\n    } else {\n        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))\n    }\n}\n\nspec fn unit_word(n: int) -> Seq<char> {\n    if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else { seq![] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let n = parse_integer(stdin_input@);\n            result@ == correct_english_word(n) + seq!['\\n']\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    is_valid_integer_string(s) && \n    { let n = parse_integer(s); 0 <= n <= 99 }\n}\n\nspec fn correct_english_word(n: int) -> Seq<char> {\n    if n == 0 { seq!['z', 'e', 'r', 'o'] }\n    else if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else if n == 10 { seq!['t', 'e', 'n'] }\n    else if n == 11 { seq!['e', 'l', 'e', 'v', 'e', 'n'] }\n    else if n == 12 { seq!['t', 'w', 'e', 'l', 'v', 'e'] }\n    else if n == 13 { seq!['t', 'h', 'i', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 14 { seq!['f', 'o', 'u', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 15 { seq!['f', 'i', 'f', 't', 'e', 'e', 'n'] }\n    else if n == 16 { seq!['s', 'i', 'x', 't', 'e', 'e', 'n'] }\n    else if n == 17 { seq!['s', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n'] }\n    else if n == 18 { seq!['e', 'i', 'g', 'h', 't', 'e', 'e', 'n'] }\n    else if n == 19 { seq!['n', 'i', 'n', 'e', 't', 'e', 'e', 'n'] }\n    else if n == 20 { seq!['t', 'w', 'e', 'n', 't', 'y'] }\n    else if n == 30 { seq!['t', 'h', 'i', 'r', 't', 'y'] }\n    else if n == 40 { seq!['f', 'o', 'r', 't', 'y'] }\n    else if n == 50 { seq!['f', 'i', 'f', 't', 'y'] }\n    else if n == 60 { seq!['s', 'i', 'x', 't', 'y'] }\n    else if n == 70 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y'] }\n    else if n == 80 { seq!['e', 'i', 'g', 'h', 't', 'y'] }\n    else if n == 90 { seq!['n', 'i', 'n', 'e', 't', 'y'] }\n    else if 21 <= n <= 29 { seq!['t', 'w', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 31 <= n <= 39 { seq!['t', 'h', 'i', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 41 <= n <= 49 { seq!['f', 'o', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 51 <= n <= 59 { seq!['f', 'i', 'f', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 61 <= n <= 69 { seq!['s', 'i', 'x', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 71 <= n <= 79 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 81 <= n <= 89 { seq!['e', 'i', 'g', 'h', 't', 'y', '-'] + unit_word(n % 10) }\n    else { seq!['n', 'i', 'n', 'e', 't', 'y', '-'] + unit_word(n % 10) }\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    (s.len() >= 1 && s.len() <= 3 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9') ||\n    (s.len() >= 2 && s.len() <= 4 && s[s.len() - 1] == '\\n' && forall|i: int| 0 <= i < s.len() - 1 ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    if s[s.len() - 1] == '\\n' {\n        parse_integer_helper(s.subrange(0, s.len() - 1))\n    } else {\n        parse_integer_helper(s)\n    }\n}\n\nspec fn parse_integer_helper(s: Seq<char>) -> int {\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() == 2 {\n        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))\n    } else {\n        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))\n    }\n}\n\nspec fn unit_word(n: int) -> Seq<char> {\n    if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else { seq![] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let n = parse_integer(stdin_input@);\n            result@ == correct_english_word(n) + seq!['\\n']\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_102.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 720, "minimize_time_ms": 122263, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 113, "minimized_LOC": 113, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn correct_english_word(n: int) -> Seq<char> {\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n\nspec fn parse_integer(s: Seq<char>) -> int {\n\nspec fn parse_integer_helper(s: Seq<char>) -> int {\n\nspec fn unit_word(n: int) -> Seq<char> {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    is_valid_integer_string(s) && \n    { let n = parse_integer(s); 0 <= n <= 99 }\n}\n\nspec fn correct_english_word(n: int) -> Seq<char> {\n    if n == 0 { seq!['z', 'e', 'r', 'o'] }\n    else if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else if n == 10 { seq!['t', 'e', 'n'] }\n    else if n == 11 { seq!['e', 'l', 'e', 'v', 'e', 'n'] }\n    else if n == 12 { seq!['t', 'w', 'e', 'l', 'v', 'e'] }\n    else if n == 13 { seq!['t', 'h', 'i', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 14 { seq!['f', 'o', 'u', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 15 { seq!['f', 'i', 'f', 't', 'e', 'e', 'n'] }\n    else if n == 16 { seq!['s', 'i', 'x', 't', 'e', 'e', 'n'] }\n    else if n == 17 { seq!['s', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n'] }\n    else if n == 18 { seq!['e', 'i', 'g', 'h', 't', 'e', 'e', 'n'] }\n    else if n == 19 { seq!['n', 'i', 'n', 'e', 't', 'e', 'e', 'n'] }\n    else if n == 20 { seq!['t', 'w', 'e', 'n', 't', 'y'] }\n    else if n == 30 { seq!['t', 'h', 'i', 'r', 't', 'y'] }\n    else if n == 40 { seq!['f', 'o', 'r', 't', 'y'] }\n    else if n == 50 { seq!['f', 'i', 'f', 't', 'y'] }\n    else if n == 60 { seq!['s', 'i', 'x', 't', 'y'] }\n    else if n == 70 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y'] }\n    else if n == 80 { seq!['e', 'i', 'g', 'h', 't', 'y'] }\n    else if n == 90 { seq!['n', 'i', 'n', 'e', 't', 'y'] }\n    else if 21 <= n <= 29 { seq!['t', 'w', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 31 <= n <= 39 { seq!['t', 'h', 'i', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 41 <= n <= 49 { seq!['f', 'o', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 51 <= n <= 59 { seq!['f', 'i', 'f', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 61 <= n <= 69 { seq!['s', 'i', 'x', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 71 <= n <= 79 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 81 <= n <= 89 { seq!['e', 'i', 'g', 'h', 't', 'y', '-'] + unit_word(n % 10) }\n    else { seq!['n', 'i', 'n', 'e', 't', 'y', '-'] + unit_word(n % 10) }\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    (s.len() >= 1 && s.len() <= 3 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9') ||\n    (s.len() >= 2 && s.len() <= 4 && s[s.len() - 1] == '\\n' && forall|i: int| 0 <= i < s.len() - 1 ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    if s[s.len() - 1] == '\\n' {\n        parse_integer_helper(s.subrange(0, s.len() - 1))\n    } else {\n        parse_integer_helper(s)\n    }\n}\n\nspec fn parse_integer_helper(s: Seq<char>) -> int {\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() == 2 {\n        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))\n    } else {\n        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))\n    }\n}\n\nspec fn unit_word(n: int) -> Seq<char> {\n    if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else { seq![] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let n = parse_integer(stdin_input@);\n            result@ == correct_english_word(n) + seq!['\\n']\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1028_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn comb2(n: int) -> int\n  recommends n >= 0\n{\n  n * (n - 1) / 2\n}\n\nspec fn valid_input(n: int, m: int) -> bool\n{\n  1 <= m <= n\n}\n\nspec fn min_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  let k = n / m;\n  let p = n % m;\n  p * comb2(k + 1) + (m - p) * comb2(k)\n}\n\nspec fn max_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  comb2(n - m + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: (i8, i8))\n  requires valid_input(n as int, m as int)\n  ensures \n      result.0 >= 0 &&\n      result.1 >= 0 &&\n      result.0 <= result.1 &&\n      result.0 == min_friendship_pairs(n as int, m as int) &&\n      result.1 == max_friendship_pairs(n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  (0, 0)\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn comb2(n: int) -> int\n  recommends n >= 0\n{\n  n * (n - 1) / 2\n}\n\nspec fn valid_input(n: int, m: int) -> bool\n{\n  1 <= m <= n\n}\n\nspec fn min_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  let k = n / m;\n  let p = n % m;\n  p * comb2(k + 1) + (m - p) * comb2(k)\n}\n\nspec fn max_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  comb2(n - m + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: (i8, i8))\n  requires valid_input(n as int, m as int)\n  ensures \n      result.0 >= 0 &&\n      result.1 >= 0 &&\n      result.0 <= result.1 &&\n      result.0 == min_friendship_pairs(n as int, m as int) &&\n      result.1 == max_friendship_pairs(n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  (0, 0)\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1028.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 653, "minimize_time_ms": 122851, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn comb2(n: int) -> int\n  recommends n >= 0\n{\n\nspec fn valid_input(n: int, m: int) -> bool\n{\n\nspec fn min_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n\nspec fn max_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n\n  requires valid_input(n as int, m as int)\n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn comb2(n: int) -> int\n  recommends n >= 0\n{\n  n * (n - 1) / 2\n}\n\nspec fn valid_input(n: int, m: int) -> bool\n{\n  1 <= m <= n\n}\n\nspec fn min_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  let k = n / m;\n  let p = n % m;\n  p * comb2(k + 1) + (m - p) * comb2(k)\n}\n\nspec fn max_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  comb2(n - m + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: (i8, i8))\n  requires valid_input(n as int, m as int)\n  ensures \n      result.0 >= 0 &&\n      result.1 >= 0 &&\n      result.0 <= result.1 &&\n      result.0 == min_friendship_pairs(n as int, m as int) &&\n      result.1 == max_friendship_pairs(n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  (0, 0)\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1038_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(a: int, b: int) -> bool {\n        0 <= a <= b\n    }\n    \n    spec fn xor_int(x: int, y: int) -> int\n        decreases x + y\n    {\n        if x >= 0 && y >= 0 {\n            if x == 0 && y == 0 { 0 }\n            else if x == 0 { y }\n            else if y == 0 { x }\n            else {\n                let bit_x = x % 2;\n                let bit_y = y % 2;\n                let xor_bit: int = if bit_x != bit_y { 1 } else { 0 };\n                xor_bit + 2 * xor_int(x / 2, y / 2)\n            }\n        } else {\n            0\n        }\n    }\n    \n    spec fn xor_range(a: int, b: int) -> int\n        decreases b - a\n    {\n        if 0 <= a <= b {\n            if a == b { a }\n            else { xor_int(a, xor_range(a + 1, b)) }\n        } else {\n            0\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i32, b: i32) -> (result: i32)\n    requires \n        a >= 0,\n        b >= 0,\n        a <= b\n    ensures \n        result >= 0,\n        result as int == xor_range(a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(a: int, b: int) -> bool {\n        0 <= a <= b\n    }\n    \n    spec fn xor_int(x: int, y: int) -> int\n        decreases x + y\n    {\n        if x >= 0 && y >= 0 {\n            if x == 0 && y == 0 { 0 }\n            else if x == 0 { y }\n            else if y == 0 { x }\n            else {\n                let bit_x = x % 2;\n                let bit_y = y % 2;\n                let xor_bit: int = if bit_x != bit_y { 1 } else { 0 };\n                xor_bit + 2 * xor_int(x / 2, y / 2)\n            }\n        } else {\n            0\n        }\n    }\n    \n    spec fn xor_range(a: int, b: int) -> int\n        decreases b - a\n    {\n        if 0 <= a <= b {\n            if a == b { a }\n            else { xor_int(a, xor_range(a + 1, b)) }\n        } else {\n            0\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i32, b: i32) -> (result: i32)\n    requires \n        a >= 0,\n        b >= 0,\n        a <= b\n    ensures \n        result >= 0,\n        result as int == xor_range(a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1038.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 911, "minimize_time_ms": 122762, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int) -> bool {\n\nspec fn xor_int(x: int, y: int) -> int\n        decreases x + y\n    {\n\nspec fn xor_range(a: int, b: int) -> int\n        decreases b - a\n    {\n\n        decreases x + y\n\n        decreases b - a\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(a: int, b: int) -> bool {\n        0 <= a <= b\n    }\n    \n    spec fn xor_int(x: int, y: int) -> int\n        decreases x + y\n    {\n        if x >= 0 && y >= 0 {\n            if x == 0 && y == 0 { 0 }\n            else if x == 0 { y }\n            else if y == 0 { x }\n            else {\n                let bit_x = x % 2;\n                let bit_y = y % 2;\n                let xor_bit: int = if bit_x != bit_y { 1 } else { 0 };\n                xor_bit + 2 * xor_int(x / 2, y / 2)\n            }\n        } else {\n            0\n        }\n    }\n    \n    spec fn xor_range(a: int, b: int) -> int\n        decreases b - a\n    {\n        if 0 <= a <= b {\n            if a == b { a }\n            else { xor_int(a, xor_range(a + 1, b)) }\n        } else {\n            0\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i32, b: i32) -> (result: i32)\n    requires \n        a >= 0,\n        b >= 0,\n        a <= b\n    ensures \n        result >= 0,\n        result as int == xor_range(a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1045_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn cubes_for_level(level: int) -> int\n    recommends level >= 1\n{\n    level * (level + 1) / 2\n}\n\nspec fn total_cubes_for_height(h: int) -> int\n    recommends h >= 1\n{\n    h * (h + 1) * (h + 2) / 6\n}\n\nspec fn valid_pyramid_height(n: int, h: int) -> bool {\n    valid_input(n) && h >= 1 && \n    total_cubes_for_height(h) <= n &&\n    total_cubes_for_height(h + 1) > n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures \n        result >= 1 &&\n        valid_pyramid_height(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn cubes_for_level(level: int) -> int\n    recommends level >= 1\n{\n    level * (level + 1) / 2\n}\n\nspec fn total_cubes_for_height(h: int) -> int\n    recommends h >= 1\n{\n    h * (h + 1) * (h + 2) / 6\n}\n\nspec fn valid_pyramid_height(n: int, h: int) -> bool {\n    valid_input(n) && h >= 1 && \n    total_cubes_for_height(h) <= n &&\n    total_cubes_for_height(h + 1) > n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures \n        result >= 1 &&\n        valid_pyramid_height(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1045.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 647, "minimize_time_ms": 122357, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn cubes_for_level(level: int) -> int\n    recommends level >= 1\n{\n\nspec fn total_cubes_for_height(h: int) -> int\n    recommends h >= 1\n{\n\nspec fn valid_pyramid_height(n: int, h: int) -> bool {\n\n    requires valid_input(n as int)\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn cubes_for_level(level: int) -> int\n    recommends level >= 1\n{\n    level * (level + 1) / 2\n}\n\nspec fn total_cubes_for_height(h: int) -> int\n    recommends h >= 1\n{\n    h * (h + 1) * (h + 2) / 6\n}\n\nspec fn valid_pyramid_height(n: int, h: int) -> bool {\n    valid_input(n) && h >= 1 && \n    total_cubes_for_height(h) <= n &&\n    total_cubes_for_height(h + 1) > n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures \n        result >= 1 &&\n        valid_pyramid_height(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1048_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_commands(commands: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, commands: Vec<char>) -> (result: usize)\n    requires \n        n >= 0,\n        commands@.len() == n,\n        valid_commands(commands@)\n    ensures \n        result >= 0,\n        result <= n,\n        result % 2 == 0,\n        result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + \n                         2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_commands(commands: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, commands: Vec<char>) -> (result: usize)\n    requires \n        n >= 0,\n        commands@.len() == n,\n        valid_commands(commands@)\n    ensures \n        result >= 0,\n        result <= n,\n        result % 2 == 0,\n        result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + \n                         2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1048.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 799, "minimize_time_ms": 122424, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n\nspec fn min(a: int, b: int) -> int {\n\nspec fn valid_commands(commands: Seq<char>) -> bool {\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_commands(commands: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, commands: Vec<char>) -> (result: usize)\n    requires \n        n >= 0,\n        commands@.len() == n,\n        valid_commands(commands@)\n    ensures \n        result >= 0,\n        result <= n,\n        result % 2 == 0,\n        result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + \n                         2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1052_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    4 <= n <= 1000 && 1 <= k <= 4 && k < n\n}\n\nspec fn factorial(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\nspec fn derangement(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 0 }\n    else if n == 2 { 1 }\n    else { (n - 1) * (derangement(n - 1) + derangement(n - 2)) }\n}\n\nspec fn binomial(n: int, k: int) -> int {\n    if k > n { 0 }\n    else if k == 0 || k == n { 1 }\n    else { factorial(n) / (factorial(k) * factorial(n - k)) }\n}\n\nspec fn sum_binomial_derangement(n: int, k: int, i: int) -> int\n    decreases n - k - i\n{\n    if i >= n - k { 0 }\n    else { binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires valid_input(n as int, k as int)\n    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    4 <= n <= 1000 && 1 <= k <= 4 && k < n\n}\n\nspec fn factorial(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\nspec fn derangement(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 0 }\n    else if n == 2 { 1 }\n    else { (n - 1) * (derangement(n - 1) + derangement(n - 2)) }\n}\n\nspec fn binomial(n: int, k: int) -> int {\n    if k > n { 0 }\n    else if k == 0 || k == n { 1 }\n    else { factorial(n) / (factorial(k) * factorial(n - k)) }\n}\n\nspec fn sum_binomial_derangement(n: int, k: int, i: int) -> int\n    decreases n - k - i\n{\n    if i >= n - k { 0 }\n    else { binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires valid_input(n as int, k as int)\n    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1052.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 628, "minimize_time_ms": 122722, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int) -> bool {\n\nspec fn factorial(n: int) -> int\n    decreases n\n{\n\nspec fn derangement(n: int) -> int\n    decreases n\n{\n\nspec fn binomial(n: int, k: int) -> int {\n\nspec fn sum_binomial_derangement(n: int, k: int, i: int) -> int\n    decreases n - k - i\n{\n\n    decreases n\n\n    decreases n\n\n    decreases n - k - i\n\n    requires valid_input(n as int, k as int)\n\n    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    4 <= n <= 1000 && 1 <= k <= 4 && k < n\n}\n\nspec fn factorial(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\nspec fn derangement(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 0 }\n    else if n == 2 { 1 }\n    else { (n - 1) * (derangement(n - 1) + derangement(n - 2)) }\n}\n\nspec fn binomial(n: int, k: int) -> int {\n    if k > n { 0 }\n    else if k == 0 || k == n { 1 }\n    else { factorial(n) / (factorial(k) * factorial(n - k)) }\n}\n\nspec fn sum_binomial_derangement(n: int, k: int, i: int) -> int\n    decreases n - k - i\n{\n    if i >= n - k { 0 }\n    else { binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires valid_input(n as int, k as int)\n    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1055_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>) -> bool {\n    a.len() > 0\n}\n\nspec fn is_sorted(x: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < x.len() ==> x[i] <= x[j]\n}\n\nspec fn thanos_sort(x: Seq<int>) -> int\n    recommends x.len() > 0\n    decreases x.len()\n{\n    let len = x.len() as int;\n    if is_sorted(x) {\n        len\n    } else {\n        let first_half = x.subrange(0, len / 2);\n        let second_half = x.subrange(len / 2, len);\n        let left_result = thanos_sort(first_half);\n        let right_result = thanos_sort(second_half);\n        if left_result > right_result { left_result } else { right_result }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: usize)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result as int == thanos_sort(a@.map(|i, x| x as int)),\n        1 <= result <= a.len(),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>) -> bool {\n    a.len() > 0\n}\n\nspec fn is_sorted(x: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < x.len() ==> x[i] <= x[j]\n}\n\nspec fn thanos_sort(x: Seq<int>) -> int\n    recommends x.len() > 0\n    decreases x.len()\n{\n    let len = x.len() as int;\n    if is_sorted(x) {\n        len\n    } else {\n        let first_half = x.subrange(0, len / 2);\n        let second_half = x.subrange(len / 2, len);\n        let left_result = thanos_sort(first_half);\n        let right_result = thanos_sort(second_half);\n        if left_result > right_result { left_result } else { right_result }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: usize)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result as int == thanos_sort(a@.map(|i, x| x as int)),\n        1 <= result <= a.len(),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1055.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 722, "minimize_time_ms": 122801, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: Seq<int>) -> bool {\n\nspec fn is_sorted(x: Seq<int>) -> bool {\n\nspec fn thanos_sort(x: Seq<int>) -> int\n    recommends x.len() > 0\n    decreases x.len()\n{\n\n    decreases x.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>) -> bool {\n    a.len() > 0\n}\n\nspec fn is_sorted(x: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < x.len() ==> x[i] <= x[j]\n}\n\nspec fn thanos_sort(x: Seq<int>) -> int\n    recommends x.len() > 0\n    decreases x.len()\n{\n    let len = x.len() as int;\n    if is_sorted(x) {\n        len\n    } else {\n        let first_half = x.subrange(0, len / 2);\n        let second_half = x.subrange(len / 2, len);\n        let left_result = thanos_sort(first_half);\n        let right_result = thanos_sort(second_half);\n        if left_result > right_result { left_result } else { right_result }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: usize)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result as int == thanos_sort(a@.map(|i, x| x as int)),\n        1 <= result <= a.len(),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_106_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {\n  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b\n}\n\nspec fn get_entrance(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  (apt - 1) / (m * k)\n}\n\nspec fn get_floor(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  ((apt - 1) - get_entrance(apt, m, k) * m * k) / k\n}\n\nspec fn min_travel_time(floors: int) -> int\n  recommends floors >= 0\n{\n  let stair_time = 5 * floors;\n  let elevator_time = 10 + floors;\n  if stair_time < elevator_time { stair_time } else { elevator_time }\n}\n\nspec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int\n  recommends n > 0\n{\n  let clockwise = (entrance_b - entrance_a + n) % n;\n  let counterclockwise = (entrance_a - entrance_b + n) % n;\n  if clockwise <= counterclockwise { clockwise } else { counterclockwise }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, a: i8, b: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int, a as int, b as int)\n  ensures result as int >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {\n  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b\n}\n\nspec fn get_entrance(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  (apt - 1) / (m * k)\n}\n\nspec fn get_floor(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  ((apt - 1) - get_entrance(apt, m, k) * m * k) / k\n}\n\nspec fn min_travel_time(floors: int) -> int\n  recommends floors >= 0\n{\n  let stair_time = 5 * floors;\n  let elevator_time = 10 + floors;\n  if stair_time < elevator_time { stair_time } else { elevator_time }\n}\n\nspec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int\n  recommends n > 0\n{\n  let clockwise = (entrance_b - entrance_a + n) % n;\n  let counterclockwise = (entrance_a - entrance_b + n) % n;\n  if clockwise <= counterclockwise { clockwise } else { counterclockwise }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, a: i8, b: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int, a as int, b as int)\n  ensures result as int >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_106.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 678, "minimize_time_ms": 122386, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {\n\nspec fn get_entrance(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n\nspec fn get_floor(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n\nspec fn min_travel_time(floors: int) -> int\n  recommends floors >= 0\n{\n\nspec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int\n  recommends n > 0\n{\n\n  requires valid_input(n as int, m as int, k as int, a as int, b as int)\n\n  ensures result as int >= 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {\n  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b\n}\n\nspec fn get_entrance(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  (apt - 1) / (m * k)\n}\n\nspec fn get_floor(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  ((apt - 1) - get_entrance(apt, m, k) * m * k) / k\n}\n\nspec fn min_travel_time(floors: int) -> int\n  recommends floors >= 0\n{\n  let stair_time = 5 * floors;\n  let elevator_time = 10 + floors;\n  if stair_time < elevator_time { stair_time } else { elevator_time }\n}\n\nspec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int\n  recommends n > 0\n{\n  let clockwise = (entrance_b - entrance_a + n) % n;\n  let counterclockwise = (entrance_a - entrance_b + n) % n;\n  if clockwise <= counterclockwise { clockwise } else { counterclockwise }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, a: i8, b: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int, a as int, b as int)\n  ensures result as int >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1071_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {\n    a.len() >= 0 && b.len() >= 0 &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 0) &&\n    (forall|j: int| 0 <= j < b.len() ==> b[j] >= 0) &&\n    n >= 1\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.drop_first()) }\n}\n\nspec fn shelves_needed(total: int, capacity: int) -> int\n    recommends capacity > 0\n{\n    if total == 0 { 0 } else { (total - 1) / capacity + 1 }\n}\n\nspec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool\n    recommends valid_input(a, b, n)\n{\n    let total_cups = sum_seq(a);\n    let total_medals = sum_seq(b);\n    let shelves_for_cups = shelves_needed(total_cups, 5);\n    let shelves_for_medals = shelves_needed(total_medals, 10);\n    shelves_for_cups + shelves_for_medals <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>, b: Vec<i8>, n: i8) -> (result: String)\n    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)\n    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { \"YES\"@ } else { \"NO\"@ })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {\n    a.len() >= 0 && b.len() >= 0 &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 0) &&\n    (forall|j: int| 0 <= j < b.len() ==> b[j] >= 0) &&\n    n >= 1\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.drop_first()) }\n}\n\nspec fn shelves_needed(total: int, capacity: int) -> int\n    recommends capacity > 0\n{\n    if total == 0 { 0 } else { (total - 1) / capacity + 1 }\n}\n\nspec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool\n    recommends valid_input(a, b, n)\n{\n    let total_cups = sum_seq(a);\n    let total_medals = sum_seq(b);\n    let shelves_for_cups = shelves_needed(total_cups, 5);\n    let shelves_for_medals = shelves_needed(total_medals, 10);\n    shelves_for_cups + shelves_for_medals <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>, b: Vec<i8>, n: i8) -> (result: String)\n    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)\n    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { \"YES\"@ } else { \"NO\"@ })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1071.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 704, "minimize_time_ms": 122697, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {\n\nspec fn sum_seq(s: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0\n    decreases s.len()\n{\n\nspec fn shelves_needed(total: int, capacity: int) -> int\n    recommends capacity > 0\n{\n\nspec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool\n    recommends valid_input(a, b, n)\n{\n\n    decreases s.len()\n\n    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)\n\n    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { \"YES\"@ } else { \"NO\"@ })"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {\n    a.len() >= 0 && b.len() >= 0 &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 0) &&\n    (forall|j: int| 0 <= j < b.len() ==> b[j] >= 0) &&\n    n >= 1\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.drop_first()) }\n}\n\nspec fn shelves_needed(total: int, capacity: int) -> int\n    recommends capacity > 0\n{\n    if total == 0 { 0 } else { (total - 1) / capacity + 1 }\n}\n\nspec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool\n    recommends valid_input(a, b, n)\n{\n    let total_cups = sum_seq(a);\n    let total_medals = sum_seq(b);\n    let shelves_for_cups = shelves_needed(total_cups, 5);\n    let shelves_for_medals = shelves_needed(total_medals, 10);\n    shelves_for_cups + shelves_for_medals <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>, b: Vec<i8>, n: i8) -> (result: String)\n    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)\n    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { \"YES\"@ } else { \"NO\"@ })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1081_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 99\n}\n\nspec fn expected_result(n: int) -> bool\n    recommends valid_input(n)\n{\n    if n < 12 {\n        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 {\n            false\n        } else {\n            true\n        }\n    } else if 12 < n < 30 {\n        false\n    } else if 69 < n < 80 {\n        false\n    } else if 89 < n {\n        false\n    } else {\n        let last_digit = n % 10;\n        if last_digit != 1 && last_digit != 7 && last_digit != 9 {\n            true\n        } else {\n            false\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: bool)\nrequires \n    valid_input(n as int),\nensures \n    result == expected_result(n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 99\n}\n\nspec fn expected_result(n: int) -> bool\n    recommends valid_input(n)\n{\n    if n < 12 {\n        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 {\n            false\n        } else {\n            true\n        }\n    } else if 12 < n < 30 {\n        false\n    } else if 69 < n < 80 {\n        false\n    } else if 89 < n {\n        false\n    } else {\n        let last_digit = n % 10;\n        if last_digit != 1 && last_digit != 7 && last_digit != 9 {\n            true\n        } else {\n            false\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: bool)\nrequires \n    valid_input(n as int),\nensures \n    result == expected_result(n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1081.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 630, "minimize_time_ms": 124364, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 7, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn expected_result(n: int) -> bool\n    recommends valid_input(n)\n{\n\nrequires \n\nensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 99\n}\n\nspec fn expected_result(n: int) -> bool\n    recommends valid_input(n)\n{\n    if n < 12 {\n        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 {\n            false\n        } else {\n            true\n        }\n    } else if 12 < n < 30 {\n        false\n    } else if 69 < n < 80 {\n        false\n    } else if 89 < n {\n        false\n    } else {\n        let last_digit = n % 10;\n        if last_digit != 1 && last_digit != 7 && last_digit != 9 {\n            true\n        } else {\n            false\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: bool)\nrequires \n    valid_input(n as int),\nensures \n    result == expected_result(n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1085_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn reduce_by_divisor(n: nat, d: nat) -> nat {\n    if n > 0 && d > 1 && n % d == 0 && n >= d {\n        n / d\n    } else {\n        n\n    }\n}\n\nspec fn count_divisors(n: int) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 1 <= d <= n && n % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_special_divisors(n: nat) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_valid_k_values(n: nat) -> int {\n    if n > 0 {\n        if n == 1 {\n            -1\n        } else {\n            count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1\n        }\n    } else {\n        -1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8) -> (result: i8)\n    requires \n        valid_input(n as nat)\n    ensures \n        result as int == count_valid_k_values(n as nat),\n        n == 1 ==> result as int == -1,\n        n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,\n        result as int >= -1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn reduce_by_divisor(n: nat, d: nat) -> nat {\n    if n > 0 && d > 1 && n % d == 0 && n >= d {\n        n / d\n    } else {\n        n\n    }\n}\n\nspec fn count_divisors(n: int) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 1 <= d <= n && n % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_special_divisors(n: nat) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_valid_k_values(n: nat) -> int {\n    if n > 0 {\n        if n == 1 {\n            -1\n        } else {\n            count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1\n        }\n    } else {\n        -1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8) -> (result: i8)\n    requires \n        valid_input(n as nat)\n    ensures \n        result as int == count_valid_k_values(n as nat),\n        n == 1 ==> result as int == -1,\n        n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,\n        result as int >= -1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1085.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 664, "minimize_time_ms": 122518, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: nat) -> bool {\n\nspec fn reduce_by_divisor(n: nat, d: nat) -> nat {\n\nspec fn count_divisors(n: int) -> nat {\n\nspec fn count_special_divisors(n: nat) -> nat {\n\nspec fn count_valid_k_values(n: nat) -> int {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn reduce_by_divisor(n: nat, d: nat) -> nat {\n    if n > 0 && d > 1 && n % d == 0 && n >= d {\n        n / d\n    } else {\n        n\n    }\n}\n\nspec fn count_divisors(n: int) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 1 <= d <= n && n % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_special_divisors(n: nat) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_valid_k_values(n: nat) -> int {\n    if n > 0 {\n        if n == 1 {\n            -1\n        } else {\n            count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1\n        }\n    } else {\n        -1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8) -> (result: i8)\n    requires \n        valid_input(n as nat)\n    ensures \n        result as int == count_valid_k_values(n as nat),\n        n == 1 ==> result as int == -1,\n        n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,\n        result as int >= -1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1096_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(position: Seq<char>) -> bool {\n  position.len() == 2 && \n  'a' <= position[0] && position[0] <= 'h' && \n  '1' <= position[1] && position[1] <= '8'\n}\n\nspec fn is_corner(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h') && \n  (position[1] == '1' || position[1] == '8')\n}\n\nspec fn is_edge(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h' || \n   position[1] == '1' || position[1] == '8') && \n  !is_corner(position)\n}\n\nspec fn is_interior(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  !is_corner(position) && !is_edge(position)\n}\n\nspec fn valid_moves(position: Seq<char>) -> int\n  recommends valid_input(position)\n{\n  if is_corner(position) { 3 }\n  else if is_edge(position) { 5 }\n  else { 8 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(position: Vec<char>) -> (moves: i8)\n  requires \n    valid_input(position@),\n  ensures \n    moves as int == valid_moves(position@),\n    is_corner(position@) ==> moves == 3,\n    is_edge(position@) ==> moves == 5,\n    is_interior(position@) ==> moves == 8,\n    moves == 3 || moves == 5 || moves == 8,\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(position: Seq<char>) -> bool {\n  position.len() == 2 && \n  'a' <= position[0] && position[0] <= 'h' && \n  '1' <= position[1] && position[1] <= '8'\n}\n\nspec fn is_corner(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h') && \n  (position[1] == '1' || position[1] == '8')\n}\n\nspec fn is_edge(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h' || \n   position[1] == '1' || position[1] == '8') && \n  !is_corner(position)\n}\n\nspec fn is_interior(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  !is_corner(position) && !is_edge(position)\n}\n\nspec fn valid_moves(position: Seq<char>) -> int\n  recommends valid_input(position)\n{\n  if is_corner(position) { 3 }\n  else if is_edge(position) { 5 }\n  else { 8 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(position: Vec<char>) -> (moves: i8)\n  requires \n    valid_input(position@),\n  ensures \n    moves as int == valid_moves(position@),\n    is_corner(position@) ==> moves == 3,\n    is_edge(position@) ==> moves == 5,\n    is_interior(position@) ==> moves == 8,\n    moves == 3 || moves == 5 || moves == 8,\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1096.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 734, "minimize_time_ms": 122697, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 65, "minimized_LOC": 65, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(position: Seq<char>) -> bool {\n\nspec fn is_corner(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n\nspec fn is_edge(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n\nspec fn is_interior(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n\nspec fn valid_moves(position: Seq<char>) -> int\n  recommends valid_input(position)\n{\n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(position: Seq<char>) -> bool {\n  position.len() == 2 && \n  'a' <= position[0] && position[0] <= 'h' && \n  '1' <= position[1] && position[1] <= '8'\n}\n\nspec fn is_corner(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h') && \n  (position[1] == '1' || position[1] == '8')\n}\n\nspec fn is_edge(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h' || \n   position[1] == '1' || position[1] == '8') && \n  !is_corner(position)\n}\n\nspec fn is_interior(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  !is_corner(position) && !is_edge(position)\n}\n\nspec fn valid_moves(position: Seq<char>) -> int\n  recommends valid_input(position)\n{\n  if is_corner(position) { 3 }\n  else if is_edge(position) { 5 }\n  else { 8 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(position: Vec<char>) -> (moves: i8)\n  requires \n    valid_input(position@),\n  ensures \n    moves as int == valid_moves(position@),\n    is_corner(position@) ==> moves == 3,\n    is_edge(position@) ==> moves == 5,\n    is_interior(position@) ==> moves == 8,\n    moves == 3 || moves == 5 || moves == 8,\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1102_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {\n    n > 0 && 1 <= a <= n && x.len() == n && \n    forall|i: int| 0 <= i < n ==> (x[i] == 0 || x[i] == 1)\n}\n\nspec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int\n    decreases n + 1 - distance\n{\n    if distance > n { \n        0\n    } else {\n        let le = a_idx - distance;\n        let rg = a_idx + distance;\n        let le_valid = le >= 0 && le < n;\n        let rg_valid = rg >= 0 && rg < n;\n        let current_caught = if !le_valid && !rg_valid {\n            0\n        } else if le_valid && !rg_valid {\n            x[le]\n        } else if !le_valid && rg_valid {\n            x[rg]\n        } else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 {\n            2\n        } else {\n            0\n        };\n        if !le_valid && !rg_valid {\n            current_caught\n        } else {\n            current_caught + sum_criminals_caught(n, a_idx, x, distance + 1)\n        }\n    }\n}\n\nspec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {\n    x[a-1] + sum_criminals_caught(n, a-1, x, 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, x: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n    ensures \n        result >= 0 &&\n        result as int == total_criminals_caught(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {\n    n > 0 && 1 <= a <= n && x.len() == n && \n    forall|i: int| 0 <= i < n ==> (x[i] == 0 || x[i] == 1)\n}\n\nspec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int\n    decreases n + 1 - distance\n{\n    if distance > n { \n        0\n    } else {\n        let le = a_idx - distance;\n        let rg = a_idx + distance;\n        let le_valid = le >= 0 && le < n;\n        let rg_valid = rg >= 0 && rg < n;\n        let current_caught = if !le_valid && !rg_valid {\n            0\n        } else if le_valid && !rg_valid {\n            x[le]\n        } else if !le_valid && rg_valid {\n            x[rg]\n        } else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 {\n            2\n        } else {\n            0\n        };\n        if !le_valid && !rg_valid {\n            current_caught\n        } else {\n            current_caught + sum_criminals_caught(n, a_idx, x, distance + 1)\n        }\n    }\n}\n\nspec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {\n    x[a-1] + sum_criminals_caught(n, a-1, x, 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, x: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n    ensures \n        result >= 0 &&\n        result as int == total_criminals_caught(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1102.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 749, "minimize_time_ms": 122560, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {\n\nspec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int\n    decreases n + 1 - distance\n{\n\nspec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {\n\n    decreases n + 1 - distance\n\n    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {\n    n > 0 && 1 <= a <= n && x.len() == n && \n    forall|i: int| 0 <= i < n ==> (x[i] == 0 || x[i] == 1)\n}\n\nspec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int\n    decreases n + 1 - distance\n{\n    if distance > n { \n        0\n    } else {\n        let le = a_idx - distance;\n        let rg = a_idx + distance;\n        let le_valid = le >= 0 && le < n;\n        let rg_valid = rg >= 0 && rg < n;\n        let current_caught = if !le_valid && !rg_valid {\n            0\n        } else if le_valid && !rg_valid {\n            x[le]\n        } else if !le_valid && rg_valid {\n            x[rg]\n        } else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 {\n            2\n        } else {\n            0\n        };\n        if !le_valid && !rg_valid {\n            current_caught\n        } else {\n            current_caught + sum_criminals_caught(n, a_idx, x, distance + 1)\n        }\n    }\n}\n\nspec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {\n    x[a-1] + sum_criminals_caught(n, a-1, x, 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, x: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n    ensures \n        result >= 0 &&\n        result as int == total_criminals_caught(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1109_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    1 <= k <= n <= 100 &&\n    n % k == 0 &&\n    a.len() == n &&\n    forall|i: int| 0 <= i < a.len() ==> a[i] == 1 || a[i] == 2\n}\n\nspec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 1).len() as int\n}\n\nspec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 2).len() as int\n}\n\nspec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    let count1 = count_ones_in_column(a, n, k, col);\n    let count2 = count_twos_in_column(a, n, k, col);\n    if count1 < count2 { count1 } else { count2 }\n}\n\nspec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int\n    decreases k - col when col <= k\n{\n    if col >= k {\n        0\n    } else {\n        min_changes_for_column(a, n, k, col) + sum_min_changes_helper(a, n, k, col + 1)\n    }\n}\n\nspec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {\n    sum_min_changes_helper(a, n, k, 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, a@.map(|i, v| v as int))\n    ensures \n        0 <= result as int <= n as int,\n        result as int == sum_min_changes_for_all_columns(a@.map(|i, v| v as int), n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    1 <= k <= n <= 100 &&\n    n % k == 0 &&\n    a.len() == n &&\n    forall|i: int| 0 <= i < a.len() ==> a[i] == 1 || a[i] == 2\n}\n\nspec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 1).len() as int\n}\n\nspec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 2).len() as int\n}\n\nspec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    let count1 = count_ones_in_column(a, n, k, col);\n    let count2 = count_twos_in_column(a, n, k, col);\n    if count1 < count2 { count1 } else { count2 }\n}\n\nspec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int\n    decreases k - col when col <= k\n{\n    if col >= k {\n        0\n    } else {\n        min_changes_for_column(a, n, k, col) + sum_min_changes_helper(a, n, k, col + 1)\n    }\n}\n\nspec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {\n    sum_min_changes_helper(a, n, k, 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, a@.map(|i, v| v as int))\n    ensures \n        0 <= result as int <= n as int,\n        result as int == sum_min_changes_for_all_columns(a@.map(|i, v| v as int), n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1109.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 684, "minimize_time_ms": 122724, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n\nspec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n\nspec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n\nspec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n\nspec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int\n    decreases k - col when col <= k\n{\n\nspec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {\n\n    decreases k - col when col <= k\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    1 <= k <= n <= 100 &&\n    n % k == 0 &&\n    a.len() == n &&\n    forall|i: int| 0 <= i < a.len() ==> a[i] == 1 || a[i] == 2\n}\n\nspec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 1).len() as int\n}\n\nspec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 2).len() as int\n}\n\nspec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    let count1 = count_ones_in_column(a, n, k, col);\n    let count2 = count_twos_in_column(a, n, k, col);\n    if count1 < count2 { count1 } else { count2 }\n}\n\nspec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int\n    decreases k - col when col <= k\n{\n    if col >= k {\n        0\n    } else {\n        min_changes_for_column(a, n, k, col) + sum_min_changes_helper(a, n, k, col + 1)\n    }\n}\n\nspec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {\n    sum_min_changes_helper(a, n, k, 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, a@.map(|i, v| v as int))\n    ensures \n        0 <= result as int <= n as int,\n        result as int == sum_min_changes_for_all_columns(a@.map(|i, v| v as int), n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1117_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {\n    if rectangles.len() <= 1 {\n        true\n    } else {\n        can_form_non_ascending_sequence_helper(rectangles, 1, max_spec(rectangles[0].0, rectangles[0].1))\n    }\n}\n\nspec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool\n    recommends 0 <= index <= rectangles.len()\n    decreases rectangles.len() - index\n{\n    if index >= rectangles.len() {\n        true\n    } else {\n        let a = rectangles[index].0;\n        let b = rectangles[index].1;\n        let min_dim = min_spec(a, b);\n        let max_dim = max_spec(a, b);\n\n        if min_dim > prev_height {\n            false\n        } else if min_dim <= prev_height < max_dim {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, min_dim)\n        } else {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, max_dim)\n        }\n    }\n}\n\nspec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {\n    /* Placeholder for parsing logic */\n    seq![]\n}\n\nspec fn min_spec(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn max_spec(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures result@ == \"YES\"@ || result@ == \"NO\"@\n    /* ensures result@ == \"YES\"@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {\n    if rectangles.len() <= 1 {\n        true\n    } else {\n        can_form_non_ascending_sequence_helper(rectangles, 1, max_spec(rectangles[0].0, rectangles[0].1))\n    }\n}\n\nspec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool\n    recommends 0 <= index <= rectangles.len()\n    decreases rectangles.len() - index\n{\n    if index >= rectangles.len() {\n        true\n    } else {\n        let a = rectangles[index].0;\n        let b = rectangles[index].1;\n        let min_dim = min_spec(a, b);\n        let max_dim = max_spec(a, b);\n\n        if min_dim > prev_height {\n            false\n        } else if min_dim <= prev_height < max_dim {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, min_dim)\n        } else {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, max_dim)\n        }\n    }\n}\n\nspec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {\n    /* Placeholder for parsing logic */\n    seq![]\n}\n\nspec fn min_spec(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn max_spec(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures result@ == \"YES\"@ || result@ == \"NO\"@\n    /* ensures result@ == \"YES\"@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1117.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 814, "minimize_time_ms": 122517, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {\n\nspec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool\n    recommends 0 <= index <= rectangles.len()\n    decreases rectangles.len() - index\n{\n\nspec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {\n\nspec fn min_spec(a: int, b: int) -> int {\n\nspec fn max_spec(a: int, b: int) -> int {\n\n    decreases rectangles.len() - index\n\n    requires input@.len() > 0\n\n    ensures result@ == \"YES\"@ || result@ == \"NO\"@\n\n    /* ensures result@ == \"YES\"@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {\n    if rectangles.len() <= 1 {\n        true\n    } else {\n        can_form_non_ascending_sequence_helper(rectangles, 1, max_spec(rectangles[0].0, rectangles[0].1))\n    }\n}\n\nspec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool\n    recommends 0 <= index <= rectangles.len()\n    decreases rectangles.len() - index\n{\n    if index >= rectangles.len() {\n        true\n    } else {\n        let a = rectangles[index].0;\n        let b = rectangles[index].1;\n        let min_dim = min_spec(a, b);\n        let max_dim = max_spec(a, b);\n\n        if min_dim > prev_height {\n            false\n        } else if min_dim <= prev_height < max_dim {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, min_dim)\n        } else {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, max_dim)\n        }\n    }\n}\n\nspec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {\n    /* Placeholder for parsing logic */\n    seq![]\n}\n\nspec fn min_spec(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn max_spec(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures result@ == \"YES\"@ || result@ == \"NO\"@\n    /* ensures result@ == \"YES\"@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1124_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(values: Seq<int>) -> bool {\n    values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if a >= b { a } else { b }) when a > 0 && b > 0\n{\n    if a > 0 && b > 0 {\n        if a == b {\n            a\n        } else if a > b {\n            gcd(a - b, b)\n        } else {\n            gcd(a, b - a)\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int\n    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n{\n    if 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        if index == values.len() {\n            current\n        } else {\n            gcd_seq(values, index + 1, gcd(current, values[index as int]))\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_of_all(values: Seq<int>) -> int {\n    if values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        gcd_seq(values, 1, values[0])\n    } else {\n        1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn values_as_int(values: Seq<i8>) -> Seq<int> {\n    values.map(|i, x| x as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(values: Vec<i8>) -> (result: i8)\n    requires valid_input(values_as_int(values@)) && values.len() <= 127\n    ensures \n        result > 0 &&\n        result as int == gcd_of_all(values_as_int(values@)) &&\n        forall|i: int| 0 <= i < values@.len() ==> (values@[i] as int) % (result as int) == 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(values: Seq<int>) -> bool {\n    values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if a >= b { a } else { b }) when a > 0 && b > 0\n{\n    if a > 0 && b > 0 {\n        if a == b {\n            a\n        } else if a > b {\n            gcd(a - b, b)\n        } else {\n            gcd(a, b - a)\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int\n    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n{\n    if 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        if index == values.len() {\n            current\n        } else {\n            gcd_seq(values, index + 1, gcd(current, values[index as int]))\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_of_all(values: Seq<int>) -> int {\n    if values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        gcd_seq(values, 1, values[0])\n    } else {\n        1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn values_as_int(values: Seq<i8>) -> Seq<int> {\n    values.map(|i, x| x as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(values: Vec<i8>) -> (result: i8)\n    requires valid_input(values_as_int(values@)) && values.len() <= 127\n    ensures \n        result > 0 &&\n        result as int == gcd_of_all(values_as_int(values@)) &&\n        forall|i: int| 0 <= i < values@.len() ==> (values@[i] as int) % (result as int) == 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1124.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 713, "minimize_time_ms": 122627, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 74, "minimized_LOC": 74, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(values: Seq<int>) -> bool {\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if a >= b {\n\nspec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int\n    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n{\n\nspec fn gcd_of_all(values: Seq<int>) -> int {\n\nspec fn values_as_int(values: Seq<i8>) -> Seq<int> {\n\n    decreases (if a >= b { a } else { b }) when a > 0 && b > 0\n\n    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n\n    requires valid_input(values_as_int(values@)) && values.len() <= 127\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(values: Seq<int>) -> bool {\n    values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if a >= b { a } else { b }) when a > 0 && b > 0\n{\n    if a > 0 && b > 0 {\n        if a == b {\n            a\n        } else if a > b {\n            gcd(a - b, b)\n        } else {\n            gcd(a, b - a)\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int\n    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n{\n    if 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        if index == values.len() {\n            current\n        } else {\n            gcd_seq(values, index + 1, gcd(current, values[index as int]))\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_of_all(values: Seq<int>) -> int {\n    if values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        gcd_seq(values, 1, values[0])\n    } else {\n        1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn values_as_int(values: Seq<i8>) -> Seq<int> {\n    values.map(|i, x| x as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(values: Vec<i8>) -> (result: i8)\n    requires valid_input(values_as_int(values@)) && values.len() <= 127\n    ensures \n        result > 0 &&\n        result as int == gcd_of_all(values_as_int(values@)) &&\n        forall|i: int| 0 <= i < values@.len() ==> (values@[i] as int) % (result as int) == 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1138_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s.index(index) == c {\n        count_char_helper(s, c, index + 1, count + 1)\n    } else {\n        count_char_helper(s, c, index + 1, count)\n    }\n}\n\nspec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        0\n    } else if s.index(index) == c {\n        1 + count_char_from_index(s, c, index + 1)\n    } else {\n        count_char_from_index(s, c, index + 1)\n    }\n}\n\nspec fn correct_result(s: Seq<char>, result: int) -> bool {\n    (s.len() % 2 != 0 ==> result == -1) &&\n    (s.len() % 2 == 0 ==> result >= 0) &&\n    (s.len() % 2 == 0 ==> result <= s.len() / 2) &&\n    (s.len() % 2 == 0 ==> result == (abs(count_char(s, 'L') - count_char(s, 'R')) + abs(count_char(s, 'U') - count_char(s, 'D'))) / 2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures correct_result(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s.index(index) == c {\n        count_char_helper(s, c, index + 1, count + 1)\n    } else {\n        count_char_helper(s, c, index + 1, count)\n    }\n}\n\nspec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        0\n    } else if s.index(index) == c {\n        1 + count_char_from_index(s, c, index + 1)\n    } else {\n        count_char_from_index(s, c, index + 1)\n    }\n}\n\nspec fn correct_result(s: Seq<char>, result: int) -> bool {\n    (s.len() % 2 != 0 ==> result == -1) &&\n    (s.len() % 2 == 0 ==> result >= 0) &&\n    (s.len() % 2 == 0 ==> result <= s.len() / 2) &&\n    (s.len() % 2 == 0 ==> result == (abs(count_char(s, 'L') - count_char(s, 'R')) + abs(count_char(s, 'U') - count_char(s, 'D'))) / 2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures correct_result(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1138.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 688, "minimize_time_ms": 122802, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn abs(x: int) -> int {\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n\nspec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int\n    decreases s.len() - index\n{\n\nspec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int\n    decreases s.len() - index\n{\n\nspec fn correct_result(s: Seq<char>, result: int) -> bool {\n\n    decreases s.len()\n\n    decreases s.len() - index\n\n    decreases s.len() - index\n\n    requires valid_input(s@)\n\n    ensures correct_result(s@, result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s.index(index) == c {\n        count_char_helper(s, c, index + 1, count + 1)\n    } else {\n        count_char_helper(s, c, index + 1, count)\n    }\n}\n\nspec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        0\n    } else if s.index(index) == c {\n        1 + count_char_from_index(s, c, index + 1)\n    } else {\n        count_char_from_index(s, c, index + 1)\n    }\n}\n\nspec fn correct_result(s: Seq<char>, result: int) -> bool {\n    (s.len() % 2 != 0 ==> result == -1) &&\n    (s.len() % 2 == 0 ==> result >= 0) &&\n    (s.len() % 2 == 0 ==> result <= s.len() / 2) &&\n    (s.len() % 2 == 0 ==> result == (abs(count_char(s, 'L') - count_char(s, 'R')) + abs(count_char(s, 'U') - count_char(s, 'D'))) / 2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures correct_result(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1142_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n#[derive(PartialEq, Eq)]\nstruct Wave {\n    start_time: nat,\n    end_time: nat,\n    monsters: nat,\n}\n\nspec fn valid_waves(waves: Seq<Wave>) -> bool {\n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] waves[i].start_time <= waves[i].end_time &&\n        waves[i].monsters > 0 &&\n        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)\n}\n\nspec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {\n    k > 0 && \n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] can_solve_wave(waves, i as nat, k)\n}\n\nspec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let wave = waves[wave_index as int];\n        let time_available = wave.end_time - wave.start_time + 1;\n        let max_possible_shots = time_available * k;\n        wave.monsters <= max_possible_shots &&\n        (wave_index == 0 || can_reach_wave_in_time(waves, wave_index, k))\n    }\n}\n\nspec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index > 0 && wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let prev_wave = waves[wave_index as int - 1];\n        let curr_wave = waves[wave_index as int];\n        let time_gap = curr_wave.start_time - prev_wave.end_time;\n        let reloads_needed = calculate_reloads_needed(prev_wave.monsters, k);\n        reloads_needed <= time_gap\n    }\n}\n\nspec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {\n    if k > 0 {\n        if monsters <= k { \n            0 \n        } else { \n            ((monsters - 1) as int / k as int) as nat\n        }\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {\n    if k > 0 && valid_waves(waves) && can_solve_all_waves(waves, k) {\n        calculate_minimum_bullets_helper(waves, k, 0, k)\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat\n    decreases waves.len() - wave_index\n{\n    if wave_index >= waves.len() {\n        0\n    } else {\n        let wave = waves[wave_index as int];\n        if current_bullets >= wave.monsters {\n            wave.monsters + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        } else {\n            let reloads_needed = (((wave.monsters - 1) as int / k as int) + 1) as nat;\n            reloads_needed * k + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_monster_waves(waves: Vec<Wave>, k: u8) -> (result: i32)\n    requires \n        valid_waves(waves@),\n        k > 0,\n    ensures \n        result == -1 <==> !can_solve_all_waves(waves@, k as nat),\n        result >= 0 <==> can_solve_all_waves(waves@, k as nat),\n        can_solve_all_waves(waves@, k as nat) ==> result == calculate_minimum_bullets(waves@, k as nat) as i32,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n#[derive(PartialEq, Eq)]\nstruct Wave {\n    start_time: nat,\n    end_time: nat,\n    monsters: nat,\n}\n\nspec fn valid_waves(waves: Seq<Wave>) -> bool {\n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] waves[i].start_time <= waves[i].end_time &&\n        waves[i].monsters > 0 &&\n        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)\n}\n\nspec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {\n    k > 0 && \n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] can_solve_wave(waves, i as nat, k)\n}\n\nspec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let wave = waves[wave_index as int];\n        let time_available = wave.end_time - wave.start_time + 1;\n        let max_possible_shots = time_available * k;\n        wave.monsters <= max_possible_shots &&\n        (wave_index == 0 || can_reach_wave_in_time(waves, wave_index, k))\n    }\n}\n\nspec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index > 0 && wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let prev_wave = waves[wave_index as int - 1];\n        let curr_wave = waves[wave_index as int];\n        let time_gap = curr_wave.start_time - prev_wave.end_time;\n        let reloads_needed = calculate_reloads_needed(prev_wave.monsters, k);\n        reloads_needed <= time_gap\n    }\n}\n\nspec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {\n    if k > 0 {\n        if monsters <= k { \n            0 \n        } else { \n            ((monsters - 1) as int / k as int) as nat\n        }\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {\n    if k > 0 && valid_waves(waves) && can_solve_all_waves(waves, k) {\n        calculate_minimum_bullets_helper(waves, k, 0, k)\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat\n    decreases waves.len() - wave_index\n{\n    if wave_index >= waves.len() {\n        0\n    } else {\n        let wave = waves[wave_index as int];\n        if current_bullets >= wave.monsters {\n            wave.monsters + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        } else {\n            let reloads_needed = (((wave.monsters - 1) as int / k as int) + 1) as nat;\n            reloads_needed * k + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_monster_waves(waves: Vec<Wave>, k: u8) -> (result: i32)\n    requires \n        valid_waves(waves@),\n        k > 0,\n    ensures \n        result == -1 <==> !can_solve_all_waves(waves@, k as nat),\n        result >= 0 <==> can_solve_all_waves(waves@, k as nat),\n        can_solve_all_waves(waves@, k as nat) ==> result == calculate_minimum_bullets(waves@, k as nat) as i32,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1142.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 785, "minimize_time_ms": 153516, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 111, "minimized_LOC": 111, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_waves(waves: Seq<Wave>) -> bool {\n\nspec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {\n\nspec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n\nspec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n\nspec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {\n\nspec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {\n\nspec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat\n    decreases waves.len() - wave_index\n{\n\n    decreases waves.len() - wave_index\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n#[derive(PartialEq, Eq)]\nstruct Wave {\n    start_time: nat,\n    end_time: nat,\n    monsters: nat,\n}\n\nspec fn valid_waves(waves: Seq<Wave>) -> bool {\n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] waves[i].start_time <= waves[i].end_time &&\n        waves[i].monsters > 0 &&\n        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)\n}\n\nspec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {\n    k > 0 && \n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] can_solve_wave(waves, i as nat, k)\n}\n\nspec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let wave = waves[wave_index as int];\n        let time_available = wave.end_time - wave.start_time + 1;\n        let max_possible_shots = time_available * k;\n        wave.monsters <= max_possible_shots &&\n        (wave_index == 0 || can_reach_wave_in_time(waves, wave_index, k))\n    }\n}\n\nspec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index > 0 && wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let prev_wave = waves[wave_index as int - 1];\n        let curr_wave = waves[wave_index as int];\n        let time_gap = curr_wave.start_time - prev_wave.end_time;\n        let reloads_needed = calculate_reloads_needed(prev_wave.monsters, k);\n        reloads_needed <= time_gap\n    }\n}\n\nspec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {\n    if k > 0 {\n        if monsters <= k { \n            0 \n        } else { \n            ((monsters - 1) as int / k as int) as nat\n        }\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {\n    if k > 0 && valid_waves(waves) && can_solve_all_waves(waves, k) {\n        calculate_minimum_bullets_helper(waves, k, 0, k)\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat\n    decreases waves.len() - wave_index\n{\n    if wave_index >= waves.len() {\n        0\n    } else {\n        let wave = waves[wave_index as int];\n        if current_bullets >= wave.monsters {\n            wave.monsters + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        } else {\n            let reloads_needed = (((wave.monsters - 1) as int / k as int) + 1) as nat;\n            reloads_needed * k + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_monster_waves(waves: Vec<Wave>, k: u8) -> (result: i32)\n    requires \n        valid_waves(waves@),\n        k > 0,\n    ensures \n        result == -1 <==> !can_solve_all_waves(waves@, k as nat),\n        result >= 0 <==> can_solve_all_waves(waves@, k as nat),\n        can_solve_all_waves(waves@, k as nat) ==> result == calculate_minimum_bullets(waves@, k as nat) as i32,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1149_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    lines.len() >= 3 && {\n        let n = parse_int(lines[0]);\n        let x_line = parse_int_list(lines[1]);\n        let y_line = parse_int_list(lines[2]);\n        n >= 1 && x_line.len() > 0 && y_line.len() > 0 &&\n        x_line[0] >= 0 && y_line[0] >= 0 &&\n        x_line.len() >= (1 + x_line[0]) as nat && y_line.len() >= (1 + y_line[0]) as nat\n    }\n}\n\nspec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    let x_line = parse_int_list(lines[1]);\n    let y_line = parse_int_list(lines[2]);\n    let x_levels = set_from_seq(x_line.subrange(1, 1 + x_line[0] as int));\n    let y_levels = set_from_seq(y_line.subrange(1, 1 + y_line[0] as int));\n    let all_levels = x_levels.union(y_levels);\n    let required_levels = Set::new(|i: int| 1 <= i <= n);\n    if required_levels.subset_of(all_levels) { \n        Seq::new(17, |i: int| if i == 0 { 'I' } else if i == 1 { ' ' } else if i == 2 { 'b' } else if i == 3 { 'e' } else if i == 4 { 'c' } else if i == 5 { 'o' } else if i == 6 { 'm' } else if i == 7 { 'e' } else if i == 8 { ' ' } else if i == 9 { 't' } else if i == 10 { 'h' } else if i == 11 { 'e' } else if i == 12 { ' ' } else if i == 13 { 'g' } else if i == 14 { 'u' } else if i == 15 { 'y' } else { '.' })\n    } else { \n        Seq::new(16, |i: int| if i == 0 { 'O' } else if i == 1 { 'h' } else if i == 2 { ',' } else if i == 3 { ' ' } else if i == 4 { 'm' } else if i == 5 { 'y' } else if i == 6 { ' ' } else if i == 7 { 'k' } else if i == 8 { 'e' } else if i == 9 { 'y' } else if i == 10 { 'b' } else if i == 11 { 'o' } else if i == 12 { 'a' } else if i == 13 { 'r' } else if i == 14 { 'd' } else { '!' })\n    }\n}\n\nspec fn set_from_seq(s: Seq<int>) -> Set<int> {\n    Set::new(|x: int| s.contains(x))\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let newline_pos = find_char(s, '\\n');\n        if newline_pos == -1 {\n            Seq::new(1 as nat, |j: int| trim(s))\n        } else if 0 <= newline_pos < s.len() {\n            Seq::new(1 as nat, |j: int| trim(s.subrange(0, newline_pos))).add(split_lines(s.subrange(newline_pos+1, s.len() as int)))\n        } else {\n            Seq::new(1 as nat, |j: int| trim(s))\n        }\n    }\n}\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[s.len() as int - 1] == '\\r' {\n        s.subrange(0, s.len() as int - 1)\n    } else {\n        s\n    }\n}\n\nspec fn find_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == c {\n        0\n    } else {\n        let rest = find_char(s.subrange(1, s.len() as int), c);\n        if rest == -1 { -1 } else { rest + 1 }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        if is_valid_digits(s.subrange(1, s.len() as int)) { \n            -parse_int_helper(s.subrange(1, s.len() as int)) \n        } else { \n            0 \n        }\n    } else if is_valid_digits(s) { \n        parse_int_helper(s) \n    } else { \n        0 \n    }\n}\n\nspec fn is_valid_digits(s: Seq<char>) -> bool {\n    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> ('0' <= s[i] <= '9')\n}\n\nspec fn parse_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        char_to_digit(s[0])\n    } else {\n        parse_int_helper(s.subrange(0, s.len() as int - 1)) * 10 + char_to_digit(s[s.len() as int - 1])\n    }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as u32 as int) - ('0' as u32 as int)\n}\n\nspec fn parse_int_list(s: Seq<char>) -> Seq<int> {\n    let parts = split_by_char(s, ' ');\n    Seq::new(parts.len(), |i: int| parse_int(parts[i]))\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let delim_pos = find_char(s, delimiter);\n        if delim_pos == -1 {\n            Seq::new(1 as nat, |j: int| s)\n        } else if delim_pos == 0 {\n            split_by_char(s.subrange(1, s.len() as int), delimiter)\n        } else if 0 < delim_pos < s.len() {\n            Seq::new(1 as nat, |j: int| s.subrange(0, delim_pos)).add(split_by_char(s.subrange(delim_pos+1, s.len() as int), delimiter))\n        } else {\n            Seq::new(1 as nat, |j: int| s)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(stdin_input@.map(|i, c| c as char))\n    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    lines.len() >= 3 && {\n        let n = parse_int(lines[0]);\n        let x_line = parse_int_list(lines[1]);\n        let y_line = parse_int_list(lines[2]);\n        n >= 1 && x_line.len() > 0 && y_line.len() > 0 &&\n        x_line[0] >= 0 && y_line[0] >= 0 &&\n        x_line.len() >= (1 + x_line[0]) as nat && y_line.len() >= (1 + y_line[0]) as nat\n    }\n}\n\nspec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    let x_line = parse_int_list(lines[1]);\n    let y_line = parse_int_list(lines[2]);\n    let x_levels = set_from_seq(x_line.subrange(1, 1 + x_line[0] as int));\n    let y_levels = set_from_seq(y_line.subrange(1, 1 + y_line[0] as int));\n    let all_levels = x_levels.union(y_levels);\n    let required_levels = Set::new(|i: int| 1 <= i <= n);\n    if required_levels.subset_of(all_levels) { \n        Seq::new(17, |i: int| if i == 0 { 'I' } else if i == 1 { ' ' } else if i == 2 { 'b' } else if i == 3 { 'e' } else if i == 4 { 'c' } else if i == 5 { 'o' } else if i == 6 { 'm' } else if i == 7 { 'e' } else if i == 8 { ' ' } else if i == 9 { 't' } else if i == 10 { 'h' } else if i == 11 { 'e' } else if i == 12 { ' ' } else if i == 13 { 'g' } else if i == 14 { 'u' } else if i == 15 { 'y' } else { '.' })\n    } else { \n        Seq::new(16, |i: int| if i == 0 { 'O' } else if i == 1 { 'h' } else if i == 2 { ',' } else if i == 3 { ' ' } else if i == 4 { 'm' } else if i == 5 { 'y' } else if i == 6 { ' ' } else if i == 7 { 'k' } else if i == 8 { 'e' } else if i == 9 { 'y' } else if i == 10 { 'b' } else if i == 11 { 'o' } else if i == 12 { 'a' } else if i == 13 { 'r' } else if i == 14 { 'd' } else { '!' })\n    }\n}\n\nspec fn set_from_seq(s: Seq<int>) -> Set<int> {\n    Set::new(|x: int| s.contains(x))\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let newline_pos = find_char(s, '\\n');\n        if newline_pos == -1 {\n            Seq::new(1 as nat, |j: int| trim(s))\n        } else if 0 <= newline_pos < s.len() {\n            Seq::new(1 as nat, |j: int| trim(s.subrange(0, newline_pos))).add(split_lines(s.subrange(newline_pos+1, s.len() as int)))\n        } else {\n            Seq::new(1 as nat, |j: int| trim(s))\n        }\n    }\n}\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[s.len() as int - 1] == '\\r' {\n        s.subrange(0, s.len() as int - 1)\n    } else {\n        s\n    }\n}\n\nspec fn find_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == c {\n        0\n    } else {\n        let rest = find_char(s.subrange(1, s.len() as int), c);\n        if rest == -1 { -1 } else { rest + 1 }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        if is_valid_digits(s.subrange(1, s.len() as int)) { \n            -parse_int_helper(s.subrange(1, s.len() as int)) \n        } else { \n            0 \n        }\n    } else if is_valid_digits(s) { \n        parse_int_helper(s) \n    } else { \n        0 \n    }\n}\n\nspec fn is_valid_digits(s: Seq<char>) -> bool {\n    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> ('0' <= s[i] <= '9')\n}\n\nspec fn parse_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        char_to_digit(s[0])\n    } else {\n        parse_int_helper(s.subrange(0, s.len() as int - 1)) * 10 + char_to_digit(s[s.len() as int - 1])\n    }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as u32 as int) - ('0' as u32 as int)\n}\n\nspec fn parse_int_list(s: Seq<char>) -> Seq<int> {\n    let parts = split_by_char(s, ' ');\n    Seq::new(parts.len(), |i: int| parse_int(parts[i]))\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let delim_pos = find_char(s, delimiter);\n        if delim_pos == -1 {\n            Seq::new(1 as nat, |j: int| s)\n        } else if delim_pos == 0 {\n            split_by_char(s.subrange(1, s.len() as int), delimiter)\n        } else if 0 < delim_pos < s.len() {\n            Seq::new(1 as nat, |j: int| s.subrange(0, delim_pos)).add(split_by_char(s.subrange(delim_pos+1, s.len() as int), delimiter))\n        } else {\n            Seq::new(1 as nat, |j: int| s)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(stdin_input@.map(|i, c| c as char))\n    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1149.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 796, "minimize_time_ms": 184157, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 159, "minimized_LOC": 159, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 21, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n\nspec fn set_from_seq(s: Seq<int>) -> Set<int> {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n\nspec fn find_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n\nspec fn parse_int(s: Seq<char>) -> int {\n\nspec fn is_valid_digits(s: Seq<char>) -> bool {\n\nspec fn parse_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn char_to_digit(c: char) -> int {\n\nspec fn parse_int_list(s: Seq<char>) -> Seq<int> {\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_input(stdin_input@.map(|i, c| c as char))\n\n    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    lines.len() >= 3 && {\n        let n = parse_int(lines[0]);\n        let x_line = parse_int_list(lines[1]);\n        let y_line = parse_int_list(lines[2]);\n        n >= 1 && x_line.len() > 0 && y_line.len() > 0 &&\n        x_line[0] >= 0 && y_line[0] >= 0 &&\n        x_line.len() >= (1 + x_line[0]) as nat && y_line.len() >= (1 + y_line[0]) as nat\n    }\n}\n\nspec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    let x_line = parse_int_list(lines[1]);\n    let y_line = parse_int_list(lines[2]);\n    let x_levels = set_from_seq(x_line.subrange(1, 1 + x_line[0] as int));\n    let y_levels = set_from_seq(y_line.subrange(1, 1 + y_line[0] as int));\n    let all_levels = x_levels.union(y_levels);\n    let required_levels = Set::new(|i: int| 1 <= i <= n);\n    if required_levels.subset_of(all_levels) { \n        Seq::new(17, |i: int| if i == 0 { 'I' } else if i == 1 { ' ' } else if i == 2 { 'b' } else if i == 3 { 'e' } else if i == 4 { 'c' } else if i == 5 { 'o' } else if i == 6 { 'm' } else if i == 7 { 'e' } else if i == 8 { ' ' } else if i == 9 { 't' } else if i == 10 { 'h' } else if i == 11 { 'e' } else if i == 12 { ' ' } else if i == 13 { 'g' } else if i == 14 { 'u' } else if i == 15 { 'y' } else { '.' })\n    } else { \n        Seq::new(16, |i: int| if i == 0 { 'O' } else if i == 1 { 'h' } else if i == 2 { ',' } else if i == 3 { ' ' } else if i == 4 { 'm' } else if i == 5 { 'y' } else if i == 6 { ' ' } else if i == 7 { 'k' } else if i == 8 { 'e' } else if i == 9 { 'y' } else if i == 10 { 'b' } else if i == 11 { 'o' } else if i == 12 { 'a' } else if i == 13 { 'r' } else if i == 14 { 'd' } else { '!' })\n    }\n}\n\nspec fn set_from_seq(s: Seq<int>) -> Set<int> {\n    Set::new(|x: int| s.contains(x))\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let newline_pos = find_char(s, '\\n');\n        if newline_pos == -1 {\n            Seq::new(1 as nat, |j: int| trim(s))\n        } else if 0 <= newline_pos < s.len() {\n            Seq::new(1 as nat, |j: int| trim(s.subrange(0, newline_pos))).add(split_lines(s.subrange(newline_pos+1, s.len() as int)))\n        } else {\n            Seq::new(1 as nat, |j: int| trim(s))\n        }\n    }\n}\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[s.len() as int - 1] == '\\r' {\n        s.subrange(0, s.len() as int - 1)\n    } else {\n        s\n    }\n}\n\nspec fn find_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == c {\n        0\n    } else {\n        let rest = find_char(s.subrange(1, s.len() as int), c);\n        if rest == -1 { -1 } else { rest + 1 }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        if is_valid_digits(s.subrange(1, s.len() as int)) { \n            -parse_int_helper(s.subrange(1, s.len() as int)) \n        } else { \n            0 \n        }\n    } else if is_valid_digits(s) { \n        parse_int_helper(s) \n    } else { \n        0 \n    }\n}\n\nspec fn is_valid_digits(s: Seq<char>) -> bool {\n    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> ('0' <= s[i] <= '9')\n}\n\nspec fn parse_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        char_to_digit(s[0])\n    } else {\n        parse_int_helper(s.subrange(0, s.len() as int - 1)) * 10 + char_to_digit(s[s.len() as int - 1])\n    }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as u32 as int) - ('0' as u32 as int)\n}\n\nspec fn parse_int_list(s: Seq<char>) -> Seq<int> {\n    let parts = split_by_char(s, ' ');\n    Seq::new(parts.len(), |i: int| parse_int(parts[i]))\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let delim_pos = find_char(s, delimiter);\n        if delim_pos == -1 {\n            Seq::new(1 as nat, |j: int| s)\n        } else if delim_pos == 0 {\n            split_by_char(s.subrange(1, s.len() as int), delimiter)\n        } else if 0 < delim_pos < s.len() {\n            Seq::new(1 as nat, |j: int| s.subrange(0, delim_pos)).add(split_by_char(s.subrange(delim_pos+1, s.len() as int), delimiter))\n        } else {\n            Seq::new(1 as nat, |j: int| s)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(stdin_input@.map(|i, c| c as char))\n    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1150_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn valid_mole(mole: (int, int, int, int)) -> bool {\n    let (x, y, a, b) = mole;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&\n    -10000 <= a <= 10000 && -10000 <= b <= 10000\n}\n\nspec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {\n    moles.len() == 4 && forall|i: int| 0 <= i < 4 ==> #[trigger] valid_mole(moles[i])\n}\n\nspec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {\n    let dx = x - center_x;\n    let dy = y - center_y;\n    let rotations = times % 4;\n    if rotations == 0 {\n        (x, y)\n    } else if rotations == 1 {\n        (center_x - dy, center_y + dx)\n    } else if rotations == 2 {\n        (center_x - dx, center_y - dy)\n    } else {\n        (center_x + dy, center_y - dx)\n    }\n}\n\nspec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {\n    let (x1, y1) = p1;\n    let (x2, y2) = p2;\n    let dx = x1 - x2;\n    let dy = y1 - y2;\n    let dx_abs: nat = if dx >= 0 { dx as nat } else { (-dx) as nat };\n    let dy_abs: nat = if dy >= 0 { dy as nat } else { (-dy) as nat };\n    dx_abs * dx_abs + dy_abs * dy_abs\n}\n\nspec fn is_square(points: Seq<(int, int)>) -> bool\n    recommends points.len() == 4\n{\n    if points.len() != 4 {\n        false\n    } else {\n        let p0 = points[0];\n        let p1 = points[1];\n        let p2 = points[2];\n        let p3 = points[3];\n        let d01 = distance_squared(p0, p1);\n        let d02 = distance_squared(p0, p2);\n        let d03 = distance_squared(p0, p3);\n        let d12 = distance_squared(p1, p2);\n        let d13 = distance_squared(p1, p3);\n        let d23 = distance_squared(p2, p3);\n        \n        d01 > 0 && (\n            (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)\n        )\n    }\n}\n\nspec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool\n    recommends valid_regiment(moles)\n{\n    total_moves <= 12\n}\n\nspec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>\n    recommends moles.len() == 4\n{\n    if moles.len() != 4 {\n        seq![]\n    } else {\n        let (x0, y0, a0, b0) = moles[0];\n        let (x1, y1, a1, b1) = moles[1];\n        let (x2, y2, a2, b2) = moles[2];\n        let (x3, y3, a3, b3) = moles[3];\n        seq![\n            rotate_point(x0, y0, a0, b0, moves0),\n            rotate_point(x1, y1, a1, b1, moves1),\n            rotate_point(x2, y2, a2, b2, moves2),\n            rotate_point(x3, y3, a3, b3, moves3)\n        ]\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    recommends is_all_digits(s) && s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 0 || !is_all_digits(s) {\n        0\n    } else if s.len() == 1 {\n        ((s[0] as int) - ('0' as int)) as nat\n    } else {\n        string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (((s[s.len() - 1] as int) - ('0' as int)) as nat)\n    }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char>\n    recommends n <= 12\n{\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else { seq!['1', '2'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(output@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn valid_mole(mole: (int, int, int, int)) -> bool {\n    let (x, y, a, b) = mole;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&\n    -10000 <= a <= 10000 && -10000 <= b <= 10000\n}\n\nspec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {\n    moles.len() == 4 && forall|i: int| 0 <= i < 4 ==> #[trigger] valid_mole(moles[i])\n}\n\nspec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {\n    let dx = x - center_x;\n    let dy = y - center_y;\n    let rotations = times % 4;\n    if rotations == 0 {\n        (x, y)\n    } else if rotations == 1 {\n        (center_x - dy, center_y + dx)\n    } else if rotations == 2 {\n        (center_x - dx, center_y - dy)\n    } else {\n        (center_x + dy, center_y - dx)\n    }\n}\n\nspec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {\n    let (x1, y1) = p1;\n    let (x2, y2) = p2;\n    let dx = x1 - x2;\n    let dy = y1 - y2;\n    let dx_abs: nat = if dx >= 0 { dx as nat } else { (-dx) as nat };\n    let dy_abs: nat = if dy >= 0 { dy as nat } else { (-dy) as nat };\n    dx_abs * dx_abs + dy_abs * dy_abs\n}\n\nspec fn is_square(points: Seq<(int, int)>) -> bool\n    recommends points.len() == 4\n{\n    if points.len() != 4 {\n        false\n    } else {\n        let p0 = points[0];\n        let p1 = points[1];\n        let p2 = points[2];\n        let p3 = points[3];\n        let d01 = distance_squared(p0, p1);\n        let d02 = distance_squared(p0, p2);\n        let d03 = distance_squared(p0, p3);\n        let d12 = distance_squared(p1, p2);\n        let d13 = distance_squared(p1, p3);\n        let d23 = distance_squared(p2, p3);\n        \n        d01 > 0 && (\n            (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)\n        )\n    }\n}\n\nspec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool\n    recommends valid_regiment(moles)\n{\n    total_moves <= 12\n}\n\nspec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>\n    recommends moles.len() == 4\n{\n    if moles.len() != 4 {\n        seq![]\n    } else {\n        let (x0, y0, a0, b0) = moles[0];\n        let (x1, y1, a1, b1) = moles[1];\n        let (x2, y2, a2, b2) = moles[2];\n        let (x3, y3, a3, b3) = moles[3];\n        seq![\n            rotate_point(x0, y0, a0, b0, moves0),\n            rotate_point(x1, y1, a1, b1, moves1),\n            rotate_point(x2, y2, a2, b2, moves2),\n            rotate_point(x3, y3, a3, b3, moves3)\n        ]\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    recommends is_all_digits(s) && s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 0 || !is_all_digits(s) {\n        0\n    } else if s.len() == 1 {\n        ((s[0] as int) - ('0' as int)) as nat\n    } else {\n        string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (((s[s.len() - 1] as int) - ('0' as int)) as nat)\n    }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char>\n    recommends n <= 12\n{\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else { seq!['1', '2'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(output@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1150.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 765, "minimize_time_ms": 123549, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 156, "minimized_LOC": 156, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>) -> bool {\n\nspec fn valid_mole(mole: (int, int, int, int)) -> bool {\n\nspec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {\n\nspec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {\n\nspec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {\n\nspec fn is_square(points: Seq<(int, int)>) -> bool\n    recommends points.len() == 4\n{\n\nspec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool\n    recommends valid_regiment(moles)\n{\n\nspec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>\n    recommends moles.len() == 4\n{\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    recommends is_all_digits(s) && s.len() > 0\n    decreases s.len()\n{\n\nspec fn nat_to_string(n: nat) -> Seq<char>\n    recommends n <= 12\n{\n\n    decreases s.len()\n\n    requires valid_input(stdin_input@)\n\n    ensures valid_output(output@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn valid_mole(mole: (int, int, int, int)) -> bool {\n    let (x, y, a, b) = mole;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&\n    -10000 <= a <= 10000 && -10000 <= b <= 10000\n}\n\nspec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {\n    moles.len() == 4 && forall|i: int| 0 <= i < 4 ==> #[trigger] valid_mole(moles[i])\n}\n\nspec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {\n    let dx = x - center_x;\n    let dy = y - center_y;\n    let rotations = times % 4;\n    if rotations == 0 {\n        (x, y)\n    } else if rotations == 1 {\n        (center_x - dy, center_y + dx)\n    } else if rotations == 2 {\n        (center_x - dx, center_y - dy)\n    } else {\n        (center_x + dy, center_y - dx)\n    }\n}\n\nspec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {\n    let (x1, y1) = p1;\n    let (x2, y2) = p2;\n    let dx = x1 - x2;\n    let dy = y1 - y2;\n    let dx_abs: nat = if dx >= 0 { dx as nat } else { (-dx) as nat };\n    let dy_abs: nat = if dy >= 0 { dy as nat } else { (-dy) as nat };\n    dx_abs * dx_abs + dy_abs * dy_abs\n}\n\nspec fn is_square(points: Seq<(int, int)>) -> bool\n    recommends points.len() == 4\n{\n    if points.len() != 4 {\n        false\n    } else {\n        let p0 = points[0];\n        let p1 = points[1];\n        let p2 = points[2];\n        let p3 = points[3];\n        let d01 = distance_squared(p0, p1);\n        let d02 = distance_squared(p0, p2);\n        let d03 = distance_squared(p0, p3);\n        let d12 = distance_squared(p1, p2);\n        let d13 = distance_squared(p1, p3);\n        let d23 = distance_squared(p2, p3);\n        \n        d01 > 0 && (\n            (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)\n        )\n    }\n}\n\nspec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool\n    recommends valid_regiment(moles)\n{\n    total_moves <= 12\n}\n\nspec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>\n    recommends moles.len() == 4\n{\n    if moles.len() != 4 {\n        seq![]\n    } else {\n        let (x0, y0, a0, b0) = moles[0];\n        let (x1, y1, a1, b1) = moles[1];\n        let (x2, y2, a2, b2) = moles[2];\n        let (x3, y3, a3, b3) = moles[3];\n        seq![\n            rotate_point(x0, y0, a0, b0, moves0),\n            rotate_point(x1, y1, a1, b1, moves1),\n            rotate_point(x2, y2, a2, b2, moves2),\n            rotate_point(x3, y3, a3, b3, moves3)\n        ]\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    recommends is_all_digits(s) && s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 0 || !is_all_digits(s) {\n        0\n    } else if s.len() == 1 {\n        ((s[0] as int) - ('0' as int)) as nat\n    } else {\n        string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (((s[s.len() - 1] as int) - ('0' as int)) as nat)\n    }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char>\n    recommends n <= 12\n{\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else { seq!['1', '2'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(output@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n              fn main() {\n    }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_116_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    l1 <= r1 && l2 <= r2\n}\n\nspec fn intersection_left(l1: int, l2: int) -> int {\n    if l1 > l2 { l1 } else { l2 }\n}\n\nspec fn intersection_right(r1: int, r2: int) -> int {\n    if r1 < r2 { r1 } else { r2 }\n}\n\nspec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    if right - left + 1 > 0 { right - left + 1 } else { 0 }\n}\n\nspec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    left <= k <= right\n}\n\nspec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {\n    let intersection_size_val = intersection_size(l1, r1, l2, r2);\n    if k_in_intersection(l1, r1, l2, r2, k) {\n        if intersection_size_val - 1 > 0 { intersection_size_val - 1 } else { 0 }\n    } else {\n        intersection_size_val\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(l1: i8, r1: i8, l2: i8, r2: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(l1 as int, r1 as int, l2 as int, r2 as int, k as int)\n    ensures \n        result as int == expected_result(l1 as int, r1 as int, l2 as int, r2 as int, k as int),\n        result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    l1 <= r1 && l2 <= r2\n}\n\nspec fn intersection_left(l1: int, l2: int) -> int {\n    if l1 > l2 { l1 } else { l2 }\n}\n\nspec fn intersection_right(r1: int, r2: int) -> int {\n    if r1 < r2 { r1 } else { r2 }\n}\n\nspec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    if right - left + 1 > 0 { right - left + 1 } else { 0 }\n}\n\nspec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    left <= k <= right\n}\n\nspec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {\n    let intersection_size_val = intersection_size(l1, r1, l2, r2);\n    if k_in_intersection(l1, r1, l2, r2, k) {\n        if intersection_size_val - 1 > 0 { intersection_size_val - 1 } else { 0 }\n    } else {\n        intersection_size_val\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(l1: i8, r1: i8, l2: i8, r2: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(l1 as int, r1 as int, l2 as int, r2 as int, k as int)\n    ensures \n        result as int == expected_result(l1 as int, r1 as int, l2 as int, r2 as int, k as int),\n        result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_116.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 627, "minimize_time_ms": 122435, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n\nspec fn intersection_left(l1: int, l2: int) -> int {\n\nspec fn intersection_right(r1: int, r2: int) -> int {\n\nspec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {\n\nspec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n\nspec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    l1 <= r1 && l2 <= r2\n}\n\nspec fn intersection_left(l1: int, l2: int) -> int {\n    if l1 > l2 { l1 } else { l2 }\n}\n\nspec fn intersection_right(r1: int, r2: int) -> int {\n    if r1 < r2 { r1 } else { r2 }\n}\n\nspec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    if right - left + 1 > 0 { right - left + 1 } else { 0 }\n}\n\nspec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    left <= k <= right\n}\n\nspec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {\n    let intersection_size_val = intersection_size(l1, r1, l2, r2);\n    if k_in_intersection(l1, r1, l2, r2, k) {\n        if intersection_size_val - 1 > 0 { intersection_size_val - 1 } else { 0 }\n    } else {\n        intersection_size_val\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(l1: i8, r1: i8, l2: i8, r2: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(l1 as int, r1 as int, l2 as int, r2 as int, k as int)\n    ensures \n        result as int == expected_result(l1 as int, r1 as int, l2 as int, r2 as int, k as int),\n        result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1176_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn min_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 { \n        s[0] \n    } else { \n        let rest_min = min_seq(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: i8)\n    requires a@.len() >= 2\n    ensures ({\n        let count_neg = Set::new(|i: int| 0 <= i < a@.len() && a@[i] < 0).len();\n        let sum_abs = sum_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        let min_abs = min_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        result as int == if count_neg % 2 == 0 { sum_abs } else { sum_abs - 2 * min_abs }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn min_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 { \n        s[0] \n    } else { \n        let rest_min = min_seq(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: i8)\n    requires a@.len() >= 2\n    ensures ({\n        let count_neg = Set::new(|i: int| 0 <= i < a@.len() && a@[i] < 0).len();\n        let sum_abs = sum_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        let min_abs = min_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        result as int == if count_neg % 2 == 0 { sum_abs } else { sum_abs - 2 * min_abs }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1176.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 707, "minimize_time_ms": 122458, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn min_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires a@.len() >= 2\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn min_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 { \n        s[0] \n    } else { \n        let rest_min = min_seq(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: i8)\n    requires a@.len() >= 2\n    ensures ({\n        let count_neg = Set::new(|i: int| 0 <= i < a@.len() && a@[i] < 0).len();\n        let sum_abs = sum_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        let min_abs = min_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        result as int == if count_neg % 2 == 0 { sum_abs } else { sum_abs - 2 * min_abs }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1177_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n    n >= 1 && s >= 1 && a.len() == n && n <= 3000 && s <= 3000 &&\n    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nspec fn valid_result(result: int) -> bool {\n    result >= 0 && result < 998244353\n}\n\nspec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > s\n}\n\nspec fn single_element_case(n: int, s: int, a: Seq<int>) -> int\n    decreases n\n{\n    if n == 1 && a.len() == 1 {\n        if s == a[0] { 1 } else { 0 }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        valid_result(result as int),\n        (result as int) % 998244353 == (result as int),\n        (n as int == 1 && s as int == a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        (n as int == 1 && s as int != a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        all_elements_greater_than_s(a@.map(|i: int, x: i8| x as int), s as int) ==> (result as int) == 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n    n >= 1 && s >= 1 && a.len() == n && n <= 3000 && s <= 3000 &&\n    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nspec fn valid_result(result: int) -> bool {\n    result >= 0 && result < 998244353\n}\n\nspec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > s\n}\n\nspec fn single_element_case(n: int, s: int, a: Seq<int>) -> int\n    decreases n\n{\n    if n == 1 && a.len() == 1 {\n        if s == a[0] { 1 } else { 0 }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        valid_result(result as int),\n        (result as int) % 998244353 == (result as int),\n        (n as int == 1 && s as int == a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        (n as int == 1 && s as int != a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        all_elements_greater_than_s(a@.map(|i: int, x: i8| x as int), s as int) ==> (result as int) == 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1177.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 703, "minimize_time_ms": 122689, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n\nspec fn valid_result(result: int) -> bool {\n\nspec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {\n\nspec fn single_element_case(n: int, s: int, a: Seq<int>) -> int\n    decreases n\n{\n\n    decreases n\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n    n >= 1 && s >= 1 && a.len() == n && n <= 3000 && s <= 3000 &&\n    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nspec fn valid_result(result: int) -> bool {\n    result >= 0 && result < 998244353\n}\n\nspec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > s\n}\n\nspec fn single_element_case(n: int, s: int, a: Seq<int>) -> int\n    decreases n\n{\n    if n == 1 && a.len() == 1 {\n        if s == a[0] { 1 } else { 0 }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        valid_result(result as int),\n        (result as int) % 998244353 == (result as int),\n        (n as int == 1 && s as int == a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        (n as int == 1 && s as int != a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        all_elements_greater_than_s(a@.map(|i: int, x: i8| x as int), s as int) ==> (result as int) == 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1195_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(lst: Seq<int>) -> bool {\n    5 <= lst.len() <= 10 &&\n    forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32\n}\n\nspec fn int_xor(a: int, b: int) -> int {\n    let a_bv = a as u32;\n    let b_bv = b as u32;\n    (a_bv ^ b_bv) as int\n}\n\nspec fn min_of_sequence(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = min_of_sequence(s.skip(1));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(lst: Vec<i8>) -> (result: i8)\n    requires valid_input(lst@.map(|i: int, x: i8| x as int))\n    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(lst: Seq<int>) -> bool {\n    5 <= lst.len() <= 10 &&\n    forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32\n}\n\nspec fn int_xor(a: int, b: int) -> int {\n    let a_bv = a as u32;\n    let b_bv = b as u32;\n    (a_bv ^ b_bv) as int\n}\n\nspec fn min_of_sequence(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = min_of_sequence(s.skip(1));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(lst: Vec<i8>) -> (result: i8)\n    requires valid_input(lst@.map(|i: int, x: i8| x as int))\n    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1195.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 987, "minimize_time_ms": 123118, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(lst: Seq<int>) -> bool {\n\nspec fn int_xor(a: int, b: int) -> int {\n\nspec fn min_of_sequence(s: Seq<int>) -> int\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    requires valid_input(lst@.map(|i: int, x: i8| x as int))\n\n    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(lst: Seq<int>) -> bool {\n    5 <= lst.len() <= 10 &&\n    forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32\n}\n\nspec fn int_xor(a: int, b: int) -> int {\n    let a_bv = a as u32;\n    let b_bv = b as u32;\n    (a_bv ^ b_bv) as int\n}\n\nspec fn min_of_sequence(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = min_of_sequence(s.skip(1));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(lst: Vec<i8>) -> (result: i8)\n    requires valid_input(lst@.map(|i: int, x: i8| x as int))\n    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1212_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_window(heights: Seq<int>, start: int, k: int) -> int\n  decreases k\n{\n  if 0 <= start && start + k <= heights.len() && k > 0 {\n    if k == 1 { heights[start] }\n    else { heights[start] + sum_window(heights, start + 1, k - 1) }\n  } else {\n    0\n  }\n}\n\nspec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool\n{\n  1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> (1 <= #[trigger] heights[i] <= 100)\n}\n\nspec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool\n{\n  &&& valid_input(n, k, heights)\n  &&& 1 <= result <= n-k+1\n  &&& (forall|start: int| 0 <= start <= n-k ==> \n        sum_window(heights, result-1, k) <= #[trigger] sum_window(heights, start, k))\n  &&& (forall|start: int| 0 <= start < result-1 ==>\n        #[trigger] sum_window(heights, start, k) > sum_window(heights, result-1, k))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, heights: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_window(heights: Seq<int>, start: int, k: int) -> int\n  decreases k\n{\n  if 0 <= start && start + k <= heights.len() && k > 0 {\n    if k == 1 { heights[start] }\n    else { heights[start] + sum_window(heights, start + 1, k - 1) }\n  } else {\n    0\n  }\n}\n\nspec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool\n{\n  1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> (1 <= #[trigger] heights[i] <= 100)\n}\n\nspec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool\n{\n  &&& valid_input(n, k, heights)\n  &&& 1 <= result <= n-k+1\n  &&& (forall|start: int| 0 <= start <= n-k ==> \n        sum_window(heights, result-1, k) <= #[trigger] sum_window(heights, start, k))\n  &&& (forall|start: int| 0 <= start < result-1 ==>\n        #[trigger] sum_window(heights, start, k) > sum_window(heights, result-1, k))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, heights: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1212.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 676, "minimize_time_ms": 123493, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn sum_window(heights: Seq<int>, start: int, k: int) -> int\n  decreases k\n{\n\nspec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool\n{\n\nspec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool\n{\n\n  decreases k\n\n  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n\n  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_window(heights: Seq<int>, start: int, k: int) -> int\n  decreases k\n{\n  if 0 <= start && start + k <= heights.len() && k > 0 {\n    if k == 1 { heights[start] }\n    else { heights[start] + sum_window(heights, start + 1, k - 1) }\n  } else {\n    0\n  }\n}\n\nspec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool\n{\n  1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> (1 <= #[trigger] heights[i] <= 100)\n}\n\nspec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool\n{\n  &&& valid_input(n, k, heights)\n  &&& 1 <= result <= n-k+1\n  &&& (forall|start: int| 0 <= start <= n-k ==> \n        sum_window(heights, result-1, k) <= #[trigger] sum_window(heights, start, k))\n  &&& (forall|start: int| 0 <= start < result-1 ==>\n        #[trigger] sum_window(heights, start, k) > sum_window(heights, result-1, k))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, heights: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n               fn main() {\n     }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1218_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 2\n}\n\nspec fn impossibility_condition(n: int, k: int) -> bool\n    recommends valid_input(n, k)\n{\n    2 * (n - 1) - k * (k - 1) > 0\n}\n\nspec fn quadratic_condition(x: int, n: int, k: int) -> bool {\n    x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0\n}\n\nspec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {\n    (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0\n}\n\nspec fn valid_solution(n: int, k: int, result: int) -> bool\n    recommends valid_input(n, k)\n{\n    if impossibility_condition(n, k) {\n        result == -1\n    } else {\n        result >= 0 && result <= k &&\n        exists|x: int| #[trigger] quadratic_condition(x, n, k) &&\n            x >= 0 && \n            quadratic_condition(x, n, k) && \n            (x == 0 || next_quadratic_condition(x, n, k)) &&\n            result == k - x\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= -1,\n        (result == -1) <==> impossibility_condition(n as int, k as int),\n        valid_solution(n as int, k as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 2\n}\n\nspec fn impossibility_condition(n: int, k: int) -> bool\n    recommends valid_input(n, k)\n{\n    2 * (n - 1) - k * (k - 1) > 0\n}\n\nspec fn quadratic_condition(x: int, n: int, k: int) -> bool {\n    x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0\n}\n\nspec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {\n    (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0\n}\n\nspec fn valid_solution(n: int, k: int, result: int) -> bool\n    recommends valid_input(n, k)\n{\n    if impossibility_condition(n, k) {\n        result == -1\n    } else {\n        result >= 0 && result <= k &&\n        exists|x: int| #[trigger] quadratic_condition(x, n, k) &&\n            x >= 0 && \n            quadratic_condition(x, n, k) && \n            (x == 0 || next_quadratic_condition(x, n, k)) &&\n            result == k - x\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= -1,\n        (result == -1) <==> impossibility_condition(n as int, k as int),\n        valid_solution(n as int, k as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1218.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 649, "minimize_time_ms": 122483, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int) -> bool {\n\nspec fn impossibility_condition(n: int, k: int) -> bool\n    recommends valid_input(n, k)\n{\n\nspec fn quadratic_condition(x: int, n: int, k: int) -> bool {\n\nspec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {\n\nspec fn valid_solution(n: int, k: int, result: int) -> bool\n    recommends valid_input(n, k)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 2\n}\n\nspec fn impossibility_condition(n: int, k: int) -> bool\n    recommends valid_input(n, k)\n{\n    2 * (n - 1) - k * (k - 1) > 0\n}\n\nspec fn quadratic_condition(x: int, n: int, k: int) -> bool {\n    x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0\n}\n\nspec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {\n    (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0\n}\n\nspec fn valid_solution(n: int, k: int, result: int) -> bool\n    recommends valid_input(n, k)\n{\n    if impossibility_condition(n, k) {\n        result == -1\n    } else {\n        result >= 0 && result <= k &&\n        exists|x: int| #[trigger] quadratic_condition(x, n, k) &&\n            x >= 0 && \n            quadratic_condition(x, n, k) && \n            (x == 0 || next_quadratic_condition(x, n, k)) &&\n            result == k - x\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= -1,\n        (result == -1) <==> impossibility_condition(n as int, k as int),\n        valid_solution(n as int, k as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1225_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(h: int) -> bool {\n    h >= 1\n}\n\nspec fn compute_attacks(h: int) -> int\n    recommends h >= 0\n{\n    if h == 0 { 0 }\n    else { compute_attacks_iterative(h, 0) }\n}\n\nspec fn compute_attacks_iterative(h: int, n: int) -> int\n    recommends h >= 0 && n >= 0\n    decreases h when h > 0\n{\n    if h == 0 { 0 }\n    else { pow2(n) + compute_attacks_iterative(h / 2, n + 1) }\n}\n\nspec fn pow2(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 { 1 }\n    else { 2 * pow2(n - 1) }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    parse_int_helper(s, 0, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    recommends 0 <= i <= s.len() && acc >= 0\n    decreases s.len() - i\n{\n    if i >= s.len() || s[i] == '\\n' || s[i] == ' ' {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        parse_int_helper(s, i + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n, seq![]) }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n when n > 0\n{\n    if n == 0 { acc }\n    else {\n        let digit = n % 10;\n        let digit_char = ('0' as int + digit) as char;\n        int_to_string_helper(n / 10, seq![digit_char].add(acc))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires stdin_input@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(h: int) -> bool {\n    h >= 1\n}\n\nspec fn compute_attacks(h: int) -> int\n    recommends h >= 0\n{\n    if h == 0 { 0 }\n    else { compute_attacks_iterative(h, 0) }\n}\n\nspec fn compute_attacks_iterative(h: int, n: int) -> int\n    recommends h >= 0 && n >= 0\n    decreases h when h > 0\n{\n    if h == 0 { 0 }\n    else { pow2(n) + compute_attacks_iterative(h / 2, n + 1) }\n}\n\nspec fn pow2(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 { 1 }\n    else { 2 * pow2(n - 1) }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    parse_int_helper(s, 0, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    recommends 0 <= i <= s.len() && acc >= 0\n    decreases s.len() - i\n{\n    if i >= s.len() || s[i] == '\\n' || s[i] == ' ' {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        parse_int_helper(s, i + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n, seq![]) }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n when n > 0\n{\n    if n == 0 { acc }\n    else {\n        let digit = n % 10;\n        let digit_char = ('0' as int + digit) as char;\n        int_to_string_helper(n / 10, seq![digit_char].add(acc))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires stdin_input@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1225.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 708, "minimize_time_ms": 122749, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 90, "minimized_LOC": 90, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(h: int) -> bool {\n\nspec fn compute_attacks(h: int) -> int\n    recommends h >= 0\n{\n\nspec fn compute_attacks_iterative(h: int, n: int) -> int\n    recommends h >= 0 && n >= 0\n    decreases h when h > 0\n{\n\nspec fn pow2(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n\nspec fn parse_int_func(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    recommends 0 <= i <= s.len() && acc >= 0\n    decreases s.len() - i\n{\n\nspec fn int_to_string_func(n: int) -> Seq<char>\n    recommends n >= 0\n{\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n when n > 0\n{\n\n    decreases h when h > 0\n\n    decreases n\n\n    decreases s.len() - i\n\n    decreases n when n > 0\n\n    requires stdin_input@.len() > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(h: int) -> bool {\n    h >= 1\n}\n\nspec fn compute_attacks(h: int) -> int\n    recommends h >= 0\n{\n    if h == 0 { 0 }\n    else { compute_attacks_iterative(h, 0) }\n}\n\nspec fn compute_attacks_iterative(h: int, n: int) -> int\n    recommends h >= 0 && n >= 0\n    decreases h when h > 0\n{\n    if h == 0 { 0 }\n    else { pow2(n) + compute_attacks_iterative(h / 2, n + 1) }\n}\n\nspec fn pow2(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 { 1 }\n    else { 2 * pow2(n - 1) }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    parse_int_helper(s, 0, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    recommends 0 <= i <= s.len() && acc >= 0\n    decreases s.len() - i\n{\n    if i >= s.len() || s[i] == '\\n' || s[i] == ' ' {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        parse_int_helper(s, i + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n, seq![]) }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n when n > 0\n{\n    if n == 0 { acc }\n    else {\n        let digit = n % 10;\n        let digit_char = ('0' as int + digit) as char;\n        int_to_string_helper(n / 10, seq![digit_char].add(acc))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires stdin_input@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1227_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_non_zero_digits(n: int) -> int\n    decreases n when n >= 0\n{\n    if n == 0 { 0 }\n    else if n % 10 == 0 { count_non_zero_digits(n / 10) }\n    else { 1 + count_non_zero_digits(n / 10) }\n}\n\nspec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int\n{\n    count_range(n, k, 1, n)\n}\n\nspec fn count_range(n: int, k: int, start: int, end: int) -> int\n    decreases if end < start { 0int } else { end - start + 1 }\n{\n    if start > end { 0 }\n    else if count_non_zero_digits(start) == k { \n        1 + count_range(n, k, start + 1, end)\n    } else { \n        count_range(n, k, start + 1, end)\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 1 && k <= 3\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_numbers_with_exactly_k_non_zero_digits(n: i8, k: i8) -> (count: i8)\nrequires\n    valid_input(n as int, k as int)\nensures\n    count as int == count_numbers_with_k_non_zero_digits(n as int, k as int),\n    count as int >= 0,\n    count as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_non_zero_digits(n: int) -> int\n    decreases n when n >= 0\n{\n    if n == 0 { 0 }\n    else if n % 10 == 0 { count_non_zero_digits(n / 10) }\n    else { 1 + count_non_zero_digits(n / 10) }\n}\n\nspec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int\n{\n    count_range(n, k, 1, n)\n}\n\nspec fn count_range(n: int, k: int, start: int, end: int) -> int\n    decreases if end < start { 0int } else { end - start + 1 }\n{\n    if start > end { 0 }\n    else if count_non_zero_digits(start) == k { \n        1 + count_range(n, k, start + 1, end)\n    } else { \n        count_range(n, k, start + 1, end)\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 1 && k <= 3\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_numbers_with_exactly_k_non_zero_digits(n: i8, k: i8) -> (count: i8)\nrequires\n    valid_input(n as int, k as int)\nensures\n    count as int == count_numbers_with_k_non_zero_digits(n as int, k as int),\n    count as int >= 0,\n    count as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1227.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 636, "minimize_time_ms": 122469, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_non_zero_digits(n: int) -> int\n    decreases n when n >= 0\n{\n\nspec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int\n{\n\nspec fn count_range(n: int, k: int, start: int, end: int) -> int\n    decreases if end < start {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n\n    decreases n when n >= 0\n\n    decreases if end < start { 0int } else { end - start + 1 }\n\nrequires\n\nensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_non_zero_digits(n: int) -> int\n    decreases n when n >= 0\n{\n    if n == 0 { 0 }\n    else if n % 10 == 0 { count_non_zero_digits(n / 10) }\n    else { 1 + count_non_zero_digits(n / 10) }\n}\n\nspec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int\n{\n    count_range(n, k, 1, n)\n}\n\nspec fn count_range(n: int, k: int, start: int, end: int) -> int\n    decreases if end < start { 0int } else { end - start + 1 }\n{\n    if start > end { 0 }\n    else if count_non_zero_digits(start) == k { \n        1 + count_range(n, k, start + 1, end)\n    } else { \n        count_range(n, k, start + 1, end)\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 1 && k <= 3\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_numbers_with_exactly_k_non_zero_digits(n: i8, k: i8) -> (count: i8)\nrequires\n    valid_input(n as int, k as int)\nensures\n    count as int == count_numbers_with_k_non_zero_digits(n as int, k as int),\n    count as int >= 0,\n    count as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1228_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn get_category(hp: int) -> char {\n        let remainder = hp % 4;\n        if remainder == 1 {\n            'A'\n        } else if remainder == 3 {\n            'B'\n        } else if remainder == 2 {\n            'C'\n        } else {\n            'D'\n        }\n    }\n    \n    spec fn valid_input(n: int) -> bool {\n        30 <= n <= 100\n    }\n    \n    spec fn valid_output(a: int, b: char) -> bool {\n        0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')\n    }\n    \n    spec fn optimal_choice(n: int, a: int, b: char) -> bool {\n        b == get_category(n + a) &&\n        ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&\n        ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&\n        ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&\n        ((n % 4 == 0) ==> (a == 1 && b == 'A'))\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: (i8, char))\n    requires \n        30 <= n <= 100\n    ensures \n        0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),\n        optimal_choice(n as int, result.0 as int, result.1),\n        result.1 == 'A' || result.1 == 'B'\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 'A')\n}\n// </vc-code>\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn get_category(hp: int) -> char {\n        let remainder = hp % 4;\n        if remainder == 1 {\n            'A'\n        } else if remainder == 3 {\n            'B'\n        } else if remainder == 2 {\n            'C'\n        } else {\n            'D'\n        }\n    }\n    \n    spec fn valid_input(n: int) -> bool {\n        30 <= n <= 100\n    }\n    \n    spec fn valid_output(a: int, b: char) -> bool {\n        0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')\n    }\n    \n    spec fn optimal_choice(n: int, a: int, b: char) -> bool {\n        b == get_category(n + a) &&\n        ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&\n        ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&\n        ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&\n        ((n % 4 == 0) ==> (a == 1 && b == 'A'))\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: (i8, char))\n    requires \n        30 <= n <= 100\n    ensures \n        0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),\n        optimal_choice(n as int, result.0 as int, result.1),\n        result.1 == 'A' || result.1 == 'B'\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 'A')\n}\n// </vc-code>\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1228.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 650, "minimize_time_ms": 122478, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn get_category(hp: int) -> char {\n\nspec fn valid_input(n: int) -> bool {\n\nspec fn valid_output(a: int, b: char) -> bool {\n\nspec fn optimal_choice(n: int, a: int, b: char) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn get_category(hp: int) -> char {\n        let remainder = hp % 4;\n        if remainder == 1 {\n            'A'\n        } else if remainder == 3 {\n            'B'\n        } else if remainder == 2 {\n            'C'\n        } else {\n            'D'\n        }\n    }\n    \n    spec fn valid_input(n: int) -> bool {\n        30 <= n <= 100\n    }\n    \n    spec fn valid_output(a: int, b: char) -> bool {\n        0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')\n    }\n    \n    spec fn optimal_choice(n: int, a: int, b: char) -> bool {\n        b == get_category(n + a) &&\n        ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&\n        ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&\n        ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&\n        ((n % 4 == 0) ==> (a == 1 && b == 'A'))\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: (i8, char))\n    requires \n        30 <= n <= 100\n    ensures \n        0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),\n        optimal_choice(n as int, result.0 as int, result.1),\n        result.1 == 'A' || result.1 == 'B'\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 'A')\n}\n// </vc-code>\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1240_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(columns: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < columns.len() ==> columns[i].0 > 0 && columns[i].1 > 0\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn sum_left(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].0 + sum_left(columns.drop_first())\n    }\n}\n\nspec fn sum_right(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].1 + sum_right(columns.drop_first())\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(columns: Vec<(i8, i8)>) -> (result: i8)\n    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))\n    ensures 0 <= result as int <= columns@.len()\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(columns: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < columns.len() ==> columns[i].0 > 0 && columns[i].1 > 0\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn sum_left(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].0 + sum_left(columns.drop_first())\n    }\n}\n\nspec fn sum_right(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].1 + sum_right(columns.drop_first())\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(columns: Vec<(i8, i8)>) -> (result: i8)\n    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))\n    ensures 0 <= result as int <= columns@.len()\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1240.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 742, "minimize_time_ms": 122505, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(columns: Seq<(int, int)>) -> bool {\n\nspec fn abs(x: int) -> int {\n\nspec fn sum_left(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n\nspec fn sum_right(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n\n    decreases columns.len()\n\n    decreases columns.len()\n\n    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))\n\n    ensures 0 <= result as int <= columns@.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(columns: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < columns.len() ==> columns[i].0 > 0 && columns[i].1 > 0\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn sum_left(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].0 + sum_left(columns.drop_first())\n    }\n}\n\nspec fn sum_right(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].1 + sum_right(columns.drop_first())\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(columns: Vec<(i8, i8)>) -> (result: i8)\n    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))\n    ensures 0 <= result as int <= columns@.len()\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_125_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_newlines(s: Seq<char>, idx: int) -> int\n    decreases s.len() - idx\n{\n    if idx >= s.len() {\n        0\n    } else if s[idx] == '\\n' {\n        1 + count_newlines(s, idx + 1)\n    } else {\n        count_newlines(s, idx + 1)\n    }\n}\n\nspec fn valid_input_string(s: Seq<char>) -> bool {\n    s.len() >= 7 &&\n    contains_four_lines(s) &&\n    all_lines_have_four_valid_integers(s)\n}\n\nspec fn contains_four_lines(s: Seq<char>) -> bool {\n    count_newlines(s, 0) >= 3\n}\n\nspec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1' || s[i] == ' ' || s[i] == '\\n')\n}\n\nspec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {\n    input_lines.len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&\n    (forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> \n        (#[trigger] input_lines[i][j] >= 0 && #[trigger] input_lines[i][j] <= 1)) &&\n    string_contains_four_lines_of_four_integers(s, input_lines)\n}\n\nspec fn string_contains_four_lines_of_four_integers(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {\n    input_lines.len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&\n    valid_input_string(s)\n}\n\nspec fn accident_possible(lanes: Seq<Seq<int>>) -> bool\n    recommends \n        lanes.len() == 4,\n        forall|i: int| 0 <= i < 4 ==> #[trigger] lanes[i].len() == 4,\n        forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> \n            (#[trigger] lanes[i][j] == 0 || #[trigger] lanes[i][j] == 1)\n{\n    exists|i: int| 0 <= i < 4 && accident_at_lane(i, lanes)\n}\n\nspec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool\n    recommends \n        0 <= i < 4,\n        lanes.len() == 4,\n        forall|j: int| 0 <= j < 4 ==> #[trigger] lanes[j].len() == 4\n{\n    (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||\n    (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||\n    (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||\n    (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> (#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),\n        valid_input_string(s@)\n    ensures \n        result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@,\n        exists|input_lines: Seq<Seq<int>>| \n            parse_input(s@, input_lines) && \n            (result@ == \"YES\\n\"@ <==> accident_possible(input_lines)),\n        result.len() >= 3\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn count_newlines(s: Seq<char>, idx: int) -> int     decreases s.len() - idx ;\n       spec fn valid_input_string(s: Seq<char>) -> bool ;\n       spec fn contains_four_lines(s: Seq<char>) -> bool ;\n       spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool ;\n       spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;\n       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n          (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||     (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||     (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||     (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1) }\n       fn solve(s: Vec<char>) -> (result: Vec<char>)     requires          s.len() > 0,         forall|i: int| 0 <= i < s.len() ==> (       \n#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),\n        valid_input_string(s@)     ensures          result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@,         exists|input_lines: Seq<Seq<int>>|              parse_input(s@, input_lines) &&              (result@ == \"YES\\n\"@ <==> accident_possible(input_lines)),         result.len() >= 3 {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_125.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 712, "minimize_time_ms": 185885, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 97, "minimized_LOC": 22, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.2268041237113402}, "labeling": {"segments": {"exec": " fn solve(s: Vec<char>) -> (result: Vec<char>)     requires          s.len() > 0,         forall|i: int| 0 <= i < s.len() ==> (       \n#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),\n        valid_input_string(s@)     ensures          result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@,         exists|input_lines: Seq<Seq<int>>|              parse_input(s@, input_lines) &&              (result@ == \"YES\\n\"@ <==> accident_possible(input_lines)),         result.len() >= 3 {\n\n fn main() {", "spec": "spec fn count_newlines(s: Seq<char>, idx: int) -> int     decreases s.len() - idx ;\n       spec fn valid_input_string(s: Seq<char>) -> bool ;\n       spec fn contains_four_lines(s: Seq<char>) -> bool ;\n       spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool ;\n       spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;\n       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n\nspec fn valid_input_string(s: Seq<char>) -> bool ;\n       spec fn contains_four_lines(s: Seq<char>) -> bool ;\n       spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool ;\n       spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;\n       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n\nspec fn contains_four_lines(s: Seq<char>) -> bool ;\n       spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool ;\n       spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;\n       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n\nspec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool ;\n       spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;\n       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n\nspec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;\n       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n\nspec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n\nspec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n\n       spec fn count_newlines(s: Seq<char>, idx: int) -> int     decreases s.len() - idx ;\n\n       fn solve(s: Vec<char>) -> (result: Vec<char>)     requires          s.len() > 0,         forall|i: int| 0 <= i < s.len() ==> (       \n\n        valid_input_string(s@)     ensures          result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@,         exists|input_lines: Seq<Seq<int>>|              parse_input(s@, input_lines) &&              (result@ == \"YES\\n\"@ <==> accident_possible(input_lines)),         result.len() >= 3 {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_newlines(s: Seq<char>, idx: int) -> int\n    decreases s.len() - idx\n{\n    if idx >= s.len() {\n        0\n    } else if s[idx] == '\\n' {\n        1 + count_newlines(s, idx + 1)\n    } else {\n        count_newlines(s, idx + 1)\n    }\n}\n\nspec fn valid_input_string(s: Seq<char>) -> bool {\n    s.len() >= 7 &&\n    contains_four_lines(s) &&\n    all_lines_have_four_valid_integers(s)\n}\n\nspec fn contains_four_lines(s: Seq<char>) -> bool {\n    count_newlines(s, 0) >= 3\n}\n\nspec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1' || s[i] == ' ' || s[i] == '\\n')\n}\n\nspec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {\n    input_lines.len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&\n    (forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> \n        (#[trigger] input_lines[i][j] >= 0 && #[trigger] input_lines[i][j] <= 1)) &&\n    string_contains_four_lines_of_four_integers(s, input_lines)\n}\n\nspec fn string_contains_four_lines_of_four_integers(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {\n    input_lines.len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&\n    valid_input_string(s)\n}\n\nspec fn accident_possible(lanes: Seq<Seq<int>>) -> bool\n    recommends \n        lanes.len() == 4,\n        forall|i: int| 0 <= i < 4 ==> #[trigger] lanes[i].len() == 4,\n        forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> \n            (#[trigger] lanes[i][j] == 0 || #[trigger] lanes[i][j] == 1)\n{\n    exists|i: int| 0 <= i < 4 && accident_at_lane(i, lanes)\n}\n\nspec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool\n    recommends \n        0 <= i < 4,\n        lanes.len() == 4,\n        forall|j: int| 0 <= j < 4 ==> #[trigger] lanes[j].len() == 4\n{\n    (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||\n    (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||\n    (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||\n    (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> (#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),\n        valid_input_string(s@)\n    ensures \n        result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@,\n        exists|input_lines: Seq<Seq<int>>| \n            parse_input(s@, input_lines) && \n            (result@ == \"YES\\n\"@ <==> accident_possible(input_lines)),\n        result.len() >= 3\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn count_newlines(s: Seq<char>, idx: int) -> int     decreases s.len() - idx ;\n       spec fn valid_input_string(s: Seq<char>) -> bool ;\n       spec fn contains_four_lines(s: Seq<char>) -> bool ;\n       spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool ;\n       spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;\n       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n          (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||     (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||     (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||     (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1) }\n       fn solve(s: Vec<char>) -> (result: Vec<char>)     requires          s.len() > 0,         forall|i: int| 0 <= i < s.len() ==> (       \n#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),\n        valid_input_string(s@)     ensures          result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@,         exists|input_lines: Seq<Seq<int>>|              parse_input(s@, input_lines) &&              (result@ == \"YES\\n\"@ <==> accident_possible(input_lines)),         result.len() >= 3 {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1255_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {\n    let lines = split_lines_function(input);\n    if lines.len() == 0 { 0 } else { max_frequency_in_all_lines(lines) }\n}\n\nspec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(s, 0, 0, seq![])\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if start < s.len() { acc.push(s.subrange(start, s.len() as int)) } else { acc }\n    } else if s[i] == '\\n' {\n        let new_acc = if start < i { acc.push(s.subrange(start, i)) } else { acc };\n        split_lines_helper(s, i + 1, i + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, i + 1, acc)\n    }\n}\n\nspec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {\n    if lines.len() == 0 { 0 } else { max_frequency_helper(lines, 0, 0) }\n}\n\nspec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { current_max }\n    else {\n        let count = count_occurrences(lines, lines[index]);\n        let new_max = if count > current_max { count } else { current_max };\n        max_frequency_helper(lines, index + 1, new_max)\n    }\n}\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {\n    count_occurrences_helper(lines, target, 0, 0)\n}\n\nspec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { count }\n    else {\n        let new_count = if lines[index] == target { count + 1 } else { count };\n        count_occurrences_helper(lines, target, index + 1, new_count)\n    }\n}\n\nspec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int\n    decreases lines.len() - index\n{\n    if index + 1 >= lines.len() { lines.len() as int }\n    else if lines[index + 1] == lines[index] { skip_identical(lines, index + 1) }\n    else { index + 1 }\n}\n\nspec fn int_to_string_function(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n > 0 { int_to_string_helper(n, seq![]) }\n    else { seq!['0'] }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    let digit = n % 10;\n    let digit_char = ('0' as u32 + digit as u32) as char;\n    if n / 10 == 0 { seq![digit_char].add(acc) }\n    else if n / 10 > 0 && n / 10 < n { int_to_string_helper(n / 10, seq![digit_char].add(acc)) }\n    else { seq![digit_char].add(acc) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {\n    let lines = split_lines_function(input);\n    if lines.len() == 0 { 0 } else { max_frequency_in_all_lines(lines) }\n}\n\nspec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(s, 0, 0, seq![])\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if start < s.len() { acc.push(s.subrange(start, s.len() as int)) } else { acc }\n    } else if s[i] == '\\n' {\n        let new_acc = if start < i { acc.push(s.subrange(start, i)) } else { acc };\n        split_lines_helper(s, i + 1, i + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, i + 1, acc)\n    }\n}\n\nspec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {\n    if lines.len() == 0 { 0 } else { max_frequency_helper(lines, 0, 0) }\n}\n\nspec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { current_max }\n    else {\n        let count = count_occurrences(lines, lines[index]);\n        let new_max = if count > current_max { count } else { current_max };\n        max_frequency_helper(lines, index + 1, new_max)\n    }\n}\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {\n    count_occurrences_helper(lines, target, 0, 0)\n}\n\nspec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { count }\n    else {\n        let new_count = if lines[index] == target { count + 1 } else { count };\n        count_occurrences_helper(lines, target, index + 1, new_count)\n    }\n}\n\nspec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int\n    decreases lines.len() - index\n{\n    if index + 1 >= lines.len() { lines.len() as int }\n    else if lines[index + 1] == lines[index] { skip_identical(lines, index + 1) }\n    else { index + 1 }\n}\n\nspec fn int_to_string_function(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n > 0 { int_to_string_helper(n, seq![]) }\n    else { seq!['0'] }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    let digit = n % 10;\n    let digit_char = ('0' as u32 + digit as u32) as char;\n    if n / 10 == 0 { seq![digit_char].add(acc) }\n    else if n / 10 > 0 && n / 10 < n { int_to_string_helper(n / 10, seq![digit_char].add(acc)) }\n    else { seq![digit_char].add(acc) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1255.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 726, "minimize_time_ms": 122434, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 106, "minimized_LOC": 106, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 21, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {\n\nspec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n\nspec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {\n\nspec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int\n    decreases lines.len() - index\n{\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {\n\nspec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int\n    decreases lines.len() - index\n{\n\nspec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int\n    decreases lines.len() - index\n{\n\nspec fn int_to_string_function(n: int) -> Seq<char> {\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n\n    decreases s.len() - i\n\n    decreases lines.len() - index\n\n    decreases lines.len() - index\n\n    decreases lines.len() - index\n\n    decreases n\n\n    requires valid_input(input@)\n\n    ensures result@.len() > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {\n    let lines = split_lines_function(input);\n    if lines.len() == 0 { 0 } else { max_frequency_in_all_lines(lines) }\n}\n\nspec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(s, 0, 0, seq![])\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if start < s.len() { acc.push(s.subrange(start, s.len() as int)) } else { acc }\n    } else if s[i] == '\\n' {\n        let new_acc = if start < i { acc.push(s.subrange(start, i)) } else { acc };\n        split_lines_helper(s, i + 1, i + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, i + 1, acc)\n    }\n}\n\nspec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {\n    if lines.len() == 0 { 0 } else { max_frequency_helper(lines, 0, 0) }\n}\n\nspec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { current_max }\n    else {\n        let count = count_occurrences(lines, lines[index]);\n        let new_max = if count > current_max { count } else { current_max };\n        max_frequency_helper(lines, index + 1, new_max)\n    }\n}\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {\n    count_occurrences_helper(lines, target, 0, 0)\n}\n\nspec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { count }\n    else {\n        let new_count = if lines[index] == target { count + 1 } else { count };\n        count_occurrences_helper(lines, target, index + 1, new_count)\n    }\n}\n\nspec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int\n    decreases lines.len() - index\n{\n    if index + 1 >= lines.len() { lines.len() as int }\n    else if lines[index + 1] == lines[index] { skip_identical(lines, index + 1) }\n    else { index + 1 }\n}\n\nspec fn int_to_string_function(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n > 0 { int_to_string_helper(n, seq![]) }\n    else { seq!['0'] }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    let digit = n % 10;\n    let digit_char = ('0' as u32 + digit as u32) as char;\n    if n / 10 == 0 { seq![digit_char].add(acc) }\n    else if n / 10 > 0 && n / 10 < n { int_to_string_helper(n / 10, seq![digit_char].add(acc)) }\n    else { seq![digit_char].add(acc) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_126_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn string_to_digits(s: Seq<char>) -> Set<int> {\n    Set::new(|i: int| \n        0 <= i < s.len() && \n        '0' <= s[i] && \n        s[i] <= '9' && \n        (s[i] as int) - ('0' as int) >= 0\n    ).map(|i: int| (s[i] as int) - ('0' as int))\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n')\n}\n\nspec fn has_unique_movement_sequence(digits: Set<int>) -> bool {\n    (digits.contains(1) || digits.contains(4) || digits.contains(7) || digits.contains(0)) &&\n    (digits.contains(1) || digits.contains(2) || digits.contains(3)) &&\n    (digits.contains(3) || digits.contains(6) || digits.contains(9) || digits.contains(0)) &&\n    (digits.contains(7) || digits.contains(0) || digits.contains(9))\n}\n\nspec fn find_char_index(s: Seq<char>, c: char) -> int {\n    if exists|i: int| 0 <= i < s.len() && s[i] == c {\n        choose|i: int| 0 <= i < s.len() && s[i] == c\n    } else {\n        -1\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if !s.contains('\\n') {\n        seq![s]\n    } else {\n        let idx = find_char_index(s, '\\n');\n        if idx == -1 {\n            seq![s]\n        } else if idx < s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx + 1, s.len() as int)))\n        } else {\n            seq![s]\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() == 3 || result@.len() == 4,\n        result@.len() > 0,\n        ({\n            let lines = split_lines(input@);\n            lines.len() >= 2 ==> {\n                let digits_str = lines[1];\n                let digits = string_to_digits(digits_str);\n                has_unique_movement_sequence(digits) ==> result@.len() == 4\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn string_to_digits(s: Seq<char>) -> Set<int> {\n    Set::new(|i: int| \n        0 <= i < s.len() && \n        '0' <= s[i] && \n        s[i] <= '9' && \n        (s[i] as int) - ('0' as int) >= 0\n    ).map(|i: int| (s[i] as int) - ('0' as int))\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n')\n}\n\nspec fn has_unique_movement_sequence(digits: Set<int>) -> bool {\n    (digits.contains(1) || digits.contains(4) || digits.contains(7) || digits.contains(0)) &&\n    (digits.contains(1) || digits.contains(2) || digits.contains(3)) &&\n    (digits.contains(3) || digits.contains(6) || digits.contains(9) || digits.contains(0)) &&\n    (digits.contains(7) || digits.contains(0) || digits.contains(9))\n}\n\nspec fn find_char_index(s: Seq<char>, c: char) -> int {\n    if exists|i: int| 0 <= i < s.len() && s[i] == c {\n        choose|i: int| 0 <= i < s.len() && s[i] == c\n    } else {\n        -1\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if !s.contains('\\n') {\n        seq![s]\n    } else {\n        let idx = find_char_index(s, '\\n');\n        if idx == -1 {\n            seq![s]\n        } else if idx < s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx + 1, s.len() as int)))\n        } else {\n            seq![s]\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() == 3 || result@.len() == 4,\n        result@.len() > 0,\n        ({\n            let lines = split_lines(input@);\n            lines.len() >= 2 ==> {\n                let digits_str = lines[1];\n                let digits = string_to_digits(digits_str);\n                has_unique_movement_sequence(digits) ==> result@.len() == 4\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_126.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 740, "minimize_time_ms": 122434, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 80, "minimized_LOC": 80, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn string_to_digits(s: Seq<char>) -> Set<int> {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn has_unique_movement_sequence(digits: Set<int>) -> bool {\n\nspec fn find_char_index(s: Seq<char>, c: char) -> int {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn string_to_digits(s: Seq<char>) -> Set<int> {\n    Set::new(|i: int| \n        0 <= i < s.len() && \n        '0' <= s[i] && \n        s[i] <= '9' && \n        (s[i] as int) - ('0' as int) >= 0\n    ).map(|i: int| (s[i] as int) - ('0' as int))\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n')\n}\n\nspec fn has_unique_movement_sequence(digits: Set<int>) -> bool {\n    (digits.contains(1) || digits.contains(4) || digits.contains(7) || digits.contains(0)) &&\n    (digits.contains(1) || digits.contains(2) || digits.contains(3)) &&\n    (digits.contains(3) || digits.contains(6) || digits.contains(9) || digits.contains(0)) &&\n    (digits.contains(7) || digits.contains(0) || digits.contains(9))\n}\n\nspec fn find_char_index(s: Seq<char>, c: char) -> int {\n    if exists|i: int| 0 <= i < s.len() && s[i] == c {\n        choose|i: int| 0 <= i < s.len() && s[i] == c\n    } else {\n        -1\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if !s.contains('\\n') {\n        seq![s]\n    } else {\n        let idx = find_char_index(s, '\\n');\n        if idx == -1 {\n            seq![s]\n        } else if idx < s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx + 1, s.len() as int)))\n        } else {\n            seq![s]\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() == 3 || result@.len() == 4,\n        result@.len() > 0,\n        ({\n            let lines = split_lines(input@);\n            lines.len() >= 2 ==> {\n                let digits_str = lines[1];\n                let digits = string_to_digits(digits_str);\n                has_unique_movement_sequence(digits) ==> result@.len() == 4\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1282_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'M' || input[i] == 'F'\n}\n\nspec fn compute_swap_time(input: Seq<char>) -> nat\n    recommends valid_input(input)\n{\n    let rev_input = input.reverse();\n    let first_f = find_char(rev_input, 'F', 0);\n\n    if first_f == -1 { 0nat }\n    else {\n        let first_m_after_f = find_char(rev_input, 'M', first_f + 1);\n        if first_m_after_f == -1 { 0nat }\n        else {\n            let last_m = rfind_char(rev_input, 'M');\n            if last_m < first_m_after_f { 0nat }\n            else {\n                let substring = rev_input.subrange(first_m_after_f, last_m + 1);\n                let balance = calculate_balance(substring);\n                let f_count = count_char(substring, 'F');\n                (balance + f_count + first_m_after_f - first_f - 1) as nat\n            }\n        }\n    }\n}\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start] == c { start }\n    else { find_char(s, c, start + 1) }\n}\n\nspec fn rfind_char(s: Seq<char>, c: char) -> int {\n    rfind_char_helper(s, c, s.len() as int - 1)\n}\n\nspec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int\n    decreases pos + 1\n{\n    if pos < 0 { -1 }\n    else if s[pos] == c { pos }\n    else { rfind_char_helper(s, c, pos - 1) }\n}\n\nspec fn calculate_balance(s: Seq<char>) -> nat {\n    calculate_balance_helper(s, 0, 0)\n}\n\nspec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { balance as nat }\n    else if s[pos] == 'M' { calculate_balance_helper(s, pos + 1, balance + 1) }\n    else { calculate_balance_helper(s, pos + 1, if balance > 0 { balance - 1 } else { 0 }) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> nat {\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { count }\n    else if s[pos] == c { count_char_helper(s, c, pos + 1, count + 1) }\n    else { count_char_helper(s, c, pos + 1, count) }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { nat_to_string_helper(n, seq![]) }\n}\n\nspec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    if n == 0 { acc }\n    else { nat_to_string_helper(n / 10, seq![('0' as u8 + (n % 10) as u8) as char] + acc) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|val: nat| val >= 0 && result@ == nat_to_string(val) + seq!['\\n'],\n        result@ == nat_to_string(compute_swap_time(input@)) + seq!['\\n']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'M' || input[i] == 'F'\n}\n\nspec fn compute_swap_time(input: Seq<char>) -> nat\n    recommends valid_input(input)\n{\n    let rev_input = input.reverse();\n    let first_f = find_char(rev_input, 'F', 0);\n\n    if first_f == -1 { 0nat }\n    else {\n        let first_m_after_f = find_char(rev_input, 'M', first_f + 1);\n        if first_m_after_f == -1 { 0nat }\n        else {\n            let last_m = rfind_char(rev_input, 'M');\n            if last_m < first_m_after_f { 0nat }\n            else {\n                let substring = rev_input.subrange(first_m_after_f, last_m + 1);\n                let balance = calculate_balance(substring);\n                let f_count = count_char(substring, 'F');\n                (balance + f_count + first_m_after_f - first_f - 1) as nat\n            }\n        }\n    }\n}\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start] == c { start }\n    else { find_char(s, c, start + 1) }\n}\n\nspec fn rfind_char(s: Seq<char>, c: char) -> int {\n    rfind_char_helper(s, c, s.len() as int - 1)\n}\n\nspec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int\n    decreases pos + 1\n{\n    if pos < 0 { -1 }\n    else if s[pos] == c { pos }\n    else { rfind_char_helper(s, c, pos - 1) }\n}\n\nspec fn calculate_balance(s: Seq<char>) -> nat {\n    calculate_balance_helper(s, 0, 0)\n}\n\nspec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { balance as nat }\n    else if s[pos] == 'M' { calculate_balance_helper(s, pos + 1, balance + 1) }\n    else { calculate_balance_helper(s, pos + 1, if balance > 0 { balance - 1 } else { 0 }) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> nat {\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { count }\n    else if s[pos] == c { count_char_helper(s, c, pos + 1, count + 1) }\n    else { count_char_helper(s, c, pos + 1, count) }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { nat_to_string_helper(n, seq![]) }\n}\n\nspec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    if n == 0 { acc }\n    else { nat_to_string_helper(n / 10, seq![('0' as u8 + (n % 10) as u8) as char] + acc) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|val: nat| val >= 0 && result@ == nat_to_string(val) + seq!['\\n'],\n        result@ == nat_to_string(compute_swap_time(input@)) + seq!['\\n']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1282.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 735, "minimize_time_ms": 122811, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 112, "minimized_LOC": 112, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 21, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn compute_swap_time(input: Seq<char>) -> nat\n    recommends valid_input(input)\n{\n\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n\nspec fn rfind_char(s: Seq<char>, c: char) -> int {\n\nspec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int\n    decreases pos + 1\n{\n\nspec fn calculate_balance(s: Seq<char>) -> nat {\n\nspec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat\n    decreases s.len() - pos\n{\n\nspec fn count_char(s: Seq<char>, c: char) -> nat {\n\nspec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat\n    decreases s.len() - pos\n{\n\nspec fn nat_to_string(n: nat) -> Seq<char> {\n\nspec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n\n    decreases s.len() - start\n\n    decreases pos + 1\n\n    decreases s.len() - pos\n\n    decreases s.len() - pos\n\n    decreases n\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'M' || input[i] == 'F'\n}\n\nspec fn compute_swap_time(input: Seq<char>) -> nat\n    recommends valid_input(input)\n{\n    let rev_input = input.reverse();\n    let first_f = find_char(rev_input, 'F', 0);\n\n    if first_f == -1 { 0nat }\n    else {\n        let first_m_after_f = find_char(rev_input, 'M', first_f + 1);\n        if first_m_after_f == -1 { 0nat }\n        else {\n            let last_m = rfind_char(rev_input, 'M');\n            if last_m < first_m_after_f { 0nat }\n            else {\n                let substring = rev_input.subrange(first_m_after_f, last_m + 1);\n                let balance = calculate_balance(substring);\n                let f_count = count_char(substring, 'F');\n                (balance + f_count + first_m_after_f - first_f - 1) as nat\n            }\n        }\n    }\n}\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start] == c { start }\n    else { find_char(s, c, start + 1) }\n}\n\nspec fn rfind_char(s: Seq<char>, c: char) -> int {\n    rfind_char_helper(s, c, s.len() as int - 1)\n}\n\nspec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int\n    decreases pos + 1\n{\n    if pos < 0 { -1 }\n    else if s[pos] == c { pos }\n    else { rfind_char_helper(s, c, pos - 1) }\n}\n\nspec fn calculate_balance(s: Seq<char>) -> nat {\n    calculate_balance_helper(s, 0, 0)\n}\n\nspec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { balance as nat }\n    else if s[pos] == 'M' { calculate_balance_helper(s, pos + 1, balance + 1) }\n    else { calculate_balance_helper(s, pos + 1, if balance > 0 { balance - 1 } else { 0 }) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> nat {\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { count }\n    else if s[pos] == c { count_char_helper(s, c, pos + 1, count + 1) }\n    else { count_char_helper(s, c, pos + 1, count) }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { nat_to_string_helper(n, seq![]) }\n}\n\nspec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    if n == 0 { acc }\n    else { nat_to_string_helper(n / 10, seq![('0' as u8 + (n % 10) as u8) as char] + acc) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|val: nat| val >= 0 && result@ == nat_to_string(val) + seq!['\\n'],\n        result@ == nat_to_string(compute_swap_time(input@)) + seq!['\\n']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1289_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn all_distances_equal(positions: Seq<int>) -> bool {\n    if positions.len() <= 2 {\n        true\n    } else {\n        let first_dist = positions[1] - positions[0];\n        true /* simplified to avoid trigger issues */\n    }\n}\n\nspec fn count_visits(visits: Seq<int>, stop: int) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn max_val(s: Seq<int>) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn sum(s: Seq<int>) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> {\n    let base_counts = Seq::new(n as nat, |i: int| count_visits(visits, i + 1));\n    Seq::new(n as nat, |i: int| \n        if i == 0 || i == n - 1 { \n            base_counts[i] * 2 \n        } else { \n            base_counts[i] \n        }\n    )\n}\n\nspec fn compute_max_rounds(counts: Seq<int>) -> int {\n    max_val(Seq::new(counts.len(), |i: int| counts[i] / 2))\n}\n\nspec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool {\n    let counts = compute_counts(n, visits);\n    let max_rounds = compute_max_rounds(counts);\n    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);\n    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;\n\n    all_zero && n > 2 && !all_distances_equal(positions)\n}\n\nspec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int {\n    let counts = compute_counts(n, visits);\n    let max_rounds = compute_max_rounds(counts);\n    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);\n    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;\n\n    if all_zero {\n        if n == 2 {\n            max_rounds * (positions[1] - positions[0]) * 2 - (positions[1] - positions[0])\n        } else {\n            let first_dist = positions[1] - positions[0];\n            max_rounds * first_dist * 2 * (n - 1) - first_dist\n        }\n    } else {\n        let edge_distance = sum(Seq::new((n-1) as nat, |i: int| min(remaining_counts[i], remaining_counts[i+1]) * (positions[i+1] - positions[i])));\n        let total_edge_length = sum(Seq::new((n-1) as nat, |i: int| positions[i+1] - positions[i]));\n        edge_distance + max_rounds * 2 * total_edge_length\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)\n    requires\n        n >= 1,\n        positions.len() == n as nat,\n        is_sorted(positions@.map(|i, x: i8| x as int)),\n        m >= 1,\n        visits.len() == m as nat\n    ensures\n        result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n            -1\n        } else {\n            calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn all_distances_equal(positions: Seq<int>) -> bool ;\n       spec fn count_visits(visits: Seq<int>, stop: int) -> int ;\n       spec fn max_val(s: Seq<int>) -> int ;\n       spec fn sum(s: Seq<int>) -> int ;\n       spec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n                  -1         }\n       else {\n                  calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))         }\n       {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1289.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 743, "minimize_time_ms": 215058, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 108, "minimized_LOC": 22, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.2037037037037037}, "labeling": {"segments": {"exec": " fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\n fn main() {", "spec": "spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn all_distances_equal(positions: Seq<int>) -> bool ;\n       spec fn count_visits(visits: Seq<int>, stop: int) -> int ;\n       spec fn max_val(s: Seq<int>) -> int ;\n       spec fn sum(s: Seq<int>) -> int ;\n       spec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn all_distances_equal(positions: Seq<int>) -> bool ;\n       spec fn count_visits(visits: Seq<int>, stop: int) -> int ;\n       spec fn max_val(s: Seq<int>) -> int ;\n       spec fn sum(s: Seq<int>) -> int ;\n       spec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn count_visits(visits: Seq<int>, stop: int) -> int ;\n       spec fn max_val(s: Seq<int>) -> int ;\n       spec fn sum(s: Seq<int>) -> int ;\n       spec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn max_val(s: Seq<int>) -> int ;\n       spec fn sum(s: Seq<int>) -> int ;\n       spec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn sum(s: Seq<int>) -> int ;\n       spec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\nspec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn all_distances_equal(positions: Seq<int>) -> bool {\n    if positions.len() <= 2 {\n        true\n    } else {\n        let first_dist = positions[1] - positions[0];\n        true /* simplified to avoid trigger issues */\n    }\n}\n\nspec fn count_visits(visits: Seq<int>, stop: int) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn max_val(s: Seq<int>) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn sum(s: Seq<int>) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> {\n    let base_counts = Seq::new(n as nat, |i: int| count_visits(visits, i + 1));\n    Seq::new(n as nat, |i: int| \n        if i == 0 || i == n - 1 { \n            base_counts[i] * 2 \n        } else { \n            base_counts[i] \n        }\n    )\n}\n\nspec fn compute_max_rounds(counts: Seq<int>) -> int {\n    max_val(Seq::new(counts.len(), |i: int| counts[i] / 2))\n}\n\nspec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool {\n    let counts = compute_counts(n, visits);\n    let max_rounds = compute_max_rounds(counts);\n    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);\n    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;\n\n    all_zero && n > 2 && !all_distances_equal(positions)\n}\n\nspec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int {\n    let counts = compute_counts(n, visits);\n    let max_rounds = compute_max_rounds(counts);\n    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);\n    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;\n\n    if all_zero {\n        if n == 2 {\n            max_rounds * (positions[1] - positions[0]) * 2 - (positions[1] - positions[0])\n        } else {\n            let first_dist = positions[1] - positions[0];\n            max_rounds * first_dist * 2 * (n - 1) - first_dist\n        }\n    } else {\n        let edge_distance = sum(Seq::new((n-1) as nat, |i: int| min(remaining_counts[i], remaining_counts[i+1]) * (positions[i+1] - positions[i])));\n        let total_edge_length = sum(Seq::new((n-1) as nat, |i: int| positions[i+1] - positions[i]));\n        edge_distance + max_rounds * 2 * total_edge_length\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)\n    requires\n        n >= 1,\n        positions.len() == n as nat,\n        is_sorted(positions@.map(|i, x: i8| x as int)),\n        m >= 1,\n        visits.len() == m as nat\n    ensures\n        result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n            -1\n        } else {\n            calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn all_distances_equal(positions: Seq<int>) -> bool ;\n       spec fn count_visits(visits: Seq<int>, stop: int) -> int ;\n       spec fn max_val(s: Seq<int>) -> int ;\n       spec fn sum(s: Seq<int>) -> int ;\n       spec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n                  -1         }\n       else {\n                  calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))         }\n       {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1291_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input.index(i) == '\\n') &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() >= 3\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output == \"YES\\n\"@ || output == \"NO\\n\"@\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    if lines.len() >= 1 {\n        let first_line = lines[0];\n        let nm_parts = split_whitespace(first_line);\n        if nm_parts.len() >= 2 {\n            let n = string_to_int(nm_parts[0]);\n            let m = string_to_int(nm_parts[1]);\n            let a_lines = if lines.len() > n { lines.subrange(1, n+1) } else { Seq::empty() };\n            let b_lines = if lines.len() > n + m { lines.subrange(n+1, n+m+1) } else { Seq::empty() };\n            (n, m, first_line, a_lines, b_lines)\n        } else {\n            let a_seq = Seq::new(1, |i: int| Seq::empty());\n            let b_seq = Seq::new(1, |i: int| Seq::empty());\n            (1, 1, first_line, a_seq, b_seq)\n        }\n    } else {\n        let a_seq = Seq::new(1, |i: int| Seq::empty());\n        let b_seq = Seq::new(1, |i: int| Seq::empty());\n        (1, 1, Seq::empty(), a_seq, b_seq)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for line splitting */\n}\n\nspec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for whitespace splitting */\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0 /* placeholder for string to int conversion */\n}\n\nspec fn solve_circle_separation(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let parsed = parse_input(input);\n    let n = parsed.0;\n    let m = parsed.1;\n    let nm_string = parsed.2;\n    let a = parsed.3;\n    let b = parsed.4;\n\n    if (\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == \"-1 0\"@) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == \"-1 0\"@) ||\n        (n == 3 && m == 3 && a.len() > 0 && a[0] == \"-3 -4\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"15 70\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"28 9\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"917 -4476\"@) ||\n        (n == 3 && m == 2 && a.len() > 0 && a[0] == \"9599 -9999\"@) ||\n        (n == 145 && m == 143 && a.len() > 0 && a[0] == \"-5915 6910\"@) ||\n        (n == 2 && m == 10 && a.len() >= 2 && ((a[0] == \"-1 0\"@ && a[1] == \"0 -1\"@) || (a[0] == \"1 0\"@ && a[1] == \"0 1\"@))) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == \"0 -1\"@) ||\n        (n == 100 && m == 100 && a.len() > 0 && a[0] == \"-10000 6429\"@)\n    ) { \n        \"NO\\n\"@\n    }\n    else if (\n        (n == 4 && m == 4 && a.len() > 0 && a[0] == \"1 0\"@) ||\n        (n == 3 && m == 4 && a.len() > 0 && a[0] == \"-9998 -10000\"@) ||\n        (n == 1) ||\n        (m == 1) ||\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == \"3782 2631\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-4729 -6837\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"6558 -2280\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-5051 5846\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-4547 4547\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"7010 10000\"@) ||\n        (n == 1948 && m == 1091 && a.len() > 0 && a[0] == \"-1873 -10000\"@) ||\n        (n == 1477 && m == 1211 && a.len() > 0 && a[0] == \"2770 -10000\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"5245 6141\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"-4957 8783\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"-1729 2513\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"8781 -5556\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"5715 5323\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"-1323 290\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"6828 3257\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"1592 -154\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"-1535 5405\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && (a[0] == \"-3041 8307\"@ || a[0] == \"-2797 3837\"@ || a[0] == \"8393 -5715\"@))\n    ) { \n        \"YES\\n\"@\n    }\n    else if (n >= 1000) { \n        \"NO\\n\"@\n    }\n    else { \n        \"YES\\n\"@\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        valid_output(result@) &&\n        result@ == solve_circle_separation(stdin_input@) &&\n        result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input.index(i) == '\\n') &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() >= 3\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output == \"YES\\n\"@ || output == \"NO\\n\"@\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    if lines.len() >= 1 {\n        let first_line = lines[0];\n        let nm_parts = split_whitespace(first_line);\n        if nm_parts.len() >= 2 {\n            let n = string_to_int(nm_parts[0]);\n            let m = string_to_int(nm_parts[1]);\n            let a_lines = if lines.len() > n { lines.subrange(1, n+1) } else { Seq::empty() };\n            let b_lines = if lines.len() > n + m { lines.subrange(n+1, n+m+1) } else { Seq::empty() };\n            (n, m, first_line, a_lines, b_lines)\n        } else {\n            let a_seq = Seq::new(1, |i: int| Seq::empty());\n            let b_seq = Seq::new(1, |i: int| Seq::empty());\n            (1, 1, first_line, a_seq, b_seq)\n        }\n    } else {\n        let a_seq = Seq::new(1, |i: int| Seq::empty());\n        let b_seq = Seq::new(1, |i: int| Seq::empty());\n        (1, 1, Seq::empty(), a_seq, b_seq)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for line splitting */\n}\n\nspec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for whitespace splitting */\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0 /* placeholder for string to int conversion */\n}\n\nspec fn solve_circle_separation(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let parsed = parse_input(input);\n    let n = parsed.0;\n    let m = parsed.1;\n    let nm_string = parsed.2;\n    let a = parsed.3;\n    let b = parsed.4;\n\n    if (\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == \"-1 0\"@) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == \"-1 0\"@) ||\n        (n == 3 && m == 3 && a.len() > 0 && a[0] == \"-3 -4\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"15 70\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"28 9\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"917 -4476\"@) ||\n        (n == 3 && m == 2 && a.len() > 0 && a[0] == \"9599 -9999\"@) ||\n        (n == 145 && m == 143 && a.len() > 0 && a[0] == \"-5915 6910\"@) ||\n        (n == 2 && m == 10 && a.len() >= 2 && ((a[0] == \"-1 0\"@ && a[1] == \"0 -1\"@) || (a[0] == \"1 0\"@ && a[1] == \"0 1\"@))) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == \"0 -1\"@) ||\n        (n == 100 && m == 100 && a.len() > 0 && a[0] == \"-10000 6429\"@)\n    ) { \n        \"NO\\n\"@\n    }\n    else if (\n        (n == 4 && m == 4 && a.len() > 0 && a[0] == \"1 0\"@) ||\n        (n == 3 && m == 4 && a.len() > 0 && a[0] == \"-9998 -10000\"@) ||\n        (n == 1) ||\n        (m == 1) ||\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == \"3782 2631\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-4729 -6837\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"6558 -2280\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-5051 5846\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-4547 4547\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"7010 10000\"@) ||\n        (n == 1948 && m == 1091 && a.len() > 0 && a[0] == \"-1873 -10000\"@) ||\n        (n == 1477 && m == 1211 && a.len() > 0 && a[0] == \"2770 -10000\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"5245 6141\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"-4957 8783\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"-1729 2513\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"8781 -5556\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"5715 5323\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"-1323 290\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"6828 3257\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"1592 -154\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"-1535 5405\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && (a[0] == \"-3041 8307\"@ || a[0] == \"-2797 3837\"@ || a[0] == \"8393 -5715\"@))\n    ) { \n        \"YES\\n\"@\n    }\n    else if (n >= 1000) { \n        \"NO\\n\"@\n    }\n    else { \n        \"YES\\n\"@\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        valid_output(result@) &&\n        result@ == solve_circle_separation(stdin_input@) &&\n        result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1291.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 771, "minimize_time_ms": 122597, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 140, "minimized_LOC": 140, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>) -> bool {\n\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)\n    recommends valid_input(input)\n{\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn solve_circle_separation(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n\n    requires valid_input(stdin_input@)\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input.index(i) == '\\n') &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() >= 3\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output == \"YES\\n\"@ || output == \"NO\\n\"@\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    if lines.len() >= 1 {\n        let first_line = lines[0];\n        let nm_parts = split_whitespace(first_line);\n        if nm_parts.len() >= 2 {\n            let n = string_to_int(nm_parts[0]);\n            let m = string_to_int(nm_parts[1]);\n            let a_lines = if lines.len() > n { lines.subrange(1, n+1) } else { Seq::empty() };\n            let b_lines = if lines.len() > n + m { lines.subrange(n+1, n+m+1) } else { Seq::empty() };\n            (n, m, first_line, a_lines, b_lines)\n        } else {\n            let a_seq = Seq::new(1, |i: int| Seq::empty());\n            let b_seq = Seq::new(1, |i: int| Seq::empty());\n            (1, 1, first_line, a_seq, b_seq)\n        }\n    } else {\n        let a_seq = Seq::new(1, |i: int| Seq::empty());\n        let b_seq = Seq::new(1, |i: int| Seq::empty());\n        (1, 1, Seq::empty(), a_seq, b_seq)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for line splitting */\n}\n\nspec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for whitespace splitting */\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0 /* placeholder for string to int conversion */\n}\n\nspec fn solve_circle_separation(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let parsed = parse_input(input);\n    let n = parsed.0;\n    let m = parsed.1;\n    let nm_string = parsed.2;\n    let a = parsed.3;\n    let b = parsed.4;\n\n    if (\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == \"-1 0\"@) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == \"-1 0\"@) ||\n        (n == 3 && m == 3 && a.len() > 0 && a[0] == \"-3 -4\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"15 70\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"28 9\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"917 -4476\"@) ||\n        (n == 3 && m == 2 && a.len() > 0 && a[0] == \"9599 -9999\"@) ||\n        (n == 145 && m == 143 && a.len() > 0 && a[0] == \"-5915 6910\"@) ||\n        (n == 2 && m == 10 && a.len() >= 2 && ((a[0] == \"-1 0\"@ && a[1] == \"0 -1\"@) || (a[0] == \"1 0\"@ && a[1] == \"0 1\"@))) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == \"0 -1\"@) ||\n        (n == 100 && m == 100 && a.len() > 0 && a[0] == \"-10000 6429\"@)\n    ) { \n        \"NO\\n\"@\n    }\n    else if (\n        (n == 4 && m == 4 && a.len() > 0 && a[0] == \"1 0\"@) ||\n        (n == 3 && m == 4 && a.len() > 0 && a[0] == \"-9998 -10000\"@) ||\n        (n == 1) ||\n        (m == 1) ||\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == \"3782 2631\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-4729 -6837\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"6558 -2280\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-5051 5846\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"-4547 4547\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"7010 10000\"@) ||\n        (n == 1948 && m == 1091 && a.len() > 0 && a[0] == \"-1873 -10000\"@) ||\n        (n == 1477 && m == 1211 && a.len() > 0 && a[0] == \"2770 -10000\"@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == \"5245 6141\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"-4957 8783\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"-1729 2513\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"8781 -5556\"@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == \"5715 5323\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"-1323 290\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"6828 3257\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"1592 -154\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && a[0] == \"-1535 5405\"@) ||\n        (nm_string == \"10000 10000\"@ && a.len() > 0 && (a[0] == \"-3041 8307\"@ || a[0] == \"-2797 3837\"@ || a[0] == \"8393 -5715\"@))\n    ) { \n        \"YES\\n\"@\n    }\n    else if (n >= 1000) { \n        \"NO\\n\"@\n    }\n    else { \n        \"YES\\n\"@\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        valid_output(result@) &&\n        result@ == solve_circle_separation(stdin_input@) &&\n        result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1298_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] == '0' || #[trigger] s[i] == '1')\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (s[0] != '0' || s.len() == 1) && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn abs_diff_count(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    let count0 = count_char(s, '0');\n    let count1 = count_char(s, '1');\n    if count1 >= count0 { count1 - count0 } else { count0 - count1 }\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { seq!['0'] }\n    else if n < 10 { seq![char_of_digit(n)] }\n    else { int_to_string(n / 10).add(seq![char_of_digit(n % 10)]) }\n}\n\nspec fn char_of_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0int { '0' }\n    else if d == 1int { '1' }\n    else if d == 2int { '2' }\n    else if d == 3int { '3' }\n    else if d == 4int { '4' }\n    else if d == 5int { '5' }\n    else if d == 6int { '6' }\n    else if d == 7int { '7' }\n    else if d == 8int { '8' }\n    else if d == 9int { '9' }\n    else { '0' }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else if s.len() == 1 { (s[0] as int) - ('0' as int) }\n    else { string_to_int(s.subrange(0, s.len() - 1)) * 10int + ((s[s.len() - 1] as int) - ('0' as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_valid_integer(stdin_input@.subrange(0, newline_pos)) &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end))\n            }\n        },\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end)) &&\n                result@ == int_to_string(abs_diff_count(stdin_input@.subrange(newline_pos + 1, binary_end))).add(seq!['\\n'])\n            }\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] == '0' || #[trigger] s[i] == '1')\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (s[0] != '0' || s.len() == 1) && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn abs_diff_count(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    let count0 = count_char(s, '0');\n    let count1 = count_char(s, '1');\n    if count1 >= count0 { count1 - count0 } else { count0 - count1 }\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { seq!['0'] }\n    else if n < 10 { seq![char_of_digit(n)] }\n    else { int_to_string(n / 10).add(seq![char_of_digit(n % 10)]) }\n}\n\nspec fn char_of_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0int { '0' }\n    else if d == 1int { '1' }\n    else if d == 2int { '2' }\n    else if d == 3int { '3' }\n    else if d == 4int { '4' }\n    else if d == 5int { '5' }\n    else if d == 6int { '6' }\n    else if d == 7int { '7' }\n    else if d == 8int { '8' }\n    else if d == 9int { '9' }\n    else { '0' }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else if s.len() == 1 { (s[0] as int) - ('0' as int) }\n    else { string_to_int(s.subrange(0, s.len() - 1)) * 10int + ((s[s.len() - 1] as int) - ('0' as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_valid_integer(stdin_input@.subrange(0, newline_pos)) &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end))\n            }\n        },\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end)) &&\n                result@ == int_to_string(abs_diff_count(stdin_input@.subrange(newline_pos + 1, binary_end))).add(seq!['\\n'])\n            }\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1298.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 722, "minimize_time_ms": 154468, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 107, "minimized_LOC": 107, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_binary_string(s: Seq<char>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n\nspec fn abs_diff_count(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n\nspec fn int_to_string(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n\nspec fn char_of_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    decreases n\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] == '0' || #[trigger] s[i] == '1')\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (s[0] != '0' || s.len() == 1) && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn abs_diff_count(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    let count0 = count_char(s, '0');\n    let count1 = count_char(s, '1');\n    if count1 >= count0 { count1 - count0 } else { count0 - count1 }\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { seq!['0'] }\n    else if n < 10 { seq![char_of_digit(n)] }\n    else { int_to_string(n / 10).add(seq![char_of_digit(n % 10)]) }\n}\n\nspec fn char_of_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0int { '0' }\n    else if d == 1int { '1' }\n    else if d == 2int { '2' }\n    else if d == 3int { '3' }\n    else if d == 4int { '4' }\n    else if d == 5int { '5' }\n    else if d == 6int { '6' }\n    else if d == 7int { '7' }\n    else if d == 8int { '8' }\n    else if d == 9int { '9' }\n    else { '0' }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else if s.len() == 1 { (s[0] as int) - ('0' as int) }\n    else { string_to_int(s.subrange(0, s.len() - 1)) * 10int + ((s[s.len() - 1] as int) - ('0' as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_valid_integer(stdin_input@.subrange(0, newline_pos)) &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end))\n            }\n        },\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end)) &&\n                result@ == int_to_string(abs_diff_count(stdin_input@.subrange(newline_pos + 1, binary_end))).add(seq!['\\n'])\n            }\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1301_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_pokemon_name(name: Seq<char>) -> bool {\n    name == seq!['v','a','p','o','r','e','o','n'] || \n    name == seq!['j','o','l','t','e','o','n'] || \n    name == seq!['f','l','a','r','e','o','n'] || \n    name == seq!['e','s','p','e','o','n'] ||\n    name == seq!['u','m','b','r','e','o','n'] || \n    name == seq!['l','e','a','f','e','o','n'] || \n    name == seq!['g','l','a','c','e','o','n'] || \n    name == seq!['s','y','l','v','e','o','n']\n}\n\nspec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool\n    recommends pokemon_name.len() == pattern.len()\n{\n    pokemon_name.len() == pattern.len() &&\n    forall|i: int| 0 <= i < pattern.len() ==> (pattern[i] == '.' || pattern[i] == pokemon_name[i])\n}\n\nspec fn get_pokemon_list() -> Seq<Seq<char>> {\n    seq![\n        seq!['v','a','p','o','r','e','o','n'],\n        seq!['j','o','l','t','e','o','n'],\n        seq!['f','l','a','r','e','o','n'],\n        seq!['e','s','p','e','o','n'],\n        seq!['u','m','b','r','e','o','n'],\n        seq!['l','e','a','f','e','o','n'],\n        seq!['g','l','a','c','e','o','n'],\n        seq!['s','y','l','v','e','o','n']\n    ]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* Additional validation logic would be implemented here */\n}\n\nspec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < pokemon_list.len() && \n        pokemon_list[i] == result &&\n        result.len() == pattern.len() &&\n        matches_pattern(result, pattern) &&\n        forall|j: int| 0 <= j < i ==> (pokemon_list[j].len() != pattern.len() || !matches_pattern(pokemon_list[j], pattern))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_pokemon_name(result@),\n        is_first_match(result@, input@, get_pokemon_list()),\n        exists|i: int| 0 <= i < get_pokemon_list().len() && \n            get_pokemon_list()[i] == result@ &&\n            matches_pattern(result@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_pokemon_name(name: Seq<char>) -> bool {\n    name == seq!['v','a','p','o','r','e','o','n'] || \n    name == seq!['j','o','l','t','e','o','n'] || \n    name == seq!['f','l','a','r','e','o','n'] || \n    name == seq!['e','s','p','e','o','n'] ||\n    name == seq!['u','m','b','r','e','o','n'] || \n    name == seq!['l','e','a','f','e','o','n'] || \n    name == seq!['g','l','a','c','e','o','n'] || \n    name == seq!['s','y','l','v','e','o','n']\n}\n\nspec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool\n    recommends pokemon_name.len() == pattern.len()\n{\n    pokemon_name.len() == pattern.len() &&\n    forall|i: int| 0 <= i < pattern.len() ==> (pattern[i] == '.' || pattern[i] == pokemon_name[i])\n}\n\nspec fn get_pokemon_list() -> Seq<Seq<char>> {\n    seq![\n        seq!['v','a','p','o','r','e','o','n'],\n        seq!['j','o','l','t','e','o','n'],\n        seq!['f','l','a','r','e','o','n'],\n        seq!['e','s','p','e','o','n'],\n        seq!['u','m','b','r','e','o','n'],\n        seq!['l','e','a','f','e','o','n'],\n        seq!['g','l','a','c','e','o','n'],\n        seq!['s','y','l','v','e','o','n']\n    ]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* Additional validation logic would be implemented here */\n}\n\nspec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < pokemon_list.len() && \n        pokemon_list[i] == result &&\n        result.len() == pattern.len() &&\n        matches_pattern(result, pattern) &&\n        forall|j: int| 0 <= j < i ==> (pokemon_list[j].len() != pattern.len() || !matches_pattern(pokemon_list[j], pattern))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_pokemon_name(result@),\n        is_first_match(result@, input@, get_pokemon_list()),\n        exists|i: int| 0 <= i < get_pokemon_list().len() && \n            get_pokemon_list()[i] == result@ &&\n            matches_pattern(result@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1301.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 690, "minimize_time_ms": 122516, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 75, "minimized_LOC": 75, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_pokemon_name(name: Seq<char>) -> bool {\n\nspec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool\n    recommends pokemon_name.len() == pattern.len()\n{\n\nspec fn get_pokemon_list() -> Seq<Seq<char>> {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_pokemon_name(name: Seq<char>) -> bool {\n    name == seq!['v','a','p','o','r','e','o','n'] || \n    name == seq!['j','o','l','t','e','o','n'] || \n    name == seq!['f','l','a','r','e','o','n'] || \n    name == seq!['e','s','p','e','o','n'] ||\n    name == seq!['u','m','b','r','e','o','n'] || \n    name == seq!['l','e','a','f','e','o','n'] || \n    name == seq!['g','l','a','c','e','o','n'] || \n    name == seq!['s','y','l','v','e','o','n']\n}\n\nspec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool\n    recommends pokemon_name.len() == pattern.len()\n{\n    pokemon_name.len() == pattern.len() &&\n    forall|i: int| 0 <= i < pattern.len() ==> (pattern[i] == '.' || pattern[i] == pokemon_name[i])\n}\n\nspec fn get_pokemon_list() -> Seq<Seq<char>> {\n    seq![\n        seq!['v','a','p','o','r','e','o','n'],\n        seq!['j','o','l','t','e','o','n'],\n        seq!['f','l','a','r','e','o','n'],\n        seq!['e','s','p','e','o','n'],\n        seq!['u','m','b','r','e','o','n'],\n        seq!['l','e','a','f','e','o','n'],\n        seq!['g','l','a','c','e','o','n'],\n        seq!['s','y','l','v','e','o','n']\n    ]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* Additional validation logic would be implemented here */\n}\n\nspec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < pokemon_list.len() && \n        pokemon_list[i] == result &&\n        result.len() == pattern.len() &&\n        matches_pattern(result, pattern) &&\n        forall|j: int| 0 <= j < i ==> (pokemon_list[j].len() != pattern.len() || !matches_pattern(pokemon_list[j], pattern))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_pokemon_name(result@),\n        is_first_match(result@, input@, get_pokemon_list()),\n        exists|i: int| 0 <= i < get_pokemon_list().len() && \n            get_pokemon_list()[i] == result@ &&\n            matches_pattern(result@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1312_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n  n >= m > 0\n}\n\nspec fn sum(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    s[0] + sum(s.subrange(1, s.len() as int)) \n  }\n}\n\nspec fn count(s: Seq<int>, val: int) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    (if s[0] == val { 1int } else { 0int }) + count(s.subrange(1, s.len() as int), val) \n  }\n}\n\nspec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {\n  &&& m > 0\n  &&& result.len() == m\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] > 0)\n  &&& sum(result) == n\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == n / m || result[i] == n / m + 1)\n  &&& count(result, n / m) == m - (n % m)\n  &&& count(result, n / m + 1) == n % m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int, m as int)\n  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n  n >= m > 0\n}\n\nspec fn sum(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    s[0] + sum(s.subrange(1, s.len() as int)) \n  }\n}\n\nspec fn count(s: Seq<int>, val: int) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    (if s[0] == val { 1int } else { 0int }) + count(s.subrange(1, s.len() as int), val) \n  }\n}\n\nspec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {\n  &&& m > 0\n  &&& result.len() == m\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] > 0)\n  &&& sum(result) == n\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == n / m || result[i] == n / m + 1)\n  &&& count(result, n / m) == m - (n % m)\n  &&& count(result, n / m + 1) == n % m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int, m as int)\n  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1312.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 690, "minimize_time_ms": 122504, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int) -> bool {\n\nspec fn sum(s: Seq<int>) -> int\n  decreases s.len()\n{\n\nspec fn count(s: Seq<int>, val: int) -> int\n  decreases s.len()\n{\n\nspec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {\n\n  decreases s.len()\n\n  decreases s.len()\n\n  requires valid_input(n as int, m as int)\n\n  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n  n >= m > 0\n}\n\nspec fn sum(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    s[0] + sum(s.subrange(1, s.len() as int)) \n  }\n}\n\nspec fn count(s: Seq<int>, val: int) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    (if s[0] == val { 1int } else { 0int }) + count(s.subrange(1, s.len() as int), val) \n  }\n}\n\nspec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {\n  &&& m > 0\n  &&& result.len() == m\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] > 0)\n  &&& sum(result) == n\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == n / m || result[i] == n / m + 1)\n  &&& count(result, n / m) == m - (n % m)\n  &&& count(result, n / m + 1) == n % m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int, m as int)\n  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1332_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(coins: Seq<int>) -> bool {\n    coins.len() == 5 && forall|i: int| 0 <= i < coins.len() ==> #[trigger] coins[i] >= 0 && #[trigger] coins[i] <= 100\n}\n\nspec fn total_coins(coins: Seq<int>) -> int {\n    if coins.len() == 5 { coins[0] + coins[1] + coins[2] + coins[3] + coins[4] } else { 0 }\n}\n\nspec fn has_valid_solution(coins: Seq<int>) -> bool {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        total > 0 && total % 5 == 0\n    } else {\n        false\n    }\n}\n\nspec fn compute_result(coins: Seq<int>) -> int {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        if total > 0 && total % 5 == 0 { total / 5 } else { -1 }\n    } else {\n        -1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(coins: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(coins@.map(|i, x| x as int)),\n    ensures\n        result as int == compute_result(coins@.map(|i, x| x as int)),\n        has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == total_coins(coins@.map(|i, x| x as int)) / 5,\n        !has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == -1,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(coins: Seq<int>) -> bool {\n    coins.len() == 5 && forall|i: int| 0 <= i < coins.len() ==> #[trigger] coins[i] >= 0 && #[trigger] coins[i] <= 100\n}\n\nspec fn total_coins(coins: Seq<int>) -> int {\n    if coins.len() == 5 { coins[0] + coins[1] + coins[2] + coins[3] + coins[4] } else { 0 }\n}\n\nspec fn has_valid_solution(coins: Seq<int>) -> bool {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        total > 0 && total % 5 == 0\n    } else {\n        false\n    }\n}\n\nspec fn compute_result(coins: Seq<int>) -> int {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        if total > 0 && total % 5 == 0 { total / 5 } else { -1 }\n    } else {\n        -1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(coins: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(coins@.map(|i, x| x as int)),\n    ensures\n        result as int == compute_result(coins@.map(|i, x| x as int)),\n        has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == total_coins(coins@.map(|i, x| x as int)) / 5,\n        !has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == -1,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1332.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 714, "minimize_time_ms": 123468, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(coins: Seq<int>) -> bool {\n\nspec fn total_coins(coins: Seq<int>) -> int {\n\nspec fn has_valid_solution(coins: Seq<int>) -> bool {\n\nspec fn compute_result(coins: Seq<int>) -> int {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(coins: Seq<int>) -> bool {\n    coins.len() == 5 && forall|i: int| 0 <= i < coins.len() ==> #[trigger] coins[i] >= 0 && #[trigger] coins[i] <= 100\n}\n\nspec fn total_coins(coins: Seq<int>) -> int {\n    if coins.len() == 5 { coins[0] + coins[1] + coins[2] + coins[3] + coins[4] } else { 0 }\n}\n\nspec fn has_valid_solution(coins: Seq<int>) -> bool {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        total > 0 && total % 5 == 0\n    } else {\n        false\n    }\n}\n\nspec fn compute_result(coins: Seq<int>) -> int {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        if total > 0 && total % 5 == 0 { total / 5 } else { -1 }\n    } else {\n        -1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(coins: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(coins@.map(|i, x| x as int)),\n    ensures\n        result as int == compute_result(coins@.map(|i, x| x as int)),\n        has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == total_coins(coins@.map(|i, x| x as int)) / 5,\n        !has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == -1,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1353_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: int, b: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    m >= 1 && m <= 1000 &&\n    a >= 1 && a <= 1000 &&\n    b >= 1 && b <= 1000\n}\n\nspec fn optimal_cost(n: int, m: int, a: int, b: int) -> int\n    recommends valid_input(n, m, a, b)\n{\n    if n * a <= ((n + m - 1) / m) * b {\n        if n * a <= (n / m) * b + (n % m) * a {\n            n * a\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    } else {\n        if ((n + m - 1) / m) * b <= (n / m) * b + (n % m) * a {\n            ((n + m - 1) / m) * b\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a as int, b as int),\n    ensures \n        result >= 0,\n        result as int == optimal_cost(n as int, m as int, a as int, b as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: int, b: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    m >= 1 && m <= 1000 &&\n    a >= 1 && a <= 1000 &&\n    b >= 1 && b <= 1000\n}\n\nspec fn optimal_cost(n: int, m: int, a: int, b: int) -> int\n    recommends valid_input(n, m, a, b)\n{\n    if n * a <= ((n + m - 1) / m) * b {\n        if n * a <= (n / m) * b + (n % m) * a {\n            n * a\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    } else {\n        if ((n + m - 1) / m) * b <= (n / m) * b + (n % m) * a {\n            ((n + m - 1) / m) * b\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a as int, b as int),\n    ensures \n        result >= 0,\n        result as int == optimal_cost(n as int, m as int, a as int, b as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1353.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 624, "minimize_time_ms": 122466, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 7, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, a: int, b: int) -> bool {\n\nspec fn optimal_cost(n: int, m: int, a: int, b: int) -> int\n    recommends valid_input(n, m, a, b)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: int, b: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    m >= 1 && m <= 1000 &&\n    a >= 1 && a <= 1000 &&\n    b >= 1 && b <= 1000\n}\n\nspec fn optimal_cost(n: int, m: int, a: int, b: int) -> int\n    recommends valid_input(n, m, a, b)\n{\n    if n * a <= ((n + m - 1) / m) * b {\n        if n * a <= (n / m) * b + (n % m) * a {\n            n * a\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    } else {\n        if ((n + m - 1) / m) * b <= (n / m) * b + (n % m) * a {\n            ((n + m - 1) / m) * b\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a as int, b as int),\n    ensures \n        result >= 0,\n        result as int == optimal_cost(n as int, m as int, a as int, b as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1356_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_a(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == 'a' { 1 as int } else { 0 as int }) + count_a(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && exists|i: int| 0 <= i < s.len() && s[i] == 'a'\n}\n\nspec fn is_good_string(s: Seq<char>) -> bool {\n    s.len() > 0 && count_a(s) > s.len() as int / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        result >= 1,\n        result <= s.len(),\n        result == min(2 * count_a(s@) - 1, s.len() as int) as usize,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_a(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == 'a' { 1 as int } else { 0 as int }) + count_a(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && exists|i: int| 0 <= i < s.len() && s[i] == 'a'\n}\n\nspec fn is_good_string(s: Seq<char>) -> bool {\n    s.len() > 0 && count_a(s) > s.len() as int / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        result >= 1,\n        result <= s.len(),\n        result == min(2 * count_a(s@) - 1, s.len() as int) as usize,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1356.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 702, "minimize_time_ms": 122486, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_a(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn min(a: int, b: int) -> int {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn is_good_string(s: Seq<char>) -> bool {\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_a(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == 'a' { 1 as int } else { 0 as int }) + count_a(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && exists|i: int| 0 <= i < s.len() && s[i] == 'a'\n}\n\nspec fn is_good_string(s: Seq<char>) -> bool {\n    s.len() > 0 && count_a(s) > s.len() as int / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        result >= 1,\n        result <= s.len(),\n        result == min(2 * count_a(s@) - 1, s.len() as int) as usize,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1381_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(k: int, n: int, s: int, p: int) -> bool {\n  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&\n  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000\n}\n\nspec fn sheets_per_person(n: int, s: int) -> int\n  recommends s >= 1\n{\n  (n + s - 1) / s\n}\n\nspec fn total_sheets_needed(k: int, n: int, s: int) -> int\n  recommends s >= 1\n{\n  k * sheets_per_person(n, s)\n}\n\nspec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int\n  recommends s >= 1 && p >= 1\n{\n  (total_sheets_needed(k, n, s) + p - 1) / p\n}\n\nspec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool\n  recommends s >= 1 && p >= 1\n{\n  result == min_packs_needed(k, n, s, p) &&\n  result * p >= total_sheets_needed(k, n, s) &&\n  (result - 1) * p < total_sheets_needed(k, n, s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i32, n: i32, s: i32, p: i32) -> (result: i32)\n  requires\n    valid_input(k as int, n as int, s as int, p as int),\n  ensures\n    result >= 1,\n    correct_result(result as int, k as int, n as int, s as int, p as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(k: int, n: int, s: int, p: int) -> bool {\n  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&\n  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000\n}\n\nspec fn sheets_per_person(n: int, s: int) -> int\n  recommends s >= 1\n{\n  (n + s - 1) / s\n}\n\nspec fn total_sheets_needed(k: int, n: int, s: int) -> int\n  recommends s >= 1\n{\n  k * sheets_per_person(n, s)\n}\n\nspec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int\n  recommends s >= 1 && p >= 1\n{\n  (total_sheets_needed(k, n, s) + p - 1) / p\n}\n\nspec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool\n  recommends s >= 1 && p >= 1\n{\n  result == min_packs_needed(k, n, s, p) &&\n  result * p >= total_sheets_needed(k, n, s) &&\n  (result - 1) * p < total_sheets_needed(k, n, s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i32, n: i32, s: i32, p: i32) -> (result: i32)\n  requires\n    valid_input(k as int, n as int, s as int, p as int),\n  ensures\n    result >= 1,\n    correct_result(result as int, k as int, n as int, s as int, p as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1381.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 626, "minimize_time_ms": 122720, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(k: int, n: int, s: int, p: int) -> bool {\n\nspec fn sheets_per_person(n: int, s: int) -> int\n  recommends s >= 1\n{\n\nspec fn total_sheets_needed(k: int, n: int, s: int) -> int\n  recommends s >= 1\n{\n\nspec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int\n  recommends s >= 1 && p >= 1\n{\n\nspec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool\n  recommends s >= 1 && p >= 1\n{\n\n  requires\n\n  ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(k: int, n: int, s: int, p: int) -> bool {\n  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&\n  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000\n}\n\nspec fn sheets_per_person(n: int, s: int) -> int\n  recommends s >= 1\n{\n  (n + s - 1) / s\n}\n\nspec fn total_sheets_needed(k: int, n: int, s: int) -> int\n  recommends s >= 1\n{\n  k * sheets_per_person(n, s)\n}\n\nspec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int\n  recommends s >= 1 && p >= 1\n{\n  (total_sheets_needed(k, n, s) + p - 1) / p\n}\n\nspec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool\n  recommends s >= 1 && p >= 1\n{\n  result == min_packs_needed(k, n, s, p) &&\n  result * p >= total_sheets_needed(k, n, s) &&\n  (result - 1) * p < total_sheets_needed(k, n, s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i32, n: i32, s: i32, p: i32) -> (result: i32)\n  requires\n    valid_input(k as int, n as int, s as int, p as int),\n  ensures\n    result >= 1,\n    correct_result(result as int, k as int, n as int, s as int, p as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1395_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 && exists|pos: int| 0 <= pos < stdin_input.len() && stdin_input[pos] == '\\n'\n}\n\nspec fn valid_digit_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn valid_number_string(s: Seq<char>) -> bool {\n    valid_digit_string(s) && s[0] != '0'\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 && forall|i: int| 0 <= i < result.len() ==> ('0' <= #[trigger] result[i] <= '9')\n}\n\nspec fn is_good_shift(s: Seq<char>, shift: int) -> bool \n    recommends 0 <= shift < s.len(), s.len() > 0\n{\n    s[shift] != '0'\n}\n\nspec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        valid_digit_string(s)\n{\n    cyclic_shift_remainder_helper(s, shift, m, 0, 0)\n}\n\nspec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        0 <= pos <= s.len(),\n        0 <= acc < m,\n        valid_digit_string(s)\n    decreases (s.len() - pos) when 0 <= pos <= s.len()\n{\n    if pos == s.len() { \n        acc \n    } else {\n        let idx = (shift + pos) % (s.len() as int);\n        let digit = (s[idx] as int) - ('0' as int);\n        let new_acc = (acc * 10 + digit) % m;\n        cyclic_shift_remainder_helper(s, shift, m, pos + 1, new_acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 && exists|pos: int| 0 <= pos < stdin_input.len() && stdin_input[pos] == '\\n'\n}\n\nspec fn valid_digit_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn valid_number_string(s: Seq<char>) -> bool {\n    valid_digit_string(s) && s[0] != '0'\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 && forall|i: int| 0 <= i < result.len() ==> ('0' <= #[trigger] result[i] <= '9')\n}\n\nspec fn is_good_shift(s: Seq<char>, shift: int) -> bool \n    recommends 0 <= shift < s.len(), s.len() > 0\n{\n    s[shift] != '0'\n}\n\nspec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        valid_digit_string(s)\n{\n    cyclic_shift_remainder_helper(s, shift, m, 0, 0)\n}\n\nspec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        0 <= pos <= s.len(),\n        0 <= acc < m,\n        valid_digit_string(s)\n    decreases (s.len() - pos) when 0 <= pos <= s.len()\n{\n    if pos == s.len() { \n        acc \n    } else {\n        let idx = (shift + pos) % (s.len() as int);\n        let digit = (s[idx] as int) - ('0' as int);\n        let new_acc = (acc * 10 + digit) % m;\n        cyclic_shift_remainder_helper(s, shift, m, pos + 1, new_acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1395.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 738, "minimize_time_ms": 123429, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 77, "minimized_LOC": 77, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn valid_digit_string(s: Seq<char>) -> bool {\n\nspec fn valid_number_string(s: Seq<char>) -> bool {\n\nspec fn valid_output(result: Seq<char>) -> bool {\n\nspec fn is_good_shift(s: Seq<char>, shift: int) -> bool \n    recommends 0 <= shift < s.len(), s.len() > 0\n{\n\nspec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        valid_digit_string(s)\n{\n\nspec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        0 <= pos <= s.len(),\n        0 <= acc < m,\n        valid_digit_string(s)\n    decreases (s.len() - pos) when 0 <= pos <= s.len()\n{\n\n    decreases (s.len() - pos) when 0 <= pos <= s.len()\n\n    requires valid_input(stdin_input@)\n\n    ensures valid_output(result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 && exists|pos: int| 0 <= pos < stdin_input.len() && stdin_input[pos] == '\\n'\n}\n\nspec fn valid_digit_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn valid_number_string(s: Seq<char>) -> bool {\n    valid_digit_string(s) && s[0] != '0'\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 && forall|i: int| 0 <= i < result.len() ==> ('0' <= #[trigger] result[i] <= '9')\n}\n\nspec fn is_good_shift(s: Seq<char>, shift: int) -> bool \n    recommends 0 <= shift < s.len(), s.len() > 0\n{\n    s[shift] != '0'\n}\n\nspec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        valid_digit_string(s)\n{\n    cyclic_shift_remainder_helper(s, shift, m, 0, 0)\n}\n\nspec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        0 <= pos <= s.len(),\n        0 <= acc < m,\n        valid_digit_string(s)\n    decreases (s.len() - pos) when 0 <= pos <= s.len()\n{\n    if pos == s.len() { \n        acc \n    } else {\n        let idx = (shift + pos) % (s.len() as int);\n        let digit = (s[idx] as int) - ('0' as int);\n        let new_acc = (acc * 10 + digit) % m;\n        cyclic_shift_remainder_helper(s, shift, m, pos + 1, new_acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n                fn main() {\n      }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1419_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1\n{\n    check_formatting(s, k, max_width, 0, 1, 0)\n}\n\nspec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() {\n        lines <= k && current_line <= max_width\n    } else {\n        if s[pos] == ' ' || s[pos] == '-' {\n            /* Potential break point */\n            if current_line + 1 > max_width {\n                /* Must break line */\n                if lines + 1 > k {\n                    false\n                } else {\n                    check_formatting(s, k, max_width, pos + 1, lines + 1, 1)\n                }\n            } else {\n                /* Can continue on current line or break */\n                (check_formatting(s, k, max_width, pos + 1, lines, current_line + 1) ||\n                 (lines < k && check_formatting(s, k, max_width, pos + 1, lines + 1, 1)))\n            }\n        } else {\n            /* Regular character - must continue on current line */\n            if current_line + 1 > max_width {\n                false\n            } else {\n                check_formatting(s, k, max_width, pos + 1, lines, current_line + 1)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, s: Vec<char>) -> (result: i8)\n    requires k >= 1,\n            s.len() >= 1,\n    ensures result >= 1,\n            result <= s@.len(),\n            can_format_text(s@, k as int, result as int),\n            result > 1 ==> !can_format_text(s@, k as int, (result - 1) as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1\n{\n    check_formatting(s, k, max_width, 0, 1, 0)\n}\n\nspec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() {\n        lines <= k && current_line <= max_width\n    } else {\n        if s[pos] == ' ' || s[pos] == '-' {\n            /* Potential break point */\n            if current_line + 1 > max_width {\n                /* Must break line */\n                if lines + 1 > k {\n                    false\n                } else {\n                    check_formatting(s, k, max_width, pos + 1, lines + 1, 1)\n                }\n            } else {\n                /* Can continue on current line or break */\n                (check_formatting(s, k, max_width, pos + 1, lines, current_line + 1) ||\n                 (lines < k && check_formatting(s, k, max_width, pos + 1, lines + 1, 1)))\n            }\n        } else {\n            /* Regular character - must continue on current line */\n            if current_line + 1 > max_width {\n                false\n            } else {\n                check_formatting(s, k, max_width, pos + 1, lines, current_line + 1)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, s: Vec<char>) -> (result: i8)\n    requires k >= 1,\n            s.len() >= 1,\n    ensures result >= 1,\n            result <= s@.len(),\n            can_format_text(s@, k as int, result as int),\n            result > 1 ==> !can_format_text(s@, k as int, (result - 1) as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1419.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 724, "minimize_time_ms": 122429, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1\n{\n\nspec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n\n    decreases s.len() - pos when 0 <= pos <= s.len()\n\n    requires k >= 1,\n\n    ensures result >= 1,"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1\n{\n    check_formatting(s, k, max_width, 0, 1, 0)\n}\n\nspec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() {\n        lines <= k && current_line <= max_width\n    } else {\n        if s[pos] == ' ' || s[pos] == '-' {\n            /* Potential break point */\n            if current_line + 1 > max_width {\n                /* Must break line */\n                if lines + 1 > k {\n                    false\n                } else {\n                    check_formatting(s, k, max_width, pos + 1, lines + 1, 1)\n                }\n            } else {\n                /* Can continue on current line or break */\n                (check_formatting(s, k, max_width, pos + 1, lines, current_line + 1) ||\n                 (lines < k && check_formatting(s, k, max_width, pos + 1, lines + 1, 1)))\n            }\n        } else {\n            /* Regular character - must continue on current line */\n            if current_line + 1 > max_width {\n                false\n            } else {\n                check_formatting(s, k, max_width, pos + 1, lines, current_line + 1)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, s: Vec<char>) -> (result: i8)\n    requires k >= 1,\n            s.len() >= 1,\n    ensures result >= 1,\n            result <= s@.len(),\n            can_format_text(s@, k as int, result as int),\n            result > 1 ==> !can_format_text(s@, k as int, (result - 1) as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1451_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {\n    n >= 1 && k >= 0 && numbers.len() == n && forall|i: int| 0 <= i < numbers.len() ==> numbers[i] > 0\n}\n\nspec fn count_lucky_digits(num: int) -> int\n    decreases num when num >= 0\n{\n    if num <= 0 { 0 }\n    else {\n        let digit = num % 10;\n        let rest = num / 10;\n        let digit_count: int = if digit == 4 || digit == 7 { 1 } else { 0 };\n        digit_count + count_lucky_digits(rest)\n    }\n}\n\nspec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int\n    decreases up_to when up_to >= 0\n{\n    if up_to <= 0 { 0 }\n    else {\n        let prev_count = count_valid_numbers(numbers, k, up_to - 1);\n        if count_lucky_digits(numbers[up_to - 1]) <= k { prev_count + 1 } else { prev_count }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, numbers: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures 0 <= result as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {\n    n >= 1 && k >= 0 && numbers.len() == n && forall|i: int| 0 <= i < numbers.len() ==> numbers[i] > 0\n}\n\nspec fn count_lucky_digits(num: int) -> int\n    decreases num when num >= 0\n{\n    if num <= 0 { 0 }\n    else {\n        let digit = num % 10;\n        let rest = num / 10;\n        let digit_count: int = if digit == 4 || digit == 7 { 1 } else { 0 };\n        digit_count + count_lucky_digits(rest)\n    }\n}\n\nspec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int\n    decreases up_to when up_to >= 0\n{\n    if up_to <= 0 { 0 }\n    else {\n        let prev_count = count_valid_numbers(numbers, k, up_to - 1);\n        if count_lucky_digits(numbers[up_to - 1]) <= k { prev_count + 1 } else { prev_count }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, numbers: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures 0 <= result as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1451.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 724, "minimize_time_ms": 122438, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {\n\nspec fn count_lucky_digits(num: int) -> int\n    decreases num when num >= 0\n{\n\nspec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int\n    decreases up_to when up_to >= 0\n{\n\n    decreases num when num >= 0\n\n    decreases up_to when up_to >= 0\n\n    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))\n\n    ensures 0 <= result as int <= n as int"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {\n    n >= 1 && k >= 0 && numbers.len() == n && forall|i: int| 0 <= i < numbers.len() ==> numbers[i] > 0\n}\n\nspec fn count_lucky_digits(num: int) -> int\n    decreases num when num >= 0\n{\n    if num <= 0 { 0 }\n    else {\n        let digit = num % 10;\n        let rest = num / 10;\n        let digit_count: int = if digit == 4 || digit == 7 { 1 } else { 0 };\n        digit_count + count_lucky_digits(rest)\n    }\n}\n\nspec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int\n    decreases up_to when up_to >= 0\n{\n    if up_to <= 0 { 0 }\n    else {\n        let prev_count = count_valid_numbers(numbers, k, up_to - 1);\n        if count_lucky_digits(numbers[up_to - 1]) <= k { prev_count + 1 } else { prev_count }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, numbers: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures 0 <= result as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1461_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {\n  n > 0 && f.len() == n && w.len() == n &&\n  (forall|i: int| #![trigger f[i]] 0 <= i < n ==> 0 <= f[i] < n) &&\n  (forall|i: int| #![trigger w[i]] 0 <= i < n ==> w[i] >= 0)\n}\n\nspec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {\n  sums.len() == n && mins.len() == n &&\n  forall|i: int| #![trigger sums[i], mins[i]] 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0\n}\n\nspec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 0 { 0 }\n  else { w[start] + path_sum(f[start], k - 1, f, w) }\n}\n\nspec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 1 { w[start] }\n  else {\n    let next_min = path_min(f[start], k - 1, f, w);\n    if w[start] <= next_min { w[start] } else { next_min }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_graph(n: i8, k: i8, f: Vec<i8>, w: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires \n    valid_graph(n as int, f@.map_values(|x: i8| x as int), w@.map_values(|x: i8| x as int)),\n    k > 0\n  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {\n  n > 0 && f.len() == n && w.len() == n &&\n  (forall|i: int| #![trigger f[i]] 0 <= i < n ==> 0 <= f[i] < n) &&\n  (forall|i: int| #![trigger w[i]] 0 <= i < n ==> w[i] >= 0)\n}\n\nspec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {\n  sums.len() == n && mins.len() == n &&\n  forall|i: int| #![trigger sums[i], mins[i]] 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0\n}\n\nspec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 0 { 0 }\n  else { w[start] + path_sum(f[start], k - 1, f, w) }\n}\n\nspec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 1 { w[start] }\n  else {\n    let next_min = path_min(f[start], k - 1, f, w);\n    if w[start] <= next_min { w[start] } else { next_min }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_graph(n: i8, k: i8, f: Vec<i8>, w: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires \n    valid_graph(n as int, f@.map_values(|x: i8| x as int), w@.map_values(|x: i8| x as int)),\n    k > 0\n  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1461.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 675, "minimize_time_ms": 123029, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {\n\nspec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {\n\nspec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n\nspec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n\n  decreases k\n\n  decreases k\n\n  requires \n\n  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {\n  n > 0 && f.len() == n && w.len() == n &&\n  (forall|i: int| #![trigger f[i]] 0 <= i < n ==> 0 <= f[i] < n) &&\n  (forall|i: int| #![trigger w[i]] 0 <= i < n ==> w[i] >= 0)\n}\n\nspec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {\n  sums.len() == n && mins.len() == n &&\n  forall|i: int| #![trigger sums[i], mins[i]] 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0\n}\n\nspec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 0 { 0 }\n  else { w[start] + path_sum(f[start], k - 1, f, w) }\n}\n\nspec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 1 { w[start] }\n  else {\n    let next_min = path_min(f[start], k - 1, f, w);\n    if w[start] <= next_min { w[start] } else { next_min }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_graph(n: i8, k: i8, f: Vec<i8>, w: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires \n    valid_graph(n as int, f@.map_values(|x: i8| x as int), w@.map_values(|x: i8| x as int)),\n    k > 0\n  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_148_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == '\\n') &&\n    {\n        let parts = parse_input(input);\n        parts.len() == 5 &&\n        parts[0] >= 4 && parts[0] <= 100 &&\n        parts[1] >= 1 && parts[1] <= parts[0] &&\n        parts[2] >= 1 && parts[2] <= parts[0] &&\n        parts[3] >= 1 && parts[3] <= parts[0] &&\n        parts[4] >= 1 && parts[4] <= parts[0] &&\n        parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&\n        parts[2] != parts[3] && parts[2] != parts[4] &&\n        parts[3] != parts[4]\n    }\n}\n\nspec fn trains_will_meet(input: Seq<char>) -> bool \n    recommends\n        input.len() > 0,\n        exists|i: int| 0 <= i < input.len() && input[i] == '\\n',\n        valid_input(input),\n{\n    let parts = parse_input(input);\n    let n = parts[0];\n    let a = parts[1];\n    let x = parts[2];\n    let b = parts[3];\n    let y = parts[4];\n\n    if a == b { true }\n    else { simulate_trains(n, a, x, b, y) }\n}\n\nspec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool\n    recommends\n        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,\n        a != x && a != b && a != y && x != b && x != y && b != y,\n{\n    simulate_trains_helper(n, a, x, b, y, 2 * n)\n}\n\nspec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {\n    if fuel <= 0 {\n        false\n    } else {\n        /* Placeholder simulation logic - returns false for now */\n        false\n    }\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<int> {\n    /* Placeholder parsing logic - returns empty sequence for now */\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: String)\n    requires \n        stdin_input.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n' as u8,\n        valid_input(stdin_input@.map(|i, x: u8| x as char)),\n    ensures\n        result@ =~= seq!['Y', 'E', 'S', '\\n'] || result@ =~= seq!['N', 'O', '\\n'],\n        result@ =~= seq!['Y', 'E', 'S', '\\n'] <==> trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n        result@ =~= seq!['N', 'O', '\\n'] <==> !trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"NO\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == '\\n') &&\n    {\n        let parts = parse_input(input);\n        parts.len() == 5 &&\n        parts[0] >= 4 && parts[0] <= 100 &&\n        parts[1] >= 1 && parts[1] <= parts[0] &&\n        parts[2] >= 1 && parts[2] <= parts[0] &&\n        parts[3] >= 1 && parts[3] <= parts[0] &&\n        parts[4] >= 1 && parts[4] <= parts[0] &&\n        parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&\n        parts[2] != parts[3] && parts[2] != parts[4] &&\n        parts[3] != parts[4]\n    }\n}\n\nspec fn trains_will_meet(input: Seq<char>) -> bool \n    recommends\n        input.len() > 0,\n        exists|i: int| 0 <= i < input.len() && input[i] == '\\n',\n        valid_input(input),\n{\n    let parts = parse_input(input);\n    let n = parts[0];\n    let a = parts[1];\n    let x = parts[2];\n    let b = parts[3];\n    let y = parts[4];\n\n    if a == b { true }\n    else { simulate_trains(n, a, x, b, y) }\n}\n\nspec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool\n    recommends\n        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,\n        a != x && a != b && a != y && x != b && x != y && b != y,\n{\n    simulate_trains_helper(n, a, x, b, y, 2 * n)\n}\n\nspec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {\n    if fuel <= 0 {\n        false\n    } else {\n        /* Placeholder simulation logic - returns false for now */\n        false\n    }\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<int> {\n    /* Placeholder parsing logic - returns empty sequence for now */\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: String)\n    requires \n        stdin_input.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n' as u8,\n        valid_input(stdin_input@.map(|i, x: u8| x as char)),\n    ensures\n        result@ =~= seq!['Y', 'E', 'S', '\\n'] || result@ =~= seq!['N', 'O', '\\n'],\n        result@ =~= seq!['Y', 'E', 'S', '\\n'] <==> trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n        result@ =~= seq!['N', 'O', '\\n'] <==> !trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"NO\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_148.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 721, "minimize_time_ms": 122477, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 89, "minimized_LOC": 89, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::string::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn trains_will_meet(input: Seq<char>) -> bool \n    recommends\n        input.len() > 0,\n        exists|i: int| 0 <= i < input.len() && input[i] == '\\n',\n        valid_input(input),\n{\n\nspec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool\n    recommends\n        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,\n        a != x && a != b && a != y && x != b && x != y && b != y,\n{\n\nspec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {\n\nspec fn parse_input(input: Seq<char>) -> Seq<int> {\n\n    requires \n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == '\\n') &&\n    {\n        let parts = parse_input(input);\n        parts.len() == 5 &&\n        parts[0] >= 4 && parts[0] <= 100 &&\n        parts[1] >= 1 && parts[1] <= parts[0] &&\n        parts[2] >= 1 && parts[2] <= parts[0] &&\n        parts[3] >= 1 && parts[3] <= parts[0] &&\n        parts[4] >= 1 && parts[4] <= parts[0] &&\n        parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&\n        parts[2] != parts[3] && parts[2] != parts[4] &&\n        parts[3] != parts[4]\n    }\n}\n\nspec fn trains_will_meet(input: Seq<char>) -> bool \n    recommends\n        input.len() > 0,\n        exists|i: int| 0 <= i < input.len() && input[i] == '\\n',\n        valid_input(input),\n{\n    let parts = parse_input(input);\n    let n = parts[0];\n    let a = parts[1];\n    let x = parts[2];\n    let b = parts[3];\n    let y = parts[4];\n\n    if a == b { true }\n    else { simulate_trains(n, a, x, b, y) }\n}\n\nspec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool\n    recommends\n        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,\n        a != x && a != b && a != y && x != b && x != y && b != y,\n{\n    simulate_trains_helper(n, a, x, b, y, 2 * n)\n}\n\nspec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {\n    if fuel <= 0 {\n        false\n    } else {\n        /* Placeholder simulation logic - returns false for now */\n        false\n    }\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<int> {\n    /* Placeholder parsing logic - returns empty sequence for now */\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: String)\n    requires \n        stdin_input.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n' as u8,\n        valid_input(stdin_input@.map(|i, x: u8| x as char)),\n    ensures\n        result@ =~= seq!['Y', 'E', 'S', '\\n'] || result@ =~= seq!['N', 'O', '\\n'],\n        result@ =~= seq!['Y', 'E', 'S', '\\n'] <==> trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n        result@ =~= seq!['N', 'O', '\\n'] <==> !trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"NO\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1486_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cities: Seq<int>) -> bool {\n  cities.len() >= 2 &&\n  forall|i: int, j: int| 0 <= i < j < cities.len() ==> cities[i] < cities[j]\n}\n\nspec fn min_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[i-1]\n  } else {\n    let left_dist = cities[i] - cities[i-1];\n    let right_dist = cities[i+1] - cities[i];\n    if left_dist <= right_dist { left_dist } else { right_dist }\n  }\n}\n\nspec fn max_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[cities.len()-1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[0]\n  } else {\n    let dist_to_first = cities[i] - cities[0];\n    let dist_to_last = cities[cities.len()-1] - cities[i];\n    if dist_to_first >= dist_to_last { dist_to_first } else { dist_to_last }\n  }\n}\n\nspec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {\n  valid_input(cities) &&\n  min_distances.len() == cities.len() &&\n  max_distances.len() == cities.len() &&\n  forall|i: int| 0 <= i < cities.len() ==> \n    min_distances[i] == min_distance(cities, i) &&\n    max_distances[i] == max_distance(cities, i) &&\n    min_distances[i] > 0 &&\n    max_distances[i] > 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn calculate_distances(cities: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires valid_input(cities@.map(|i, v: i8| v as int))\n  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cities: Seq<int>) -> bool {\n  cities.len() >= 2 &&\n  forall|i: int, j: int| 0 <= i < j < cities.len() ==> cities[i] < cities[j]\n}\n\nspec fn min_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[i-1]\n  } else {\n    let left_dist = cities[i] - cities[i-1];\n    let right_dist = cities[i+1] - cities[i];\n    if left_dist <= right_dist { left_dist } else { right_dist }\n  }\n}\n\nspec fn max_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[cities.len()-1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[0]\n  } else {\n    let dist_to_first = cities[i] - cities[0];\n    let dist_to_last = cities[cities.len()-1] - cities[i];\n    if dist_to_first >= dist_to_last { dist_to_first } else { dist_to_last }\n  }\n}\n\nspec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {\n  valid_input(cities) &&\n  min_distances.len() == cities.len() &&\n  max_distances.len() == cities.len() &&\n  forall|i: int| 0 <= i < cities.len() ==> \n    min_distances[i] == min_distance(cities, i) &&\n    max_distances[i] == max_distance(cities, i) &&\n    min_distances[i] > 0 &&\n    max_distances[i] > 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn calculate_distances(cities: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires valid_input(cities@.map(|i, v: i8| v as int))\n  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1486.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 818, "minimize_time_ms": 122428, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 74, "minimized_LOC": 74, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(cities: Seq<int>) -> bool {\n\nspec fn min_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n\nspec fn max_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n\nspec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {\n\n  requires valid_input(cities@.map(|i, v: i8| v as int))\n\n  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cities: Seq<int>) -> bool {\n  cities.len() >= 2 &&\n  forall|i: int, j: int| 0 <= i < j < cities.len() ==> cities[i] < cities[j]\n}\n\nspec fn min_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[i-1]\n  } else {\n    let left_dist = cities[i] - cities[i-1];\n    let right_dist = cities[i+1] - cities[i];\n    if left_dist <= right_dist { left_dist } else { right_dist }\n  }\n}\n\nspec fn max_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[cities.len()-1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[0]\n  } else {\n    let dist_to_first = cities[i] - cities[0];\n    let dist_to_last = cities[cities.len()-1] - cities[i];\n    if dist_to_first >= dist_to_last { dist_to_first } else { dist_to_last }\n  }\n}\n\nspec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {\n  valid_input(cities) &&\n  min_distances.len() == cities.len() &&\n  max_distances.len() == cities.len() &&\n  forall|i: int| 0 <= i < cities.len() ==> \n    min_distances[i] == min_distance(cities, i) &&\n    max_distances[i] == max_distance(cities, i) &&\n    min_distances[i] > 0 &&\n    max_distances[i] > 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn calculate_distances(cities: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires valid_input(cities@.map(|i, v: i8| v as int))\n  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1526_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    0 <= a <= 50 && 0 <= b <= 50 && 0 <= c <= 50\n}\n\nspec fn max_of_3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a }\n    else if b >= c { b }\n    else { c }\n}\n\nspec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {\n    if a >= b && a >= c {\n        if b >= c { (a, b, c) } else { (a, c, b) }\n    } else if b >= a && b >= c {\n        if a >= c { (b, a, c) } else { (b, c, a) }\n    } else {\n        if a >= b { (c, a, b) } else { (c, b, a) }\n    }\n}\n\nspec fn min_operations(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let (a0, a1, a2) = sort_descending(a, b, c);\n    let gap1 = a0 - a1;\n    let updated_smallest = a2 + gap1;\n    let remaining_gap = a0 - updated_smallest;\n    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2\n}\n\nspec fn all_equal(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires\n        valid_input(a as int, b as int, c as int),\n    ensures\n        result >= 0,\n        all_equal(a as int, b as int, c as int) ==> result == 0,\n        result as int == min_operations(a as int, b as int, c as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    0 <= a <= 50 && 0 <= b <= 50 && 0 <= c <= 50\n}\n\nspec fn max_of_3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a }\n    else if b >= c { b }\n    else { c }\n}\n\nspec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {\n    if a >= b && a >= c {\n        if b >= c { (a, b, c) } else { (a, c, b) }\n    } else if b >= a && b >= c {\n        if a >= c { (b, a, c) } else { (b, c, a) }\n    } else {\n        if a >= b { (c, a, b) } else { (c, b, a) }\n    }\n}\n\nspec fn min_operations(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let (a0, a1, a2) = sort_descending(a, b, c);\n    let gap1 = a0 - a1;\n    let updated_smallest = a2 + gap1;\n    let remaining_gap = a0 - updated_smallest;\n    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2\n}\n\nspec fn all_equal(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires\n        valid_input(a as int, b as int, c as int),\n    ensures\n        result >= 0,\n        all_equal(a as int, b as int, c as int) ==> result == 0,\n        result as int == min_operations(a as int, b as int, c as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1526.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 624, "minimize_time_ms": 122637, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 65, "minimized_LOC": 65, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, c: int) -> bool {\n\nspec fn max_of_3(a: int, b: int, c: int) -> int {\n\nspec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {\n\nspec fn min_operations(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n\nspec fn all_equal(a: int, b: int, c: int) -> bool {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    0 <= a <= 50 && 0 <= b <= 50 && 0 <= c <= 50\n}\n\nspec fn max_of_3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a }\n    else if b >= c { b }\n    else { c }\n}\n\nspec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {\n    if a >= b && a >= c {\n        if b >= c { (a, b, c) } else { (a, c, b) }\n    } else if b >= a && b >= c {\n        if a >= c { (b, a, c) } else { (b, c, a) }\n    } else {\n        if a >= b { (c, a, b) } else { (c, b, a) }\n    }\n}\n\nspec fn min_operations(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let (a0, a1, a2) = sort_descending(a, b, c);\n    let gap1 = a0 - a1;\n    let updated_smallest = a2 + gap1;\n    let remaining_gap = a0 - updated_smallest;\n    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2\n}\n\nspec fn all_equal(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires\n        valid_input(a as int, b as int, c as int),\n    ensures\n        result >= 0,\n        all_equal(a as int, b as int, c as int) ==> result == 0,\n        result as int == min_operations(a as int, b as int, c as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1529_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(input, 0, seq![], seq![])\n    }\n}\n\nspec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i when 0 <= i <= input.len()\n{\n    if i == input.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if i < input.len() && input[i] == '\\n' {\n        split_lines_helper(input, i + 1, seq![], acc.push(current))\n    } else if i < input.len() {\n        split_lines_helper(input, i + 1, current.push(input[i]), acc)\n    } else {\n        acc\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        acc\n    } else if i < s.len() && '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n == 0 {\n        seq![]\n    } else if n == 1 && 1 < lines.len() {\n        classify_sentence_func(lines[1])\n    } else if n > 1 && n < lines.len() {\n        build_output_func(lines, n-1) + seq!['\\n'] + classify_sentence_func(lines[n])\n    } else {\n        seq![]\n    }\n}\n\nspec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {\n    if ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) && !starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) {\n        seq!['F', 'r', 'e', 'd', 'a', '\\'', 's']\n    } else if starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) && !ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) {\n        seq!['R', 'a', 'i', 'n', 'b', 'o', 'w', '\\'', 's']\n    } else {\n        seq!['O', 'M', 'G', '>', '.', '<', ' ', 'I', ' ', 'd', 'o', 'n', '\\'', 't', ' ', 'k', 'n', 'o', 'w', '!']\n    }\n}\n\nspec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {\n    prefix.len() <= s.len() && (forall|i: int| 0 <= i < prefix.len() ==> s[i] == prefix[i])\n}\n\nspec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {\n    suffix.len() <= s.len() && (forall|i: int| 0 <= i < suffix.len() ==> s[s.len() - suffix.len() + i] == suffix[i])\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(input, 0, seq![], seq![])\n    }\n}\n\nspec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i when 0 <= i <= input.len()\n{\n    if i == input.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if i < input.len() && input[i] == '\\n' {\n        split_lines_helper(input, i + 1, seq![], acc.push(current))\n    } else if i < input.len() {\n        split_lines_helper(input, i + 1, current.push(input[i]), acc)\n    } else {\n        acc\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        acc\n    } else if i < s.len() && '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n == 0 {\n        seq![]\n    } else if n == 1 && 1 < lines.len() {\n        classify_sentence_func(lines[1])\n    } else if n > 1 && n < lines.len() {\n        build_output_func(lines, n-1) + seq!['\\n'] + classify_sentence_func(lines[n])\n    } else {\n        seq![]\n    }\n}\n\nspec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {\n    if ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) && !starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) {\n        seq!['F', 'r', 'e', 'd', 'a', '\\'', 's']\n    } else if starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) && !ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) {\n        seq!['R', 'a', 'i', 'n', 'b', 'o', 'w', '\\'', 's']\n    } else {\n        seq!['O', 'M', 'G', '>', '.', '<', ' ', 'I', ' ', 'd', 'o', 'n', '\\'', 't', ' ', 'k', 'n', 'o', 'w', '!']\n    }\n}\n\nspec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {\n    prefix.len() <= s.len() && (forall|i: int| 0 <= i < prefix.len() ==> s[i] == prefix[i])\n}\n\nspec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {\n    suffix.len() <= s.len() && (forall|i: int| 0 <= i < suffix.len() ==> s[s.len() - suffix.len() + i] == suffix[i])\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1529.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 763, "minimize_time_ms": 122893, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 109, "minimized_LOC": 109, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i when 0 <= i <= input.len()\n{\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n\nspec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n\nspec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {\n\nspec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {\n\nspec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {\n\nspec fn min(a: int, b: int) -> int {\n\n    decreases input.len() - i when 0 <= i <= input.len()\n\n    decreases s.len() - i when 0 <= i <= s.len()\n\n    decreases n when n >= 0\n\n    requires valid_input(input@)\n\n    ensures result@.len() >= 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(input, 0, seq![], seq![])\n    }\n}\n\nspec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i when 0 <= i <= input.len()\n{\n    if i == input.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if i < input.len() && input[i] == '\\n' {\n        split_lines_helper(input, i + 1, seq![], acc.push(current))\n    } else if i < input.len() {\n        split_lines_helper(input, i + 1, current.push(input[i]), acc)\n    } else {\n        acc\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        acc\n    } else if i < s.len() && '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n == 0 {\n        seq![]\n    } else if n == 1 && 1 < lines.len() {\n        classify_sentence_func(lines[1])\n    } else if n > 1 && n < lines.len() {\n        build_output_func(lines, n-1) + seq!['\\n'] + classify_sentence_func(lines[n])\n    } else {\n        seq![]\n    }\n}\n\nspec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {\n    if ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) && !starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) {\n        seq!['F', 'r', 'e', 'd', 'a', '\\'', 's']\n    } else if starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) && !ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) {\n        seq!['R', 'a', 'i', 'n', 'b', 'o', 'w', '\\'', 's']\n    } else {\n        seq!['O', 'M', 'G', '>', '.', '<', ' ', 'I', ' ', 'd', 'o', 'n', '\\'', 't', ' ', 'k', 'n', 'o', 'w', '!']\n    }\n}\n\nspec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {\n    prefix.len() <= s.len() && (forall|i: int| 0 <= i < prefix.len() ==> s[i] == prefix[i])\n}\n\nspec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {\n    suffix.len() <= s.len() && (forall|i: int| 0 <= i < suffix.len() ==> s[s.len() - suffix.len() + i] == suffix[i])\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1541_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_lever_input(s: Seq<char>) -> bool {\n        s.len() >= 3 &&\n        (exists|i: int| 0 <= i < s.len() && s[i] == '^') &&\n        (forall|i: int| 0 <= i < s.len() ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&\n        (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == '^' ==> s[j] != '^') &&\n        (forall|i: int| 0 <= i < s.len() && s[i] == '^' ==> (i != 0 && i != s.len() - 1))\n    }\n    \n    spec fn find_pivot(s: Seq<char>) -> int {\n        find_pivot_helper(s, 0)\n    }\n    \n    spec fn find_pivot_helper(s: Seq<char>, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if s[index] == '^' {\n            index\n        } else {\n            find_pivot_helper(s, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0)\n    }\n    \n    spec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if '1' <= s[index] <= '9' {\n            let weight = (s[index] as int) - ('0' as int);\n            (pivot_pos - index) * weight + calculate_torque_helper(s, pivot_pos, index + 1)\n        } else {\n            calculate_torque_helper(s, pivot_pos, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0) - calculate_torque_helper(s, pivot_pos, up_to)\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_lever_input(s@)\n    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_lever_input(s: Seq<char>) -> bool {\n        s.len() >= 3 &&\n        (exists|i: int| 0 <= i < s.len() && s[i] == '^') &&\n        (forall|i: int| 0 <= i < s.len() ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&\n        (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == '^' ==> s[j] != '^') &&\n        (forall|i: int| 0 <= i < s.len() && s[i] == '^' ==> (i != 0 && i != s.len() - 1))\n    }\n    \n    spec fn find_pivot(s: Seq<char>) -> int {\n        find_pivot_helper(s, 0)\n    }\n    \n    spec fn find_pivot_helper(s: Seq<char>, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if s[index] == '^' {\n            index\n        } else {\n            find_pivot_helper(s, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0)\n    }\n    \n    spec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if '1' <= s[index] <= '9' {\n            let weight = (s[index] as int) - ('0' as int);\n            (pivot_pos - index) * weight + calculate_torque_helper(s, pivot_pos, index + 1)\n        } else {\n            calculate_torque_helper(s, pivot_pos, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0) - calculate_torque_helper(s, pivot_pos, up_to)\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_lever_input(s@)\n    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1541.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 740, "minimize_time_ms": 122663, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_lever_input(s: Seq<char>) -> bool {\n\nspec fn find_pivot(s: Seq<char>) -> int {\n\nspec fn find_pivot_helper(s: Seq<char>, index: int) -> int\n        decreases s.len() - index\n    {\n\nspec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {\n\nspec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int\n        decreases s.len() - index\n    {\n\nspec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {\n\n        decreases s.len() - index\n\n        decreases s.len() - index\n\n    requires valid_lever_input(s@)\n\n    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_lever_input(s: Seq<char>) -> bool {\n        s.len() >= 3 &&\n        (exists|i: int| 0 <= i < s.len() && s[i] == '^') &&\n        (forall|i: int| 0 <= i < s.len() ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&\n        (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == '^' ==> s[j] != '^') &&\n        (forall|i: int| 0 <= i < s.len() && s[i] == '^' ==> (i != 0 && i != s.len() - 1))\n    }\n    \n    spec fn find_pivot(s: Seq<char>) -> int {\n        find_pivot_helper(s, 0)\n    }\n    \n    spec fn find_pivot_helper(s: Seq<char>, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if s[index] == '^' {\n            index\n        } else {\n            find_pivot_helper(s, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0)\n    }\n    \n    spec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if '1' <= s[index] <= '9' {\n            let weight = (s[index] as int) - ('0' as int);\n            (pivot_pos - index) * weight + calculate_torque_helper(s, pivot_pos, index + 1)\n        } else {\n            calculate_torque_helper(s, pivot_pos, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0) - calculate_torque_helper(s, pivot_pos, up_to)\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_lever_input(s@)\n    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1550_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, digits: Seq<char>) -> bool {\n    n > 0 && digits.len() == n && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= '0' && #[trigger] digits[i] <= '9'\n}\n\nspec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {\n    let key = if s[index] == '0' { 0 } else { 10 - (s[index] as int - '0' as int) };\n    let transformed = transform_digits(s, key);\n    rotate_string(transformed, index)\n}\n\nspec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let digit = (s[0] as int - '0' as int + key) % 10;\n        seq![('0' as int + digit) as char].add(transform_digits(s.skip(1), key))\n    }\n}\n\nspec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        s.skip(index).add(s.take(index))\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n    decreases input.len()\n{\n    parse_input_helper(input, 0, seq![], seq![])\n}\n\nspec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i\n{\n    if i >= input.len() {\n        if current_line.len() > 0 { lines.push(current_line) } else { lines }\n    } else if input[i] == '\\n' {\n        parse_input_helper(input, i + 1, seq![], lines.push(current_line))\n    } else {\n        parse_input_helper(input, i + 1, current_line.push(input[i]), lines)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        0\n    } else {\n        (s[0] as int - '0' as int) + 10 * parse_int(s.skip(1))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        string_to_int(s.skip(1))\n    } else {\n        (s[0] as int - '0' as int) * pow(10, (s.len() - 1) as nat) + string_to_int(s.skip(1))\n    }\n}\n\nspec fn pow(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        (exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n'),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let lines = parse_input(stdin_input@);\n            if lines.len() >= 2 {\n                let n = parse_int(lines[0]);\n                let digits = lines[1];\n                if valid_input(n, digits) {\n                    let min_result = result@.take(result@.len() - 1);\n                    min_result.len() == n &&\n                    (forall|i: int| 0 <= i < min_result.len() ==> #[trigger] min_result[i] >= '0' && #[trigger] min_result[i] <= '9') &&\n                    (exists|index: int| 0 <= index < n && min_result == modify_string(digits, index)) &&\n                    (forall|index: int| 0 <= index < n ==> string_to_int(min_result) <= string_to_int(modify_string(digits, index)))\n                } else {\n                    result@ == seq!['\\n']\n                }\n            } else {\n                result@ == seq!['\\n']\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, digits: Seq<char>) -> bool {\n    n > 0 && digits.len() == n && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= '0' && #[trigger] digits[i] <= '9'\n}\n\nspec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {\n    let key = if s[index] == '0' { 0 } else { 10 - (s[index] as int - '0' as int) };\n    let transformed = transform_digits(s, key);\n    rotate_string(transformed, index)\n}\n\nspec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let digit = (s[0] as int - '0' as int + key) % 10;\n        seq![('0' as int + digit) as char].add(transform_digits(s.skip(1), key))\n    }\n}\n\nspec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        s.skip(index).add(s.take(index))\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n    decreases input.len()\n{\n    parse_input_helper(input, 0, seq![], seq![])\n}\n\nspec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i\n{\n    if i >= input.len() {\n        if current_line.len() > 0 { lines.push(current_line) } else { lines }\n    } else if input[i] == '\\n' {\n        parse_input_helper(input, i + 1, seq![], lines.push(current_line))\n    } else {\n        parse_input_helper(input, i + 1, current_line.push(input[i]), lines)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        0\n    } else {\n        (s[0] as int - '0' as int) + 10 * parse_int(s.skip(1))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        string_to_int(s.skip(1))\n    } else {\n        (s[0] as int - '0' as int) * pow(10, (s.len() - 1) as nat) + string_to_int(s.skip(1))\n    }\n}\n\nspec fn pow(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        (exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n'),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let lines = parse_input(stdin_input@);\n            if lines.len() >= 2 {\n                let n = parse_int(lines[0]);\n                let digits = lines[1];\n                if valid_input(n, digits) {\n                    let min_result = result@.take(result@.len() - 1);\n                    min_result.len() == n &&\n                    (forall|i: int| 0 <= i < min_result.len() ==> #[trigger] min_result[i] >= '0' && #[trigger] min_result[i] <= '9') &&\n                    (exists|index: int| 0 <= index < n && min_result == modify_string(digits, index)) &&\n                    (forall|index: int| 0 <= index < n ==> string_to_int(min_result) <= string_to_int(modify_string(digits, index)))\n                } else {\n                    result@ == seq!['\\n']\n                }\n            } else {\n                result@ == seq!['\\n']\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1550.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 953, "minimize_time_ms": 215246, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 134, "minimized_LOC": 134, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 21, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, digits: Seq<char>) -> bool {\n\nspec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {\n\nspec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>\n    decreases s.len()\n{\n\nspec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n    decreases input.len()\n{\n\nspec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i\n{\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn pow(base: int, exp: nat) -> int\n    decreases exp\n{\n\n    decreases s.len()\n\n    decreases input.len()\n\n    decreases input.len() - i\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases exp\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, digits: Seq<char>) -> bool {\n    n > 0 && digits.len() == n && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= '0' && #[trigger] digits[i] <= '9'\n}\n\nspec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {\n    let key = if s[index] == '0' { 0 } else { 10 - (s[index] as int - '0' as int) };\n    let transformed = transform_digits(s, key);\n    rotate_string(transformed, index)\n}\n\nspec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let digit = (s[0] as int - '0' as int + key) % 10;\n        seq![('0' as int + digit) as char].add(transform_digits(s.skip(1), key))\n    }\n}\n\nspec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        s.skip(index).add(s.take(index))\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n    decreases input.len()\n{\n    parse_input_helper(input, 0, seq![], seq![])\n}\n\nspec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i\n{\n    if i >= input.len() {\n        if current_line.len() > 0 { lines.push(current_line) } else { lines }\n    } else if input[i] == '\\n' {\n        parse_input_helper(input, i + 1, seq![], lines.push(current_line))\n    } else {\n        parse_input_helper(input, i + 1, current_line.push(input[i]), lines)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        0\n    } else {\n        (s[0] as int - '0' as int) + 10 * parse_int(s.skip(1))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        string_to_int(s.skip(1))\n    } else {\n        (s[0] as int - '0' as int) * pow(10, (s.len() - 1) as nat) + string_to_int(s.skip(1))\n    }\n}\n\nspec fn pow(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        (exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n'),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let lines = parse_input(stdin_input@);\n            if lines.len() >= 2 {\n                let n = parse_int(lines[0]);\n                let digits = lines[1];\n                if valid_input(n, digits) {\n                    let min_result = result@.take(result@.len() - 1);\n                    min_result.len() == n &&\n                    (forall|i: int| 0 <= i < min_result.len() ==> #[trigger] min_result[i] >= '0' && #[trigger] min_result[i] <= '9') &&\n                    (exists|index: int| 0 <= index < n && min_result == modify_string(digits, index)) &&\n                    (forall|index: int| 0 <= index < n ==> string_to_int(min_result) <= string_to_int(modify_string(digits, index)))\n                } else {\n                    result@ == seq!['\\n']\n                }\n            } else {\n                result@ == seq!['\\n']\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {\n      }\n", "use vstd::prelude::*;\n                fn main() {\n      }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1568_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    1 <= a <= 1000 &&\n    1 <= b <= 1000 &&\n    1 <= c <= 1000 &&\n    1 <= t <= 1000 &&\n    arrivals.len() == n &&\n    forall|i: int| 0 <= i < arrivals.len() ==> #[trigger] arrivals[i] >= 1 && #[trigger] arrivals[i] <= t\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {\n    if b > c {\n        n * a\n    } else {\n        n * a + (c - b) * (n * t - sum_seq(arrivals))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, c: i8, t: i8, arrivals: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    1 <= a <= 1000 &&\n    1 <= b <= 1000 &&\n    1 <= c <= 1000 &&\n    1 <= t <= 1000 &&\n    arrivals.len() == n &&\n    forall|i: int| 0 <= i < arrivals.len() ==> #[trigger] arrivals[i] >= 1 && #[trigger] arrivals[i] <= t\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {\n    if b > c {\n        n * a\n    } else {\n        n * a + (c - b) * (n * t - sum_seq(arrivals))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, c: i8, t: i8, arrivals: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1568.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 723, "minimize_time_ms": 122406, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {\n\n    decreases s.len()\n\n    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n\n    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    1 <= a <= 1000 &&\n    1 <= b <= 1000 &&\n    1 <= c <= 1000 &&\n    1 <= t <= 1000 &&\n    arrivals.len() == n &&\n    forall|i: int| 0 <= i < arrivals.len() ==> #[trigger] arrivals[i] >= 1 && #[trigger] arrivals[i] <= t\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {\n    if b > c {\n        n * a\n    } else {\n        n * a + (c - b) * (n * t - sum_seq(arrivals))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, c: i8, t: i8, arrivals: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1577_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|newline_pos: int| 0 <= newline_pos < input.len() && input[newline_pos] == '\\n'\n}\n\nspec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_game_string(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let s = lines[1];\n        s.len() == n && n >= 1\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_game_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'D'\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {\n    if count_a > count_d {\n        seq!['A', 'n', 't', 'o', 'n']\n    } else if count_d > count_a {\n        seq!['D', 'a', 'n', 'i', 'k']\n    } else {\n        seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p']\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn string_to_int(s: Seq<char>) -> int;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@) &&\n        valid_parsed_input(split_lines(input@))\n    ensures \n        result@ == seq!['A', 'n', 't', 'o', 'n'] || \n        result@ == seq!['D', 'a', 'n', 'i', 'k'] || \n        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&\n        result@ == {\n            let lines = split_lines(input@);\n            let s = lines[1];\n            let count_a = count_char(s, 'A');\n            let count_d = count_char(s, 'D');\n            determine_winner(count_a, count_d)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|newline_pos: int| 0 <= newline_pos < input.len() && input[newline_pos] == '\\n'\n}\n\nspec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_game_string(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let s = lines[1];\n        s.len() == n && n >= 1\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_game_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'D'\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {\n    if count_a > count_d {\n        seq!['A', 'n', 't', 'o', 'n']\n    } else if count_d > count_a {\n        seq!['D', 'a', 'n', 'i', 'k']\n    } else {\n        seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p']\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn string_to_int(s: Seq<char>) -> int;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@) &&\n        valid_parsed_input(split_lines(input@))\n    ensures \n        result@ == seq!['A', 'n', 't', 'o', 'n'] || \n        result@ == seq!['D', 'a', 'n', 'i', 'k'] || \n        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&\n        result@ == {\n            let lines = split_lines(input@);\n            let s = lines[1];\n            let count_a = count_char(s, 'A');\n            let count_d = count_char(s, 'D');\n            determine_winner(count_a, count_d)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1577.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 672, "minimize_time_ms": 92050, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 81, "minimized_LOC": 81, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn is_valid_game_string(s: Seq<char>) -> bool {\n\nspec fn count_char(s: Seq<char>, c: char) -> int \n    decreases s.len()\n{\n\nspec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn string_to_int(s: Seq<char>) -> int;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@) &&\n        valid_parsed_input(split_lines(input@))\n    ensures \n        result@ == seq!['A', 'n', 't', 'o', 'n'] || \n        result@ == seq!['D', 'a', 'n', 'i', 'k'] || \n        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&\n        result@ == {\n\nspec fn string_to_int(s: Seq<char>) -> int;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@) &&\n        valid_parsed_input(split_lines(input@))\n    ensures \n        result@ == seq!['A', 'n', 't', 'o', 'n'] || \n        result@ == seq!['D', 'a', 'n', 'i', 'k'] || \n        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&\n        result@ == {\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|newline_pos: int| 0 <= newline_pos < input.len() && input[newline_pos] == '\\n'\n}\n\nspec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_game_string(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let s = lines[1];\n        s.len() == n && n >= 1\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_game_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'D'\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {\n    if count_a > count_d {\n        seq!['A', 'n', 't', 'o', 'n']\n    } else if count_d > count_a {\n        seq!['D', 'a', 'n', 'i', 'k']\n    } else {\n        seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p']\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn string_to_int(s: Seq<char>) -> int;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@) &&\n        valid_parsed_input(split_lines(input@))\n    ensures \n        result@ == seq!['A', 'n', 't', 'o', 'n'] || \n        result@ == seq!['D', 'a', 'n', 'i', 'k'] || \n        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&\n        result@ == {\n            let lines = split_lines(input@);\n            let s = lines[1];\n            let count_a = count_char(s, 'A');\n            let count_d = count_char(s, 'D');\n            determine_winner(count_a, count_d)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1594_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int\n  recommends \n    n >= 0,\n    songs.len() >= n,\n    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases n\n  when n >= 0 && songs.len() >= n\n{\n  if n == 0 { \n    0 \n  } else { \n    songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1) \n  }\n}\n\nspec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int\n  recommends \n    song_idx >= -1,\n    songs.len() > song_idx,\n    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases song_idx + 1\n  when song_idx >= -1 && songs.len() > song_idx\n{\n  if song_idx == -1 { \n    0 \n  } else { \n    songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1) \n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, songs: Vec<(i8, i8)>, queries: Vec<i8>) -> (result: Vec<i8>)\n  requires \n    n >= 0,\n    m >= 0,\n    songs.len() == n as nat,\n    queries.len() == m as nat,\n    forall|i: int| #![trigger songs[i]] 0 <= i < n as int ==> songs[i].0 > 0 && songs[i].1 > 0,\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int - 1 ==> queries[i] < queries[i + 1],\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int ==> queries[i] >= 1,\n    m == 0 || queries[(m-1) as int] as int <= sum_playlist_duration(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), n as int)\n  ensures \n    result.len() == m as nat,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> 1 <= result[i] as int <= n as int,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> queries[i] as int <= cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 1),\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> result[i] as int == 1 || queries[i] as int > cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 2)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int\n  recommends \n    n >= 0,\n    songs.len() >= n,\n    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases n\n  when n >= 0 && songs.len() >= n\n{\n  if n == 0 { \n    0 \n  } else { \n    songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1) \n  }\n}\n\nspec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int\n  recommends \n    song_idx >= -1,\n    songs.len() > song_idx,\n    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases song_idx + 1\n  when song_idx >= -1 && songs.len() > song_idx\n{\n  if song_idx == -1 { \n    0 \n  } else { \n    songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1) \n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, songs: Vec<(i8, i8)>, queries: Vec<i8>) -> (result: Vec<i8>)\n  requires \n    n >= 0,\n    m >= 0,\n    songs.len() == n as nat,\n    queries.len() == m as nat,\n    forall|i: int| #![trigger songs[i]] 0 <= i < n as int ==> songs[i].0 > 0 && songs[i].1 > 0,\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int - 1 ==> queries[i] < queries[i + 1],\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int ==> queries[i] >= 1,\n    m == 0 || queries[(m-1) as int] as int <= sum_playlist_duration(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), n as int)\n  ensures \n    result.len() == m as nat,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> 1 <= result[i] as int <= n as int,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> queries[i] as int <= cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 1),\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> result[i] as int == 1 || queries[i] as int > cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 2)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1594.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 777, "minimize_time_ms": 122568, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int\n  recommends \n    n >= 0,\n    songs.len() >= n,\n    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases n\n  when n >= 0 && songs.len() >= n\n{\n\nspec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int\n  recommends \n    song_idx >= -1,\n    songs.len() > song_idx,\n    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases song_idx + 1\n  when song_idx >= -1 && songs.len() > song_idx\n{\n\n  decreases n\n\n  decreases song_idx + 1\n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int\n  recommends \n    n >= 0,\n    songs.len() >= n,\n    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases n\n  when n >= 0 && songs.len() >= n\n{\n  if n == 0 { \n    0 \n  } else { \n    songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1) \n  }\n}\n\nspec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int\n  recommends \n    song_idx >= -1,\n    songs.len() > song_idx,\n    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases song_idx + 1\n  when song_idx >= -1 && songs.len() > song_idx\n{\n  if song_idx == -1 { \n    0 \n  } else { \n    songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1) \n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, songs: Vec<(i8, i8)>, queries: Vec<i8>) -> (result: Vec<i8>)\n  requires \n    n >= 0,\n    m >= 0,\n    songs.len() == n as nat,\n    queries.len() == m as nat,\n    forall|i: int| #![trigger songs[i]] 0 <= i < n as int ==> songs[i].0 > 0 && songs[i].1 > 0,\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int - 1 ==> queries[i] < queries[i + 1],\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int ==> queries[i] >= 1,\n    m == 0 || queries[(m-1) as int] as int <= sum_playlist_duration(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), n as int)\n  ensures \n    result.len() == m as nat,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> 1 <= result[i] as int <= n as int,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> queries[i] as int <= cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 1),\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> result[i] as int == 1 || queries[i] as int > cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 2)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1598_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {\n    if str.len() == 0 {\n        0\n    } else if str.len() == 1 {\n        1\n    } else {\n        longest_non_decreasing_subseq_helper(str, 1, 1, 1)\n    }\n}\n\nspec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat\n    decreases str.len() - i\n{\n    if i >= str.len() {\n        max_len\n    } else {\n        let new_current_len = if str[i] >= str[i-1] { current_len + 1 } else { 1 };\n        let new_max_len = if new_current_len > max_len { new_current_len } else { max_len };\n        longest_non_decreasing_subseq_helper(str, i + 1, new_current_len, new_max_len)\n    }\n}\n\nspec fn count_zeros(str: Seq<char>) -> nat\n    decreases str.len()\n{\n    if str.len() == 0 {\n        0\n    } else if str[0] == '0' {\n        1 + count_zeros(str.subrange(1, str.len() as int))\n    } else {\n        count_zeros(str.subrange(1, str.len() as int))\n    }\n}\n\nspec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {\n    forall|l: int, r: int| 0 <= l <= r <= s.len() ==> \n        longest_non_decreasing_subseq(s.subrange(l, r)) == longest_non_decreasing_subseq(t.subrange(l, r))\n}\n\nspec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && same_subsequence_lengths(s, t)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_binary_string(s@),\n    ensures\n        valid_solution(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {\n    if str.len() == 0 {\n        0\n    } else if str.len() == 1 {\n        1\n    } else {\n        longest_non_decreasing_subseq_helper(str, 1, 1, 1)\n    }\n}\n\nspec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat\n    decreases str.len() - i\n{\n    if i >= str.len() {\n        max_len\n    } else {\n        let new_current_len = if str[i] >= str[i-1] { current_len + 1 } else { 1 };\n        let new_max_len = if new_current_len > max_len { new_current_len } else { max_len };\n        longest_non_decreasing_subseq_helper(str, i + 1, new_current_len, new_max_len)\n    }\n}\n\nspec fn count_zeros(str: Seq<char>) -> nat\n    decreases str.len()\n{\n    if str.len() == 0 {\n        0\n    } else if str[0] == '0' {\n        1 + count_zeros(str.subrange(1, str.len() as int))\n    } else {\n        count_zeros(str.subrange(1, str.len() as int))\n    }\n}\n\nspec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {\n    forall|l: int, r: int| 0 <= l <= r <= s.len() ==> \n        longest_non_decreasing_subseq(s.subrange(l, r)) == longest_non_decreasing_subseq(t.subrange(l, r))\n}\n\nspec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && same_subsequence_lengths(s, t)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_binary_string(s@),\n    ensures\n        valid_solution(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1598.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 737, "minimize_time_ms": 122405, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 76, "minimized_LOC": 76, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_binary_string(s: Seq<char>) -> bool {\n\nspec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {\n\nspec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat\n    decreases str.len() - i\n{\n\nspec fn count_zeros(str: Seq<char>) -> nat\n    decreases str.len()\n{\n\nspec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {\n\nspec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n\n    decreases str.len() - i\n\n    decreases str.len()\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {\n    if str.len() == 0 {\n        0\n    } else if str.len() == 1 {\n        1\n    } else {\n        longest_non_decreasing_subseq_helper(str, 1, 1, 1)\n    }\n}\n\nspec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat\n    decreases str.len() - i\n{\n    if i >= str.len() {\n        max_len\n    } else {\n        let new_current_len = if str[i] >= str[i-1] { current_len + 1 } else { 1 };\n        let new_max_len = if new_current_len > max_len { new_current_len } else { max_len };\n        longest_non_decreasing_subseq_helper(str, i + 1, new_current_len, new_max_len)\n    }\n}\n\nspec fn count_zeros(str: Seq<char>) -> nat\n    decreases str.len()\n{\n    if str.len() == 0 {\n        0\n    } else if str[0] == '0' {\n        1 + count_zeros(str.subrange(1, str.len() as int))\n    } else {\n        count_zeros(str.subrange(1, str.len() as int))\n    }\n}\n\nspec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {\n    forall|l: int, r: int| 0 <= l <= r <= s.len() ==> \n        longest_non_decreasing_subseq(s.subrange(l, r)) == longest_non_decreasing_subseq(t.subrange(l, r))\n}\n\nspec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && same_subsequence_lengths(s, t)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_binary_string(s@),\n    ensures\n        valid_solution(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1605_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'a' || s[i] == 'b'\n}\n\nspec fn merge_consecutive(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s.len() == 1 {\n        s\n    } else if s[0] == s[1] {\n        merge_consecutive(s.subrange(1, s.len() as int))\n    } else {\n        seq![s[0]].add(merge_consecutive(s.subrange(1, s.len() as int)))\n    }\n}\n\nspec fn is_palindrome(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        true\n    } else {\n        s[0] == s[s.len() - 1] && is_palindrome(s.subrange(1, s.len() - 1))\n    }\n}\n\nspec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {\n    &&& valid_input(s)\n    &&& 0 <= i <= j < s.len()\n    &&& {\n        let sub = s.subrange(i, j + 1);\n        is_palindrome(merge_consecutive(sub))\n    }\n}\n\nspec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {\n    &&& valid_input(s)\n    &&& even_count >= 0\n    &&& odd_count >= 0\n    &&& even_count + odd_count >= s.len()\n    &&& odd_count >= s.len()\n    &&& (s.len() == 1 ==> even_count == 0 && odd_count == 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: (u32, u32))\n    requires valid_input(s@)\n    ensures valid_output(s@, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'a' || s[i] == 'b'\n}\n\nspec fn merge_consecutive(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s.len() == 1 {\n        s\n    } else if s[0] == s[1] {\n        merge_consecutive(s.subrange(1, s.len() as int))\n    } else {\n        seq![s[0]].add(merge_consecutive(s.subrange(1, s.len() as int)))\n    }\n}\n\nspec fn is_palindrome(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        true\n    } else {\n        s[0] == s[s.len() - 1] && is_palindrome(s.subrange(1, s.len() - 1))\n    }\n}\n\nspec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {\n    &&& valid_input(s)\n    &&& 0 <= i <= j < s.len()\n    &&& {\n        let sub = s.subrange(i, j + 1);\n        is_palindrome(merge_consecutive(sub))\n    }\n}\n\nspec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {\n    &&& valid_input(s)\n    &&& even_count >= 0\n    &&& odd_count >= 0\n    &&& even_count + odd_count >= s.len()\n    &&& odd_count >= s.len()\n    &&& (s.len() == 1 ==> even_count == 0 && odd_count == 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: (u32, u32))\n    requires valid_input(s@)\n    ensures valid_output(s@, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1605.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 708, "minimize_time_ms": 92281, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn merge_consecutive(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n\nspec fn is_palindrome(s: Seq<char>) -> bool\n    decreases s.len()\n{\n\nspec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {\n\nspec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_input(s@)\n\n    ensures valid_output(s@, result.0 as int, result.1 as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'a' || s[i] == 'b'\n}\n\nspec fn merge_consecutive(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s.len() == 1 {\n        s\n    } else if s[0] == s[1] {\n        merge_consecutive(s.subrange(1, s.len() as int))\n    } else {\n        seq![s[0]].add(merge_consecutive(s.subrange(1, s.len() as int)))\n    }\n}\n\nspec fn is_palindrome(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        true\n    } else {\n        s[0] == s[s.len() - 1] && is_palindrome(s.subrange(1, s.len() - 1))\n    }\n}\n\nspec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {\n    &&& valid_input(s)\n    &&& 0 <= i <= j < s.len()\n    &&& {\n        let sub = s.subrange(i, j + 1);\n        is_palindrome(merge_consecutive(sub))\n    }\n}\n\nspec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {\n    &&& valid_input(s)\n    &&& even_count >= 0\n    &&& odd_count >= 0\n    &&& even_count + odd_count >= s.len()\n    &&& odd_count >= s.len()\n    &&& (s.len() == 1 ==> even_count == 0 && odd_count == 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: (u32, u32))\n    requires valid_input(s@)\n    ensures valid_output(s@, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1618_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn valid_stairs(stair_heights: Seq<int>) -> bool {\n    stair_heights.len() >= 1 &&\n    (forall|i: int| 0 <= i < stair_heights.len() - 1 ==> #[trigger] stair_heights[i] <= stair_heights[add(i, 1)]) &&\n    (forall|i: int| 0 <= i < stair_heights.len() ==> #[trigger] stair_heights[i] >= 0)\n}\n\nspec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {\n    forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1\n}\n\nspec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool\n    recommends \n        stair_heights.len() >= 1,\n        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()\n{\n    result.len() == boxes.len() &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] >= stair_heights[0] && result[i] >= stair_heights[sub(boxes[i].0, 1)]) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] == max(if i == 0 { stair_heights[0] } else { result[sub(i, 1)] + boxes[sub(i, 1)].1 }, \n                        stair_heights[sub(boxes[i].0, 1)]))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stairs_amount: i8, stair_heights: Vec<i8>, boxes_amount: i8, boxes: Vec<(i8, i8)>) -> (result: Vec<i8>)\n    requires \n        stairs_amount >= 1,\n        stair_heights.len() == stairs_amount as int,\n        boxes_amount >= 0,\n        boxes.len() == boxes_amount as int,\n        valid_stairs(stair_heights@.map(|i: int, x: i8| x as int)),\n        valid_boxes(boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stairs_amount as int),\n    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn valid_stairs(stair_heights: Seq<int>) -> bool {\n    stair_heights.len() >= 1 &&\n    (forall|i: int| 0 <= i < stair_heights.len() - 1 ==> #[trigger] stair_heights[i] <= stair_heights[add(i, 1)]) &&\n    (forall|i: int| 0 <= i < stair_heights.len() ==> #[trigger] stair_heights[i] >= 0)\n}\n\nspec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {\n    forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1\n}\n\nspec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool\n    recommends \n        stair_heights.len() >= 1,\n        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()\n{\n    result.len() == boxes.len() &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] >= stair_heights[0] && result[i] >= stair_heights[sub(boxes[i].0, 1)]) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] == max(if i == 0 { stair_heights[0] } else { result[sub(i, 1)] + boxes[sub(i, 1)].1 }, \n                        stair_heights[sub(boxes[i].0, 1)]))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stairs_amount: i8, stair_heights: Vec<i8>, boxes_amount: i8, boxes: Vec<(i8, i8)>) -> (result: Vec<i8>)\n    requires \n        stairs_amount >= 1,\n        stair_heights.len() == stairs_amount as int,\n        boxes_amount >= 0,\n        boxes.len() == boxes_amount as int,\n        valid_stairs(stair_heights@.map(|i: int, x: i8| x as int)),\n        valid_boxes(boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stairs_amount as int),\n    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1618.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 684, "minimize_time_ms": 153504, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn max(a: int, b: int) -> int {\n\nspec fn valid_stairs(stair_heights: Seq<int>) -> bool {\n\nspec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {\n\nspec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool\n    recommends \n        stair_heights.len() >= 1,\n        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()\n{\n\n    requires \n\n    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn valid_stairs(stair_heights: Seq<int>) -> bool {\n    stair_heights.len() >= 1 &&\n    (forall|i: int| 0 <= i < stair_heights.len() - 1 ==> #[trigger] stair_heights[i] <= stair_heights[add(i, 1)]) &&\n    (forall|i: int| 0 <= i < stair_heights.len() ==> #[trigger] stair_heights[i] >= 0)\n}\n\nspec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {\n    forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1\n}\n\nspec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool\n    recommends \n        stair_heights.len() >= 1,\n        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()\n{\n    result.len() == boxes.len() &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] >= stair_heights[0] && result[i] >= stair_heights[sub(boxes[i].0, 1)]) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] == max(if i == 0 { stair_heights[0] } else { result[sub(i, 1)] + boxes[sub(i, 1)].1 }, \n                        stair_heights[sub(boxes[i].0, 1)]))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stairs_amount: i8, stair_heights: Vec<i8>, boxes_amount: i8, boxes: Vec<(i8, i8)>) -> (result: Vec<i8>)\n    requires \n        stairs_amount >= 1,\n        stair_heights.len() == stairs_amount as int,\n        boxes_amount >= 0,\n        boxes.len() == boxes_amount as int,\n        valid_stairs(stair_heights@.map(|i: int, x: i8| x as int)),\n        valid_boxes(boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stairs_amount as int),\n    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1621_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn string_value(s: Seq<char>, w: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 }\n  else {\n    let char_index = (s.last() as int) - ('a' as int);\n    string_value(s.drop_last(), w) + s.len() * w[char_index]\n  }\n}\n\nspec fn append_value(start_pos: int, count: int, max_val: int) -> int\n  decreases count\n{\n  if count <= 0 { 0 }\n  else { (start_pos + count) * max_val + append_value(start_pos, count - 1, max_val) }\n}\n\nspec fn max_value(w: Seq<int>) -> int\n  decreases w.len()\n{\n  if w.len() <= 1 { w[0] }\n  else if w[0] >= max_value(w.subrange(1, w.len() as int)) { w[0] }\n  else { max_value(w.subrange(1, w.len() as int)) }\n}\n\nspec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool\n{\n  w.len() == 26 && \n  k >= 0 && \n  s.len() <= 1000 && \n  k <= 1000 && \n  (forall|i: int| 0 <= i < w.len() ==> #[trigger] w[i] >= 0 && #[trigger] w[i] <= 1000) &&\n  (forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] && #[trigger] s[i] <= 'z')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, k: i8, w: Vec<i8>) -> (result: i8)\n  requires valid_input(s@, k as int, w@.map(|i, x| x as int))\n  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn string_value(s: Seq<char>, w: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 }\n  else {\n    let char_index = (s.last() as int) - ('a' as int);\n    string_value(s.drop_last(), w) + s.len() * w[char_index]\n  }\n}\n\nspec fn append_value(start_pos: int, count: int, max_val: int) -> int\n  decreases count\n{\n  if count <= 0 { 0 }\n  else { (start_pos + count) * max_val + append_value(start_pos, count - 1, max_val) }\n}\n\nspec fn max_value(w: Seq<int>) -> int\n  decreases w.len()\n{\n  if w.len() <= 1 { w[0] }\n  else if w[0] >= max_value(w.subrange(1, w.len() as int)) { w[0] }\n  else { max_value(w.subrange(1, w.len() as int)) }\n}\n\nspec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool\n{\n  w.len() == 26 && \n  k >= 0 && \n  s.len() <= 1000 && \n  k <= 1000 && \n  (forall|i: int| 0 <= i < w.len() ==> #[trigger] w[i] >= 0 && #[trigger] w[i] <= 1000) &&\n  (forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] && #[trigger] s[i] <= 'z')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, k: i8, w: Vec<i8>) -> (result: i8)\n  requires valid_input(s@, k as int, w@.map(|i, x| x as int))\n  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1621.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 705, "minimize_time_ms": 122385, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn string_value(s: Seq<char>, w: Seq<int>) -> int\n  decreases s.len()\n{\n\nspec fn append_value(start_pos: int, count: int, max_val: int) -> int\n  decreases count\n{\n\nspec fn max_value(w: Seq<int>) -> int\n  decreases w.len()\n{\n\nspec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool\n{\n\n  decreases s.len()\n\n  decreases count\n\n  decreases w.len()\n\n  requires valid_input(s@, k as int, w@.map(|i, x| x as int))\n\n  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn string_value(s: Seq<char>, w: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 }\n  else {\n    let char_index = (s.last() as int) - ('a' as int);\n    string_value(s.drop_last(), w) + s.len() * w[char_index]\n  }\n}\n\nspec fn append_value(start_pos: int, count: int, max_val: int) -> int\n  decreases count\n{\n  if count <= 0 { 0 }\n  else { (start_pos + count) * max_val + append_value(start_pos, count - 1, max_val) }\n}\n\nspec fn max_value(w: Seq<int>) -> int\n  decreases w.len()\n{\n  if w.len() <= 1 { w[0] }\n  else if w[0] >= max_value(w.subrange(1, w.len() as int)) { w[0] }\n  else { max_value(w.subrange(1, w.len() as int)) }\n}\n\nspec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool\n{\n  w.len() == 26 && \n  k >= 0 && \n  s.len() <= 1000 && \n  k <= 1000 && \n  (forall|i: int| 0 <= i < w.len() ==> #[trigger] w[i] >= 0 && #[trigger] w[i] <= 1000) &&\n  (forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] && #[trigger] s[i] <= 'z')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, k: i8, w: Vec<i8>) -> (result: i8)\n  requires valid_input(s@, k as int, w@.map(|i, x| x as int))\n  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1623_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, l: int, r: int) -> bool {\n    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 } else { base * power(base, exp - 1) }\n}\n\nspec fn sum_with_decreasing_powers(n: int, start_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 } \n    else if start_power <= 1 { n }\n    else { start_power + sum_with_decreasing_powers(n - 1, start_power / 2) }\n}\n\nspec fn sum_with_increasing_powers(n: int, max_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 }\n    else if n == 1 { max_power }\n    else { max_power + sum_with_increasing_powers(n - 1, max_power * 2) }\n}\n\nspec fn min_sum_calculation(n: int, l: int) -> int {\n    if n >= 1 && l >= 1 {\n        let start_power = power(2, l - 1);\n        sum_with_decreasing_powers(n, start_power)\n    } else {\n        0\n    }\n}\n\nspec fn max_sum_calculation(n: int, r: int) -> int {\n    if n >= 1 && r >= 1 {\n        let max_power = power(2, r - 1);\n        sum_with_increasing_powers(n, max_power)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, l: i8, r: i8) -> (result: (i8, i8))\n    requires valid_input(n as int, l as int, r as int)\n    ensures ({\n        let (min_sum, max_sum) = result;\n        min_sum > 0 &&\n        max_sum > 0 &&\n        min_sum <= max_sum &&\n        min_sum as int == min_sum_calculation(n as int, l as int) &&\n        max_sum as int == max_sum_calculation(n as int, r as int)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, l: int, r: int) -> bool {\n    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 } else { base * power(base, exp - 1) }\n}\n\nspec fn sum_with_decreasing_powers(n: int, start_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 } \n    else if start_power <= 1 { n }\n    else { start_power + sum_with_decreasing_powers(n - 1, start_power / 2) }\n}\n\nspec fn sum_with_increasing_powers(n: int, max_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 }\n    else if n == 1 { max_power }\n    else { max_power + sum_with_increasing_powers(n - 1, max_power * 2) }\n}\n\nspec fn min_sum_calculation(n: int, l: int) -> int {\n    if n >= 1 && l >= 1 {\n        let start_power = power(2, l - 1);\n        sum_with_decreasing_powers(n, start_power)\n    } else {\n        0\n    }\n}\n\nspec fn max_sum_calculation(n: int, r: int) -> int {\n    if n >= 1 && r >= 1 {\n        let max_power = power(2, r - 1);\n        sum_with_increasing_powers(n, max_power)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, l: i8, r: i8) -> (result: (i8, i8))\n    requires valid_input(n as int, l as int, r as int)\n    ensures ({\n        let (min_sum, max_sum) = result;\n        min_sum > 0 &&\n        max_sum > 0 &&\n        min_sum <= max_sum &&\n        min_sum as int == min_sum_calculation(n as int, l as int) &&\n        max_sum as int == max_sum_calculation(n as int, r as int)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1623.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 647, "minimize_time_ms": 92135, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 76, "minimized_LOC": 76, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, l: int, r: int) -> bool {\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n\nspec fn sum_with_decreasing_powers(n: int, start_power: int) -> int\n    decreases n\n{\n\nspec fn sum_with_increasing_powers(n: int, max_power: int) -> int\n    decreases n\n{\n\nspec fn min_sum_calculation(n: int, l: int) -> int {\n\nspec fn max_sum_calculation(n: int, r: int) -> int {\n\n    decreases exp\n\n    decreases n\n\n    decreases n\n\n    requires valid_input(n as int, l as int, r as int)\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, l: int, r: int) -> bool {\n    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 } else { base * power(base, exp - 1) }\n}\n\nspec fn sum_with_decreasing_powers(n: int, start_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 } \n    else if start_power <= 1 { n }\n    else { start_power + sum_with_decreasing_powers(n - 1, start_power / 2) }\n}\n\nspec fn sum_with_increasing_powers(n: int, max_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 }\n    else if n == 1 { max_power }\n    else { max_power + sum_with_increasing_powers(n - 1, max_power * 2) }\n}\n\nspec fn min_sum_calculation(n: int, l: int) -> int {\n    if n >= 1 && l >= 1 {\n        let start_power = power(2, l - 1);\n        sum_with_decreasing_powers(n, start_power)\n    } else {\n        0\n    }\n}\n\nspec fn max_sum_calculation(n: int, r: int) -> int {\n    if n >= 1 && r >= 1 {\n        let max_power = power(2, r - 1);\n        sum_with_increasing_powers(n, max_power)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, l: i8, r: i8) -> (result: (i8, i8))\n    requires valid_input(n as int, l as int, r as int)\n    ensures ({\n        let (min_sum, max_sum) = result;\n        min_sum > 0 &&\n        max_sum > 0 &&\n        min_sum <= max_sum &&\n        min_sum as int == min_sum_calculation(n as int, l as int) &&\n        max_sum as int == max_sum_calculation(n as int, r as int)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1627_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {\n    forall|op: (int, int)| operations.contains(op) ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1\n}\n\nspec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool \n    decreases arr.len() - i\n{\n    if i >= arr.len() - 1 {\n        true\n    } else {\n        arr[i] <= arr[i + 1] && is_sorted_helper(arr, i + 1)\n    }\n}\n\nspec fn is_sorted(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 {\n        true\n    } else {\n        is_sorted_helper(arr, 0)\n    }\n}\n\nspec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {\n    if i >= 0 && j >= 0 && i < arr.len() && j < arr.len() && j == i + 1 {\n        arr.update(i, arr[j]).update(j, arr[i])\n    } else {\n        arr\n    }\n}\n\nspec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>\n    decreases operations.len()\n{\n    if operations.len() == 0 {\n        arr\n    } else {\n        let op = operations[0];\n        if 1 <= op.0 <= arr.len() && 1 <= op.1 <= arr.len() && op.1 == op.0 + 1 {\n            let new_arr = swap_adjacent(arr, (op.0 - 1) as int, (op.1 - 1) as int);\n            apply_operations(new_arr, operations.drop_first())\n        } else {\n            apply_operations(arr, operations.drop_first())\n        }\n    }\n}\n\nspec fn count_inversions(arr: Seq<int>) -> nat {\n    /* Count of pairs (i, j) where i < j and arr[i] > arr[j] */\n    0nat /* Placeholder implementation */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, arr: Vec<i8>) -> (operations: Vec<(i8, i8)>)\n  requires \n      valid_input(n as int, arr@.map_values(|x: i8| x as int)),\n  ensures \n      valid_operations(operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)), n as int) &&\n      (is_sorted(apply_operations(arr@.map_values(|x: i8| x as int), operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)))) || operations.len() == 20000) &&\n      operations.len() <= 20000 &&\n      (is_sorted(arr@.map_values(|x: i8| x as int)) ==> operations.len() == 0)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {\n    forall|op: (int, int)| operations.contains(op) ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1\n}\n\nspec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool \n    decreases arr.len() - i\n{\n    if i >= arr.len() - 1 {\n        true\n    } else {\n        arr[i] <= arr[i + 1] && is_sorted_helper(arr, i + 1)\n    }\n}\n\nspec fn is_sorted(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 {\n        true\n    } else {\n        is_sorted_helper(arr, 0)\n    }\n}\n\nspec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {\n    if i >= 0 && j >= 0 && i < arr.len() && j < arr.len() && j == i + 1 {\n        arr.update(i, arr[j]).update(j, arr[i])\n    } else {\n        arr\n    }\n}\n\nspec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>\n    decreases operations.len()\n{\n    if operations.len() == 0 {\n        arr\n    } else {\n        let op = operations[0];\n        if 1 <= op.0 <= arr.len() && 1 <= op.1 <= arr.len() && op.1 == op.0 + 1 {\n            let new_arr = swap_adjacent(arr, (op.0 - 1) as int, (op.1 - 1) as int);\n            apply_operations(new_arr, operations.drop_first())\n        } else {\n            apply_operations(arr, operations.drop_first())\n        }\n    }\n}\n\nspec fn count_inversions(arr: Seq<int>) -> nat {\n    /* Count of pairs (i, j) where i < j and arr[i] > arr[j] */\n    0nat /* Placeholder implementation */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, arr: Vec<i8>) -> (operations: Vec<(i8, i8)>)\n  requires \n      valid_input(n as int, arr@.map_values(|x: i8| x as int)),\n  ensures \n      valid_operations(operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)), n as int) &&\n      (is_sorted(apply_operations(arr@.map_values(|x: i8| x as int), operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)))) || operations.len() == 20000) &&\n      operations.len() <= 20000 &&\n      (is_sorted(arr@.map_values(|x: i8| x as int)) ==> operations.len() == 0)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1627.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 746, "minimize_time_ms": 92102, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 87, "minimized_LOC": 87, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, arr: Seq<int>) -> bool {\n\nspec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {\n\nspec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool \n    decreases arr.len() - i\n{\n\nspec fn is_sorted(arr: Seq<int>) -> bool {\n\nspec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {\n\nspec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>\n    decreases operations.len()\n{\n\nspec fn count_inversions(arr: Seq<int>) -> nat {\n\n    decreases arr.len() - i\n\n    decreases operations.len()\n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {\n    forall|op: (int, int)| operations.contains(op) ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1\n}\n\nspec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool \n    decreases arr.len() - i\n{\n    if i >= arr.len() - 1 {\n        true\n    } else {\n        arr[i] <= arr[i + 1] && is_sorted_helper(arr, i + 1)\n    }\n}\n\nspec fn is_sorted(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 {\n        true\n    } else {\n        is_sorted_helper(arr, 0)\n    }\n}\n\nspec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {\n    if i >= 0 && j >= 0 && i < arr.len() && j < arr.len() && j == i + 1 {\n        arr.update(i, arr[j]).update(j, arr[i])\n    } else {\n        arr\n    }\n}\n\nspec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>\n    decreases operations.len()\n{\n    if operations.len() == 0 {\n        arr\n    } else {\n        let op = operations[0];\n        if 1 <= op.0 <= arr.len() && 1 <= op.1 <= arr.len() && op.1 == op.0 + 1 {\n            let new_arr = swap_adjacent(arr, (op.0 - 1) as int, (op.1 - 1) as int);\n            apply_operations(new_arr, operations.drop_first())\n        } else {\n            apply_operations(arr, operations.drop_first())\n        }\n    }\n}\n\nspec fn count_inversions(arr: Seq<int>) -> nat {\n    /* Count of pairs (i, j) where i < j and arr[i] > arr[j] */\n    0nat /* Placeholder implementation */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, arr: Vec<i8>) -> (operations: Vec<(i8, i8)>)\n  requires \n      valid_input(n as int, arr@.map_values(|x: i8| x as int)),\n  ensures \n      valid_operations(operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)), n as int) &&\n      (is_sorted(apply_operations(arr@.map_values(|x: i8| x as int), operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)))) || operations.len() == 20000) &&\n      operations.len() <= 20000 &&\n      (is_sorted(arr@.map_values(|x: i8| x as int)) ==> operations.len() == 0)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_164_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {\n    y1 < y2 < y_w &&\n    y_b + r < y_w &&\n    2 * r < y2 - y1 &&\n    x_b > 0 && y_b > 0 && r > 0 &&\n    2 * (y_w - r) - y1 - y_b - r != 0\n}\n\nspec fn compute_w(y_w: int, r: int) -> int {\n    y_w - r\n}\n\nspec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {\n    2 * (y_w - r) - y1 - y_b - r\n}\n\nspec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {\n    2 * (y_w - r) - y2 - y_b\n}\n\nspec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {\n    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)\n}\n\nspec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {\n    (new_y1 * new_y1 + x_b * x_b) * r * r\n}\n\nspec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool\n    recommends valid_input(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    let new_y2 = compute_new_y2(y_w, r, y2, y_b);\n    let left_side = compute_left_side(x_b, new_y1, new_y2);\n    let right_side = compute_right_side(x_b, new_y1, r);\n    left_side <= right_side\n}\n\nspec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int\n    recommends \n        valid_input(y1, y2, y_w, x_b, y_b, r) &&\n        !is_impossible(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    x_b * (new_y1 + y_b - w) / new_y1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(y1: i8, y2: i8, y_w: i8, x_b: i8, y_b: i8, r: i8) -> (result: i8)\n    requires \n        valid_input(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n    ensures \n        is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result == -1,\n        !is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result as int == compute_solution(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {\n    y1 < y2 < y_w &&\n    y_b + r < y_w &&\n    2 * r < y2 - y1 &&\n    x_b > 0 && y_b > 0 && r > 0 &&\n    2 * (y_w - r) - y1 - y_b - r != 0\n}\n\nspec fn compute_w(y_w: int, r: int) -> int {\n    y_w - r\n}\n\nspec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {\n    2 * (y_w - r) - y1 - y_b - r\n}\n\nspec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {\n    2 * (y_w - r) - y2 - y_b\n}\n\nspec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {\n    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)\n}\n\nspec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {\n    (new_y1 * new_y1 + x_b * x_b) * r * r\n}\n\nspec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool\n    recommends valid_input(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    let new_y2 = compute_new_y2(y_w, r, y2, y_b);\n    let left_side = compute_left_side(x_b, new_y1, new_y2);\n    let right_side = compute_right_side(x_b, new_y1, r);\n    left_side <= right_side\n}\n\nspec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int\n    recommends \n        valid_input(y1, y2, y_w, x_b, y_b, r) &&\n        !is_impossible(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    x_b * (new_y1 + y_b - w) / new_y1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(y1: i8, y2: i8, y_w: i8, x_b: i8, y_b: i8, r: i8) -> (result: i8)\n    requires \n        valid_input(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n    ensures \n        is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result == -1,\n        !is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result as int == compute_solution(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_164.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 628, "minimize_time_ms": 122539, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 79, "minimized_LOC": 79, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {\n\nspec fn compute_w(y_w: int, r: int) -> int {\n\nspec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {\n\nspec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {\n\nspec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {\n\nspec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {\n\nspec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool\n    recommends valid_input(y1, y2, y_w, x_b, y_b, r)\n{\n\nspec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int\n    recommends \n        valid_input(y1, y2, y_w, x_b, y_b, r) &&\n        !is_impossible(y1, y2, y_w, x_b, y_b, r)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {\n    y1 < y2 < y_w &&\n    y_b + r < y_w &&\n    2 * r < y2 - y1 &&\n    x_b > 0 && y_b > 0 && r > 0 &&\n    2 * (y_w - r) - y1 - y_b - r != 0\n}\n\nspec fn compute_w(y_w: int, r: int) -> int {\n    y_w - r\n}\n\nspec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {\n    2 * (y_w - r) - y1 - y_b - r\n}\n\nspec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {\n    2 * (y_w - r) - y2 - y_b\n}\n\nspec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {\n    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)\n}\n\nspec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {\n    (new_y1 * new_y1 + x_b * x_b) * r * r\n}\n\nspec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool\n    recommends valid_input(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    let new_y2 = compute_new_y2(y_w, r, y2, y_b);\n    let left_side = compute_left_side(x_b, new_y1, new_y2);\n    let right_side = compute_right_side(x_b, new_y1, r);\n    left_side <= right_side\n}\n\nspec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int\n    recommends \n        valid_input(y1, y2, y_w, x_b, y_b, r) &&\n        !is_impossible(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    x_b * (new_y1 + y_b - w) / new_y1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(y1: i8, y2: i8, y_w: i8, x_b: i8, y_b: i8, r: i8) -> (result: i8)\n    requires \n        valid_input(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n    ensures \n        is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result == -1,\n        !is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result as int == compute_solution(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1643_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '0' {\n        1 + count_zeros(s.subrange(1, s.len() as int))\n    } else {\n        count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_ones(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        1 + count_ones(s.subrange(1, s.len() as int))\n    } else {\n        count_ones(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        1\n    } else {\n        let count_ones = count_ones(s);\n        let count_zeros = s.len() - count_ones;\n        if count_zeros == 0 {\n            count_ones\n        } else if count_ones == 0 {\n            1\n        } else {\n            count_zeros + count_ones\n        }\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int\n    recommends 0 <= l <= r < s.len()\n{\n    let sub = s.subrange(l, r + 1);\n    longest_non_decreasing_subseq_length_complete(sub)\n}\n\nspec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    &&& s.len() == t.len()\n    &&& valid_binary_string(s)\n    &&& valid_binary_string(t)\n    &&& (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' ==> t[i] == '0')\n    &&& (forall|i: int| 0 <= i < s.len() ==> t[i] == '1' ==> s[i] == '1')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_binary_string(s@)\n    ensures basic_valid_solution(s@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '0' {\n        1 + count_zeros(s.subrange(1, s.len() as int))\n    } else {\n        count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_ones(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        1 + count_ones(s.subrange(1, s.len() as int))\n    } else {\n        count_ones(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        1\n    } else {\n        let count_ones = count_ones(s);\n        let count_zeros = s.len() - count_ones;\n        if count_zeros == 0 {\n            count_ones\n        } else if count_ones == 0 {\n            1\n        } else {\n            count_zeros + count_ones\n        }\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int\n    recommends 0 <= l <= r < s.len()\n{\n    let sub = s.subrange(l, r + 1);\n    longest_non_decreasing_subseq_length_complete(sub)\n}\n\nspec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    &&& s.len() == t.len()\n    &&& valid_binary_string(s)\n    &&& valid_binary_string(t)\n    &&& (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' ==> t[i] == '0')\n    &&& (forall|i: int| 0 <= i < s.len() ==> t[i] == '1' ==> s[i] == '1')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_binary_string(s@)\n    ensures basic_valid_solution(s@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1643.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1050, "minimize_time_ms": 92165, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 87, "minimized_LOC": 87, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_binary_string(s: Seq<char>) -> bool {\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn count_ones(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {\n\nspec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int\n    recommends 0 <= l <= r < s.len()\n{\n\nspec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_binary_string(s@)\n\n    ensures basic_valid_solution(s@, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '0' {\n        1 + count_zeros(s.subrange(1, s.len() as int))\n    } else {\n        count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_ones(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        1 + count_ones(s.subrange(1, s.len() as int))\n    } else {\n        count_ones(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        1\n    } else {\n        let count_ones = count_ones(s);\n        let count_zeros = s.len() - count_ones;\n        if count_zeros == 0 {\n            count_ones\n        } else if count_ones == 0 {\n            1\n        } else {\n            count_zeros + count_ones\n        }\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int\n    recommends 0 <= l <= r < s.len()\n{\n    let sub = s.subrange(l, r + 1);\n    longest_non_decreasing_subseq_length_complete(sub)\n}\n\nspec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    &&& s.len() == t.len()\n    &&& valid_binary_string(s)\n    &&& valid_binary_string(t)\n    &&& (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' ==> t[i] == '0')\n    &&& (forall|i: int| 0 <= i < s.len() ==> t[i] == '1' ==> s[i] == '1')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_binary_string(s@)\n    ensures basic_valid_solution(s@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1646_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1') &&\n    (s == seq!['0'] || s[0] == '1')\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0int\n    } else { \n        (if s[0] == '0' { 1int } else { 0int }) + count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn create_zero_seq(n: nat) -> Seq<char> {\n    Seq::new(n, |i: int| '0')\n}\n\nspec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {\n    (s == seq!['0'] ==> result == seq!['0'])\n    &&\n    (s != seq!['0'] ==> result == seq!['1'] + create_zero_seq(count_zeros(s) as nat))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 1 && n <= 100,\n        s.len() == n as usize,\n        valid_binary_string(s@),\n    ensures \n        valid_binary_string(result@),\n        is_minimal_form(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1') &&\n    (s == seq!['0'] || s[0] == '1')\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0int\n    } else { \n        (if s[0] == '0' { 1int } else { 0int }) + count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn create_zero_seq(n: nat) -> Seq<char> {\n    Seq::new(n, |i: int| '0')\n}\n\nspec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {\n    (s == seq!['0'] ==> result == seq!['0'])\n    &&\n    (s != seq!['0'] ==> result == seq!['1'] + create_zero_seq(count_zeros(s) as nat))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 1 && n <= 100,\n        s.len() == n as usize,\n        valid_binary_string(s@),\n    ensures \n        valid_binary_string(result@),\n        is_minimal_form(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1646.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 668, "minimize_time_ms": 92023, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_binary_string(s: Seq<char>) -> bool {\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn create_zero_seq(n: nat) -> Seq<char> {\n\nspec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1') &&\n    (s == seq!['0'] || s[0] == '1')\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0int\n    } else { \n        (if s[0] == '0' { 1int } else { 0int }) + count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn create_zero_seq(n: nat) -> Seq<char> {\n    Seq::new(n, |i: int| '0')\n}\n\nspec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {\n    (s == seq!['0'] ==> result == seq!['0'])\n    &&\n    (s != seq!['0'] ==> result == seq!['1'] + create_zero_seq(count_zeros(s) as nat))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 1 && n <= 100,\n        s.len() == n as usize,\n        valid_binary_string(s@),\n    ensures \n        valid_binary_string(result@),\n        is_minimal_form(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1656_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn wow_factor(s: Seq<char>) -> int {\n    if s.len() < 4 { 0 }\n    else {\n        wow_factor_sum(s, 0)\n    }\n}\n\nspec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos <= 1 { 0 }\n    else {\n        let prev = count_vv_pairs_before(s, pos - 1);\n        if s[pos-1] == 'v' && s[pos-2] == 'v' { prev + 1 } else { prev }\n    }\n}\n\nspec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() - 1 { 0 }\n    else {\n        let rest = count_vv_pairs_after(s, pos + 1);\n        if pos + 1 < s.len() && s[pos] == 'v' && s[pos+1] == 'v' { rest + 1 } else { rest }\n    }\n}\n\nspec fn wow_factor_sum(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() { 0 }\n    else {\n        let current = if s[pos] == 'o' { \n            count_vv_pairs_before(s, pos) * count_vv_pairs_after(s, pos + 1)\n        } else { 0 };\n        current + wow_factor_sum(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    ensures\n        result as int == wow_factor(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn wow_factor(s: Seq<char>) -> int {\n    if s.len() < 4 { 0 }\n    else {\n        wow_factor_sum(s, 0)\n    }\n}\n\nspec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos <= 1 { 0 }\n    else {\n        let prev = count_vv_pairs_before(s, pos - 1);\n        if s[pos-1] == 'v' && s[pos-2] == 'v' { prev + 1 } else { prev }\n    }\n}\n\nspec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() - 1 { 0 }\n    else {\n        let rest = count_vv_pairs_after(s, pos + 1);\n        if pos + 1 < s.len() && s[pos] == 'v' && s[pos+1] == 'v' { rest + 1 } else { rest }\n    }\n}\n\nspec fn wow_factor_sum(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() { 0 }\n    else {\n        let current = if s[pos] == 'o' { \n            count_vv_pairs_before(s, pos) * count_vv_pairs_after(s, pos + 1)\n        } else { 0 };\n        current + wow_factor_sum(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    ensures\n        result as int == wow_factor(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1656.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 662, "minimize_time_ms": 92036, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn wow_factor(s: Seq<char>) -> int {\n\nspec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n\nspec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n\nspec fn wow_factor_sum(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n\n    decreases pos\n\n    decreases s.len() - pos\n\n    decreases s.len() - pos\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn wow_factor(s: Seq<char>) -> int {\n    if s.len() < 4 { 0 }\n    else {\n        wow_factor_sum(s, 0)\n    }\n}\n\nspec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos <= 1 { 0 }\n    else {\n        let prev = count_vv_pairs_before(s, pos - 1);\n        if s[pos-1] == 'v' && s[pos-2] == 'v' { prev + 1 } else { prev }\n    }\n}\n\nspec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() - 1 { 0 }\n    else {\n        let rest = count_vv_pairs_after(s, pos + 1);\n        if pos + 1 < s.len() && s[pos] == 'v' && s[pos+1] == 'v' { rest + 1 } else { rest }\n    }\n}\n\nspec fn wow_factor_sum(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() { 0 }\n    else {\n        let current = if s[pos] == 'o' { \n            count_vv_pairs_before(s, pos) * count_vv_pairs_after(s, pos + 1)\n        } else { 0 };\n        current + wow_factor_sum(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    ensures\n        result as int == wow_factor(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1689_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {\n    n >= 0 && rows.len() == n && forall|i: int| 0 <= i < rows.len() ==> rows[i].len() == 5\n}\n\nspec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < rows.len() && \n        ((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n         (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < rows.len() ==> \n        !((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n          (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {\n    result.len() != 2 || result[0] != 'N' || result[1] != 'O' ==> result.len() >= 4\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {\n    v@.map(|i, row: Vec<char>| row@)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, rows: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        valid_input(n as int, vec_to_seq_seq(rows))\n    ensures \n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') || result@.len() >= 4,\n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> no_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        !(result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> has_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        valid_solution(result@, vec_to_seq_seq(rows))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {\n    n >= 0 && rows.len() == n && forall|i: int| 0 <= i < rows.len() ==> rows[i].len() == 5\n}\n\nspec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < rows.len() && \n        ((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n         (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < rows.len() ==> \n        !((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n          (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {\n    result.len() != 2 || result[0] != 'N' || result[1] != 'O' ==> result.len() >= 4\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {\n    v@.map(|i, row: Vec<char>| row@)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, rows: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        valid_input(n as int, vec_to_seq_seq(rows))\n    ensures \n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') || result@.len() >= 4,\n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> no_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        !(result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> has_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        valid_solution(result@, vec_to_seq_seq(rows))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1689.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 685, "minimize_time_ms": 92171, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {\n\nspec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n\nspec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n\nspec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {\n\nspec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {\n    n >= 0 && rows.len() == n && forall|i: int| 0 <= i < rows.len() ==> rows[i].len() == 5\n}\n\nspec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < rows.len() && \n        ((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n         (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < rows.len() ==> \n        !((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n          (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {\n    result.len() != 2 || result[0] != 'N' || result[1] != 'O' ==> result.len() >= 4\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {\n    v@.map(|i, row: Vec<char>| row@)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, rows: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        valid_input(n as int, vec_to_seq_seq(rows))\n    ensures \n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') || result@.len() >= 4,\n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> no_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        !(result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> has_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        valid_solution(result@, vec_to_seq_seq(rows))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_171_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn contains_lowercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'a' <= s[i] && s[i] <= 'z'\n}\n\nspec fn contains_uppercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'A' <= s[i] && s[i] <= 'Z'\n}\n\nspec fn contains_digit(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_password(s: Seq<char>) -> bool {\n    s.len() >= 5 && contains_lowercase(s) && contains_uppercase(s) && contains_digit(s)\n}\n\nspec fn trim_newline(s: Seq<char>) -> Seq<char> {\n    if s.len() > 0 && s[s.len() as int - 1] == '\\n' { \n        s.subrange(0, s.len() as int - 1) \n    } else { \n        s \n    }\n}\n\nspec fn strip_whitespace(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        s\n    } else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' {\n        strip_whitespace(s.subrange(1, s.len() as int))\n    } else if s[s.len() as int - 1] == ' ' || s[s.len() as int - 1] == '\\t' || s[s.len() as int - 1] == '\\n' || s[s.len() as int - 1] == '\\r' {\n        strip_whitespace(s.subrange(0, s.len() as int - 1))\n    } else { \n        s \n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires input@.len() > 0\n    ensures ({\n        let processed_input = trim_newline(input@);\n        let stripped = strip_whitespace(processed_input);\n        if is_valid_password(stripped) {\n            output@ == seq!['C', 'o', 'r', 'r', 'e', 'c', 't', '\\n']\n        } else {\n            output@ == seq!['T', 'o', 'o', ' ', 'w', 'e', 'a', 'k', '\\n']\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn contains_lowercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'a' <= s[i] && s[i] <= 'z'\n}\n\nspec fn contains_uppercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'A' <= s[i] && s[i] <= 'Z'\n}\n\nspec fn contains_digit(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_password(s: Seq<char>) -> bool {\n    s.len() >= 5 && contains_lowercase(s) && contains_uppercase(s) && contains_digit(s)\n}\n\nspec fn trim_newline(s: Seq<char>) -> Seq<char> {\n    if s.len() > 0 && s[s.len() as int - 1] == '\\n' { \n        s.subrange(0, s.len() as int - 1) \n    } else { \n        s \n    }\n}\n\nspec fn strip_whitespace(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        s\n    } else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' {\n        strip_whitespace(s.subrange(1, s.len() as int))\n    } else if s[s.len() as int - 1] == ' ' || s[s.len() as int - 1] == '\\t' || s[s.len() as int - 1] == '\\n' || s[s.len() as int - 1] == '\\r' {\n        strip_whitespace(s.subrange(0, s.len() as int - 1))\n    } else { \n        s \n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires input@.len() > 0\n    ensures ({\n        let processed_input = trim_newline(input@);\n        let stripped = strip_whitespace(processed_input);\n        if is_valid_password(stripped) {\n            output@ == seq!['C', 'o', 'r', 'r', 'e', 'c', 't', '\\n']\n        } else {\n            output@ == seq!['T', 'o', 'o', ' ', 'w', 'e', 'a', 'k', '\\n']\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_171.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 728, "minimize_time_ms": 92152, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 70, "minimized_LOC": 70, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn contains_lowercase(s: Seq<char>) -> bool {\n\nspec fn contains_uppercase(s: Seq<char>) -> bool {\n\nspec fn contains_digit(s: Seq<char>) -> bool {\n\nspec fn is_valid_password(s: Seq<char>) -> bool {\n\nspec fn trim_newline(s: Seq<char>) -> Seq<char> {\n\nspec fn strip_whitespace(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    requires input@.len() > 0\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn contains_lowercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'a' <= s[i] && s[i] <= 'z'\n}\n\nspec fn contains_uppercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'A' <= s[i] && s[i] <= 'Z'\n}\n\nspec fn contains_digit(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_password(s: Seq<char>) -> bool {\n    s.len() >= 5 && contains_lowercase(s) && contains_uppercase(s) && contains_digit(s)\n}\n\nspec fn trim_newline(s: Seq<char>) -> Seq<char> {\n    if s.len() > 0 && s[s.len() as int - 1] == '\\n' { \n        s.subrange(0, s.len() as int - 1) \n    } else { \n        s \n    }\n}\n\nspec fn strip_whitespace(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        s\n    } else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' {\n        strip_whitespace(s.subrange(1, s.len() as int))\n    } else if s[s.len() as int - 1] == ' ' || s[s.len() as int - 1] == '\\t' || s[s.len() as int - 1] == '\\n' || s[s.len() as int - 1] == '\\r' {\n        strip_whitespace(s.subrange(0, s.len() as int - 1))\n    } else { \n        s \n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires input@.len() > 0\n    ensures ({\n        let processed_input = trim_newline(input@);\n        let stripped = strip_whitespace(processed_input);\n        if is_valid_password(stripped) {\n            output@ == seq!['C', 'o', 'r', 'r', 'e', 'c', 't', '\\n']\n        } else {\n            output@ == seq!['T', 'o', 'o', ' ', 'w', 'e', 'a', 'k', '\\n']\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1711_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 2 && m >= 1 && n <= m && m <= 200000\n}\n\nspec fn combination(n: int, k: int, modulus: int) -> int {\n    0  /* placeholder - actual combinatorial calculation */\n}\n\nspec fn power(base: int, exp: int, modulus: int) -> int {\n    0  /* placeholder - actual modular exponentiation */\n}\n\nspec fn expected_result(n: int, m: int) -> int {\n    if n == 2 {\n        0\n    } else {\n        (((combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * power(2, n - 3, 998244353)) % 998244353\n    }\n}\n\nspec fn valid_output(result: int) -> bool {\n    0 <= result < 998244353\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        valid_output(result as int),\n        result as int == expected_result(n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 2 && m >= 1 && n <= m && m <= 200000\n}\n\nspec fn combination(n: int, k: int, modulus: int) -> int {\n    0  /* placeholder - actual combinatorial calculation */\n}\n\nspec fn power(base: int, exp: int, modulus: int) -> int {\n    0  /* placeholder - actual modular exponentiation */\n}\n\nspec fn expected_result(n: int, m: int) -> int {\n    if n == 2 {\n        0\n    } else {\n        (((combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * power(2, n - 3, 998244353)) % 998244353\n    }\n}\n\nspec fn valid_output(result: int) -> bool {\n    0 <= result < 998244353\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        valid_output(result as int),\n        result as int == expected_result(n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1711.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 629, "minimize_time_ms": 92168, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int) -> bool {\n\nspec fn combination(n: int, k: int, modulus: int) -> int {\n\nspec fn power(base: int, exp: int, modulus: int) -> int {\n\nspec fn expected_result(n: int, m: int) -> int {\n\nspec fn valid_output(result: int) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 2 && m >= 1 && n <= m && m <= 200000\n}\n\nspec fn combination(n: int, k: int, modulus: int) -> int {\n    0  /* placeholder - actual combinatorial calculation */\n}\n\nspec fn power(base: int, exp: int, modulus: int) -> int {\n    0  /* placeholder - actual modular exponentiation */\n}\n\nspec fn expected_result(n: int, m: int) -> int {\n    if n == 2 {\n        0\n    } else {\n        (((combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * power(2, n - 3, 998244353)) % 998244353\n    }\n}\n\nspec fn valid_output(result: int) -> bool {\n    0 <= result < 998244353\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        valid_output(result as int),\n        result as int == expected_result(n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1712_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {\n    n >= 0 && a > 0 && b > 0 && mobs.len() == n &&\n    forall|i: int| 0 <= i < n ==> #[trigger] mobs[i] >= 0\n}\n\nspec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < n ==> \n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a']) || \n        (result[i]@ =~= seq!['V', 'o', 'v', 'a']) || \n        (result[i]@ =~= seq!['B', 'o', 't', 'h'])\n}\n\nspec fn determine_winner(k: int, a: int, b: int) -> int {\n    if k <= a { 0 } else { 1 }\n}\n\nspec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool\n    recommends a > 0 && b > 0 && mobs.len() == n\n{\n    valid_output(result, n) &&\n    forall|i: int| 0 <= i < n ==> {\n        let total = a + b;\n        let k = if mobs[i] == 0 { 0 } else { mobs[i] % total };\n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a'] <==> determine_winner(k, a, b) == 0) &&\n        (result[i]@ =~= seq!['V', 'o', 'v', 'a'] <==> determine_winner(k, a, b) == 1) &&\n        (result[i]@ =~= seq!['B', 'o', 't', 'h'] <==> determine_winner(k, a, b) == 2)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, mobs: Vec<i8>) -> (result: Vec<Vec<char>>)\n    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {\n    n >= 0 && a > 0 && b > 0 && mobs.len() == n &&\n    forall|i: int| 0 <= i < n ==> #[trigger] mobs[i] >= 0\n}\n\nspec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < n ==> \n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a']) || \n        (result[i]@ =~= seq!['V', 'o', 'v', 'a']) || \n        (result[i]@ =~= seq!['B', 'o', 't', 'h'])\n}\n\nspec fn determine_winner(k: int, a: int, b: int) -> int {\n    if k <= a { 0 } else { 1 }\n}\n\nspec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool\n    recommends a > 0 && b > 0 && mobs.len() == n\n{\n    valid_output(result, n) &&\n    forall|i: int| 0 <= i < n ==> {\n        let total = a + b;\n        let k = if mobs[i] == 0 { 0 } else { mobs[i] % total };\n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a'] <==> determine_winner(k, a, b) == 0) &&\n        (result[i]@ =~= seq!['V', 'o', 'v', 'a'] <==> determine_winner(k, a, b) == 1) &&\n        (result[i]@ =~= seq!['B', 'o', 't', 'h'] <==> determine_winner(k, a, b) == 2)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, mobs: Vec<i8>) -> (result: Vec<Vec<char>>)\n    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1712.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 694, "minimize_time_ms": 123340, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {\n\nspec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {\n\nspec fn determine_winner(k: int, a: int, b: int) -> int {\n\nspec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool\n    recommends a > 0 && b > 0 && mobs.len() == n\n{\n\n    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n\n    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {\n    n >= 0 && a > 0 && b > 0 && mobs.len() == n &&\n    forall|i: int| 0 <= i < n ==> #[trigger] mobs[i] >= 0\n}\n\nspec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < n ==> \n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a']) || \n        (result[i]@ =~= seq!['V', 'o', 'v', 'a']) || \n        (result[i]@ =~= seq!['B', 'o', 't', 'h'])\n}\n\nspec fn determine_winner(k: int, a: int, b: int) -> int {\n    if k <= a { 0 } else { 1 }\n}\n\nspec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool\n    recommends a > 0 && b > 0 && mobs.len() == n\n{\n    valid_output(result, n) &&\n    forall|i: int| 0 <= i < n ==> {\n        let total = a + b;\n        let k = if mobs[i] == 0 { 0 } else { mobs[i] % total };\n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a'] <==> determine_winner(k, a, b) == 0) &&\n        (result[i]@ =~= seq!['V', 'o', 'v', 'a'] <==> determine_winner(k, a, b) == 1) &&\n        (result[i]@ =~= seq!['B', 'o', 't', 'h'] <==> determine_winner(k, a, b) == 2)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, mobs: Vec<i8>) -> (result: Vec<Vec<char>>)\n    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n              fn main() {\n    }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1723_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_output(n: int, result: Seq<String>) -> bool\n    recommends n >= 2\n{\n    if n < 6 {\n        result.len() == 1 + (n - 1) &&\n        result[0]@ == seq!['-', '1'] &&\n        (forall|i: int| #![auto] 1 <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 1))\n    } else {\n        result.len() == (5 + (n - 6)) + (n - 1) &&\n        result[0]@ == seq!['1', ' ', '2'] && \n        result[1]@ == seq!['1', ' ', '3'] && \n        result[2]@ == seq!['1', ' ', '4'] && \n        result[3]@ == seq!['2', ' ', '5'] && \n        result[4]@ == seq!['2', ' ', '6'] &&\n        (forall|i: int| #![auto] 5 <= i < 5 + (n - 6) ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 2)) &&\n        (forall|i: int| #![auto] 5 + (n - 6) <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i - (5 + (n - 6)) + 2))\n    }\n}\n\nspec fn int_to_string_pos(n: nat) -> Seq<char>\n    decreases n\n{\n    if n < 10 {\n        seq![(n + ('0' as nat)) as char]\n    } else {\n        int_to_string_pos(n / 10) + int_to_string_pos(n % 10)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n < 0 {\n        seq!['-'] + int_to_string_pos((-n) as nat)\n    } else {\n        int_to_string_pos(n as nat)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<String>)\n    requires n as int >= 2\n    ensures valid_output(n as int, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_output(n: int, result: Seq<String>) -> bool\n    recommends n >= 2\n{\n    if n < 6 {\n        result.len() == 1 + (n - 1) &&\n        result[0]@ == seq!['-', '1'] &&\n        (forall|i: int| #![auto] 1 <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 1))\n    } else {\n        result.len() == (5 + (n - 6)) + (n - 1) &&\n        result[0]@ == seq!['1', ' ', '2'] && \n        result[1]@ == seq!['1', ' ', '3'] && \n        result[2]@ == seq!['1', ' ', '4'] && \n        result[3]@ == seq!['2', ' ', '5'] && \n        result[4]@ == seq!['2', ' ', '6'] &&\n        (forall|i: int| #![auto] 5 <= i < 5 + (n - 6) ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 2)) &&\n        (forall|i: int| #![auto] 5 + (n - 6) <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i - (5 + (n - 6)) + 2))\n    }\n}\n\nspec fn int_to_string_pos(n: nat) -> Seq<char>\n    decreases n\n{\n    if n < 10 {\n        seq![(n + ('0' as nat)) as char]\n    } else {\n        int_to_string_pos(n / 10) + int_to_string_pos(n % 10)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n < 0 {\n        seq!['-'] + int_to_string_pos((-n) as nat)\n    } else {\n        int_to_string_pos(n as nat)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<String>)\n    requires n as int >= 2\n    ensures valid_output(n as int, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1723.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 698, "minimize_time_ms": 123366, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_output(n: int, result: Seq<String>) -> bool\n    recommends n >= 2\n{\n\nspec fn int_to_string_pos(n: nat) -> Seq<char>\n    decreases n\n{\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\n    decreases n\n\n    requires n as int >= 2\n\n    ensures valid_output(n as int, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_output(n: int, result: Seq<String>) -> bool\n    recommends n >= 2\n{\n    if n < 6 {\n        result.len() == 1 + (n - 1) &&\n        result[0]@ == seq!['-', '1'] &&\n        (forall|i: int| #![auto] 1 <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 1))\n    } else {\n        result.len() == (5 + (n - 6)) + (n - 1) &&\n        result[0]@ == seq!['1', ' ', '2'] && \n        result[1]@ == seq!['1', ' ', '3'] && \n        result[2]@ == seq!['1', ' ', '4'] && \n        result[3]@ == seq!['2', ' ', '5'] && \n        result[4]@ == seq!['2', ' ', '6'] &&\n        (forall|i: int| #![auto] 5 <= i < 5 + (n - 6) ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 2)) &&\n        (forall|i: int| #![auto] 5 + (n - 6) <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i - (5 + (n - 6)) + 2))\n    }\n}\n\nspec fn int_to_string_pos(n: nat) -> Seq<char>\n    decreases n\n{\n    if n < 10 {\n        seq![(n + ('0' as nat)) as char]\n    } else {\n        int_to_string_pos(n / 10) + int_to_string_pos(n % 10)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n < 0 {\n        seq!['-'] + int_to_string_pos((-n) as nat)\n    } else {\n        int_to_string_pos(n as nat)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<String>)\n    requires n as int >= 2\n    ensures valid_output(n as int, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n                fn main() {\n      }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1725_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool {\n    n > 0 && m > 0 && d > 0 &&\n    matrix.len() == n &&\n    (forall|i: int| #![auto] 0 <= i < n ==> matrix[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> matrix[i][j] > 0)\n}\n\nspec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool\n    recommends valid_input(matrix.len() as int, if matrix.len() > 0 { matrix[0].len() as int } else { 0 }, d, matrix)\n{\n    forall|i: int, j: int, k: int, l: int| \n        0 <= i < matrix.len() && 0 <= j < matrix[0].len() && \n        0 <= k < matrix.len() && 0 <= l < matrix[0].len() ==>\n        matrix[i][j] % d == matrix[k][l] % d\n}\n\nspec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>\n    decreases matrix.len()\n{\n    if matrix.len() == 0 {\n        seq![]\n    } else {\n        matrix[0].add(flatten(matrix.subrange(1, matrix.len() as int)))\n    }\n}\n\nspec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>\n    recommends d > 0\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![s[0] / d].add(divide_sequence_by_d(s.subrange(1, s.len() as int), d))\n    }\n}\n\nspec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if s[0] >= target { s[0] - target } else { target - s[0] }) + \n        sum_abs_differences_from_target(s.subrange(1, s.len() as int), target)\n    }\n}\n\nspec fn seq_min(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() == 0 {\n        0\n    } else {\n        let rest_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() == 0 {\n        0\n    } else {\n        let rest_max = seq_max(s.subrange(1, s.len() as int));\n        if s[0] >= rest_max { s[0] } else { rest_max }\n    }\n}\n\nspec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int\n    recommends simplified.len() > 0\n    decreases max_val - min_val\n{\n    if min_val >= max_val {\n        sum_abs_differences_from_target(simplified, min_val)\n    } else {\n        let mid = (min_val + max_val) / 2;\n        let mid_ops = sum_abs_differences_from_target(simplified, mid);\n        let left_ops = if mid > min_val { min_ops_in_range(simplified, min_val, mid - 1) } else { mid_ops };\n        let right_ops = if mid < max_val { min_ops_in_range(simplified, mid + 1, max_val) } else { mid_ops };\n        if mid_ops <= left_ops && mid_ops <= right_ops {\n            mid_ops\n        } else if left_ops <= right_ops {\n            left_ops\n        } else {\n            right_ops\n        }\n    }\n}\n\nspec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int\n    recommends simplified.len() > 0\n{\n    let min_val = seq_min(simplified);\n    let max_val = seq_max(simplified);\n    min_ops_in_range(simplified, min_val, max_val)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures \n        result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),\n        result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),\n        result >= 0 ==> {\n            let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));\n            let simplified = divide_sequence_by_d(flat, d as int);\n            result as int == minimum_operations_to_make_equal(simplified)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool ;\n       spec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool     recommends valid_input(matrix.len() as int, if matrix.len() > 0 {\n      matrix[0].len() as int }\n       else {\n      0 }\n      , d, matrix) ;\n       spec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>     decreases matrix.len() ;\n       spec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>     recommends d > 0     decreases s.len() ;\n       spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int     decreases s.len() ;\n       spec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n                  let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));\n                  let simplified = divide_sequence_by_d(flat, d as int);\n                  result as int == minimum_operations_to_make_equal(simplified)         }\n       {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1725.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 761, "minimize_time_ms": 184568, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 137, "minimized_LOC": 25, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.18248175182481752}, "labeling": {"segments": {"exec": " fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n\n fn main() {", "spec": "spec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool ;\n       spec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool     recommends valid_input(matrix.len() as int, if matrix.len() > 0 {\n\nspec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool     recommends valid_input(matrix.len() as int, if matrix.len() > 0 {\n\nspec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>     decreases matrix.len() ;\n       spec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>     recommends d > 0     decreases s.len() ;\n       spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int     decreases s.len() ;\n       spec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n\nspec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>     recommends d > 0     decreases s.len() ;\n       spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int     decreases s.len() ;\n       spec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n\nspec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int     decreases s.len() ;\n       spec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n\nspec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n\nspec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n\nspec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n\nspec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n\n       spec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>     decreases matrix.len() ;\n\n       spec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>     recommends d > 0     decreases s.len() ;\n\n       spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int     decreases s.len() ;\n\n       spec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n\n       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool {\n    n > 0 && m > 0 && d > 0 &&\n    matrix.len() == n &&\n    (forall|i: int| #![auto] 0 <= i < n ==> matrix[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> matrix[i][j] > 0)\n}\n\nspec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool\n    recommends valid_input(matrix.len() as int, if matrix.len() > 0 { matrix[0].len() as int } else { 0 }, d, matrix)\n{\n    forall|i: int, j: int, k: int, l: int| \n        0 <= i < matrix.len() && 0 <= j < matrix[0].len() && \n        0 <= k < matrix.len() && 0 <= l < matrix[0].len() ==>\n        matrix[i][j] % d == matrix[k][l] % d\n}\n\nspec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>\n    decreases matrix.len()\n{\n    if matrix.len() == 0 {\n        seq![]\n    } else {\n        matrix[0].add(flatten(matrix.subrange(1, matrix.len() as int)))\n    }\n}\n\nspec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>\n    recommends d > 0\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![s[0] / d].add(divide_sequence_by_d(s.subrange(1, s.len() as int), d))\n    }\n}\n\nspec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if s[0] >= target { s[0] - target } else { target - s[0] }) + \n        sum_abs_differences_from_target(s.subrange(1, s.len() as int), target)\n    }\n}\n\nspec fn seq_min(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() == 0 {\n        0\n    } else {\n        let rest_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() == 0 {\n        0\n    } else {\n        let rest_max = seq_max(s.subrange(1, s.len() as int));\n        if s[0] >= rest_max { s[0] } else { rest_max }\n    }\n}\n\nspec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int\n    recommends simplified.len() > 0\n    decreases max_val - min_val\n{\n    if min_val >= max_val {\n        sum_abs_differences_from_target(simplified, min_val)\n    } else {\n        let mid = (min_val + max_val) / 2;\n        let mid_ops = sum_abs_differences_from_target(simplified, mid);\n        let left_ops = if mid > min_val { min_ops_in_range(simplified, min_val, mid - 1) } else { mid_ops };\n        let right_ops = if mid < max_val { min_ops_in_range(simplified, mid + 1, max_val) } else { mid_ops };\n        if mid_ops <= left_ops && mid_ops <= right_ops {\n            mid_ops\n        } else if left_ops <= right_ops {\n            left_ops\n        } else {\n            right_ops\n        }\n    }\n}\n\nspec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int\n    recommends simplified.len() > 0\n{\n    let min_val = seq_min(simplified);\n    let max_val = seq_max(simplified);\n    min_ops_in_range(simplified, min_val, max_val)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures \n        result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),\n        result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),\n        result >= 0 ==> {\n            let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));\n            let simplified = divide_sequence_by_d(flat, d as int);\n            result as int == minimum_operations_to_make_equal(simplified)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool ;\n       spec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool     recommends valid_input(matrix.len() as int, if matrix.len() > 0 {\n      matrix[0].len() as int }\n       else {\n      0 }\n      , d, matrix) ;\n       spec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>     decreases matrix.len() ;\n       spec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>     recommends d > 0     decreases s.len() ;\n       spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int     decreases s.len() ;\n       spec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n                  let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));\n                  let simplified = divide_sequence_by_d(flat, d as int);\n                  result as int == minimum_operations_to_make_equal(simplified)         }\n       {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n         verus! {}\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1735_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_max_moves(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let stack: Seq<char> = seq![];\n        let moves: nat = 0;\n        count_max_moves_helper(s, 0, stack, moves)\n    }\n}\n\nspec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat\n    decreases s.len() - i\n{\n    if i <= s.len() {\n        if i == s.len() {\n            moves\n        } else if stack.len() > 0 && s[i as int] == stack[stack.len() as int - 1] {\n            count_max_moves_helper(s, i + 1, stack.subrange(0, stack.len() as int - 1), moves + 1)\n        } else {\n            count_max_moves_helper(s, i + 1, stack.push(s[i as int]), moves)\n        }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: &'static str)\n    requires s.len() >= 1\n    ensures\n        result == \"Yes\" || result == \"No\",\n        result == \"Yes\" <==> count_max_moves(s@) % 2 == 1,\n        result == \"No\" <==> count_max_moves(s@) % 2 == 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_max_moves(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let stack: Seq<char> = seq![];\n        let moves: nat = 0;\n        count_max_moves_helper(s, 0, stack, moves)\n    }\n}\n\nspec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat\n    decreases s.len() - i\n{\n    if i <= s.len() {\n        if i == s.len() {\n            moves\n        } else if stack.len() > 0 && s[i as int] == stack[stack.len() as int - 1] {\n            count_max_moves_helper(s, i + 1, stack.subrange(0, stack.len() as int - 1), moves + 1)\n        } else {\n            count_max_moves_helper(s, i + 1, stack.push(s[i as int]), moves)\n        }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: &'static str)\n    requires s.len() >= 1\n    ensures\n        result == \"Yes\" || result == \"No\",\n        result == \"Yes\" <==> count_max_moves(s@) % 2 == 1,\n        result == \"No\" <==> count_max_moves(s@) % 2 == 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1735.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 717, "minimize_time_ms": 122331, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_max_moves(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\nspec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat\n    decreases s.len() - i\n{\n\n    decreases s.len()\n\n    decreases s.len() - i\n\n    requires s.len() >= 1\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_max_moves(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let stack: Seq<char> = seq![];\n        let moves: nat = 0;\n        count_max_moves_helper(s, 0, stack, moves)\n    }\n}\n\nspec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat\n    decreases s.len() - i\n{\n    if i <= s.len() {\n        if i == s.len() {\n            moves\n        } else if stack.len() > 0 && s[i as int] == stack[stack.len() as int - 1] {\n            count_max_moves_helper(s, i + 1, stack.subrange(0, stack.len() as int - 1), moves + 1)\n        } else {\n            count_max_moves_helper(s, i + 1, stack.push(s[i as int]), moves)\n        }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: &'static str)\n    requires s.len() >= 1\n    ensures\n        result == \"Yes\" || result == \"No\",\n        result == \"Yes\" <==> count_max_moves(s@) % 2 == 1,\n        result == \"No\" <==> count_max_moves(s@) % 2 == 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1746_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn has_children(node: int, parents: Seq<int>, n: int) -> bool\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    exists|i: int| 0 <= i < n - 1 && parents[i] - 1 == node\n}\n\nspec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    (Set::new(|i: int| 0 <= i < n - 1 && parents[i] - 1 == node && !has_children(i + 1, parents, n))).len() as int\n}\n\nspec fn valid_input(n: int, parents: Seq<int>) -> bool\n{\n    n >= 3 && parents.len() == n - 1 && \n    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] parents[i] >= 1 && parents[i] <= i + 1)\n}\n\nspec fn is_spruce(n: int, parents: Seq<int>) -> bool\n    recommends valid_input(n, parents)\n{\n    forall|node: int| 0 <= node < n && has_children(node, parents, n) ==> \n        count_leaf_children(node, parents, n) >= 3\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, parents: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, parents@.map_values(|x: i8| x as int)),\n    ensures \n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        result@ == seq!['Y', 'e', 's'] <==> is_spruce(n as int, parents@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn has_children(node: int, parents: Seq<int>, n: int) -> bool\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    exists|i: int| 0 <= i < n - 1 && parents[i] - 1 == node\n}\n\nspec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    (Set::new(|i: int| 0 <= i < n - 1 && parents[i] - 1 == node && !has_children(i + 1, parents, n))).len() as int\n}\n\nspec fn valid_input(n: int, parents: Seq<int>) -> bool\n{\n    n >= 3 && parents.len() == n - 1 && \n    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] parents[i] >= 1 && parents[i] <= i + 1)\n}\n\nspec fn is_spruce(n: int, parents: Seq<int>) -> bool\n    recommends valid_input(n, parents)\n{\n    forall|node: int| 0 <= node < n && has_children(node, parents, n) ==> \n        count_leaf_children(node, parents, n) >= 3\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, parents: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, parents@.map_values(|x: i8| x as int)),\n    ensures \n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        result@ == seq!['Y', 'e', 's'] <==> is_spruce(n as int, parents@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1746.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 705, "minimize_time_ms": 122441, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn has_children(node: int, parents: Seq<int>, n: int) -> bool\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n\nspec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n\nspec fn valid_input(n: int, parents: Seq<int>) -> bool\n{\n\nspec fn is_spruce(n: int, parents: Seq<int>) -> bool\n    recommends valid_input(n, parents)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn has_children(node: int, parents: Seq<int>, n: int) -> bool\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    exists|i: int| 0 <= i < n - 1 && parents[i] - 1 == node\n}\n\nspec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    (Set::new(|i: int| 0 <= i < n - 1 && parents[i] - 1 == node && !has_children(i + 1, parents, n))).len() as int\n}\n\nspec fn valid_input(n: int, parents: Seq<int>) -> bool\n{\n    n >= 3 && parents.len() == n - 1 && \n    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] parents[i] >= 1 && parents[i] <= i + 1)\n}\n\nspec fn is_spruce(n: int, parents: Seq<int>) -> bool\n    recommends valid_input(n, parents)\n{\n    forall|node: int| 0 <= node < n && has_children(node, parents, n) ==> \n        count_leaf_children(node, parents, n) >= 3\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, parents: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, parents@.map_values(|x: i8| x as int)),\n    ensures \n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        result@ == seq!['Y', 'e', 's'] <==> is_spruce(n as int, parents@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1761_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {\n    0  /* placeholder for uninterpreted function */\n}\n\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 2 &&\n    {\n        let n = parse_int_helper(input[0], 0, 0);\n        n >= 1 && n + 1 < input.len()\n    }\n}\n\nspec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>\n    decreases words.len()\n{\n    if words.len() == 0 {\n        seq!['<', '3']\n    } else {\n        seq!['<', '3'] + words[0] + build_expected_pattern(words.subrange(1, words.len() as int))\n    }\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool\n    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()\n{\n    if pattern_index <= pattern.len() && text_index <= text.len() {\n        if pattern_index == pattern.len() {\n            true\n        } else if text_index == text.len() {\n            false\n        } else if pattern[pattern_index as int] == text[text_index as int] {\n            is_subsequence_helper(pattern, text, (pattern_index + 1) as nat, (text_index + 1) as nat)\n        } else {\n            is_subsequence_helper(pattern, text, pattern_index, (text_index + 1) as nat)\n        }\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        input.len() >= 2,\n        valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures \n        result@ == seq!['y', 'e', 's'] || result@ == seq!['n', 'o'],\n        result@ == seq!['y', 'e', 's'] <==> {\n            valid_input(input@.map(|i, v: Vec<char>| v@)) && {\n                let n = parse_int_helper(input@.map(|i, v: Vec<char>| v@)[0], 0, 0);\n                let expected = build_expected_pattern(input@.map(|i, v: Vec<char>| v@).subrange(1, n + 1));\n                let message = input@.map(|i, v: Vec<char>| v@)[n + 1];\n                is_subsequence(expected, message)\n            }\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {\n    0  /* placeholder for uninterpreted function */\n}\n\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 2 &&\n    {\n        let n = parse_int_helper(input[0], 0, 0);\n        n >= 1 && n + 1 < input.len()\n    }\n}\n\nspec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>\n    decreases words.len()\n{\n    if words.len() == 0 {\n        seq!['<', '3']\n    } else {\n        seq!['<', '3'] + words[0] + build_expected_pattern(words.subrange(1, words.len() as int))\n    }\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool\n    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()\n{\n    if pattern_index <= pattern.len() && text_index <= text.len() {\n        if pattern_index == pattern.len() {\n            true\n        } else if text_index == text.len() {\n            false\n        } else if pattern[pattern_index as int] == text[text_index as int] {\n            is_subsequence_helper(pattern, text, (pattern_index + 1) as nat, (text_index + 1) as nat)\n        } else {\n            is_subsequence_helper(pattern, text, pattern_index, (text_index + 1) as nat)\n        }\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        input.len() >= 2,\n        valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures \n        result@ == seq!['y', 'e', 's'] || result@ == seq!['n', 'o'],\n        result@ == seq!['y', 'e', 's'] <==> {\n            valid_input(input@.map(|i, v: Vec<char>| v@)) && {\n                let n = parse_int_helper(input@.map(|i, v: Vec<char>| v@)[0], 0, 0);\n                let expected = build_expected_pattern(input@.map(|i, v: Vec<char>| v@).subrange(1, n + 1));\n                let message = input@.map(|i, v: Vec<char>| v@)[n + 1];\n                is_subsequence(expected, message)\n            }\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1761.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 742, "minimize_time_ms": 122432, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 80, "minimized_LOC": 80, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {\n\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n\nspec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>\n    decreases words.len()\n{\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool\n    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()\n{\n\n    decreases words.len()\n\n    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {\n    0  /* placeholder for uninterpreted function */\n}\n\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 2 &&\n    {\n        let n = parse_int_helper(input[0], 0, 0);\n        n >= 1 && n + 1 < input.len()\n    }\n}\n\nspec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>\n    decreases words.len()\n{\n    if words.len() == 0 {\n        seq!['<', '3']\n    } else {\n        seq!['<', '3'] + words[0] + build_expected_pattern(words.subrange(1, words.len() as int))\n    }\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool\n    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()\n{\n    if pattern_index <= pattern.len() && text_index <= text.len() {\n        if pattern_index == pattern.len() {\n            true\n        } else if text_index == text.len() {\n            false\n        } else if pattern[pattern_index as int] == text[text_index as int] {\n            is_subsequence_helper(pattern, text, (pattern_index + 1) as nat, (text_index + 1) as nat)\n        } else {\n            is_subsequence_helper(pattern, text, pattern_index, (text_index + 1) as nat)\n        }\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        input.len() >= 2,\n        valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures \n        result@ == seq!['y', 'e', 's'] || result@ == seq!['n', 'o'],\n        result@ == seq!['y', 'e', 's'] <==> {\n            valid_input(input@.map(|i, v: Vec<char>| v@)) && {\n                let n = parse_int_helper(input@.map(|i, v: Vec<char>| v@)[0], 0, 0);\n                let expected = build_expected_pattern(input@.map(|i, v: Vec<char>| v@).subrange(1, n + 1));\n                let message = input@.map(|i, v: Vec<char>| v@)[n + 1];\n                is_subsequence(expected, message)\n            }\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1766_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() >= 1 &&\n    (forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0) &&\n    (forall|i: int, j: int| 0 <= i < j < cards.len() ==> cards[i] != cards[j])\n}\n\nspec fn sum(cards: Seq<int>) -> int \n    decreases cards.len()\n{\n    if cards.len() == 0 { \n        0 \n    } else { \n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int\n    decreases right - left + 1\n    when 0 <= left <= right < cards.len()\n{\n    if left == right {\n        if sereja_turn { cards[left] } else { 0 }\n    } else if cards[left] > cards[right] {\n        (if sereja_turn { cards[left] } else { 0 }) + sereja_optimal_score(cards, left+1, right, !sereja_turn)\n    } else {\n        (if sereja_turn { cards[right] } else { 0 }) + sereja_optimal_score(cards, left, right-1, !sereja_turn)\n    }\n}\n\nspec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {\n    valid_input(cards) ==>\n    scores.len() == 2 &&\n    scores[0] >= 0 && scores[1] >= 0 &&\n    scores[0] + scores[1] == sum(cards) &&\n    scores[0] == sereja_optimal_score(cards, 0, cards.len()-1, true) &&\n    scores[1] == sum(cards) - sereja_optimal_score(cards, 0, cards.len()-1, true)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>) -> (scores: Vec<i8>)\n    requires valid_input(cards@.map(|i, x| x as int))\n    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() >= 1 &&\n    (forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0) &&\n    (forall|i: int, j: int| 0 <= i < j < cards.len() ==> cards[i] != cards[j])\n}\n\nspec fn sum(cards: Seq<int>) -> int \n    decreases cards.len()\n{\n    if cards.len() == 0 { \n        0 \n    } else { \n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int\n    decreases right - left + 1\n    when 0 <= left <= right < cards.len()\n{\n    if left == right {\n        if sereja_turn { cards[left] } else { 0 }\n    } else if cards[left] > cards[right] {\n        (if sereja_turn { cards[left] } else { 0 }) + sereja_optimal_score(cards, left+1, right, !sereja_turn)\n    } else {\n        (if sereja_turn { cards[right] } else { 0 }) + sereja_optimal_score(cards, left, right-1, !sereja_turn)\n    }\n}\n\nspec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {\n    valid_input(cards) ==>\n    scores.len() == 2 &&\n    scores[0] >= 0 && scores[1] >= 0 &&\n    scores[0] + scores[1] == sum(cards) &&\n    scores[0] == sereja_optimal_score(cards, 0, cards.len()-1, true) &&\n    scores[1] == sum(cards) - sereja_optimal_score(cards, 0, cards.len()-1, true)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>) -> (scores: Vec<i8>)\n    requires valid_input(cards@.map(|i, x| x as int))\n    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1766.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 686, "minimize_time_ms": 122701, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(cards: Seq<int>) -> bool {\n\nspec fn sum(cards: Seq<int>) -> int \n    decreases cards.len()\n{\n\nspec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int\n    decreases right - left + 1\n    when 0 <= left <= right < cards.len()\n{\n\nspec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {\n\n    decreases cards.len()\n\n    decreases right - left + 1\n\n    requires valid_input(cards@.map(|i, x| x as int))\n\n    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() >= 1 &&\n    (forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0) &&\n    (forall|i: int, j: int| 0 <= i < j < cards.len() ==> cards[i] != cards[j])\n}\n\nspec fn sum(cards: Seq<int>) -> int \n    decreases cards.len()\n{\n    if cards.len() == 0 { \n        0 \n    } else { \n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int\n    decreases right - left + 1\n    when 0 <= left <= right < cards.len()\n{\n    if left == right {\n        if sereja_turn { cards[left] } else { 0 }\n    } else if cards[left] > cards[right] {\n        (if sereja_turn { cards[left] } else { 0 }) + sereja_optimal_score(cards, left+1, right, !sereja_turn)\n    } else {\n        (if sereja_turn { cards[right] } else { 0 }) + sereja_optimal_score(cards, left, right-1, !sereja_turn)\n    }\n}\n\nspec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {\n    valid_input(cards) ==>\n    scores.len() == 2 &&\n    scores[0] >= 0 && scores[1] >= 0 &&\n    scores[0] + scores[1] == sum(cards) &&\n    scores[0] == sereja_optimal_score(cards, 0, cards.len()-1, true) &&\n    scores[1] == sum(cards) - sereja_optimal_score(cards, 0, cards.len()-1, true)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>) -> (scores: Vec<i8>)\n    requires valid_input(cards@.map(|i, x| x as int))\n    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1795_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, f: Seq<int>) -> bool {\n    n >= 2 && n <= 5000 &&\n    f.len() == n &&\n    forall|i: int| 0 <= i < f.len() ==> 1 <= f[i] <= n && f[i] != i + 1\n}\n\nspec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>\n    recommends valid_input(n, f)\n{\n    Seq::new(n as nat, |j: int| f[j] - 1)\n}\n\nspec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool\n    recommends \n        a.len() == n &&\n        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n\n{\n    exists|i: int| 0 <= i < n && \n        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i\n}\n\nspec fn has_love_triangle(n: int, f: Seq<int>) -> bool\n    recommends valid_input(n, f)\n{\n    let a = zero_indexed_array(n, f);\n    has_love_triangle_with(n, a)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, f: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, f@.map(|i: int, x: i8| x as int)),\n    ensures \n        result@.len() == 2 || result@.len() == 3,\n        (result@.len() == 3) <==> has_love_triangle(n as int, f@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, f: Seq<int>) -> bool {\n    n >= 2 && n <= 5000 &&\n    f.len() == n &&\n    forall|i: int| 0 <= i < f.len() ==> 1 <= f[i] <= n && f[i] != i + 1\n}\n\nspec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>\n    recommends valid_input(n, f)\n{\n    Seq::new(n as nat, |j: int| f[j] - 1)\n}\n\nspec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool\n    recommends \n        a.len() == n &&\n        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n\n{\n    exists|i: int| 0 <= i < n && \n        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i\n}\n\nspec fn has_love_triangle(n: int, f: Seq<int>) -> bool\n    recommends valid_input(n, f)\n{\n    let a = zero_indexed_array(n, f);\n    has_love_triangle_with(n, a)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, f: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, f@.map(|i: int, x: i8| x as int)),\n    ensures \n        result@.len() == 2 || result@.len() == 3,\n        (result@.len() == 3) <==> has_love_triangle(n as int, f@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1795.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1009, "minimize_time_ms": 122575, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, f: Seq<int>) -> bool {\n\nspec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>\n    recommends valid_input(n, f)\n{\n\nspec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool\n    recommends \n        a.len() == n &&\n        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n\n{\n\nspec fn has_love_triangle(n: int, f: Seq<int>) -> bool\n    recommends valid_input(n, f)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, f: Seq<int>) -> bool {\n    n >= 2 && n <= 5000 &&\n    f.len() == n &&\n    forall|i: int| 0 <= i < f.len() ==> 1 <= f[i] <= n && f[i] != i + 1\n}\n\nspec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>\n    recommends valid_input(n, f)\n{\n    Seq::new(n as nat, |j: int| f[j] - 1)\n}\n\nspec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool\n    recommends \n        a.len() == n &&\n        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n\n{\n    exists|i: int| 0 <= i < n && \n        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i\n}\n\nspec fn has_love_triangle(n: int, f: Seq<int>) -> bool\n    recommends valid_input(n, f)\n{\n    let a = zero_indexed_array(n, f);\n    has_love_triangle_with(n, a)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, f: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, f@.map(|i: int, x: i8| x as int)),\n    ensures \n        result@.len() == 2 || result@.len() == 3,\n        (result@.len() == 3) <==> has_love_triangle(n as int, f@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1797_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, p: Seq<int>) -> bool {\n  n > 0 && p.len() == n &&\n  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&\n  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn count_true(visited: Seq<bool>) -> int\n  decreases visited.len()\n{\n  if visited.len() == 0 { 0int }\n  else { (if visited[0] { 1int } else { 0int }) + count_true(visited.subrange(1, visited.len() as int)) }\n}\n\nspec fn sum_of_squares(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0int } else { s[0] * s[0] + sum_of_squares(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_unvisited(visited: Seq<bool>) -> int {\n  0int  /* placeholder */\n}\n\nspec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {\n  1int  /* placeholder */\n}\n\nspec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {\n  visited  /* placeholder */\n}\n\nspec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {\n  get_cycles_helper(n, p, Seq::new(n as nat, |i: int| false), Seq::empty())\n}\n\nspec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>\n  decreases n - count_true(visited)\n{\n  if count_true(visited) >= n { cycles }\n  else {\n    let unvisited = find_unvisited(visited);\n    if unvisited == -1int { cycles }\n    else if 0 <= unvisited < n {\n      let cycle_length = get_cycle_length(p, visited, unvisited);\n      let new_visited = mark_cycle_visited(p, visited, unvisited);\n      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n {\n        get_cycles_helper(n, p, new_visited, cycles.push(cycle_length))\n      } else {\n        cycles.push(cycle_length)\n      }\n    } else {\n      cycles\n    }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))\n  ensures result > 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, p: Seq<int>) -> bool {\n  n > 0 && p.len() == n &&\n  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&\n  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn count_true(visited: Seq<bool>) -> int\n  decreases visited.len()\n{\n  if visited.len() == 0 { 0int }\n  else { (if visited[0] { 1int } else { 0int }) + count_true(visited.subrange(1, visited.len() as int)) }\n}\n\nspec fn sum_of_squares(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0int } else { s[0] * s[0] + sum_of_squares(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_unvisited(visited: Seq<bool>) -> int {\n  0int  /* placeholder */\n}\n\nspec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {\n  1int  /* placeholder */\n}\n\nspec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {\n  visited  /* placeholder */\n}\n\nspec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {\n  get_cycles_helper(n, p, Seq::new(n as nat, |i: int| false), Seq::empty())\n}\n\nspec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>\n  decreases n - count_true(visited)\n{\n  if count_true(visited) >= n { cycles }\n  else {\n    let unvisited = find_unvisited(visited);\n    if unvisited == -1int { cycles }\n    else if 0 <= unvisited < n {\n      let cycle_length = get_cycle_length(p, visited, unvisited);\n      let new_visited = mark_cycle_visited(p, visited, unvisited);\n      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n {\n        get_cycles_helper(n, p, new_visited, cycles.push(cycle_length))\n      } else {\n        cycles.push(cycle_length)\n      }\n    } else {\n      cycles\n    }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))\n  ensures result > 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1797.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 912, "minimize_time_ms": 122654, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 81, "minimized_LOC": 81, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, p: Seq<int>) -> bool {\n\nspec fn count_true(visited: Seq<bool>) -> int\n  decreases visited.len()\n{\n\nspec fn sum_of_squares(s: Seq<int>) -> int\n  decreases s.len()\n{\n\nspec fn find_unvisited(visited: Seq<bool>) -> int {\n\nspec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {\n\nspec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {\n\nspec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {\n\nspec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>\n  decreases n - count_true(visited)\n{\n\n  decreases visited.len()\n\n  decreases s.len()\n\n  decreases n - count_true(visited)\n\n  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))\n\n  ensures result > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, p: Seq<int>) -> bool {\n  n > 0 && p.len() == n &&\n  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&\n  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn count_true(visited: Seq<bool>) -> int\n  decreases visited.len()\n{\n  if visited.len() == 0 { 0int }\n  else { (if visited[0] { 1int } else { 0int }) + count_true(visited.subrange(1, visited.len() as int)) }\n}\n\nspec fn sum_of_squares(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0int } else { s[0] * s[0] + sum_of_squares(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_unvisited(visited: Seq<bool>) -> int {\n  0int  /* placeholder */\n}\n\nspec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {\n  1int  /* placeholder */\n}\n\nspec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {\n  visited  /* placeholder */\n}\n\nspec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {\n  get_cycles_helper(n, p, Seq::new(n as nat, |i: int| false), Seq::empty())\n}\n\nspec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>\n  decreases n - count_true(visited)\n{\n  if count_true(visited) >= n { cycles }\n  else {\n    let unvisited = find_unvisited(visited);\n    if unvisited == -1int { cycles }\n    else if 0 <= unvisited < n {\n      let cycle_length = get_cycle_length(p, visited, unvisited);\n      let new_visited = mark_cycle_visited(p, visited, unvisited);\n      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n {\n        get_cycles_helper(n, p, new_visited, cycles.push(cycle_length))\n      } else {\n        cycles.push(cycle_length)\n      }\n    } else {\n      cycles\n    }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))\n  ensures result > 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_181_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn normalize_angle(angle: int) -> int {\n    let n = angle % 360;\n    if n < 0 { n + 360 } else { n }\n}\n\nspec fn deviation_from_vertical(angle: int) -> int\n    recommends 0 <= angle < 360\n{\n    if angle <= 180 { angle } else { 360 - angle }\n}\n\nspec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    normalize_angle(-camera_angle + 90 * rotations)\n}\n\nspec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    deviation_from_vertical(image_angle_after_rotations(camera_angle, rotations))\n}\n\nspec fn is_optimal_rotations(camera_angle: int, result: int) -> bool\n    recommends 0 <= result <= 3\n{\n    forall|k: int| 0 <= k <= 3 ==> #[trigger] image_deviation_after_rotations(camera_angle, k) >= image_deviation_after_rotations(camera_angle, result) && (image_deviation_after_rotations(camera_angle, k) > image_deviation_after_rotations(camera_angle, result) || result <= k)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8) -> (result: u8)\n    ensures \n        0 <= result <= 3,\n        is_optimal_rotations(x as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn normalize_angle(angle: int) -> int {\n    let n = angle % 360;\n    if n < 0 { n + 360 } else { n }\n}\n\nspec fn deviation_from_vertical(angle: int) -> int\n    recommends 0 <= angle < 360\n{\n    if angle <= 180 { angle } else { 360 - angle }\n}\n\nspec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    normalize_angle(-camera_angle + 90 * rotations)\n}\n\nspec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    deviation_from_vertical(image_angle_after_rotations(camera_angle, rotations))\n}\n\nspec fn is_optimal_rotations(camera_angle: int, result: int) -> bool\n    recommends 0 <= result <= 3\n{\n    forall|k: int| 0 <= k <= 3 ==> #[trigger] image_deviation_after_rotations(camera_angle, k) >= image_deviation_after_rotations(camera_angle, result) && (image_deviation_after_rotations(camera_angle, k) > image_deviation_after_rotations(camera_angle, result) || result <= k)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8) -> (result: u8)\n    ensures \n        0 <= result <= 3,\n        is_optimal_rotations(x as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_181.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 633, "minimize_time_ms": 123170, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn normalize_angle(angle: int) -> int {\n\nspec fn deviation_from_vertical(angle: int) -> int\n    recommends 0 <= angle < 360\n{\n\nspec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n\nspec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n\nspec fn is_optimal_rotations(camera_angle: int, result: int) -> bool\n    recommends 0 <= result <= 3\n{\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn normalize_angle(angle: int) -> int {\n    let n = angle % 360;\n    if n < 0 { n + 360 } else { n }\n}\n\nspec fn deviation_from_vertical(angle: int) -> int\n    recommends 0 <= angle < 360\n{\n    if angle <= 180 { angle } else { 360 - angle }\n}\n\nspec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    normalize_angle(-camera_angle + 90 * rotations)\n}\n\nspec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    deviation_from_vertical(image_angle_after_rotations(camera_angle, rotations))\n}\n\nspec fn is_optimal_rotations(camera_angle: int, result: int) -> bool\n    recommends 0 <= result <= 3\n{\n    forall|k: int| 0 <= k <= 3 ==> #[trigger] image_deviation_after_rotations(camera_angle, k) >= image_deviation_after_rotations(camera_angle, result) && (image_deviation_after_rotations(camera_angle, k) > image_deviation_after_rotations(camera_angle, result) || result <= k)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8) -> (result: u8)\n    ensures \n        0 <= result <= 3,\n        is_optimal_rotations(x as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\n fn main() {}\n"]}
{"id": "apps_test_1826_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|pos: int| 0 <= pos < input.len() && input[pos] == '\\n'\n}\n\nspec fn valid_move_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'U' || s[i] == 'R'\n}\n\nspec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {\n    if length <= 1 {\n        0\n    } else {\n        count_replacements_helper(s, start, length, 1, 0)\n    }\n}\n\nspec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int\n    decreases length - i\n{\n    if i >= length {\n        count\n    } else if start + i < s.len() && s[start + i - 1] != s[start + i] {\n        if i + 2 <= length {\n            count_replacements_helper(s, start, length, i + 2, count + 1)\n        } else {\n            count + 1\n        }\n    } else {\n        count_replacements_helper(s, start, length, i + 1, count)\n    }\n}\n\nspec fn minimized_length(original_length: int, replacements: int) -> int {\n    original_length - replacements\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|pos: int| 0 <= pos < input.len() && input[pos] == '\\n'\n}\n\nspec fn valid_move_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'U' || s[i] == 'R'\n}\n\nspec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {\n    if length <= 1 {\n        0\n    } else {\n        count_replacements_helper(s, start, length, 1, 0)\n    }\n}\n\nspec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int\n    decreases length - i\n{\n    if i >= length {\n        count\n    } else if start + i < s.len() && s[start + i - 1] != s[start + i] {\n        if i + 2 <= length {\n            count_replacements_helper(s, start, length, i + 2, count + 1)\n        } else {\n            count + 1\n        }\n    } else {\n        count_replacements_helper(s, start, length, i + 1, count)\n    }\n}\n\nspec fn minimized_length(original_length: int, replacements: int) -> int {\n    original_length - replacements\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1826.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 684, "minimize_time_ms": 92098, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_move_sequence(s: Seq<char>) -> bool {\n\nspec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {\n\nspec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int\n    decreases length - i\n{\n\nspec fn minimized_length(original_length: int, replacements: int) -> int {\n\n    decreases length - i\n\n    requires valid_input(input@)\n\n    ensures result@.len() > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|pos: int| 0 <= pos < input.len() && input[pos] == '\\n'\n}\n\nspec fn valid_move_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'U' || s[i] == 'R'\n}\n\nspec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {\n    if length <= 1 {\n        0\n    } else {\n        count_replacements_helper(s, start, length, 1, 0)\n    }\n}\n\nspec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int\n    decreases length - i\n{\n    if i >= length {\n        count\n    } else if start + i < s.len() && s[start + i - 1] != s[start + i] {\n        if i + 2 <= length {\n            count_replacements_helper(s, start, length, i + 2, count + 1)\n        } else {\n            count + 1\n        }\n    } else {\n        count_replacements_helper(s, start, length, i + 1, count)\n    }\n}\n\nspec fn minimized_length(original_length: int, replacements: int) -> int {\n    original_length - replacements\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1837_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| #![trigger a[i]] 0 <= i < n ==> 0 <= a[i] < n) &&\n    (forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < n ==> a[i] != a[j]) &&\n    (forall|k: int| #![trigger a[k]] 0 <= k < n ==> exists|i: int| 0 <= i < n && a[i] == k)\n}\n\nspec fn current_fixed_points(a: Seq<int>) -> int {\n    a.len() as int\n}\n\nspec fn max_possible_fixed_points(a: Seq<int>) -> int \n    recommends valid_input(a.len() as int, a)\n{\n    let current = current_fixed_points(a);\n    if current == a.len() {\n        a.len() as int\n    } else if exists|i: int| 0 <= i < a.len() && a[i] != i && a[a[i] as int] == i {\n        current + 2\n    } else {\n        current + 1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i, x| x as int)),\n    ensures \n        result as int == max_possible_fixed_points(a@.map(|i, x| x as int)),\n        result >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| #![trigger a[i]] 0 <= i < n ==> 0 <= a[i] < n) &&\n    (forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < n ==> a[i] != a[j]) &&\n    (forall|k: int| #![trigger a[k]] 0 <= k < n ==> exists|i: int| 0 <= i < n && a[i] == k)\n}\n\nspec fn current_fixed_points(a: Seq<int>) -> int {\n    a.len() as int\n}\n\nspec fn max_possible_fixed_points(a: Seq<int>) -> int \n    recommends valid_input(a.len() as int, a)\n{\n    let current = current_fixed_points(a);\n    if current == a.len() {\n        a.len() as int\n    } else if exists|i: int| 0 <= i < a.len() && a[i] != i && a[a[i] as int] == i {\n        current + 2\n    } else {\n        current + 1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i, x| x as int)),\n    ensures \n        result as int == max_possible_fixed_points(a@.map(|i, x| x as int)),\n        result >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1837.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 670, "minimize_time_ms": 122345, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>) -> bool {\n\nspec fn current_fixed_points(a: Seq<int>) -> int {\n\nspec fn max_possible_fixed_points(a: Seq<int>) -> int \n    recommends valid_input(a.len() as int, a)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| #![trigger a[i]] 0 <= i < n ==> 0 <= a[i] < n) &&\n    (forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < n ==> a[i] != a[j]) &&\n    (forall|k: int| #![trigger a[k]] 0 <= k < n ==> exists|i: int| 0 <= i < n && a[i] == k)\n}\n\nspec fn current_fixed_points(a: Seq<int>) -> int {\n    a.len() as int\n}\n\nspec fn max_possible_fixed_points(a: Seq<int>) -> int \n    recommends valid_input(a.len() as int, a)\n{\n    let current = current_fixed_points(a);\n    if current == a.len() {\n        a.len() as int\n    } else if exists|i: int| 0 <= i < a.len() && a[i] != i && a[a[i] as int] == i {\n        current + 2\n    } else {\n        current + 1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i, x| x as int)),\n    ensures \n        result as int == max_possible_fixed_points(a@.map(|i, x| x as int)),\n        result >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1849_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec const MOD: int = 998244353int;\n\nspec fn valid_input(n: int) -> bool\n{\n  n >= 1\n}\n\nspec fn pow(base: int, exp: int, modulus: int) -> int\n  decreases exp\n{\n  if exp <= 0 { 1int }\n  else { (base * pow(base, exp - 1, modulus)) % modulus }\n}\n\nspec fn block_count_formula(n: int, i: int) -> int\n  recommends n >= 1 && 1 <= i <= n\n{\n  if i == n { 10int }\n  else { \n    ((2int * 9int * pow(10int, n - i - 1, MOD) * 10int) + \n     (if i < n - 1 { ((n - 1 - i) * 9int * 9int * pow(10int, n - i - 2, MOD) * 10int) } else { 0int })) % MOD\n  }\n}\n\nspec fn valid_result(result: Seq<int>, n: int) -> bool\n  recommends n >= 1\n{\n  result.len() == n &&\n  (forall|k: int| 0 <= k < n ==> #[trigger] result[k] >= 0 && #[trigger] result[k] < MOD) &&\n  (n >= 1 ==> result[n-1] == 10int) &&\n  (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] == block_count_formula(n, i+1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec const MOD: int = 998244353int;\n\nspec fn valid_input(n: int) -> bool\n{\n  n >= 1\n}\n\nspec fn pow(base: int, exp: int, modulus: int) -> int\n  decreases exp\n{\n  if exp <= 0 { 1int }\n  else { (base * pow(base, exp - 1, modulus)) % modulus }\n}\n\nspec fn block_count_formula(n: int, i: int) -> int\n  recommends n >= 1 && 1 <= i <= n\n{\n  if i == n { 10int }\n  else { \n    ((2int * 9int * pow(10int, n - i - 1, MOD) * 10int) + \n     (if i < n - 1 { ((n - 1 - i) * 9int * 9int * pow(10int, n - i - 2, MOD) * 10int) } else { 0int })) % MOD\n  }\n}\n\nspec fn valid_result(result: Seq<int>, n: int) -> bool\n  recommends n >= 1\n{\n  result.len() == n &&\n  (forall|k: int| 0 <= k < n ==> #[trigger] result[k] >= 0 && #[trigger] result[k] < MOD) &&\n  (n >= 1 ==> result[n-1] == 10int) &&\n  (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] == block_count_formula(n, i+1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1849.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 744, "minimize_time_ms": 123012, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool\n{\n\nspec fn pow(base: int, exp: int, modulus: int) -> int\n  decreases exp\n{\n\nspec fn block_count_formula(n: int, i: int) -> int\n  recommends n >= 1 && 1 <= i <= n\n{\n\nspec fn valid_result(result: Seq<int>, n: int) -> bool\n  recommends n >= 1\n{\n\n  decreases exp\n\n  requires valid_input(n as int)\n\n  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec const MOD: int = 998244353int;\n\nspec fn valid_input(n: int) -> bool\n{\n  n >= 1\n}\n\nspec fn pow(base: int, exp: int, modulus: int) -> int\n  decreases exp\n{\n  if exp <= 0 { 1int }\n  else { (base * pow(base, exp - 1, modulus)) % modulus }\n}\n\nspec fn block_count_formula(n: int, i: int) -> int\n  recommends n >= 1 && 1 <= i <= n\n{\n  if i == n { 10int }\n  else { \n    ((2int * 9int * pow(10int, n - i - 1, MOD) * 10int) + \n     (if i < n - 1 { ((n - 1 - i) * 9int * 9int * pow(10int, n - i - 2, MOD) * 10int) } else { 0int })) % MOD\n  }\n}\n\nspec fn valid_result(result: Seq<int>, n: int) -> bool\n  recommends n >= 1\n{\n  result.len() == n &&\n  (forall|k: int| 0 <= k < n ==> #[trigger] result[k] >= 0 && #[trigger] result[k] < MOD) &&\n  (n >= 1 ==> result[n-1] == 10int) &&\n  (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] == block_count_formula(n, i+1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n                fn main() {\n      }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1850_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {\n        n >= 1 && n <= 200000 &&\n        d >= 1 && d <= n &&\n        current_points.len() == n &&\n        awards.len() == n &&\n        d-1 < current_points.len() &&\n        (forall|i: int| 0 <= i < current_points.len()-1 ==> \n            #[trigger] current_points.index(i) >= current_points.index((i+1) as int)) &&\n        (forall|i: int| 0 <= i < awards.len()-1 ==> \n            #[trigger] awards.index(i) >= awards.index((i+1) as int))\n    }\n    \n    spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int)\n    {\n        count_overtaken_helper(current_points, awards, d, 0, 0)\n    }\n    \n    spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int),\n            0 <= pos <= d-1,\n            0 <= used_awards <= awards.len()\n        decreases d-1-pos\n    {\n        if pos >= d-1 {\n            0\n        } else {\n            let target_score = current_points.index(d-1) + awards.index(0);\n            let remaining_awards = awards.len() - used_awards;\n            if remaining_awards > 0 && used_awards < awards.len() && current_points.index(pos) + awards.index(awards.len()-1-used_awards) <= target_score {\n                1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)\n            } else {\n                count_overtaken_helper(current_points, awards, d, pos+1, used_awards)\n            }\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, current_points: Vec<i8>, awards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, d as int, current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int))\n    ensures \n        1 <= result as int <= d as int,\n        result as int == d as int - count_overtaken(current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int), d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {\n        n >= 1 && n <= 200000 &&\n        d >= 1 && d <= n &&\n        current_points.len() == n &&\n        awards.len() == n &&\n        d-1 < current_points.len() &&\n        (forall|i: int| 0 <= i < current_points.len()-1 ==> \n            #[trigger] current_points.index(i) >= current_points.index((i+1) as int)) &&\n        (forall|i: int| 0 <= i < awards.len()-1 ==> \n            #[trigger] awards.index(i) >= awards.index((i+1) as int))\n    }\n    \n    spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int)\n    {\n        count_overtaken_helper(current_points, awards, d, 0, 0)\n    }\n    \n    spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int),\n            0 <= pos <= d-1,\n            0 <= used_awards <= awards.len()\n        decreases d-1-pos\n    {\n        if pos >= d-1 {\n            0\n        } else {\n            let target_score = current_points.index(d-1) + awards.index(0);\n            let remaining_awards = awards.len() - used_awards;\n            if remaining_awards > 0 && used_awards < awards.len() && current_points.index(pos) + awards.index(awards.len()-1-used_awards) <= target_score {\n                1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)\n            } else {\n                count_overtaken_helper(current_points, awards, d, pos+1, used_awards)\n            }\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, current_points: Vec<i8>, awards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, d as int, current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int))\n    ensures \n        1 <= result as int <= d as int,\n        result as int == d as int - count_overtaken(current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int), d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1850.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 690, "minimize_time_ms": 153652, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 73, "minimized_LOC": 73, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {\n\nspec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int)\n    {\n\nspec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int),\n            0 <= pos <= d-1,\n            0 <= used_awards <= awards.len()\n        decreases d-1-pos\n    {\n\n        decreases d-1-pos\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {\n        n >= 1 && n <= 200000 &&\n        d >= 1 && d <= n &&\n        current_points.len() == n &&\n        awards.len() == n &&\n        d-1 < current_points.len() &&\n        (forall|i: int| 0 <= i < current_points.len()-1 ==> \n            #[trigger] current_points.index(i) >= current_points.index((i+1) as int)) &&\n        (forall|i: int| 0 <= i < awards.len()-1 ==> \n            #[trigger] awards.index(i) >= awards.index((i+1) as int))\n    }\n    \n    spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int)\n    {\n        count_overtaken_helper(current_points, awards, d, 0, 0)\n    }\n    \n    spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int),\n            0 <= pos <= d-1,\n            0 <= used_awards <= awards.len()\n        decreases d-1-pos\n    {\n        if pos >= d-1 {\n            0\n        } else {\n            let target_score = current_points.index(d-1) + awards.index(0);\n            let remaining_awards = awards.len() - used_awards;\n            if remaining_awards > 0 && used_awards < awards.len() && current_points.index(pos) + awards.index(awards.len()-1-used_awards) <= target_score {\n                1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)\n            } else {\n                count_overtaken_helper(current_points, awards, d, pos+1, used_awards)\n            }\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, current_points: Vec<i8>, awards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, d as int, current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int))\n    ensures \n        1 <= result as int <= d as int,\n        result as int == d as int - count_overtaken(current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int), d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1877_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n >= 0 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> (s[i] == 'U' || s[i] == 'R')\n}\n\nspec fn count_kingdom_transitions(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else { count_transitions_helper(s, 0, 0, 0, -1) }\n}\n\nspec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() { 0 }\n    else {\n        let new_x = if s[pos] == 'U' { x } else { x + 1 };\n        let new_y = if s[pos] == 'U' { y + 1 } else { y };\n\n        if new_x == new_y {\n            count_transitions_helper(s, pos + 1, new_x, new_y, pred)\n        } else {\n            let cur = if new_x > new_y { 0 } else { 1 };\n            let transition: int = if cur != pred && pred != -1 { 1 } else { 0 };\n            transition + count_transitions_helper(s, pos + 1, new_x, new_y, cur)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(n as int, s@),\n        n >= 0\n    ensures \n        result >= 0 &&\n        result <= n &&\n        (n == 0 ==> result == 0) &&\n        result as int == count_kingdom_transitions(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n >= 0 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> (s[i] == 'U' || s[i] == 'R')\n}\n\nspec fn count_kingdom_transitions(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else { count_transitions_helper(s, 0, 0, 0, -1) }\n}\n\nspec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() { 0 }\n    else {\n        let new_x = if s[pos] == 'U' { x } else { x + 1 };\n        let new_y = if s[pos] == 'U' { y + 1 } else { y };\n\n        if new_x == new_y {\n            count_transitions_helper(s, pos + 1, new_x, new_y, pred)\n        } else {\n            let cur = if new_x > new_y { 0 } else { 1 };\n            let transition: int = if cur != pred && pred != -1 { 1 } else { 0 };\n            transition + count_transitions_helper(s, pos + 1, new_x, new_y, cur)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(n as int, s@),\n        n >= 0\n    ensures \n        result >= 0 &&\n        result <= n &&\n        (n == 0 ==> result == 0) &&\n        result as int == count_kingdom_transitions(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1877.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 768, "minimize_time_ms": 122382, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, s: Seq<char>) -> bool {\n\nspec fn count_kingdom_transitions(s: Seq<char>) -> int {\n\nspec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n\n    decreases s.len() - pos when 0 <= pos <= s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n >= 0 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> (s[i] == 'U' || s[i] == 'R')\n}\n\nspec fn count_kingdom_transitions(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else { count_transitions_helper(s, 0, 0, 0, -1) }\n}\n\nspec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() { 0 }\n    else {\n        let new_x = if s[pos] == 'U' { x } else { x + 1 };\n        let new_y = if s[pos] == 'U' { y + 1 } else { y };\n\n        if new_x == new_y {\n            count_transitions_helper(s, pos + 1, new_x, new_y, pred)\n        } else {\n            let cur = if new_x > new_y { 0 } else { 1 };\n            let transition: int = if cur != pred && pred != -1 { 1 } else { 0 };\n            transition + count_transitions_helper(s, pos + 1, new_x, new_y, cur)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(n as int, s@),\n        n >= 0\n    ensures \n        result >= 0 &&\n        result <= n &&\n        (n == 0 ==> result == 0) &&\n        result as int == count_kingdom_transitions(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1878_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        }\n    } else if s[pos] == '\\n' {\n        let new_acc = if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        };\n        split_lines_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        parse_int_pos_func(s)\n    }\n}\n\nspec fn parse_int_pos_func(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if '0' <= s[0] && s[0] <= '9' {\n        (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn parse_ints_func(s: Seq<char>) -> Seq<int> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        parse_ints_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        }\n    } else if s[pos] == ' ' {\n        let new_acc = if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        };\n        parse_ints_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        parse_ints_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'] + int_to_string_pos(-n)\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char]\n    }\n}\n\nspec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int\n    decreases rectangle_lines.len()\n{\n    if rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))\n    }\n}\n\nspec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 || rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@),\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|total_area: int| {\n            &&& total_area >= 0\n            &&& result@ == int_to_string_func(total_area) + seq!['\\n']\n            &&& {\n                let processed_input = if input@.len() > 0 && input@[input@.len() - 1] == '\\n' {\n                    input@\n                } else {\n                    input@ + seq!['\\n']\n                };\n                let lines = split_lines_func(processed_input);\n                if lines.len() == 0 {\n                    total_area == 0\n                } else {\n                    let n = parse_int_func(lines[0]);\n                    if n >= 0 && n + 1 <= lines.len() {\n                        total_area == compute_total_area(lines.subrange(1, n + 1))\n                    } else {\n                        total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)\n                    }\n                }\n            }\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        }\n    } else if s[pos] == '\\n' {\n        let new_acc = if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        };\n        split_lines_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        parse_int_pos_func(s)\n    }\n}\n\nspec fn parse_int_pos_func(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if '0' <= s[0] && s[0] <= '9' {\n        (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn parse_ints_func(s: Seq<char>) -> Seq<int> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        parse_ints_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        }\n    } else if s[pos] == ' ' {\n        let new_acc = if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        };\n        parse_ints_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        parse_ints_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'] + int_to_string_pos(-n)\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char]\n    }\n}\n\nspec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int\n    decreases rectangle_lines.len()\n{\n    if rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))\n    }\n}\n\nspec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 || rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@),\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|total_area: int| {\n            &&& total_area >= 0\n            &&& result@ == int_to_string_func(total_area) + seq!['\\n']\n            &&& {\n                let processed_input = if input@.len() > 0 && input@[input@.len() - 1] == '\\n' {\n                    input@\n                } else {\n                    input@ + seq!['\\n']\n                };\n                let lines = split_lines_func(processed_input);\n                if lines.len() == 0 {\n                    total_area == 0\n                } else {\n                    let n = parse_int_func(lines[0]);\n                    if n >= 0 && n + 1 <= lines.len() {\n                        total_area == compute_total_area(lines.subrange(1, n + 1))\n                    } else {\n                        total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)\n                    }\n                }\n            }\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1878.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 788, "minimize_time_ms": 92118, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 188, "minimized_LOC": 188, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 23, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\nspec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n\nspec fn parse_int_pos_func(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn parse_ints_func(s: Seq<char>) -> Seq<int> {\n\nspec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n\nspec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int\n    decreases rectangle_lines.len()\n{\n\nspec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int\n    decreases n when n >= 0\n{\n\n    decreases s.len()\n\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n\n    decreases s.len()\n\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n\n    decreases n when n > 0\n\n    decreases rectangle_lines.len()\n\n    decreases n when n >= 0\n\n    requires valid_input(input@),\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        }\n    } else if s[pos] == '\\n' {\n        let new_acc = if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        };\n        split_lines_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        parse_int_pos_func(s)\n    }\n}\n\nspec fn parse_int_pos_func(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if '0' <= s[0] && s[0] <= '9' {\n        (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn parse_ints_func(s: Seq<char>) -> Seq<int> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        parse_ints_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        }\n    } else if s[pos] == ' ' {\n        let new_acc = if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        };\n        parse_ints_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        parse_ints_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'] + int_to_string_pos(-n)\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char]\n    }\n}\n\nspec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int\n    decreases rectangle_lines.len()\n{\n    if rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))\n    }\n}\n\nspec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 || rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@),\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|total_area: int| {\n            &&& total_area >= 0\n            &&& result@ == int_to_string_func(total_area) + seq!['\\n']\n            &&& {\n                let processed_input = if input@.len() > 0 && input@[input@.len() - 1] == '\\n' {\n                    input@\n                } else {\n                    input@ + seq!['\\n']\n                };\n                let lines = split_lines_func(processed_input);\n                if lines.len() == 0 {\n                    total_area == 0\n                } else {\n                    let n = parse_int_func(lines[0]);\n                    if n >= 0 && n + 1 <= lines.len() {\n                        total_area == compute_total_area(lines.subrange(1, n + 1))\n                    } else {\n                        total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)\n                    }\n                }\n            }\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1887_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {\n    n >= 1 && h1.len() >= n && h2.len() >= n &&\n    (forall|i: int| 0 <= i < n ==> h1[i] >= 0) &&\n    (forall|i: int| 0 <= i < n ==> h2[i] >= 0)\n}\n\nspec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n{\n    let dp1 = max_height_ending_in_row1(n, h1, h2);\n    let dp2 = max_height_ending_in_row2(n, h1, h2);\n    if dp1 > dp2 { dp1 } else { dp2 }\n}\n\nspec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row1_decreases\n{\n    if n == 1 { h1[0] }\n    else {\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let take_from_row2 = prev_row2 + h1[n-1];\n        if take_from_row2 > prev_row1 { take_from_row2 } else { prev_row1 }\n    }\n}\n\nspec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row2_decreases\n{\n    if n == 1 { h2[0] }\n    else {\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let take_from_row1 = prev_row1 + h2[n-1];\n        if take_from_row1 > prev_row2 { take_from_row1 } else { prev_row2 }\n    }\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, h1: Vec<i8>, h2: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n    ensures \n        result >= 0,\n        result as int == max_team_height(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {\n    n >= 1 && h1.len() >= n && h2.len() >= n &&\n    (forall|i: int| 0 <= i < n ==> h1[i] >= 0) &&\n    (forall|i: int| 0 <= i < n ==> h2[i] >= 0)\n}\n\nspec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n{\n    let dp1 = max_height_ending_in_row1(n, h1, h2);\n    let dp2 = max_height_ending_in_row2(n, h1, h2);\n    if dp1 > dp2 { dp1 } else { dp2 }\n}\n\nspec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row1_decreases\n{\n    if n == 1 { h1[0] }\n    else {\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let take_from_row2 = prev_row2 + h1[n-1];\n        if take_from_row2 > prev_row1 { take_from_row2 } else { prev_row1 }\n    }\n}\n\nspec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row2_decreases\n{\n    if n == 1 { h2[0] }\n    else {\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let take_from_row1 = prev_row1 + h2[n-1];\n        if take_from_row1 > prev_row2 { take_from_row1 } else { prev_row2 }\n    }\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, h1: Vec<i8>, h2: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n    ensures \n        result >= 0,\n        result as int == max_team_height(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1887.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1325, "minimize_time_ms": 184431, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 78, "minimized_LOC": 78, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {\n\nspec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n{\n\nspec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row1_decreases\n{\n\nspec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row2_decreases\n{\n\n    decreases n via max_height_ending_in_row1_decreases\n\n    decreases n via max_height_ending_in_row2_decreases\n\n    requires \n\n    ensures ", "proof": "proof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n\nproof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {\n    n >= 1 && h1.len() >= n && h2.len() >= n &&\n    (forall|i: int| 0 <= i < n ==> h1[i] >= 0) &&\n    (forall|i: int| 0 <= i < n ==> h2[i] >= 0)\n}\n\nspec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n{\n    let dp1 = max_height_ending_in_row1(n, h1, h2);\n    let dp2 = max_height_ending_in_row2(n, h1, h2);\n    if dp1 > dp2 { dp1 } else { dp2 }\n}\n\nspec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row1_decreases\n{\n    if n == 1 { h1[0] }\n    else {\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let take_from_row2 = prev_row2 + h1[n-1];\n        if take_from_row2 > prev_row1 { take_from_row2 } else { prev_row1 }\n    }\n}\n\nspec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row2_decreases\n{\n    if n == 1 { h2[0] }\n    else {\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let take_from_row1 = prev_row1 + h2[n-1];\n        if take_from_row1 > prev_row2 { take_from_row1 } else { prev_row2 }\n    }\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, h1: Vec<i8>, h2: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n    ensures \n        result >= 0,\n        result as int == max_team_height(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1889_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {\n    grid.len() == n && n > 0 && m > 0 &&\n    (forall|i: int| 0 <= i < n ==> grid[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {\n    queries.len() == q && q >= 0 &&\n    (forall|k: int| 0 <= k < q ==> #[trigger] queries[k].0 >= 1 && queries[k].0 <= n && queries[k].1 >= 1 && queries[k].1 <= m)\n}\n\nspec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int\n    decreases l.len() - index\n{\n    if index >= l.len() {\n        max_so_far\n    } else if l[index] == 1 {\n        let new_current = current + 1;\n        let new_max = if new_current > max_so_far { new_current } else { max_so_far };\n        cons_helper(l, index + 1, new_current, new_max)\n    } else {\n        cons_helper(l, index + 1, 0, max_so_far)\n    }\n}\n\nspec fn cons(l: Seq<int>) -> int {\n    cons_helper(l, 0, 0, 0)\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let rest = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] > rest { s[0] } else { rest }\n    }\n}\n\nspec fn compute_score(grid: Seq<Seq<int>>) -> int {\n    if grid.len() == 0 {\n        0\n    } else {\n        let row_scores = Seq::new(grid.len(), |i: int| cons(grid[i]));\n        max_in_seq(row_scores)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, q: i8, grid: Vec<Vec<i8>>, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires \n        valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), n as int, m as int),\n        valid_queries(queries@.map(|k: int, query: (i8, i8)| (query.0 as int, query.1 as int)), q as int, n as int, m as int),\n    ensures \n        results.len() == q,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {\n    grid.len() == n && n > 0 && m > 0 &&\n    (forall|i: int| 0 <= i < n ==> grid[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {\n    queries.len() == q && q >= 0 &&\n    (forall|k: int| 0 <= k < q ==> #[trigger] queries[k].0 >= 1 && queries[k].0 <= n && queries[k].1 >= 1 && queries[k].1 <= m)\n}\n\nspec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int\n    decreases l.len() - index\n{\n    if index >= l.len() {\n        max_so_far\n    } else if l[index] == 1 {\n        let new_current = current + 1;\n        let new_max = if new_current > max_so_far { new_current } else { max_so_far };\n        cons_helper(l, index + 1, new_current, new_max)\n    } else {\n        cons_helper(l, index + 1, 0, max_so_far)\n    }\n}\n\nspec fn cons(l: Seq<int>) -> int {\n    cons_helper(l, 0, 0, 0)\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let rest = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] > rest { s[0] } else { rest }\n    }\n}\n\nspec fn compute_score(grid: Seq<Seq<int>>) -> int {\n    if grid.len() == 0 {\n        0\n    } else {\n        let row_scores = Seq::new(grid.len(), |i: int| cons(grid[i]));\n        max_in_seq(row_scores)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, q: i8, grid: Vec<Vec<i8>>, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires \n        valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), n as int, m as int),\n        valid_queries(queries@.map(|k: int, query: (i8, i8)| (query.0 as int, query.1 as int)), q as int, n as int, m as int),\n    ensures \n        results.len() == q,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1889.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 818, "minimize_time_ms": 154470, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 80, "minimized_LOC": 80, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {\n\nspec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {\n\nspec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int\n    decreases l.len() - index\n{\n\nspec fn cons(l: Seq<int>) -> int {\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn compute_score(grid: Seq<Seq<int>>) -> int {\n\n    decreases l.len() - index\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {\n    grid.len() == n && n > 0 && m > 0 &&\n    (forall|i: int| 0 <= i < n ==> grid[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {\n    queries.len() == q && q >= 0 &&\n    (forall|k: int| 0 <= k < q ==> #[trigger] queries[k].0 >= 1 && queries[k].0 <= n && queries[k].1 >= 1 && queries[k].1 <= m)\n}\n\nspec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int\n    decreases l.len() - index\n{\n    if index >= l.len() {\n        max_so_far\n    } else if l[index] == 1 {\n        let new_current = current + 1;\n        let new_max = if new_current > max_so_far { new_current } else { max_so_far };\n        cons_helper(l, index + 1, new_current, new_max)\n    } else {\n        cons_helper(l, index + 1, 0, max_so_far)\n    }\n}\n\nspec fn cons(l: Seq<int>) -> int {\n    cons_helper(l, 0, 0, 0)\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let rest = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] > rest { s[0] } else { rest }\n    }\n}\n\nspec fn compute_score(grid: Seq<Seq<int>>) -> int {\n    if grid.len() == 0 {\n        0\n    } else {\n        let row_scores = Seq::new(grid.len(), |i: int| cons(grid[i]));\n        max_in_seq(row_scores)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, q: i8, grid: Vec<Vec<i8>>, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires \n        valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), n as int, m as int),\n        valid_queries(queries@.map(|k: int, query: (i8, i8)| (query.0 as int, query.1 as int)), q as int, n as int, m as int),\n    ensures \n        results.len() == q,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n           fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_189_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, sticks: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    sticks.len() == n &&\n    (forall|i: int| 0 <= i < sticks.len() ==> #[trigger] sticks[i] >= 1 && #[trigger] sticks[i] <= 100)\n}\n\nspec fn cost_for_t(sticks: Seq<int>, t: int) -> int {\n    sum_costs(sticks, t, 0)\n}\n\nspec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int\n    decreases sticks.len() - index when 0 <= index <= sticks.len()\n{\n    if index < 0 || index >= sticks.len() {\n        0\n    } else if index == sticks.len() {\n        0\n    } else {\n        max_int(0, abs_int(t - sticks[index as int]) - 1) + sum_costs(sticks, t, index + 1)\n    }\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn max_int(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n    forall|other_t: int| 1 <= other_t <= 99 ==> \n        #[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))\n    requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))\n    ensures ({\n        let (t, min_cost) = result;\n        1 <= t as int <= 99 &&\n        min_cost as int >= 0 &&\n        min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&\n        is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(n: int, sticks: Seq<int>) -> bool ;\n       spec fn cost_for_t(sticks: Seq<int>, t: int) -> int ;\n       spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int     decreases sticks.len() - index when 0 <= index <= sticks.len() ;\n       spec fn abs_int(x: int) -> int ;\n       spec fn max_int(a: int, b: int) -> int ;\n       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n          forall|other_t: int| 1 <= other_t <= 99 ==>                 \n#[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)\n}\n       fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))     requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))     ensures ({\n              let (t, min_cost) = result;\n              1 <= t as int <= 99 &&         min_cost as int >= 0 &&         min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&         is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)     }\n      ) {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_189.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 699, "minimize_time_ms": 155920, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 66, "minimized_LOC": 20, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 0.30303030303030304}, "labeling": {"ensures_count": 1, "segments": {"exec": " fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))     requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))     ensures ({\n\n fn main() {", "spec": "spec fn valid_input(n: int, sticks: Seq<int>) -> bool ;\n       spec fn cost_for_t(sticks: Seq<int>, t: int) -> int ;\n       spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int     decreases sticks.len() - index when 0 <= index <= sticks.len() ;\n       spec fn abs_int(x: int) -> int ;\n       spec fn max_int(a: int, b: int) -> int ;\n       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n\nspec fn cost_for_t(sticks: Seq<int>, t: int) -> int ;\n       spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int     decreases sticks.len() - index when 0 <= index <= sticks.len() ;\n       spec fn abs_int(x: int) -> int ;\n       spec fn max_int(a: int, b: int) -> int ;\n       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n\nspec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int     decreases sticks.len() - index when 0 <= index <= sticks.len() ;\n       spec fn abs_int(x: int) -> int ;\n       spec fn max_int(a: int, b: int) -> int ;\n       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n\nspec fn abs_int(x: int) -> int ;\n       spec fn max_int(a: int, b: int) -> int ;\n       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n\nspec fn max_int(a: int, b: int) -> int ;\n       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n\nspec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n\n       spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int     decreases sticks.len() - index when 0 <= index <= sticks.len() ;\n\n       fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))     requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))     ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, sticks: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    sticks.len() == n &&\n    (forall|i: int| 0 <= i < sticks.len() ==> #[trigger] sticks[i] >= 1 && #[trigger] sticks[i] <= 100)\n}\n\nspec fn cost_for_t(sticks: Seq<int>, t: int) -> int {\n    sum_costs(sticks, t, 0)\n}\n\nspec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int\n    decreases sticks.len() - index when 0 <= index <= sticks.len()\n{\n    if index < 0 || index >= sticks.len() {\n        0\n    } else if index == sticks.len() {\n        0\n    } else {\n        max_int(0, abs_int(t - sticks[index as int]) - 1) + sum_costs(sticks, t, index + 1)\n    }\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn max_int(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n    forall|other_t: int| 1 <= other_t <= 99 ==> \n        #[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))\n    requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))\n    ensures ({\n        let (t, min_cost) = result;\n        1 <= t as int <= 99 &&\n        min_cost as int >= 0 &&\n        min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&\n        is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(n: int, sticks: Seq<int>) -> bool ;\n       spec fn cost_for_t(sticks: Seq<int>, t: int) -> int ;\n       spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int     decreases sticks.len() - index when 0 <= index <= sticks.len() ;\n       spec fn abs_int(x: int) -> int ;\n       spec fn max_int(a: int, b: int) -> int ;\n       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n          forall|other_t: int| 1 <= other_t <= 99 ==>                 \n#[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)\n}\n       fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))     requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))     ensures ({\n              let (t, min_cost) = result;\n              1 <= t as int <= 99 &&         min_cost as int >= 0 &&         min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&         is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)     }\n      ) {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n              fn main() {\n    }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1925_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    parse_three_ints_func(input).1 > 0\n}\n\nspec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) \n    recommends s.len() > 0\n{\n    let nums = parse_numbers(s, 0, seq![], 0, false);\n    if nums.len() >= 3 { \n        (nums[0], if nums[1] > 0 { nums[1] } else { 1 }, nums[2])\n    } else { \n        (0, 1, 0) \n    }\n}\n\nspec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if in_number && nums.len() < 3 { nums.push(current) } else { nums }\n    } else if nums.len() >= 3 {\n        nums\n    } else {\n        let c = s[i];\n        if c >= '0' && c <= '9' {\n            let digit = c as int - '0' as int;\n            if !in_number {\n                parse_numbers(s, i + 1, nums, digit, true)\n            } else {\n                parse_numbers(s, i + 1, nums, current * 10 + digit, true)\n            }\n        } else if in_number {\n            parse_numbers(s, i + 1, nums.push(current), 0, false)\n        } else {\n            parse_numbers(s, i + 1, nums, current, false)\n        }\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'].add(int_to_string_helper_func(-n)) }\n    else { int_to_string_helper_func(n) }\n}\n\nspec fn int_to_string_helper_func(n: int) -> Seq<char> \n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_helper_func(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn compute_max_value(a: int, b: int, n: int) -> int \n    recommends b > 0\n{\n    let min_val = if b - 1 < n { b - 1 } else { n };\n    (a * min_val) / b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures ({\n        let parts = parse_three_ints_func(input@);\n        let a = parts.0;\n        let b = parts.1;  \n        let n = parts.2;\n        b > 0 &&\n        result@ == int_to_string_func(compute_max_value(a, b, n)).add(seq!['\\n'])\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    parse_three_ints_func(input).1 > 0\n}\n\nspec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) \n    recommends s.len() > 0\n{\n    let nums = parse_numbers(s, 0, seq![], 0, false);\n    if nums.len() >= 3 { \n        (nums[0], if nums[1] > 0 { nums[1] } else { 1 }, nums[2])\n    } else { \n        (0, 1, 0) \n    }\n}\n\nspec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if in_number && nums.len() < 3 { nums.push(current) } else { nums }\n    } else if nums.len() >= 3 {\n        nums\n    } else {\n        let c = s[i];\n        if c >= '0' && c <= '9' {\n            let digit = c as int - '0' as int;\n            if !in_number {\n                parse_numbers(s, i + 1, nums, digit, true)\n            } else {\n                parse_numbers(s, i + 1, nums, current * 10 + digit, true)\n            }\n        } else if in_number {\n            parse_numbers(s, i + 1, nums.push(current), 0, false)\n        } else {\n            parse_numbers(s, i + 1, nums, current, false)\n        }\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'].add(int_to_string_helper_func(-n)) }\n    else { int_to_string_helper_func(n) }\n}\n\nspec fn int_to_string_helper_func(n: int) -> Seq<char> \n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_helper_func(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn compute_max_value(a: int, b: int, n: int) -> int \n    recommends b > 0\n{\n    let min_val = if b - 1 < n { b - 1 } else { n };\n    (a * min_val) / b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures ({\n        let parts = parse_three_ints_func(input@);\n        let a = parts.0;\n        let b = parts.1;  \n        let n = parts.2;\n        b > 0 &&\n        result@ == int_to_string_func(compute_max_value(a, b, n)).add(seq!['\\n'])\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1925.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 733, "minimize_time_ms": 123064, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 100, "minimized_LOC": 100, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) \n    recommends s.len() > 0\n{\n\nspec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n\nspec fn int_to_string_helper_func(n: int) -> Seq<char> \n    recommends n > 0\n    decreases n\n{\n\nspec fn compute_max_value(a: int, b: int, n: int) -> int \n    recommends b > 0\n{\n\n    decreases s.len() - i\n\n    decreases n\n\n    requires \n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    parse_three_ints_func(input).1 > 0\n}\n\nspec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) \n    recommends s.len() > 0\n{\n    let nums = parse_numbers(s, 0, seq![], 0, false);\n    if nums.len() >= 3 { \n        (nums[0], if nums[1] > 0 { nums[1] } else { 1 }, nums[2])\n    } else { \n        (0, 1, 0) \n    }\n}\n\nspec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if in_number && nums.len() < 3 { nums.push(current) } else { nums }\n    } else if nums.len() >= 3 {\n        nums\n    } else {\n        let c = s[i];\n        if c >= '0' && c <= '9' {\n            let digit = c as int - '0' as int;\n            if !in_number {\n                parse_numbers(s, i + 1, nums, digit, true)\n            } else {\n                parse_numbers(s, i + 1, nums, current * 10 + digit, true)\n            }\n        } else if in_number {\n            parse_numbers(s, i + 1, nums.push(current), 0, false)\n        } else {\n            parse_numbers(s, i + 1, nums, current, false)\n        }\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'].add(int_to_string_helper_func(-n)) }\n    else { int_to_string_helper_func(n) }\n}\n\nspec fn int_to_string_helper_func(n: int) -> Seq<char> \n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_helper_func(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn compute_max_value(a: int, b: int, n: int) -> int \n    recommends b > 0\n{\n    let min_val = if b - 1 < n { b - 1 } else { n };\n    (a * min_val) / b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures ({\n        let parts = parse_three_ints_func(input@);\n        let a = parts.0;\n        let b = parts.1;  \n        let n = parts.2;\n        b > 0 &&\n        result@ == int_to_string_func(compute_max_value(a, b, n)).add(seq!['\\n'])\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_194_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && groups.len() == n &&\n    forall|i: int| 0 <= i < groups.len() ==> groups[i] == 1 || groups[i] == 2\n}\n\nspec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {\n    count_denied_people_with_half(groups, a, b, 0)\n}\n\nspec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int\n    decreases groups.len()\n{\n    if groups.len() == 0 {\n        0\n    } else {\n        let group = groups[0];\n        let rest = groups.subrange(1, groups.len() as int);\n        if group == 2 {\n            if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied)\n            } else {\n                2 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        } else {\n            if a > 0 {\n                count_denied_people_with_half(rest, a - 1, b, half_occupied)\n            } else if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied + 1)\n            } else if half_occupied > 0 {\n                count_denied_people_with_half(rest, a, b, half_occupied - 1)\n            } else {\n                1 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, groups: Vec<i8>) -> (denied: i8)\n    requires \n        valid_input(n as int, a as int, b as int, groups@.map_values(|x: i8| x as int))\n    ensures \n        denied >= 0,\n        denied as int == count_denied_people(groups@.map_values(|x: i8| x as int), a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && groups.len() == n &&\n    forall|i: int| 0 <= i < groups.len() ==> groups[i] == 1 || groups[i] == 2\n}\n\nspec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {\n    count_denied_people_with_half(groups, a, b, 0)\n}\n\nspec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int\n    decreases groups.len()\n{\n    if groups.len() == 0 {\n        0\n    } else {\n        let group = groups[0];\n        let rest = groups.subrange(1, groups.len() as int);\n        if group == 2 {\n            if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied)\n            } else {\n                2 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        } else {\n            if a > 0 {\n                count_denied_people_with_half(rest, a - 1, b, half_occupied)\n            } else if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied + 1)\n            } else if half_occupied > 0 {\n                count_denied_people_with_half(rest, a, b, half_occupied - 1)\n            } else {\n                1 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, groups: Vec<i8>) -> (denied: i8)\n    requires \n        valid_input(n as int, a as int, b as int, groups@.map_values(|x: i8| x as int))\n    ensures \n        denied >= 0,\n        denied as int == count_denied_people(groups@.map_values(|x: i8| x as int), a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_194.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 729, "minimize_time_ms": 122786, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {\n\nspec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {\n\nspec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int\n    decreases groups.len()\n{\n\n    decreases groups.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && groups.len() == n &&\n    forall|i: int| 0 <= i < groups.len() ==> groups[i] == 1 || groups[i] == 2\n}\n\nspec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {\n    count_denied_people_with_half(groups, a, b, 0)\n}\n\nspec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int\n    decreases groups.len()\n{\n    if groups.len() == 0 {\n        0\n    } else {\n        let group = groups[0];\n        let rest = groups.subrange(1, groups.len() as int);\n        if group == 2 {\n            if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied)\n            } else {\n                2 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        } else {\n            if a > 0 {\n                count_denied_people_with_half(rest, a - 1, b, half_occupied)\n            } else if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied + 1)\n            } else if half_occupied > 0 {\n                count_denied_people_with_half(rest, a, b, half_occupied - 1)\n            } else {\n                1 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, groups: Vec<i8>) -> (denied: i8)\n    requires \n        valid_input(n as int, a as int, b as int, groups@.map_values(|x: i8| x as int))\n    ensures \n        denied >= 0,\n        denied as int == count_denied_people(groups@.map_values(|x: i8| x as int), a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1958_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {\n    1 <= n <= 40 &&\n    2 <= p <= 1000 &&\n    p % 2 == 0 &&\n    buyers.len() == n &&\n    forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n}\n\nspec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n{\n    compute_payment_backward(buyers, p, buyers.len() - 1, 0)\n}\n\nspec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                -1 <= current_index < buyers.len(),\n                current_apples >= 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n    decreases current_index + 1\n{\n    if current_index < 0 {\n        0\n    } else {\n        let new_apples = if buyers[current_index] == \"halfplus\" { \n                            current_apples * 2 + 1\n                         } else { \n                            current_apples * 2\n                         };\n        let payment = if buyers[current_index] == \"halfplus\" { \n                          (new_apples / 2) * p\n                       } else { \n                          current_apples * p\n                       };\n        payment + compute_payment_backward(buyers, p, current_index - 1, new_apples)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, buyers: Vec<&str>) -> (result: i8)\n    requires valid_input(n as int, p as int, buyers@)\n    ensures result >= 0,\n            result as int == compute_total_payment(buyers@, p as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {\n    1 <= n <= 40 &&\n    2 <= p <= 1000 &&\n    p % 2 == 0 &&\n    buyers.len() == n &&\n    forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n}\n\nspec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n{\n    compute_payment_backward(buyers, p, buyers.len() - 1, 0)\n}\n\nspec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                -1 <= current_index < buyers.len(),\n                current_apples >= 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n    decreases current_index + 1\n{\n    if current_index < 0 {\n        0\n    } else {\n        let new_apples = if buyers[current_index] == \"halfplus\" { \n                            current_apples * 2 + 1\n                         } else { \n                            current_apples * 2\n                         };\n        let payment = if buyers[current_index] == \"halfplus\" { \n                          (new_apples / 2) * p\n                       } else { \n                          current_apples * p\n                       };\n        payment + compute_payment_backward(buyers, p, current_index - 1, new_apples)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, buyers: Vec<&str>) -> (result: i8)\n    requires valid_input(n as int, p as int, buyers@)\n    ensures result >= 0,\n            result as int == compute_total_payment(buyers@, p as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1958.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 655, "minimize_time_ms": 122495, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {\n\nspec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n{\n\nspec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                -1 <= current_index < buyers.len(),\n                current_apples >= 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n    decreases current_index + 1\n{\n\n    decreases current_index + 1\n\n    requires valid_input(n as int, p as int, buyers@)\n\n    ensures result >= 0,"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {\n    1 <= n <= 40 &&\n    2 <= p <= 1000 &&\n    p % 2 == 0 &&\n    buyers.len() == n &&\n    forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n}\n\nspec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n{\n    compute_payment_backward(buyers, p, buyers.len() - 1, 0)\n}\n\nspec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                -1 <= current_index < buyers.len(),\n                current_apples >= 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n    decreases current_index + 1\n{\n    if current_index < 0 {\n        0\n    } else {\n        let new_apples = if buyers[current_index] == \"halfplus\" { \n                            current_apples * 2 + 1\n                         } else { \n                            current_apples * 2\n                         };\n        let payment = if buyers[current_index] == \"halfplus\" { \n                          (new_apples / 2) * p\n                       } else { \n                          current_apples * p\n                       };\n        payment + compute_payment_backward(buyers, p, current_index - 1, new_apples)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, buyers: Vec<&str>) -> (result: i8)\n    requires valid_input(n as int, p as int, buyers@)\n    ensures result >= 0,\n            result as int == compute_total_payment(buyers@, p as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1965_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == x {\n        1 + count_occurrences(s.drop_first(), x)\n    } else {\n        count_occurrences(s.drop_first(), x)\n    }\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.drop_first())\n    }\n}\n\nspec fn valid_input(n: int, ratings: Seq<int>) -> bool {\n    n >= 2 && ratings.len() == n\n}\n\nspec fn all_infected(k: int, ratings: Seq<int>) -> bool {\n    ratings.contains(k) && count_occurrences(ratings, k) == ratings.len()\n}\n\nspec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {\n    (ratings.contains(k) && count_occurrences(ratings, k) != ratings.len()) ||\n    (!ratings.contains(k) && k * ratings.len() == sum(ratings))\n}\n\nspec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {\n    !ratings.contains(k) && k * ratings.len() != sum(ratings)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_case(n: i8, k: i8, ratings: Vec<i8>) -> (answer: i8)\n    requires \n        valid_input(n as int, ratings@.map(|i: int, x: i8| x as int))\n    ensures \n        answer >= 0 && answer <= 2,\n        all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 0,\n        can_infect_in_one_contest(k as int, ratings@.map(|i: int, x: i8| x as int)) && !all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 1,\n        requires_two_contests(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 2\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == x {\n        1 + count_occurrences(s.drop_first(), x)\n    } else {\n        count_occurrences(s.drop_first(), x)\n    }\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.drop_first())\n    }\n}\n\nspec fn valid_input(n: int, ratings: Seq<int>) -> bool {\n    n >= 2 && ratings.len() == n\n}\n\nspec fn all_infected(k: int, ratings: Seq<int>) -> bool {\n    ratings.contains(k) && count_occurrences(ratings, k) == ratings.len()\n}\n\nspec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {\n    (ratings.contains(k) && count_occurrences(ratings, k) != ratings.len()) ||\n    (!ratings.contains(k) && k * ratings.len() == sum(ratings))\n}\n\nspec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {\n    !ratings.contains(k) && k * ratings.len() != sum(ratings)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_case(n: i8, k: i8, ratings: Vec<i8>) -> (answer: i8)\n    requires \n        valid_input(n as int, ratings@.map(|i: int, x: i8| x as int))\n    ensures \n        answer >= 0 && answer <= 2,\n        all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 0,\n        can_infect_in_one_contest(k as int, ratings@.map(|i: int, x: i8| x as int)) && !all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 1,\n        requires_two_contests(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 2\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1965.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 703, "minimize_time_ms": 122356, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn valid_input(n: int, ratings: Seq<int>) -> bool {\n\nspec fn all_infected(k: int, ratings: Seq<int>) -> bool {\n\nspec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {\n\nspec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == x {\n        1 + count_occurrences(s.drop_first(), x)\n    } else {\n        count_occurrences(s.drop_first(), x)\n    }\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.drop_first())\n    }\n}\n\nspec fn valid_input(n: int, ratings: Seq<int>) -> bool {\n    n >= 2 && ratings.len() == n\n}\n\nspec fn all_infected(k: int, ratings: Seq<int>) -> bool {\n    ratings.contains(k) && count_occurrences(ratings, k) == ratings.len()\n}\n\nspec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {\n    (ratings.contains(k) && count_occurrences(ratings, k) != ratings.len()) ||\n    (!ratings.contains(k) && k * ratings.len() == sum(ratings))\n}\n\nspec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {\n    !ratings.contains(k) && k * ratings.len() != sum(ratings)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_case(n: i8, k: i8, ratings: Vec<i8>) -> (answer: i8)\n    requires \n        valid_input(n as int, ratings@.map(|i: int, x: i8| x as int))\n    ensures \n        answer >= 0 && answer <= 2,\n        all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 0,\n        can_infect_in_one_contest(k as int, ratings@.map(|i: int, x: i8| x as int)) && !all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 1,\n        requires_two_contests(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 2\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1985_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }\n}\n\nspec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int\n    recommends 0 <= pos < a.len(), b.len() > 0\n{\n    b[0] - sum(a.subrange(0, pos + 1))\n}\n\nspec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n    decreases pos\n    when pos >= 0\n{\n    if pos == 0 { \n        set![score_at_pos] \n    } else { \n        set![score_at_pos].union(compute_backward_scores(pos - 1, score_at_pos - a[pos], a))\n    }\n}\n\nspec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n    decreases a.len() - pos\n    when pos < a.len()\n{\n    if pos == a.len() - 1 { \n        Set::empty() \n    } else { \n        compute_forward_scores(pos + 1, score_at_pos + a[pos + 1], a).insert(score_at_pos + a[pos + 1])\n    }\n}\n\nspec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n{\n    let backwards = compute_backward_scores(pos, score_at_pos, a);\n    let forwards = compute_forward_scores(pos, score_at_pos, a);\n    backwards.union(forwards)\n}\n\nspec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool\n    recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0\n{\n    let scores = compute_scores(pos, b[0], a);\n    forall|j: int| 0 <= j < b.len() ==> #[trigger] scores.contains(b[j])\n}\n\nspec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>\n    recommends \n        k > 0,\n        a.len() == k,\n        b.len() > 0,\n        forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000,\n        forall|i: int| 0 <= i < b.len() ==> -4000000 <= #[trigger] b[i] <= 4000000\n{\n    Set::new(|x: int| exists|i: int| #[trigger] is_valid_initial_score(i, k, a, b) && 0 <= i < k && x == compute_initial_score(i, a, b))\n}\n\nspec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool\n{\n    k > 0 && n > 0 && a.len() == k && b.len() == n && n <= k &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] b[i] != #[trigger] b[j]) &&\n    (forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000) &&\n    (forall|i: int| 0 <= i < n ==> -4000000 <= #[trigger] b[i] <= 4000000)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, n: i8, a: Vec<i8>, b: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(k as int, n as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))\n    ensures\n        result >= 0,\n        result <= k,\n        result as int == valid_initial_scores(k as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)).len(),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n       spec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int     recommends 0 <= pos < a.len(), b.len() > 0 ;\n       spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases pos     when pos >= 0 ;\n       spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;\n       spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;\n       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n         (forall|i: int| 0 <= i < n ==> -4000000 <=        \n#[trigger] b[i] <= 4000000)\n}\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1985.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 746, "minimize_time_ms": 154431, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 99, "minimized_LOC": 18, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.18181818181818182}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n       spec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int     recommends 0 <= pos < a.len(), b.len() > 0 ;\n       spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases pos     when pos >= 0 ;\n       spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;\n       spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;\n       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int     recommends 0 <= pos < a.len(), b.len() > 0 ;\n       spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases pos     when pos >= 0 ;\n       spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;\n       spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;\n       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases pos     when pos >= 0 ;\n       spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;\n       spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;\n       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;\n       spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;\n       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;\n       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\n       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n\n       spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases pos     when pos >= 0 ;\n\n       spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }\n}\n\nspec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int\n    recommends 0 <= pos < a.len(), b.len() > 0\n{\n    b[0] - sum(a.subrange(0, pos + 1))\n}\n\nspec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n    decreases pos\n    when pos >= 0\n{\n    if pos == 0 { \n        set![score_at_pos] \n    } else { \n        set![score_at_pos].union(compute_backward_scores(pos - 1, score_at_pos - a[pos], a))\n    }\n}\n\nspec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n    decreases a.len() - pos\n    when pos < a.len()\n{\n    if pos == a.len() - 1 { \n        Set::empty() \n    } else { \n        compute_forward_scores(pos + 1, score_at_pos + a[pos + 1], a).insert(score_at_pos + a[pos + 1])\n    }\n}\n\nspec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n{\n    let backwards = compute_backward_scores(pos, score_at_pos, a);\n    let forwards = compute_forward_scores(pos, score_at_pos, a);\n    backwards.union(forwards)\n}\n\nspec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool\n    recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0\n{\n    let scores = compute_scores(pos, b[0], a);\n    forall|j: int| 0 <= j < b.len() ==> #[trigger] scores.contains(b[j])\n}\n\nspec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>\n    recommends \n        k > 0,\n        a.len() == k,\n        b.len() > 0,\n        forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000,\n        forall|i: int| 0 <= i < b.len() ==> -4000000 <= #[trigger] b[i] <= 4000000\n{\n    Set::new(|x: int| exists|i: int| #[trigger] is_valid_initial_score(i, k, a, b) && 0 <= i < k && x == compute_initial_score(i, a, b))\n}\n\nspec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool\n{\n    k > 0 && n > 0 && a.len() == k && b.len() == n && n <= k &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] b[i] != #[trigger] b[j]) &&\n    (forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000) &&\n    (forall|i: int| 0 <= i < n ==> -4000000 <= #[trigger] b[i] <= 4000000)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, n: i8, a: Vec<i8>, b: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(k as int, n as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))\n    ensures\n        result >= 0,\n        result <= k,\n        result as int == valid_initial_scores(k as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)).len(),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n       spec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int     recommends 0 <= pos < a.len(), b.len() > 0 ;\n       spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases pos     when pos >= 0 ;\n       spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;\n       spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;\n       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n         (forall|i: int| 0 <= i < n ==> -4000000 <=        \n#[trigger] b[i] <= 4000000)\n}\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n             fn main() {\n   }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1988_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 2 &&\n    (s.last() == '\\n' || (s.len() >= 2 && s.subrange(s.len() - 2, s.len() as int) == seq!['\\n']))\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 0 &&\n    (result.len() == 0 || result.last() == '\\n')\n}\n\nspec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>\n    recommends 1 <= k <= n && input_str.len() == n\n{\n    let i = k - 1;\n    if (n - i) % 2 == 0 {\n        input_str.subrange(i, n as int) + input_str.subrange(0, i)\n    } else {\n        input_str.subrange(i, n as int) + reverse_string(input_str.subrange(0, i))\n    }\n}\n\nspec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool\n    recommends input_str.len() == n\n{\n    1 <= k <= n &&\n    result_str == transform_string(input_str, n, k) &&\n    true /* Simplified to avoid trigger issues */\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![] /* TODO: Define line splitting logic */\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0 /* TODO: Define integer parsing logic */\n}\n\nspec fn is_lowercase_letter(c: char) -> bool {\n    'a' <= c && c <= 'z'\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char> {\n    s /* TODO: Define string reversal logic */\n}\n\nspec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {\n    true /* TODO: Define lexicographic comparison */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n  requires valid_input(s@)\n  ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 2 &&\n    (s.last() == '\\n' || (s.len() >= 2 && s.subrange(s.len() - 2, s.len() as int) == seq!['\\n']))\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 0 &&\n    (result.len() == 0 || result.last() == '\\n')\n}\n\nspec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>\n    recommends 1 <= k <= n && input_str.len() == n\n{\n    let i = k - 1;\n    if (n - i) % 2 == 0 {\n        input_str.subrange(i, n as int) + input_str.subrange(0, i)\n    } else {\n        input_str.subrange(i, n as int) + reverse_string(input_str.subrange(0, i))\n    }\n}\n\nspec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool\n    recommends input_str.len() == n\n{\n    1 <= k <= n &&\n    result_str == transform_string(input_str, n, k) &&\n    true /* Simplified to avoid trigger issues */\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![] /* TODO: Define line splitting logic */\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0 /* TODO: Define integer parsing logic */\n}\n\nspec fn is_lowercase_letter(c: char) -> bool {\n    'a' <= c && c <= 'z'\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char> {\n    s /* TODO: Define string reversal logic */\n}\n\nspec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {\n    true /* TODO: Define lexicographic comparison */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n  requires valid_input(s@)\n  ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1988.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 768, "minimize_time_ms": 92204, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 73, "minimized_LOC": 73, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn valid_output(result: Seq<char>) -> bool {\n\nspec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>\n    recommends 1 <= k <= n && input_str.len() == n\n{\n\nspec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool\n    recommends input_str.len() == n\n{\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int(line: Seq<char>) -> int {\n\nspec fn is_lowercase_letter(c: char) -> bool {\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char> {\n\nspec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {\n\n  requires valid_input(s@)\n\n  ensures valid_output(result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 2 &&\n    (s.last() == '\\n' || (s.len() >= 2 && s.subrange(s.len() - 2, s.len() as int) == seq!['\\n']))\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 0 &&\n    (result.len() == 0 || result.last() == '\\n')\n}\n\nspec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>\n    recommends 1 <= k <= n && input_str.len() == n\n{\n    let i = k - 1;\n    if (n - i) % 2 == 0 {\n        input_str.subrange(i, n as int) + input_str.subrange(0, i)\n    } else {\n        input_str.subrange(i, n as int) + reverse_string(input_str.subrange(0, i))\n    }\n}\n\nspec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool\n    recommends input_str.len() == n\n{\n    1 <= k <= n &&\n    result_str == transform_string(input_str, n, k) &&\n    true /* Simplified to avoid trigger issues */\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![] /* TODO: Define line splitting logic */\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0 /* TODO: Define integer parsing logic */\n}\n\nspec fn is_lowercase_letter(c: char) -> bool {\n    'a' <= c && c <= 'z'\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char> {\n    s /* TODO: Define string reversal logic */\n}\n\nspec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {\n    true /* TODO: Define lexicographic comparison */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n  requires valid_input(s@)\n  ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_199_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {\n    n > 0 && v.len() == n && s >= 0 && forall|i: int| 0 <= i < v.len() ==> v[i] >= 0\n}\n\nspec fn sum(v: Seq<int>) -> int\n    decreases v.len()\n{\n    if v.len() == 0 {\n        0\n    } else {\n        v[0] + sum(v.subrange(1, v.len() as int))\n    }\n}\n\nspec fn min_seq(v: Seq<int>) -> int\n    recommends v.len() > 0\n    decreases v.len()\n{\n    if v.len() == 1 {\n        v[0]\n    } else if v.len() > 1 && v[0] <= min_seq(v.subrange(1, v.len() as int)) {\n        v[0]\n    } else if v.len() > 1 {\n        min_seq(v.subrange(1, v.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: i8, v: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, v@.map(|i, x| x as int))\n    ensures \n        sum(v@.map(|i, x| x as int)) < s as int ==> result == -1,\n        sum(v@.map(|i, x| x as int)) >= s as int ==> result == min((sum(v@.map(|i, x| x as int)) - s as int) / n as int, min_seq(v@.map(|i, x| x as int))) as i8,\n        result == -1 || result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {\n    n > 0 && v.len() == n && s >= 0 && forall|i: int| 0 <= i < v.len() ==> v[i] >= 0\n}\n\nspec fn sum(v: Seq<int>) -> int\n    decreases v.len()\n{\n    if v.len() == 0 {\n        0\n    } else {\n        v[0] + sum(v.subrange(1, v.len() as int))\n    }\n}\n\nspec fn min_seq(v: Seq<int>) -> int\n    recommends v.len() > 0\n    decreases v.len()\n{\n    if v.len() == 1 {\n        v[0]\n    } else if v.len() > 1 && v[0] <= min_seq(v.subrange(1, v.len() as int)) {\n        v[0]\n    } else if v.len() > 1 {\n        min_seq(v.subrange(1, v.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: i8, v: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, v@.map(|i, x| x as int))\n    ensures \n        sum(v@.map(|i, x| x as int)) < s as int ==> result == -1,\n        sum(v@.map(|i, x| x as int)) >= s as int ==> result == min((sum(v@.map(|i, x| x as int)) - s as int) / n as int, min_seq(v@.map(|i, x| x as int))) as i8,\n        result == -1 || result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_199.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 701, "minimize_time_ms": 122551, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {\n\nspec fn sum(v: Seq<int>) -> int\n    decreases v.len()\n{\n\nspec fn min_seq(v: Seq<int>) -> int\n    recommends v.len() > 0\n    decreases v.len()\n{\n\nspec fn min(a: int, b: int) -> int {\n\n    decreases v.len()\n\n    decreases v.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {\n    n > 0 && v.len() == n && s >= 0 && forall|i: int| 0 <= i < v.len() ==> v[i] >= 0\n}\n\nspec fn sum(v: Seq<int>) -> int\n    decreases v.len()\n{\n    if v.len() == 0 {\n        0\n    } else {\n        v[0] + sum(v.subrange(1, v.len() as int))\n    }\n}\n\nspec fn min_seq(v: Seq<int>) -> int\n    recommends v.len() > 0\n    decreases v.len()\n{\n    if v.len() == 1 {\n        v[0]\n    } else if v.len() > 1 && v[0] <= min_seq(v.subrange(1, v.len() as int)) {\n        v[0]\n    } else if v.len() > 1 {\n        min_seq(v.subrange(1, v.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: i8, v: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, v@.map(|i, x| x as int))\n    ensures \n        sum(v@.map(|i, x| x as int)) < s as int ==> result == -1,\n        sum(v@.map(|i, x| x as int)) >= s as int ==> result == min((sum(v@.map(|i, x| x as int)) - s as int) / n as int, min_seq(v@.map(|i, x| x as int))) as i8,\n        result == -1 || result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2025_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_composite(x: int) -> bool {\n    x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0\n}\n\nspec fn valid_input(queries: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1\n}\n\nspec fn max_composite_summands(n: int) -> int {\n    if n % 4 == 0 {\n        n / 4\n    } else if n % 4 == 1 && n / 4 >= 2 {\n        n / 4 - 1\n    } else if n % 4 == 2 && n / 4 >= 1 {\n        n / 4\n    } else if n % 4 == 3 && n / 4 >= 3 {\n        n / 4 - 1\n    } else {\n        -1\n    }\n}\n\nspec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i, x: i8| x as int))\n    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_composite(x: int) -> bool {\n    x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0\n}\n\nspec fn valid_input(queries: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1\n}\n\nspec fn max_composite_summands(n: int) -> int {\n    if n % 4 == 0 {\n        n / 4\n    } else if n % 4 == 1 && n / 4 >= 2 {\n        n / 4 - 1\n    } else if n % 4 == 2 && n / 4 >= 1 {\n        n / 4\n    } else if n % 4 == 3 && n / 4 >= 3 {\n        n / 4 - 1\n    } else {\n        -1\n    }\n}\n\nspec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i, x: i8| x as int))\n    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2025.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 780, "minimize_time_ms": 122300, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_composite(x: int) -> bool {\n\nspec fn valid_input(queries: Seq<int>) -> bool {\n\nspec fn max_composite_summands(n: int) -> int {\n\nspec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {\n\n    requires valid_input(queries@.map(|i, x: i8| x as int))\n\n    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_composite(x: int) -> bool {\n    x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0\n}\n\nspec fn valid_input(queries: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1\n}\n\nspec fn max_composite_summands(n: int) -> int {\n    if n % 4 == 0 {\n        n / 4\n    } else if n % 4 == 1 && n / 4 >= 2 {\n        n / 4 - 1\n    } else if n % 4 == 2 && n / 4 >= 1 {\n        n / 4\n    } else if n % 4 == 3 && n / 4 >= 3 {\n        n / 4 - 1\n    } else {\n        -1\n    }\n}\n\nspec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i, x: i8| x as int))\n    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_203_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    1 <= n <= 200000 && s.len() == n &&\n    forall|i: int| 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'\n}\n\nspec fn count_d(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'D' { 1int } else { 0int }) + count_d(s.subrange(1, s.len() as int)) }\n}\n\nspec fn count_r(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'R' { 1int } else { 0int }) + count_r(s.subrange(1, s.len() as int)) }\n}\n\nspec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {\n    if count_d(s) == 0 { seq!['R'] }\n    else if count_r(s) == 0 { seq!['D'] }\n    else if count_d(s) >= count_r(s) { seq!['D'] }\n    else { seq!['R'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(n as int, s@)\n    ensures result@ == optimal_elimination_game_winner(s@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    1 <= n <= 200000 && s.len() == n &&\n    forall|i: int| 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'\n}\n\nspec fn count_d(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'D' { 1int } else { 0int }) + count_d(s.subrange(1, s.len() as int)) }\n}\n\nspec fn count_r(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'R' { 1int } else { 0int }) + count_r(s.subrange(1, s.len() as int)) }\n}\n\nspec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {\n    if count_d(s) == 0 { seq!['R'] }\n    else if count_r(s) == 0 { seq!['D'] }\n    else if count_d(s) >= count_r(s) { seq!['D'] }\n    else { seq!['R'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(n as int, s@)\n    ensures result@ == optimal_elimination_game_winner(s@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_203.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 760, "minimize_time_ms": 92399, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, s: Seq<char>) -> bool {\n\nspec fn count_d(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn count_r(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_input(n as int, s@)\n\n    ensures result@ == optimal_elimination_game_winner(s@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    1 <= n <= 200000 && s.len() == n &&\n    forall|i: int| 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'\n}\n\nspec fn count_d(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'D' { 1int } else { 0int }) + count_d(s.subrange(1, s.len() as int)) }\n}\n\nspec fn count_r(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'R' { 1int } else { 0int }) + count_r(s.subrange(1, s.len() as int)) }\n}\n\nspec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {\n    if count_d(s) == 0 { seq!['R'] }\n    else if count_r(s) == 0 { seq!['D'] }\n    else if count_d(s) >= count_r(s) { seq!['D'] }\n    else { seq!['R'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(n as int, s@)\n    ensures result@ == optimal_elimination_game_winner(s@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_204_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, x: int, y: int) -> bool {\n  a > 0 && b > 0 && x > 0 && y > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a >= 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn min(a: int, b: int) -> int {\n  if a <= b { a } else { b }\n}\n\nspec fn expected_result(a: int, b: int, x: int, y: int) -> int\n  recommends valid_input(a, b, x, y)\n{\n  let g = gcd(x, y);\n  let x_reduced = x / g;\n  let y_reduced = y / g;\n  min(a / x_reduced, b / y_reduced)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, x: i8, y: i8) -> (result: i8)\nrequires \n  valid_input(a as int, b as int, x as int, y as int)\nensures \n  result as int >= 0,\n  result as int == expected_result(a as int, b as int, x as int, y as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, x: int, y: int) -> bool {\n  a > 0 && b > 0 && x > 0 && y > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a >= 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn min(a: int, b: int) -> int {\n  if a <= b { a } else { b }\n}\n\nspec fn expected_result(a: int, b: int, x: int, y: int) -> int\n  recommends valid_input(a, b, x, y)\n{\n  let g = gcd(x, y);\n  let x_reduced = x / g;\n  let y_reduced = y / g;\n  min(a / x_reduced, b / y_reduced)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, x: i8, y: i8) -> (result: i8)\nrequires \n  valid_input(a as int, b as int, x as int, y as int)\nensures \n  result as int >= 0,\n  result as int == expected_result(a as int, b as int, x as int, y as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_204.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 633, "minimize_time_ms": 92052, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, x: int, y: int) -> bool {\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a >= 0 && b >= 0\n  decreases b when b >= 0\n{\n\nspec fn min(a: int, b: int) -> int {\n\nspec fn expected_result(a: int, b: int, x: int, y: int) -> int\n  recommends valid_input(a, b, x, y)\n{\n\n  decreases b when b >= 0\n\nrequires \n\nensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, x: int, y: int) -> bool {\n  a > 0 && b > 0 && x > 0 && y > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a >= 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn min(a: int, b: int) -> int {\n  if a <= b { a } else { b }\n}\n\nspec fn expected_result(a: int, b: int, x: int, y: int) -> int\n  recommends valid_input(a, b, x, y)\n{\n  let g = gcd(x, y);\n  let x_reduced = x / g;\n  let y_reduced = y / g;\n  min(a / x_reduced, b / y_reduced)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, x: i8, y: i8) -> (result: i8)\nrequires \n  valid_input(a as int, b as int, x as int, y as int)\nensures \n  result as int >= 0,\n  result as int == expected_result(a as int, b as int, x as int, y as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2044_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && a.len() == n && \n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1)\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n    result.len() == n && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)\n}\n\nspec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { 0 }\n    else { (s + a[i]) / m }\n}\n\nspec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { s }\n    else { (s + a[i]) % m }\n}\n\nspec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool\n    recommends m >= 1\n{\n    result.len() == a.len() &&\n    (forall|i: int| 0 <= i < a.len() ==> {\n        let s = compute_state_at(a, m, i);\n        #[trigger] result[i] == (s + a[i]) / m\n    })\n}\n\nspec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int\n    recommends m >= 1, day >= 0\n    decreases day\n{\n    if day <= 0 { 0 }\n    else if day > a.len() { compute_state_at(a, m, a.len() as int) }\n    else if day > 0 && day <= a.len() { (compute_state_at(a, m, day - 1) + a[day - 1]) % m }\n    else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: Vec<i8>) -> (result: Vec<i8>)\nrequires\n    valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int))\nensures\n    valid_output(result@.map(|i: int, x: i8| x as int), n as int),\n    correct_page_turns(result@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), m as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && a.len() == n && \n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1)\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n    result.len() == n && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)\n}\n\nspec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { 0 }\n    else { (s + a[i]) / m }\n}\n\nspec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { s }\n    else { (s + a[i]) % m }\n}\n\nspec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool\n    recommends m >= 1\n{\n    result.len() == a.len() &&\n    (forall|i: int| 0 <= i < a.len() ==> {\n        let s = compute_state_at(a, m, i);\n        #[trigger] result[i] == (s + a[i]) / m\n    })\n}\n\nspec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int\n    recommends m >= 1, day >= 0\n    decreases day\n{\n    if day <= 0 { 0 }\n    else if day > a.len() { compute_state_at(a, m, a.len() as int) }\n    else if day > 0 && day <= a.len() { (compute_state_at(a, m, day - 1) + a[day - 1]) % m }\n    else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: Vec<i8>) -> (result: Vec<i8>)\nrequires\n    valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int))\nensures\n    valid_output(result@.map(|i: int, x: i8| x as int), n as int),\n    correct_page_turns(result@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), m as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2044.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 695, "minimize_time_ms": 123544, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 73, "minimized_LOC": 73, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n\nspec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n\nspec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n\nspec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool\n    recommends m >= 1\n{\n\nspec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int\n    recommends m >= 1, day >= 0\n    decreases day\n{\n\n    decreases day\n\nrequires\n\nensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && a.len() == n && \n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1)\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n    result.len() == n && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)\n}\n\nspec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { 0 }\n    else { (s + a[i]) / m }\n}\n\nspec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { s }\n    else { (s + a[i]) % m }\n}\n\nspec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool\n    recommends m >= 1\n{\n    result.len() == a.len() &&\n    (forall|i: int| 0 <= i < a.len() ==> {\n        let s = compute_state_at(a, m, i);\n        #[trigger] result[i] == (s + a[i]) / m\n    })\n}\n\nspec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int\n    recommends m >= 1, day >= 0\n    decreases day\n{\n    if day <= 0 { 0 }\n    else if day > a.len() { compute_state_at(a, m, a.len() as int) }\n    else if day > 0 && day <= a.len() { (compute_state_at(a, m, day - 1) + a[day - 1]) % m }\n    else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: Vec<i8>) -> (result: Vec<i8>)\nrequires\n    valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int))\nensures\n    valid_output(result@.map(|i: int, x: i8| x as int), n as int),\n    correct_page_turns(result@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), m as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n               fn main() {\n     }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2049_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {\n  &&& 0 <= l <= r < arr.len()\n  &&& if l == r {\n    true\n  } else {\n    exists|k: int| l <= k <= r && \n      is_non_decreasing(arr, l, k) && \n      is_non_increasing(arr, k, r)\n  }\n}\n\nspec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] <= arr[i+1]\n}\n\nspec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] >= arr[i+1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, arr: Vec<i8>, queries: Vec<(i8, i8)>) -> (results: Vec<Vec<char>>)\n  requires \n    n >= 1 && m >= 1,\n    arr@.len() == n as int,\n    queries@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> 1 <= #[trigger] queries@[i].0 as int <= queries@[i].1 as int <= n as int,\n  ensures \n    results@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> #[trigger] results@[i]@ == seq!['Y', 'e', 's'] || results@[i]@ == seq!['N', 'o'],\n    forall|i: int| 0 <= i < m as int ==> \n      (#[trigger] results@[i]@ == seq!['Y', 'e', 's'] <==> is_ladder(arr@.map(|_i, v| v as int), queries@[i].0 as int - 1, queries@[i].1 as int - 1)),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {\n  &&& 0 <= l <= r < arr.len()\n  &&& if l == r {\n    true\n  } else {\n    exists|k: int| l <= k <= r && \n      is_non_decreasing(arr, l, k) && \n      is_non_increasing(arr, k, r)\n  }\n}\n\nspec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] <= arr[i+1]\n}\n\nspec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] >= arr[i+1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, arr: Vec<i8>, queries: Vec<(i8, i8)>) -> (results: Vec<Vec<char>>)\n  requires \n    n >= 1 && m >= 1,\n    arr@.len() == n as int,\n    queries@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> 1 <= #[trigger] queries@[i].0 as int <= queries@[i].1 as int <= n as int,\n  ensures \n    results@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> #[trigger] results@[i]@ == seq!['Y', 'e', 's'] || results@[i]@ == seq!['N', 'o'],\n    forall|i: int| 0 <= i < m as int ==> \n      (#[trigger] results@[i]@ == seq!['Y', 'e', 's'] <==> is_ladder(arr@.map(|_i, v| v as int), queries@[i].0 as int - 1, queries@[i].1 as int - 1)),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2049.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 856, "minimize_time_ms": 153580, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {\n\nspec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {\n\nspec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {\n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {\n  &&& 0 <= l <= r < arr.len()\n  &&& if l == r {\n    true\n  } else {\n    exists|k: int| l <= k <= r && \n      is_non_decreasing(arr, l, k) && \n      is_non_increasing(arr, k, r)\n  }\n}\n\nspec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] <= arr[i+1]\n}\n\nspec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] >= arr[i+1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, arr: Vec<i8>, queries: Vec<(i8, i8)>) -> (results: Vec<Vec<char>>)\n  requires \n    n >= 1 && m >= 1,\n    arr@.len() == n as int,\n    queries@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> 1 <= #[trigger] queries@[i].0 as int <= queries@[i].1 as int <= n as int,\n  ensures \n    results@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> #[trigger] results@[i]@ == seq!['Y', 'e', 's'] || results@[i]@ == seq!['N', 'o'],\n    forall|i: int| 0 <= i < m as int ==> \n      (#[trigger] results@[i]@ == seq!['Y', 'e', 's'] <==> is_ladder(arr@.map(|_i, v| v as int), queries@[i].0 as int - 1, queries@[i].1 as int - 1)),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n             fn main() {\n   }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2074_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0\n}\n\nspec fn seq_min(s: Seq<int>) -> int \n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_min = seq_min(s.drop_first());\n        if s[0] <= tail_min { \n            s[0]\n        } else { \n            tail_min\n        }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_max = seq_max(s.drop_first());\n        if s[0] >= tail_max { \n            s[0]\n        } else { \n            tail_max\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(grid: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures ({\n        let grid_spec = grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int));\n        let row_mins = Seq::new(grid_spec.len(), |i: int| seq_min(grid_spec[i]));\n        result as int == seq_max(row_mins)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0\n}\n\nspec fn seq_min(s: Seq<int>) -> int \n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_min = seq_min(s.drop_first());\n        if s[0] <= tail_min { \n            s[0]\n        } else { \n            tail_min\n        }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_max = seq_max(s.drop_first());\n        if s[0] >= tail_max { \n            s[0]\n        } else { \n            tail_max\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(grid: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures ({\n        let grid_spec = grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int));\n        let row_mins = Seq::new(grid_spec.len(), |i: int| seq_min(grid_spec[i]));\n        result as int == seq_max(row_mins)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2074.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1106, "minimize_time_ms": 122639, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n\nspec fn seq_min(s: Seq<int>) -> int \n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0\n}\n\nspec fn seq_min(s: Seq<int>) -> int \n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_min = seq_min(s.drop_first());\n        if s[0] <= tail_min { \n            s[0]\n        } else { \n            tail_min\n        }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_max = seq_max(s.drop_first());\n        if s[0] >= tail_max { \n            s[0]\n        } else { \n            tail_max\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(grid: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures ({\n        let grid_spec = grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int));\n        let row_mins = Seq::new(grid_spec.len(), |i: int| seq_min(grid_spec[i]));\n        result as int == seq_max(row_mins)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_208_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {\n    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100\n}\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) != int_abs(y1 - y2)\n}\n\nspec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) == int_abs(y1 - y2)\n}\n\nspec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 == x2\n}\n\nspec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 == y2\n}\n\nspec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y2, x2, y1]\n}\n\nspec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1 + int_abs(y2 - y1), y1, x1 + int_abs(y2 - y1), y2]\n}\n\nspec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y1 + int_abs(x2 - x1), x2, y1 + int_abs(x2 - x1)]\n}\n\nspec fn valid_output(result: Seq<int>) -> bool {\n    (result.len() == 1 && result[0] == -1) ||\n    (result.len() == 4 && (forall|i: int| #![trigger result[i]] 0 <= i < 4 ==> -1000 <= result[i] <= 1000))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(x1 as int, y1 as int, x2 as int, y2 as int)\n    ensures \n        valid_output(result@.map(|i, v| v as int)),\n        is_invalid_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == seq![-1],\n        is_diagonal_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_diagonal_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_vertical_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_vertical_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_horizontal_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_horizontal_result(x1 as int, y1 as int, x2 as int, y2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {\n    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100\n}\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) != int_abs(y1 - y2)\n}\n\nspec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) == int_abs(y1 - y2)\n}\n\nspec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 == x2\n}\n\nspec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 == y2\n}\n\nspec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y2, x2, y1]\n}\n\nspec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1 + int_abs(y2 - y1), y1, x1 + int_abs(y2 - y1), y2]\n}\n\nspec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y1 + int_abs(x2 - x1), x2, y1 + int_abs(x2 - x1)]\n}\n\nspec fn valid_output(result: Seq<int>) -> bool {\n    (result.len() == 1 && result[0] == -1) ||\n    (result.len() == 4 && (forall|i: int| #![trigger result[i]] 0 <= i < 4 ==> -1000 <= result[i] <= 1000))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(x1 as int, y1 as int, x2 as int, y2 as int)\n    ensures \n        valid_output(result@.map(|i, v| v as int)),\n        is_invalid_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == seq![-1],\n        is_diagonal_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_diagonal_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_vertical_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_vertical_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_horizontal_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_horizontal_result(x1 as int, y1 as int, x2 as int, y2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_208.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 925, "minimize_time_ms": 185246, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 73, "minimized_LOC": 73, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {\n\nspec fn int_abs(x: int) -> int {\n\nspec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n\nspec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n\nspec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n\nspec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n\nspec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n\nspec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n\nspec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n\nspec fn valid_output(result: Seq<int>) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {\n    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100\n}\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) != int_abs(y1 - y2)\n}\n\nspec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) == int_abs(y1 - y2)\n}\n\nspec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 == x2\n}\n\nspec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 == y2\n}\n\nspec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y2, x2, y1]\n}\n\nspec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1 + int_abs(y2 - y1), y1, x1 + int_abs(y2 - y1), y2]\n}\n\nspec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y1 + int_abs(x2 - x1), x2, y1 + int_abs(x2 - x1)]\n}\n\nspec fn valid_output(result: Seq<int>) -> bool {\n    (result.len() == 1 && result[0] == -1) ||\n    (result.len() == 4 && (forall|i: int| #![trigger result[i]] 0 <= i < 4 ==> -1000 <= result[i] <= 1000))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(x1 as int, y1 as int, x2 as int, y2 as int)\n    ensures \n        valid_output(result@.map(|i, v| v as int)),\n        is_invalid_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == seq![-1],\n        is_diagonal_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_diagonal_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_vertical_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_vertical_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_horizontal_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_horizontal_result(x1 as int, y1 as int, x2 as int, y2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2080_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 2000000000\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    result >= 0 &&\n    result >= n - 1 &&\n    result <= n * (n - 1) / 2\n}\n\nspec fn compute_expected_result(n: int) -> int {\n    let quad_solv_numerator = isqrt(8*n + 1) - 1;\n    let x = quad_solv_numerator / 2;\n    let y = x + 1;\n    let xed = x * (x - 1) / 2 + n - x;\n    let ybr = n - y;\n    let yed = 2 * ybr;\n    if xed > yed { xed } else { yed }\n}\n\nspec fn isqrt(n: int) -> int {\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n <= 3 { 1 }\n    else {\n        let guess = n / 2;\n        let low = 0;\n        let high = guess + 1;\n        isqrt_helper(n, low, high)\n    }\n}\n\nspec fn isqrt_helper(n: int, low: int, high: int) -> int\n    decreases high - low\n{\n    if high - low <= 1 { low }\n    else {\n        let mid = (low + high) / 2;\n        if mid * mid <= n {\n            isqrt_helper(n, mid, high)\n        } else {\n            isqrt_helper(n, low, mid)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int),\n    ensures\n        valid_output(n as int, result as int),\n        result as int == compute_expected_result(n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 2000000000\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    result >= 0 &&\n    result >= n - 1 &&\n    result <= n * (n - 1) / 2\n}\n\nspec fn compute_expected_result(n: int) -> int {\n    let quad_solv_numerator = isqrt(8*n + 1) - 1;\n    let x = quad_solv_numerator / 2;\n    let y = x + 1;\n    let xed = x * (x - 1) / 2 + n - x;\n    let ybr = n - y;\n    let yed = 2 * ybr;\n    if xed > yed { xed } else { yed }\n}\n\nspec fn isqrt(n: int) -> int {\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n <= 3 { 1 }\n    else {\n        let guess = n / 2;\n        let low = 0;\n        let high = guess + 1;\n        isqrt_helper(n, low, high)\n    }\n}\n\nspec fn isqrt_helper(n: int, low: int, high: int) -> int\n    decreases high - low\n{\n    if high - low <= 1 { low }\n    else {\n        let mid = (low + high) / 2;\n        if mid * mid <= n {\n            isqrt_helper(n, mid, high)\n        } else {\n            isqrt_helper(n, low, mid)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int),\n    ensures\n        valid_output(n as int, result as int),\n        result as int == compute_expected_result(n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2080.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 692, "minimize_time_ms": 122212, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 74, "minimized_LOC": 74, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn valid_output(n: int, result: int) -> bool {\n\nspec fn compute_expected_result(n: int) -> int {\n\nspec fn isqrt(n: int) -> int {\n\nspec fn isqrt_helper(n: int, low: int, high: int) -> int\n    decreases high - low\n{\n\n    decreases high - low\n\n    requires \n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 2000000000\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    result >= 0 &&\n    result >= n - 1 &&\n    result <= n * (n - 1) / 2\n}\n\nspec fn compute_expected_result(n: int) -> int {\n    let quad_solv_numerator = isqrt(8*n + 1) - 1;\n    let x = quad_solv_numerator / 2;\n    let y = x + 1;\n    let xed = x * (x - 1) / 2 + n - x;\n    let ybr = n - y;\n    let yed = 2 * ybr;\n    if xed > yed { xed } else { yed }\n}\n\nspec fn isqrt(n: int) -> int {\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n <= 3 { 1 }\n    else {\n        let guess = n / 2;\n        let low = 0;\n        let high = guess + 1;\n        isqrt_helper(n, low, high)\n    }\n}\n\nspec fn isqrt_helper(n: int, low: int, high: int) -> int\n    decreases high - low\n{\n    if high - low <= 1 { low }\n    else {\n        let mid = (low + high) / 2;\n        if mid * mid <= n {\n            isqrt_helper(n, mid, high)\n        } else {\n            isqrt_helper(n, low, mid)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int),\n    ensures\n        valid_output(n as int, result as int),\n        result as int == compute_expected_result(n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2104_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(l: int, r: int) -> bool {\n    l < r && (r - l) % 2 == 1\n}\n\nspec fn gcd(a: int, b: int) -> int\n    recommends a != 0 || b != 0\n    decreases (if a >= 0 { a } else { -a })\n{\n    if a == 0 {\n        if b >= 0 { b } else { -b }\n    } else {\n        gcd(b % a, a)\n    }\n}\n\nspec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {\n    exists|i: int, j: int| l <= i <= r && l <= j <= r && i != j &&\n        pair == int_to_string(i).add(seq![' ']).add(int_to_string(j)) &&\n        (i != 0 || j != 0) && gcd(i, j) == 1\n}\n\nspec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {\n    result.len() >= 1 &&\n    result[0] == seq!['Y', 'E', 'S'] &&\n    result.len() == 1 + (r - l + 1) / 2 &&\n    (forall|i: int| 1 <= i < result.len() ==> pair_has_gcd_one(result[i], l, r))\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'].add(int_to_string_pos(-n))\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![char_from_digit(n)]\n    } else {\n        int_to_string_pos(n / 10).push(char_from_digit(n % 10))\n    }\n}\n\nspec fn char_from_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(l: i8, r: i8) -> (result: Vec<Vec<char>>)\n    requires valid_input(l as int, r as int)\n    ensures\n        result.len() >= 1,\n        result[0]@ == seq!['Y', 'E', 'S'],\n        result.len() == 1 + (r as int - l as int + 1) / 2,\n        forall|i: int| 1 <= i < result.len() ==> \n            #[trigger] result[i]@ == int_to_string(l as int + 2 * (i - 1)).add(seq![' ']).add(int_to_string(l as int + 2 * (i - 1) + 1))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(l: int, r: int) -> bool {\n    l < r && (r - l) % 2 == 1\n}\n\nspec fn gcd(a: int, b: int) -> int\n    recommends a != 0 || b != 0\n    decreases (if a >= 0 { a } else { -a })\n{\n    if a == 0 {\n        if b >= 0 { b } else { -b }\n    } else {\n        gcd(b % a, a)\n    }\n}\n\nspec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {\n    exists|i: int, j: int| l <= i <= r && l <= j <= r && i != j &&\n        pair == int_to_string(i).add(seq![' ']).add(int_to_string(j)) &&\n        (i != 0 || j != 0) && gcd(i, j) == 1\n}\n\nspec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {\n    result.len() >= 1 &&\n    result[0] == seq!['Y', 'E', 'S'] &&\n    result.len() == 1 + (r - l + 1) / 2 &&\n    (forall|i: int| 1 <= i < result.len() ==> pair_has_gcd_one(result[i], l, r))\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'].add(int_to_string_pos(-n))\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![char_from_digit(n)]\n    } else {\n        int_to_string_pos(n / 10).push(char_from_digit(n % 10))\n    }\n}\n\nspec fn char_from_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(l: i8, r: i8) -> (result: Vec<Vec<char>>)\n    requires valid_input(l as int, r as int)\n    ensures\n        result.len() >= 1,\n        result[0]@ == seq!['Y', 'E', 'S'],\n        result.len() == 1 + (r as int - l as int + 1) / 2,\n        forall|i: int| 1 <= i < result.len() ==> \n            #[trigger] result[i]@ == int_to_string(l as int + 2 * (i - 1)).add(seq![' ']).add(int_to_string(l as int + 2 * (i - 1) + 1))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2104.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 779, "minimize_time_ms": 184315, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 94, "minimized_LOC": 94, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(l: int, r: int) -> bool {\n\nspec fn gcd(a: int, b: int) -> int\n    recommends a != 0 || b != 0\n    decreases (if a >= 0 {\n\nspec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {\n\nspec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n\nspec fn char_from_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n\n    decreases (if a >= 0 { a } else { -a })\n\n    decreases n\n\n    requires valid_input(l as int, r as int)\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(l: int, r: int) -> bool {\n    l < r && (r - l) % 2 == 1\n}\n\nspec fn gcd(a: int, b: int) -> int\n    recommends a != 0 || b != 0\n    decreases (if a >= 0 { a } else { -a })\n{\n    if a == 0 {\n        if b >= 0 { b } else { -b }\n    } else {\n        gcd(b % a, a)\n    }\n}\n\nspec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {\n    exists|i: int, j: int| l <= i <= r && l <= j <= r && i != j &&\n        pair == int_to_string(i).add(seq![' ']).add(int_to_string(j)) &&\n        (i != 0 || j != 0) && gcd(i, j) == 1\n}\n\nspec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {\n    result.len() >= 1 &&\n    result[0] == seq!['Y', 'E', 'S'] &&\n    result.len() == 1 + (r - l + 1) / 2 &&\n    (forall|i: int| 1 <= i < result.len() ==> pair_has_gcd_one(result[i], l, r))\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'].add(int_to_string_pos(-n))\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![char_from_digit(n)]\n    } else {\n        int_to_string_pos(n / 10).push(char_from_digit(n % 10))\n    }\n}\n\nspec fn char_from_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(l: i8, r: i8) -> (result: Vec<Vec<char>>)\n    requires valid_input(l as int, r as int)\n    ensures\n        result.len() >= 1,\n        result[0]@ == seq!['Y', 'E', 'S'],\n        result.len() == 1 + (r as int - l as int + 1) / 2,\n        forall|i: int| 1 <= i < result.len() ==> \n            #[trigger] result[i]@ == int_to_string(l as int + 2 * (i - 1)).add(seq![' ']).add(int_to_string(l as int + 2 * (i - 1) + 1))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2123_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    via max_in_seq_decreases\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        let tail = s.subrange(1, s.len() as int);\n        let tail_max = max_in_seq(tail);\n        if s[0] >= tail_max { s[0] } else { tail_max }\n    }\n}\n\n#[via_fn]\nproof fn max_in_seq_decreases(s: Seq<int>) {\n    assume(false);\n}\n\nspec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool\n    recommends valid_input(n, heights)\n{\n    result == max_in_seq(heights) &&\n    forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&\n    exists|i: int| 0 <= i < heights.len() && heights[i] == result\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))\n    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    via max_in_seq_decreases\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        let tail = s.subrange(1, s.len() as int);\n        let tail_max = max_in_seq(tail);\n        if s[0] >= tail_max { s[0] } else { tail_max }\n    }\n}\n\n#[via_fn]\nproof fn max_in_seq_decreases(s: Seq<int>) {\n    assume(false);\n}\n\nspec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool\n    recommends valid_input(n, heights)\n{\n    result == max_in_seq(heights) &&\n    forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&\n    exists|i: int| 0 <= i < heights.len() && heights[i] == result\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))\n    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2123.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 706, "minimize_time_ms": 154362, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, heights: Seq<int>) -> bool {\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    via max_in_seq_decreases\n{\n\nspec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool\n    recommends valid_input(n, heights)\n{\n\n    decreases s.len()\n\n    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))\n\n    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)", "proof": "proof fn max_in_seq_decreases(s: Seq<int>) {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    via max_in_seq_decreases\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        let tail = s.subrange(1, s.len() as int);\n        let tail_max = max_in_seq(tail);\n        if s[0] >= tail_max { s[0] } else { tail_max }\n    }\n}\n\n#[via_fn]\nproof fn max_in_seq_decreases(s: Seq<int>) {\n    assume(false);\n}\n\nspec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool\n    recommends valid_input(n, heights)\n{\n    result == max_in_seq(heights) &&\n    forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&\n    exists|i: int| 0 <= i < heights.len() && heights[i] == result\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))\n    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_217_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, f: int, k: int) -> bool {\n  a > 0 && b > 0 && f > 0 && k > 0 && f < a\n}\n\nspec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b < f ||                                    \n  b < a - f ||                               \n  (k > 1 && b < 2 * a - f) ||               \n  (k == 1 && b < a && b < f)                \n}\n\nspec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b >= f &&                                  \n  b >= a - f &&                             \n  (k <= 1 || b >= 2 * a - f) &&            \n  (k == 1 ==> (b >= a || b >= f))          \n}\n\nspec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k == 1 && result >= 0 ==> (\n    (b >= a && result == 0) ||                \n    (b < a && b >= f && result == 1)          \n  )\n}\n\nspec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k > 1 && result >= 0 ==> (\n    b >= f && b >= a - f && b >= 2 * a - f    \n  )\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, f: i8, k: i8) -> (result: i8)\n  requires\n    valid_input(a as int, b as int, f as int, k as int)\n  ensures\n    result as int >= -1 &&\n    ((result as int == -1) <==> impossible_conditions(a as int, b as int, f as int, k as int)) &&\n    (result as int >= 0 ==> result as int <= k as int) &&\n    (result as int >= 0 ==> feasibility_conditions(a as int, b as int, f as int, k as int)) &&\n    single_journey_result(a as int, b as int, f as int, k as int, result as int) &&\n    multi_journey_feasibility(a as int, b as int, f as int, k as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, f: int, k: int) -> bool {\n  a > 0 && b > 0 && f > 0 && k > 0 && f < a\n}\n\nspec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b < f ||                                    \n  b < a - f ||                               \n  (k > 1 && b < 2 * a - f) ||               \n  (k == 1 && b < a && b < f)                \n}\n\nspec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b >= f &&                                  \n  b >= a - f &&                             \n  (k <= 1 || b >= 2 * a - f) &&            \n  (k == 1 ==> (b >= a || b >= f))          \n}\n\nspec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k == 1 && result >= 0 ==> (\n    (b >= a && result == 0) ||                \n    (b < a && b >= f && result == 1)          \n  )\n}\n\nspec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k > 1 && result >= 0 ==> (\n    b >= f && b >= a - f && b >= 2 * a - f    \n  )\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, f: i8, k: i8) -> (result: i8)\n  requires\n    valid_input(a as int, b as int, f as int, k as int)\n  ensures\n    result as int >= -1 &&\n    ((result as int == -1) <==> impossible_conditions(a as int, b as int, f as int, k as int)) &&\n    (result as int >= 0 ==> result as int <= k as int) &&\n    (result as int >= 0 ==> feasibility_conditions(a as int, b as int, f as int, k as int)) &&\n    single_journey_result(a as int, b as int, f as int, k as int, result as int) &&\n    multi_journey_feasibility(a as int, b as int, f as int, k as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_217.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 679, "minimize_time_ms": 122520, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, f: int, k: int) -> bool {\n\nspec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {\n\nspec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {\n\nspec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {\n\nspec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {\n\n  requires\n\n  ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, f: int, k: int) -> bool {\n  a > 0 && b > 0 && f > 0 && k > 0 && f < a\n}\n\nspec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b < f ||                                    \n  b < a - f ||                               \n  (k > 1 && b < 2 * a - f) ||               \n  (k == 1 && b < a && b < f)                \n}\n\nspec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b >= f &&                                  \n  b >= a - f &&                             \n  (k <= 1 || b >= 2 * a - f) &&            \n  (k == 1 ==> (b >= a || b >= f))          \n}\n\nspec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k == 1 && result >= 0 ==> (\n    (b >= a && result == 0) ||                \n    (b < a && b >= f && result == 1)          \n  )\n}\n\nspec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k > 1 && result >= 0 ==> (\n    b >= f && b >= a - f && b >= 2 * a - f    \n  )\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, f: i8, k: i8) -> (result: i8)\n  requires\n    valid_input(a as int, b as int, f as int, k as int)\n  ensures\n    result as int >= -1 &&\n    ((result as int == -1) <==> impossible_conditions(a as int, b as int, f as int, k as int)) &&\n    (result as int >= 0 ==> result as int <= k as int) &&\n    (result as int >= 0 ==> feasibility_conditions(a as int, b as int, f as int, k as int)) &&\n    single_journey_result(a as int, b as int, f as int, k as int, result as int) &&\n    multi_journey_feasibility(a as int, b as int, f as int, k as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2209_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 1 &&\n    (forall|i: int| 0 <= i < input[0].len() ==> #[trigger] input[0][i] == input[0][i] && '0' <= input[0][i] <= '9') &&\n    {\n        let n = string_to_int(input[0]);\n        n >= 1 && input.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n ==> #[trigger] input[i] == input[i] && (input[i].len() > 0 &&\n            forall|j: int| 0 <= j < input[i].len() ==> #[trigger] input[i][j] == input[i][j] && (input[i][j] == 's' || input[i][j] == 'h'))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { string_to_int(s.subrange(0, s.len() as int - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn count_sh_subsequences(s: Seq<char>) -> int {\n    count_sh_subsequences_helper(s, 0, 0)\n}\n\nspec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int\n    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0\n{\n    if index == s.len() { 0 }\n    else if index < s.len() && s[index] == 's' {\n        count_sh_subsequences_helper(s, index + 1, s_count + 1)\n    } else if index < s.len() && s[index] == 'h' {\n        s_count + count_sh_subsequences_helper(s, index + 1, s_count)\n    } else {\n        count_sh_subsequences_helper(s, index + 1, s_count)\n    }\n}\n\nspec fn string_ratio(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 } else { count_char(s, 's') * 1000 / s.len() as int }\n}\n\nspec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>\n    decreases strings.len()\n{\n    if strings.len() == 0 { Seq::empty() }\n    else { strings[0] + concatenate_strings(strings.subrange(1, strings.len() as int)) }\n}\n\nspec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < strings.len() ==> \n        #[trigger] strings[i] == strings[i] && #[trigger] strings[j] == strings[j] &&\n        strings[i].len() > 0 && strings[j].len() > 0 ==> \n        string_ratio(strings[i]) <= string_ratio(strings[j])\n}\n\nspec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {\n    arranged.len() == original.len() &&\n    forall|s: Seq<char>| #[trigger] original.contains(s) <==> arranged.contains(s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<Vec<char>>) -> (result: i32)\n    requires valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 1 &&\n    (forall|i: int| 0 <= i < input[0].len() ==> #[trigger] input[0][i] == input[0][i] && '0' <= input[0][i] <= '9') &&\n    {\n        let n = string_to_int(input[0]);\n        n >= 1 && input.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n ==> #[trigger] input[i] == input[i] && (input[i].len() > 0 &&\n            forall|j: int| 0 <= j < input[i].len() ==> #[trigger] input[i][j] == input[i][j] && (input[i][j] == 's' || input[i][j] == 'h'))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { string_to_int(s.subrange(0, s.len() as int - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn count_sh_subsequences(s: Seq<char>) -> int {\n    count_sh_subsequences_helper(s, 0, 0)\n}\n\nspec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int\n    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0\n{\n    if index == s.len() { 0 }\n    else if index < s.len() && s[index] == 's' {\n        count_sh_subsequences_helper(s, index + 1, s_count + 1)\n    } else if index < s.len() && s[index] == 'h' {\n        s_count + count_sh_subsequences_helper(s, index + 1, s_count)\n    } else {\n        count_sh_subsequences_helper(s, index + 1, s_count)\n    }\n}\n\nspec fn string_ratio(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 } else { count_char(s, 's') * 1000 / s.len() as int }\n}\n\nspec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>\n    decreases strings.len()\n{\n    if strings.len() == 0 { Seq::empty() }\n    else { strings[0] + concatenate_strings(strings.subrange(1, strings.len() as int)) }\n}\n\nspec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < strings.len() ==> \n        #[trigger] strings[i] == strings[i] && #[trigger] strings[j] == strings[j] &&\n        strings[i].len() > 0 && strings[j].len() > 0 ==> \n        string_ratio(strings[i]) <= string_ratio(strings[j])\n}\n\nspec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {\n    arranged.len() == original.len() &&\n    forall|s: Seq<char>| #[trigger] original.contains(s) <==> arranged.contains(s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<Vec<char>>) -> (result: i32)\n    requires valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2209.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 760, "minimize_time_ms": 123209, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 91, "minimized_LOC": 91, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<Seq<char>>) -> bool {\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n\nspec fn count_sh_subsequences(s: Seq<char>) -> int {\n\nspec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int\n    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0\n{\n\nspec fn string_ratio(s: Seq<char>) -> int {\n\nspec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>\n    decreases strings.len()\n{\n\nspec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {\n\nspec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0\n\n    decreases strings.len()\n\n    requires valid_input(input@.map(|i, v: Vec<char>| v@))\n\n    ensures result >= 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 1 &&\n    (forall|i: int| 0 <= i < input[0].len() ==> #[trigger] input[0][i] == input[0][i] && '0' <= input[0][i] <= '9') &&\n    {\n        let n = string_to_int(input[0]);\n        n >= 1 && input.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n ==> #[trigger] input[i] == input[i] && (input[i].len() > 0 &&\n            forall|j: int| 0 <= j < input[i].len() ==> #[trigger] input[i][j] == input[i][j] && (input[i][j] == 's' || input[i][j] == 'h'))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { string_to_int(s.subrange(0, s.len() as int - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn count_sh_subsequences(s: Seq<char>) -> int {\n    count_sh_subsequences_helper(s, 0, 0)\n}\n\nspec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int\n    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0\n{\n    if index == s.len() { 0 }\n    else if index < s.len() && s[index] == 's' {\n        count_sh_subsequences_helper(s, index + 1, s_count + 1)\n    } else if index < s.len() && s[index] == 'h' {\n        s_count + count_sh_subsequences_helper(s, index + 1, s_count)\n    } else {\n        count_sh_subsequences_helper(s, index + 1, s_count)\n    }\n}\n\nspec fn string_ratio(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 } else { count_char(s, 's') * 1000 / s.len() as int }\n}\n\nspec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>\n    decreases strings.len()\n{\n    if strings.len() == 0 { Seq::empty() }\n    else { strings[0] + concatenate_strings(strings.subrange(1, strings.len() as int)) }\n}\n\nspec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < strings.len() ==> \n        #[trigger] strings[i] == strings[i] && #[trigger] strings[j] == strings[j] &&\n        strings[i].len() > 0 && strings[j].len() > 0 ==> \n        string_ratio(strings[i]) <= string_ratio(strings[j])\n}\n\nspec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {\n    arranged.len() == original.len() &&\n    forall|s: Seq<char>| #[trigger] original.contains(s) <==> arranged.contains(s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<Vec<char>>) -> (result: i32)\n    requires valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_222_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn generate_squares() -> Seq<int> {\n    generate_squares_helper(1, 44721)\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n) }\n}\n\nspec fn generate_squares_helper(start: int, end: int) -> Seq<int>\n    decreases end + 1 - start when start <= end\n{\n    if start > end { Seq::empty() }\n    else { seq![start * start].add(generate_squares_helper(start + 1, end)) }\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool\n    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()\n{\n    if pi >= pattern.len() { true }\n    else if ti >= text.len() { false }\n    else if pattern[pi] == text[ti] { \n        is_subsequence_helper(pattern, text, pi + 1, ti + 1)\n    } else {\n        is_subsequence_helper(pattern, text, pi, ti + 1)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 { seq![('0' as u8 + (n % 10) as u8) as char] }\n    else { int_to_string_helper(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char]) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i32)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s@[i] <= '9',\n        s@[0] != '0' || s.len() == 1,\n    ensures \n        result == -1 || result >= 0,\n        result == -1 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) ==> !is_subsequence(int_to_string(sq), s@),\n        result >= 0 ==> exists|sq: int| #![auto] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) && result == s.len() as i32 - int_to_string(sq).len() as i32,\n        result >= 0 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) ==> s.len() as i32 - int_to_string(sq).len() as i32 >= result,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn generate_squares() -> Seq<int> {\n    generate_squares_helper(1, 44721)\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n) }\n}\n\nspec fn generate_squares_helper(start: int, end: int) -> Seq<int>\n    decreases end + 1 - start when start <= end\n{\n    if start > end { Seq::empty() }\n    else { seq![start * start].add(generate_squares_helper(start + 1, end)) }\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool\n    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()\n{\n    if pi >= pattern.len() { true }\n    else if ti >= text.len() { false }\n    else if pattern[pi] == text[ti] { \n        is_subsequence_helper(pattern, text, pi + 1, ti + 1)\n    } else {\n        is_subsequence_helper(pattern, text, pi, ti + 1)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 { seq![('0' as u8 + (n % 10) as u8) as char] }\n    else { int_to_string_helper(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char]) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i32)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s@[i] <= '9',\n        s@[0] != '0' || s.len() == 1,\n    ensures \n        result == -1 || result >= 0,\n        result == -1 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) ==> !is_subsequence(int_to_string(sq), s@),\n        result >= 0 ==> exists|sq: int| #![auto] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) && result == s.len() as i32 - int_to_string(sq).len() as i32,\n        result >= 0 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) ==> s.len() as i32 - int_to_string(sq).len() as i32 >= result,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_222.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 731, "minimize_time_ms": 122691, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn generate_squares() -> Seq<int> {\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn generate_squares_helper(start: int, end: int) -> Seq<int>\n    decreases end + 1 - start when start <= end\n{\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool\n    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()\n{\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n\n    decreases end + 1 - start when start <= end\n\n    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()\n\n    decreases n when n > 0\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn generate_squares() -> Seq<int> {\n    generate_squares_helper(1, 44721)\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n) }\n}\n\nspec fn generate_squares_helper(start: int, end: int) -> Seq<int>\n    decreases end + 1 - start when start <= end\n{\n    if start > end { Seq::empty() }\n    else { seq![start * start].add(generate_squares_helper(start + 1, end)) }\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool\n    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()\n{\n    if pi >= pattern.len() { true }\n    else if ti >= text.len() { false }\n    else if pattern[pi] == text[ti] { \n        is_subsequence_helper(pattern, text, pi + 1, ti + 1)\n    } else {\n        is_subsequence_helper(pattern, text, pi, ti + 1)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 { seq![('0' as u8 + (n % 10) as u8) as char] }\n    else { int_to_string_helper(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char]) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i32)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s@[i] <= '9',\n        s@[0] != '0' || s.len() == 1,\n    ensures \n        result == -1 || result >= 0,\n        result == -1 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) ==> !is_subsequence(int_to_string(sq), s@),\n        result >= 0 ==> exists|sq: int| #![auto] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) && result == s.len() as i32 - int_to_string(sq).len() as i32,\n        result >= 0 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) ==> s.len() as i32 - int_to_string(sq).len() as i32 >= result,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2220_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {\n    n >= 2 && k >= 1 && m >= 1 && emotes.len() == n &&\n    forall|i: int| 0 <= i < emotes.len() ==> emotes[i] >= 1\n}\n\nspec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {\n    let k_plus_1 = k + 1;\n    let total = m / k_plus_1;\n    let remainder = m % k_plus_1;\n\n    let max_val = max_value(emotes);\n    let second_max_val = second_max_value(emotes);\n    remainder * max_val + max_val * (total * k) + second_max_val * total\n}\n\nspec fn max_value(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] >= max_value(s.skip(1)) {\n        s[0]\n    } else if s.len() > 1 {\n        max_value(s.skip(1))\n    } else {\n        s[0]\n    }\n}\n\nspec fn second_max_value(s: Seq<int>) -> int {\n    let max_val = max_value(s);\n    let filtered = filter_out(s, max_val, 1);\n    if filtered.len() > 0 {\n        max_value(filtered)\n    } else {\n        1\n    }\n}\n\nspec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>\n    decreases s.len(), count\n{\n    if s.len() == 0 || count == 0 {\n        s\n    } else if s[0] == val {\n        filter_out(s.skip(1), val, count - 1)\n    } else {\n        seq![s[0]].add(filter_out(s.skip(1), val, count))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, emotes: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, k as int, \n            seq![].add(emotes@.map(|i: int, x: i8| x as int)))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {\n    n >= 2 && k >= 1 && m >= 1 && emotes.len() == n &&\n    forall|i: int| 0 <= i < emotes.len() ==> emotes[i] >= 1\n}\n\nspec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {\n    let k_plus_1 = k + 1;\n    let total = m / k_plus_1;\n    let remainder = m % k_plus_1;\n\n    let max_val = max_value(emotes);\n    let second_max_val = second_max_value(emotes);\n    remainder * max_val + max_val * (total * k) + second_max_val * total\n}\n\nspec fn max_value(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] >= max_value(s.skip(1)) {\n        s[0]\n    } else if s.len() > 1 {\n        max_value(s.skip(1))\n    } else {\n        s[0]\n    }\n}\n\nspec fn second_max_value(s: Seq<int>) -> int {\n    let max_val = max_value(s);\n    let filtered = filter_out(s, max_val, 1);\n    if filtered.len() > 0 {\n        max_value(filtered)\n    } else {\n        1\n    }\n}\n\nspec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>\n    decreases s.len(), count\n{\n    if s.len() == 0 || count == 0 {\n        s\n    } else if s[0] == val {\n        filter_out(s.skip(1), val, count - 1)\n    } else {\n        seq![s[0]].add(filter_out(s.skip(1), val, count))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, emotes: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, k as int, \n            seq![].add(emotes@.map(|i: int, x: i8| x as int)))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2220.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 752, "minimize_time_ms": 122730, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 79, "minimized_LOC": 79, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {\n\nspec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {\n\nspec fn max_value(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn second_max_value(s: Seq<int>) -> int {\n\nspec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>\n    decreases s.len(), count\n{\n\n    decreases s.len()\n\n    decreases s.len(), count\n\n    requires \n\n    ensures result >= 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {\n    n >= 2 && k >= 1 && m >= 1 && emotes.len() == n &&\n    forall|i: int| 0 <= i < emotes.len() ==> emotes[i] >= 1\n}\n\nspec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {\n    let k_plus_1 = k + 1;\n    let total = m / k_plus_1;\n    let remainder = m % k_plus_1;\n\n    let max_val = max_value(emotes);\n    let second_max_val = second_max_value(emotes);\n    remainder * max_val + max_val * (total * k) + second_max_val * total\n}\n\nspec fn max_value(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] >= max_value(s.skip(1)) {\n        s[0]\n    } else if s.len() > 1 {\n        max_value(s.skip(1))\n    } else {\n        s[0]\n    }\n}\n\nspec fn second_max_value(s: Seq<int>) -> int {\n    let max_val = max_value(s);\n    let filtered = filter_out(s, max_val, 1);\n    if filtered.len() > 0 {\n        max_value(filtered)\n    } else {\n        1\n    }\n}\n\nspec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>\n    decreases s.len(), count\n{\n    if s.len() == 0 || count == 0 {\n        s\n    } else if s[0] == val {\n        filter_out(s.skip(1), val, count - 1)\n    } else {\n        seq![s[0]].add(filter_out(s.skip(1), val, count))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, emotes: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, k as int, \n            seq![].add(emotes@.map(|i: int, x: i8| x as int)))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2238_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 3 && n <= 101 && n % 2 == 1\n}\n\nspec fn valid_result(result: Seq<String>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() == n\n}\n\nspec fn repeat_char(c: char, count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 { Seq::empty() }\n    else { repeat_char(c, count - 1).push(c) }\n}\n\nspec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {\n    result.len() == n ==> {\n        let magic = (n - 1) / 2;\n        \n        (forall|i: int| 0 <= i <= magic && i < result.len() ==> {\n            let stars = magic - i;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        }) &&\n        \n        (forall|i: int| magic + 1 <= i < n && i < result.len() ==> {\n            let u = i - magic;\n            let stars = u;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize) -> (result: Vec<String>)\n    requires \n        valid_input(n as int)\n    ensures \n        valid_result(result@, n as int),\n        correct_diamond_pattern(result@, n as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 3 && n <= 101 && n % 2 == 1\n}\n\nspec fn valid_result(result: Seq<String>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() == n\n}\n\nspec fn repeat_char(c: char, count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 { Seq::empty() }\n    else { repeat_char(c, count - 1).push(c) }\n}\n\nspec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {\n    result.len() == n ==> {\n        let magic = (n - 1) / 2;\n        \n        (forall|i: int| 0 <= i <= magic && i < result.len() ==> {\n            let stars = magic - i;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        }) &&\n        \n        (forall|i: int| magic + 1 <= i < n && i < result.len() ==> {\n            let u = i - magic;\n            let stars = u;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize) -> (result: Vec<String>)\n    requires \n        valid_input(n as int)\n    ensures \n        valid_result(result@, n as int),\n        correct_diamond_pattern(result@, n as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2238.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 794, "minimize_time_ms": 154073, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn valid_result(result: Seq<String>, n: int) -> bool {\n\nspec fn repeat_char(c: char, count: int) -> Seq<char>\n    decreases count\n{\n\nspec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {\n\n    decreases count\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 3 && n <= 101 && n % 2 == 1\n}\n\nspec fn valid_result(result: Seq<String>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() == n\n}\n\nspec fn repeat_char(c: char, count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 { Seq::empty() }\n    else { repeat_char(c, count - 1).push(c) }\n}\n\nspec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {\n    result.len() == n ==> {\n        let magic = (n - 1) / 2;\n        \n        (forall|i: int| 0 <= i <= magic && i < result.len() ==> {\n            let stars = magic - i;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        }) &&\n        \n        (forall|i: int| magic + 1 <= i < n && i < result.len() ==> {\n            let u = i - magic;\n            let stars = u;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize) -> (result: Vec<String>)\n    requires \n        valid_input(n as int)\n    ensures \n        valid_result(result@, n as int),\n        correct_diamond_pattern(result@, n as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_228_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn minimum(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] <= minimum(s.subrange(1, s.len() as int)) {\n        s[0]\n    } else {\n        minimum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_occurrences(s: Seq<int>, val: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == val { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), val)\n    }\n}\n\nspec fn valid_input(n: int, piles: Seq<int>) -> bool {\n    n >= 2 && n % 2 == 0 && piles.len() == n && forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, piles: Vec<i8>) -> (result: &'static str)\n    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))\n    ensures result == \"Alice\" || result == \"Bob\"\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Alice\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn minimum(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] <= minimum(s.subrange(1, s.len() as int)) {\n        s[0]\n    } else {\n        minimum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_occurrences(s: Seq<int>, val: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == val { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), val)\n    }\n}\n\nspec fn valid_input(n: int, piles: Seq<int>) -> bool {\n    n >= 2 && n % 2 == 0 && piles.len() == n && forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, piles: Vec<i8>) -> (result: &'static str)\n    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))\n    ensures result == \"Alice\" || result == \"Bob\"\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Alice\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_228.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 735, "minimize_time_ms": 153908, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn minimum(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n\nspec fn count_occurrences(s: Seq<int>, val: int) -> int\n    decreases s.len()\n{\n\nspec fn valid_input(n: int, piles: Seq<int>) -> bool {\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))\n\n    ensures result == \"Alice\" || result == \"Bob\""}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn minimum(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] <= minimum(s.subrange(1, s.len() as int)) {\n        s[0]\n    } else {\n        minimum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_occurrences(s: Seq<int>, val: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == val { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), val)\n    }\n}\n\nspec fn valid_input(n: int, piles: Seq<int>) -> bool {\n    n >= 2 && n % 2 == 0 && piles.len() == n && forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, piles: Vec<i8>) -> (result: &'static str)\n    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))\n    ensures result == \"Alice\" || result == \"Bob\"\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Alice\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n      fn main() {\n    }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2293_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    input@.len() > 0\n    /* Additional validation logic would go here in a real implementation */\n}\n\nspec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    Set::empty() /* Placeholder - actual implementation would parse input */\n}\n\nspec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    let all_stores: Set<int> = Set::new(|i: int| 1 <= i <= n);\n    let dora_set = extract_dora_set(input, day_index, n);\n    all_stores.difference(dora_set)\n}\n\nspec fn solution_exists(input: &str) -> bool\n    recommends valid_input(input)\n{\n    /* Logic to check if a valid assignment exists */\n    true /* Placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        valid_input(input),\n    ensures\n        result@ =~= \"possible\"@ || result@ =~= \"impossible\"@,\n        (result@ =~= \"possible\"@) <==> solution_exists(input),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"impossible\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    input@.len() > 0\n    /* Additional validation logic would go here in a real implementation */\n}\n\nspec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    Set::empty() /* Placeholder - actual implementation would parse input */\n}\n\nspec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    let all_stores: Set<int> = Set::new(|i: int| 1 <= i <= n);\n    let dora_set = extract_dora_set(input, day_index, n);\n    all_stores.difference(dora_set)\n}\n\nspec fn solution_exists(input: &str) -> bool\n    recommends valid_input(input)\n{\n    /* Logic to check if a valid assignment exists */\n    true /* Placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        valid_input(input),\n    ensures\n        result@ =~= \"possible\"@ || result@ =~= \"impossible\"@,\n        (result@ =~= \"possible\"@) <==> solution_exists(input),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"impossible\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2293.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 719, "minimize_time_ms": 122888, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: &str) -> bool {\n\nspec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n\nspec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n\nspec fn solution_exists(input: &str) -> bool\n    recommends valid_input(input)\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    input@.len() > 0\n    /* Additional validation logic would go here in a real implementation */\n}\n\nspec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    Set::empty() /* Placeholder - actual implementation would parse input */\n}\n\nspec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    let all_stores: Set<int> = Set::new(|i: int| 1 <= i <= n);\n    let dora_set = extract_dora_set(input, day_index, n);\n    all_stores.difference(dora_set)\n}\n\nspec fn solution_exists(input: &str) -> bool\n    recommends valid_input(input)\n{\n    /* Logic to check if a valid assignment exists */\n    true /* Placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        valid_input(input),\n    ensures\n        result@ =~= \"possible\"@ || result@ =~= \"impossible\"@,\n        (result@ =~= \"possible\"@) <==> solution_exists(input),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"impossible\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2297_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_query(query: (int, int)) -> bool {\n    query.0 >= 1 && query.0 <= query.1\n}\n\nspec fn valid_input(queries: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn array_element(i: int) -> int\n    recommends i >= 1\n{\n    i * (if i % 2 == 1 { -1 } else { 1 })\n}\n\nspec fn range_sum(l: int, r: int) -> int\n    recommends l >= 1\n    decreases r - l + 1\n{\n    if l > r { 0 } else { array_element(l) + range_sum(l + 1, r) }\n}\n\nspec fn prefix_sum(k: int) -> int {\n    if k % 2 == 0 { k / 2 } else { -(k + 1) / 2 }\n}\n\nspec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool\n    recommends valid_input(queries)\n{\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == prefix_sum(queries[i].1) - prefix_sum(queries[i].0 - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))\n    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_query(query: (int, int)) -> bool {\n    query.0 >= 1 && query.0 <= query.1\n}\n\nspec fn valid_input(queries: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn array_element(i: int) -> int\n    recommends i >= 1\n{\n    i * (if i % 2 == 1 { -1 } else { 1 })\n}\n\nspec fn range_sum(l: int, r: int) -> int\n    recommends l >= 1\n    decreases r - l + 1\n{\n    if l > r { 0 } else { array_element(l) + range_sum(l + 1, r) }\n}\n\nspec fn prefix_sum(k: int) -> int {\n    if k % 2 == 0 { k / 2 } else { -(k + 1) / 2 }\n}\n\nspec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool\n    recommends valid_input(queries)\n{\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == prefix_sum(queries[i].1) - prefix_sum(queries[i].0 - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))\n    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2297.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 795, "minimize_time_ms": 122765, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_query(query: (int, int)) -> bool {\n\nspec fn valid_input(queries: Seq<(int, int)>) -> bool {\n\nspec fn array_element(i: int) -> int\n    recommends i >= 1\n{\n\nspec fn range_sum(l: int, r: int) -> int\n    recommends l >= 1\n    decreases r - l + 1\n{\n\nspec fn prefix_sum(k: int) -> int {\n\nspec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool\n    recommends valid_input(queries)\n{\n\n    decreases r - l + 1\n\n    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))\n\n    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_query(query: (int, int)) -> bool {\n    query.0 >= 1 && query.0 <= query.1\n}\n\nspec fn valid_input(queries: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn array_element(i: int) -> int\n    recommends i >= 1\n{\n    i * (if i % 2 == 1 { -1 } else { 1 })\n}\n\nspec fn range_sum(l: int, r: int) -> int\n    recommends l >= 1\n    decreases r - l + 1\n{\n    if l > r { 0 } else { array_element(l) + range_sum(l + 1, r) }\n}\n\nspec fn prefix_sum(k: int) -> int {\n    if k % 2 == 0 { k / 2 } else { -(k + 1) / 2 }\n}\n\nspec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool\n    recommends valid_input(queries)\n{\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == prefix_sum(queries[i].1) - prefix_sum(queries[i].0 - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))\n    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2308_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 && \n    is_valid_number(lines[0]) &&\n    {\n        let t = string_to_int(lines[0]);\n        t >= 0 && lines.len() >= 2 * t + 1 &&\n        forall|i: int| 1 <= i < 2 * t + 1 ==> #[trigger] lines.len() > i && is_binary_string(lines[i]) && contains_one(lines[i])\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] is_valid_number(output_lines[i])\n    }\n}\n\nspec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && 1 + 2*i < lines.len() && 2 + 2*i < lines.len() ==> {\n            let x = lines[1 + 2*i];\n            let y = lines[2 + 2*i];\n            let rev_x = reverse(x);\n            let rev_y = reverse(y);\n            let start = index_of(rev_y, '1');\n            start >= 0 &&\n            {\n                let offset = index_of_from(rev_x, '1', start);\n                #[trigger] string_to_int(output_lines[i]) == offset\n            }\n        }\n    }\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == '0' || s.index(i) == '1'\n}\n\nspec fn contains_one(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && #[trigger] s.index(i) == '1'\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '0' && s.index(i) <= '9'\n}\n\n/* Helper functions */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    arbitrary()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    arbitrary()\n}\n\nspec fn reverse(s: Seq<char>) -> Seq<char> {\n    arbitrary()\n}\n\nspec fn index_of(s: Seq<char>, c: char) -> int {\n    arbitrary()\n}\n\nspec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {\n    arbitrary()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (output: String)\n    requires\n        input@.len() > 0,\n        input@.index(input@.len() as int - 1) == '\\n',\n        valid_input(input@),\n    ensures\n        valid_output(output@, input@),\n        output@.len() > 0 ==> output@.index(output@.len() as int - 1) != '\\n',\n        correct_computation(output@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 && \n    is_valid_number(lines[0]) &&\n    {\n        let t = string_to_int(lines[0]);\n        t >= 0 && lines.len() >= 2 * t + 1 &&\n        forall|i: int| 1 <= i < 2 * t + 1 ==> #[trigger] lines.len() > i && is_binary_string(lines[i]) && contains_one(lines[i])\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] is_valid_number(output_lines[i])\n    }\n}\n\nspec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && 1 + 2*i < lines.len() && 2 + 2*i < lines.len() ==> {\n            let x = lines[1 + 2*i];\n            let y = lines[2 + 2*i];\n            let rev_x = reverse(x);\n            let rev_y = reverse(y);\n            let start = index_of(rev_y, '1');\n            start >= 0 &&\n            {\n                let offset = index_of_from(rev_x, '1', start);\n                #[trigger] string_to_int(output_lines[i]) == offset\n            }\n        }\n    }\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == '0' || s.index(i) == '1'\n}\n\nspec fn contains_one(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && #[trigger] s.index(i) == '1'\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '0' && s.index(i) <= '9'\n}\n\n/* Helper functions */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    arbitrary()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    arbitrary()\n}\n\nspec fn reverse(s: Seq<char>) -> Seq<char> {\n    arbitrary()\n}\n\nspec fn index_of(s: Seq<char>, c: char) -> int {\n    arbitrary()\n}\n\nspec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {\n    arbitrary()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (output: String)\n    requires\n        input@.len() > 0,\n        input@.index(input@.len() as int - 1) == '\\n',\n        valid_input(input@),\n    ensures\n        valid_output(output@, input@),\n        output@.len() > 0 ==> output@.index(output@.len() as int - 1) != '\\n',\n        correct_computation(output@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2308.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 773, "minimize_time_ms": 185361, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 105, "minimized_LOC": 105, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n\nspec fn contains_one(s: Seq<char>) -> bool {\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn reverse(s: Seq<char>) -> Seq<char> {\n\nspec fn index_of(s: Seq<char>, c: char) -> int {\n\nspec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 && \n    is_valid_number(lines[0]) &&\n    {\n        let t = string_to_int(lines[0]);\n        t >= 0 && lines.len() >= 2 * t + 1 &&\n        forall|i: int| 1 <= i < 2 * t + 1 ==> #[trigger] lines.len() > i && is_binary_string(lines[i]) && contains_one(lines[i])\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] is_valid_number(output_lines[i])\n    }\n}\n\nspec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && 1 + 2*i < lines.len() && 2 + 2*i < lines.len() ==> {\n            let x = lines[1 + 2*i];\n            let y = lines[2 + 2*i];\n            let rev_x = reverse(x);\n            let rev_y = reverse(y);\n            let start = index_of(rev_y, '1');\n            start >= 0 &&\n            {\n                let offset = index_of_from(rev_x, '1', start);\n                #[trigger] string_to_int(output_lines[i]) == offset\n            }\n        }\n    }\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == '0' || s.index(i) == '1'\n}\n\nspec fn contains_one(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && #[trigger] s.index(i) == '1'\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '0' && s.index(i) <= '9'\n}\n\n/* Helper functions */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    arbitrary()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    arbitrary()\n}\n\nspec fn reverse(s: Seq<char>) -> Seq<char> {\n    arbitrary()\n}\n\nspec fn index_of(s: Seq<char>, c: char) -> int {\n    arbitrary()\n}\n\nspec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {\n    arbitrary()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (output: String)\n    requires\n        input@.len() > 0,\n        input@.index(input@.len() as int - 1) == '\\n',\n        valid_input(input@),\n    ensures\n        valid_output(output@, input@),\n        output@.len() > 0 ==> output@.index(output@.len() as int - 1) != '\\n',\n        correct_computation(output@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2320_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_character(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == c { 1 as int } else { 0 as int }) + count_character(s.skip(1), c)\n    }\n}\n\nspec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && \n    (forall|c: char| count_character(s, c) == count_character(t, c))\n}\n\nspec fn find_next_match(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        s.len() as int\n    } else if s[start] == c {\n        start\n    } else {\n        find_next_match(s, c, start + 1)\n    }\n}\n\nspec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool\n    decreases j - i + 1, s.len() - k\n{\n    if i > j {\n        true\n    } else if k >= s.len() {\n        false\n    } else {\n        let next_k = find_next_match(s, t[j], k);\n        if next_k >= s.len() {\n            false\n        } else if i == j {\n            true\n        } else {\n            can_match_substring(s, t, i, j-1, next_k+1)\n        }\n    }\n}\n\nspec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int\n    decreases t.len() - i, t.len() - j\n{\n    if i >= t.len() {\n        max_so_far\n    } else if j >= t.len() {\n        max_preservable_length(s, t, i+1, i+1, max_so_far)\n    } else {\n        let current_len = j - i + 1;\n        let can_match = can_match_substring(s, t, i, j, 0);\n        let new_max = if can_match && current_len > max_so_far { current_len } else { max_so_far };\n        max_preservable_length(s, t, i, j+1, new_max)\n    }\n}\n\nspec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        max_preservable_length(s, t, 0, 0, 0)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, t: Vec<char>) -> (result: i32)\n    requires \n        s.len() == t.len(),\n        s.len() >= 0,\n    ensures \n        result == -1 <==> !has_same_character_counts(s@, t@),\n        result >= -1,\n        result != -1 ==> 0 <= result <= s.len() as i32,\n        result != -1 ==> has_same_character_counts(s@, t@),\n        result != -1 ==> result == s.len() as i32 - max_longest_subsequence(s@, t@) as i32,\n        s.len() == 0 ==> result == 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_character(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == c { 1 as int } else { 0 as int }) + count_character(s.skip(1), c)\n    }\n}\n\nspec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && \n    (forall|c: char| count_character(s, c) == count_character(t, c))\n}\n\nspec fn find_next_match(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        s.len() as int\n    } else if s[start] == c {\n        start\n    } else {\n        find_next_match(s, c, start + 1)\n    }\n}\n\nspec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool\n    decreases j - i + 1, s.len() - k\n{\n    if i > j {\n        true\n    } else if k >= s.len() {\n        false\n    } else {\n        let next_k = find_next_match(s, t[j], k);\n        if next_k >= s.len() {\n            false\n        } else if i == j {\n            true\n        } else {\n            can_match_substring(s, t, i, j-1, next_k+1)\n        }\n    }\n}\n\nspec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int\n    decreases t.len() - i, t.len() - j\n{\n    if i >= t.len() {\n        max_so_far\n    } else if j >= t.len() {\n        max_preservable_length(s, t, i+1, i+1, max_so_far)\n    } else {\n        let current_len = j - i + 1;\n        let can_match = can_match_substring(s, t, i, j, 0);\n        let new_max = if can_match && current_len > max_so_far { current_len } else { max_so_far };\n        max_preservable_length(s, t, i, j+1, new_max)\n    }\n}\n\nspec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        max_preservable_length(s, t, 0, 0, 0)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, t: Vec<char>) -> (result: i32)\n    requires \n        s.len() == t.len(),\n        s.len() >= 0,\n    ensures \n        result == -1 <==> !has_same_character_counts(s@, t@),\n        result >= -1,\n        result != -1 ==> 0 <= result <= s.len() as i32,\n        result != -1 ==> has_same_character_counts(s@, t@),\n        result != -1 ==> result == s.len() as i32 - max_longest_subsequence(s@, t@) as i32,\n        s.len() == 0 ==> result == 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2320.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 771, "minimize_time_ms": 122637, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 105, "minimized_LOC": 105, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_character(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n\nspec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {\n\nspec fn find_next_match(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n\nspec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool\n    decreases j - i + 1, s.len() - k\n{\n\nspec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int\n    decreases t.len() - i, t.len() - j\n{\n\nspec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int\n{\n\n    decreases s.len()\n\n    decreases s.len() - start\n\n    decreases j - i + 1, s.len() - k\n\n    decreases t.len() - i, t.len() - j\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_character(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == c { 1 as int } else { 0 as int }) + count_character(s.skip(1), c)\n    }\n}\n\nspec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && \n    (forall|c: char| count_character(s, c) == count_character(t, c))\n}\n\nspec fn find_next_match(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        s.len() as int\n    } else if s[start] == c {\n        start\n    } else {\n        find_next_match(s, c, start + 1)\n    }\n}\n\nspec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool\n    decreases j - i + 1, s.len() - k\n{\n    if i > j {\n        true\n    } else if k >= s.len() {\n        false\n    } else {\n        let next_k = find_next_match(s, t[j], k);\n        if next_k >= s.len() {\n            false\n        } else if i == j {\n            true\n        } else {\n            can_match_substring(s, t, i, j-1, next_k+1)\n        }\n    }\n}\n\nspec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int\n    decreases t.len() - i, t.len() - j\n{\n    if i >= t.len() {\n        max_so_far\n    } else if j >= t.len() {\n        max_preservable_length(s, t, i+1, i+1, max_so_far)\n    } else {\n        let current_len = j - i + 1;\n        let can_match = can_match_substring(s, t, i, j, 0);\n        let new_max = if can_match && current_len > max_so_far { current_len } else { max_so_far };\n        max_preservable_length(s, t, i, j+1, new_max)\n    }\n}\n\nspec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        max_preservable_length(s, t, 0, 0, 0)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, t: Vec<char>) -> (result: i32)\n    requires \n        s.len() == t.len(),\n        s.len() >= 0,\n    ensures \n        result == -1 <==> !has_same_character_counts(s@, t@),\n        result >= -1,\n        result != -1 ==> 0 <= result <= s.len() as i32,\n        result != -1 ==> has_same_character_counts(s@, t@),\n        result != -1 ==> result == s.len() as i32 - max_longest_subsequence(s@, t@) as i32,\n        s.len() == 0 ==> result == 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2330_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\npub enum Result {\n    Impossible,\n    Possible { cost: int, edges: Seq<(int, int)> }\n}\n\nspec fn seq_sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + seq_sum(s.skip(1))\n    }\n}\n\nspec fn seq_sum_first(s: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n > 0 && n - 1 < s.len() {\n        s[n-1] + seq_sum_first(s, n-1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index(weights: Seq<int>) -> int {\n    if weights.len() > 0 {\n        min_index_helper(weights, 0, 1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if weights[next] < weights[current_min] {\n        min_index_helper(weights, next, next + 1)\n    } else {\n        min_index_helper(weights, current_min, next + 1)\n    }\n}\n\nspec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {\n    if weights.len() > 1 && 0 <= exclude < weights.len() {\n        let first_valid = if exclude == 0 { 1 } else { 0 };\n        min_index_excluding_helper(weights, exclude, first_valid, 0)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if next == exclude {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    } else if weights[next] < weights[current_min] {\n        min_index_excluding_helper(weights, exclude, next, next + 1)\n    } else {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: i8, cases: Vec<(i8, i8, Vec<i8>)>) -> (results: Vec<Result>)\n    requires \n        t >= 0,\n        cases.len() == t as nat,\n        forall|i: int| #![auto] 0 <= i < t as int ==> \n            cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2@.len() == cases[i].0 as nat\n    ensures \n        results@.len() == t as nat\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\npub enum Result {\n    Impossible,\n    Possible { cost: int, edges: Seq<(int, int)> }\n}\n\nspec fn seq_sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + seq_sum(s.skip(1))\n    }\n}\n\nspec fn seq_sum_first(s: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n > 0 && n - 1 < s.len() {\n        s[n-1] + seq_sum_first(s, n-1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index(weights: Seq<int>) -> int {\n    if weights.len() > 0 {\n        min_index_helper(weights, 0, 1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if weights[next] < weights[current_min] {\n        min_index_helper(weights, next, next + 1)\n    } else {\n        min_index_helper(weights, current_min, next + 1)\n    }\n}\n\nspec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {\n    if weights.len() > 1 && 0 <= exclude < weights.len() {\n        let first_valid = if exclude == 0 { 1 } else { 0 };\n        min_index_excluding_helper(weights, exclude, first_valid, 0)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if next == exclude {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    } else if weights[next] < weights[current_min] {\n        min_index_excluding_helper(weights, exclude, next, next + 1)\n    } else {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: i8, cases: Vec<(i8, i8, Vec<i8>)>) -> (results: Vec<Result>)\n    requires \n        t >= 0,\n        cases.len() == t as nat,\n        forall|i: int| #![auto] 0 <= i < t as int ==> \n            cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2@.len() == cases[i].0 as nat\n    ensures \n        results@.len() == t as nat\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2330.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 792, "minimize_time_ms": 123543, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 102, "minimized_LOC": 102, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn seq_sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn seq_sum_first(s: Seq<int>, n: int) -> int\n    decreases n\n{\n\nspec fn min_index(weights: Seq<int>) -> int {\n\nspec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n\nspec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {\n\nspec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n\n    decreases s.len()\n\n    decreases n\n\n    decreases weights.len() - next\n\n    decreases weights.len() - next\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\npub enum Result {\n    Impossible,\n    Possible { cost: int, edges: Seq<(int, int)> }\n}\n\nspec fn seq_sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + seq_sum(s.skip(1))\n    }\n}\n\nspec fn seq_sum_first(s: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n > 0 && n - 1 < s.len() {\n        s[n-1] + seq_sum_first(s, n-1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index(weights: Seq<int>) -> int {\n    if weights.len() > 0 {\n        min_index_helper(weights, 0, 1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if weights[next] < weights[current_min] {\n        min_index_helper(weights, next, next + 1)\n    } else {\n        min_index_helper(weights, current_min, next + 1)\n    }\n}\n\nspec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {\n    if weights.len() > 1 && 0 <= exclude < weights.len() {\n        let first_valid = if exclude == 0 { 1 } else { 0 };\n        min_index_excluding_helper(weights, exclude, first_valid, 0)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if next == exclude {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    } else if weights[next] < weights[current_min] {\n        min_index_excluding_helper(weights, exclude, next, next + 1)\n    } else {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: i8, cases: Vec<(i8, i8, Vec<i8>)>) -> (results: Vec<Result>)\n    requires \n        t >= 0,\n        cases.len() == t as nat,\n        forall|i: int| #![auto] 0 <= i < t as int ==> \n            cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2@.len() == cases[i].0 as nat\n    ensures \n        results@.len() == t as nat\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2340_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {\n    h >= 1 && n >= 1 && platforms.len() >= n && n > 0 && platforms.len() > 0 && platforms[0] == h\n}\n\nspec fn valid_crystal_count(crystals: int, n: int) -> bool {\n    crystals >= 0 && crystals <= n - 1\n}\n\nspec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {\n    if platforms.len() >= 1 && platforms[0] == h && h >= 1 {\n        if platforms.len() == 1 {\n            0\n        } else {\n            count_crystals_needed_up_to(h, platforms.push(0), (platforms.len() - 1) as int)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            0\n        } else {\n            let cur_pos = simulate_position_up_to(h, arr, up_to - 1);\n            let prev_crystals = count_crystals_needed_up_to(h, arr, up_to - 1);\n            if cur_pos == arr[up_to as int] {\n                prev_crystals\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                prev_crystals\n            } else {\n                prev_crystals + 1\n            }\n        }\n    } else {\n        0\n    }\n}\n\nspec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            h\n        } else {\n            let prev_pos = simulate_position_up_to(h, arr, up_to - 1);\n            if prev_pos == arr[up_to as int] {\n                prev_pos\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                arr[up_to as int] - 1\n            } else {\n                prev_pos\n            }\n        }\n    } else {\n        h\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires input@.len() > 0\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {\n    h >= 1 && n >= 1 && platforms.len() >= n && n > 0 && platforms.len() > 0 && platforms[0] == h\n}\n\nspec fn valid_crystal_count(crystals: int, n: int) -> bool {\n    crystals >= 0 && crystals <= n - 1\n}\n\nspec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {\n    if platforms.len() >= 1 && platforms[0] == h && h >= 1 {\n        if platforms.len() == 1 {\n            0\n        } else {\n            count_crystals_needed_up_to(h, platforms.push(0), (platforms.len() - 1) as int)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            0\n        } else {\n            let cur_pos = simulate_position_up_to(h, arr, up_to - 1);\n            let prev_crystals = count_crystals_needed_up_to(h, arr, up_to - 1);\n            if cur_pos == arr[up_to as int] {\n                prev_crystals\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                prev_crystals\n            } else {\n                prev_crystals + 1\n            }\n        }\n    } else {\n        0\n    }\n}\n\nspec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            h\n        } else {\n            let prev_pos = simulate_position_up_to(h, arr, up_to - 1);\n            if prev_pos == arr[up_to as int] {\n                prev_pos\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                arr[up_to as int] - 1\n            } else {\n                prev_pos\n            }\n        }\n    } else {\n        h\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires input@.len() > 0\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2340.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 749, "minimize_time_ms": 123099, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 88, "minimized_LOC": 88, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::string::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {\n\nspec fn valid_crystal_count(crystals: int, n: int) -> bool {\n\nspec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {\n\nspec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n\nspec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n\n    decreases up_to\n\n    decreases up_to\n\n    requires input@.len() > 0\n\n    ensures result@.len() >= 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {\n    h >= 1 && n >= 1 && platforms.len() >= n && n > 0 && platforms.len() > 0 && platforms[0] == h\n}\n\nspec fn valid_crystal_count(crystals: int, n: int) -> bool {\n    crystals >= 0 && crystals <= n - 1\n}\n\nspec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {\n    if platforms.len() >= 1 && platforms[0] == h && h >= 1 {\n        if platforms.len() == 1 {\n            0\n        } else {\n            count_crystals_needed_up_to(h, platforms.push(0), (platforms.len() - 1) as int)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            0\n        } else {\n            let cur_pos = simulate_position_up_to(h, arr, up_to - 1);\n            let prev_crystals = count_crystals_needed_up_to(h, arr, up_to - 1);\n            if cur_pos == arr[up_to as int] {\n                prev_crystals\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                prev_crystals\n            } else {\n                prev_crystals + 1\n            }\n        }\n    } else {\n        0\n    }\n}\n\nspec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            h\n        } else {\n            let prev_pos = simulate_position_up_to(h, arr, up_to - 1);\n            if prev_pos == arr[up_to as int] {\n                prev_pos\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                arr[up_to as int] - 1\n            } else {\n                prev_pos\n            }\n        }\n    } else {\n        h\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires input@.len() > 0\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_235_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn vasya_eats_with_strategy(n: int, k: int) -> int\n    decreases n\n{\n    if n <= 0 || k < 1 { \n        0 \n    } else {\n        let cur = if n < k { n } else { k };\n        let remaining_after_vasya = n - cur;\n        let remaining_after_petya = remaining_after_vasya - remaining_after_vasya / 10;\n        cur + vasya_eats_with_strategy(remaining_after_petya, k)\n    }\n}\n\nspec fn is_minimal_solution(n: int, k: int) -> bool {\n    valid_input(n) && k >= 1 && \n    vasya_eats_with_strategy(n, k) * 2 >= n &&\n    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures\n        1 <= result as int <= n as int,\n        is_minimal_solution(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn vasya_eats_with_strategy(n: int, k: int) -> int\n    decreases n\n{\n    if n <= 0 || k < 1 { \n        0 \n    } else {\n        let cur = if n < k { n } else { k };\n        let remaining_after_vasya = n - cur;\n        let remaining_after_petya = remaining_after_vasya - remaining_after_vasya / 10;\n        cur + vasya_eats_with_strategy(remaining_after_petya, k)\n    }\n}\n\nspec fn is_minimal_solution(n: int, k: int) -> bool {\n    valid_input(n) && k >= 1 && \n    vasya_eats_with_strategy(n, k) * 2 >= n &&\n    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures\n        1 <= result as int <= n as int,\n        is_minimal_solution(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_235.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 654, "minimize_time_ms": 122435, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn vasya_eats_with_strategy(n: int, k: int) -> int\n    decreases n\n{\n\nspec fn is_minimal_solution(n: int, k: int) -> bool {\n\n    decreases n\n\n    requires valid_input(n as int)\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn vasya_eats_with_strategy(n: int, k: int) -> int\n    decreases n\n{\n    if n <= 0 || k < 1 { \n        0 \n    } else {\n        let cur = if n < k { n } else { k };\n        let remaining_after_vasya = n - cur;\n        let remaining_after_petya = remaining_after_vasya - remaining_after_vasya / 10;\n        cur + vasya_eats_with_strategy(remaining_after_petya, k)\n    }\n}\n\nspec fn is_minimal_solution(n: int, k: int) -> bool {\n    valid_input(n) && k >= 1 && \n    vasya_eats_with_strategy(n, k) * 2 >= n &&\n    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures\n        1 <= result as int <= n as int,\n        is_minimal_solution(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2353_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && d >= 0\n}\n\nspec fn first_alarm_sufficient(a: int, b: int) -> bool {\n    a <= b\n}\n\nspec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c <= d\n}\n\nspec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c > d\n}\n\nspec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {\n    let remaining = a - b;\n    let cycles = (remaining - 1) / (c - d) + 1;\n    b + c * cycles\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int, d as int)\n    ensures \n        first_alarm_sufficient(a as int, b as int) ==> result as int == b as int,\n        never_wakes(a as int, b as int, c as int, d as int) ==> result == -1,\n        eventually_wakes(a as int, b as int, c as int, d as int) ==> result as int == calculate_wake_time(a as int, b as int, c as int, d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && d >= 0\n}\n\nspec fn first_alarm_sufficient(a: int, b: int) -> bool {\n    a <= b\n}\n\nspec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c <= d\n}\n\nspec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c > d\n}\n\nspec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {\n    let remaining = a - b;\n    let cycles = (remaining - 1) / (c - d) + 1;\n    b + c * cycles\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int, d as int)\n    ensures \n        first_alarm_sufficient(a as int, b as int) ==> result as int == b as int,\n        never_wakes(a as int, b as int, c as int, d as int) ==> result == -1,\n        eventually_wakes(a as int, b as int, c as int, d as int) ==> result as int == calculate_wake_time(a as int, b as int, c as int, d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2353.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 677, "minimize_time_ms": 123485, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n\nspec fn first_alarm_sufficient(a: int, b: int) -> bool {\n\nspec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {\n\nspec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {\n\nspec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && d >= 0\n}\n\nspec fn first_alarm_sufficient(a: int, b: int) -> bool {\n    a <= b\n}\n\nspec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c <= d\n}\n\nspec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c > d\n}\n\nspec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {\n    let remaining = a - b;\n    let cycles = (remaining - 1) / (c - d) + 1;\n    b + c * cycles\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int, d as int)\n    ensures \n        first_alarm_sufficient(a as int, b as int) ==> result as int == b as int,\n        never_wakes(a as int, b as int, c as int, d as int) ==> result == -1,\n        eventually_wakes(a as int, b as int, c as int, d as int) ==> result as int == calculate_wake_time(a as int, b as int, c as int, d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2386_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1\n}\n\nspec fn transform(a: Seq<int>) -> Seq<int> {\n    Seq::new(a.len(), |i: int| a[i] - (i + 1))\n}\n\nspec fn sum_abs_diffs(a: Seq<int>, target: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        abs_int(a[0] - target) + sum_abs_diffs(a.subrange(1, a.len() as int), target)\n    }\n}\n\nspec fn median_of(a: Seq<int>) -> int {\n    let sorted = sorted_seq(a);\n    if sorted.len() == 0 {\n        0\n    } else if sorted.len() % 2 == 1 {\n        sorted[sorted.len() as int / 2]\n    } else if sorted.len() == 2 {\n        (sorted[0] + sorted[1]) / 2\n    } else {\n        (sorted[sorted.len() as int / 2 - 1] + sorted[sorted.len() as int / 2]) / 2\n    }\n}\n\nspec fn sorted_seq(a: Seq<int>) -> Seq<int> {\n    a\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int == sum_abs_diffs(transform(a@.map(|i: int, x: i8| x as int)), median_of(transform(a@.map(|i: int, x: i8| x as int)))),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1\n}\n\nspec fn transform(a: Seq<int>) -> Seq<int> {\n    Seq::new(a.len(), |i: int| a[i] - (i + 1))\n}\n\nspec fn sum_abs_diffs(a: Seq<int>, target: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        abs_int(a[0] - target) + sum_abs_diffs(a.subrange(1, a.len() as int), target)\n    }\n}\n\nspec fn median_of(a: Seq<int>) -> int {\n    let sorted = sorted_seq(a);\n    if sorted.len() == 0 {\n        0\n    } else if sorted.len() % 2 == 1 {\n        sorted[sorted.len() as int / 2]\n    } else if sorted.len() == 2 {\n        (sorted[0] + sorted[1]) / 2\n    } else {\n        (sorted[sorted.len() as int / 2 - 1] + sorted[sorted.len() as int / 2]) / 2\n    }\n}\n\nspec fn sorted_seq(a: Seq<int>) -> Seq<int> {\n    a\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int == sum_abs_diffs(transform(a@.map(|i: int, x: i8| x as int)), median_of(transform(a@.map(|i: int, x: i8| x as int)))),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2386.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 816, "minimize_time_ms": 122417, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>) -> bool {\n\nspec fn transform(a: Seq<int>) -> Seq<int> {\n\nspec fn sum_abs_diffs(a: Seq<int>, target: int) -> int\n    decreases a.len()\n{\n\nspec fn median_of(a: Seq<int>) -> int {\n\nspec fn sorted_seq(a: Seq<int>) -> Seq<int> {\n\nspec fn abs_int(x: int) -> int {\n\n    decreases a.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1\n}\n\nspec fn transform(a: Seq<int>) -> Seq<int> {\n    Seq::new(a.len(), |i: int| a[i] - (i + 1))\n}\n\nspec fn sum_abs_diffs(a: Seq<int>, target: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        abs_int(a[0] - target) + sum_abs_diffs(a.subrange(1, a.len() as int), target)\n    }\n}\n\nspec fn median_of(a: Seq<int>) -> int {\n    let sorted = sorted_seq(a);\n    if sorted.len() == 0 {\n        0\n    } else if sorted.len() % 2 == 1 {\n        sorted[sorted.len() as int / 2]\n    } else if sorted.len() == 2 {\n        (sorted[0] + sorted[1]) / 2\n    } else {\n        (sorted[sorted.len() as int / 2 - 1] + sorted[sorted.len() as int / 2]) / 2\n    }\n}\n\nspec fn sorted_seq(a: Seq<int>) -> Seq<int> {\n    a\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int == sum_abs_diffs(transform(a@.map(|i: int, x: i8| x as int)), median_of(transform(a@.map(|i: int, x: i8| x as int)))),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2406_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])\n}\n\nspec fn valid_output(n: int, result: Seq<int>) -> bool {\n    result.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)\n}\n\nspec fn is_stable(result: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, heights@.map(|i, v| v as int))\n    ensures \n        valid_output(n as int, result@.map(|i, v| v as int)) &&\n        sum_seq(result@.map(|i, v| v as int)) == sum_seq(heights@.map(|i, v| v as int)) &&\n        is_stable(result@.map(|i, v| v as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])\n}\n\nspec fn valid_output(n: int, result: Seq<int>) -> bool {\n    result.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)\n}\n\nspec fn is_stable(result: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, heights@.map(|i, v| v as int))\n    ensures \n        valid_output(n as int, result@.map(|i, v| v as int)) &&\n        sum_seq(result@.map(|i, v| v as int)) == sum_seq(heights@.map(|i, v| v as int)) &&\n        is_stable(result@.map(|i, v| v as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2406.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 756, "minimize_time_ms": 122513, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, heights: Seq<int>) -> bool {\n\nspec fn valid_output(n: int, result: Seq<int>) -> bool {\n\nspec fn is_stable(result: Seq<int>) -> bool {\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])\n}\n\nspec fn valid_output(n: int, result: Seq<int>) -> bool {\n    result.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)\n}\n\nspec fn is_stable(result: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, heights@.map(|i, v| v as int))\n    ensures \n        valid_output(n as int, result@.map(|i, v| v as int)) &&\n        sum_seq(result@.map(|i, v| v as int)) == sum_seq(heights@.map(|i, v| v as int)) &&\n        is_stable(result@.map(|i, v| v as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2425_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn power2(k: nat) -> int\n    decreases k\n{\n    if k == 0 { 1 } else { 2 * power2((k - 1) as nat) }\n}\n\nspec fn valid_query(a: int) -> bool\n{\n    2 <= a <= power2(25) - 1\n}\n\nspec fn valid_queries(queries: Seq<int>) -> bool\n{\n    forall|i: int| #![auto] 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn largest_proper_divisor(n: int) -> int\n    recommends n > 1\n{\n    if n <= 1 { \n        1 \n    } else { \n        largest_proper_divisor_helper(n, 2) \n    }\n}\n\nspec fn largest_proper_divisor_helper(n: int, d: int) -> int\n    recommends n > 1 && d >= 2\n    decreases if n >= d { n - d } else { 0 }\n{\n    if d * d > n { \n        1 \n    } else if n % d == 0 { \n        let quotient = n / d;\n        if quotient == d { \n            quotient \n        } else if n > d {\n            let remainder_check = largest_proper_divisor_helper(n, d + 1);\n            if quotient > remainder_check { quotient } else { remainder_check }\n        } else {\n            quotient\n        }\n    } else if n > d { \n        largest_proper_divisor_helper(n, d + 1) \n    } else {\n        1\n    }\n}\n\nspec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool\n{\n    results.len() == queries.len() &&\n    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_queries(queries@.map(|_i, x: i8| x as int))\n    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn power2(k: nat) -> int\n    decreases k\n{\n    if k == 0 { 1 } else { 2 * power2((k - 1) as nat) }\n}\n\nspec fn valid_query(a: int) -> bool\n{\n    2 <= a <= power2(25) - 1\n}\n\nspec fn valid_queries(queries: Seq<int>) -> bool\n{\n    forall|i: int| #![auto] 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn largest_proper_divisor(n: int) -> int\n    recommends n > 1\n{\n    if n <= 1 { \n        1 \n    } else { \n        largest_proper_divisor_helper(n, 2) \n    }\n}\n\nspec fn largest_proper_divisor_helper(n: int, d: int) -> int\n    recommends n > 1 && d >= 2\n    decreases if n >= d { n - d } else { 0 }\n{\n    if d * d > n { \n        1 \n    } else if n % d == 0 { \n        let quotient = n / d;\n        if quotient == d { \n            quotient \n        } else if n > d {\n            let remainder_check = largest_proper_divisor_helper(n, d + 1);\n            if quotient > remainder_check { quotient } else { remainder_check }\n        } else {\n            quotient\n        }\n    } else if n > d { \n        largest_proper_divisor_helper(n, d + 1) \n    } else {\n        1\n    }\n}\n\nspec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool\n{\n    results.len() == queries.len() &&\n    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_queries(queries@.map(|_i, x: i8| x as int))\n    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2425.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 728, "minimize_time_ms": 123227, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 81, "minimized_LOC": 81, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn power2(k: nat) -> int\n    decreases k\n{\n\nspec fn valid_query(a: int) -> bool\n{\n\nspec fn valid_queries(queries: Seq<int>) -> bool\n{\n\nspec fn largest_proper_divisor(n: int) -> int\n    recommends n > 1\n{\n\nspec fn largest_proper_divisor_helper(n: int, d: int) -> int\n    recommends n > 1 && d >= 2\n    decreases if n >= d {\n\nspec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool\n{\n\n    decreases k\n\n    decreases if n >= d { n - d } else { 0 }\n\n    requires valid_queries(queries@.map(|_i, x: i8| x as int))\n\n    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn power2(k: nat) -> int\n    decreases k\n{\n    if k == 0 { 1 } else { 2 * power2((k - 1) as nat) }\n}\n\nspec fn valid_query(a: int) -> bool\n{\n    2 <= a <= power2(25) - 1\n}\n\nspec fn valid_queries(queries: Seq<int>) -> bool\n{\n    forall|i: int| #![auto] 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn largest_proper_divisor(n: int) -> int\n    recommends n > 1\n{\n    if n <= 1 { \n        1 \n    } else { \n        largest_proper_divisor_helper(n, 2) \n    }\n}\n\nspec fn largest_proper_divisor_helper(n: int, d: int) -> int\n    recommends n > 1 && d >= 2\n    decreases if n >= d { n - d } else { 0 }\n{\n    if d * d > n { \n        1 \n    } else if n % d == 0 { \n        let quotient = n / d;\n        if quotient == d { \n            quotient \n        } else if n > d {\n            let remainder_check = largest_proper_divisor_helper(n, d + 1);\n            if quotient > remainder_check { quotient } else { remainder_check }\n        } else {\n            quotient\n        }\n    } else if n > d { \n        largest_proper_divisor_helper(n, d + 1) \n    } else {\n        1\n    }\n}\n\nspec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool\n{\n    results.len() == queries.len() &&\n    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_queries(queries@.map(|_i, x: i8| x as int))\n    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2434_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn yes_string() -> Seq<char> {\n    seq!['Y', 'E', 'S']\n}\n\nspec fn no_string() -> Seq<char> {\n    seq!['N', 'O']\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_by_newline(input);\n    lines.len() >= 1 && \n    is_valid_int(lines[0]) &&\n    {\n        let t = parse_int(lines[0]);\n        t >= 0 && t + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= t ==> #[trigger] is_valid_two_int_line(lines[i])\n    }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn is_valid_two_int_line(s: Seq<char>) -> bool {\n    let parts = split_by_space(s);\n    parts.len() >= 2 && is_valid_int(parts[0]) && is_valid_int(parts[1])\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    let input_lines = split_by_newline(input);\n    if input_lines.len() == 0 { \n        output.len() == 0\n    } else {\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_by_newline(output);\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] seq_equals(output_lines[i], yes_string()) || #[trigger] seq_equals(output_lines[i], no_string())\n    }\n}\n\nspec fn correct_divisibility_results(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_by_newline(input);\n    if input_lines.len() == 0 { \n        output.len() == 0\n    } else {\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_by_newline(output);\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && i + 1 < input_lines.len() ==> {\n            let parts = split_by_space(input_lines[i + 1]);\n            parts.len() >= 2 ==> {\n                let x = parse_int(parts[0]);\n                let y = parse_int(parts[1]);\n                y != 0 ==> (#[trigger] seq_equals(output_lines[i], yes_string()) <==> x % y == 0)\n            }\n        }\n    }\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == #[trigger] s2[i]\n}\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![]\n    } else if s[0] == '\\n' { \n        seq![seq![]].add(split_by_newline(s.subrange(1, s.len() as int)))\n    } else {\n        let rest = split_by_newline(s.subrange(1, s.len() as int));\n        if rest.len() == 0 { \n            seq![s]\n        } else { \n            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![]\n    } else if s[0] == ' ' { \n        seq![seq![]].add(split_by_space(s.subrange(1, s.len() as int)))\n    } else {\n        let rest = split_by_space(s.subrange(1, s.len() as int));\n        if rest.len() == 0 { \n            seq![s]\n        } else { \n            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 {\n        if '0' <= s[0] <= '9' { \n            s[0] as int - '0' as int \n        } else { \n            0 \n        }\n    } else {\n        if '0' <= s[0] <= '9' {\n            (s[0] as int - '0' as int) * pow10(s.len() - 1) + parse_int(s.subrange(1, s.len() as int))\n        } else { \n            0 \n        }\n    }\n}\n\nspec fn pow10(n: int) -> int \n    decreases n\n{\n    if n <= 0 { 1 } else { 10 * pow10(n - 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires \n        input.len() > 0,\n        valid_input_format(input@),\n    ensures \n        forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n',\n        valid_output_format(output@, input@),\n        correct_divisibility_results(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn yes_string() -> Seq<char> ;\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn is_valid_int(s: Seq<char>) -> bool ;\n       spec fn is_valid_two_int_line(s: Seq<char>) -> bool ;\n       spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;\n       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2434.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 841, "minimize_time_ms": 184452, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 152, "minimized_LOC": 15, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.09868421052631579}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn yes_string() -> Seq<char> ;\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn is_valid_int(s: Seq<char>) -> bool ;\n       spec fn is_valid_two_int_line(s: Seq<char>) -> bool ;\n       spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;\n       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn is_valid_int(s: Seq<char>) -> bool ;\n       spec fn is_valid_two_int_line(s: Seq<char>) -> bool ;\n       spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;\n       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn is_valid_int(s: Seq<char>) -> bool ;\n       spec fn is_valid_two_int_line(s: Seq<char>) -> bool ;\n       spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;\n       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn is_valid_two_int_line(s: Seq<char>) -> bool ;\n       spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;\n       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;\n       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\nspec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n\n       spec fn pow10(n: int) -> int      decreases n ;"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn yes_string() -> Seq<char> {\n    seq!['Y', 'E', 'S']\n}\n\nspec fn no_string() -> Seq<char> {\n    seq!['N', 'O']\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_by_newline(input);\n    lines.len() >= 1 && \n    is_valid_int(lines[0]) &&\n    {\n        let t = parse_int(lines[0]);\n        t >= 0 && t + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= t ==> #[trigger] is_valid_two_int_line(lines[i])\n    }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn is_valid_two_int_line(s: Seq<char>) -> bool {\n    let parts = split_by_space(s);\n    parts.len() >= 2 && is_valid_int(parts[0]) && is_valid_int(parts[1])\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    let input_lines = split_by_newline(input);\n    if input_lines.len() == 0 { \n        output.len() == 0\n    } else {\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_by_newline(output);\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] seq_equals(output_lines[i], yes_string()) || #[trigger] seq_equals(output_lines[i], no_string())\n    }\n}\n\nspec fn correct_divisibility_results(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_by_newline(input);\n    if input_lines.len() == 0 { \n        output.len() == 0\n    } else {\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_by_newline(output);\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && i + 1 < input_lines.len() ==> {\n            let parts = split_by_space(input_lines[i + 1]);\n            parts.len() >= 2 ==> {\n                let x = parse_int(parts[0]);\n                let y = parse_int(parts[1]);\n                y != 0 ==> (#[trigger] seq_equals(output_lines[i], yes_string()) <==> x % y == 0)\n            }\n        }\n    }\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == #[trigger] s2[i]\n}\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![]\n    } else if s[0] == '\\n' { \n        seq![seq![]].add(split_by_newline(s.subrange(1, s.len() as int)))\n    } else {\n        let rest = split_by_newline(s.subrange(1, s.len() as int));\n        if rest.len() == 0 { \n            seq![s]\n        } else { \n            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![]\n    } else if s[0] == ' ' { \n        seq![seq![]].add(split_by_space(s.subrange(1, s.len() as int)))\n    } else {\n        let rest = split_by_space(s.subrange(1, s.len() as int));\n        if rest.len() == 0 { \n            seq![s]\n        } else { \n            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 {\n        if '0' <= s[0] <= '9' { \n            s[0] as int - '0' as int \n        } else { \n            0 \n        }\n    } else {\n        if '0' <= s[0] <= '9' {\n            (s[0] as int - '0' as int) * pow10(s.len() - 1) + parse_int(s.subrange(1, s.len() as int))\n        } else { \n            0 \n        }\n    }\n}\n\nspec fn pow10(n: int) -> int \n    decreases n\n{\n    if n <= 0 { 1 } else { 10 * pow10(n - 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires \n        input.len() > 0,\n        valid_input_format(input@),\n    ensures \n        forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n',\n        valid_output_format(output@, input@),\n        correct_divisibility_results(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn yes_string() -> Seq<char> ;\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn is_valid_int(s: Seq<char>) -> bool ;\n       spec fn is_valid_two_int_line(s: Seq<char>) -> bool ;\n       spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;\n       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n                fn main() {\n      }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2435_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool {\n    test_cases.len() >= 0 &&\n    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {\n        let (n, x, operations) = test_cases[i];\n        n >= 1 && 1 <= x <= n && operations.len() >= 0 &&\n        forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 >= 1 && {\n            let (l, r) = operations[j];\n            1 <= l <= r <= n\n        }\n    }\n}\n\nspec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)\n    recommends forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 <= operations[j].1\n{\n    compute_final_bounds_helper(x, x, operations, 0)\n}\n\nspec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool\n    recommends valid_input(test_cases)\n{\n    results.len() == test_cases.len() &&\n    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {\n        let (n, x, operations) = test_cases[i];\n        let final_bounds = compute_final_bounds(x, operations);\n        results[i] == final_bounds.1 - final_bounds.0 + 1 &&\n        final_bounds.0 <= x <= final_bounds.1 &&\n        results[i] >= 1 &&\n        1 <= final_bounds.0 <= final_bounds.1 <= n\n    }\n}\n\nspec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)\n    decreases operations.len() - index\n{\n    if index >= operations.len() {\n        (min_pos, max_pos)\n    } else {\n        let (l, r) = operations[index];\n        let new_min = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {\n            if l < min_pos { l } else { min_pos }\n        } else { min_pos };\n        let new_max = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {\n            if r > max_pos { r } else { max_pos }\n        } else { max_pos };\n        compute_final_bounds_helper(new_min, new_max, operations, index + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(test_cases: Vec<(i8, i8, Vec<(i8, i8)>)>) -> (results: Vec<i8>)\n    requires valid_input(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))))\n    ensures valid_results(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))), results@.map(|i: int, r: i8| r as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool ;\n        spec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)     recommends forall|j: int| 0 <= j < operations.len() ==>        \n#[trigger] operations[j].0 <= operations[j].1\n;\n        spec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool     recommends valid_input(test_cases) ;\n        spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;\n        }\n        fn main() {\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2435.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 805, "minimize_time_ms": 154169, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 73, "minimized_LOC": 11, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 6, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.1506849315068493}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool ;\n        spec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)     recommends forall|j: int| 0 <= j < operations.len() ==>        \n#[trigger] operations[j].0 <= operations[j].1\n;\n        spec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool     recommends valid_input(test_cases) ;\n        spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;\n        }\n        fn main() {\n\nspec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)     recommends forall|j: int| 0 <= j < operations.len() ==>        \n#[trigger] operations[j].0 <= operations[j].1\n;\n        spec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool     recommends valid_input(test_cases) ;\n        spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;\n        }\n        fn main() {\n\nspec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool     recommends valid_input(test_cases) ;\n        spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;\n        }\n        fn main() {\n\nspec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;\n        }\n        fn main() {\n\n        spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool {\n    test_cases.len() >= 0 &&\n    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {\n        let (n, x, operations) = test_cases[i];\n        n >= 1 && 1 <= x <= n && operations.len() >= 0 &&\n        forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 >= 1 && {\n            let (l, r) = operations[j];\n            1 <= l <= r <= n\n        }\n    }\n}\n\nspec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)\n    recommends forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 <= operations[j].1\n{\n    compute_final_bounds_helper(x, x, operations, 0)\n}\n\nspec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool\n    recommends valid_input(test_cases)\n{\n    results.len() == test_cases.len() &&\n    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {\n        let (n, x, operations) = test_cases[i];\n        let final_bounds = compute_final_bounds(x, operations);\n        results[i] == final_bounds.1 - final_bounds.0 + 1 &&\n        final_bounds.0 <= x <= final_bounds.1 &&\n        results[i] >= 1 &&\n        1 <= final_bounds.0 <= final_bounds.1 <= n\n    }\n}\n\nspec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)\n    decreases operations.len() - index\n{\n    if index >= operations.len() {\n        (min_pos, max_pos)\n    } else {\n        let (l, r) = operations[index];\n        let new_min = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {\n            if l < min_pos { l } else { min_pos }\n        } else { min_pos };\n        let new_max = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {\n            if r > max_pos { r } else { max_pos }\n        } else { max_pos };\n        compute_final_bounds_helper(new_min, new_max, operations, index + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(test_cases: Vec<(i8, i8, Vec<(i8, i8)>)>) -> (results: Vec<i8>)\n    requires valid_input(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))))\n    ensures valid_results(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))), results@.map(|i: int, r: i8| r as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool ;\n        spec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)     recommends forall|j: int| 0 <= j < operations.len() ==>        \n#[trigger] operations[j].0 <= operations[j].1\n;\n        spec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool     recommends valid_input(test_cases) ;\n        spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;\n        }\n        fn main() {\n       }\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_244_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_position(pos: int) -> bool {\n    0 <= pos <= 2\n}\n\nspec fn swap_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n\nspec fn reverse_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn shell_game(n: i32, x: i8) -> (result: i8)\n    requires \n        n >= 1 && n <= 2000000000,\n        valid_position(x as int),\n    ensures valid_position(result as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_position(pos: int) -> bool {\n    0 <= pos <= 2\n}\n\nspec fn swap_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n\nspec fn reverse_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn shell_game(n: i32, x: i8) -> (result: i8)\n    requires \n        n >= 1 && n <= 2000000000,\n        valid_position(x as int),\n    ensures valid_position(result as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_244.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 812, "minimize_time_ms": 122566, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_position(pos: int) -> bool {\n\nspec fn swap_move(pos: int, move_num: int) -> int {\n\nspec fn reverse_move(pos: int, move_num: int) -> int {\n\n    requires \n\n    ensures valid_position(result as int),"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_position(pos: int) -> bool {\n    0 <= pos <= 2\n}\n\nspec fn swap_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n\nspec fn reverse_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn shell_game(n: i32, x: i8) -> (result: i8)\n    requires \n        n >= 1 && n <= 2000000000,\n        valid_position(x as int),\n    ensures valid_position(result as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2443_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat\n  recommends modulus > 0, i <= s.len()\n  decreases i\n{\n    if i == 0 { 1 }\n    else { (s[i as int - 1] * prefix_product(s, (i - 1) as nat, modulus)) % modulus }\n}\n\nspec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>\n  recommends modulus > 0\n{\n    Seq::new(s.len(), |i: int| prefix_product(s, (i + 1) as nat, modulus))\n}\n\nspec fn all_distinct<T>(s: Seq<T>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]\n}\n\nspec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool\n  recommends modulus > 0\n{\n    let products = prefix_products(s, modulus);\n    forall|i: int| 0 <= i < products.len() ==> !forbidden.contains(products[i])\n}\n\nspec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {\n    m >= 1 &&\n    n >= 0 &&\n    forbidden.len() == n &&\n    (forall|i: int| 0 <= i < forbidden.len() ==> #[trigger] forbidden[i] >= 0 && forbidden[i] < m) &&\n    (forall|i: int, j: int| 0 <= i < j < forbidden.len() ==> #[trigger] forbidden[i] != #[trigger] forbidden[j])\n}\n\nspec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool\n  recommends m > 0\n{\n    (forall|i: int| 0 <= i < sequence.len() ==> #[trigger] sequence[i] >= 0 && sequence[i] < m) &&\n    all_distinct(Seq::new(1, |x: int| 1).add(prefix_products(sequence, m))) &&\n    no_forbidden_products(sequence, forbidden, m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, m: u8, forbidden: Vec<u8>) -> (result: (u8, Vec<u8>))\n  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))\n  ensures ({\n      let (length, sequence) = result;\n      length == sequence.len() as u8 &&\n      length >= 0 &&\n      (m == 1 ==> length == 0 && sequence@ == Seq::<u8>::empty()) &&\n      (m > 1 ==> valid_sequence(sequence@.map(|i, x: u8| x as nat), m as nat, forbidden@.map(|i, x: u8| x as nat))) &&\n      (n == 0 && m > 1 ==> length > 0)\n  })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, Vec::new())\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat\n  recommends modulus > 0, i <= s.len()\n  decreases i\n{\n    if i == 0 { 1 }\n    else { (s[i as int - 1] * prefix_product(s, (i - 1) as nat, modulus)) % modulus }\n}\n\nspec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>\n  recommends modulus > 0\n{\n    Seq::new(s.len(), |i: int| prefix_product(s, (i + 1) as nat, modulus))\n}\n\nspec fn all_distinct<T>(s: Seq<T>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]\n}\n\nspec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool\n  recommends modulus > 0\n{\n    let products = prefix_products(s, modulus);\n    forall|i: int| 0 <= i < products.len() ==> !forbidden.contains(products[i])\n}\n\nspec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {\n    m >= 1 &&\n    n >= 0 &&\n    forbidden.len() == n &&\n    (forall|i: int| 0 <= i < forbidden.len() ==> #[trigger] forbidden[i] >= 0 && forbidden[i] < m) &&\n    (forall|i: int, j: int| 0 <= i < j < forbidden.len() ==> #[trigger] forbidden[i] != #[trigger] forbidden[j])\n}\n\nspec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool\n  recommends m > 0\n{\n    (forall|i: int| 0 <= i < sequence.len() ==> #[trigger] sequence[i] >= 0 && sequence[i] < m) &&\n    all_distinct(Seq::new(1, |x: int| 1).add(prefix_products(sequence, m))) &&\n    no_forbidden_products(sequence, forbidden, m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, m: u8, forbidden: Vec<u8>) -> (result: (u8, Vec<u8>))\n  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))\n  ensures ({\n      let (length, sequence) = result;\n      length == sequence.len() as u8 &&\n      length >= 0 &&\n      (m == 1 ==> length == 0 && sequence@ == Seq::<u8>::empty()) &&\n      (m > 1 ==> valid_sequence(sequence@.map(|i, x: u8| x as nat), m as nat, forbidden@.map(|i, x: u8| x as nat))) &&\n      (n == 0 && m > 1 ==> length > 0)\n  })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, Vec::new())\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2443.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 860, "minimize_time_ms": 153620, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 72, "minimized_LOC": 72, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat\n  recommends modulus > 0, i <= s.len()\n  decreases i\n{\n\nspec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>\n  recommends modulus > 0\n{\n\nspec fn all_distinct<T>(s: Seq<T>) -> bool {\n\nspec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool\n  recommends modulus > 0\n{\n\nspec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {\n\nspec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool\n  recommends m > 0\n{\n\n  decreases i\n\n  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))\n\n  ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat\n  recommends modulus > 0, i <= s.len()\n  decreases i\n{\n    if i == 0 { 1 }\n    else { (s[i as int - 1] * prefix_product(s, (i - 1) as nat, modulus)) % modulus }\n}\n\nspec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>\n  recommends modulus > 0\n{\n    Seq::new(s.len(), |i: int| prefix_product(s, (i + 1) as nat, modulus))\n}\n\nspec fn all_distinct<T>(s: Seq<T>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]\n}\n\nspec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool\n  recommends modulus > 0\n{\n    let products = prefix_products(s, modulus);\n    forall|i: int| 0 <= i < products.len() ==> !forbidden.contains(products[i])\n}\n\nspec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {\n    m >= 1 &&\n    n >= 0 &&\n    forbidden.len() == n &&\n    (forall|i: int| 0 <= i < forbidden.len() ==> #[trigger] forbidden[i] >= 0 && forbidden[i] < m) &&\n    (forall|i: int, j: int| 0 <= i < j < forbidden.len() ==> #[trigger] forbidden[i] != #[trigger] forbidden[j])\n}\n\nspec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool\n  recommends m > 0\n{\n    (forall|i: int| 0 <= i < sequence.len() ==> #[trigger] sequence[i] >= 0 && sequence[i] < m) &&\n    all_distinct(Seq::new(1, |x: int| 1).add(prefix_products(sequence, m))) &&\n    no_forbidden_products(sequence, forbidden, m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, m: u8, forbidden: Vec<u8>) -> (result: (u8, Vec<u8>))\n  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))\n  ensures ({\n      let (length, sequence) = result;\n      length == sequence.len() as u8 &&\n      length >= 0 &&\n      (m == 1 ==> length == 0 && sequence@ == Seq::<u8>::empty()) &&\n      (m > 1 ==> valid_sequence(sequence@.map(|i, x: u8| x as nat), m as nat, forbidden@.map(|i, x: u8| x as nat))) &&\n      (n == 0 && m > 1 ==> length > 0)\n  })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, Vec::new())\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2451_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {\n    n >= 1 && h >= 1 && 1 <= a <= b <= h\n}\n\nspec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {\n    1 <= query.0 <= n && 1 <= query.1 <= h &&\n    1 <= query.2 <= n && 1 <= query.3 <= h\n}\n\nspec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> #[trigger] valid_query(queries[i], n, h)\n}\n\nspec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {\n    if t1 == t2 {\n        if f1 >= f2 { f1 - f2 } else { f2 - f1 }\n    } else if f1 >= a && f1 <= b {\n        (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= f1 { f2 - f1 } else { f1 - f2 })\n    } else if f1 < a {\n        (a - f1) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= a { f2 - a } else { a - f2 })\n    } else {\n        (f1 - b) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= b { f2 - b } else { b - f2 })\n    }\n}\n\nspec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> {\n        let (t1, f1, t2, f2) = queries[i];\n        #[trigger] results[i] == min_travel_time(t1, f1, t2, f2, a, b)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, h: i8, a: i8, b: i8, queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)\n    requires\n        valid_building_params(n as int, h as int, a as int, b as int),\n        valid_queries(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), n as int, h as int),\n    ensures\n        correct_results(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), results@.map_values(|x: i8| x as int), a as int, b as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {\n    n >= 1 && h >= 1 && 1 <= a <= b <= h\n}\n\nspec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {\n    1 <= query.0 <= n && 1 <= query.1 <= h &&\n    1 <= query.2 <= n && 1 <= query.3 <= h\n}\n\nspec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> #[trigger] valid_query(queries[i], n, h)\n}\n\nspec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {\n    if t1 == t2 {\n        if f1 >= f2 { f1 - f2 } else { f2 - f1 }\n    } else if f1 >= a && f1 <= b {\n        (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= f1 { f2 - f1 } else { f1 - f2 })\n    } else if f1 < a {\n        (a - f1) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= a { f2 - a } else { a - f2 })\n    } else {\n        (f1 - b) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= b { f2 - b } else { b - f2 })\n    }\n}\n\nspec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> {\n        let (t1, f1, t2, f2) = queries[i];\n        #[trigger] results[i] == min_travel_time(t1, f1, t2, f2, a, b)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, h: i8, a: i8, b: i8, queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)\n    requires\n        valid_building_params(n as int, h as int, a as int, b as int),\n        valid_queries(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), n as int, h as int),\n    ensures\n        correct_results(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), results@.map_values(|x: i8| x as int), a as int, b as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2451.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 797, "minimize_time_ms": 124006, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {\n\nspec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {\n\nspec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {\n\nspec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {\n\nspec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {\n    n >= 1 && h >= 1 && 1 <= a <= b <= h\n}\n\nspec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {\n    1 <= query.0 <= n && 1 <= query.1 <= h &&\n    1 <= query.2 <= n && 1 <= query.3 <= h\n}\n\nspec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> #[trigger] valid_query(queries[i], n, h)\n}\n\nspec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {\n    if t1 == t2 {\n        if f1 >= f2 { f1 - f2 } else { f2 - f1 }\n    } else if f1 >= a && f1 <= b {\n        (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= f1 { f2 - f1 } else { f1 - f2 })\n    } else if f1 < a {\n        (a - f1) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= a { f2 - a } else { a - f2 })\n    } else {\n        (f1 - b) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= b { f2 - b } else { b - f2 })\n    }\n}\n\nspec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> {\n        let (t1, f1, t2, f2) = queries[i];\n        #[trigger] results[i] == min_travel_time(t1, f1, t2, f2, a, b)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, h: i8, a: i8, b: i8, queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)\n    requires\n        valid_building_params(n as int, h as int, a as int, b as int),\n        valid_queries(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), n as int, h as int),\n    ensures\n        correct_results(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), results@.map_values(|x: i8| x as int), a as int, b as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n         verus! {}\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2467_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn is_distinct(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j]\n}\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i + 1]\n}\n\nspec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool {\n    combo.len() == k &&\n    sum(combo) == n &&\n    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&\n    is_distinct(combo) &&\n    is_sorted(combo)\n}\n\nspec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n    combo.len() == k &&\n    sum(combo) == n &&\n    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&\n    is_distinct(combo) &&\n    is_sorted(combo) &&\n    combo.len() >= temp.len() &&\n    (forall|i: int| 0 <= i < temp.len() ==> #[trigger] temp[i] == #[trigger] combo[i]) &&\n    (forall|i: int| temp.len() <= i < combo.len() ==> #[trigger] combo[i] >= start)\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn to_int_seq(v: Vec<i8>) -> Seq<int> {\n    v@.map(|i: int, x: i8| x as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)\n    requires k > 0 && n > 0 && k <= 9\n    ensures \n        (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == k as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> sum(to_int_seq(#[trigger] result[i])) == n as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < #[trigger] result[i].len() ==> 1 <= #[trigger] result[i][j] as int <= 9) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_distinct(to_int_seq(#[trigger] result[i]))) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_sorted(to_int_seq(#[trigger] result[i]))) &&\n        (forall|i: int, j: int| 0 <= i < j < result.len() ==> to_int_seq(#[trigger] result[i]) != to_int_seq(#[trigger] result[j])) &&\n        (forall|combo: Seq<int>| is_valid_combination(combo, k as int, n as int) ==> exists|i: int| 0 <= i < result.len() && to_int_seq(#[trigger] result[i]) == combo) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(#[trigger] result[i]), k as int, n as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n       spec fn is_distinct(s: Seq<int>) -> bool ;\n       spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool ;\n       spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n        (forall|i: int| temp.len() <= i < combo.len() ==>        \n#[trigger] combo[i] >= start)\n}\n       spec fn to_int_seq(v: Vec<i8>) -> Seq<int> {\n          v@.map(|i: int, x: i8| x as int) }\n       fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)     requires k > 0 && n > 0 && k <= 9     ensures          (forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i].len() == k as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(       \n#[trigger] result[i]), k as int, n as int))\n{\n          Vec::new() }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2467.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 817, "minimize_time_ms": 185191, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 72, "minimized_LOC": 21, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 0.2916666666666667}, "labeling": {"ensures_count": 1, "segments": {"exec": " fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)     requires k > 0 && n > 0 && k <= 9     ensures          (forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i].len() == k as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(       \n#[trigger] result[i]), k as int, n as int))\n{\n\n fn main() {", "spec": "spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n       spec fn is_distinct(s: Seq<int>) -> bool ;\n       spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool ;\n       spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n\nspec fn is_distinct(s: Seq<int>) -> bool ;\n       spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool ;\n       spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n\nspec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool ;\n       spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n\nspec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool ;\n       spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n\nspec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n\nspec fn to_int_seq(v: Vec<i8>) -> Seq<int> {\n\n       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n\n       fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)     requires k > 0 && n > 0 && k <= 9     ensures          (forall|i: int| 0 <= i < result.len() ==>        "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn is_distinct(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j]\n}\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i + 1]\n}\n\nspec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool {\n    combo.len() == k &&\n    sum(combo) == n &&\n    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&\n    is_distinct(combo) &&\n    is_sorted(combo)\n}\n\nspec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n    combo.len() == k &&\n    sum(combo) == n &&\n    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&\n    is_distinct(combo) &&\n    is_sorted(combo) &&\n    combo.len() >= temp.len() &&\n    (forall|i: int| 0 <= i < temp.len() ==> #[trigger] temp[i] == #[trigger] combo[i]) &&\n    (forall|i: int| temp.len() <= i < combo.len() ==> #[trigger] combo[i] >= start)\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn to_int_seq(v: Vec<i8>) -> Seq<int> {\n    v@.map(|i: int, x: i8| x as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)\n    requires k > 0 && n > 0 && k <= 9\n    ensures \n        (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == k as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> sum(to_int_seq(#[trigger] result[i])) == n as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < #[trigger] result[i].len() ==> 1 <= #[trigger] result[i][j] as int <= 9) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_distinct(to_int_seq(#[trigger] result[i]))) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_sorted(to_int_seq(#[trigger] result[i]))) &&\n        (forall|i: int, j: int| 0 <= i < j < result.len() ==> to_int_seq(#[trigger] result[i]) != to_int_seq(#[trigger] result[j])) &&\n        (forall|combo: Seq<int>| is_valid_combination(combo, k as int, n as int) ==> exists|i: int| 0 <= i < result.len() && to_int_seq(#[trigger] result[i]) == combo) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(#[trigger] result[i]), k as int, n as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n       spec fn is_distinct(s: Seq<int>) -> bool ;\n       spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool ;\n       spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n        (forall|i: int| temp.len() <= i < combo.len() ==>        \n#[trigger] combo[i] >= start)\n}\n       spec fn to_int_seq(v: Vec<i8>) -> Seq<int> {\n          v@.map(|i: int, x: i8| x as int) }\n       fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)     requires k > 0 && n > 0 && k <= 9     ensures          (forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i].len() == k as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(       \n#[trigger] result[i]), k as int, n as int))\n{\n          Vec::new() }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2486_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int\n  recommends\n    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],\n    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,\n    k >= 1\n{\n  if sorted.len() == 0 {\n    0\n  } else {\n    unnecessary_cards_count_helper(sorted, k, 0, 0, 0)\n  }\n}\n\nspec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int\n  recommends\n    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],\n    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,\n    k >= 1,\n    0 <= i <= sorted.len(),\n    temp >= 0,\n    ans >= 0\n  decreases sorted.len() - i\n{\n  if i >= sorted.len() {\n    ans\n  } else {\n    let x = sorted[i];\n    if temp + x < k {\n      unnecessary_cards_count_helper(sorted, k, temp + x, ans + 1, i + 1)\n    } else {\n      unnecessary_cards_count_helper(sorted, k, 0, 0, i + 1)\n    }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    n >= 1,\n    k >= 1,\n    a.len() == n as usize,\n    forall|i: int| 0 <= i < a.len() ==> a[i] as int >= 1\n  ensures\n    result >= 0,\n    result as int <= n as int,\n    exists|sorted: Seq<int>|\n      sorted.len() == a@.len() &&\n      sorted.to_multiset() == a@.map(|i: int, x: i8| x as int).to_multiset() &&\n      (forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j]) &&\n      (forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1) &&\n      result as int == unnecessary_cards_count(sorted, k as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int\n  recommends\n    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],\n    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,\n    k >= 1\n{\n  if sorted.len() == 0 {\n    0\n  } else {\n    unnecessary_cards_count_helper(sorted, k, 0, 0, 0)\n  }\n}\n\nspec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int\n  recommends\n    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],\n    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,\n    k >= 1,\n    0 <= i <= sorted.len(),\n    temp >= 0,\n    ans >= 0\n  decreases sorted.len() - i\n{\n  if i >= sorted.len() {\n    ans\n  } else {\n    let x = sorted[i];\n    if temp + x < k {\n      unnecessary_cards_count_helper(sorted, k, temp + x, ans + 1, i + 1)\n    } else {\n      unnecessary_cards_count_helper(sorted, k, 0, 0, i + 1)\n    }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    n >= 1,\n    k >= 1,\n    a.len() == n as usize,\n    forall|i: int| 0 <= i < a.len() ==> a[i] as int >= 1\n  ensures\n    result >= 0,\n    result as int <= n as int,\n    exists|sorted: Seq<int>|\n      sorted.len() == a@.len() &&\n      sorted.to_multiset() == a@.map(|i: int, x: i8| x as int).to_multiset() &&\n      (forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j]) &&\n      (forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1) &&\n      result as int == unnecessary_cards_count(sorted, k as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2486.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 762, "minimize_time_ms": 122469, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int\n  recommends\n    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],\n    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,\n    k >= 1\n{\n\nspec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int\n  recommends\n    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],\n    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,\n    k >= 1,\n    0 <= i <= sorted.len(),\n    temp >= 0,\n    ans >= 0\n  decreases sorted.len() - i\n{\n\n  decreases sorted.len() - i\n\n  requires\n\n  ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int\n  recommends\n    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],\n    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,\n    k >= 1\n{\n  if sorted.len() == 0 {\n    0\n  } else {\n    unnecessary_cards_count_helper(sorted, k, 0, 0, 0)\n  }\n}\n\nspec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int\n  recommends\n    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],\n    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,\n    k >= 1,\n    0 <= i <= sorted.len(),\n    temp >= 0,\n    ans >= 0\n  decreases sorted.len() - i\n{\n  if i >= sorted.len() {\n    ans\n  } else {\n    let x = sorted[i];\n    if temp + x < k {\n      unnecessary_cards_count_helper(sorted, k, temp + x, ans + 1, i + 1)\n    } else {\n      unnecessary_cards_count_helper(sorted, k, 0, 0, i + 1)\n    }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    n >= 1,\n    k >= 1,\n    a.len() == n as usize,\n    forall|i: int| 0 <= i < a.len() ==> a[i] as int >= 1\n  ensures\n    result >= 0,\n    result as int <= n as int,\n    exists|sorted: Seq<int>|\n      sorted.len() == a@.len() &&\n      sorted.to_multiset() == a@.map(|i: int, x: i8| x as int).to_multiset() &&\n      (forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j]) &&\n      (forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1) &&\n      result as int == unnecessary_cards_count(sorted, k as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2516_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_prime(p: int) -> bool {\n    p >= 2 && forall|k: int| 2 <= k < p ==> #[trigger] (p % k) != 0\n}\n\nspec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {\n    n >= 1 &&\n    p >= 2 &&\n    is_prime(p) &&\n    s.len() == n &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn substring_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        substring_to_int(s.subrange(0, s.len() as int - 1)) * 10 + ((s[s.len() as int - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn valid_result(result: int, n: int) -> bool {\n    result >= 0 && result <= n * (n + 1) / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, s: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, p as int, s@)\n    ensures valid_result(result as int, n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_prime(p: int) -> bool {\n    p >= 2 && forall|k: int| 2 <= k < p ==> #[trigger] (p % k) != 0\n}\n\nspec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {\n    n >= 1 &&\n    p >= 2 &&\n    is_prime(p) &&\n    s.len() == n &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn substring_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        substring_to_int(s.subrange(0, s.len() as int - 1)) * 10 + ((s[s.len() as int - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn valid_result(result: int, n: int) -> bool {\n    result >= 0 && result <= n * (n + 1) / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, s: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, p as int, s@)\n    ensures valid_result(result as int, n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2516.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 660, "minimize_time_ms": 122331, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_prime(p: int) -> bool {\n\nspec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {\n\nspec fn substring_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn valid_result(result: int, n: int) -> bool {\n\n    decreases s.len()\n\n    requires valid_input(n as int, p as int, s@)\n\n    ensures valid_result(result as int, n as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_prime(p: int) -> bool {\n    p >= 2 && forall|k: int| 2 <= k < p ==> #[trigger] (p % k) != 0\n}\n\nspec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {\n    n >= 1 &&\n    p >= 2 &&\n    is_prime(p) &&\n    s.len() == n &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn substring_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        substring_to_int(s.subrange(0, s.len() as int - 1)) * 10 + ((s[s.len() as int - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn valid_result(result: int, n: int) -> bool {\n    result >= 0 && result <= n * (n + 1) / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, s: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, p as int, s@)\n    ensures valid_result(result as int, n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_253_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(nums: Seq<int>) -> bool {\n    nums.len() == 3 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] > 0 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1500\n}\n\nspec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {\n    if x <= y && x <= z {\n        if y <= z { (x, y, z) } else { (x, z, y) }\n    } else if y <= x && y <= z {\n        if x <= z { (y, x, z) } else { (y, z, x) }\n    } else {\n        if x <= y { (z, x, y) } else { (z, y, x) }\n    }\n}\n\nspec fn compute_result(x: int, y: int, z: int) -> Seq<char> {\n    let sorted = sort_three(x, y, z);\n    let a = sorted.0;\n    let b = sorted.1;\n    let c = sorted.2;\n\n    if a > 3 {\n        seq!['N', 'O']\n    } else if a == 3 {\n        if b > 3 {\n            seq!['N', 'O']\n        } else if b == 3 {\n            if c > 3 { seq!['N', 'O'] } else { seq!['Y', 'E', 'S'] }\n        } else {\n            seq!['N', 'O']\n        }\n    } else if a == 1 {\n        seq!['Y', 'E', 'S']\n    } else {\n        if b == 2 {\n            seq!['Y', 'E', 'S']\n        } else if b > 4 {\n            seq!['N', 'O']\n        } else if b == 4 {\n            if c == 4 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }\n        } else {\n            seq!['N', 'O']\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(nums: Vec<i8>) -> (result: Vec<char>)\n    requires\n        valid_input(nums@.map(|i, x| x as int)),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        result@ == compute_result(nums@[0] as int, nums@[1] as int, nums@[2] as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(nums: Seq<int>) -> bool {\n    nums.len() == 3 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] > 0 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1500\n}\n\nspec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {\n    if x <= y && x <= z {\n        if y <= z { (x, y, z) } else { (x, z, y) }\n    } else if y <= x && y <= z {\n        if x <= z { (y, x, z) } else { (y, z, x) }\n    } else {\n        if x <= y { (z, x, y) } else { (z, y, x) }\n    }\n}\n\nspec fn compute_result(x: int, y: int, z: int) -> Seq<char> {\n    let sorted = sort_three(x, y, z);\n    let a = sorted.0;\n    let b = sorted.1;\n    let c = sorted.2;\n\n    if a > 3 {\n        seq!['N', 'O']\n    } else if a == 3 {\n        if b > 3 {\n            seq!['N', 'O']\n        } else if b == 3 {\n            if c > 3 { seq!['N', 'O'] } else { seq!['Y', 'E', 'S'] }\n        } else {\n            seq!['N', 'O']\n        }\n    } else if a == 1 {\n        seq!['Y', 'E', 'S']\n    } else {\n        if b == 2 {\n            seq!['Y', 'E', 'S']\n        } else if b > 4 {\n            seq!['N', 'O']\n        } else if b == 4 {\n            if c == 4 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }\n        } else {\n            seq!['N', 'O']\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(nums: Vec<i8>) -> (result: Vec<char>)\n    requires\n        valid_input(nums@.map(|i, x| x as int)),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        result@ == compute_result(nums@[0] as int, nums@[1] as int, nums@[2] as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_253.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 768, "minimize_time_ms": 122521, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 75, "minimized_LOC": 75, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(nums: Seq<int>) -> bool {\n\nspec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {\n\nspec fn compute_result(x: int, y: int, z: int) -> Seq<char> {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(nums: Seq<int>) -> bool {\n    nums.len() == 3 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] > 0 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1500\n}\n\nspec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {\n    if x <= y && x <= z {\n        if y <= z { (x, y, z) } else { (x, z, y) }\n    } else if y <= x && y <= z {\n        if x <= z { (y, x, z) } else { (y, z, x) }\n    } else {\n        if x <= y { (z, x, y) } else { (z, y, x) }\n    }\n}\n\nspec fn compute_result(x: int, y: int, z: int) -> Seq<char> {\n    let sorted = sort_three(x, y, z);\n    let a = sorted.0;\n    let b = sorted.1;\n    let c = sorted.2;\n\n    if a > 3 {\n        seq!['N', 'O']\n    } else if a == 3 {\n        if b > 3 {\n            seq!['N', 'O']\n        } else if b == 3 {\n            if c > 3 { seq!['N', 'O'] } else { seq!['Y', 'E', 'S'] }\n        } else {\n            seq!['N', 'O']\n        }\n    } else if a == 1 {\n        seq!['Y', 'E', 'S']\n    } else {\n        if b == 2 {\n            seq!['Y', 'E', 'S']\n        } else if b > 4 {\n            seq!['N', 'O']\n        } else if b == 4 {\n            if c == 4 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }\n        } else {\n            seq!['N', 'O']\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(nums: Vec<i8>) -> (result: Vec<char>)\n    requires\n        valid_input(nums@.map(|i, x| x as int)),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        result@ == compute_result(nums@[0] as int, nums@[1] as int, nums@[2] as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2548_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(digits: Seq<int>) -> bool {\n    digits.len() >= 1 && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= 0 && #[trigger] digits[i] <= 9\n}\n\nspec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool\n    recommends 0 <= start <= end < digits.len()\n{\n    let subarray_sum = sum(digits.subrange(start, end + 1));\n    let subarray_length = end - start + 1;\n    subarray_sum == subarray_length\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.drop_first()) }\n}\n\nspec fn count_good_subarrays(digits: Seq<int>) -> int\n    recommends valid_input(digits)\n{\n    count_good_subarrays_helper(digits, 0, map![0 => 1], 0, 0)\n}\n\nspec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, \n                                  current_sum: int, current_count: int) -> int\n    recommends \n        0 <= pos <= digits.len() &&\n        valid_input(digits) &&\n        current_count == pos &&\n        current_sum >= 0 &&\n        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&\n        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)\n    decreases digits.len() - pos\n{\n    if pos >= digits.len() { 0 }\n    else {\n        let new_sum = current_sum + digits[pos];\n        let new_count = current_count + 1;\n        let diff = new_count - new_sum;\n        let contribution = if freq_map.dom().contains(diff) { freq_map[diff] } else { 0 };\n        let new_freq_map = freq_map.insert(diff, if freq_map.dom().contains(diff) { freq_map[diff] + 1 } else { 1 });\n        contribution + count_good_subarrays_helper(digits, pos + 1, new_freq_map, new_sum, new_count)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_good_subarrays_in_array(digits: Vec<i8>) -> (count: i8)\n    requires \n        valid_input(digits@.map(|i, x| x as int)),\n    ensures \n        count >= 0,\n        count as int == count_good_subarrays(digits@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(digits: Seq<int>) -> bool {\n    digits.len() >= 1 && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= 0 && #[trigger] digits[i] <= 9\n}\n\nspec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool\n    recommends 0 <= start <= end < digits.len()\n{\n    let subarray_sum = sum(digits.subrange(start, end + 1));\n    let subarray_length = end - start + 1;\n    subarray_sum == subarray_length\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.drop_first()) }\n}\n\nspec fn count_good_subarrays(digits: Seq<int>) -> int\n    recommends valid_input(digits)\n{\n    count_good_subarrays_helper(digits, 0, map![0 => 1], 0, 0)\n}\n\nspec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, \n                                  current_sum: int, current_count: int) -> int\n    recommends \n        0 <= pos <= digits.len() &&\n        valid_input(digits) &&\n        current_count == pos &&\n        current_sum >= 0 &&\n        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&\n        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)\n    decreases digits.len() - pos\n{\n    if pos >= digits.len() { 0 }\n    else {\n        let new_sum = current_sum + digits[pos];\n        let new_count = current_count + 1;\n        let diff = new_count - new_sum;\n        let contribution = if freq_map.dom().contains(diff) { freq_map[diff] } else { 0 };\n        let new_freq_map = freq_map.insert(diff, if freq_map.dom().contains(diff) { freq_map[diff] + 1 } else { 1 });\n        contribution + count_good_subarrays_helper(digits, pos + 1, new_freq_map, new_sum, new_count)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_good_subarrays_in_array(digits: Vec<i8>) -> (count: i8)\n    requires \n        valid_input(digits@.map(|i, x| x as int)),\n    ensures \n        count >= 0,\n        count as int == count_good_subarrays(digits@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2548.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 778, "minimize_time_ms": 153709, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 74, "minimized_LOC": 74, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(digits: Seq<int>) -> bool {\n\nspec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool\n    recommends 0 <= start <= end < digits.len()\n{\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn count_good_subarrays(digits: Seq<int>) -> int\n    recommends valid_input(digits)\n{\n\nspec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, \n                                  current_sum: int, current_count: int) -> int\n    recommends \n        0 <= pos <= digits.len() &&\n        valid_input(digits) &&\n        current_count == pos &&\n        current_sum >= 0 &&\n        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&\n        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)\n    decreases digits.len() - pos\n{\n\n    decreases s.len()\n\n    decreases digits.len() - pos\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(digits: Seq<int>) -> bool {\n    digits.len() >= 1 && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= 0 && #[trigger] digits[i] <= 9\n}\n\nspec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool\n    recommends 0 <= start <= end < digits.len()\n{\n    let subarray_sum = sum(digits.subrange(start, end + 1));\n    let subarray_length = end - start + 1;\n    subarray_sum == subarray_length\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.drop_first()) }\n}\n\nspec fn count_good_subarrays(digits: Seq<int>) -> int\n    recommends valid_input(digits)\n{\n    count_good_subarrays_helper(digits, 0, map![0 => 1], 0, 0)\n}\n\nspec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, \n                                  current_sum: int, current_count: int) -> int\n    recommends \n        0 <= pos <= digits.len() &&\n        valid_input(digits) &&\n        current_count == pos &&\n        current_sum >= 0 &&\n        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&\n        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)\n    decreases digits.len() - pos\n{\n    if pos >= digits.len() { 0 }\n    else {\n        let new_sum = current_sum + digits[pos];\n        let new_count = current_count + 1;\n        let diff = new_count - new_sum;\n        let contribution = if freq_map.dom().contains(diff) { freq_map[diff] } else { 0 };\n        let new_freq_map = freq_map.insert(diff, if freq_map.dom().contains(diff) { freq_map[diff] + 1 } else { 1 });\n        contribution + count_good_subarrays_helper(digits, pos + 1, new_freq_map, new_sum, new_count)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_good_subarrays_in_array(digits: Vec<i8>) -> (count: i8)\n    requires \n        valid_input(digits@.map(|i, x| x as int)),\n    ensures \n        count >= 0,\n        count as int == count_good_subarrays(digits@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n           fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2550_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && scores.len() == n &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 0 && #[trigger] scores[i] <= m\n}\n\nspec fn sum(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 { \n        0 \n    } else { \n        nums[0] + sum(nums.subrange(1, nums.len() as int)) \n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {\n    redistributed.len() == original.len() &&\n    sum(redistributed) == sum(original) &&\n    forall|i: int| 0 <= i < redistributed.len() ==> #[trigger] redistributed[i] >= 0 && #[trigger] redistributed[i] <= m\n}\n\nspec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {\n    min(sum(scores), m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, scores: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n    ensures \n        result as int == max_possible_first_score(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n        result as int == min(sum(scores@.map(|_i: int, x: i8| x as int)), m as int),\n        exists|redistributed: Seq<int>| (valid_redistribution(scores@.map(|_i: int, x: i8| x as int), redistributed, m as int) && \n            redistributed[0] == result as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && scores.len() == n &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 0 && #[trigger] scores[i] <= m\n}\n\nspec fn sum(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 { \n        0 \n    } else { \n        nums[0] + sum(nums.subrange(1, nums.len() as int)) \n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {\n    redistributed.len() == original.len() &&\n    sum(redistributed) == sum(original) &&\n    forall|i: int| 0 <= i < redistributed.len() ==> #[trigger] redistributed[i] >= 0 && #[trigger] redistributed[i] <= m\n}\n\nspec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {\n    min(sum(scores), m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, scores: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n    ensures \n        result as int == max_possible_first_score(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n        result as int == min(sum(scores@.map(|_i: int, x: i8| x as int)), m as int),\n        exists|redistributed: Seq<int>| (valid_redistribution(scores@.map(|_i: int, x: i8| x as int), redistributed, m as int) && \n            redistributed[0] == result as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2550.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 709, "minimize_time_ms": 122531, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {\n\nspec fn sum(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n\nspec fn min(a: int, b: int) -> int {\n\nspec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {\n\nspec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {\n\n    decreases nums.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && scores.len() == n &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 0 && #[trigger] scores[i] <= m\n}\n\nspec fn sum(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 { \n        0 \n    } else { \n        nums[0] + sum(nums.subrange(1, nums.len() as int)) \n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {\n    redistributed.len() == original.len() &&\n    sum(redistributed) == sum(original) &&\n    forall|i: int| 0 <= i < redistributed.len() ==> #[trigger] redistributed[i] >= 0 && #[trigger] redistributed[i] <= m\n}\n\nspec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {\n    min(sum(scores), m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, scores: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n    ensures \n        result as int == max_possible_first_score(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n        result as int == min(sum(scores@.map(|_i: int, x: i8| x as int)), m as int),\n        exists|redistributed: Seq<int>| (valid_redistribution(scores@.map(|_i: int, x: i8| x as int), redistributed, m as int) && \n            redistributed[0] == result as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2568_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'\n}\n\nspec fn compute_result(s: Seq<char>) -> int {\n    compute_result_helper(s, 0, 0, 0, s.len() as int)\n}\n\nspec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        ans\n    } else if s[i] == '+' {\n        compute_result_helper(s, i + 1, cur + 1, pm, ans)\n    } else {\n        let new_cur = cur - 1;\n        if new_cur < pm {\n            compute_result_helper(s, i + 1, new_cur, new_cur, ans + i + 1)\n        } else {\n            compute_result_helper(s, i + 1, new_cur, pm, ans)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(s@),\n        s.len() <= 127\n    ensures \n        result as int >= s@.len(),\n        result as int == compute_result(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'\n}\n\nspec fn compute_result(s: Seq<char>) -> int {\n    compute_result_helper(s, 0, 0, 0, s.len() as int)\n}\n\nspec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        ans\n    } else if s[i] == '+' {\n        compute_result_helper(s, i + 1, cur + 1, pm, ans)\n    } else {\n        let new_cur = cur - 1;\n        if new_cur < pm {\n            compute_result_helper(s, i + 1, new_cur, new_cur, ans + i + 1)\n        } else {\n            compute_result_helper(s, i + 1, new_cur, pm, ans)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(s@),\n        s.len() <= 127\n    ensures \n        result as int >= s@.len(),\n        result as int == compute_result(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2568.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 775, "minimize_time_ms": 92498, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn compute_result(s: Seq<char>) -> int {\n\nspec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n\n    decreases s.len() - i when 0 <= i <= s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'\n}\n\nspec fn compute_result(s: Seq<char>) -> int {\n    compute_result_helper(s, 0, 0, 0, s.len() as int)\n}\n\nspec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        ans\n    } else if s[i] == '+' {\n        compute_result_helper(s, i + 1, cur + 1, pm, ans)\n    } else {\n        let new_cur = cur - 1;\n        if new_cur < pm {\n            compute_result_helper(s, i + 1, new_cur, new_cur, ans + i + 1)\n        } else {\n            compute_result_helper(s, i + 1, new_cur, pm, ans)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(s@),\n        s.len() <= 127\n    ensures \n        result as int >= s@.len(),\n        result as int == compute_result(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2583_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn determine_winner(n: int) -> &'static str\n    recommends n >= 1\n{\n    if n == 1 { \"FastestFinger\" }\n    else if n == 2 { \"Ashishgup\" }\n    else if is_power_of_two(n) { \"FastestFinger\" }\n    else if n % 4 != 2 { \"Ashishgup\" }\n    else if is_limited_prime(n / 2) { \"FastestFinger\" }\n    else { \"Ashishgup\" }\n}\n\nspec fn is_power_of_two(n: int) -> bool\n    recommends n >= 1\n    decreases n\n{\n    if n <= 0 { false }\n    else { n == 1 || (n % 2 == 0 && is_power_of_two(n / 2)) }\n}\n\nspec fn is_limited_prime(p: int) -> bool\n    recommends p >= 1\n{\n    if p <= 1 { false }\n    else if p == 2 { true }\n    else if p % 2 == 0 { false }\n    else { true /* simplified primality check */ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<i8>) -> (result: Vec<&'static str>)\n    requires\n        input.len() >= 1,\n        input[0] as int >= 1,\n        input.len() == input[0] as int + 1,\n        forall|i: int| #![auto] 1 <= i < input.len() ==> input[i as int] as int >= 1\n    ensures\n        result.len() == input[0] as int,\n        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int] == \"FastestFinger\" || result[i as int] == \"Ashishgup\",\n        forall|i: int| #![auto] 1 <= i < input.len() ==> result[(i-1) as int] == determine_winner(input[i as int] as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn determine_winner(n: int) -> &'static str\n    recommends n >= 1\n{\n    if n == 1 { \"FastestFinger\" }\n    else if n == 2 { \"Ashishgup\" }\n    else if is_power_of_two(n) { \"FastestFinger\" }\n    else if n % 4 != 2 { \"Ashishgup\" }\n    else if is_limited_prime(n / 2) { \"FastestFinger\" }\n    else { \"Ashishgup\" }\n}\n\nspec fn is_power_of_two(n: int) -> bool\n    recommends n >= 1\n    decreases n\n{\n    if n <= 0 { false }\n    else { n == 1 || (n % 2 == 0 && is_power_of_two(n / 2)) }\n}\n\nspec fn is_limited_prime(p: int) -> bool\n    recommends p >= 1\n{\n    if p <= 1 { false }\n    else if p == 2 { true }\n    else if p % 2 == 0 { false }\n    else { true /* simplified primality check */ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<i8>) -> (result: Vec<&'static str>)\n    requires\n        input.len() >= 1,\n        input[0] as int >= 1,\n        input.len() == input[0] as int + 1,\n        forall|i: int| #![auto] 1 <= i < input.len() ==> input[i as int] as int >= 1\n    ensures\n        result.len() == input[0] as int,\n        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int] == \"FastestFinger\" || result[i as int] == \"Ashishgup\",\n        forall|i: int| #![auto] 1 <= i < input.len() ==> result[(i-1) as int] == determine_winner(input[i as int] as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2583.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 717, "minimize_time_ms": 123209, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn determine_winner(n: int) -> &'static str\n    recommends n >= 1\n{\n\nspec fn is_power_of_two(n: int) -> bool\n    recommends n >= 1\n    decreases n\n{\n\nspec fn is_limited_prime(p: int) -> bool\n    recommends p >= 1\n{\n\n    decreases n\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn determine_winner(n: int) -> &'static str\n    recommends n >= 1\n{\n    if n == 1 { \"FastestFinger\" }\n    else if n == 2 { \"Ashishgup\" }\n    else if is_power_of_two(n) { \"FastestFinger\" }\n    else if n % 4 != 2 { \"Ashishgup\" }\n    else if is_limited_prime(n / 2) { \"FastestFinger\" }\n    else { \"Ashishgup\" }\n}\n\nspec fn is_power_of_two(n: int) -> bool\n    recommends n >= 1\n    decreases n\n{\n    if n <= 0 { false }\n    else { n == 1 || (n % 2 == 0 && is_power_of_two(n / 2)) }\n}\n\nspec fn is_limited_prime(p: int) -> bool\n    recommends p >= 1\n{\n    if p <= 1 { false }\n    else if p == 2 { true }\n    else if p % 2 == 0 { false }\n    else { true /* simplified primality check */ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<i8>) -> (result: Vec<&'static str>)\n    requires\n        input.len() >= 1,\n        input[0] as int >= 1,\n        input.len() == input[0] as int + 1,\n        forall|i: int| #![auto] 1 <= i < input.len() ==> input[i as int] as int >= 1\n    ensures\n        result.len() == input[0] as int,\n        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int] == \"FastestFinger\" || result[i as int] == \"Ashishgup\",\n        forall|i: int| #![auto] 1 <= i < input.len() ==> result[(i-1) as int] == determine_winner(input[i as int] as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n      fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2622_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = parse_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let first_line = parse_ints_func(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 1 && m <= n &&\n            lines.len() >= 1 + n + m &&\n            (forall|k: int| 1 <= k <= n ==> k < lines.len() && lines[k].len() >= m) &&\n            (forall|k: int| 1 + n <= k < 1 + n + m ==> k < lines.len() && lines[k].len() >= n)\n        }\n    }\n}\n\nspec fn valid_solution(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = parse_lines_func(input);\n    if lines.len() < 3 { \n        true \n    } else {\n        let first_line = parse_ints_func(lines[0]);\n        if first_line.len() < 2 { \n            true \n        } else {\n            let n = first_line[0];\n            let m = first_line[1];\n            if n <= 0 || m <= 0 || m > n { \n                true \n            } else {\n                let result_parts = parse_ints_func(result);\n                if result_parts.len() < 2 { \n                    false \n                } else {\n                    let i = result_parts[0];\n                    let j = result_parts[1];\n                    1 <= i <= n - m + 1 && 1 <= j <= n - m + 1 &&\n                    if lines.len() >= 1 + n + m { \n                        correct_sub_matrices_match(lines, n, m, i - 1, j - 1) \n                    } else { \n                        false \n                    }\n                }\n            }\n        }\n    }\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        false \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        exists|i: int, j: int| 0 <= i <= n - m && 0 <= j <= n - m &&\n            correct_sub_matrices_match(lines, n, m, i, j)\n    }\n}\n\nspec fn solution_found(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_solution(input, result) &&\n    if !valid_input_format(input) { \n        false \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let i = result_parts[0] - 1;\n            let j = result_parts[1] - 1;\n            correct_sub_matrices_match(lines, n, m, i, j)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        true \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let i = result_parts[0] - 1;\n            let j = result_parts[1] - 1;\n            0 <= i <= n - m && 0 <= j <= n - m &&\n            (forall|r: int, c: int| \n                #![trigger r + c]\n                (0 <= r < m && 0 <= c < m) ==> true)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn always_returns_first_match(input: Seq<char>, result: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        true \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let result_i = result_parts[0] - 1;\n            let result_j = result_parts[1] - 1;\n            forall|i: int, j: int| \n                #![trigger correct_sub_matrices_match(lines, n, m, i, j)]\n                (0 <= i <= n - m && 0 <= j <= n - m &&\n                (i < result_i || (i == result_i && j < result_j))) ==>\n                !correct_sub_matrices_match(lines, n, m, i, j)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool\n    recommends \n        lines.len() >= 1 + n + m,\n        0 <= i <= n - m && 0 <= j <= n - m\n{\n    forall|r: int, c: int| \n        #![trigger r + c]\n        (0 <= r < m && 0 <= c < m) ==> true\n}\n\nspec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]\n}\n\nspec fn parse_ints_func(line: Seq<char>) -> Seq<int> {\n    seq![1, 1]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else { seq!['1', '0'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        result@.len() > 0,\n        exists|i: int, j: int| i >= 1 && j >= 1 && result@ == int_to_string_func(i) + seq![' '] + int_to_string_func(j),\n        valid_solution(stdin_input@, result@),\n        solution_exists(stdin_input@) ==> solution_found(stdin_input@, result@),\n        correct_matrix_matching(stdin_input@, result@),\n        always_returns_first_match(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool     recommends          lines.len() >= 1 + n + m,         0 <= i <= n - m && 0 <= j <= n - m ;\n       spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2622.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 838, "minimize_time_ms": 153772, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 194, "minimized_LOC": 10, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 6, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.05154639175257732}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool     recommends          lines.len() >= 1 + n + m,         0 <= i <= n - m && 0 <= j <= n - m ;\n       spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;\n       }\n        fn main() {\n\nspec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool     recommends          lines.len() >= 1 + n + m,         0 <= i <= n - m && 0 <= j <= n - m ;\n       spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;\n       }\n        fn main() {\n\nspec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool     recommends          lines.len() >= 1 + n + m,         0 <= i <= n - m && 0 <= j <= n - m ;\n       spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;\n       }\n        fn main() {\n\nspec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;\n       }\n        fn main() {\n\nspec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;\n       }\n        fn main() {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = parse_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let first_line = parse_ints_func(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 1 && m <= n &&\n            lines.len() >= 1 + n + m &&\n            (forall|k: int| 1 <= k <= n ==> k < lines.len() && lines[k].len() >= m) &&\n            (forall|k: int| 1 + n <= k < 1 + n + m ==> k < lines.len() && lines[k].len() >= n)\n        }\n    }\n}\n\nspec fn valid_solution(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = parse_lines_func(input);\n    if lines.len() < 3 { \n        true \n    } else {\n        let first_line = parse_ints_func(lines[0]);\n        if first_line.len() < 2 { \n            true \n        } else {\n            let n = first_line[0];\n            let m = first_line[1];\n            if n <= 0 || m <= 0 || m > n { \n                true \n            } else {\n                let result_parts = parse_ints_func(result);\n                if result_parts.len() < 2 { \n                    false \n                } else {\n                    let i = result_parts[0];\n                    let j = result_parts[1];\n                    1 <= i <= n - m + 1 && 1 <= j <= n - m + 1 &&\n                    if lines.len() >= 1 + n + m { \n                        correct_sub_matrices_match(lines, n, m, i - 1, j - 1) \n                    } else { \n                        false \n                    }\n                }\n            }\n        }\n    }\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        false \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        exists|i: int, j: int| 0 <= i <= n - m && 0 <= j <= n - m &&\n            correct_sub_matrices_match(lines, n, m, i, j)\n    }\n}\n\nspec fn solution_found(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_solution(input, result) &&\n    if !valid_input_format(input) { \n        false \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let i = result_parts[0] - 1;\n            let j = result_parts[1] - 1;\n            correct_sub_matrices_match(lines, n, m, i, j)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        true \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let i = result_parts[0] - 1;\n            let j = result_parts[1] - 1;\n            0 <= i <= n - m && 0 <= j <= n - m &&\n            (forall|r: int, c: int| \n                #![trigger r + c]\n                (0 <= r < m && 0 <= c < m) ==> true)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn always_returns_first_match(input: Seq<char>, result: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        true \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let result_i = result_parts[0] - 1;\n            let result_j = result_parts[1] - 1;\n            forall|i: int, j: int| \n                #![trigger correct_sub_matrices_match(lines, n, m, i, j)]\n                (0 <= i <= n - m && 0 <= j <= n - m &&\n                (i < result_i || (i == result_i && j < result_j))) ==>\n                !correct_sub_matrices_match(lines, n, m, i, j)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool\n    recommends \n        lines.len() >= 1 + n + m,\n        0 <= i <= n - m && 0 <= j <= n - m\n{\n    forall|r: int, c: int| \n        #![trigger r + c]\n        (0 <= r < m && 0 <= c < m) ==> true\n}\n\nspec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]\n}\n\nspec fn parse_ints_func(line: Seq<char>) -> Seq<int> {\n    seq![1, 1]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else { seq!['1', '0'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        result@.len() > 0,\n        exists|i: int, j: int| i >= 1 && j >= 1 && result@ == int_to_string_func(i) + seq![' '] + int_to_string_func(j),\n        valid_solution(stdin_input@, result@),\n        solution_exists(stdin_input@) ==> solution_found(stdin_input@, result@),\n        correct_matrix_matching(stdin_input@, result@),\n        always_returns_first_match(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool     recommends          lines.len() >= 1 + n + m,         0 <= i <= n - m && 0 <= j <= n - m ;\n       spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;\n       }\n        fn main() {\n      }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2629_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn spiral_order(row: int, col: int, n: int) -> int\n    recommends 0 <= row < n && 0 <= col < n && n >= 1\n    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1\n{\n    let layer = min(min(row, col), min(n-1-row, n-1-col));\n    let layer_start = 4 * layer * (n - layer - 1) + layer;\n\n    if row == layer {\n        /* Top row of current layer */\n        layer_start + (col - layer)\n    } else if col == n - 1 - layer {\n        /* Right column of current layer */\n        layer_start + (n - 2 * layer - 1) + (row - layer)\n    } else if row == n - 1 - layer {\n        /* Bottom row of current layer */\n        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)\n    } else {\n        /* Left column of current layer */\n        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {\n    matrix.len() == n &&\n    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)\n    requires \n        valid_input(n as int)\n    ensures \n        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn spiral_order(row: int, col: int, n: int) -> int\n    recommends 0 <= row < n && 0 <= col < n && n >= 1\n    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1\n{\n    let layer = min(min(row, col), min(n-1-row, n-1-col));\n    let layer_start = 4 * layer * (n - layer - 1) + layer;\n\n    if row == layer {\n        /* Top row of current layer */\n        layer_start + (col - layer)\n    } else if col == n - 1 - layer {\n        /* Right column of current layer */\n        layer_start + (n - 2 * layer - 1) + (row - layer)\n    } else if row == n - 1 - layer {\n        /* Bottom row of current layer */\n        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)\n    } else {\n        /* Left column of current layer */\n        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {\n    matrix.len() == n &&\n    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)\n    requires \n        valid_input(n as int)\n    ensures \n        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2629.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 803, "minimize_time_ms": 153436, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn min(a: int, b: int) -> int {\n\nspec fn spiral_order(row: int, col: int, n: int) -> int\n    recommends 0 <= row < n && 0 <= col < n && n >= 1\n    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1\n{\n\nspec fn valid_input(n: int) -> bool {\n\nspec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {\n\n    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn spiral_order(row: int, col: int, n: int) -> int\n    recommends 0 <= row < n && 0 <= col < n && n >= 1\n    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1\n{\n    let layer = min(min(row, col), min(n-1-row, n-1-col));\n    let layer_start = 4 * layer * (n - layer - 1) + layer;\n\n    if row == layer {\n        /* Top row of current layer */\n        layer_start + (col - layer)\n    } else if col == n - 1 - layer {\n        /* Right column of current layer */\n        layer_start + (n - 2 * layer - 1) + (row - layer)\n    } else if row == n - 1 - layer {\n        /* Bottom row of current layer */\n        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)\n    } else {\n        /* Left column of current layer */\n        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {\n    matrix.len() == n &&\n    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)\n    requires \n        valid_input(n as int)\n    ensures \n        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2630_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && grid[0].len() > 0 &&\n    (forall|i: int| #![trigger grid[i].len(), grid[0].len()] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()) &&\n    (forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn binomial(n: int, k: int) -> int\n    decreases n, k\n{\n    if k > n || n < 0 || k < 0 {\n        0int\n    } else if k == 0 || k == n {\n        1int\n    } else if k == 1 {\n        n\n    } else {\n        binomial(n-1, k-1) + binomial(n-1, k)\n    }\n}\n\nspec fn dp_path_count(grid: Seq<Seq<int>>) -> int\n    recommends valid_grid(grid)\n{\n    let m = grid.len();\n    let n = grid[0].len();\n    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {\n        0int\n    } else if m == 1 && n == 1 {\n        1int\n    } else if m == 1 {\n        if forall|j: int| #![trigger grid[0][j]] 0 <= j < n ==> grid[0][j] == 0 { 1int } else { 0int }\n    } else if n == 1 {\n        if forall|i: int| #![trigger grid[i][0]] 0 <= i < m ==> grid[i][0] == 0 { 1int } else { 0int }\n    } else if forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 {\n        binomial(m + n - 2, m - 1)\n    } else {\n        0int  /* placeholder for complex case */\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nexec fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i8>>) -> (result: i8)\n    requires \n        valid_grid(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n    ensures \n        result >= 0,\n        obstacle_grid@[0][0] == 1 ==> result == 0,\n        obstacle_grid@[obstacle_grid@.len()-1][obstacle_grid@[0].len()-1] == 1 ==> result == 0,\n        obstacle_grid@.len() == 1 && obstacle_grid@[0].len() == 1 ==> \n            result == (if obstacle_grid@[0][0] == 0 { 1i8 } else { 0i8 }),\n        result as int == dp_path_count(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n        (forall|i: int, j: int| #![trigger obstacle_grid@[i][j]] 0 <= i < obstacle_grid@.len() && 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[i][j] == 0) ==> \n            result as int == binomial(obstacle_grid@.len() + obstacle_grid@[0].len() - 2, obstacle_grid@.len() - 1),\n        obstacle_grid@.len() == 1 ==> \n            (result > 0 <==> (forall|j: int| #![trigger obstacle_grid@[0][j]] 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[0][j] == 0)),\n        obstacle_grid@[0].len() == 1 ==> \n            (result > 0 <==> (forall|i: int| #![trigger obstacle_grid@[i][0]] 0 <= i < obstacle_grid@.len() ==> obstacle_grid@[i][0] == 0))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && grid[0].len() > 0 &&\n    (forall|i: int| #![trigger grid[i].len(), grid[0].len()] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()) &&\n    (forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn binomial(n: int, k: int) -> int\n    decreases n, k\n{\n    if k > n || n < 0 || k < 0 {\n        0int\n    } else if k == 0 || k == n {\n        1int\n    } else if k == 1 {\n        n\n    } else {\n        binomial(n-1, k-1) + binomial(n-1, k)\n    }\n}\n\nspec fn dp_path_count(grid: Seq<Seq<int>>) -> int\n    recommends valid_grid(grid)\n{\n    let m = grid.len();\n    let n = grid[0].len();\n    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {\n        0int\n    } else if m == 1 && n == 1 {\n        1int\n    } else if m == 1 {\n        if forall|j: int| #![trigger grid[0][j]] 0 <= j < n ==> grid[0][j] == 0 { 1int } else { 0int }\n    } else if n == 1 {\n        if forall|i: int| #![trigger grid[i][0]] 0 <= i < m ==> grid[i][0] == 0 { 1int } else { 0int }\n    } else if forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 {\n        binomial(m + n - 2, m - 1)\n    } else {\n        0int  /* placeholder for complex case */\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nexec fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i8>>) -> (result: i8)\n    requires \n        valid_grid(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n    ensures \n        result >= 0,\n        obstacle_grid@[0][0] == 1 ==> result == 0,\n        obstacle_grid@[obstacle_grid@.len()-1][obstacle_grid@[0].len()-1] == 1 ==> result == 0,\n        obstacle_grid@.len() == 1 && obstacle_grid@[0].len() == 1 ==> \n            result == (if obstacle_grid@[0][0] == 0 { 1i8 } else { 0i8 }),\n        result as int == dp_path_count(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n        (forall|i: int, j: int| #![trigger obstacle_grid@[i][j]] 0 <= i < obstacle_grid@.len() && 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[i][j] == 0) ==> \n            result as int == binomial(obstacle_grid@.len() + obstacle_grid@[0].len() - 2, obstacle_grid@.len() - 1),\n        obstacle_grid@.len() == 1 ==> \n            (result > 0 <==> (forall|j: int| #![trigger obstacle_grid@[0][j]] 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[0][j] == 0)),\n        obstacle_grid@[0].len() == 1 ==> \n            (result > 0 <==> (forall|i: int| #![trigger obstacle_grid@[i][0]] 0 <= i < obstacle_grid@.len() ==> obstacle_grid@[i][0] == 0))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2630.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 811, "minimize_time_ms": 183714, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 81, "minimized_LOC": 81, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n\nspec fn binomial(n: int, k: int) -> int\n    decreases n, k\n{\n\nspec fn dp_path_count(grid: Seq<Seq<int>>) -> int\n    recommends valid_grid(grid)\n{\n\n    decreases n, k\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && grid[0].len() > 0 &&\n    (forall|i: int| #![trigger grid[i].len(), grid[0].len()] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()) &&\n    (forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn binomial(n: int, k: int) -> int\n    decreases n, k\n{\n    if k > n || n < 0 || k < 0 {\n        0int\n    } else if k == 0 || k == n {\n        1int\n    } else if k == 1 {\n        n\n    } else {\n        binomial(n-1, k-1) + binomial(n-1, k)\n    }\n}\n\nspec fn dp_path_count(grid: Seq<Seq<int>>) -> int\n    recommends valid_grid(grid)\n{\n    let m = grid.len();\n    let n = grid[0].len();\n    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {\n        0int\n    } else if m == 1 && n == 1 {\n        1int\n    } else if m == 1 {\n        if forall|j: int| #![trigger grid[0][j]] 0 <= j < n ==> grid[0][j] == 0 { 1int } else { 0int }\n    } else if n == 1 {\n        if forall|i: int| #![trigger grid[i][0]] 0 <= i < m ==> grid[i][0] == 0 { 1int } else { 0int }\n    } else if forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 {\n        binomial(m + n - 2, m - 1)\n    } else {\n        0int  /* placeholder for complex case */\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nexec fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i8>>) -> (result: i8)\n    requires \n        valid_grid(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n    ensures \n        result >= 0,\n        obstacle_grid@[0][0] == 1 ==> result == 0,\n        obstacle_grid@[obstacle_grid@.len()-1][obstacle_grid@[0].len()-1] == 1 ==> result == 0,\n        obstacle_grid@.len() == 1 && obstacle_grid@[0].len() == 1 ==> \n            result == (if obstacle_grid@[0][0] == 0 { 1i8 } else { 0i8 }),\n        result as int == dp_path_count(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n        (forall|i: int, j: int| #![trigger obstacle_grid@[i][j]] 0 <= i < obstacle_grid@.len() && 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[i][j] == 0) ==> \n            result as int == binomial(obstacle_grid@.len() + obstacle_grid@[0].len() - 2, obstacle_grid@.len() - 1),\n        obstacle_grid@.len() == 1 ==> \n            (result > 0 <==> (forall|j: int| #![trigger obstacle_grid@[0][j]] 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[0][j] == 0)),\n        obstacle_grid@[0].len() == 1 ==> \n            (result > 0 <==> (forall|i: int| #![trigger obstacle_grid@[i][0]] 0 <= i < obstacle_grid@.len() ==> obstacle_grid@[i][0] == 0))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2632_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {\n    path.len() >= 1 &&\n    path[0] == (0int, 0int) &&\n    path[path.len() - 1] == (m - 1, n - 1) &&\n    (forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&\n    forall|i: int| #![trigger path[i]] 0 <= i < path.len() - 1 ==> \n        (path[i + 1].0 == path[i].0 && path[i + 1].1 == path[i].1 + 1) ||\n        (path[i + 1].0 == path[i].0 + 1 && path[i + 1].1 == path[i].1)\n}\n\nspec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int\n    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()\n    decreases path.len()\n{\n    if path.len() == 0 { \n        0 \n    } else { \n        grid[path[0].0][path[0].1] as int + path_sum(path.subrange(1, path.len() as int), grid)\n    }\n}\n\nspec fn valid_input(grid: Seq<Vec<i32>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (grid.len() > 0 ==> (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len())) &&\n    forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn min_path_sum(grid: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        valid_input(grid@),\n    ensures \n        result >= 0,\n        grid.len() == 1 && grid[0].len() == 1 ==> result == grid[0][0],\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {\n    path.len() >= 1 &&\n    path[0] == (0int, 0int) &&\n    path[path.len() - 1] == (m - 1, n - 1) &&\n    (forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&\n    forall|i: int| #![trigger path[i]] 0 <= i < path.len() - 1 ==> \n        (path[i + 1].0 == path[i].0 && path[i + 1].1 == path[i].1 + 1) ||\n        (path[i + 1].0 == path[i].0 + 1 && path[i + 1].1 == path[i].1)\n}\n\nspec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int\n    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()\n    decreases path.len()\n{\n    if path.len() == 0 { \n        0 \n    } else { \n        grid[path[0].0][path[0].1] as int + path_sum(path.subrange(1, path.len() as int), grid)\n    }\n}\n\nspec fn valid_input(grid: Seq<Vec<i32>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (grid.len() > 0 ==> (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len())) &&\n    forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn min_path_sum(grid: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        valid_input(grid@),\n    ensures \n        result >= 0,\n        grid.len() == 1 && grid[0].len() == 1 ==> result == grid[0][0],\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2632.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 752, "minimize_time_ms": 123505, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {\n\nspec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int\n    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()\n    decreases path.len()\n{\n\nspec fn valid_input(grid: Seq<Vec<i32>>) -> bool {\n\n    decreases path.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {\n    path.len() >= 1 &&\n    path[0] == (0int, 0int) &&\n    path[path.len() - 1] == (m - 1, n - 1) &&\n    (forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&\n    forall|i: int| #![trigger path[i]] 0 <= i < path.len() - 1 ==> \n        (path[i + 1].0 == path[i].0 && path[i + 1].1 == path[i].1 + 1) ||\n        (path[i + 1].0 == path[i].0 + 1 && path[i + 1].1 == path[i].1)\n}\n\nspec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int\n    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()\n    decreases path.len()\n{\n    if path.len() == 0 { \n        0 \n    } else { \n        grid[path[0].0][path[0].1] as int + path_sum(path.subrange(1, path.len() as int), grid)\n    }\n}\n\nspec fn valid_input(grid: Seq<Vec<i32>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (grid.len() > 0 ==> (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len())) &&\n    forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn min_path_sum(grid: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        valid_input(grid@),\n    ensures \n        result >= 0,\n        grid.len() == 1 && grid[0].len() == 1 ==> result == grid[0][0],\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n           fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2633_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {\n    dungeon.len() > 0 &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() > 0) &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() == dungeon[0].len())\n}\n\nspec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool\n    recommends valid_dungeon(dungeon)\n{\n    path.len() > 0 &&\n    path[0] == (0int, 0int) &&\n    path[path.len()-1] == (dungeon.len()-1, dungeon[0].len()-1) &&\n    (forall|i: int| 0 <= i < path.len() ==> {\n        let (r, c) = #[trigger] path[i];\n        0 <= r < dungeon.len() && 0 <= c < dungeon[0].len()\n    }) &&\n    forall|i: int| 0 <= i < path.len()-1 ==> {\n        (#[trigger] path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||\n        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)\n    }\n}\n\nspec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int\n    recommends \n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path),\n        0 <= step < path.len()\n    decreases step when step >= 0\n{\n    if step == 0 {\n        let (r, c) = path[0];\n        initial_health + dungeon[r][c]\n    } else {\n        let (r, c) = path[step];\n        health_at_step(dungeon, path, (step-1) as int, initial_health) + dungeon[r][c]\n    }\n}\n\nspec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool\n    recommends\n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path)\n{\n    forall|i: int| 0 <= i < path.len() ==> \n        #[trigger] health_at_step(dungeon, path, i, initial_health) > 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn calculate_minimum_hp(dungeon: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures result >= 1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {\n    dungeon.len() > 0 &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() > 0) &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() == dungeon[0].len())\n}\n\nspec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool\n    recommends valid_dungeon(dungeon)\n{\n    path.len() > 0 &&\n    path[0] == (0int, 0int) &&\n    path[path.len()-1] == (dungeon.len()-1, dungeon[0].len()-1) &&\n    (forall|i: int| 0 <= i < path.len() ==> {\n        let (r, c) = #[trigger] path[i];\n        0 <= r < dungeon.len() && 0 <= c < dungeon[0].len()\n    }) &&\n    forall|i: int| 0 <= i < path.len()-1 ==> {\n        (#[trigger] path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||\n        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)\n    }\n}\n\nspec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int\n    recommends \n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path),\n        0 <= step < path.len()\n    decreases step when step >= 0\n{\n    if step == 0 {\n        let (r, c) = path[0];\n        initial_health + dungeon[r][c]\n    } else {\n        let (r, c) = path[step];\n        health_at_step(dungeon, path, (step-1) as int, initial_health) + dungeon[r][c]\n    }\n}\n\nspec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool\n    recommends\n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path)\n{\n    forall|i: int| 0 <= i < path.len() ==> \n        #[trigger] health_at_step(dungeon, path, i, initial_health) > 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn calculate_minimum_hp(dungeon: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures result >= 1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2633.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 734, "minimize_time_ms": 123378, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {\n\nspec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool\n    recommends valid_dungeon(dungeon)\n{\n\nspec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int\n    recommends \n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path),\n        0 <= step < path.len()\n    decreases step when step >= 0\n{\n\nspec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool\n    recommends\n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path)\n{\n\n    decreases step when step >= 0\n\n    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n\n    ensures result >= 1"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {\n    dungeon.len() > 0 &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() > 0) &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() == dungeon[0].len())\n}\n\nspec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool\n    recommends valid_dungeon(dungeon)\n{\n    path.len() > 0 &&\n    path[0] == (0int, 0int) &&\n    path[path.len()-1] == (dungeon.len()-1, dungeon[0].len()-1) &&\n    (forall|i: int| 0 <= i < path.len() ==> {\n        let (r, c) = #[trigger] path[i];\n        0 <= r < dungeon.len() && 0 <= c < dungeon[0].len()\n    }) &&\n    forall|i: int| 0 <= i < path.len()-1 ==> {\n        (#[trigger] path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||\n        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)\n    }\n}\n\nspec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int\n    recommends \n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path),\n        0 <= step < path.len()\n    decreases step when step >= 0\n{\n    if step == 0 {\n        let (r, c) = path[0];\n        initial_health + dungeon[r][c]\n    } else {\n        let (r, c) = path[step];\n        health_at_step(dungeon, path, (step-1) as int, initial_health) + dungeon[r][c]\n    }\n}\n\nspec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool\n    recommends\n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path)\n{\n    forall|i: int| 0 <= i < path.len() ==> \n        #[trigger] health_at_step(dungeon, path, i, initial_health) > 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn calculate_minimum_hp(dungeon: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures result >= 1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_27_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, s: Seq<char>) -> bool {\n    s.len() == n\n}\n\nspec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {\n    max_copy_savings_up_to(s, n, n / 2)\n}\n\nspec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat\n    decreases limit\n{\n    if limit == 0 { 0 }\n    else {\n        let i = (limit - 1) as nat;\n        let current = if can_copy_at(s, n, i) { i } else { 0 };\n        let prev = max_copy_savings_up_to(s, n, i);\n        if current > prev { current } else { prev }\n    }\n}\n\nspec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {\n    let prefix_len = i + 1;\n    let end_pos = i + 1 + prefix_len;\n    end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i+1) as int, end_pos as int)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, s: Vec<char>) -> (result: u8)\n    requires \n        valid_input(n as nat, s@)\n    ensures \n        result as nat <= n as nat,\n        n == 0 ==> result == 0,\n        n > 0 ==> result >= 1,\n        result as nat == n as nat - max_copy_savings(s@, n as nat)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, s: Seq<char>) -> bool {\n    s.len() == n\n}\n\nspec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {\n    max_copy_savings_up_to(s, n, n / 2)\n}\n\nspec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat\n    decreases limit\n{\n    if limit == 0 { 0 }\n    else {\n        let i = (limit - 1) as nat;\n        let current = if can_copy_at(s, n, i) { i } else { 0 };\n        let prev = max_copy_savings_up_to(s, n, i);\n        if current > prev { current } else { prev }\n    }\n}\n\nspec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {\n    let prefix_len = i + 1;\n    let end_pos = i + 1 + prefix_len;\n    end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i+1) as int, end_pos as int)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, s: Vec<char>) -> (result: u8)\n    requires \n        valid_input(n as nat, s@)\n    ensures \n        result as nat <= n as nat,\n        n == 0 ==> result == 0,\n        n > 0 ==> result >= 1,\n        result as nat == n as nat - max_copy_savings(s@, n as nat)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_27.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 666, "minimize_time_ms": 92832, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: nat, s: Seq<char>) -> bool {\n\nspec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {\n\nspec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat\n    decreases limit\n{\n\nspec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {\n\n    decreases limit\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, s: Seq<char>) -> bool {\n    s.len() == n\n}\n\nspec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {\n    max_copy_savings_up_to(s, n, n / 2)\n}\n\nspec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat\n    decreases limit\n{\n    if limit == 0 { 0 }\n    else {\n        let i = (limit - 1) as nat;\n        let current = if can_copy_at(s, n, i) { i } else { 0 };\n        let prev = max_copy_savings_up_to(s, n, i);\n        if current > prev { current } else { prev }\n    }\n}\n\nspec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {\n    let prefix_len = i + 1;\n    let end_pos = i + 1 + prefix_len;\n    end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i+1) as int, end_pos as int)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, s: Vec<char>) -> (result: u8)\n    requires \n        valid_input(n as nat, s@)\n    ensures \n        result as nat <= n as nat,\n        n == 0 ==> result == 0,\n        n > 0 ==> result >= 1,\n        result as nat == n as nat - max_copy_savings(s@, n as nat)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_287_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 0 && k <= n\n}\n\nspec fn valid_output(result: Seq<int>, n: int, k: int) -> bool\n{\n    result.len() == 2 && \n    result[0] >= 0 && \n    result[1] >= 0 && \n    result[0] <= result[1] &&\n    result[0] <= n - k &&\n    result[1] <= n - k\n}\n\nspec fn min_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 } else { 1 }\n}\n\nspec fn max_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 }\n    else if n - k < k * 2 { n - k }\n    else { k * 2 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires valid_input(n as int, k as int)\n    ensures \n        result.len() == 2 &&\n        valid_output(result@.map(|i: int, x: i8| x as int), n as int, k as int) &&\n        result[0] as int == min_good_apartments(n as int, k as int) &&\n        result[1] as int == max_good_apartments(n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 0 && k <= n\n}\n\nspec fn valid_output(result: Seq<int>, n: int, k: int) -> bool\n{\n    result.len() == 2 && \n    result[0] >= 0 && \n    result[1] >= 0 && \n    result[0] <= result[1] &&\n    result[0] <= n - k &&\n    result[1] <= n - k\n}\n\nspec fn min_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 } else { 1 }\n}\n\nspec fn max_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 }\n    else if n - k < k * 2 { n - k }\n    else { k * 2 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires valid_input(n as int, k as int)\n    ensures \n        result.len() == 2 &&\n        valid_output(result@.map(|i: int, x: i8| x as int), n as int, k as int) &&\n        result[0] as int == min_good_apartments(n as int, k as int) &&\n        result[1] as int == max_good_apartments(n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_287.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 697, "minimize_time_ms": 92411, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int) -> bool\n{\n\nspec fn valid_output(result: Seq<int>, n: int, k: int) -> bool\n{\n\nspec fn min_good_apartments(n: int, k: int) -> int\n{\n\nspec fn max_good_apartments(n: int, k: int) -> int\n{\n\n    requires valid_input(n as int, k as int)\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 0 && k <= n\n}\n\nspec fn valid_output(result: Seq<int>, n: int, k: int) -> bool\n{\n    result.len() == 2 && \n    result[0] >= 0 && \n    result[1] >= 0 && \n    result[0] <= result[1] &&\n    result[0] <= n - k &&\n    result[1] <= n - k\n}\n\nspec fn min_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 } else { 1 }\n}\n\nspec fn max_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 }\n    else if n - k < k * 2 { n - k }\n    else { k * 2 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires valid_input(n as int, k as int)\n    ensures \n        result.len() == 2 &&\n        valid_output(result@.map(|i: int, x: i8| x as int), n as int, k as int) &&\n        result[0] as int == min_good_apartments(n as int, k as int) &&\n        result[1] as int == max_good_apartments(n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_299_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn chest_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn chest_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn biceps_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn biceps_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn back_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn back_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn valid_input(reps: Seq<int>) -> bool {\n    reps.len() > 0 && forall|i: int| 0 <= i < reps.len() ==> reps[i] > 0\n}\n\nspec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {\n    let chest_total_val = chest_total(reps);\n    let biceps_total_val = biceps_total(reps);\n    let back_total_val = back_total(reps);\n\n    match muscle {\n        \"chest\" => chest_total_val >= biceps_total_val && chest_total_val >= back_total_val,\n        \"biceps\" => biceps_total_val > chest_total_val && biceps_total_val >= back_total_val,\n        \"back\" => back_total_val > chest_total_val && back_total_val > biceps_total_val,\n        _ => false,\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_strongest_muscle_group(reps: Vec<i8>) -> (result: &'static str)\n    requires \n        valid_input(reps@.map(|i: int, x: i8| x as int))\n    ensures \n        result == \"chest\" || result == \"biceps\" || result == \"back\",\n        is_winner(result, reps@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"chest\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn chest_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn chest_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn biceps_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn biceps_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn back_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn back_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn valid_input(reps: Seq<int>) -> bool {\n    reps.len() > 0 && forall|i: int| 0 <= i < reps.len() ==> reps[i] > 0\n}\n\nspec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {\n    let chest_total_val = chest_total(reps);\n    let biceps_total_val = biceps_total(reps);\n    let back_total_val = back_total(reps);\n\n    match muscle {\n        \"chest\" => chest_total_val >= biceps_total_val && chest_total_val >= back_total_val,\n        \"biceps\" => biceps_total_val > chest_total_val && biceps_total_val >= back_total_val,\n        \"back\" => back_total_val > chest_total_val && back_total_val > biceps_total_val,\n        _ => false,\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_strongest_muscle_group(reps: Vec<i8>) -> (result: &'static str)\n    requires \n        valid_input(reps@.map(|i: int, x: i8| x as int))\n    ensures \n        result == \"chest\" || result == \"biceps\" || result == \"back\",\n        is_winner(result, reps@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"chest\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_299.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 800, "minimize_time_ms": 122580, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 110, "minimized_LOC": 110, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn chest_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n\nspec fn chest_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n\nspec fn biceps_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n\nspec fn biceps_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n\nspec fn back_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n\nspec fn back_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n\nspec fn valid_input(reps: Seq<int>) -> bool {\n\nspec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {\n\ndecreases reps.len()\n\ndecreases reps.len()\n\ndecreases reps.len()\n\ndecreases reps.len()\n\ndecreases reps.len()\n\ndecreases reps.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn chest_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn chest_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn biceps_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn biceps_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn back_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn back_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn valid_input(reps: Seq<int>) -> bool {\n    reps.len() > 0 && forall|i: int| 0 <= i < reps.len() ==> reps[i] > 0\n}\n\nspec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {\n    let chest_total_val = chest_total(reps);\n    let biceps_total_val = biceps_total(reps);\n    let back_total_val = back_total(reps);\n\n    match muscle {\n        \"chest\" => chest_total_val >= biceps_total_val && chest_total_val >= back_total_val,\n        \"biceps\" => biceps_total_val > chest_total_val && biceps_total_val >= back_total_val,\n        \"back\" => back_total_val > chest_total_val && back_total_val > biceps_total_val,\n        _ => false,\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_strongest_muscle_group(reps: Vec<i8>) -> (result: &'static str)\n    requires \n        valid_input(reps@.map(|i: int, x: i8| x as int))\n    ensures \n        result == \"chest\" || result == \"biceps\" || result == \"back\",\n        is_winner(result, reps@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"chest\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_302_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 } else { base * pow(base, (exp - 1) as nat) }\n}\n\nspec fn repunit(n: nat) -> nat\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n == 2 { 11 }\n    else if n == 3 { 111 }\n    else if n == 4 { 1111 }\n    else if n == 5 { 11111 }\n    else { n }\n}\n\nspec fn valid_input(n: nat) -> bool\n{\n    true\n}\n\nspec fn valid_output(n: nat, result: nat) -> bool\n{\n    (n == 0 ==> result == 0) &&\n    (n > 0 ==> result > 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn min_repunit_sum(n: u8) -> (result: u8)\n    requires valid_input(n as nat)\n    ensures valid_output(n as nat, result as nat)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 } else { base * pow(base, (exp - 1) as nat) }\n}\n\nspec fn repunit(n: nat) -> nat\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n == 2 { 11 }\n    else if n == 3 { 111 }\n    else if n == 4 { 1111 }\n    else if n == 5 { 11111 }\n    else { n }\n}\n\nspec fn valid_input(n: nat) -> bool\n{\n    true\n}\n\nspec fn valid_output(n: nat, result: nat) -> bool\n{\n    (n == 0 ==> result == 0) &&\n    (n > 0 ==> result > 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn min_repunit_sum(n: u8) -> (result: u8)\n    requires valid_input(n as nat)\n    ensures valid_output(n as nat, result as nat)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_302.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 634, "minimize_time_ms": 92034, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn pow(base: nat, exp: nat) -> nat\n    decreases exp\n{\n\nspec fn repunit(n: nat) -> nat\n{\n\nspec fn valid_input(n: nat) -> bool\n{\n\nspec fn valid_output(n: nat, result: nat) -> bool\n{\n\n    decreases exp\n\n    requires valid_input(n as nat)\n\n    ensures valid_output(n as nat, result as nat)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 } else { base * pow(base, (exp - 1) as nat) }\n}\n\nspec fn repunit(n: nat) -> nat\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n == 2 { 11 }\n    else if n == 3 { 111 }\n    else if n == 4 { 1111 }\n    else if n == 5 { 11111 }\n    else { n }\n}\n\nspec fn valid_input(n: nat) -> bool\n{\n    true\n}\n\nspec fn valid_output(n: nat, result: nat) -> bool\n{\n    (n == 0 ==> result == 0) &&\n    (n > 0 ==> result > 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn min_repunit_sum(n: u8) -> (result: u8)\n    requires valid_input(n as nat)\n    ensures valid_output(n as nat, result as nat)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_3805_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn extract_first_line(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        Seq::empty()\n    } else if input[0] == '\\n' {\n        Seq::empty()\n    } else {\n        seq![input[0]] + extract_first_line(input.subrange(1, input.len() as int))\n    }\n}\n\nspec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        stack\n    } else {\n        let c = input[0];\n        let new_stack = if stack.len() > 0 && stack[stack.len() - 1] == c {\n            stack.subrange(0, stack.len() - 1)\n        } else {\n            stack.push(c)\n        };\n        process_string(input.subrange(1, input.len() as int), new_stack)\n    }\n}\n\nspec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool\n{\n    let stack = process_string(input, Seq::empty());\n    stack.len() == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn extract_first_line(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        Seq::empty()\n    } else if input[0] == '\\n' {\n        Seq::empty()\n    } else {\n        seq![input[0]] + extract_first_line(input.subrange(1, input.len() as int))\n    }\n}\n\nspec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        stack\n    } else {\n        let c = input[0];\n        let new_stack = if stack.len() > 0 && stack[stack.len() - 1] == c {\n            stack.subrange(0, stack.len() - 1)\n        } else {\n            stack.push(c)\n        };\n        process_string(input.subrange(1, input.len() as int), new_stack)\n    }\n}\n\nspec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool\n{\n    let stack = process_string(input, Seq::empty());\n    stack.len() == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_3805.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 659, "minimize_time_ms": 92144, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn extract_first_line(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n\nspec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n\nspec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool\n{\n\n    decreases input.len()\n\n    decreases input.len()\n\n    ensures result@.len() > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn extract_first_line(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        Seq::empty()\n    } else if input[0] == '\\n' {\n        Seq::empty()\n    } else {\n        seq![input[0]] + extract_first_line(input.subrange(1, input.len() as int))\n    }\n}\n\nspec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        stack\n    } else {\n        let c = input[0];\n        let new_stack = if stack.len() > 0 && stack[stack.len() - 1] == c {\n            stack.subrange(0, stack.len() - 1)\n        } else {\n            stack.push(c)\n        };\n        process_string(input.subrange(1, input.len() as int), new_stack)\n    }\n}\n\nspec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool\n{\n    let stack = process_string(input, Seq::empty());\n    stack.len() == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4088_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* TODO: Implement full validation logic for:\n     * - Lines parsing and validation\n     * - Test case count validation  \n     * - String and integer array parsing\n     * - Character and bounds validation\n     */\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> output.len() > 0\n    /* TODO: Implement validation for:\n     * - Output lines matching test cases\n     * - Correct string lengths\n     * - Valid lowercase characters\n     */\n}\n\nspec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement constraint validation for:\n     * - Distance sum calculations\n     * - Character ordering requirements\n     */\n}\n\nspec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement character count preservation:\n     * - Character frequency validation\n     * - Subset usage validation\n     */\n}\n\nspec fn contains_newline_terminated_results(output: Seq<char>) -> bool {\n    output.len() > 0 ==> output[output.len() - 1] == '\\n'\n}\n\nspec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {\n    0\n    /* TODO: Implement distance sum calculation:\n     * - Compare characters lexicographically\n     * - Calculate absolute differences\n     * - Sum all applicable distances\n     */\n}\n\nspec fn abs_diff(i: int, j: int) -> int {\n    if i >= j { i - j } else { j - i }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        valid_output_format(result@, stdin_input@),\n        output_satisfies_constraints(result@, stdin_input@),\n        preserves_character_usage(result@, stdin_input@),\n        result@.len() > 0 ==> contains_newline_terminated_results(result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* TODO: Implement full validation logic for:\n     * - Lines parsing and validation\n     * - Test case count validation  \n     * - String and integer array parsing\n     * - Character and bounds validation\n     */\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> output.len() > 0\n    /* TODO: Implement validation for:\n     * - Output lines matching test cases\n     * - Correct string lengths\n     * - Valid lowercase characters\n     */\n}\n\nspec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement constraint validation for:\n     * - Distance sum calculations\n     * - Character ordering requirements\n     */\n}\n\nspec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement character count preservation:\n     * - Character frequency validation\n     * - Subset usage validation\n     */\n}\n\nspec fn contains_newline_terminated_results(output: Seq<char>) -> bool {\n    output.len() > 0 ==> output[output.len() - 1] == '\\n'\n}\n\nspec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {\n    0\n    /* TODO: Implement distance sum calculation:\n     * - Compare characters lexicographically\n     * - Calculate absolute differences\n     * - Sum all applicable distances\n     */\n}\n\nspec fn abs_diff(i: int, j: int) -> int {\n    if i >= j { i - j } else { j - i }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        valid_output_format(result@, stdin_input@),\n        output_satisfies_constraints(result@, stdin_input@),\n        preserves_character_usage(result@, stdin_input@),\n        result@.len() > 0 ==> contains_newline_terminated_results(result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4088.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 655, "minimize_time_ms": 122165, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 85, "minimized_LOC": 85, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn contains_newline_terminated_results(output: Seq<char>) -> bool {\n\nspec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {\n\nspec fn abs_diff(i: int, j: int) -> int {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* TODO: Implement full validation logic for:\n     * - Lines parsing and validation\n     * - Test case count validation  \n     * - String and integer array parsing\n     * - Character and bounds validation\n     */\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> output.len() > 0\n    /* TODO: Implement validation for:\n     * - Output lines matching test cases\n     * - Correct string lengths\n     * - Valid lowercase characters\n     */\n}\n\nspec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement constraint validation for:\n     * - Distance sum calculations\n     * - Character ordering requirements\n     */\n}\n\nspec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement character count preservation:\n     * - Character frequency validation\n     * - Subset usage validation\n     */\n}\n\nspec fn contains_newline_terminated_results(output: Seq<char>) -> bool {\n    output.len() > 0 ==> output[output.len() - 1] == '\\n'\n}\n\nspec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {\n    0\n    /* TODO: Implement distance sum calculation:\n     * - Compare characters lexicographically\n     * - Calculate absolute differences\n     * - Sum all applicable distances\n     */\n}\n\nspec fn abs_diff(i: int, j: int) -> int {\n    if i >= j { i - j } else { j - i }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        valid_output_format(result@, stdin_input@),\n        output_satisfies_constraints(result@, stdin_input@),\n        preserves_character_usage(result@, stdin_input@),\n        result@.len() > 0 ==> contains_newline_terminated_results(result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_409_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        0\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        1 + count_substring(s.subrange(1, s.len() as int), pattern)\n    } else {\n        count_substring(s.subrange(1, s.len() as int), pattern)\n    }\n}\n\nspec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        -1\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        0\n    } else {\n        let rest = find_index(s.subrange(1, s.len() as int), pattern);\n        if rest == -1 { -1 } else { 1 + rest }\n    }\n}\n\nspec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {\n    let ab_pattern = seq!['A', 'B'];\n    let ba_pattern = seq!['B', 'A'];\n    let ab_index = find_index(s, ab_pattern);\n    let ba_index = find_index(s, ba_pattern);\n\n    (ab_index >= 0 && ba_index >= 0) &&\n    (\n        (ab_index >= 0 && ab_index + 2 < s.len() && count_substring(s.subrange(ab_index + 2, s.len() as int), ba_pattern) > 0) ||\n        (ba_index >= 0 && ba_index + 2 < s.len() && count_substring(s.subrange(ba_index + 2, s.len() as int), ab_pattern) > 0)\n    )\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        has_non_overlapping_ab_and_ba(input@) <==> result@ == seq!['Y', 'E', 'S']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    vec!['N', 'O']\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        0\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        1 + count_substring(s.subrange(1, s.len() as int), pattern)\n    } else {\n        count_substring(s.subrange(1, s.len() as int), pattern)\n    }\n}\n\nspec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        -1\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        0\n    } else {\n        let rest = find_index(s.subrange(1, s.len() as int), pattern);\n        if rest == -1 { -1 } else { 1 + rest }\n    }\n}\n\nspec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {\n    let ab_pattern = seq!['A', 'B'];\n    let ba_pattern = seq!['B', 'A'];\n    let ab_index = find_index(s, ab_pattern);\n    let ba_index = find_index(s, ba_pattern);\n\n    (ab_index >= 0 && ba_index >= 0) &&\n    (\n        (ab_index >= 0 && ab_index + 2 < s.len() && count_substring(s.subrange(ab_index + 2, s.len() as int), ba_pattern) > 0) ||\n        (ba_index >= 0 && ba_index + 2 < s.len() && count_substring(s.subrange(ba_index + 2, s.len() as int), ab_pattern) > 0)\n    )\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        has_non_overlapping_ab_and_ba(input@) <==> result@ == seq!['Y', 'E', 'S']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    vec!['N', 'O']\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_409.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 986, "minimize_time_ms": 92513, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 70, "minimized_LOC": 70, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat \n    decreases s.len()\n{\n\nspec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int \n    decreases s.len()\n{\n\nspec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_input(input@)\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        0\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        1 + count_substring(s.subrange(1, s.len() as int), pattern)\n    } else {\n        count_substring(s.subrange(1, s.len() as int), pattern)\n    }\n}\n\nspec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        -1\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        0\n    } else {\n        let rest = find_index(s.subrange(1, s.len() as int), pattern);\n        if rest == -1 { -1 } else { 1 + rest }\n    }\n}\n\nspec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {\n    let ab_pattern = seq!['A', 'B'];\n    let ba_pattern = seq!['B', 'A'];\n    let ab_index = find_index(s, ab_pattern);\n    let ba_index = find_index(s, ba_pattern);\n\n    (ab_index >= 0 && ba_index >= 0) &&\n    (\n        (ab_index >= 0 && ab_index + 2 < s.len() && count_substring(s.subrange(ab_index + 2, s.len() as int), ba_pattern) > 0) ||\n        (ba_index >= 0 && ba_index + 2 < s.len() && count_substring(s.subrange(ba_index + 2, s.len() as int), ab_pattern) > 0)\n    )\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        has_non_overlapping_ab_and_ba(input@) <==> result@ == seq!['Y', 'E', 'S']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    vec!['N', 'O']\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4111_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < n ==> arr[i] >= 1\n}\n\nspec fn sum_even_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 0 { arr[start] } else { 0 };\n        contribution + sum_even_indices(arr, start + 1)\n    }\n}\n\nspec fn sum_odd_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 1 { arr[start] } else { 0 };\n        contribution + sum_odd_indices(arr, start + 1)\n    }\n}\n\nspec fn count_balanced_removals(arr: Seq<int>) -> int {\n    let n = arr.len();\n    if n == 0 {\n        0\n    } else {\n        count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)\n    }\n}\n\nspec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int\n    decreases arr.len() - i when 0 <= i <= arr.len()\n{\n    if i == arr.len() {\n        0\n    } else {\n        let contribution: int = \n            if i % 2 == 0 {\n                let val1 = temp1 + count2 - temp2;\n                let val2 = temp2 + count1 - temp1 - arr[i];\n                if val1 == val2 { 1 } else { 0 }\n            } else {\n                let val1 = temp1 + count2 - temp2 - arr[i];\n                let val2 = temp2 + count1 - temp1;\n                if val1 == val2 { 1 } else { 0 }\n            };\n        let new_temp1 = if i % 2 == 0 { temp1 + arr[i] } else { temp1 };\n        let new_temp2 = if i % 2 == 1 { temp2 + arr[i] } else { temp2 };\n        contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, arr: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, arr@.map(|i: int, x: i8| x as int)),\n    ensures \n        0 <= result as int <= n as int,\n        result as int == count_balanced_removals(arr@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < n ==> arr[i] >= 1\n}\n\nspec fn sum_even_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 0 { arr[start] } else { 0 };\n        contribution + sum_even_indices(arr, start + 1)\n    }\n}\n\nspec fn sum_odd_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 1 { arr[start] } else { 0 };\n        contribution + sum_odd_indices(arr, start + 1)\n    }\n}\n\nspec fn count_balanced_removals(arr: Seq<int>) -> int {\n    let n = arr.len();\n    if n == 0 {\n        0\n    } else {\n        count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)\n    }\n}\n\nspec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int\n    decreases arr.len() - i when 0 <= i <= arr.len()\n{\n    if i == arr.len() {\n        0\n    } else {\n        let contribution: int = \n            if i % 2 == 0 {\n                let val1 = temp1 + count2 - temp2;\n                let val2 = temp2 + count1 - temp1 - arr[i];\n                if val1 == val2 { 1 } else { 0 }\n            } else {\n                let val1 = temp1 + count2 - temp2 - arr[i];\n                let val2 = temp2 + count1 - temp1;\n                if val1 == val2 { 1 } else { 0 }\n            };\n        let new_temp1 = if i % 2 == 0 { temp1 + arr[i] } else { temp1 };\n        let new_temp2 = if i % 2 == 1 { temp2 + arr[i] } else { temp2 };\n        contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, arr: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, arr@.map(|i: int, x: i8| x as int)),\n    ensures \n        0 <= result as int <= n as int,\n        result as int == count_balanced_removals(arr@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4111.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 682, "minimize_time_ms": 92400, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 84, "minimized_LOC": 84, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, arr: Seq<int>) -> bool {\n\nspec fn sum_even_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n\nspec fn sum_odd_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n\nspec fn count_balanced_removals(arr: Seq<int>) -> int {\n\nspec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int\n    decreases arr.len() - i when 0 <= i <= arr.len()\n{\n\n    decreases arr.len() - start when 0 <= start <= arr.len()\n\n    decreases arr.len() - start when 0 <= start <= arr.len()\n\n    decreases arr.len() - i when 0 <= i <= arr.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < n ==> arr[i] >= 1\n}\n\nspec fn sum_even_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 0 { arr[start] } else { 0 };\n        contribution + sum_even_indices(arr, start + 1)\n    }\n}\n\nspec fn sum_odd_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 1 { arr[start] } else { 0 };\n        contribution + sum_odd_indices(arr, start + 1)\n    }\n}\n\nspec fn count_balanced_removals(arr: Seq<int>) -> int {\n    let n = arr.len();\n    if n == 0 {\n        0\n    } else {\n        count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)\n    }\n}\n\nspec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int\n    decreases arr.len() - i when 0 <= i <= arr.len()\n{\n    if i == arr.len() {\n        0\n    } else {\n        let contribution: int = \n            if i % 2 == 0 {\n                let val1 = temp1 + count2 - temp2;\n                let val2 = temp2 + count1 - temp1 - arr[i];\n                if val1 == val2 { 1 } else { 0 }\n            } else {\n                let val1 = temp1 + count2 - temp2 - arr[i];\n                let val2 = temp2 + count1 - temp1;\n                if val1 == val2 { 1 } else { 0 }\n            };\n        let new_temp1 = if i % 2 == 0 { temp1 + arr[i] } else { temp1 };\n        let new_temp2 = if i % 2 == 1 { temp2 + arr[i] } else { temp2 };\n        contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, arr: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, arr@.map(|i: int, x: i8| x as int)),\n    ensures \n        0 <= result as int <= n as int,\n        result as int == count_balanced_removals(arr@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4115_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1\n}\n\nspec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int\n    decreases limit\n{\n    if limit <= 0 || s.len() < 1 { \n        0 \n    } else {\n        let n = s.len() as int - 1;\n        let mismatch: int = if limit > 0 && limit <= s.len() && s[limit-1] != s[n - (limit-1)] { 1 } else { 0 };\n        count_mismatches_up_to(s, limit-1) + mismatch\n    }\n}\n\nspec fn count_mismatches(s: Seq<char>) -> int {\n    if s.len() >= 1 {\n        count_mismatches_up_to(s, s.len() as int)\n    } else {\n        0\n    }\n}\n\nspec fn valid_result(s: Seq<char>, result: int) -> bool {\n    if valid_input(s) {\n        result >= 0 && result <= s.len() / 2 && result == (count_mismatches(s) / 2)\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures valid_result(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1\n}\n\nspec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int\n    decreases limit\n{\n    if limit <= 0 || s.len() < 1 { \n        0 \n    } else {\n        let n = s.len() as int - 1;\n        let mismatch: int = if limit > 0 && limit <= s.len() && s[limit-1] != s[n - (limit-1)] { 1 } else { 0 };\n        count_mismatches_up_to(s, limit-1) + mismatch\n    }\n}\n\nspec fn count_mismatches(s: Seq<char>) -> int {\n    if s.len() >= 1 {\n        count_mismatches_up_to(s, s.len() as int)\n    } else {\n        0\n    }\n}\n\nspec fn valid_result(s: Seq<char>, result: int) -> bool {\n    if valid_input(s) {\n        result >= 0 && result <= s.len() / 2 && result == (count_mismatches(s) / 2)\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures valid_result(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4115.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 777, "minimize_time_ms": 122473, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int\n    decreases limit\n{\n\nspec fn count_mismatches(s: Seq<char>) -> int {\n\nspec fn valid_result(s: Seq<char>, result: int) -> bool {\n\n    decreases limit\n\n    requires valid_input(s@)\n\n    ensures valid_result(s@, result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1\n}\n\nspec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int\n    decreases limit\n{\n    if limit <= 0 || s.len() < 1 { \n        0 \n    } else {\n        let n = s.len() as int - 1;\n        let mismatch: int = if limit > 0 && limit <= s.len() && s[limit-1] != s[n - (limit-1)] { 1 } else { 0 };\n        count_mismatches_up_to(s, limit-1) + mismatch\n    }\n}\n\nspec fn count_mismatches(s: Seq<char>) -> int {\n    if s.len() >= 1 {\n        count_mismatches_up_to(s, s.len() as int)\n    } else {\n        0\n    }\n}\n\nspec fn valid_result(s: Seq<char>, result: int) -> bool {\n    if valid_input(s) {\n        result >= 0 && result <= s.len() / 2 && result == (count_mismatches(s) / 2)\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures valid_result(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4143_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n}\n\nspec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int\n    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n{\n    let temp1 = if a <= b { a } else { b };\n    let temp2 = if temp1 <= c { temp1 } else { c };\n    let temp3 = if temp2 <= d { temp2 } else { d };\n    if temp3 <= e { temp3 } else { e }\n}\n\nspec fn ceil_div(a: int, b: int) -> int\n    recommends a >= 0 && b >= 1\n{\n    (a + b - 1) / b\n}\n\nspec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool\n    recommends valid_input(n, a, b, c, d, e)\n{\n    let min_cap = min_capacity(a, b, c, d, e);\n    let groups = ceil_div(n, min_cap);\n    result == 4 + groups\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, c: i8, d: i8, e: i8) -> (result: i8)\n    requires \n        valid_input(n as int, a as int, b as int, c as int, d as int, e as int)\n    ensures \n        correct_result(n as int, a as int, b as int, c as int, d as int, e as int, result as int) &&\n        result >= 5\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n}\n\nspec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int\n    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n{\n    let temp1 = if a <= b { a } else { b };\n    let temp2 = if temp1 <= c { temp1 } else { c };\n    let temp3 = if temp2 <= d { temp2 } else { d };\n    if temp3 <= e { temp3 } else { e }\n}\n\nspec fn ceil_div(a: int, b: int) -> int\n    recommends a >= 0 && b >= 1\n{\n    (a + b - 1) / b\n}\n\nspec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool\n    recommends valid_input(n, a, b, c, d, e)\n{\n    let min_cap = min_capacity(a, b, c, d, e);\n    let groups = ceil_div(n, min_cap);\n    result == 4 + groups\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, c: i8, d: i8, e: i8) -> (result: i8)\n    requires \n        valid_input(n as int, a as int, b as int, c as int, d as int, e as int)\n    ensures \n        correct_result(n as int, a as int, b as int, c as int, d as int, e as int, result as int) &&\n        result >= 5\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4143.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 697, "minimize_time_ms": 122286, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {\n\nspec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int\n    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n{\n\nspec fn ceil_div(a: int, b: int) -> int\n    recommends a >= 0 && b >= 1\n{\n\nspec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool\n    recommends valid_input(n, a, b, c, d, e)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n}\n\nspec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int\n    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n{\n    let temp1 = if a <= b { a } else { b };\n    let temp2 = if temp1 <= c { temp1 } else { c };\n    let temp3 = if temp2 <= d { temp2 } else { d };\n    if temp3 <= e { temp3 } else { e }\n}\n\nspec fn ceil_div(a: int, b: int) -> int\n    recommends a >= 0 && b >= 1\n{\n    (a + b - 1) / b\n}\n\nspec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool\n    recommends valid_input(n, a, b, c, d, e)\n{\n    let min_cap = min_capacity(a, b, c, d, e);\n    let groups = ceil_div(n, min_cap);\n    result == 4 + groups\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, c: i8, d: i8, e: i8) -> (result: i8)\n    requires \n        valid_input(n as int, a as int, b as int, c as int, d as int, e as int)\n    ensures \n        correct_result(n as int, a as int, b as int, c as int, d as int, e as int, result as int) &&\n        result >= 5\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4159_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, k: int) -> bool {\n    a >= 0 && b >= 0 && k >= 0\n}\n\nspec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { a - k }\n    else { 0 }\n}\n\nspec fn expected_aoki_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { b }\n    else if k - a < b { b - (k - a) }\n    else { 0 }\n}\n\nspec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool\n    recommends valid_input(a, b, k)\n{\n    takahashi == expected_takahashi_cookies(a, b, k) &&\n    aoki == expected_aoki_cookies(a, b, k) &&\n    takahashi >= 0 && aoki >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, k: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, k as int)\n    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, k: int) -> bool {\n    a >= 0 && b >= 0 && k >= 0\n}\n\nspec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { a - k }\n    else { 0 }\n}\n\nspec fn expected_aoki_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { b }\n    else if k - a < b { b - (k - a) }\n    else { 0 }\n}\n\nspec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool\n    recommends valid_input(a, b, k)\n{\n    takahashi == expected_takahashi_cookies(a, b, k) &&\n    aoki == expected_aoki_cookies(a, b, k) &&\n    takahashi >= 0 && aoki >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, k: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, k as int)\n    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4159.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 691, "minimize_time_ms": 122472, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, k: int) -> bool {\n\nspec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n\nspec fn expected_aoki_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n\nspec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool\n    recommends valid_input(a, b, k)\n{\n\n    requires valid_input(a as int, b as int, k as int)\n\n    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, k: int) -> bool {\n    a >= 0 && b >= 0 && k >= 0\n}\n\nspec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { a - k }\n    else { 0 }\n}\n\nspec fn expected_aoki_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { b }\n    else if k - a < b { b - (k - a) }\n    else { 0 }\n}\n\nspec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool\n    recommends valid_input(a, b, k)\n{\n    takahashi == expected_takahashi_cookies(a, b, k) &&\n    aoki == expected_aoki_cookies(a, b, k) &&\n    takahashi >= 0 && aoki >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, k: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, k as int)\n    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4167_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool\n    recommends k >= 1\n{\n    1 <= a <= n && 1 <= b <= n && 1 <= c <= n &&\n    (a + b) % k == 0 && (b + c) % k == 0 && (c + a) % k == 0\n}\n\nspec fn count_valid_triples(n: int, k: int) -> int\n    recommends n >= 1 && k >= 1\n{\n    if k % 2 == 1 {\n        let cnt1 = n / k;\n        cnt1 * cnt1 * cnt1\n    } else {\n        let cnt1 = n / k;\n        let cnt2 = n / k + (if n % k >= k / 2 { 1int } else { 0int });\n        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1\n}\n\nspec fn count_divisible_by_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k }\n}\n\nspec fn count_with_remainder_half_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k + (if n % k >= k / 2 { 1int } else { 0int }) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= 0,\n        result as int == count_valid_triples(n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool\n    recommends k >= 1\n{\n    1 <= a <= n && 1 <= b <= n && 1 <= c <= n &&\n    (a + b) % k == 0 && (b + c) % k == 0 && (c + a) % k == 0\n}\n\nspec fn count_valid_triples(n: int, k: int) -> int\n    recommends n >= 1 && k >= 1\n{\n    if k % 2 == 1 {\n        let cnt1 = n / k;\n        cnt1 * cnt1 * cnt1\n    } else {\n        let cnt1 = n / k;\n        let cnt2 = n / k + (if n % k >= k / 2 { 1int } else { 0int });\n        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1\n}\n\nspec fn count_divisible_by_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k }\n}\n\nspec fn count_with_remainder_half_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k + (if n % k >= k / 2 { 1int } else { 0int }) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= 0,\n        result as int == count_valid_triples(n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4167.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 690, "minimize_time_ms": 92483, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool\n    recommends k >= 1\n{\n\nspec fn count_valid_triples(n: int, k: int) -> int\n    recommends n >= 1 && k >= 1\n{\n\nspec fn valid_input(n: int, k: int) -> bool {\n\nspec fn count_divisible_by_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n\nspec fn count_with_remainder_half_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool\n    recommends k >= 1\n{\n    1 <= a <= n && 1 <= b <= n && 1 <= c <= n &&\n    (a + b) % k == 0 && (b + c) % k == 0 && (c + a) % k == 0\n}\n\nspec fn count_valid_triples(n: int, k: int) -> int\n    recommends n >= 1 && k >= 1\n{\n    if k % 2 == 1 {\n        let cnt1 = n / k;\n        cnt1 * cnt1 * cnt1\n    } else {\n        let cnt1 = n / k;\n        let cnt2 = n / k + (if n % k >= k / 2 { 1int } else { 0int });\n        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1\n}\n\nspec fn count_divisible_by_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k }\n}\n\nspec fn count_with_remainder_half_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k + (if n % k >= k / 2 { 1int } else { 0int }) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= 0,\n        result as int == count_valid_triples(n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4173_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_query(query: (int, int, int)) -> bool {\n    query.0 > 0 && query.1 > 0 && query.2 > 0\n}\n\nspec fn min_cost_for_query(n: int, a: int, b: int) -> int\n    recommends n > 0 && a > 0 && b > 0\n{\n    if n % 2 == 0 {\n        if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n    } else {\n        if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(i8, i8, i8)>) -> (results: Vec<i8>)\n    requires \n        forall|i: int| 0 <= i < queries@.len() ==> #[trigger] valid_query((queries@[i].0 as int, queries@[i].1 as int, queries@[i].2 as int))\n    ensures \n        results@.len() == queries@.len() &&\n        forall|i: int| 0 <= i < queries@.len() ==> {\n            let n = queries@[i].0 as int;\n            let a = queries@[i].1 as int;\n            let b = queries@[i].2 as int;\n            #[trigger] results@[i] as int == (if n % 2 == 0 {\n                if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n            } else {\n                if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n            })\n        }\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_query(query: (int, int, int)) -> bool {\n    query.0 > 0 && query.1 > 0 && query.2 > 0\n}\n\nspec fn min_cost_for_query(n: int, a: int, b: int) -> int\n    recommends n > 0 && a > 0 && b > 0\n{\n    if n % 2 == 0 {\n        if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n    } else {\n        if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(i8, i8, i8)>) -> (results: Vec<i8>)\n    requires \n        forall|i: int| 0 <= i < queries@.len() ==> #[trigger] valid_query((queries@[i].0 as int, queries@[i].1 as int, queries@[i].2 as int))\n    ensures \n        results@.len() == queries@.len() &&\n        forall|i: int| 0 <= i < queries@.len() ==> {\n            let n = queries@[i].0 as int;\n            let a = queries@[i].1 as int;\n            let b = queries@[i].2 as int;\n            #[trigger] results@[i] as int == (if n % 2 == 0 {\n                if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n            } else {\n                if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n            })\n        }\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4173.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 659, "minimize_time_ms": 123304, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 7, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_query(query: (int, int, int)) -> bool {\n\nspec fn min_cost_for_query(n: int, a: int, b: int) -> int\n    recommends n > 0 && a > 0 && b > 0\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_query(query: (int, int, int)) -> bool {\n    query.0 > 0 && query.1 > 0 && query.2 > 0\n}\n\nspec fn min_cost_for_query(n: int, a: int, b: int) -> int\n    recommends n > 0 && a > 0 && b > 0\n{\n    if n % 2 == 0 {\n        if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n    } else {\n        if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(i8, i8, i8)>) -> (results: Vec<i8>)\n    requires \n        forall|i: int| 0 <= i < queries@.len() ==> #[trigger] valid_query((queries@[i].0 as int, queries@[i].1 as int, queries@[i].2 as int))\n    ensures \n        results@.len() == queries@.len() &&\n        forall|i: int| 0 <= i < queries@.len() ==> {\n            let n = queries@[i].0 as int;\n            let a = queries@[i].1 as int;\n            let b = queries@[i].2 as int;\n            #[trigger] results@[i] as int == (if n % 2 == 0 {\n                if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n            } else {\n                if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n            })\n        }\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n           fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4176_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|space_index: int| 0 <= space_index < input.len() && \n        input[space_index] == ' ' &&\n    forall|i: int| 0 <= i < input.len() ==> \n        (input[i] == ' ' || ('0' <= input[i] <= '9'))\n}\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n    if valid_input(s) { (1, 1) } else { (1, 1) }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 { (a * b) / spec_gcd(a, b) } else { 1 }\n}\n\nspec fn spec_gcd(a: int, b: int) -> int\n    decreases b\n{\n    if a > 0 && b > 0 {\n        if b == 0 { a } else { spec_gcd(b, a % b) }\n    } else { 1 }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    forall|i: int| 0 <= i < output.len() ==> #[trigger] output[i] >= '0' && #[trigger] output[i] <= '9'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures ({\n        let nums = parse_two_ints(input@);\n        let a = nums.0;\n        let b = nums.1;\n        a > 0 && b > 0\n    }) && valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|space_index: int| 0 <= space_index < input.len() && \n        input[space_index] == ' ' &&\n    forall|i: int| 0 <= i < input.len() ==> \n        (input[i] == ' ' || ('0' <= input[i] <= '9'))\n}\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n    if valid_input(s) { (1, 1) } else { (1, 1) }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 { (a * b) / spec_gcd(a, b) } else { 1 }\n}\n\nspec fn spec_gcd(a: int, b: int) -> int\n    decreases b\n{\n    if a > 0 && b > 0 {\n        if b == 0 { a } else { spec_gcd(b, a % b) }\n    } else { 1 }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    forall|i: int| 0 <= i < output.len() ==> #[trigger] output[i] >= '0' && #[trigger] output[i] <= '9'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures ({\n        let nums = parse_two_ints(input@);\n        let a = nums.0;\n        let b = nums.1;\n        a > 0 && b > 0\n    }) && valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4176.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 758, "minimize_time_ms": 123406, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n\nspec fn lcm(a: int, b: int) -> int {\n\nspec fn spec_gcd(a: int, b: int) -> int\n    decreases b\n{\n\nspec fn valid_output(output: Seq<char>) -> bool {\n\n    decreases b\n\n    requires valid_input(input@)\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|space_index: int| 0 <= space_index < input.len() && \n        input[space_index] == ' ' &&\n    forall|i: int| 0 <= i < input.len() ==> \n        (input[i] == ' ' || ('0' <= input[i] <= '9'))\n}\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n    if valid_input(s) { (1, 1) } else { (1, 1) }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 { (a * b) / spec_gcd(a, b) } else { 1 }\n}\n\nspec fn spec_gcd(a: int, b: int) -> int\n    decreases b\n{\n    if a > 0 && b > 0 {\n        if b == 0 { a } else { spec_gcd(b, a % b) }\n    } else { 1 }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    forall|i: int| 0 <= i < output.len() ==> #[trigger] output[i] >= '0' && #[trigger] output[i] <= '9'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures ({\n        let nums = parse_two_ints(input@);\n        let a = nums.0;\n        let b = nums.1;\n        a > 0 && b > 0\n    }) && valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4178_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_height_up_to(heights: Seq<int>, index: int) -> int\n    decreases index + 1\n{\n    if heights.len() > 0 && -1 <= index < heights.len() {\n        if index < 0 {\n            0\n        } else if index == 0 {\n            heights[0]\n        } else if heights[index] > max_height_up_to(heights, index - 1) {\n            heights[index]\n        } else {\n            max_height_up_to(heights, index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n >= 1 && heights.len() == n && (forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1)\n}\n\nspec fn can_make_non_decreasing(heights: Seq<int>) -> bool {\n    if heights.len() > 0 {\n        forall|i: int| 0 <= i < heights.len() ==> heights[i] >= max_height_up_to(heights, i) - 1\n    } else {\n        true\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: String)\n    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))\n    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_height_up_to(heights: Seq<int>, index: int) -> int\n    decreases index + 1\n{\n    if heights.len() > 0 && -1 <= index < heights.len() {\n        if index < 0 {\n            0\n        } else if index == 0 {\n            heights[0]\n        } else if heights[index] > max_height_up_to(heights, index - 1) {\n            heights[index]\n        } else {\n            max_height_up_to(heights, index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n >= 1 && heights.len() == n && (forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1)\n}\n\nspec fn can_make_non_decreasing(heights: Seq<int>) -> bool {\n    if heights.len() > 0 {\n        forall|i: int| 0 <= i < heights.len() ==> heights[i] >= max_height_up_to(heights, i) - 1\n    } else {\n        true\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: String)\n    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))\n    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4178.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 651, "minimize_time_ms": 92069, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn max_height_up_to(heights: Seq<int>, index: int) -> int\n    decreases index + 1\n{\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n\nspec fn can_make_non_decreasing(heights: Seq<int>) -> bool {\n\n    decreases index + 1\n\n    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))\n\n    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_height_up_to(heights: Seq<int>, index: int) -> int\n    decreases index + 1\n{\n    if heights.len() > 0 && -1 <= index < heights.len() {\n        if index < 0 {\n            0\n        } else if index == 0 {\n            heights[0]\n        } else if heights[index] > max_height_up_to(heights, index - 1) {\n            heights[index]\n        } else {\n            max_height_up_to(heights, index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n >= 1 && heights.len() == n && (forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1)\n}\n\nspec fn can_make_non_decreasing(heights: Seq<int>) -> bool {\n    if heights.len() > 0 {\n        forall|i: int| 0 <= i < heights.len() ==> heights[i] >= max_height_up_to(heights, i) - 1\n    } else {\n        true\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: String)\n    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))\n    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4183_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn gcd(a: int, b: int) -> int\n    decreases b when b >= 0\n{\n    if a > 0 && b >= 0 {\n        if b == 0 { a } else { gcd(b, a % b) }\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 {\n        (a * b) / gcd(a, b)\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() > 0 {\n        if nums.len() == 1 { \n            nums[0] \n        } else { \n            lcm(nums[0], lcm_seq(nums.skip(1)))\n        }\n    } else {\n        1  /* default for empty sequence */\n    }\n}\n\nspec fn valid_input(periods: Seq<int>) -> bool {\n    periods.len() > 0 && periods.len() <= 100 &&\n    forall|i: int| 0 <= i < periods.len() ==> periods[i] > 0\n}\n\nspec fn correct_result(periods: Seq<int>, result: int) -> bool {\n    valid_input(periods) ==> result == lcm_seq(periods)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_minimum_time(periods: Vec<i8>) -> (result: i8)\n    requires valid_input(periods@.map(|i: int, v: i8| v as int))\n    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn gcd(a: int, b: int) -> int\n    decreases b when b >= 0\n{\n    if a > 0 && b >= 0 {\n        if b == 0 { a } else { gcd(b, a % b) }\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 {\n        (a * b) / gcd(a, b)\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() > 0 {\n        if nums.len() == 1 { \n            nums[0] \n        } else { \n            lcm(nums[0], lcm_seq(nums.skip(1)))\n        }\n    } else {\n        1  /* default for empty sequence */\n    }\n}\n\nspec fn valid_input(periods: Seq<int>) -> bool {\n    periods.len() > 0 && periods.len() <= 100 &&\n    forall|i: int| 0 <= i < periods.len() ==> periods[i] > 0\n}\n\nspec fn correct_result(periods: Seq<int>, result: int) -> bool {\n    valid_input(periods) ==> result == lcm_seq(periods)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_minimum_time(periods: Vec<i8>) -> (result: i8)\n    requires valid_input(periods@.map(|i: int, v: i8| v as int))\n    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4183.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 646, "minimize_time_ms": 122189, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 65, "minimized_LOC": 65, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn gcd(a: int, b: int) -> int\n    decreases b when b >= 0\n{\n\nspec fn lcm(a: int, b: int) -> int {\n\nspec fn lcm_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n\nspec fn valid_input(periods: Seq<int>) -> bool {\n\nspec fn correct_result(periods: Seq<int>, result: int) -> bool {\n\n    decreases b when b >= 0\n\n    decreases nums.len()\n\n    requires valid_input(periods@.map(|i: int, v: i8| v as int))\n\n    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn gcd(a: int, b: int) -> int\n    decreases b when b >= 0\n{\n    if a > 0 && b >= 0 {\n        if b == 0 { a } else { gcd(b, a % b) }\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 {\n        (a * b) / gcd(a, b)\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() > 0 {\n        if nums.len() == 1 { \n            nums[0] \n        } else { \n            lcm(nums[0], lcm_seq(nums.skip(1)))\n        }\n    } else {\n        1  /* default for empty sequence */\n    }\n}\n\nspec fn valid_input(periods: Seq<int>) -> bool {\n    periods.len() > 0 && periods.len() <= 100 &&\n    forall|i: int| 0 <= i < periods.len() ==> periods[i] > 0\n}\n\nspec fn correct_result(periods: Seq<int>, result: int) -> bool {\n    valid_input(periods) ==> result == lcm_seq(periods)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_minimum_time(periods: Vec<i8>) -> (result: i8)\n    requires valid_input(periods@.map(|i: int, v: i8| v as int))\n    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4194_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 0 && m >= 0 && m == a.len()\n}\n\nspec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {\n    sum_seq(a) <= n\n}\n\nspec fn total_assignment_days(a: Seq<int>) -> int {\n    sum_seq(a)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else { \n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a@.map(|i, x: i8| x as int))\n    ensures \n        m as int == 0 ==> result as int == n as int,\n        m as int > 0 && can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == n as int - total_assignment_days(a@.map(|i, x: i8| x as int)),\n        m as int > 0 && !can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == -1,\n        result as int >= -1\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 0 && m >= 0 && m == a.len()\n}\n\nspec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {\n    sum_seq(a) <= n\n}\n\nspec fn total_assignment_days(a: Seq<int>) -> int {\n    sum_seq(a)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else { \n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a@.map(|i, x: i8| x as int))\n    ensures \n        m as int == 0 ==> result as int == n as int,\n        m as int > 0 && can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == n as int - total_assignment_days(a@.map(|i, x: i8| x as int)),\n        m as int > 0 && !can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == -1,\n        result as int >= -1\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4194.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 705, "minimize_time_ms": 92411, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n\nspec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {\n\nspec fn total_assignment_days(a: Seq<int>) -> int {\n\nspec fn sum_seq(s: Seq<int>) -> int \n    decreases s.len()\n{\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 0 && m >= 0 && m == a.len()\n}\n\nspec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {\n    sum_seq(a) <= n\n}\n\nspec fn total_assignment_days(a: Seq<int>) -> int {\n    sum_seq(a)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else { \n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a@.map(|i, x: i8| x as int))\n    ensures \n        m as int == 0 ==> result as int == n as int,\n        m as int > 0 && can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == n as int - total_assignment_days(a@.map(|i, x: i8| x as int)),\n        m as int > 0 && !can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == -1,\n        result as int >= -1\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4216_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn num_digits(n: int) -> int\n  recommends n >= 1\n  decreases n\n{\n  if n < 10 { 1 } else { 1 + num_digits(n / 10) }\n}\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn f(a: int, b: int) -> int\n  recommends a >= 1 && b >= 1\n{\n  let digits_a = num_digits(a);\n  let digits_b = num_digits(b);\n  if digits_a > digits_b { digits_a } else { digits_b }\n}\n\nspec fn is_factor_pair(a: int, b: int, n: int) -> bool {\n  a >= 1 && b >= 1 && a * b == n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n  requires \n    valid_input(n as int)\n  ensures \n    result >= 1,\n    exists|a: int, b: int| is_factor_pair(a, b, n as int) && result as int == f(a, b),\n    forall|a: int, b: int| is_factor_pair(a, b, n as int) ==> result as int <= f(a, b),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn num_digits(n: int) -> int\n  recommends n >= 1\n  decreases n\n{\n  if n < 10 { 1 } else { 1 + num_digits(n / 10) }\n}\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn f(a: int, b: int) -> int\n  recommends a >= 1 && b >= 1\n{\n  let digits_a = num_digits(a);\n  let digits_b = num_digits(b);\n  if digits_a > digits_b { digits_a } else { digits_b }\n}\n\nspec fn is_factor_pair(a: int, b: int, n: int) -> bool {\n  a >= 1 && b >= 1 && a * b == n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n  requires \n    valid_input(n as int)\n  ensures \n    result >= 1,\n    exists|a: int, b: int| is_factor_pair(a, b, n as int) && result as int == f(a, b),\n    forall|a: int, b: int| is_factor_pair(a, b, n as int) ==> result as int <= f(a, b),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4216.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 595, "minimize_time_ms": 92231, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn num_digits(n: int) -> int\n  recommends n >= 1\n  decreases n\n{\n\nspec fn valid_input(n: int) -> bool {\n\nspec fn f(a: int, b: int) -> int\n  recommends a >= 1 && b >= 1\n{\n\nspec fn is_factor_pair(a: int, b: int, n: int) -> bool {\n\n  decreases n\n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn num_digits(n: int) -> int\n  recommends n >= 1\n  decreases n\n{\n  if n < 10 { 1 } else { 1 + num_digits(n / 10) }\n}\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn f(a: int, b: int) -> int\n  recommends a >= 1 && b >= 1\n{\n  let digits_a = num_digits(a);\n  let digits_b = num_digits(b);\n  if digits_a > digits_b { digits_a } else { digits_b }\n}\n\nspec fn is_factor_pair(a: int, b: int, n: int) -> bool {\n  a >= 1 && b >= 1 && a * b == n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n  requires \n    valid_input(n as int)\n  ensures \n    result >= 1,\n    exists|a: int, b: int| is_factor_pair(a, b, n as int) && result as int == f(a, b),\n    forall|a: int, b: int| is_factor_pair(a, b, n as int) ==> result as int <= f(a, b),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4220_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    (exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n') &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        is_valid_positive_integer(k_str)\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        let k = string_to_int(k_str);\n        1 <= k <= 100\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n        let s = if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest };\n        1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n    })\n}\n\nspec fn extract_k(stdin_input: Seq<char>) -> int\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let k_str = stdin_input.subrange(0, newline_pos as int);\n    string_to_int(k_str)\n}\n\nspec fn extract_s(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n    if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest }\n}\n\nspec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(stdin_input)\n{\n    let k = extract_k(stdin_input);\n    let s = extract_s(stdin_input);\n    k >= 1 && k <= 100 &&\n    s.len() >= 1 && s.len() <= 100 &&\n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z') &&\n    (s.len() <= k ==> result == s.add(seq!['\\n'])) &&\n    (s.len() > k ==> result == s.subrange(0, k).add(seq!['.', '.', '.']).add(seq!['\\n']))\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> nat\n    recommends start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { \n        s.len() \n    } else if s[start as int] == '\\n' { \n        start \n    } else { \n        find_newline(s, start + 1) \n    }\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9') && \n    s != seq!['0']\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_positive_integer(s)\n{\n    string_to_int_helper(s, 0, 0)\n}\n\nspec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int\n    recommends\n        pos <= s.len(),\n        acc >= 0,\n        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',\n        is_valid_positive_integer(s)\n    decreases s.len() - pos\n{\n    if pos >= s.len() { \n        if acc == 0 { 1 } else { acc }\n    } else if s[pos as int] >= '0' && s[pos as int] <= '9' {\n        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos as int] as int - '0' as int))\n    } else {\n        if acc == 0 { 1 } else { acc }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    (exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n') &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        is_valid_positive_integer(k_str)\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        let k = string_to_int(k_str);\n        1 <= k <= 100\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n        let s = if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest };\n        1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n    })\n}\n\nspec fn extract_k(stdin_input: Seq<char>) -> int\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let k_str = stdin_input.subrange(0, newline_pos as int);\n    string_to_int(k_str)\n}\n\nspec fn extract_s(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n    if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest }\n}\n\nspec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(stdin_input)\n{\n    let k = extract_k(stdin_input);\n    let s = extract_s(stdin_input);\n    k >= 1 && k <= 100 &&\n    s.len() >= 1 && s.len() <= 100 &&\n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z') &&\n    (s.len() <= k ==> result == s.add(seq!['\\n'])) &&\n    (s.len() > k ==> result == s.subrange(0, k).add(seq!['.', '.', '.']).add(seq!['\\n']))\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> nat\n    recommends start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { \n        s.len() \n    } else if s[start as int] == '\\n' { \n        start \n    } else { \n        find_newline(s, start + 1) \n    }\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9') && \n    s != seq!['0']\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_positive_integer(s)\n{\n    string_to_int_helper(s, 0, 0)\n}\n\nspec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int\n    recommends\n        pos <= s.len(),\n        acc >= 0,\n        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',\n        is_valid_positive_integer(s)\n    decreases s.len() - pos\n{\n    if pos >= s.len() { \n        if acc == 0 { 1 } else { acc }\n    } else if s[pos as int] >= '0' && s[pos as int] <= '9' {\n        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos as int] as int - '0' as int))\n    } else {\n        if acc == 0 { 1 } else { acc }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4220.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 702, "minimize_time_ms": 153385, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 117, "minimized_LOC": 117, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn extract_k(stdin_input: Seq<char>) -> int\n    recommends valid_input(stdin_input)\n{\n\nspec fn extract_s(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n\nspec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(stdin_input)\n{\n\nspec fn find_newline(s: Seq<char>, start: nat) -> nat\n    recommends start <= s.len()\n    decreases s.len() - start\n{\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_positive_integer(s)\n{\n\nspec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int\n    recommends\n        pos <= s.len(),\n        acc >= 0,\n        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',\n        is_valid_positive_integer(s)\n    decreases s.len() - pos\n{\n\n    decreases s.len() - start\n\n    decreases s.len() - pos\n\n    requires valid_input(stdin_input@)\n\n    ensures correct_output(stdin_input@, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    (exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n') &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        is_valid_positive_integer(k_str)\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        let k = string_to_int(k_str);\n        1 <= k <= 100\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n        let s = if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest };\n        1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n    })\n}\n\nspec fn extract_k(stdin_input: Seq<char>) -> int\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let k_str = stdin_input.subrange(0, newline_pos as int);\n    string_to_int(k_str)\n}\n\nspec fn extract_s(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n    if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest }\n}\n\nspec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(stdin_input)\n{\n    let k = extract_k(stdin_input);\n    let s = extract_s(stdin_input);\n    k >= 1 && k <= 100 &&\n    s.len() >= 1 && s.len() <= 100 &&\n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z') &&\n    (s.len() <= k ==> result == s.add(seq!['\\n'])) &&\n    (s.len() > k ==> result == s.subrange(0, k).add(seq!['.', '.', '.']).add(seq!['\\n']))\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> nat\n    recommends start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { \n        s.len() \n    } else if s[start as int] == '\\n' { \n        start \n    } else { \n        find_newline(s, start + 1) \n    }\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9') && \n    s != seq!['0']\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_positive_integer(s)\n{\n    string_to_int_helper(s, 0, 0)\n}\n\nspec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int\n    recommends\n        pos <= s.len(),\n        acc >= 0,\n        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',\n        is_valid_positive_integer(s)\n    decreases s.len() - pos\n{\n    if pos >= s.len() { \n        if acc == 0 { 1 } else { acc }\n    } else if s[pos as int] >= '0' && s[pos as int] <= '9' {\n        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos as int] as int - '0' as int))\n    } else {\n        if acc == 0 { 1 } else { acc }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n          fn main() {\n}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4224_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > 0\n}\n\nspec fn count_factors_of_two(n: int) -> int\n    decreases n when n > 0\n{\n    if n > 0 && n % 2 == 0 { 1 + count_factors_of_two(n / 2) }\n    else { 0 }\n}\n\nspec fn sum_factors(a: Seq<int>, i: int) -> int\n    decreases a.len() - i when 0 <= i <= a.len()\n{\n    if 0 <= i < a.len() && (forall|j: int| 0 <= j < a.len() ==> a[j] > 0) {\n        count_factors_of_two(a[i]) + sum_factors(a, i + 1)\n    } else if i == a.len() {\n        0\n    } else {\n        0\n    }\n}\n\nspec fn max_operations(a: Seq<int>) -> int {\n    if valid_input(a) { sum_factors(a, 0) } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result >= 0,\n        result as int == max_operations(a@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > 0\n}\n\nspec fn count_factors_of_two(n: int) -> int\n    decreases n when n > 0\n{\n    if n > 0 && n % 2 == 0 { 1 + count_factors_of_two(n / 2) }\n    else { 0 }\n}\n\nspec fn sum_factors(a: Seq<int>, i: int) -> int\n    decreases a.len() - i when 0 <= i <= a.len()\n{\n    if 0 <= i < a.len() && (forall|j: int| 0 <= j < a.len() ==> a[j] > 0) {\n        count_factors_of_two(a[i]) + sum_factors(a, i + 1)\n    } else if i == a.len() {\n        0\n    } else {\n        0\n    }\n}\n\nspec fn max_operations(a: Seq<int>) -> int {\n    if valid_input(a) { sum_factors(a, 0) } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result >= 0,\n        result as int == max_operations(a@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4224.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 698, "minimize_time_ms": 92133, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: Seq<int>) -> bool {\n\nspec fn count_factors_of_two(n: int) -> int\n    decreases n when n > 0\n{\n\nspec fn sum_factors(a: Seq<int>, i: int) -> int\n    decreases a.len() - i when 0 <= i <= a.len()\n{\n\nspec fn max_operations(a: Seq<int>) -> int {\n\n    decreases n when n > 0\n\n    decreases a.len() - i when 0 <= i <= a.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > 0\n}\n\nspec fn count_factors_of_two(n: int) -> int\n    decreases n when n > 0\n{\n    if n > 0 && n % 2 == 0 { 1 + count_factors_of_two(n / 2) }\n    else { 0 }\n}\n\nspec fn sum_factors(a: Seq<int>, i: int) -> int\n    decreases a.len() - i when 0 <= i <= a.len()\n{\n    if 0 <= i < a.len() && (forall|j: int| 0 <= j < a.len() ==> a[j] > 0) {\n        count_factors_of_two(a[i]) + sum_factors(a, i + 1)\n    } else if i == a.len() {\n        0\n    } else {\n        0\n    }\n}\n\nspec fn max_operations(a: Seq<int>) -> int {\n    if valid_input(a) { sum_factors(a, 0) } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result >= 0,\n        result as int == max_operations(a@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4225_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, k: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && k >= 1 && k <= a + b + c\n}\n\nspec fn max_sum(a: int, b: int, c: int, k: int) -> int\n    recommends valid_input(a, b, c, k)\n{\n    if k <= a + b {\n        if k <= a { k } else { a }\n    } else {\n        a - (k - a - b)\n    }\n}\n\nspec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {\n    exists|parts: Seq<Seq<char>>| parts.len() >= 4 && \n        parts == split_string_pure(input) &&\n        a == string_to_int_pure(parts[0]) &&\n        b == string_to_int_pure(parts[1]) &&\n        c == string_to_int_pure(parts[2]) &&\n        k == string_to_int_pure(parts[3]) &&\n        valid_input(a, b, c, k)\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char>\n    recommends n >= -2000000000 && n <= 2000000000\n{\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'] + int_to_string_pure_helper(-n) }\n    else { int_to_string_pure_helper(n) }\n}\n\nspec fn int_to_string_pure_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 { seq![('0' as u8 + n as u8) as char] }\n    else { int_to_string_pure_helper(n / 10) + seq![('0' as u8 + (n % 10) as u8) as char] }\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { seq![] }\n    else { split_string_helper(s, 0, seq![], seq![]) }\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if current.len() > 0 { parts + seq![current] } else { parts }\n    } else if s[i] == ' ' || s[i] == '\\n' {\n        if current.len() > 0 { \n            split_string_helper(s, i+1, seq![], parts + seq![current])\n        } else { \n            split_string_helper(s, i+1, seq![], parts)\n        }\n    } else {\n        split_string_helper(s, i+1, current + seq![s[i]], parts)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s[0] == '-' { -string_to_int_helper(s, 1) }\n    else { string_to_int_helper(s, 0) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, start: int) -> int\n    recommends 0 <= start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { 0 }\n    else if '0' <= s[start] <= '9' {\n        (s[start] as u8 - '0' as u8) as int + 10 * string_to_int_helper(s, start + 1)\n    } else {\n        string_to_int_helper(s, start + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input@.len() > 0\n    ensures \n        result@.len() > 0 &&\n        result@[result@.len() as int - 1] == '\\n' &&\n        ((exists|a: int, b: int, c: int, k: int| \n            parsed_values(input@, a, b, c, k) &&\n            ({\n                let max_sum_val = max_sum(a, b, c, k);\n                max_sum_val >= -2000000000 && max_sum_val <= 2000000000 &&\n                result@ == int_to_string_pure(max_sum_val) + seq!['\\n']\n            })) ||\n        (forall|a: int, b: int, c: int, k: int| !parsed_values(input@, a, b, c, k) ==> result@ == seq!['0', '\\n']))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, k: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && k >= 1 && k <= a + b + c\n}\n\nspec fn max_sum(a: int, b: int, c: int, k: int) -> int\n    recommends valid_input(a, b, c, k)\n{\n    if k <= a + b {\n        if k <= a { k } else { a }\n    } else {\n        a - (k - a - b)\n    }\n}\n\nspec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {\n    exists|parts: Seq<Seq<char>>| parts.len() >= 4 && \n        parts == split_string_pure(input) &&\n        a == string_to_int_pure(parts[0]) &&\n        b == string_to_int_pure(parts[1]) &&\n        c == string_to_int_pure(parts[2]) &&\n        k == string_to_int_pure(parts[3]) &&\n        valid_input(a, b, c, k)\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char>\n    recommends n >= -2000000000 && n <= 2000000000\n{\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'] + int_to_string_pure_helper(-n) }\n    else { int_to_string_pure_helper(n) }\n}\n\nspec fn int_to_string_pure_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 { seq![('0' as u8 + n as u8) as char] }\n    else { int_to_string_pure_helper(n / 10) + seq![('0' as u8 + (n % 10) as u8) as char] }\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { seq![] }\n    else { split_string_helper(s, 0, seq![], seq![]) }\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if current.len() > 0 { parts + seq![current] } else { parts }\n    } else if s[i] == ' ' || s[i] == '\\n' {\n        if current.len() > 0 { \n            split_string_helper(s, i+1, seq![], parts + seq![current])\n        } else { \n            split_string_helper(s, i+1, seq![], parts)\n        }\n    } else {\n        split_string_helper(s, i+1, current + seq![s[i]], parts)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s[0] == '-' { -string_to_int_helper(s, 1) }\n    else { string_to_int_helper(s, 0) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, start: int) -> int\n    recommends 0 <= start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { 0 }\n    else if '0' <= s[start] <= '9' {\n        (s[start] as u8 - '0' as u8) as int + 10 * string_to_int_helper(s, start + 1)\n    } else {\n        string_to_int_helper(s, start + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input@.len() > 0\n    ensures \n        result@.len() > 0 &&\n        result@[result@.len() as int - 1] == '\\n' &&\n        ((exists|a: int, b: int, c: int, k: int| \n            parsed_values(input@, a, b, c, k) &&\n            ({\n                let max_sum_val = max_sum(a, b, c, k);\n                max_sum_val >= -2000000000 && max_sum_val <= 2000000000 &&\n                result@ == int_to_string_pure(max_sum_val) + seq!['\\n']\n            })) ||\n        (forall|a: int, b: int, c: int, k: int| !parsed_values(input@, a, b, c, k) ==> result@ == seq!['0', '\\n']))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4225.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 702, "minimize_time_ms": 122553, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 117, "minimized_LOC": 117, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, c: int, k: int) -> bool {\n\nspec fn max_sum(a: int, b: int, c: int, k: int) -> int\n    recommends valid_input(a, b, c, k)\n{\n\nspec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {\n\nspec fn int_to_string_pure(n: int) -> Seq<char>\n    recommends n >= -2000000000 && n <= 2000000000\n{\n\nspec fn int_to_string_pure_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n\nspec fn string_to_int_helper(s: Seq<char>, start: int) -> int\n    recommends 0 <= start <= s.len()\n    decreases s.len() - start\n{\n\n    decreases n\n\n    decreases s.len() - i\n\n    decreases s.len() - start\n\n    requires input@.len() > 0\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, k: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && k >= 1 && k <= a + b + c\n}\n\nspec fn max_sum(a: int, b: int, c: int, k: int) -> int\n    recommends valid_input(a, b, c, k)\n{\n    if k <= a + b {\n        if k <= a { k } else { a }\n    } else {\n        a - (k - a - b)\n    }\n}\n\nspec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {\n    exists|parts: Seq<Seq<char>>| parts.len() >= 4 && \n        parts == split_string_pure(input) &&\n        a == string_to_int_pure(parts[0]) &&\n        b == string_to_int_pure(parts[1]) &&\n        c == string_to_int_pure(parts[2]) &&\n        k == string_to_int_pure(parts[3]) &&\n        valid_input(a, b, c, k)\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char>\n    recommends n >= -2000000000 && n <= 2000000000\n{\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'] + int_to_string_pure_helper(-n) }\n    else { int_to_string_pure_helper(n) }\n}\n\nspec fn int_to_string_pure_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 { seq![('0' as u8 + n as u8) as char] }\n    else { int_to_string_pure_helper(n / 10) + seq![('0' as u8 + (n % 10) as u8) as char] }\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { seq![] }\n    else { split_string_helper(s, 0, seq![], seq![]) }\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if current.len() > 0 { parts + seq![current] } else { parts }\n    } else if s[i] == ' ' || s[i] == '\\n' {\n        if current.len() > 0 { \n            split_string_helper(s, i+1, seq![], parts + seq![current])\n        } else { \n            split_string_helper(s, i+1, seq![], parts)\n        }\n    } else {\n        split_string_helper(s, i+1, current + seq![s[i]], parts)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s[0] == '-' { -string_to_int_helper(s, 1) }\n    else { string_to_int_helper(s, 0) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, start: int) -> int\n    recommends 0 <= start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { 0 }\n    else if '0' <= s[start] <= '9' {\n        (s[start] as u8 - '0' as u8) as int + 10 * string_to_int_helper(s, start + 1)\n    } else {\n        string_to_int_helper(s, start + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input@.len() > 0\n    ensures \n        result@.len() > 0 &&\n        result@[result@.len() as int - 1] == '\\n' &&\n        ((exists|a: int, b: int, c: int, k: int| \n            parsed_values(input@, a, b, c, k) &&\n            ({\n                let max_sum_val = max_sum(a, b, c, k);\n                max_sum_val >= -2000000000 && max_sum_val <= 2000000000 &&\n                result@ == int_to_string_pure(max_sum_val) + seq!['\\n']\n            })) ||\n        (forall|a: int, b: int, c: int, k: int| !parsed_values(input@, a, b, c, k) ==> result@ == seq!['0', '\\n']))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4245_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 1 && b >= 0\n}\n\nspec fn sockets_after_strips(strips: int, a: int) -> int\n    recommends a > 1 && strips >= 0\n{\n    1 + strips * (a - 1)\n}\n\nspec fn ceiling_division(x: int, y: int) -> int\n    recommends y > 0\n{\n    if x % y == 0 {\n        x / y\n    } else if x >= 0 {\n        x / y + 1\n    } else {\n        x / y\n    }\n}\n\nspec fn min_strips_needed(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n    if b <= 1 {\n        0\n    } else {\n        ceiling_division(b - 1, a - 1)\n    }\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n    recommends valid_input(a, b)\n{\n    result >= 0 &&\n    sockets_after_strips(result, a) >= b &&\n    (result == 0 || sockets_after_strips(result - 1, a) < b)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures correct_result(a as int, b as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 1 && b >= 0\n}\n\nspec fn sockets_after_strips(strips: int, a: int) -> int\n    recommends a > 1 && strips >= 0\n{\n    1 + strips * (a - 1)\n}\n\nspec fn ceiling_division(x: int, y: int) -> int\n    recommends y > 0\n{\n    if x % y == 0 {\n        x / y\n    } else if x >= 0 {\n        x / y + 1\n    } else {\n        x / y\n    }\n}\n\nspec fn min_strips_needed(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n    if b <= 1 {\n        0\n    } else {\n        ceiling_division(b - 1, a - 1)\n    }\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n    recommends valid_input(a, b)\n{\n    result >= 0 &&\n    sockets_after_strips(result, a) >= b &&\n    (result == 0 || sockets_after_strips(result - 1, a) < b)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures correct_result(a as int, b as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4245.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 728, "minimize_time_ms": 152877, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int) -> bool {\n\nspec fn sockets_after_strips(strips: int, a: int) -> int\n    recommends a > 1 && strips >= 0\n{\n\nspec fn ceiling_division(x: int, y: int) -> int\n    recommends y > 0\n{\n\nspec fn min_strips_needed(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n    recommends valid_input(a, b)\n{\n\n    requires valid_input(a as int, b as int)\n\n    ensures correct_result(a as int, b as int, result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 1 && b >= 0\n}\n\nspec fn sockets_after_strips(strips: int, a: int) -> int\n    recommends a > 1 && strips >= 0\n{\n    1 + strips * (a - 1)\n}\n\nspec fn ceiling_division(x: int, y: int) -> int\n    recommends y > 0\n{\n    if x % y == 0 {\n        x / y\n    } else if x >= 0 {\n        x / y + 1\n    } else {\n        x / y\n    }\n}\n\nspec fn min_strips_needed(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n    if b <= 1 {\n        0\n    } else {\n        ceiling_division(b - 1, a - 1)\n    }\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n    recommends valid_input(a, b)\n{\n    result >= 0 &&\n    sockets_after_strips(result, a) >= b &&\n    (result == 0 || sockets_after_strips(result - 1, a) < b)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures correct_result(a as int, b as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4246_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['S', 'C', 'R'], seq!['S', 'C', 'R']]\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else { seq!['3'] }\n}\nspec fn is_valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    lines.len() >= 2 && lines[0].len() == 3 && lines[1].len() == 3\n}\n\nspec fn count_matches_from_input(input: Seq<char>) -> int\n    recommends input.len() > 0 && is_valid_input(input)\n{\n    let lines = parse_lines(input);\n    count_matches(lines[0], lines[1])\n}\n\nspec fn count_matches(s: Seq<char>, t: Seq<char>) -> int\n    recommends s.len() == 3 && t.len() == 3\n{\n    (if s[0] == t[0] { 1int } else { 0int }) +\n    (if s[1] == t[1] { 1int } else { 0int }) +\n    (if s[2] == t[2] { 1int } else { 0int })\n}\n\nspec fn compute_result(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    if lines.len() < 2 {\n        seq!['0', '\\n']\n    } else if lines[0].len() != 3 || lines[1].len() != 3 {\n        seq!['0', '\\n']\n    } else {\n        int_to_string(count_matches(lines[0], lines[1])).add(seq!['\\n'])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        input.len() > 0,\n    ensures\n        result@ == compute_result(input@),\n        result.len() >= 2 && result[result.len() - 1] == '\\n',\n        result[0] == '0' || result[0] == '1' || result[0] == '2' || result[0] == '3',\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['S', 'C', 'R'], seq!['S', 'C', 'R']]\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else { seq!['3'] }\n}\nspec fn is_valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    lines.len() >= 2 && lines[0].len() == 3 && lines[1].len() == 3\n}\n\nspec fn count_matches_from_input(input: Seq<char>) -> int\n    recommends input.len() > 0 && is_valid_input(input)\n{\n    let lines = parse_lines(input);\n    count_matches(lines[0], lines[1])\n}\n\nspec fn count_matches(s: Seq<char>, t: Seq<char>) -> int\n    recommends s.len() == 3 && t.len() == 3\n{\n    (if s[0] == t[0] { 1int } else { 0int }) +\n    (if s[1] == t[1] { 1int } else { 0int }) +\n    (if s[2] == t[2] { 1int } else { 0int })\n}\n\nspec fn compute_result(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    if lines.len() < 2 {\n        seq!['0', '\\n']\n    } else if lines[0].len() != 3 || lines[1].len() != 3 {\n        seq!['0', '\\n']\n    } else {\n        int_to_string(count_matches(lines[0], lines[1])).add(seq!['\\n'])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        input.len() > 0,\n    ensures\n        result@ == compute_result(input@),\n        result.len() >= 2 && result[result.len() - 1] == '\\n',\n        result[0] == '0' || result[0] == '1' || result[0] == '2' || result[0] == '3',\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4246.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1516, "minimize_time_ms": 154264, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 76, "minimized_LOC": 76, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn is_valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n\nspec fn count_matches_from_input(input: Seq<char>) -> int\n    recommends input.len() > 0 && is_valid_input(input)\n{\n\nspec fn count_matches(s: Seq<char>, t: Seq<char>) -> int\n    recommends s.len() == 3 && t.len() == 3\n{\n\nspec fn compute_result(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['S', 'C', 'R'], seq!['S', 'C', 'R']]\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else { seq!['3'] }\n}\nspec fn is_valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    lines.len() >= 2 && lines[0].len() == 3 && lines[1].len() == 3\n}\n\nspec fn count_matches_from_input(input: Seq<char>) -> int\n    recommends input.len() > 0 && is_valid_input(input)\n{\n    let lines = parse_lines(input);\n    count_matches(lines[0], lines[1])\n}\n\nspec fn count_matches(s: Seq<char>, t: Seq<char>) -> int\n    recommends s.len() == 3 && t.len() == 3\n{\n    (if s[0] == t[0] { 1int } else { 0int }) +\n    (if s[1] == t[1] { 1int } else { 0int }) +\n    (if s[2] == t[2] { 1int } else { 0int })\n}\n\nspec fn compute_result(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    if lines.len() < 2 {\n        seq!['0', '\\n']\n    } else if lines[0].len() != 3 || lines[1].len() != 3 {\n        seq!['0', '\\n']\n    } else {\n        int_to_string(count_matches(lines[0], lines[1])).add(seq!['\\n'])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        input.len() > 0,\n    ensures\n        result@ == compute_result(input@),\n        result.len() >= 2 && result[result.len() - 1] == '\\n',\n        result[0] == '0' || result[0] == '1' || result[0] == '2' || result[0] == '3',\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4252_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3\n}\n\nspec fn count_excessive_positions(s: Seq<char>) -> int {\n    count_excessive_positions_helper(s, 0, 0)\n}\n\nspec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let new_consecutive_x = if s[pos] == 'x' { consecutive_x + 1 } else { 0 };\n        let current_contribution: int = if new_consecutive_x > 2 { 1 } else { 0 };\n        current_contribution + count_excessive_positions_helper(s, pos + 1, new_consecutive_x)\n    }\n}\n\nspec fn consecutive_x_count(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos == 0 {\n        0\n    } else if pos > 0 && pos <= s.len() && s[pos - 1] == 'x' {\n        1 + consecutive_x_count(s, pos - 1)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures \n        result >= 0,\n        result as int <= s@.len(),\n        result as int == count_excessive_positions(s@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3\n}\n\nspec fn count_excessive_positions(s: Seq<char>) -> int {\n    count_excessive_positions_helper(s, 0, 0)\n}\n\nspec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let new_consecutive_x = if s[pos] == 'x' { consecutive_x + 1 } else { 0 };\n        let current_contribution: int = if new_consecutive_x > 2 { 1 } else { 0 };\n        current_contribution + count_excessive_positions_helper(s, pos + 1, new_consecutive_x)\n    }\n}\n\nspec fn consecutive_x_count(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos == 0 {\n        0\n    } else if pos > 0 && pos <= s.len() && s[pos - 1] == 'x' {\n        1 + consecutive_x_count(s, pos - 1)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures \n        result >= 0,\n        result as int <= s@.len(),\n        result as int == count_excessive_positions(s@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4252.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1108, "minimize_time_ms": 122883, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn count_excessive_positions(s: Seq<char>) -> int {\n\nspec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int\n    decreases s.len() - pos\n{\n\nspec fn consecutive_x_count(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n\n    decreases s.len() - pos\n\n    decreases pos\n\n    requires valid_input(s@)\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3\n}\n\nspec fn count_excessive_positions(s: Seq<char>) -> int {\n    count_excessive_positions_helper(s, 0, 0)\n}\n\nspec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let new_consecutive_x = if s[pos] == 'x' { consecutive_x + 1 } else { 0 };\n        let current_contribution: int = if new_consecutive_x > 2 { 1 } else { 0 };\n        current_contribution + count_excessive_positions_helper(s, pos + 1, new_consecutive_x)\n    }\n}\n\nspec fn consecutive_x_count(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos == 0 {\n        0\n    } else if pos > 0 && pos <= s.len() && s[pos - 1] == 'x' {\n        1 + consecutive_x_count(s, pos - 1)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures \n        result >= 0,\n        result as int <= s@.len(),\n        result as int == count_excessive_positions(s@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4253_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(r: int) -> bool {\n    1 <= r <= 100\n}\n\nspec fn dodecagon_area(r: int) -> int {\n    3 * r * r\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10) + int_to_string(n % 10)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() > 1 {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(r: int) -> bool {\n    1 <= r <= 100\n}\n\nspec fn dodecagon_area(r: int) -> int {\n    3 * r * r\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10) + int_to_string(n % 10)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() > 1 {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4253.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 731, "minimize_time_ms": 122771, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(r: int) -> bool {\n\nspec fn dodecagon_area(r: int) -> int {\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n\n    decreases n\n\n    decreases s.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(r: int) -> bool {\n    1 <= r <= 100\n}\n\nspec fn dodecagon_area(r: int) -> int {\n    3 * r * r\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10) + int_to_string(n % 10)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() > 1 {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4254_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let trimmed = trim_newlines(input);\n    let space_index = find_space(trimmed);\n    space_index >= 0 && space_index < trimmed.len() - 1 &&\n    is_valid_integer(trimmed.subrange(0, space_index)) &&\n    is_valid_integer(trimmed.subrange(space_index + 1, trimmed.len() as int))\n}\n\nspec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {\n    valid_input_format(input) &&\n    {\n        let trimmed = trim_newlines(input);\n        let space_index = find_space(trimmed);\n        let s_str = trimmed.subrange(0, space_index);\n        let w_str = trimmed.subrange(space_index + 1, trimmed.len() as int);\n        string_to_int(s_str) == s && string_to_int(w_str) == w\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    if s.len() == 0 {\n        false\n    } else if s[0] == '-' {\n        s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    } else {\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    }\n}\n\nspec fn trim_newlines(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s[s.len() - 1] == '\\n' {\n        trim_newlines(s.subrange(0, s.len() - 1))\n    } else {\n        s\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    find_space_helper(s, 0)\n}\n\nspec fn find_space_helper(s: Seq<char>, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        -1\n    } else if s[index] == ' ' {\n        index\n    } else {\n        find_space_helper(s, index + 1)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' && s.len() > 1 {\n        -string_to_int_helper(s.subrange(1, s.len() as int), 0, 0)\n    } else {\n        string_to_int_helper(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        acc\n    } else {\n        let digit = (s[index] as int) - ('0' as int);\n        string_to_int_helper(s, index + 1, acc * 10 + digit)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let trimmed = trim_newlines(input);\n    let space_index = find_space(trimmed);\n    space_index >= 0 && space_index < trimmed.len() - 1 &&\n    is_valid_integer(trimmed.subrange(0, space_index)) &&\n    is_valid_integer(trimmed.subrange(space_index + 1, trimmed.len() as int))\n}\n\nspec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {\n    valid_input_format(input) &&\n    {\n        let trimmed = trim_newlines(input);\n        let space_index = find_space(trimmed);\n        let s_str = trimmed.subrange(0, space_index);\n        let w_str = trimmed.subrange(space_index + 1, trimmed.len() as int);\n        string_to_int(s_str) == s && string_to_int(w_str) == w\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    if s.len() == 0 {\n        false\n    } else if s[0] == '-' {\n        s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    } else {\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    }\n}\n\nspec fn trim_newlines(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s[s.len() - 1] == '\\n' {\n        trim_newlines(s.subrange(0, s.len() - 1))\n    } else {\n        s\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    find_space_helper(s, 0)\n}\n\nspec fn find_space_helper(s: Seq<char>, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        -1\n    } else if s[index] == ' ' {\n        index\n    } else {\n        find_space_helper(s, index + 1)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' && s.len() > 1 {\n        -string_to_int_helper(s.subrange(1, s.len() as int), 0, 0)\n    } else {\n        string_to_int_helper(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        acc\n    } else {\n        let digit = (s[index] as int) - ('0' as int);\n        string_to_int_helper(s, index + 1, acc * 10 + digit)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4254.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 787, "minimize_time_ms": 154482, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 102, "minimized_LOC": 102, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn trim_newlines(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n\nspec fn find_space(s: Seq<char>) -> int {\n\nspec fn find_space_helper(s: Seq<char>, index: int) -> int\n    decreases s.len() - index\n{\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    decreases s.len() - index\n{\n\n    decreases s.len()\n\n    decreases s.len() - index\n\n    decreases s.len() - index\n\n    requires input.len() > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let trimmed = trim_newlines(input);\n    let space_index = find_space(trimmed);\n    space_index >= 0 && space_index < trimmed.len() - 1 &&\n    is_valid_integer(trimmed.subrange(0, space_index)) &&\n    is_valid_integer(trimmed.subrange(space_index + 1, trimmed.len() as int))\n}\n\nspec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {\n    valid_input_format(input) &&\n    {\n        let trimmed = trim_newlines(input);\n        let space_index = find_space(trimmed);\n        let s_str = trimmed.subrange(0, space_index);\n        let w_str = trimmed.subrange(space_index + 1, trimmed.len() as int);\n        string_to_int(s_str) == s && string_to_int(w_str) == w\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    if s.len() == 0 {\n        false\n    } else if s[0] == '-' {\n        s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    } else {\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    }\n}\n\nspec fn trim_newlines(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s[s.len() - 1] == '\\n' {\n        trim_newlines(s.subrange(0, s.len() - 1))\n    } else {\n        s\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    find_space_helper(s, 0)\n}\n\nspec fn find_space_helper(s: Seq<char>, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        -1\n    } else if s[index] == ' ' {\n        index\n    } else {\n        find_space_helper(s, index + 1)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' && s.len() > 1 {\n        -string_to_int_helper(s.subrange(1, s.len() as int), 0, 0)\n    } else {\n        string_to_int_helper(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        acc\n    } else {\n        let digit = (s[index] as int) - ('0' as int);\n        string_to_int_helper(s, index + 1, acc * 10 + digit)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4256_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|i: int, j: int| 0 <= i < j < input.len() && input[i] == ' ' && input[j] == ' ' &&\n    ({\n        let parts = split_string_spec(input);\n        parts.len() >= 3 && \n        is_valid_integer(parts[0]) && is_valid_integer(parts[1]) && is_valid_integer(parts[2]) &&\n        ({\n            let a = string_to_int_spec(parts[0]);\n            let b = string_to_int_spec(parts[1]);\n            let c = string_to_int_spec(parts[2]);\n            1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n        })\n    })\n}\n\nspec fn compute_drinks(a: int, b: int, c: int) -> int {\n    if b / a < c { b / a } else { c }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn string_to_int_spec(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 { \n        s[0] as int - '0' as int\n    } else if s.len() > 1 { \n        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    } else {\n        0\n    }\n}\n\nspec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { \n        seq![] \n    } else {\n        split_helper(s, 0, seq![])\n    }\n}\n\nspec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        if current.len() > 0 { seq![current] } else { seq![] }\n    } else if s[index] == ' ' || s[index] == '\\n' || s[index] == '\\t' {\n        if current.len() > 0 { \n            seq![current] + split_helper(s, index + 1, seq![])\n        } else { \n            split_helper(s, index + 1, seq![])\n        }\n    } else {\n        split_helper(s, index + 1, current.push(s[index]))\n    }\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 { \n        seq!['0'] \n    } else if n < 10 && n > 0 { \n        seq![('0' as int + n) as char]\n    } else if n > 0 { \n        int_to_string_spec(n / 10) + seq![('0' as int + (n % 10)) as char]\n    } else {\n        seq!['0']\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let parts = split_string_spec(input@);\n            let a = string_to_int_spec(parts[0]);\n            let b = string_to_int_spec(parts[1]);\n            let c = string_to_int_spec(parts[2]);\n            let drinks = compute_drinks(a, b, c);\n            result@ == int_to_string_spec(drinks) + seq!['\\n']\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool ;\n       spec fn compute_drinks(a: int, b: int, c: int) -> int ;\n       spec fn is_valid_integer(s: Seq<char>) -> bool ;\n       spec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n                  let parts = split_string_spec(input@);\n                  let a = string_to_int_spec(parts[0]);\n                  let b = string_to_int_spec(parts[1]);\n                  let c = string_to_int_spec(parts[2]);\n                  let drinks = compute_drinks(a, b, c);\n                  result@ == int_to_string_spec(drinks) + seq!['\\n']         }\n      ), {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4256.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 802, "minimize_time_ms": 215916, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 112, "minimized_LOC": 22, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 21, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.19642857142857142}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool ;\n       spec fn compute_drinks(a: int, b: int, c: int) -> int ;\n       spec fn is_valid_integer(s: Seq<char>) -> bool ;\n       spec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n\nspec fn compute_drinks(a: int, b: int, c: int) -> int ;\n       spec fn is_valid_integer(s: Seq<char>) -> bool ;\n       spec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n\nspec fn is_valid_integer(s: Seq<char>) -> bool ;\n       spec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n\nspec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n\nspec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n\nspec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n\nspec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n\n       spec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;\n\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|i: int, j: int| 0 <= i < j < input.len() && input[i] == ' ' && input[j] == ' ' &&\n    ({\n        let parts = split_string_spec(input);\n        parts.len() >= 3 && \n        is_valid_integer(parts[0]) && is_valid_integer(parts[1]) && is_valid_integer(parts[2]) &&\n        ({\n            let a = string_to_int_spec(parts[0]);\n            let b = string_to_int_spec(parts[1]);\n            let c = string_to_int_spec(parts[2]);\n            1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n        })\n    })\n}\n\nspec fn compute_drinks(a: int, b: int, c: int) -> int {\n    if b / a < c { b / a } else { c }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn string_to_int_spec(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 { \n        s[0] as int - '0' as int\n    } else if s.len() > 1 { \n        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    } else {\n        0\n    }\n}\n\nspec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { \n        seq![] \n    } else {\n        split_helper(s, 0, seq![])\n    }\n}\n\nspec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        if current.len() > 0 { seq![current] } else { seq![] }\n    } else if s[index] == ' ' || s[index] == '\\n' || s[index] == '\\t' {\n        if current.len() > 0 { \n            seq![current] + split_helper(s, index + 1, seq![])\n        } else { \n            split_helper(s, index + 1, seq![])\n        }\n    } else {\n        split_helper(s, index + 1, current.push(s[index]))\n    }\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 { \n        seq!['0'] \n    } else if n < 10 && n > 0 { \n        seq![('0' as int + n) as char]\n    } else if n > 0 { \n        int_to_string_spec(n / 10) + seq![('0' as int + (n % 10)) as char]\n    } else {\n        seq!['0']\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let parts = split_string_spec(input@);\n            let a = string_to_int_spec(parts[0]);\n            let b = string_to_int_spec(parts[1]);\n            let c = string_to_int_spec(parts[2]);\n            let drinks = compute_drinks(a, b, c);\n            result@ == int_to_string_spec(drinks) + seq!['\\n']\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool ;\n       spec fn compute_drinks(a: int, b: int, c: int) -> int ;\n       spec fn is_valid_integer(s: Seq<char>) -> bool ;\n       spec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n                  let parts = split_string_spec(input@);\n                  let a = string_to_int_spec(parts[0]);\n                  let b = string_to_int_spec(parts[1]);\n                  let c = string_to_int_spec(parts[2]);\n                  let drinks = compute_drinks(a, b, c);\n                  result@ == int_to_string_spec(drinks) + seq!['\\n']         }\n      ), {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n           fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4297_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn divisible_by_both(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    result % 2 == 0 && result % n == 0\n}\n\nspec fn is_smallest(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    forall|k: int| 1 <= k < result ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n) == 0)\n}\n\nspec fn lcm(a: int, b: int) -> int\n    recommends a >= 1 && b >= 1\n{\n    if a % b == 0 {\n        a\n    } else if b % a == 0 {\n        b\n    } else {\n        a * b\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        n >= 1,\n    ensures \n        result >= 1,\n        result as int % 2 == 0 && result as int % n as int == 0,\n        forall|k: int| 1 <= k < result as int ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n as int) == 0),\n        (n as int % 2 == 0 ==> result as int == n as int) && (n as int % 2 != 0 ==> result as int == n as int * 2),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn divisible_by_both(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    result % 2 == 0 && result % n == 0\n}\n\nspec fn is_smallest(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    forall|k: int| 1 <= k < result ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n) == 0)\n}\n\nspec fn lcm(a: int, b: int) -> int\n    recommends a >= 1 && b >= 1\n{\n    if a % b == 0 {\n        a\n    } else if b % a == 0 {\n        b\n    } else {\n        a * b\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        n >= 1,\n    ensures \n        result >= 1,\n        result as int % 2 == 0 && result as int % n as int == 0,\n        forall|k: int| 1 <= k < result as int ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n as int) == 0),\n        (n as int % 2 == 0 ==> result as int == n as int) && (n as int % 2 != 0 ==> result as int == n as int * 2),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4297.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 721, "minimize_time_ms": 154890, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn divisible_by_both(result: int, n: int) -> bool\n    recommends n >= 1\n{\n\nspec fn is_smallest(result: int, n: int) -> bool\n    recommends n >= 1\n{\n\nspec fn lcm(a: int, b: int) -> int\n    recommends a >= 1 && b >= 1\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn divisible_by_both(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    result % 2 == 0 && result % n == 0\n}\n\nspec fn is_smallest(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    forall|k: int| 1 <= k < result ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n) == 0)\n}\n\nspec fn lcm(a: int, b: int) -> int\n    recommends a >= 1 && b >= 1\n{\n    if a % b == 0 {\n        a\n    } else if b % a == 0 {\n        b\n    } else {\n        a * b\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        n >= 1,\n    ensures \n        result >= 1,\n        result as int % 2 == 0 && result as int % n as int == 0,\n        forall|k: int| 1 <= k < result as int ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n as int) == 0),\n        (n as int % 2 == 0 ==> result as int == n as int) && (n as int % 2 != 0 ==> result as int == n as int * 2),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n             fn main() {\n   }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4299_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 999\n}\n\nspec fn is_hon_digit(digit: int) -> bool {\n    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9\n}\n\nspec fn is_pon_digit(digit: int) -> bool {\n    digit == 0 || digit == 1 || digit == 6 || digit == 8\n}\n\nspec fn is_bon_digit(digit: int) -> bool {\n    digit == 3\n}\n\nspec fn correct_pronunciation(n: int) -> Seq<char> {\n    let ones_digit = n % 10;\n    if is_hon_digit(ones_digit) {\n        seq!['h', 'o', 'n', '\\n']\n    } else if is_pon_digit(ones_digit) {\n        seq!['p', 'o', 'n', '\\n']\n    } else {\n        seq!['b', 'o', 'n', '\\n']\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<char>)\n    requires valid_input(n as int)\n    ensures result@ == correct_pronunciation(n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 999\n}\n\nspec fn is_hon_digit(digit: int) -> bool {\n    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9\n}\n\nspec fn is_pon_digit(digit: int) -> bool {\n    digit == 0 || digit == 1 || digit == 6 || digit == 8\n}\n\nspec fn is_bon_digit(digit: int) -> bool {\n    digit == 3\n}\n\nspec fn correct_pronunciation(n: int) -> Seq<char> {\n    let ones_digit = n % 10;\n    if is_hon_digit(ones_digit) {\n        seq!['h', 'o', 'n', '\\n']\n    } else if is_pon_digit(ones_digit) {\n        seq!['p', 'o', 'n', '\\n']\n    } else {\n        seq!['b', 'o', 'n', '\\n']\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<char>)\n    requires valid_input(n as int)\n    ensures result@ == correct_pronunciation(n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4299.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 881, "minimize_time_ms": 122969, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn is_hon_digit(digit: int) -> bool {\n\nspec fn is_pon_digit(digit: int) -> bool {\n\nspec fn is_bon_digit(digit: int) -> bool {\n\nspec fn correct_pronunciation(n: int) -> Seq<char> {\n\n    requires valid_input(n as int)\n\n    ensures result@ == correct_pronunciation(n as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 999\n}\n\nspec fn is_hon_digit(digit: int) -> bool {\n    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9\n}\n\nspec fn is_pon_digit(digit: int) -> bool {\n    digit == 0 || digit == 1 || digit == 6 || digit == 8\n}\n\nspec fn is_bon_digit(digit: int) -> bool {\n    digit == 3\n}\n\nspec fn correct_pronunciation(n: int) -> Seq<char> {\n    let ones_digit = n % 10;\n    if is_hon_digit(ones_digit) {\n        seq!['h', 'o', 'n', '\\n']\n    } else if is_pon_digit(ones_digit) {\n        seq!['p', 'o', 'n', '\\n']\n    } else {\n        seq!['b', 'o', 'n', '\\n']\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<char>)\n    requires valid_input(n as int)\n    ensures result@ == correct_pronunciation(n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4317_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 3 &&\n    exists|space_pos: int| 0 < space_pos < input.len() - 1 && input[space_pos] == ' ' &&\n    (forall|i: int| 0 <= i < space_pos ==> input[i] != ' ') &&\n    (forall|i: int| space_pos + 1 <= i < input.len() ==> input[i] != ' ' || input[i] == '\\n') &&\n    is_valid_integer(get_a_string(input)) && is_valid_integer(get_b_string(input)) &&\n    -100 <= get_a(input) <= 100 && -100 <= get_b(input) <= 100\n}\n\nspec fn get_a(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(0, space_index))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(0, space_index))\n    }\n}\n\nspec fn get_b(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(space_index + 1, trimmed.len() as int))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(space_index + 1, input.len() as int))\n    }\n}\n\nspec fn get_a_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(0, space_index)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(0, space_index)\n    }\n}\n\nspec fn get_b_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(space_index + 1, trimmed.len() as int)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(space_index + 1, input.len() as int)\n    }\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c {\n        a\n    } else if b >= c {\n        b\n    } else {\n        c\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    0  /* placeholder for finding space position */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true  /* placeholder for integer validation */\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0  /* placeholder for parsing integer */\n}\n\nspec fn int_to_string(i: int) -> Seq<char> {\n    seq!['0']  /* placeholder for integer to string conversion */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(input@.map_values(|b: u8| b as char))\n    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 3 &&\n    exists|space_pos: int| 0 < space_pos < input.len() - 1 && input[space_pos] == ' ' &&\n    (forall|i: int| 0 <= i < space_pos ==> input[i] != ' ') &&\n    (forall|i: int| space_pos + 1 <= i < input.len() ==> input[i] != ' ' || input[i] == '\\n') &&\n    is_valid_integer(get_a_string(input)) && is_valid_integer(get_b_string(input)) &&\n    -100 <= get_a(input) <= 100 && -100 <= get_b(input) <= 100\n}\n\nspec fn get_a(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(0, space_index))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(0, space_index))\n    }\n}\n\nspec fn get_b(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(space_index + 1, trimmed.len() as int))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(space_index + 1, input.len() as int))\n    }\n}\n\nspec fn get_a_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(0, space_index)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(0, space_index)\n    }\n}\n\nspec fn get_b_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(space_index + 1, trimmed.len() as int)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(space_index + 1, input.len() as int)\n    }\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c {\n        a\n    } else if b >= c {\n        b\n    } else {\n        c\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    0  /* placeholder for finding space position */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true  /* placeholder for integer validation */\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0  /* placeholder for parsing integer */\n}\n\nspec fn int_to_string(i: int) -> Seq<char> {\n    seq!['0']  /* placeholder for integer to string conversion */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(input@.map_values(|b: u8| b as char))\n    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4317.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 833, "minimize_time_ms": 124097, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 104, "minimized_LOC": 104, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn get_a(input: Seq<char>) -> int {\n\nspec fn get_b(input: Seq<char>) -> int {\n\nspec fn get_a_string(input: Seq<char>) -> Seq<char> {\n\nspec fn get_b_string(input: Seq<char>) -> Seq<char> {\n\nspec fn max3(a: int, b: int, c: int) -> int {\n\nspec fn find_space(s: Seq<char>) -> int {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn parse_int(s: Seq<char>) -> int {\n\nspec fn int_to_string(i: int) -> Seq<char> {\n\n    requires valid_input(input@.map_values(|b: u8| b as char))\n\n    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 3 &&\n    exists|space_pos: int| 0 < space_pos < input.len() - 1 && input[space_pos] == ' ' &&\n    (forall|i: int| 0 <= i < space_pos ==> input[i] != ' ') &&\n    (forall|i: int| space_pos + 1 <= i < input.len() ==> input[i] != ' ' || input[i] == '\\n') &&\n    is_valid_integer(get_a_string(input)) && is_valid_integer(get_b_string(input)) &&\n    -100 <= get_a(input) <= 100 && -100 <= get_b(input) <= 100\n}\n\nspec fn get_a(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(0, space_index))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(0, space_index))\n    }\n}\n\nspec fn get_b(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(space_index + 1, trimmed.len() as int))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(space_index + 1, input.len() as int))\n    }\n}\n\nspec fn get_a_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(0, space_index)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(0, space_index)\n    }\n}\n\nspec fn get_b_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(space_index + 1, trimmed.len() as int)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(space_index + 1, input.len() as int)\n    }\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c {\n        a\n    } else if b >= c {\n        b\n    } else {\n        c\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    0  /* placeholder for finding space position */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true  /* placeholder for integer validation */\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0  /* placeholder for parsing integer */\n}\n\nspec fn int_to_string(i: int) -> Seq<char> {\n    seq!['0']  /* placeholder for integer to string conversion */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(input@.map_values(|b: u8| b as char))\n    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4318_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int\n    decreases up_to_index\n{\n    if 0 <= up_to_index < heights.len() {\n        if up_to_index == 0 {\n            heights[0]\n        } else if heights[up_to_index] >= max_height_up_to(heights, up_to_index - 1) {\n            heights[up_to_index]\n        } else {\n            max_height_up_to(heights, up_to_index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool {\n    if 0 <= mountain_index < heights.len() {\n        mountain_index == 0 || heights[mountain_index] >= max_height_up_to(heights, mountain_index - 1)\n    } else {\n        false\n    }\n}\n\nspec fn count_visible_mountains(heights: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n <= 0 {\n        0\n    } else if has_ocean_visibility(heights, n - 1) {\n        1 + count_visible_mountains(heights, n - 1)\n    } else {\n        count_visible_mountains(heights, n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u32, heights: Vec<i32>) -> (result: u32)\n    requires \n        n > 0,\n        heights.len() == n,\n        n <= 20,\n        forall|i: int| 0 <= i < heights.len() ==> 1 <= #[trigger] heights[i] as int <= 100,\n    ensures \n        1 <= result <= n,\n        result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int     decreases up_to_index ;\n       spec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool ;\n       spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int     decreases n ;\n       fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        \n#[trigger] heights[i] as int <= 100,\n    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {\n          assume(false);\n          0 }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4318.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 792, "minimize_time_ms": 185737, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 67, "minimized_LOC": 13, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.19402985074626866}, "labeling": {"segments": {"exec": " fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        \n#[trigger] heights[i] as int <= 100,\n    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {\n\n fn main() {", "spec": "spec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int     decreases up_to_index ;\n       spec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool ;\n       spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int     decreases n ;\n       fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        \n#[trigger] heights[i] as int <= 100,\n    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {\n\nspec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool ;\n       spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int     decreases n ;\n       fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        \n#[trigger] heights[i] as int <= 100,\n    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {\n\nspec fn count_visible_mountains(heights: Seq<int>, n: int) -> int     decreases n ;\n       fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        \n#[trigger] heights[i] as int <= 100,\n    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {\n\n       spec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int     decreases up_to_index ;\n\n       spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int     decreases n ;\n\n       fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        \n\n    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int\n    decreases up_to_index\n{\n    if 0 <= up_to_index < heights.len() {\n        if up_to_index == 0 {\n            heights[0]\n        } else if heights[up_to_index] >= max_height_up_to(heights, up_to_index - 1) {\n            heights[up_to_index]\n        } else {\n            max_height_up_to(heights, up_to_index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool {\n    if 0 <= mountain_index < heights.len() {\n        mountain_index == 0 || heights[mountain_index] >= max_height_up_to(heights, mountain_index - 1)\n    } else {\n        false\n    }\n}\n\nspec fn count_visible_mountains(heights: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n <= 0 {\n        0\n    } else if has_ocean_visibility(heights, n - 1) {\n        1 + count_visible_mountains(heights, n - 1)\n    } else {\n        count_visible_mountains(heights, n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u32, heights: Vec<i32>) -> (result: u32)\n    requires \n        n > 0,\n        heights.len() == n,\n        n <= 20,\n        forall|i: int| 0 <= i < heights.len() ==> 1 <= #[trigger] heights[i] as int <= 100,\n    ensures \n        1 <= result <= n,\n        result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int     decreases up_to_index ;\n       spec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool ;\n       spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int     decreases n ;\n       fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        \n#[trigger] heights[i] as int <= 100,\n    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {\n          assume(false);\n          0 }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n             fn main() {\n   }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4332_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn digit_value(c: char) -> int\n    recommends is_digit(c)\n{\n    c as int - '0' as int\n}\n\nspec fn sum_of_digits(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if is_digit(s[0]) {\n        digit_value(s[0]) + sum_of_digits(s.subrange(1, s.len() as int))\n    } else {\n        sum_of_digits(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if is_digit(s[0]) {\n        string_to_int(s.subrange(1, s.len() as int)) + digit_value(s[0]) * power_10((s.len() - 1) as int)\n    } else {\n        string_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn power_10(n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 { 1 } else { 10 * power_10(n - 1) }\n}\n\nspec fn clean_input(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        seq![]\n    } else if input[input.len() - 1] == '\\n' || input[input.len() - 1] == ' ' {\n        clean_input(input.subrange(0, input.len() - 1))\n    } else {\n        input\n    }\n}\n\nspec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| #![auto] 0 <= i < s.len() ==> is_digit(s[i])) && \n    (s.len() > 1 ==> s[0] != '0') && \n    string_to_int(s) > 0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    valid_positive_integer_string(clean_input(input))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn is_digit(c: char) -> bool ;\n       spec fn digit_value(c: char) -> int     recommends is_digit(c) ;\n       spec fn string_to_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn power_10(n: int) -> int     decreases n when n >= 0 ;\n       spec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n         (s.len() > 1 ==> s[0] != '0') &&      string_to_int(s) > 0 }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4332.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 860, "minimize_time_ms": 185876, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 87, "minimized_LOC": 11, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.12643678160919541}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn is_digit(c: char) -> bool ;\n       spec fn digit_value(c: char) -> int     recommends is_digit(c) ;\n       spec fn string_to_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn power_10(n: int) -> int     decreases n when n >= 0 ;\n       spec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n\nspec fn digit_value(c: char) -> int     recommends is_digit(c) ;\n       spec fn string_to_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn power_10(n: int) -> int     decreases n when n >= 0 ;\n       spec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n\nspec fn string_to_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn power_10(n: int) -> int     decreases n when n >= 0 ;\n       spec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n\nspec fn power_10(n: int) -> int     decreases n when n >= 0 ;\n       spec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n\nspec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n\n       spec fn string_to_int(s: Seq<char>) -> int     decreases s.len() ;\n\n       spec fn power_10(n: int) -> int     decreases n when n >= 0 ;"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn digit_value(c: char) -> int\n    recommends is_digit(c)\n{\n    c as int - '0' as int\n}\n\nspec fn sum_of_digits(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if is_digit(s[0]) {\n        digit_value(s[0]) + sum_of_digits(s.subrange(1, s.len() as int))\n    } else {\n        sum_of_digits(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if is_digit(s[0]) {\n        string_to_int(s.subrange(1, s.len() as int)) + digit_value(s[0]) * power_10((s.len() - 1) as int)\n    } else {\n        string_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn power_10(n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 { 1 } else { 10 * power_10(n - 1) }\n}\n\nspec fn clean_input(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        seq![]\n    } else if input[input.len() - 1] == '\\n' || input[input.len() - 1] == ' ' {\n        clean_input(input.subrange(0, input.len() - 1))\n    } else {\n        input\n    }\n}\n\nspec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| #![auto] 0 <= i < s.len() ==> is_digit(s[i])) && \n    (s.len() > 1 ==> s[0] != '0') && \n    string_to_int(s) > 0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    valid_positive_integer_string(clean_input(input))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn is_digit(c: char) -> bool ;\n       spec fn digit_value(c: char) -> int     recommends is_digit(c) ;\n       spec fn string_to_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn power_10(n: int) -> int     decreases n when n >= 0 ;\n       spec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n         (s.len() > 1 ==> s[0] != '0') &&      string_to_int(s) > 0 }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n             fn main() {\n   }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4343_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> {\n    let s_val = string_to_base26(s);\n    let t_val = string_to_base26(t);\n    let median_val = (s_val + t_val) / 2;\n    base26_to_string(median_val, k)\n}\n\nspec fn string_to_base26(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { ((s[0] as int - 'a' as int) * pow26((s.len() - 1) as nat) + string_to_base26(s.subrange(1, s.len() as int))) as nat }\n}\n\nspec fn base26_to_string(val: nat, k: int) -> Seq<char>\n    decreases k when k >= 1\n{\n    if k == 1 { seq![((val % 26) + ('a' as int)) as char] }\n    else { base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }\n}\n\nspec fn pow26(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 26 * pow26((n - 1) as nat) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)\n    requires \n        k >= 1,\n        s.len() == k,\n        t.len() == k,\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] s[i] <= 'z',\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] t[i] <= 'z',\n    ensures \n        result.len() == k,\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] result[i] <= 'z',\n        result@ == median_string(s@, t@, k as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> ;\n       spec fn string_to_base26(s: Seq<char>) -> nat     decreases s.len() ;\n       spec fn base26_to_string(val: nat, k: int) -> Seq<char>     decreases k when k >= 1 {\n          if k == 1 {\n     seq![((val % 26) + ('a' as int)) as char] }\n          else {\n     base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }\n      }\n       spec fn pow26(n: nat) -> nat     decreases n {\n          if n == 0 {\n     1 }\n      else {\n     26 * pow26((n - 1) as nat) }\n      }\n       fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)     requires          k >= 1,         s.len() == k,         t.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n#[trigger] s[i] <= 'z',\n    ensures          result.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n#[trigger] result[i] <= 'z',\n        result@ == median_string(s@, t@, k as int), {\n          assume(false);\n          Vec::new() }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4343.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 792, "minimize_time_ms": 186631, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 26, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.41935483870967744}, "labeling": {"segments": {"exec": " fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)     requires          k >= 1,         s.len() == k,         t.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n#[trigger] s[i] <= 'z',\n    ensures          result.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n#[trigger] result[i] <= 'z',\n        result@ == median_string(s@, t@, k as int), {\n\n fn main() {", "spec": "spec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> ;\n       spec fn string_to_base26(s: Seq<char>) -> nat     decreases s.len() ;\n       spec fn base26_to_string(val: nat, k: int) -> Seq<char>     decreases k when k >= 1 {\n\nspec fn string_to_base26(s: Seq<char>) -> nat     decreases s.len() ;\n       spec fn base26_to_string(val: nat, k: int) -> Seq<char>     decreases k when k >= 1 {\n\nspec fn base26_to_string(val: nat, k: int) -> Seq<char>     decreases k when k >= 1 {\n\nspec fn pow26(n: nat) -> nat     decreases n {\n\n       spec fn string_to_base26(s: Seq<char>) -> nat     decreases s.len() ;\n\n       spec fn base26_to_string(val: nat, k: int) -> Seq<char>     decreases k when k >= 1 {\n\n       spec fn pow26(n: nat) -> nat     decreases n {\n\n       fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)     requires          k >= 1,         s.len() == k,         t.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n\n    ensures          result.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> {\n    let s_val = string_to_base26(s);\n    let t_val = string_to_base26(t);\n    let median_val = (s_val + t_val) / 2;\n    base26_to_string(median_val, k)\n}\n\nspec fn string_to_base26(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { ((s[0] as int - 'a' as int) * pow26((s.len() - 1) as nat) + string_to_base26(s.subrange(1, s.len() as int))) as nat }\n}\n\nspec fn base26_to_string(val: nat, k: int) -> Seq<char>\n    decreases k when k >= 1\n{\n    if k == 1 { seq![((val % 26) + ('a' as int)) as char] }\n    else { base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }\n}\n\nspec fn pow26(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 26 * pow26((n - 1) as nat) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)\n    requires \n        k >= 1,\n        s.len() == k,\n        t.len() == k,\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] s[i] <= 'z',\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] t[i] <= 'z',\n    ensures \n        result.len() == k,\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] result[i] <= 'z',\n        result@ == median_string(s@, t@, k as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> ;\n       spec fn string_to_base26(s: Seq<char>) -> nat     decreases s.len() ;\n       spec fn base26_to_string(val: nat, k: int) -> Seq<char>     decreases k when k >= 1 {\n          if k == 1 {\n     seq![((val % 26) + ('a' as int)) as char] }\n          else {\n     base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }\n      }\n       spec fn pow26(n: nat) -> nat     decreases n {\n          if n == 0 {\n     1 }\n      else {\n     26 * pow26((n - 1) as nat) }\n      }\n       fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)     requires          k >= 1,         s.len() == k,         t.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n#[trigger] s[i] <= 'z',\n    ensures          result.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n#[trigger] result[i] <= 'z',\n        result@ == median_string(s@, t@, k as int), {\n          assume(false);\n          Vec::new() }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4363_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int, s: int) -> bool {\n    k >= 0 && s >= 0 && s <= 3 * k\n}\n\nspec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {\n    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s\n}\n\nspec fn count_valid_triples(k: int, s: int) -> int\n    recommends k >= 0\n{\n    count_valid_triples_helper(k, s, 0)\n}\n\nspec fn count_valid_triples_helper(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n    decreases if k >= z { k + 1 - z } else { 0 }\n{\n    if z > k { 0 }\n    else { count_valid_triples_for_z(k, s, z) + count_valid_triples_helper(k, s, z + 1) }\n}\n\nspec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n{\n    count_valid_triples_for_z_helper(k, s, z, 0)\n}\n\nspec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int\n    recommends k >= 0, z >= 0, y >= 0\n    decreases if k >= y { k + 1 - y } else { 0 }\n{\n    if y > k { 0 }\n    else { \n        let x = s - y - z;\n        let this_count: int = if 0 <= x <= k { 1 } else { 0 };\n        this_count + count_valid_triples_for_z_helper(k, s, z, y + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_triples(k: i8, s: i8) -> (count: i8)\n    requires\n        valid_input(k as int, s as int),\n    ensures\n        count as int == count_valid_triples(k as int, s as int),\n        count >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int, s: int) -> bool {\n    k >= 0 && s >= 0 && s <= 3 * k\n}\n\nspec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {\n    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s\n}\n\nspec fn count_valid_triples(k: int, s: int) -> int\n    recommends k >= 0\n{\n    count_valid_triples_helper(k, s, 0)\n}\n\nspec fn count_valid_triples_helper(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n    decreases if k >= z { k + 1 - z } else { 0 }\n{\n    if z > k { 0 }\n    else { count_valid_triples_for_z(k, s, z) + count_valid_triples_helper(k, s, z + 1) }\n}\n\nspec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n{\n    count_valid_triples_for_z_helper(k, s, z, 0)\n}\n\nspec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int\n    recommends k >= 0, z >= 0, y >= 0\n    decreases if k >= y { k + 1 - y } else { 0 }\n{\n    if y > k { 0 }\n    else { \n        let x = s - y - z;\n        let this_count: int = if 0 <= x <= k { 1 } else { 0 };\n        this_count + count_valid_triples_for_z_helper(k, s, z, y + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_triples(k: i8, s: i8) -> (count: i8)\n    requires\n        valid_input(k as int, s as int),\n    ensures\n        count as int == count_valid_triples(k as int, s as int),\n        count >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4363.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 808, "minimize_time_ms": 122700, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(k: int, s: int) -> bool {\n\nspec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {\n\nspec fn count_valid_triples(k: int, s: int) -> int\n    recommends k >= 0\n{\n\nspec fn count_valid_triples_helper(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n    decreases if k >= z {\n\nspec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n{\n\nspec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int\n    recommends k >= 0, z >= 0, y >= 0\n    decreases if k >= y {\n\n    decreases if k >= z { k + 1 - z } else { 0 }\n\n    decreases if k >= y { k + 1 - y } else { 0 }\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int, s: int) -> bool {\n    k >= 0 && s >= 0 && s <= 3 * k\n}\n\nspec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {\n    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s\n}\n\nspec fn count_valid_triples(k: int, s: int) -> int\n    recommends k >= 0\n{\n    count_valid_triples_helper(k, s, 0)\n}\n\nspec fn count_valid_triples_helper(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n    decreases if k >= z { k + 1 - z } else { 0 }\n{\n    if z > k { 0 }\n    else { count_valid_triples_for_z(k, s, z) + count_valid_triples_helper(k, s, z + 1) }\n}\n\nspec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n{\n    count_valid_triples_for_z_helper(k, s, z, 0)\n}\n\nspec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int\n    recommends k >= 0, z >= 0, y >= 0\n    decreases if k >= y { k + 1 - y } else { 0 }\n{\n    if y > k { 0 }\n    else { \n        let x = s - y - z;\n        let this_count: int = if 0 <= x <= k { 1 } else { 0 };\n        this_count + count_valid_triples_for_z_helper(k, s, z, y + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_triples(k: i8, s: i8) -> (count: i8)\n    requires\n        valid_input(k as int, s as int),\n    ensures\n        count as int == count_valid_triples(k as int, s as int),\n        count >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4365_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int) -> bool {\n    2 <= k <= 100\n}\n\nspec fn count_odd_numbers(k: int) -> int\n    recommends k >= 1\n{\n    (k + 1) / 2\n}\n\nspec fn count_even_numbers(k: int) -> int\n    recommends k >= 1\n{\n    k / 2\n}\n\nspec fn expected_result(k: int) -> int\n    recommends valid_input(k)\n{\n    count_odd_numbers(k) * count_even_numbers(k)\n}\n\nspec fn correct_result(k: int, result: int) -> bool\n    recommends valid_input(k)\n{\n    result == expected_result(k)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_even_odd_pairs(k: i8) -> (result: i8)\n    requires\n        valid_input(k as int),\n    ensures\n        correct_result(k as int, result as int),\n        result >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int) -> bool {\n    2 <= k <= 100\n}\n\nspec fn count_odd_numbers(k: int) -> int\n    recommends k >= 1\n{\n    (k + 1) / 2\n}\n\nspec fn count_even_numbers(k: int) -> int\n    recommends k >= 1\n{\n    k / 2\n}\n\nspec fn expected_result(k: int) -> int\n    recommends valid_input(k)\n{\n    count_odd_numbers(k) * count_even_numbers(k)\n}\n\nspec fn correct_result(k: int, result: int) -> bool\n    recommends valid_input(k)\n{\n    result == expected_result(k)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_even_odd_pairs(k: i8) -> (result: i8)\n    requires\n        valid_input(k as int),\n    ensures\n        correct_result(k as int, result as int),\n        result >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4365.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 712, "minimize_time_ms": 153733, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(k: int) -> bool {\n\nspec fn count_odd_numbers(k: int) -> int\n    recommends k >= 1\n{\n\nspec fn count_even_numbers(k: int) -> int\n    recommends k >= 1\n{\n\nspec fn expected_result(k: int) -> int\n    recommends valid_input(k)\n{\n\nspec fn correct_result(k: int, result: int) -> bool\n    recommends valid_input(k)\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int) -> bool {\n    2 <= k <= 100\n}\n\nspec fn count_odd_numbers(k: int) -> int\n    recommends k >= 1\n{\n    (k + 1) / 2\n}\n\nspec fn count_even_numbers(k: int) -> int\n    recommends k >= 1\n{\n    k / 2\n}\n\nspec fn expected_result(k: int) -> int\n    recommends valid_input(k)\n{\n    count_odd_numbers(k) * count_even_numbers(k)\n}\n\nspec fn correct_result(k: int, result: int) -> bool\n    recommends valid_input(k)\n{\n    result == expected_result(k)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_even_odd_pairs(k: i8) -> (result: i8)\n    requires\n        valid_input(k as int),\n    ensures\n        correct_result(k as int, result as int),\n        result >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4366_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else if n == 12 { seq!['1', '2'] }\n    else if n == 13 { seq!['1', '3'] }\n    else if n == 14 { seq!['1', '4'] }\n    else if n == 15 { seq!['1', '5'] }\n    else if n == 16 { seq!['1', '6'] }\n    else if n == 17 { seq!['1', '7'] }\n    else if n == 18 { seq!['1', '8'] }\n    else if n == 19 { seq!['1', '9'] }\n    else if n == 20 { seq!['2', '0'] }\n    else if n == 21 { seq!['2', '1'] }\n    else if n == 22 { seq!['2', '2'] }\n    else if n == 23 { seq!['2', '3'] }\n    else { seq!['0'] }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b))\n}\n\nspec fn contest_start_time(a: int, b: int) -> int {\n    (a + b) % 24\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) ==> \n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b)) &&\n    result == int_to_string(contest_start_time(a, b)) + seq!['\\n']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    ensures correct_output(input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else if n == 12 { seq!['1', '2'] }\n    else if n == 13 { seq!['1', '3'] }\n    else if n == 14 { seq!['1', '4'] }\n    else if n == 15 { seq!['1', '5'] }\n    else if n == 16 { seq!['1', '6'] }\n    else if n == 17 { seq!['1', '7'] }\n    else if n == 18 { seq!['1', '8'] }\n    else if n == 19 { seq!['1', '9'] }\n    else if n == 20 { seq!['2', '0'] }\n    else if n == 21 { seq!['2', '1'] }\n    else if n == 22 { seq!['2', '2'] }\n    else if n == 23 { seq!['2', '3'] }\n    else { seq!['0'] }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b))\n}\n\nspec fn contest_start_time(a: int, b: int) -> int {\n    (a + b) % 24\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) ==> \n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b)) &&\n    result == int_to_string(contest_start_time(a, b)) + seq!['\\n']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    ensures correct_output(input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4366.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 867, "minimize_time_ms": 123054, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn contest_start_time(a: int, b: int) -> int {\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n\n    ensures correct_output(input@, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else if n == 12 { seq!['1', '2'] }\n    else if n == 13 { seq!['1', '3'] }\n    else if n == 14 { seq!['1', '4'] }\n    else if n == 15 { seq!['1', '5'] }\n    else if n == 16 { seq!['1', '6'] }\n    else if n == 17 { seq!['1', '7'] }\n    else if n == 18 { seq!['1', '8'] }\n    else if n == 19 { seq!['1', '9'] }\n    else if n == 20 { seq!['2', '0'] }\n    else if n == 21 { seq!['2', '1'] }\n    else if n == 22 { seq!['2', '2'] }\n    else if n == 23 { seq!['2', '3'] }\n    else { seq!['0'] }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b))\n}\n\nspec fn contest_start_time(a: int, b: int) -> int {\n    (a + b) % 24\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) ==> \n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b)) &&\n    result == int_to_string(contest_start_time(a, b)) + seq!['\\n']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    ensures correct_output(input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4371_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '1' && #[trigger] s.index(i) <= '9'\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    100 * ((s.index(0) as int) - ('0' as int)) + \n    10 * ((s.index(1) as int) - ('0' as int)) + \n    ((s.index(2) as int) - ('0' as int))\n}\n\nspec fn abs_diff(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {\n    s.subrange(i, i + 3)\n}\n\nspec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {\n    valid_input(s) ==> (\n        result >= 0 &&\n        (exists|i: int| 0 <= i <= s.len() - 3 && result == abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i)))) &&\n        (forall|i: int| 0 <= i <= s.len() - 3 ==> result <= abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i))))\n    )\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i32)\n    requires valid_input(s@)\n    ensures is_minimum_difference(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '1' && #[trigger] s.index(i) <= '9'\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    100 * ((s.index(0) as int) - ('0' as int)) + \n    10 * ((s.index(1) as int) - ('0' as int)) + \n    ((s.index(2) as int) - ('0' as int))\n}\n\nspec fn abs_diff(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {\n    s.subrange(i, i + 3)\n}\n\nspec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {\n    valid_input(s) ==> (\n        result >= 0 &&\n        (exists|i: int| 0 <= i <= s.len() - 3 && result == abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i)))) &&\n        (forall|i: int| 0 <= i <= s.len() - 3 ==> result <= abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i))))\n    )\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i32)\n    requires valid_input(s@)\n    ensures is_minimum_difference(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4371.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 761, "minimize_time_ms": 154671, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn abs_diff(x: int) -> int {\n\nspec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {\n\nspec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {\n\n    requires valid_input(s@)\n\n    ensures is_minimum_difference(s@, result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '1' && #[trigger] s.index(i) <= '9'\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    100 * ((s.index(0) as int) - ('0' as int)) + \n    10 * ((s.index(1) as int) - ('0' as int)) + \n    ((s.index(2) as int) - ('0' as int))\n}\n\nspec fn abs_diff(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {\n    s.subrange(i, i + 3)\n}\n\nspec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {\n    valid_input(s) ==> (\n        result >= 0 &&\n        (exists|i: int| 0 <= i <= s.len() - 3 && result == abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i)))) &&\n        (forall|i: int| 0 <= i <= s.len() - 3 ==> result <= abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i))))\n    )\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i32)\n    requires valid_input(s@)\n    ensures is_minimum_difference(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4386_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n') &&\n    (forall|i: int| #![trigger input[i]] 0 <= i < input.len() ==> input[i] == '\\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n' && (forall|j: int| #![trigger input[j]] 0 <= j < i ==> '0' <= input[j] <= '9'))\n}\n\nspec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {\n    2800 <= a < 5000 &&\n    1 <= s.len() <= 10 &&\n    (forall|j: int| #![trigger s[j]] 0 <= j < s.len() ==> 'a' <= s[j] <= 'z')\n}\n\nspec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {\n    (a >= 3200 ==> result == s + seq!['\\n']) &&\n    (a < 3200 ==> result == seq!['r', 'e', 'd', '\\n'])\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {\n    (0, seq!['a'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n'\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n') &&\n    (forall|i: int| #![trigger input[i]] 0 <= i < input.len() ==> input[i] == '\\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n' && (forall|j: int| #![trigger input[j]] 0 <= j < i ==> '0' <= input[j] <= '9'))\n}\n\nspec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {\n    2800 <= a < 5000 &&\n    1 <= s.len() <= 10 &&\n    (forall|j: int| #![trigger s[j]] 0 <= j < s.len() ==> 'a' <= s[j] <= 'z')\n}\n\nspec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {\n    (a >= 3200 ==> result == s + seq!['\\n']) &&\n    (a < 3200 ==> result == seq!['r', 'e', 'd', '\\n'])\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {\n    (0, seq!['a'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n'\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4386.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 757, "minimize_time_ms": 154494, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {\n\nspec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n') &&\n    (forall|i: int| #![trigger input[i]] 0 <= i < input.len() ==> input[i] == '\\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n' && (forall|j: int| #![trigger input[j]] 0 <= j < i ==> '0' <= input[j] <= '9'))\n}\n\nspec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {\n    2800 <= a < 5000 &&\n    1 <= s.len() <= 10 &&\n    (forall|j: int| #![trigger s[j]] 0 <= j < s.len() ==> 'a' <= s[j] <= 'z')\n}\n\nspec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {\n    (a >= 3200 ==> result == s + seq!['\\n']) &&\n    (a < 3200 ==> result == seq!['r', 'e', 'd', '\\n'])\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {\n    (0, seq!['a'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n'\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n             fn main() {\n   }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4392_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {\n    a.len() > 1 && allowed_pos.len() == a.len()\n}\n\nspec fn is_sorted(a: Seq<int>) -> bool\n    decreases a.len()\n{\n    if a.len() <= 1 {\n        true\n    } else {\n        a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))\n    }\n}\n\nspec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {\n    original.len() == target.len() && target.len() == allowed.len() &&\n    original.to_multiset() == target.to_multiset()\n}\n\nspec fn sort_sequence(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_seq(s)\n    }\n}\n\nspec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_helper(s, s.len() as nat)\n    }\n}\n\nspec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>\n    decreases passes\n{\n    if passes == 0 {\n        s\n    } else {\n        bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)\n    }\n}\n\nspec fn bubble_pass(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_pass_helper(s, 0)\n    }\n}\n\nspec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>\n    decreases if pos <= s.len() { s.len() - pos } else { 0 }\n{\n    if pos >= s.len() || pos >= s.len() - 1 {\n        s\n    } else if s[pos as int] > s[(pos + 1) as int] {\n        bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)\n    } else {\n        bubble_pass_helper(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn can_sort(a: &mut Vec<i8>, allowed_pos: &[bool]) -> (result: bool)\n    requires \n        valid_input(old(a)@.map_values(|x: i8| x as int), allowed_pos@),\n    ensures \n        a@.map_values(|x: i8| x as int).to_multiset() == old(a)@.map_values(|x: i8| x as int).to_multiset(),\n        result == is_sorted(a@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {\n    a.len() > 1 && allowed_pos.len() == a.len()\n}\n\nspec fn is_sorted(a: Seq<int>) -> bool\n    decreases a.len()\n{\n    if a.len() <= 1 {\n        true\n    } else {\n        a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))\n    }\n}\n\nspec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {\n    original.len() == target.len() && target.len() == allowed.len() &&\n    original.to_multiset() == target.to_multiset()\n}\n\nspec fn sort_sequence(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_seq(s)\n    }\n}\n\nspec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_helper(s, s.len() as nat)\n    }\n}\n\nspec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>\n    decreases passes\n{\n    if passes == 0 {\n        s\n    } else {\n        bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)\n    }\n}\n\nspec fn bubble_pass(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_pass_helper(s, 0)\n    }\n}\n\nspec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>\n    decreases if pos <= s.len() { s.len() - pos } else { 0 }\n{\n    if pos >= s.len() || pos >= s.len() - 1 {\n        s\n    } else if s[pos as int] > s[(pos + 1) as int] {\n        bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)\n    } else {\n        bubble_pass_helper(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn can_sort(a: &mut Vec<i8>, allowed_pos: &[bool]) -> (result: bool)\n    requires \n        valid_input(old(a)@.map_values(|x: i8| x as int), allowed_pos@),\n    ensures \n        a@.map_values(|x: i8| x as int).to_multiset() == old(a)@.map_values(|x: i8| x as int).to_multiset(),\n        result == is_sorted(a@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4392.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 791, "minimize_time_ms": 123582, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 101, "minimized_LOC": 101, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {\n\nspec fn is_sorted(a: Seq<int>) -> bool\n    decreases a.len()\n{\n\nspec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {\n\nspec fn sort_sequence(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n\nspec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n\nspec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>\n    decreases passes\n{\n\nspec fn bubble_pass(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n\nspec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>\n    decreases if pos <= s.len() {\n\n    decreases a.len()\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases passes\n\n    decreases s.len()\n\n    decreases if pos <= s.len() { s.len() - pos } else { 0 }\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {\n    a.len() > 1 && allowed_pos.len() == a.len()\n}\n\nspec fn is_sorted(a: Seq<int>) -> bool\n    decreases a.len()\n{\n    if a.len() <= 1 {\n        true\n    } else {\n        a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))\n    }\n}\n\nspec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {\n    original.len() == target.len() && target.len() == allowed.len() &&\n    original.to_multiset() == target.to_multiset()\n}\n\nspec fn sort_sequence(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_seq(s)\n    }\n}\n\nspec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_helper(s, s.len() as nat)\n    }\n}\n\nspec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>\n    decreases passes\n{\n    if passes == 0 {\n        s\n    } else {\n        bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)\n    }\n}\n\nspec fn bubble_pass(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_pass_helper(s, 0)\n    }\n}\n\nspec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>\n    decreases if pos <= s.len() { s.len() - pos } else { 0 }\n{\n    if pos >= s.len() || pos >= s.len() - 1 {\n        s\n    } else if s[pos as int] > s[(pos + 1) as int] {\n        bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)\n    } else {\n        bubble_pass_helper(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn can_sort(a: &mut Vec<i8>, allowed_pos: &[bool]) -> (result: bool)\n    requires \n        valid_input(old(a)@.map_values(|x: i8| x as int), allowed_pos@),\n    ensures \n        a@.map_values(|x: i8| x as int).to_multiset() == old(a)@.map_values(|x: i8| x as int).to_multiset(),\n        result == is_sorted(a@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4404_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {\n    s.len() >= 10 && \n    s[4] == '/' && s[7] == '/' &&\n    string_to_int(s.subrange(0, 4)) == y &&\n    string_to_int(s.subrange(5, 7)) == m &&\n    string_to_int(s.subrange(8, 10)) == d\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 { char_to_digit(s[0]) }\n    else if s.len() == 2 { char_to_digit(s[0]) * 10 + char_to_digit(s[1]) }\n    else if s.len() == 4 { char_to_digit(s[0]) * 1000 + char_to_digit(s[1]) * 100 + char_to_digit(s[2]) * 10 + char_to_digit(s[3]) }\n    else { 0 }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    if '0' <= c && c <= '9' { (c as int) - ('0' as int) } else { 0 }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31\n}\n\nspec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && \n    ((m < 4 || (m == 4 && d <= 30)) ==> result == seq!['H', 'e', 'i', 's', 'e', 'i']) && \n    ((m > 4 || (m == 4 && d > 30)) ==> result == seq!['T', 'B', 'D'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {\n    s.len() >= 10 && \n    s[4] == '/' && s[7] == '/' &&\n    string_to_int(s.subrange(0, 4)) == y &&\n    string_to_int(s.subrange(5, 7)) == m &&\n    string_to_int(s.subrange(8, 10)) == d\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 { char_to_digit(s[0]) }\n    else if s.len() == 2 { char_to_digit(s[0]) * 10 + char_to_digit(s[1]) }\n    else if s.len() == 4 { char_to_digit(s[0]) * 1000 + char_to_digit(s[1]) * 100 + char_to_digit(s[2]) * 10 + char_to_digit(s[3]) }\n    else { 0 }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    if '0' <= c && c <= '9' { (c as int) - ('0' as int) } else { 0 }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31\n}\n\nspec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && \n    ((m < 4 || (m == 4 && d <= 30)) ==> result == seq!['H', 'e', 'i', 's', 'e', 'i']) && \n    ((m > 4 || (m == 4 && d > 30)) ==> result == seq!['T', 'B', 'D'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4404.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 812, "minimize_time_ms": 123115, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn char_to_digit(c: char) -> int {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {\n\n    requires valid_input(stdin_input@)\n\n    ensures correct_output(stdin_input@, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {\n    s.len() >= 10 && \n    s[4] == '/' && s[7] == '/' &&\n    string_to_int(s.subrange(0, 4)) == y &&\n    string_to_int(s.subrange(5, 7)) == m &&\n    string_to_int(s.subrange(8, 10)) == d\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 { char_to_digit(s[0]) }\n    else if s.len() == 2 { char_to_digit(s[0]) * 10 + char_to_digit(s[1]) }\n    else if s.len() == 4 { char_to_digit(s[0]) * 1000 + char_to_digit(s[1]) * 100 + char_to_digit(s[2]) * 10 + char_to_digit(s[3]) }\n    else { 0 }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    if '0' <= c && c <= '9' { (c as int) - ('0' as int) } else { 0 }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31\n}\n\nspec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && \n    ((m < 4 || (m == 4 && d <= 30)) ==> result == seq!['H', 'e', 'i', 's', 'e', 'i']) && \n    ((m > 4 || (m == 4 && d > 30)) ==> result == seq!['T', 'B', 'D'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_442_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn h(x: int, y: int) -> int {\n    x * x + 2 * x * y + x + 1\n}\n\nspec fn valid_input(r: int) -> bool {\n    r > 0\n}\n\nspec fn valid_solution(result: Seq<int>, r: int) -> bool {\n    if result.len() == 0 {\n        true\n    } else {\n        result.len() == 2 && result[0] > 0 && result[1] > 0 && h(result[0], result[1]) == r\n    }\n}\n\nspec fn has_solution(r: int) -> bool {\n    r > 4 && r % 2 == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(r: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(r as int)\n    ensures \n        valid_solution(result@.map(|i: int, x: i8| x as int), r as int),\n        result@.len() == 0 || result@.len() == 2,\n        result@.len() == 2 ==> result@[0] as int > 0 && result@[1] as int > 0,\n        result@.len() == 2 ==> h(result@[0] as int, result@[1] as int) == r as int,\n        r as int <= 4 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 0 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 1 ==> result@.len() == 2 && result@[0] as int == 1 && result@[1] as int == ((r as int) - 3) / 2,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn h(x: int, y: int) -> int {\n    x * x + 2 * x * y + x + 1\n}\n\nspec fn valid_input(r: int) -> bool {\n    r > 0\n}\n\nspec fn valid_solution(result: Seq<int>, r: int) -> bool {\n    if result.len() == 0 {\n        true\n    } else {\n        result.len() == 2 && result[0] > 0 && result[1] > 0 && h(result[0], result[1]) == r\n    }\n}\n\nspec fn has_solution(r: int) -> bool {\n    r > 4 && r % 2 == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(r: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(r as int)\n    ensures \n        valid_solution(result@.map(|i: int, x: i8| x as int), r as int),\n        result@.len() == 0 || result@.len() == 2,\n        result@.len() == 2 ==> result@[0] as int > 0 && result@[1] as int > 0,\n        result@.len() == 2 ==> h(result@[0] as int, result@[1] as int) == r as int,\n        r as int <= 4 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 0 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 1 ==> result@.len() == 2 && result@[0] as int == 1 && result@[1] as int == ((r as int) - 3) / 2,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_442.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 769, "minimize_time_ms": 122987, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn h(x: int, y: int) -> int {\n\nspec fn valid_input(r: int) -> bool {\n\nspec fn valid_solution(result: Seq<int>, r: int) -> bool {\n\nspec fn has_solution(r: int) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn h(x: int, y: int) -> int {\n    x * x + 2 * x * y + x + 1\n}\n\nspec fn valid_input(r: int) -> bool {\n    r > 0\n}\n\nspec fn valid_solution(result: Seq<int>, r: int) -> bool {\n    if result.len() == 0 {\n        true\n    } else {\n        result.len() == 2 && result[0] > 0 && result[1] > 0 && h(result[0], result[1]) == r\n    }\n}\n\nspec fn has_solution(r: int) -> bool {\n    r > 4 && r % 2 == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(r: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(r as int)\n    ensures \n        valid_solution(result@.map(|i: int, x: i8| x as int), r as int),\n        result@.len() == 0 || result@.len() == 2,\n        result@.len() == 2 ==> result@[0] as int > 0 && result@[1] as int > 0,\n        result@.len() == 2 ==> h(result@[0] as int, result@[1] as int) == r as int,\n        r as int <= 4 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 0 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 1 ==> result@.len() == 2 && result@[0] as int == 1 && result@[1] as int == ((r as int) - 3) / 2,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4427_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let tokens = parse_input_pure(input);\n    tokens.len() == 3 && \n    2 <= tokens[0] <= 5 &&\n    1 <= tokens[1] <= 100 &&\n    tokens[1] < tokens[2] && tokens[2] <= 200\n}\n\nspec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int\n    recommends n >= 1\n    decreases n when n >= 1\n{\n    if n == 1 { r * x0 - d }\n    else if n >= 2 { r * calculate_recurrence(r, d, x0, n - 1) - d }\n    else { 0 }\n}\n\nspec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {\n    generate_output_up_to_iteration(r, d, x0, 10)\n}\n\nspec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>\n    recommends iterations >= 0\n    decreases iterations when iterations >= 0\n{\n    if iterations == 0 { \n        Seq::empty() \n    } else if iterations >= 1 { \n        let current_value = calculate_recurrence(r, d, x0, iterations);\n        let previous_output = generate_output_up_to_iteration(r, d, x0, iterations - 1);\n        previous_output + int_to_string(current_value) + seq!['\\n']\n    } else {\n        Seq::empty()\n    }\n}\n\nspec fn parse_input_pure(input: Seq<char>) -> Seq<int> {\n    seq![1, 1, 100]  /* placeholder */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']  /* placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@ == generate_expected_output(\n            parse_input_pure(input@)[0], \n            parse_input_pure(input@)[1], \n            parse_input_pure(input@)[2]\n        )\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let tokens = parse_input_pure(input);\n    tokens.len() == 3 && \n    2 <= tokens[0] <= 5 &&\n    1 <= tokens[1] <= 100 &&\n    tokens[1] < tokens[2] && tokens[2] <= 200\n}\n\nspec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int\n    recommends n >= 1\n    decreases n when n >= 1\n{\n    if n == 1 { r * x0 - d }\n    else if n >= 2 { r * calculate_recurrence(r, d, x0, n - 1) - d }\n    else { 0 }\n}\n\nspec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {\n    generate_output_up_to_iteration(r, d, x0, 10)\n}\n\nspec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>\n    recommends iterations >= 0\n    decreases iterations when iterations >= 0\n{\n    if iterations == 0 { \n        Seq::empty() \n    } else if iterations >= 1 { \n        let current_value = calculate_recurrence(r, d, x0, iterations);\n        let previous_output = generate_output_up_to_iteration(r, d, x0, iterations - 1);\n        previous_output + int_to_string(current_value) + seq!['\\n']\n    } else {\n        Seq::empty()\n    }\n}\n\nspec fn parse_input_pure(input: Seq<char>) -> Seq<int> {\n    seq![1, 1, 100]  /* placeholder */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']  /* placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@ == generate_expected_output(\n            parse_input_pure(input@)[0], \n            parse_input_pure(input@)[1], \n            parse_input_pure(input@)[2]\n        )\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4427.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 773, "minimize_time_ms": 123482, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 78, "minimized_LOC": 78, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n\nspec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int\n    recommends n >= 1\n    decreases n when n >= 1\n{\n\nspec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {\n\nspec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>\n    recommends iterations >= 0\n    decreases iterations when iterations >= 0\n{\n\nspec fn parse_input_pure(input: Seq<char>) -> Seq<int> {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\n    decreases n when n >= 1\n\n    decreases iterations when iterations >= 0\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let tokens = parse_input_pure(input);\n    tokens.len() == 3 && \n    2 <= tokens[0] <= 5 &&\n    1 <= tokens[1] <= 100 &&\n    tokens[1] < tokens[2] && tokens[2] <= 200\n}\n\nspec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int\n    recommends n >= 1\n    decreases n when n >= 1\n{\n    if n == 1 { r * x0 - d }\n    else if n >= 2 { r * calculate_recurrence(r, d, x0, n - 1) - d }\n    else { 0 }\n}\n\nspec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {\n    generate_output_up_to_iteration(r, d, x0, 10)\n}\n\nspec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>\n    recommends iterations >= 0\n    decreases iterations when iterations >= 0\n{\n    if iterations == 0 { \n        Seq::empty() \n    } else if iterations >= 1 { \n        let current_value = calculate_recurrence(r, d, x0, iterations);\n        let previous_output = generate_output_up_to_iteration(r, d, x0, iterations - 1);\n        previous_output + int_to_string(current_value) + seq!['\\n']\n    } else {\n        Seq::empty()\n    }\n}\n\nspec fn parse_input_pure(input: Seq<char>) -> Seq<int> {\n    seq![1, 1, 100]  /* placeholder */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']  /* placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@ == generate_expected_output(\n            parse_input_pure(input@)[0], \n            parse_input_pure(input@)[1], \n            parse_input_pure(input@)[2]\n        )\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_443_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, packets: Seq<int>) -> bool {\n    n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1\n}\n\nspec fn is_possible(n: int, packets: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    n >= 2 && (n > 2 || packets[0] != packets[1])\n}\n\nspec fn sum_packets(packets: Seq<int>) -> int\n    decreases packets.len()\n{\n    if packets.len() == 0 {\n        0\n    } else {\n        packets[0] + sum_packets(packets.subrange(1, packets.len() as int))\n    }\n}\n\nspec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    if !is_possible(n, packets) {\n        result.len() == 0\n    } else {\n        result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&\n        exists|min_index: int| 0 <= min_index < packets.len() && \n        result[1] == min_index + 1 &&\n        (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&\n        (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, packets: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))\n    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, packets: Seq<int>) -> bool {\n    n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1\n}\n\nspec fn is_possible(n: int, packets: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    n >= 2 && (n > 2 || packets[0] != packets[1])\n}\n\nspec fn sum_packets(packets: Seq<int>) -> int\n    decreases packets.len()\n{\n    if packets.len() == 0 {\n        0\n    } else {\n        packets[0] + sum_packets(packets.subrange(1, packets.len() as int))\n    }\n}\n\nspec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    if !is_possible(n, packets) {\n        result.len() == 0\n    } else {\n        result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&\n        exists|min_index: int| 0 <= min_index < packets.len() && \n        result[1] == min_index + 1 &&\n        (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&\n        (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, packets: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))\n    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_443.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 773, "minimize_time_ms": 154078, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, packets: Seq<int>) -> bool {\n\nspec fn is_possible(n: int, packets: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n\nspec fn sum_packets(packets: Seq<int>) -> int\n    decreases packets.len()\n{\n\nspec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n\n    decreases packets.len()\n\n    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))\n\n    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, packets: Seq<int>) -> bool {\n    n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1\n}\n\nspec fn is_possible(n: int, packets: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    n >= 2 && (n > 2 || packets[0] != packets[1])\n}\n\nspec fn sum_packets(packets: Seq<int>) -> int\n    decreases packets.len()\n{\n    if packets.len() == 0 {\n        0\n    } else {\n        packets[0] + sum_packets(packets.subrange(1, packets.len() as int))\n    }\n}\n\nspec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    if !is_possible(n, packets) {\n        result.len() == 0\n    } else {\n        result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&\n        exists|min_index: int| 0 <= min_index < packets.len() && \n        result[1] == min_index + 1 &&\n        (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&\n        (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, packets: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))\n    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4430_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int\n    recommends\n        boxes >= 1,\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n{\n    greedy_pack_from_end_helper(a, a.len() - 1, boxes, capacity, capacity)\n}\n\nspec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int\n    recommends\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n        boxes_left >= 1,\n        0 <= current_box_space <= capacity,\n    decreases pos + 1,\n{\n    if pos < 0 {\n        0int\n    } else if pos >= a.len() {\n        0int\n    } else if a[pos] > capacity {\n        0int\n    } else if a[pos] <= current_box_space {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])\n    } else if boxes_left > 1 {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])\n    } else {\n        0int\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires\n        n >= 0,\n        m >= 1,\n        k >= 1,\n        a.len() == n as usize,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] as int >= 1 && #[trigger] a[i] as int <= k as int,\n    ensures\n        0 <= result as int <= n as int,\n        result as int == greedy_pack_from_end(a@.map(|i, x| x as int), m as int, k as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int\n    recommends\n        boxes >= 1,\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n{\n    greedy_pack_from_end_helper(a, a.len() - 1, boxes, capacity, capacity)\n}\n\nspec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int\n    recommends\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n        boxes_left >= 1,\n        0 <= current_box_space <= capacity,\n    decreases pos + 1,\n{\n    if pos < 0 {\n        0int\n    } else if pos >= a.len() {\n        0int\n    } else if a[pos] > capacity {\n        0int\n    } else if a[pos] <= current_box_space {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])\n    } else if boxes_left > 1 {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])\n    } else {\n        0int\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires\n        n >= 0,\n        m >= 1,\n        k >= 1,\n        a.len() == n as usize,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] as int >= 1 && #[trigger] a[i] as int <= k as int,\n    ensures\n        0 <= result as int <= n as int,\n        result as int == greedy_pack_from_end(a@.map(|i, x| x as int), m as int, k as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4430.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 786, "minimize_time_ms": 123473, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int\n    recommends\n        boxes >= 1,\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n{\n\nspec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int\n    recommends\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n        boxes_left >= 1,\n        0 <= current_box_space <= capacity,\n    decreases pos + 1,\n{\n\n    decreases pos + 1,\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int\n    recommends\n        boxes >= 1,\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n{\n    greedy_pack_from_end_helper(a, a.len() - 1, boxes, capacity, capacity)\n}\n\nspec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int\n    recommends\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n        boxes_left >= 1,\n        0 <= current_box_space <= capacity,\n    decreases pos + 1,\n{\n    if pos < 0 {\n        0int\n    } else if pos >= a.len() {\n        0int\n    } else if a[pos] > capacity {\n        0int\n    } else if a[pos] <= current_box_space {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])\n    } else if boxes_left > 1 {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])\n    } else {\n        0int\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires\n        n >= 0,\n        m >= 1,\n        k >= 1,\n        a.len() == n as usize,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] as int >= 1 && #[trigger] a[i] as int <= k as int,\n    ensures\n        0 <= result as int <= n as int,\n        result as int == greedy_pack_from_end(a@.map(|i, x| x as int), m as int, k as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4431_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {\n    n == s.len() &&\n    k == available.len() &&\n    forall|i: int, j: int| 0 <= i < j < available.len() ==> available[i] != available[j]\n}\n\nspec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else {\n        let segments = get_maximal_valid_segments(s, available_set, 0);\n        sum_segment_counts(segments)\n    }\n}\n\nspec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() { Seq::empty() }\n    else {\n        let segment_length = get_next_segment_length(s, available_set, start_idx);\n        if segment_length == 0 {\n            get_maximal_valid_segments(s, available_set, start_idx + 1)\n        } else {\n            let skip_length = skip_invalid_chars(s, available_set, start_idx + segment_length);\n            let next_idx = start_idx + segment_length + skip_length;\n            if next_idx <= s.len() {\n                seq![segment_length].add(get_maximal_valid_segments(s, available_set, next_idx))\n            } else {\n                seq![segment_length]\n            }\n        }\n    }\n}\n\nspec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || !available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + get_next_segment_length(s, available_set, start_idx + 1) }\n}\n\nspec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + skip_invalid_chars(s, available_set, start_idx + 1) }\n}\n\nspec fn sum_segment_counts(segments: Seq<nat>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { 0 }\n    else { segments[0] * (segments[0] + 1) / 2 + sum_segment_counts(segments.subrange(1, segments.len() as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, k: u8, s: Vec<char>, available: Vec<char>) -> (result: u8)\n    requires valid_input(n as nat, k as nat, s@, available@)\n    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {\n    n == s.len() &&\n    k == available.len() &&\n    forall|i: int, j: int| 0 <= i < j < available.len() ==> available[i] != available[j]\n}\n\nspec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else {\n        let segments = get_maximal_valid_segments(s, available_set, 0);\n        sum_segment_counts(segments)\n    }\n}\n\nspec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() { Seq::empty() }\n    else {\n        let segment_length = get_next_segment_length(s, available_set, start_idx);\n        if segment_length == 0 {\n            get_maximal_valid_segments(s, available_set, start_idx + 1)\n        } else {\n            let skip_length = skip_invalid_chars(s, available_set, start_idx + segment_length);\n            let next_idx = start_idx + segment_length + skip_length;\n            if next_idx <= s.len() {\n                seq![segment_length].add(get_maximal_valid_segments(s, available_set, next_idx))\n            } else {\n                seq![segment_length]\n            }\n        }\n    }\n}\n\nspec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || !available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + get_next_segment_length(s, available_set, start_idx + 1) }\n}\n\nspec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + skip_invalid_chars(s, available_set, start_idx + 1) }\n}\n\nspec fn sum_segment_counts(segments: Seq<nat>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { 0 }\n    else { segments[0] * (segments[0] + 1) / 2 + sum_segment_counts(segments.subrange(1, segments.len() as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, k: u8, s: Vec<char>, available: Vec<char>) -> (result: u8)\n    requires valid_input(n as nat, k as nat, s@, available@)\n    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4431.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 788, "minimize_time_ms": 123920, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 82, "minimized_LOC": 82, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {\n\nspec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat\n    decreases s.len()\n{\n\nspec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n\nspec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n\nspec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n\nspec fn sum_segment_counts(segments: Seq<nat>) -> nat\n    decreases segments.len()\n{\n\n    decreases s.len()\n\n    decreases s.len() - start_idx when start_idx <= s.len()\n\n    decreases s.len() - start_idx when start_idx <= s.len()\n\n    decreases s.len() - start_idx when start_idx <= s.len()\n\n    decreases segments.len()\n\n    requires valid_input(n as nat, k as nat, s@, available@)\n\n    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {\n    n == s.len() &&\n    k == available.len() &&\n    forall|i: int, j: int| 0 <= i < j < available.len() ==> available[i] != available[j]\n}\n\nspec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else {\n        let segments = get_maximal_valid_segments(s, available_set, 0);\n        sum_segment_counts(segments)\n    }\n}\n\nspec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() { Seq::empty() }\n    else {\n        let segment_length = get_next_segment_length(s, available_set, start_idx);\n        if segment_length == 0 {\n            get_maximal_valid_segments(s, available_set, start_idx + 1)\n        } else {\n            let skip_length = skip_invalid_chars(s, available_set, start_idx + segment_length);\n            let next_idx = start_idx + segment_length + skip_length;\n            if next_idx <= s.len() {\n                seq![segment_length].add(get_maximal_valid_segments(s, available_set, next_idx))\n            } else {\n                seq![segment_length]\n            }\n        }\n    }\n}\n\nspec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || !available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + get_next_segment_length(s, available_set, start_idx + 1) }\n}\n\nspec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + skip_invalid_chars(s, available_set, start_idx + 1) }\n}\n\nspec fn sum_segment_counts(segments: Seq<nat>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { 0 }\n    else { segments[0] * (segments[0] + 1) / 2 + sum_segment_counts(segments.subrange(1, segments.len() as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, k: u8, s: Vec<char>, available: Vec<char>) -> (result: u8)\n    requires valid_input(n as nat, k as nat, s@, available@)\n    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4441_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {\n    let lines = split_lines_func(stdin_input);\n    if lines.len() >= 1 {\n        let n = string_to_int(lines[0]);\n        if n == 1 {\n            seq!['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\n']\n        } else if n != 1 && lines.len() >= 3 {\n            let a = string_to_int(lines[1]);\n            let b = string_to_int(lines[2]);\n            int_to_string(a + b) + seq!['\\n']\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_func_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i >= s.len() {\n        if current.len() == 0 { acc } else { acc.push(current) }\n    } else if s[i] == '\\n' {\n        split_lines_func_helper(s, i + 1, seq![], acc.push(current))\n    } else {\n        split_lines_func_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -string_to_int_helper(s.subrange(1, s.len() as int))\n    } else {\n        string_to_int_helper(s)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        seq![]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@ == expected_output(stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {\n    let lines = split_lines_func(stdin_input);\n    if lines.len() >= 1 {\n        let n = string_to_int(lines[0]);\n        if n == 1 {\n            seq!['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\n']\n        } else if n != 1 && lines.len() >= 3 {\n            let a = string_to_int(lines[1]);\n            let b = string_to_int(lines[2]);\n            int_to_string(a + b) + seq!['\\n']\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_func_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i >= s.len() {\n        if current.len() == 0 { acc } else { acc.push(current) }\n    } else if s[i] == '\\n' {\n        split_lines_func_helper(s, i + 1, seq![], acc.push(current))\n    } else {\n        split_lines_func_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -string_to_int_helper(s.subrange(1, s.len() as int))\n    } else {\n        string_to_int_helper(s)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        seq![]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@ == expected_output(stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4441.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 849, "minimize_time_ms": 122890, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 102, "minimized_LOC": 102, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n\n    decreases s.len() - i when 0 <= i <= s.len()\n\n    decreases s.len()\n\n    decreases n when n >= 0\n\n    requires valid_input(stdin_input@)\n\n    ensures result@ == expected_output(stdin_input@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {\n    let lines = split_lines_func(stdin_input);\n    if lines.len() >= 1 {\n        let n = string_to_int(lines[0]);\n        if n == 1 {\n            seq!['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\n']\n        } else if n != 1 && lines.len() >= 3 {\n            let a = string_to_int(lines[1]);\n            let b = string_to_int(lines[2]);\n            int_to_string(a + b) + seq!['\\n']\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_func_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i >= s.len() {\n        if current.len() == 0 { acc } else { acc.push(current) }\n    } else if s[i] == '\\n' {\n        split_lines_func_helper(s, i + 1, seq![], acc.push(current))\n    } else {\n        split_lines_func_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -string_to_int_helper(s.subrange(1, s.len() as int))\n    } else {\n        string_to_int_helper(s)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        seq![]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@ == expected_output(stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4444_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 2 &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ') &&\n    (forall|i: int| 0 <= i < input.len() ==> (#[trigger] input[i] == ' ' || input[i] == '\\n' || ('a' <= input[i] <= 'z'))) &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ' && \n     (forall|j: int| 0 <= j < i ==> #[trigger] input[j] != ' ' && input[j] != '\\n') &&\n     (forall|j: int| i+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n'))\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    output[output.len() as int - 1] == '\\n' &&\n    (forall|i: int| 0 <= i < output.len() - 1 ==> ('a' <= #[trigger] output[i] <= 'z'))\n}\n\nspec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)\n    recommends valid_input(input)\n{\n    let space_pos = choose|space_pos: int| 0 < space_pos < input.len() && input[space_pos] == ' ' &&\n                       (forall|j: int| 0 <= j < space_pos ==> #[trigger] input[j] != ' ') &&\n                       (forall|j: int| space_pos+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n');\n    let s = input.subrange(0, space_pos);\n    let t = if input[input.len() as int - 1] == '\\n' { \n        input.subrange(space_pos + 1, input.len() - 1) \n    } else { \n        input.subrange(space_pos + 1, input.len() as int) \n    };\n    (s, t)\n}\n\nspec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let (s, t) = extract_strings(input);\n    output == t.add(s).push('\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_output(output@),\n        correct_concatenation(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 2 &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ') &&\n    (forall|i: int| 0 <= i < input.len() ==> (#[trigger] input[i] == ' ' || input[i] == '\\n' || ('a' <= input[i] <= 'z'))) &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ' && \n     (forall|j: int| 0 <= j < i ==> #[trigger] input[j] != ' ' && input[j] != '\\n') &&\n     (forall|j: int| i+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n'))\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    output[output.len() as int - 1] == '\\n' &&\n    (forall|i: int| 0 <= i < output.len() - 1 ==> ('a' <= #[trigger] output[i] <= 'z'))\n}\n\nspec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)\n    recommends valid_input(input)\n{\n    let space_pos = choose|space_pos: int| 0 < space_pos < input.len() && input[space_pos] == ' ' &&\n                       (forall|j: int| 0 <= j < space_pos ==> #[trigger] input[j] != ' ') &&\n                       (forall|j: int| space_pos+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n');\n    let s = input.subrange(0, space_pos);\n    let t = if input[input.len() as int - 1] == '\\n' { \n        input.subrange(space_pos + 1, input.len() - 1) \n    } else { \n        input.subrange(space_pos + 1, input.len() as int) \n    };\n    (s, t)\n}\n\nspec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let (s, t) = extract_strings(input);\n    output == t.add(s).push('\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_output(output@),\n        correct_concatenation(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4444.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 798, "minimize_time_ms": 184735, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>) -> bool {\n\nspec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)\n    recommends valid_input(input)\n{\n\nspec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 2 &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ') &&\n    (forall|i: int| 0 <= i < input.len() ==> (#[trigger] input[i] == ' ' || input[i] == '\\n' || ('a' <= input[i] <= 'z'))) &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ' && \n     (forall|j: int| 0 <= j < i ==> #[trigger] input[j] != ' ' && input[j] != '\\n') &&\n     (forall|j: int| i+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n'))\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    output[output.len() as int - 1] == '\\n' &&\n    (forall|i: int| 0 <= i < output.len() - 1 ==> ('a' <= #[trigger] output[i] <= 'z'))\n}\n\nspec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)\n    recommends valid_input(input)\n{\n    let space_pos = choose|space_pos: int| 0 < space_pos < input.len() && input[space_pos] == ' ' &&\n                       (forall|j: int| 0 <= j < space_pos ==> #[trigger] input[j] != ' ') &&\n                       (forall|j: int| space_pos+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n');\n    let s = input.subrange(0, space_pos);\n    let t = if input[input.len() as int - 1] == '\\n' { \n        input.subrange(space_pos + 1, input.len() - 1) \n    } else { \n        input.subrange(space_pos + 1, input.len() as int) \n    };\n    (s, t)\n}\n\nspec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let (s, t) = extract_strings(input);\n    output == t.add(s).push('\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_output(output@),\n        correct_concatenation(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4446_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {\n    n > 0 && a > 0 && b > 0 && k >= 0 && h.len() == n && \n    forall|i: int| 0 <= i < h.len() ==> h[i] > 0\n}\n\nspec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>\n    decreases h.len()\n{\n    if h.len() == 0 {\n        seq![]\n    } else {\n        let h_mod = h[0] % (a + b);\n        let h_final = if h_mod == 0 { a + b } else { h_mod };\n        seq![h_final] + process_health_values(h.drop_first(), a, b)\n    }\n}\n\nspec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {\n    count_killable_helper(sorted_health, a, k, 0, 0)\n}\n\nspec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int\n    decreases sorted_health.len() - index\n{\n    if index >= sorted_health.len() {\n        acc\n    } else {\n        let x = sorted_health[index];\n        if x <= a {\n            count_killable_helper(sorted_health, a, remaining_k, index + 1, acc + 1)\n        } else {\n            let needed_skips = (x + a - 1) / a - 1;\n            if remaining_k >= needed_skips {\n                count_killable_helper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)\n            } else {\n                count_killable_helper(sorted_health, a, remaining_k, index + 1, acc)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_core(n: i8, a: i8, b: i8, k: i8, h: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))\n    ensures 0 <= result as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {\n    n > 0 && a > 0 && b > 0 && k >= 0 && h.len() == n && \n    forall|i: int| 0 <= i < h.len() ==> h[i] > 0\n}\n\nspec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>\n    decreases h.len()\n{\n    if h.len() == 0 {\n        seq![]\n    } else {\n        let h_mod = h[0] % (a + b);\n        let h_final = if h_mod == 0 { a + b } else { h_mod };\n        seq![h_final] + process_health_values(h.drop_first(), a, b)\n    }\n}\n\nspec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {\n    count_killable_helper(sorted_health, a, k, 0, 0)\n}\n\nspec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int\n    decreases sorted_health.len() - index\n{\n    if index >= sorted_health.len() {\n        acc\n    } else {\n        let x = sorted_health[index];\n        if x <= a {\n            count_killable_helper(sorted_health, a, remaining_k, index + 1, acc + 1)\n        } else {\n            let needed_skips = (x + a - 1) / a - 1;\n            if remaining_k >= needed_skips {\n                count_killable_helper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)\n            } else {\n                count_killable_helper(sorted_health, a, remaining_k, index + 1, acc)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_core(n: i8, a: i8, b: i8, k: i8, h: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))\n    ensures 0 <= result as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4446.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 798, "minimize_time_ms": 122821, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {\n\nspec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>\n    decreases h.len()\n{\n\nspec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {\n\nspec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int\n    decreases sorted_health.len() - index\n{\n\n    decreases h.len()\n\n    decreases sorted_health.len() - index\n\n    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))\n\n    ensures 0 <= result as int <= n as int"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {\n    n > 0 && a > 0 && b > 0 && k >= 0 && h.len() == n && \n    forall|i: int| 0 <= i < h.len() ==> h[i] > 0\n}\n\nspec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>\n    decreases h.len()\n{\n    if h.len() == 0 {\n        seq![]\n    } else {\n        let h_mod = h[0] % (a + b);\n        let h_final = if h_mod == 0 { a + b } else { h_mod };\n        seq![h_final] + process_health_values(h.drop_first(), a, b)\n    }\n}\n\nspec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {\n    count_killable_helper(sorted_health, a, k, 0, 0)\n}\n\nspec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int\n    decreases sorted_health.len() - index\n{\n    if index >= sorted_health.len() {\n        acc\n    } else {\n        let x = sorted_health[index];\n        if x <= a {\n            count_killable_helper(sorted_health, a, remaining_k, index + 1, acc + 1)\n        } else {\n            let needed_skips = (x + a - 1) / a - 1;\n            if remaining_k >= needed_skips {\n                count_killable_helper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)\n            } else {\n                count_killable_helper(sorted_health, a, remaining_k, index + 1, acc)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_core(n: i8, a: i8, b: i8, k: i8, h: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))\n    ensures 0 <= result as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4469_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(queries: Seq<(char, int)>) -> bool {\n    &&& queries.len() > 0\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].0 == 'L' || queries[i].0 == 'R' || queries[i].0 == '?')\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].1 > 0)\n    &&& (forall|i: int, j: int| 0 <= i < j < queries.len() && (queries[i].0 == 'L' || queries[i].0 == 'R') && (queries[j].0 == 'L' || queries[j].0 == 'R') ==> queries[i].1 != queries[j].1)\n    &&& (forall|i: int| 0 <= i < queries.len() && queries[i].0 == '?' ==> \n        exists|j: int| 0 <= j < i && (queries[j].0 == 'L' || queries[j].0 == 'R') && queries[j].1 == queries[i].1)\n    &&& (exists|i: int| 0 <= i < queries.len() && queries[i].0 == '?')\n}\n\nspec fn count_query_ops(queries: Seq<(char, int)>) -> int\n    decreases queries.len()\n{\n    if queries.len() == 0 {\n        0\n    } else {\n        let head = queries[0];\n        let tail = queries.subrange(1, queries.len() as int);\n        if head.0 == '?' {\n            1 + count_query_ops(tail)\n        } else {\n            count_query_ops(tail)\n        }\n    }\n}\n\nspec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {\n    &&& results.len() == count_query_ops(queries)\n    &&& (forall|i: int| 0 <= i < results.len() ==> results[i] >= 0)\n    &&& (forall|r_idx: int| #[trigger] results[r_idx] == compute_min_removals(queries, r_idx) ==> 0 <= r_idx < results.len() ==> \n        (exists|q_idx: int| 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n    &&& (forall|q_idx: int| #[trigger] queries[q_idx] == queries[q_idx] ==> 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' ==>\n        (exists|r_idx: int| 0 <= r_idx < results.len() &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n}\n\nstruct BookshelfState {\n    positions: Map<int, int>,\n    head: int,\n    tail: int,\n}\n\nspec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {\n    BookshelfState {\n        positions: Map::empty(),\n        head: 0,\n        tail: 0,\n    }\n}\n\nspec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(char, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))\n    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(queries: Seq<(char, int)>) -> bool {\n    &&& queries.len() > 0\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].0 == 'L' || queries[i].0 == 'R' || queries[i].0 == '?')\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].1 > 0)\n    &&& (forall|i: int, j: int| 0 <= i < j < queries.len() && (queries[i].0 == 'L' || queries[i].0 == 'R') && (queries[j].0 == 'L' || queries[j].0 == 'R') ==> queries[i].1 != queries[j].1)\n    &&& (forall|i: int| 0 <= i < queries.len() && queries[i].0 == '?' ==> \n        exists|j: int| 0 <= j < i && (queries[j].0 == 'L' || queries[j].0 == 'R') && queries[j].1 == queries[i].1)\n    &&& (exists|i: int| 0 <= i < queries.len() && queries[i].0 == '?')\n}\n\nspec fn count_query_ops(queries: Seq<(char, int)>) -> int\n    decreases queries.len()\n{\n    if queries.len() == 0 {\n        0\n    } else {\n        let head = queries[0];\n        let tail = queries.subrange(1, queries.len() as int);\n        if head.0 == '?' {\n            1 + count_query_ops(tail)\n        } else {\n            count_query_ops(tail)\n        }\n    }\n}\n\nspec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {\n    &&& results.len() == count_query_ops(queries)\n    &&& (forall|i: int| 0 <= i < results.len() ==> results[i] >= 0)\n    &&& (forall|r_idx: int| #[trigger] results[r_idx] == compute_min_removals(queries, r_idx) ==> 0 <= r_idx < results.len() ==> \n        (exists|q_idx: int| 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n    &&& (forall|q_idx: int| #[trigger] queries[q_idx] == queries[q_idx] ==> 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' ==>\n        (exists|r_idx: int| 0 <= r_idx < results.len() &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n}\n\nstruct BookshelfState {\n    positions: Map<int, int>,\n    head: int,\n    tail: int,\n}\n\nspec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {\n    BookshelfState {\n        positions: Map::empty(),\n        head: 0,\n        tail: 0,\n    }\n}\n\nspec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(char, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))\n    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4469.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 826, "minimize_time_ms": 185219, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 82, "minimized_LOC": 82, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(queries: Seq<(char, int)>) -> bool {\n\nspec fn count_query_ops(queries: Seq<(char, int)>) -> int\n    decreases queries.len()\n{\n\nspec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {\n\nspec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {\n\nspec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {\n\n    decreases queries.len()\n\n    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))\n\n    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(queries: Seq<(char, int)>) -> bool {\n    &&& queries.len() > 0\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].0 == 'L' || queries[i].0 == 'R' || queries[i].0 == '?')\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].1 > 0)\n    &&& (forall|i: int, j: int| 0 <= i < j < queries.len() && (queries[i].0 == 'L' || queries[i].0 == 'R') && (queries[j].0 == 'L' || queries[j].0 == 'R') ==> queries[i].1 != queries[j].1)\n    &&& (forall|i: int| 0 <= i < queries.len() && queries[i].0 == '?' ==> \n        exists|j: int| 0 <= j < i && (queries[j].0 == 'L' || queries[j].0 == 'R') && queries[j].1 == queries[i].1)\n    &&& (exists|i: int| 0 <= i < queries.len() && queries[i].0 == '?')\n}\n\nspec fn count_query_ops(queries: Seq<(char, int)>) -> int\n    decreases queries.len()\n{\n    if queries.len() == 0 {\n        0\n    } else {\n        let head = queries[0];\n        let tail = queries.subrange(1, queries.len() as int);\n        if head.0 == '?' {\n            1 + count_query_ops(tail)\n        } else {\n            count_query_ops(tail)\n        }\n    }\n}\n\nspec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {\n    &&& results.len() == count_query_ops(queries)\n    &&& (forall|i: int| 0 <= i < results.len() ==> results[i] >= 0)\n    &&& (forall|r_idx: int| #[trigger] results[r_idx] == compute_min_removals(queries, r_idx) ==> 0 <= r_idx < results.len() ==> \n        (exists|q_idx: int| 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n    &&& (forall|q_idx: int| #[trigger] queries[q_idx] == queries[q_idx] ==> 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' ==>\n        (exists|r_idx: int| 0 <= r_idx < results.len() &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n}\n\nstruct BookshelfState {\n    positions: Map<int, int>,\n    head: int,\n    tail: int,\n}\n\nspec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {\n    BookshelfState {\n        positions: Map::empty(),\n        head: 0,\n        tail: 0,\n    }\n}\n\nspec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(char, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))\n    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {\n      }\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4470_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn can_reach_one(n: nat) -> bool\n    recommends n > 0\n{\n    only_factors_235(n)\n}\n\nspec fn only_factors_235(n: nat) -> bool\n    recommends n > 0\n{\n    reduce_by_factors_235(n) == 1\n}\n\nspec fn reduce_by_factors_235(n: nat) -> nat\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        1\n    } else if n % 2 == 0 {\n        reduce_by_factors_235(n / 2)\n    } else if n % 3 == 0 {\n        reduce_by_factors_235(n / 3)\n    } else if n % 5 == 0 {\n        reduce_by_factors_235(n / 5)\n    } else {\n        n\n    }\n}\n\nspec fn min_moves_to_one(n: nat) -> nat\n    recommends n > 0 && can_reach_one(n)\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        0\n    } else if n % 2 == 0 {\n        1 + min_moves_to_one(n / 2)\n    } else if n % 3 == 0 {\n        2 + min_moves_to_one(n / 3)\n    } else if n % 5 == 0 {\n        3 + min_moves_to_one(n / 5)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8) -> (result: i8)\n    requires\n        valid_input(n as nat),\n    ensures\n        result >= -1,\n        result == -1 <==> !can_reach_one(n as nat),\n        result >= 0 ==> can_reach_one(n as nat) && result == min_moves_to_one(n as nat) as i8,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn can_reach_one(n: nat) -> bool\n    recommends n > 0\n{\n    only_factors_235(n)\n}\n\nspec fn only_factors_235(n: nat) -> bool\n    recommends n > 0\n{\n    reduce_by_factors_235(n) == 1\n}\n\nspec fn reduce_by_factors_235(n: nat) -> nat\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        1\n    } else if n % 2 == 0 {\n        reduce_by_factors_235(n / 2)\n    } else if n % 3 == 0 {\n        reduce_by_factors_235(n / 3)\n    } else if n % 5 == 0 {\n        reduce_by_factors_235(n / 5)\n    } else {\n        n\n    }\n}\n\nspec fn min_moves_to_one(n: nat) -> nat\n    recommends n > 0 && can_reach_one(n)\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        0\n    } else if n % 2 == 0 {\n        1 + min_moves_to_one(n / 2)\n    } else if n % 3 == 0 {\n        2 + min_moves_to_one(n / 3)\n    } else if n % 5 == 0 {\n        3 + min_moves_to_one(n / 5)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8) -> (result: i8)\n    requires\n        valid_input(n as nat),\n    ensures\n        result >= -1,\n        result == -1 <==> !can_reach_one(n as nat),\n        result >= 0 ==> can_reach_one(n as nat) && result == min_moves_to_one(n as nat) as i8,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4470.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 744, "minimize_time_ms": 122736, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 80, "minimized_LOC": 80, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: nat) -> bool {\n\nspec fn can_reach_one(n: nat) -> bool\n    recommends n > 0\n{\n\nspec fn only_factors_235(n: nat) -> bool\n    recommends n > 0\n{\n\nspec fn reduce_by_factors_235(n: nat) -> nat\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n\nspec fn min_moves_to_one(n: nat) -> nat\n    recommends n > 0 && can_reach_one(n)\n    decreases n\n    when n > 0\n{\n\n    decreases n\n\n    decreases n\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn can_reach_one(n: nat) -> bool\n    recommends n > 0\n{\n    only_factors_235(n)\n}\n\nspec fn only_factors_235(n: nat) -> bool\n    recommends n > 0\n{\n    reduce_by_factors_235(n) == 1\n}\n\nspec fn reduce_by_factors_235(n: nat) -> nat\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        1\n    } else if n % 2 == 0 {\n        reduce_by_factors_235(n / 2)\n    } else if n % 3 == 0 {\n        reduce_by_factors_235(n / 3)\n    } else if n % 5 == 0 {\n        reduce_by_factors_235(n / 5)\n    } else {\n        n\n    }\n}\n\nspec fn min_moves_to_one(n: nat) -> nat\n    recommends n > 0 && can_reach_one(n)\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        0\n    } else if n % 2 == 0 {\n        1 + min_moves_to_one(n / 2)\n    } else if n % 3 == 0 {\n        2 + min_moves_to_one(n / 3)\n    } else if n % 5 == 0 {\n        3 + min_moves_to_one(n / 5)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8) -> (result: i8)\n    requires\n        valid_input(n as nat),\n    ensures\n        result >= -1,\n        result == -1 <==> !can_reach_one(n as nat),\n        result >= 0 ==> can_reach_one(n as nat) && result == min_moves_to_one(n as nat) as i8,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4477_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_boring_apartment(x: int) -> bool {\n    (x >= 1 && x <= 9) ||\n    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||\n    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||\n    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)\n}\n\nspec fn digit_count(n: int) -> int {\n    if n <= 9 { 1 }\n    else if n <= 99 { 2 }\n    else if n <= 999 { 3 }\n    else { 4 }\n}\n\nspec fn boring_apartment_value(digit: int, length: int) -> int {\n    if length == 1 { digit }\n    else if length == 2 { digit * 11 }\n    else if length == 3 { digit * 111 }\n    else { digit * 1111 }\n}\n\nspec fn total_digits_pressed(x: int) -> int {\n    let digit = if x <= 9 { x } \n                 else if x <= 99 { x / 11 }\n                 else if x <= 999 { x / 111 }\n                 else { x / 1111 };\n    let length = digit_count(x);\n\n    let prev_digits = if digit == 1 { 0 } else { (digit - 1) * (1 + 2 + 3 + 4) };\n\n    let current_digits = (length * (length + 1)) / 2;\n\n    prev_digits + current_digits\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i32) -> (result: i32)\n    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999\n    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && \n            (x as int == 1 ==> result as int == 1) &&\n            (x as int == 22 ==> result as int == 13) &&\n            (x as int == 777 ==> result as int == 66) &&\n            (x as int == 9999 ==> result as int == 90)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_boring_apartment(x: int) -> bool {\n    (x >= 1 && x <= 9) ||\n    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||\n    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||\n    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)\n}\n\nspec fn digit_count(n: int) -> int {\n    if n <= 9 { 1 }\n    else if n <= 99 { 2 }\n    else if n <= 999 { 3 }\n    else { 4 }\n}\n\nspec fn boring_apartment_value(digit: int, length: int) -> int {\n    if length == 1 { digit }\n    else if length == 2 { digit * 11 }\n    else if length == 3 { digit * 111 }\n    else { digit * 1111 }\n}\n\nspec fn total_digits_pressed(x: int) -> int {\n    let digit = if x <= 9 { x } \n                 else if x <= 99 { x / 11 }\n                 else if x <= 999 { x / 111 }\n                 else { x / 1111 };\n    let length = digit_count(x);\n\n    let prev_digits = if digit == 1 { 0 } else { (digit - 1) * (1 + 2 + 3 + 4) };\n\n    let current_digits = (length * (length + 1)) / 2;\n\n    prev_digits + current_digits\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i32) -> (result: i32)\n    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999\n    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && \n            (x as int == 1 ==> result as int == 1) &&\n            (x as int == 22 ==> result as int == 13) &&\n            (x as int == 777 ==> result as int == 66) &&\n            (x as int == 9999 ==> result as int == 90)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4477.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 710, "minimize_time_ms": 122750, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_boring_apartment(x: int) -> bool {\n\nspec fn digit_count(n: int) -> int {\n\nspec fn boring_apartment_value(digit: int, length: int) -> int {\n\nspec fn total_digits_pressed(x: int) -> int {\n\n    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999\n\n    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_boring_apartment(x: int) -> bool {\n    (x >= 1 && x <= 9) ||\n    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||\n    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||\n    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)\n}\n\nspec fn digit_count(n: int) -> int {\n    if n <= 9 { 1 }\n    else if n <= 99 { 2 }\n    else if n <= 999 { 3 }\n    else { 4 }\n}\n\nspec fn boring_apartment_value(digit: int, length: int) -> int {\n    if length == 1 { digit }\n    else if length == 2 { digit * 11 }\n    else if length == 3 { digit * 111 }\n    else { digit * 1111 }\n}\n\nspec fn total_digits_pressed(x: int) -> int {\n    let digit = if x <= 9 { x } \n                 else if x <= 99 { x / 11 }\n                 else if x <= 999 { x / 111 }\n                 else { x / 1111 };\n    let length = digit_count(x);\n\n    let prev_digits = if digit == 1 { 0 } else { (digit - 1) * (1 + 2 + 3 + 4) };\n\n    let current_digits = (length * (length + 1)) / 2;\n\n    prev_digits + current_digits\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i32) -> (result: i32)\n    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999\n    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && \n            (x as int == 1 ==> result as int == 1) &&\n            (x as int == 22 ==> result as int == 13) &&\n            (x as int == 777 ==> result as int == 66) &&\n            (x as int == 9999 ==> result as int == 90)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4487_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {\n    parts.len() == 3 && parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0\n}\n\nspec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {\n    a.len() > 0 && b.len() > 0 && c.len() > 0 &&\n    a[a.len() - 1] == b[0] && b[b.len() - 1] == c[0]\n}\n\nspec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn expected_result(input: Seq<char>) -> Seq<char> {\n    let stripped = if input.len() > 0 && input[input.len() - 1] == '\\n' {\n        input.subrange(0, input.len() - 1)\n    } else {\n        input\n    };\n    let parts = split_on_spaces(stripped);\n    if valid_parsed_input(parts) {\n        if is_word_chain(parts[0], parts[1], parts[2]) {\n            seq!['Y', 'E', 'S', '\\n']\n        } else {\n            seq!['N', 'O', '\\n']\n        }\n    } else {\n        seq![]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == expected_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {\n    parts.len() == 3 && parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0\n}\n\nspec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {\n    a.len() > 0 && b.len() > 0 && c.len() > 0 &&\n    a[a.len() - 1] == b[0] && b[b.len() - 1] == c[0]\n}\n\nspec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn expected_result(input: Seq<char>) -> Seq<char> {\n    let stripped = if input.len() > 0 && input[input.len() - 1] == '\\n' {\n        input.subrange(0, input.len() - 1)\n    } else {\n        input\n    };\n    let parts = split_on_spaces(stripped);\n    if valid_parsed_input(parts) {\n        if is_word_chain(parts[0], parts[1], parts[2]) {\n            seq!['Y', 'E', 'S', '\\n']\n        } else {\n            seq!['N', 'O', '\\n']\n        }\n    } else {\n        seq![]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == expected_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4487.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 749, "minimize_time_ms": 122795, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {\n\nspec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {\n\nspec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn expected_result(input: Seq<char>) -> Seq<char> {\n\nspec fn expected_result(input: Seq<char>) -> Seq<char> {\n\n    requires valid_input(input@)\n\n    ensures result@ == expected_result(input@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {\n    parts.len() == 3 && parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0\n}\n\nspec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {\n    a.len() > 0 && b.len() > 0 && c.len() > 0 &&\n    a[a.len() - 1] == b[0] && b[b.len() - 1] == c[0]\n}\n\nspec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn expected_result(input: Seq<char>) -> Seq<char> {\n    let stripped = if input.len() > 0 && input[input.len() - 1] == '\\n' {\n        input.subrange(0, input.len() - 1)\n    } else {\n        input\n    };\n    let parts = split_on_spaces(stripped);\n    if valid_parsed_input(parts) {\n        if is_word_chain(parts[0], parts[1], parts[2]) {\n            seq!['Y', 'E', 'S', '\\n']\n        } else {\n            seq!['N', 'O', '\\n']\n        }\n    } else {\n        seq![]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == expected_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4488_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_integer(lines[1])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == '\\n' {\n        split_lines_spec(s.subrange(1, s.len() as int))\n    } else {\n        let next_newline = find_next_newline(s, 0);\n        if next_newline == -1 {\n            seq![s]\n        } else if next_newline >= 0 && next_newline < s.len() && next_newline + 1 <= s.len() {\n            seq![s.subrange(0, next_newline)] + split_lines_spec(s.subrange(next_newline + 1, s.len() as int))\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn find_next_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        -1\n    } else if s[start as int] == '\\n' {\n        start as int\n    } else {\n        find_next_newline(s, start + 1)\n    }\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    parse_int_helper(s, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, pos: nat) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() || s[pos as int] == '\\n' || s[pos as int] == '\\r' {\n        0\n    } else if '0' <= s[pos as int] <= '9' {\n        (s[pos as int] as int - '0' as int) + 10 * parse_int_helper(s, pos + 1)\n    } else {\n        parse_int_helper(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures ({\n        let input_seq = input@;\n        valid_input(input_seq) ==> {\n            let lines = split_lines_spec(input_seq);\n            let a = parse_int_spec(lines[0]);\n            let b = parse_int_spec(lines[1]);\n            (result@ == \"LESS\\n\"@) == (a < b) &&\n            (result@ == \"GREATER\\n\"@) == (a > b) &&\n            (result@ == \"EQUAL\\n\"@) == (a == b)\n        }\n    }) && ({\n        let input_seq = input@;\n        !valid_input(input_seq) ==> result@ == \"\"@\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_integer(lines[1])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == '\\n' {\n        split_lines_spec(s.subrange(1, s.len() as int))\n    } else {\n        let next_newline = find_next_newline(s, 0);\n        if next_newline == -1 {\n            seq![s]\n        } else if next_newline >= 0 && next_newline < s.len() && next_newline + 1 <= s.len() {\n            seq![s.subrange(0, next_newline)] + split_lines_spec(s.subrange(next_newline + 1, s.len() as int))\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn find_next_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        -1\n    } else if s[start as int] == '\\n' {\n        start as int\n    } else {\n        find_next_newline(s, start + 1)\n    }\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    parse_int_helper(s, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, pos: nat) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() || s[pos as int] == '\\n' || s[pos as int] == '\\r' {\n        0\n    } else if '0' <= s[pos as int] <= '9' {\n        (s[pos as int] as int - '0' as int) + 10 * parse_int_helper(s, pos + 1)\n    } else {\n        parse_int_helper(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures ({\n        let input_seq = input@;\n        valid_input(input_seq) ==> {\n            let lines = split_lines_spec(input_seq);\n            let a = parse_int_spec(lines[0]);\n            let b = parse_int_spec(lines[1]);\n            (result@ == \"LESS\\n\"@) == (a < b) &&\n            (result@ == \"GREATER\\n\"@) == (a > b) &&\n            (result@ == \"EQUAL\\n\"@) == (a == b)\n        }\n    }) && ({\n        let input_seq = input@;\n        !valid_input(input_seq) ==> result@ == \"\"@\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4488.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 833, "minimize_time_ms": 216253, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 94, "minimized_LOC": 94, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 22, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\nspec fn find_next_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n\nspec fn parse_int_helper(s: Seq<char>, pos: nat) -> int\n    decreases s.len() - pos\n{\n\n    decreases s.len()\n\n    decreases s.len() - start\n\n    decreases s.len() - pos\n\n    requires input@.len() > 0\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_integer(lines[1])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == '\\n' {\n        split_lines_spec(s.subrange(1, s.len() as int))\n    } else {\n        let next_newline = find_next_newline(s, 0);\n        if next_newline == -1 {\n            seq![s]\n        } else if next_newline >= 0 && next_newline < s.len() && next_newline + 1 <= s.len() {\n            seq![s.subrange(0, next_newline)] + split_lines_spec(s.subrange(next_newline + 1, s.len() as int))\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn find_next_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        -1\n    } else if s[start as int] == '\\n' {\n        start as int\n    } else {\n        find_next_newline(s, start + 1)\n    }\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    parse_int_helper(s, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, pos: nat) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() || s[pos as int] == '\\n' || s[pos as int] == '\\r' {\n        0\n    } else if '0' <= s[pos as int] <= '9' {\n        (s[pos as int] as int - '0' as int) + 10 * parse_int_helper(s, pos + 1)\n    } else {\n        parse_int_helper(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures ({\n        let input_seq = input@;\n        valid_input(input_seq) ==> {\n            let lines = split_lines_spec(input_seq);\n            let a = parse_int_spec(lines[0]);\n            let b = parse_int_spec(lines[1]);\n            (result@ == \"LESS\\n\"@) == (a < b) &&\n            (result@ == \"GREATER\\n\"@) == (a > b) &&\n            (result@ == \"EQUAL\\n\"@) == (a == b)\n        }\n    }) && ({\n        let input_seq = input@;\n        !valid_input(input_seq) ==> result@ == \"\"@\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {\n      }\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4489_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(cards: Seq<&str>, target: &str) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else if cards[0] == target {\n        1 + count_occurrences(cards.subrange(1, cards.len() as int), target)\n    } else {\n        count_occurrences(cards.subrange(1, cards.len() as int), target)\n    }\n}\n\nspec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>\n    decreases all_strings.len()\n{\n    if all_strings.len() == 0 {\n        Seq::empty()\n    } else {\n        let rest_unique = get_unique_strings(all_strings.subrange(1, all_strings.len() as int));\n        if rest_unique.contains(all_strings[0]) {\n            rest_unique\n        } else {\n            seq![all_strings[0]].add(rest_unique)\n        }\n    }\n}\n\nspec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)\n}\n\nspec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n        current_max\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)\n    }\n}\n\nproof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)\n    ensures count_occurrences(cards, target) >= 0\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n    } else if cards[0] == target {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    } else {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    }\n}\n\nproof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)\n    ensures max_net_earnings(blue_cards, red_cards) >= 0\n{\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, 0, 0);\n}\n\nproof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)\n    requires \n        0 <= index <= unique_blue.len(),\n        current_max >= 0\n    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, index + 1, new_max);\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(blue_cards: Vec<&str>, red_cards: Vec<&str>) -> (result: i8)\n    ensures \n        result >= 0,\n        result as int == max_net_earnings(blue_cards@, red_cards@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(cards: Seq<&str>, target: &str) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else if cards[0] == target {\n        1 + count_occurrences(cards.subrange(1, cards.len() as int), target)\n    } else {\n        count_occurrences(cards.subrange(1, cards.len() as int), target)\n    }\n}\n\nspec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>\n    decreases all_strings.len()\n{\n    if all_strings.len() == 0 {\n        Seq::empty()\n    } else {\n        let rest_unique = get_unique_strings(all_strings.subrange(1, all_strings.len() as int));\n        if rest_unique.contains(all_strings[0]) {\n            rest_unique\n        } else {\n            seq![all_strings[0]].add(rest_unique)\n        }\n    }\n}\n\nspec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)\n}\n\nspec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n        current_max\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)\n    }\n}\n\nproof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)\n    ensures count_occurrences(cards, target) >= 0\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n    } else if cards[0] == target {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    } else {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    }\n}\n\nproof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)\n    ensures max_net_earnings(blue_cards, red_cards) >= 0\n{\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, 0, 0);\n}\n\nproof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)\n    requires \n        0 <= index <= unique_blue.len(),\n        current_max >= 0\n    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, index + 1, new_max);\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(blue_cards: Vec<&str>, red_cards: Vec<&str>) -> (result: i8)\n    ensures \n        result >= 0,\n        result as int == max_net_earnings(blue_cards@, red_cards@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4489.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 833, "minimize_time_ms": 153414, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 109, "minimized_LOC": 109, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_occurrences(cards: Seq<&str>, target: &str) -> int\n    decreases cards.len()\n{\n\nspec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>\n    decreases all_strings.len()\n{\n\nspec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {\n\nspec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int\n    decreases unique_blue.len() - index\n{\n\n    decreases cards.len()\n\n    decreases all_strings.len()\n\n    decreases unique_blue.len() - index\n\n    ensures count_occurrences(cards, target) >= 0\n\n    decreases cards.len()\n\n    ensures max_net_earnings(blue_cards, red_cards) >= 0\n\n    requires \n\n    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max\n\n    decreases unique_blue.len() - index\n\n    ensures ", "proof": "proof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)\n    ensures count_occurrences(cards, target) >= 0\n    decreases cards.len()\n{\n\nproof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)\n    ensures max_net_earnings(blue_cards, red_cards) >= 0\n{\n\nproof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)\n    requires \n        0 <= index <= unique_blue.len(),\n        current_max >= 0\n    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max\n    decreases unique_blue.len() - index\n{"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(cards: Seq<&str>, target: &str) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else if cards[0] == target {\n        1 + count_occurrences(cards.subrange(1, cards.len() as int), target)\n    } else {\n        count_occurrences(cards.subrange(1, cards.len() as int), target)\n    }\n}\n\nspec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>\n    decreases all_strings.len()\n{\n    if all_strings.len() == 0 {\n        Seq::empty()\n    } else {\n        let rest_unique = get_unique_strings(all_strings.subrange(1, all_strings.len() as int));\n        if rest_unique.contains(all_strings[0]) {\n            rest_unique\n        } else {\n            seq![all_strings[0]].add(rest_unique)\n        }\n    }\n}\n\nspec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)\n}\n\nspec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n        current_max\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)\n    }\n}\n\nproof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)\n    ensures count_occurrences(cards, target) >= 0\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n    } else if cards[0] == target {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    } else {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    }\n}\n\nproof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)\n    ensures max_net_earnings(blue_cards, red_cards) >= 0\n{\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, 0, 0);\n}\n\nproof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)\n    requires \n        0 <= index <= unique_blue.len(),\n        current_max >= 0\n    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, index + 1, new_max);\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(blue_cards: Vec<&str>, red_cards: Vec<&str>) -> (result: i8)\n    ensures \n        result >= 0,\n        result as int == max_net_earnings(blue_cards@, red_cards@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4490_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_dna_base(c: char) -> bool {\n    c == 'A' || c == 'T' || c == 'C' || c == 'G'\n}\n\nspec fn dna_complement(c: char) -> char\n    recommends valid_dna_base(c)\n{\n    if c == 'A' { 'T' }\n    else if c == 'T' { 'A' }\n    else if c == 'C' { 'G' }\n    else if c == 'G' { 'C' }\n    else { 'A' } /* default case for spec completeness */\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    choose|i: int| 0 <= i < input.len() && input[i] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\\n' {\n        input.subrange(0, find_newline(input))\n    } else {\n        input\n    };\n    input_line.len() == 1 && valid_dna_base(input_line[0])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures ({\n        let input_seq = stdin_input@;\n        let input_line = if exists|i: int| 0 <= i < input_seq.len() && input_seq[i] == '\\n' {\n            input_seq.subrange(0, find_newline(input_seq))\n        } else {\n            input_seq\n        };\n        if valid_input(input_seq) {\n            result@ == seq![dna_complement(input_line[0]), '\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_dna_base(c: char) -> bool {\n    c == 'A' || c == 'T' || c == 'C' || c == 'G'\n}\n\nspec fn dna_complement(c: char) -> char\n    recommends valid_dna_base(c)\n{\n    if c == 'A' { 'T' }\n    else if c == 'T' { 'A' }\n    else if c == 'C' { 'G' }\n    else if c == 'G' { 'C' }\n    else { 'A' } /* default case for spec completeness */\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    choose|i: int| 0 <= i < input.len() && input[i] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\\n' {\n        input.subrange(0, find_newline(input))\n    } else {\n        input\n    };\n    input_line.len() == 1 && valid_dna_base(input_line[0])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures ({\n        let input_seq = stdin_input@;\n        let input_line = if exists|i: int| 0 <= i < input_seq.len() && input_seq[i] == '\\n' {\n            input_seq.subrange(0, find_newline(input_seq))\n        } else {\n            input_seq\n        };\n        if valid_input(input_seq) {\n            result@ == seq![dna_complement(input_line[0]), '\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4490.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 800, "minimize_time_ms": 122781, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_dna_base(c: char) -> bool {\n\nspec fn dna_complement(c: char) -> char\n    recommends valid_dna_base(c)\n{\n\nspec fn find_newline(input: Seq<char>) -> int {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\n    requires stdin_input@.len() > 0\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_dna_base(c: char) -> bool {\n    c == 'A' || c == 'T' || c == 'C' || c == 'G'\n}\n\nspec fn dna_complement(c: char) -> char\n    recommends valid_dna_base(c)\n{\n    if c == 'A' { 'T' }\n    else if c == 'T' { 'A' }\n    else if c == 'C' { 'G' }\n    else if c == 'G' { 'C' }\n    else { 'A' } /* default case for spec completeness */\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    choose|i: int| 0 <= i < input.len() && input[i] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\\n' {\n        input.subrange(0, find_newline(input))\n    } else {\n        input\n    };\n    input_line.len() == 1 && valid_dna_base(input_line[0])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures ({\n        let input_seq = stdin_input@;\n        let input_line = if exists|i: int| 0 <= i < input_seq.len() && input_seq[i] == '\\n' {\n            input_seq.subrange(0, find_newline(input_seq))\n        } else {\n            input_seq\n        };\n        if valid_input(input_seq) {\n            result@ == seq![dna_complement(input_line[0]), '\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4494_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    ({\n        let s = if input[input.len()-1] == '\\n' { \n            input.subrange(0, input.len() - 1)\n        } else { \n            input\n        };\n        s == \"ABC\"@ || s == \"ARC\"@\n    })\n}\n\nspec fn normalize_input(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    if input[input.len()-1] == '\\n' { \n        input.subrange(0, input.len() - 1)\n    } else { \n        input\n    }\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let s = normalize_input(input);\n    if s == \"ABC\"@ { \"ARC\\n\"@ } else { \"ABC\\n\"@ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == expected_output(input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    ({\n        let s = if input[input.len()-1] == '\\n' { \n            input.subrange(0, input.len() - 1)\n        } else { \n            input\n        };\n        s == \"ABC\"@ || s == \"ARC\"@\n    })\n}\n\nspec fn normalize_input(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    if input[input.len()-1] == '\\n' { \n        input.subrange(0, input.len() - 1)\n    } else { \n        input\n    }\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let s = normalize_input(input);\n    if s == \"ABC\"@ { \"ARC\\n\"@ } else { \"ABC\\n\"@ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == expected_output(input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4494.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 752, "minimize_time_ms": 123531, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn normalize_input(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n\n    requires valid_input(input@)\n\n    ensures result@ == expected_output(input@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    ({\n        let s = if input[input.len()-1] == '\\n' { \n            input.subrange(0, input.len() - 1)\n        } else { \n            input\n        };\n        s == \"ABC\"@ || s == \"ARC\"@\n    })\n}\n\nspec fn normalize_input(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    if input[input.len()-1] == '\\n' { \n        input.subrange(0, input.len() - 1)\n    } else { \n        input\n    }\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let s = normalize_input(input);\n    if s == \"ABC\"@ { \"ARC\\n\"@ } else { \"ABC\\n\"@ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == expected_output(input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4496_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(d: int) -> bool {\n    22 <= d <= 25\n}\n\nspec fn expected_output(d: int) -> Seq<char> {\n    if valid_input(d) {\n        let eve_count = 25 - d;\n        let base_string = seq!['C', 'h', 'r', 'i', 's', 't', 'm', 'a', 's'];\n        if eve_count == 0 {\n            base_string\n        } else {\n            base_string + repeat_eve(eve_count)\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn repeat_eve(count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 {\n        seq![]\n    } else {\n        seq![' ', 'E', 'v', 'e'] + repeat_eve(count - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(d: i8) -> (result: String)\n    requires valid_input(d as int)\n    ensures result@ == expected_output(d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(d: int) -> bool {\n    22 <= d <= 25\n}\n\nspec fn expected_output(d: int) -> Seq<char> {\n    if valid_input(d) {\n        let eve_count = 25 - d;\n        let base_string = seq!['C', 'h', 'r', 'i', 's', 't', 'm', 'a', 's'];\n        if eve_count == 0 {\n            base_string\n        } else {\n            base_string + repeat_eve(eve_count)\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn repeat_eve(count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 {\n        seq![]\n    } else {\n        seq![' ', 'E', 'v', 'e'] + repeat_eve(count - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(d: i8) -> (result: String)\n    requires valid_input(d as int)\n    ensures result@ == expected_output(d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4496.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 769, "minimize_time_ms": 122856, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(d: int) -> bool {\n\nspec fn expected_output(d: int) -> Seq<char> {\n\nspec fn repeat_eve(count: int) -> Seq<char>\n    decreases count\n{\n\n    decreases count\n\n    requires valid_input(d as int)\n\n    ensures result@ == expected_output(d as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(d: int) -> bool {\n    22 <= d <= 25\n}\n\nspec fn expected_output(d: int) -> Seq<char> {\n    if valid_input(d) {\n        let eve_count = 25 - d;\n        let base_string = seq!['C', 'h', 'r', 'i', 's', 't', 'm', 'a', 's'];\n        if eve_count == 0 {\n            base_string\n        } else {\n            base_string + repeat_eve(eve_count)\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn repeat_eve(count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 {\n        seq![]\n    } else {\n        seq![' ', 'E', 'v', 'e'] + repeat_eve(count - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(d: i8) -> (result: String)\n    requires valid_input(d as int)\n    ensures result@ == expected_output(d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_45_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n > 0 && k > 0\n}\n\nspec fn is_strictly_increasing(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i+1]\n}\n\nspec fn all_positive(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] > 0\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool\n{\n    s.len() == k && all_positive(s) && is_strictly_increasing(s) && sum_seq(s) == n\n}\n\nspec fn is_possible(n: int, k: int) -> bool\n{\n    k * (k + 1) / 2 <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        ((result.len() == 1 && result[0] == -1) || \n         (valid_sequence(result@.map(|_i: int, x: i8| x as int), n as int, k as int))) &&\n        ((result.len() == 1 && result[0] == -1) <==> !is_possible(n as int, k as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n > 0 && k > 0\n}\n\nspec fn is_strictly_increasing(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i+1]\n}\n\nspec fn all_positive(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] > 0\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool\n{\n    s.len() == k && all_positive(s) && is_strictly_increasing(s) && sum_seq(s) == n\n}\n\nspec fn is_possible(n: int, k: int) -> bool\n{\n    k * (k + 1) / 2 <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        ((result.len() == 1 && result[0] == -1) || \n         (valid_sequence(result@.map(|_i: int, x: i8| x as int), n as int, k as int))) &&\n        ((result.len() == 1 && result[0] == -1) <==> !is_possible(n as int, k as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_45.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 779, "minimize_time_ms": 154756, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int) -> bool\n{\n\nspec fn is_strictly_increasing(s: Seq<int>) -> bool\n{\n\nspec fn all_positive(s: Seq<int>) -> bool\n{\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool\n{\n\nspec fn is_possible(n: int, k: int) -> bool\n{\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n > 0 && k > 0\n}\n\nspec fn is_strictly_increasing(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i+1]\n}\n\nspec fn all_positive(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] > 0\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool\n{\n    s.len() == k && all_positive(s) && is_strictly_increasing(s) && sum_seq(s) == n\n}\n\nspec fn is_possible(n: int, k: int) -> bool\n{\n    k * (k + 1) / 2 <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        ((result.len() == 1 && result[0] == -1) || \n         (valid_sequence(result@.map(|_i: int, x: i8| x as int), n as int, k as int))) &&\n        ((result.len() == 1 && result[0] == -1) <==> !is_possible(n as int, k as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n           fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4502_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n\n}\n\nspec fn simulate_operations(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        seq![a[0]]\n    } else {\n        let shorter = a.subrange(0, (a.len() - 1) as int);\n        let prev = simulate_operations(shorter);\n        reverse_seq(prev.push(a[(a.len() - 1) as int]))\n    }\n}\n\nspec fn compute_result(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    let n = a.len();\n    let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);\n    let e = Seq::new(n / 2, |i: int| a[2*i + 1]);\n    if n % 2 == 0 {\n        reverse_seq(e).add(o)\n    } else {\n        reverse_seq(o).add(e)\n    }\n}\n\nspec fn reverse_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len() when s.len() > 0\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let rest = s.subrange(1, s.len() as int);\n        reverse_seq(rest).push(s[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result.len() == n as int,\n        result@.map(|i: int, x: i8| x as int) == compute_result(a@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n\n}\n\nspec fn simulate_operations(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        seq![a[0]]\n    } else {\n        let shorter = a.subrange(0, (a.len() - 1) as int);\n        let prev = simulate_operations(shorter);\n        reverse_seq(prev.push(a[(a.len() - 1) as int]))\n    }\n}\n\nspec fn compute_result(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    let n = a.len();\n    let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);\n    let e = Seq::new(n / 2, |i: int| a[2*i + 1]);\n    if n % 2 == 0 {\n        reverse_seq(e).add(o)\n    } else {\n        reverse_seq(o).add(e)\n    }\n}\n\nspec fn reverse_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len() when s.len() > 0\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let rest = s.subrange(1, s.len() as int);\n        reverse_seq(rest).push(s[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result.len() == n as int,\n        result@.map(|i: int, x: i8| x as int) == compute_result(a@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4502.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 834, "minimize_time_ms": 122885, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>) -> bool {\n\nspec fn simulate_operations(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n    decreases a.len() when a.len() > 0\n{\n\nspec fn compute_result(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n\nspec fn reverse_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len() when s.len() > 0\n{\n\n    decreases a.len() when a.len() > 0\n\n    decreases s.len() when s.len() > 0\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n\n}\n\nspec fn simulate_operations(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        seq![a[0]]\n    } else {\n        let shorter = a.subrange(0, (a.len() - 1) as int);\n        let prev = simulate_operations(shorter);\n        reverse_seq(prev.push(a[(a.len() - 1) as int]))\n    }\n}\n\nspec fn compute_result(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    let n = a.len();\n    let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);\n    let e = Seq::new(n / 2, |i: int| a[2*i + 1]);\n    if n % 2 == 0 {\n        reverse_seq(e).add(o)\n    } else {\n        reverse_seq(o).add(e)\n    }\n}\n\nspec fn reverse_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len() when s.len() > 0\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let rest = s.subrange(1, s.len() as int);\n        reverse_seq(rest).push(s[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result.len() == n as int,\n        result@.map(|i: int, x: i8| x as int) == compute_result(a@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4508_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 && edges.len() == n - 1 &&\n    forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1\n}\n\nspec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 ==> forall|v: int| 2 <= v <= n ==> shortest_path_distance(n, edges, 1, v) <= 2\n}\n\nspec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { 0 } else { compute_shortest_path(n, edges, start, end) }\n    } else {\n        -1\n    }\n}\n\nspec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        let adj = build_adjacency_list(n, edges);\n        bfs(adj, n, start, end)\n    } else {\n        -1\n    }\n}\n\nspec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {\n    if n >= 1 {\n        let adj = Seq::new((n + 1) as nat, |i: int| Seq::<int>::empty());\n        add_edges_to_adj_list(adj, edges)\n    } else {\n        Seq::<Seq<int>>::empty()\n    }\n}\n\nspec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>\n    decreases edges.len()\n{\n    if adj.len() >= 1 {\n        if edges.len() == 0 {\n            adj\n        } else {\n            let e = edges[0];\n            if 1 <= e.0 < adj.len() && 1 <= e.1 < adj.len() {\n                let new_adj = adj.update(e.0, adj[e.0].push(e.1)).update(e.1, adj[e.1].push(e.0));\n                add_edges_to_adj_list(new_adj, edges.subrange(1, edges.len() as int))\n            } else {\n                add_edges_to_adj_list(adj, edges.subrange(1, edges.len() as int))\n            }\n        }\n    } else {\n        adj\n    }\n}\n\nspec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {\n    if n >= 1 && adj.len() == n + 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { \n            0 \n        } else if adj[start].contains(end) { \n            1 \n        } else if distance_is_2(adj, start, end) { \n            2 \n        } else { \n            3 \n        }\n    } else {\n        -1\n    }\n}\n\nspec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {\n    if adj.len() > 0 && 0 <= start < adj.len() {\n        exists|neighbor: int| adj[start].contains(neighbor) && 0 <= neighbor < adj.len() && adj[neighbor].contains(end)\n    } else {\n        false\n    }\n}\n\nspec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {\n    valid_input(n, original_edges) ==> num_edges_to_add >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, edges: Vec<(i8, i8)>) -> (num_edges_to_add: i8)\n    requires n >= 2,\n             edges.len() == (n - 1) as nat,\n             forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1\n    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),\n            all_vertices_within_distance2(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> num_edges_to_add >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 && edges.len() == n - 1 &&\n    forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1\n}\n\nspec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 ==> forall|v: int| 2 <= v <= n ==> shortest_path_distance(n, edges, 1, v) <= 2\n}\n\nspec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { 0 } else { compute_shortest_path(n, edges, start, end) }\n    } else {\n        -1\n    }\n}\n\nspec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        let adj = build_adjacency_list(n, edges);\n        bfs(adj, n, start, end)\n    } else {\n        -1\n    }\n}\n\nspec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {\n    if n >= 1 {\n        let adj = Seq::new((n + 1) as nat, |i: int| Seq::<int>::empty());\n        add_edges_to_adj_list(adj, edges)\n    } else {\n        Seq::<Seq<int>>::empty()\n    }\n}\n\nspec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>\n    decreases edges.len()\n{\n    if adj.len() >= 1 {\n        if edges.len() == 0 {\n            adj\n        } else {\n            let e = edges[0];\n            if 1 <= e.0 < adj.len() && 1 <= e.1 < adj.len() {\n                let new_adj = adj.update(e.0, adj[e.0].push(e.1)).update(e.1, adj[e.1].push(e.0));\n                add_edges_to_adj_list(new_adj, edges.subrange(1, edges.len() as int))\n            } else {\n                add_edges_to_adj_list(adj, edges.subrange(1, edges.len() as int))\n            }\n        }\n    } else {\n        adj\n    }\n}\n\nspec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {\n    if n >= 1 && adj.len() == n + 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { \n            0 \n        } else if adj[start].contains(end) { \n            1 \n        } else if distance_is_2(adj, start, end) { \n            2 \n        } else { \n            3 \n        }\n    } else {\n        -1\n    }\n}\n\nspec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {\n    if adj.len() > 0 && 0 <= start < adj.len() {\n        exists|neighbor: int| adj[start].contains(neighbor) && 0 <= neighbor < adj.len() && adj[neighbor].contains(end)\n    } else {\n        false\n    }\n}\n\nspec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {\n    valid_input(n, original_edges) ==> num_edges_to_add >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, edges: Vec<(i8, i8)>) -> (num_edges_to_add: i8)\n    requires n >= 2,\n             edges.len() == (n - 1) as nat,\n             forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1\n    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),\n            all_vertices_within_distance2(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> num_edges_to_add >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4508.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 824, "minimize_time_ms": 152913, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 110, "minimized_LOC": 110, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {\n\nspec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {\n\nspec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n\nspec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n\nspec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {\n\nspec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>\n    decreases edges.len()\n{\n\nspec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {\n\nspec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {\n\nspec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {\n\n    decreases edges.len()\n\n    requires n >= 2,\n\n    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 && edges.len() == n - 1 &&\n    forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1\n}\n\nspec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 ==> forall|v: int| 2 <= v <= n ==> shortest_path_distance(n, edges, 1, v) <= 2\n}\n\nspec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { 0 } else { compute_shortest_path(n, edges, start, end) }\n    } else {\n        -1\n    }\n}\n\nspec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        let adj = build_adjacency_list(n, edges);\n        bfs(adj, n, start, end)\n    } else {\n        -1\n    }\n}\n\nspec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {\n    if n >= 1 {\n        let adj = Seq::new((n + 1) as nat, |i: int| Seq::<int>::empty());\n        add_edges_to_adj_list(adj, edges)\n    } else {\n        Seq::<Seq<int>>::empty()\n    }\n}\n\nspec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>\n    decreases edges.len()\n{\n    if adj.len() >= 1 {\n        if edges.len() == 0 {\n            adj\n        } else {\n            let e = edges[0];\n            if 1 <= e.0 < adj.len() && 1 <= e.1 < adj.len() {\n                let new_adj = adj.update(e.0, adj[e.0].push(e.1)).update(e.1, adj[e.1].push(e.0));\n                add_edges_to_adj_list(new_adj, edges.subrange(1, edges.len() as int))\n            } else {\n                add_edges_to_adj_list(adj, edges.subrange(1, edges.len() as int))\n            }\n        }\n    } else {\n        adj\n    }\n}\n\nspec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {\n    if n >= 1 && adj.len() == n + 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { \n            0 \n        } else if adj[start].contains(end) { \n            1 \n        } else if distance_is_2(adj, start, end) { \n            2 \n        } else { \n            3 \n        }\n    } else {\n        -1\n    }\n}\n\nspec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {\n    if adj.len() > 0 && 0 <= start < adj.len() {\n        exists|neighbor: int| adj[start].contains(neighbor) && 0 <= neighbor < adj.len() && adj[neighbor].contains(end)\n    } else {\n        false\n    }\n}\n\nspec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {\n    valid_input(n, original_edges) ==> num_edges_to_add >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, edges: Vec<(i8, i8)>) -> (num_edges_to_add: i8)\n    requires n >= 2,\n             edges.len() == (n - 1) as nat,\n             forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1\n    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),\n            all_vertices_within_distance2(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> num_edges_to_add >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4551_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_parseable(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4\n}\n\nspec fn all_parts_are_integers(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] <= '9') || (i == 0 && s[i] == '-'))\n}\n\nspec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 && \n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3]) &&\n    string_to_int_pure(parts[0]) == a &&\n    string_to_int_pure(parts[1]) == b &&\n    string_to_int_pure(parts[2]) == c &&\n    string_to_int_pure(parts[3]) == d\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    split_string_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i < 0 || i > s.len() {\n        acc\n    } else if i == s.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\t' {\n        if current.len() > 0 {\n            split_string_helper(s, i + 1, seq![], acc.push(current))\n        } else {\n            split_string_helper(s, i + 1, seq![], acc)\n        }\n    } else {\n        split_string_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if !is_valid_integer(s) {\n        0\n    } else if s.len() > 0 && s[0] == '-' {\n        -string_to_int_helper_unsigned(s, 1, 0)\n    } else {\n        string_to_int_helper_unsigned(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i\n{\n    if i < 0 || i >= s.len() {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        string_to_int_helper_unsigned(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    ensures \n        (forall|a: int, b: int, c: int, d: int| \n            valid_parse(input@, a, b, c, d) ==> \n            ((result@ == \"Left\\n\"@) <==> (a + b > c + d)) &&\n            ((result@ == \"Right\\n\"@) <==> (a + b < c + d)) &&\n            ((result@ == \"Balanced\\n\"@) <==> (a + b == c + d))) &&\n        (valid_parseable(input@) && all_parts_are_integers(input@) ==> \n            (result@ == \"Left\\n\"@ || result@ == \"Right\\n\"@ || result@ == \"Balanced\\n\"@)) &&\n        ((!valid_parseable(input@) || !all_parts_are_integers(input@)) ==> result@ == \"\"@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_parseable(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4\n}\n\nspec fn all_parts_are_integers(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] <= '9') || (i == 0 && s[i] == '-'))\n}\n\nspec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 && \n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3]) &&\n    string_to_int_pure(parts[0]) == a &&\n    string_to_int_pure(parts[1]) == b &&\n    string_to_int_pure(parts[2]) == c &&\n    string_to_int_pure(parts[3]) == d\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    split_string_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i < 0 || i > s.len() {\n        acc\n    } else if i == s.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\t' {\n        if current.len() > 0 {\n            split_string_helper(s, i + 1, seq![], acc.push(current))\n        } else {\n            split_string_helper(s, i + 1, seq![], acc)\n        }\n    } else {\n        split_string_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if !is_valid_integer(s) {\n        0\n    } else if s.len() > 0 && s[0] == '-' {\n        -string_to_int_helper_unsigned(s, 1, 0)\n    } else {\n        string_to_int_helper_unsigned(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i\n{\n    if i < 0 || i >= s.len() {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        string_to_int_helper_unsigned(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    ensures \n        (forall|a: int, b: int, c: int, d: int| \n            valid_parse(input@, a, b, c, d) ==> \n            ((result@ == \"Left\\n\"@) <==> (a + b > c + d)) &&\n            ((result@ == \"Right\\n\"@) <==> (a + b < c + d)) &&\n            ((result@ == \"Balanced\\n\"@) <==> (a + b == c + d))) &&\n        (valid_parseable(input@) && all_parts_are_integers(input@) ==> \n            (result@ == \"Left\\n\"@ || result@ == \"Right\\n\"@ || result@ == \"Balanced\\n\"@)) &&\n        ((!valid_parseable(input@) || !all_parts_are_integers(input@)) ==> result@ == \"\"@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4551.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 971, "minimize_time_ms": 153086, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 109, "minimized_LOC": 109, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_parseable(input: Seq<char>) -> bool {\n\nspec fn all_parts_are_integers(input: Seq<char>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n\nspec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i\n{\n\n    decreases s.len()\n\n    decreases s.len() - i\n\n    decreases s.len() - i\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_parseable(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4\n}\n\nspec fn all_parts_are_integers(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] <= '9') || (i == 0 && s[i] == '-'))\n}\n\nspec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 && \n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3]) &&\n    string_to_int_pure(parts[0]) == a &&\n    string_to_int_pure(parts[1]) == b &&\n    string_to_int_pure(parts[2]) == c &&\n    string_to_int_pure(parts[3]) == d\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    split_string_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i < 0 || i > s.len() {\n        acc\n    } else if i == s.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\t' {\n        if current.len() > 0 {\n            split_string_helper(s, i + 1, seq![], acc.push(current))\n        } else {\n            split_string_helper(s, i + 1, seq![], acc)\n        }\n    } else {\n        split_string_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if !is_valid_integer(s) {\n        0\n    } else if s.len() > 0 && s[0] == '-' {\n        -string_to_int_helper_unsigned(s, 1, 0)\n    } else {\n        string_to_int_helper_unsigned(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i\n{\n    if i < 0 || i >= s.len() {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        string_to_int_helper_unsigned(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    ensures \n        (forall|a: int, b: int, c: int, d: int| \n            valid_parse(input@, a, b, c, d) ==> \n            ((result@ == \"Left\\n\"@) <==> (a + b > c + d)) &&\n            ((result@ == \"Right\\n\"@) <==> (a + b < c + d)) &&\n            ((result@ == \"Balanced\\n\"@) <==> (a + b == c + d))) &&\n        (valid_parseable(input@) && all_parts_are_integers(input@) ==> \n            (result@ == \"Left\\n\"@ || result@ == \"Right\\n\"@ || result@ == \"Balanced\\n\"@)) &&\n        ((!valid_parseable(input@) || !all_parts_are_integers(input@)) ==> result@ == \"\"@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4554_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(w: int, a: int, b: int) -> bool {\n    w >= 1 && a >= 1 && b >= 1\n}\n\nspec fn abs_diff(x: int, y: int) -> int {\n    if x >= y { x - y } else { y - x }\n}\n\nspec fn min_move_distance(w: int, a: int, b: int) -> int\n    recommends valid_input(w, a, b)\n{\n    let distance = abs_diff(a, b);\n    if distance <= w { 0 }\n    else { distance - w }\n}\n\nspec fn rectangles_connect(w: int, a: int, b: int) -> bool\n    recommends valid_input(w, a, b)\n{\n    abs_diff(a, b) <= w\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(w: i8, a: i8, b: i8) -> (result: i8)\n    requires valid_input(w as int, a as int, b as int)\n    ensures \n        result as int == min_move_distance(w as int, a as int, b as int) &&\n        result >= 0 &&\n        (rectangles_connect(w as int, a as int, b as int) <==> result == 0)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(w: int, a: int, b: int) -> bool {\n    w >= 1 && a >= 1 && b >= 1\n}\n\nspec fn abs_diff(x: int, y: int) -> int {\n    if x >= y { x - y } else { y - x }\n}\n\nspec fn min_move_distance(w: int, a: int, b: int) -> int\n    recommends valid_input(w, a, b)\n{\n    let distance = abs_diff(a, b);\n    if distance <= w { 0 }\n    else { distance - w }\n}\n\nspec fn rectangles_connect(w: int, a: int, b: int) -> bool\n    recommends valid_input(w, a, b)\n{\n    abs_diff(a, b) <= w\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(w: i8, a: i8, b: i8) -> (result: i8)\n    requires valid_input(w as int, a as int, b as int)\n    ensures \n        result as int == min_move_distance(w as int, a as int, b as int) &&\n        result >= 0 &&\n        (rectangles_connect(w as int, a as int, b as int) <==> result == 0)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4554.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 733, "minimize_time_ms": 125187, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(w: int, a: int, b: int) -> bool {\n\nspec fn abs_diff(x: int, y: int) -> int {\n\nspec fn min_move_distance(w: int, a: int, b: int) -> int\n    recommends valid_input(w, a, b)\n{\n\nspec fn rectangles_connect(w: int, a: int, b: int) -> bool\n    recommends valid_input(w, a, b)\n{\n\n    requires valid_input(w as int, a as int, b as int)\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(w: int, a: int, b: int) -> bool {\n    w >= 1 && a >= 1 && b >= 1\n}\n\nspec fn abs_diff(x: int, y: int) -> int {\n    if x >= y { x - y } else { y - x }\n}\n\nspec fn min_move_distance(w: int, a: int, b: int) -> int\n    recommends valid_input(w, a, b)\n{\n    let distance = abs_diff(a, b);\n    if distance <= w { 0 }\n    else { distance - w }\n}\n\nspec fn rectangles_connect(w: int, a: int, b: int) -> bool\n    recommends valid_input(w, a, b)\n{\n    abs_diff(a, b) <= w\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(w: i8, a: i8, b: i8) -> (result: i8)\n    requires valid_input(w as int, a as int, b as int)\n    ensures \n        result as int == min_move_distance(w as int, a as int, b as int) &&\n        result >= 0 &&\n        (rectangles_connect(w as int, a as int, b as int) <==> result == 0)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4556_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& input.len() >= 18\n    &&& input[input.len() as int - 1] == '\\n'\n    &&& input.subrange(0, 7) == seq!['A', 't', 'C', 'o', 'd', 'e', 'r']\n    &&& input[7] == ' '\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        input.subrange(space_pos + 1, space_pos + 8) == seq!['C', 'o', 'n', 't', 'e', 's', 't'] &&\n        space_pos + 8 == input.len() - 1\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        space_pos > 8 &&\n        'A' <= input[8] <= 'Z' &&\n        forall|k: int| 9 <= k < space_pos ==> 'a' <= #[trigger] input.index(k) <= 'z'\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& result.len() == 4\n    &&& result[0] == 'A'\n    &&& result[2] == 'C'\n    &&& result[3] == '\\n'\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        result[1] == input[8]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& input.len() >= 18\n    &&& input[input.len() as int - 1] == '\\n'\n    &&& input.subrange(0, 7) == seq!['A', 't', 'C', 'o', 'd', 'e', 'r']\n    &&& input[7] == ' '\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        input.subrange(space_pos + 1, space_pos + 8) == seq!['C', 'o', 'n', 't', 'e', 's', 't'] &&\n        space_pos + 8 == input.len() - 1\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        space_pos > 8 &&\n        'A' <= input[8] <= 'Z' &&\n        forall|k: int| 9 <= k < space_pos ==> 'a' <= #[trigger] input.index(k) <= 'z'\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& result.len() == 4\n    &&& result[0] == 'A'\n    &&& result[2] == 'C'\n    &&& result[3] == '\\n'\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        result[1] == input[8]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4556.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 784, "minimize_time_ms": 214945, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool \n    decreases input.len()\n{\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool \n    decreases input.len()\n{\n\n    decreases input.len()\n\n    decreases input.len()\n\n    requires valid_input(input@)\n\n    ensures valid_output(input@, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& input.len() >= 18\n    &&& input[input.len() as int - 1] == '\\n'\n    &&& input.subrange(0, 7) == seq!['A', 't', 'C', 'o', 'd', 'e', 'r']\n    &&& input[7] == ' '\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        input.subrange(space_pos + 1, space_pos + 8) == seq!['C', 'o', 'n', 't', 'e', 's', 't'] &&\n        space_pos + 8 == input.len() - 1\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        space_pos > 8 &&\n        'A' <= input[8] <= 'Z' &&\n        forall|k: int| 9 <= k < space_pos ==> 'a' <= #[trigger] input.index(k) <= 'z'\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& result.len() == 4\n    &&& result[0] == 'A'\n    &&& result[2] == 'C'\n    &&& result[3] == '\\n'\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        result[1] == input[8]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n          fn main() {\n}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4567_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(scores: Seq<int>) -> bool {\n    scores.len() > 0 && scores.len() <= 100 &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 1 && #[trigger] scores[i] <= 100\n}\n\nspec fn sum_seq(scores: Seq<int>) -> int\n    decreases scores.len()\n{\n    if scores.len() == 0 {\n        0\n    } else {\n        scores[0] + sum_seq(scores.subrange(1, scores.len() as int))\n    }\n}\n\nspec fn all_multiples_of_10(scores: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] % 10 == 0\n}\n\nspec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {\n    scores.contains(value) && \n    value % 10 != 0 &&\n    forall|x: int| #[trigger] scores.contains(x) && x % 10 != 0 ==> value <= x\n}\n\nspec fn correct_result(scores: Seq<int>, result: int) -> bool {\n    let total_sum = sum_seq(scores);\n    if total_sum % 10 != 0 {\n        result == total_sum\n    } else if all_multiples_of_10(scores) {\n        result == 0\n    } else {\n        exists|smallest_non_multiple: int| \n            is_smallest_non_multiple(scores, smallest_non_multiple) &&\n            result == total_sum - smallest_non_multiple\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(scores: Vec<i8>) -> (result: i8)\n    requires valid_input(scores@.map(|i, x| x as int))\n    ensures correct_result(scores@.map(|i, x| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(scores: Seq<int>) -> bool {\n    scores.len() > 0 && scores.len() <= 100 &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 1 && #[trigger] scores[i] <= 100\n}\n\nspec fn sum_seq(scores: Seq<int>) -> int\n    decreases scores.len()\n{\n    if scores.len() == 0 {\n        0\n    } else {\n        scores[0] + sum_seq(scores.subrange(1, scores.len() as int))\n    }\n}\n\nspec fn all_multiples_of_10(scores: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] % 10 == 0\n}\n\nspec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {\n    scores.contains(value) && \n    value % 10 != 0 &&\n    forall|x: int| #[trigger] scores.contains(x) && x % 10 != 0 ==> value <= x\n}\n\nspec fn correct_result(scores: Seq<int>, result: int) -> bool {\n    let total_sum = sum_seq(scores);\n    if total_sum % 10 != 0 {\n        result == total_sum\n    } else if all_multiples_of_10(scores) {\n        result == 0\n    } else {\n        exists|smallest_non_multiple: int| \n            is_smallest_non_multiple(scores, smallest_non_multiple) &&\n            result == total_sum - smallest_non_multiple\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(scores: Vec<i8>) -> (result: i8)\n    requires valid_input(scores@.map(|i, x| x as int))\n    ensures correct_result(scores@.map(|i, x| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4567.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1150, "minimize_time_ms": 219003, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(scores: Seq<int>) -> bool {\n\nspec fn sum_seq(scores: Seq<int>) -> int\n    decreases scores.len()\n{\n\nspec fn all_multiples_of_10(scores: Seq<int>) -> bool {\n\nspec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {\n\nspec fn correct_result(scores: Seq<int>, result: int) -> bool {\n\n    decreases scores.len()\n\n    requires valid_input(scores@.map(|i, x| x as int))\n\n    ensures correct_result(scores@.map(|i, x| x as int), result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(scores: Seq<int>) -> bool {\n    scores.len() > 0 && scores.len() <= 100 &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 1 && #[trigger] scores[i] <= 100\n}\n\nspec fn sum_seq(scores: Seq<int>) -> int\n    decreases scores.len()\n{\n    if scores.len() == 0 {\n        0\n    } else {\n        scores[0] + sum_seq(scores.subrange(1, scores.len() as int))\n    }\n}\n\nspec fn all_multiples_of_10(scores: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] % 10 == 0\n}\n\nspec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {\n    scores.contains(value) && \n    value % 10 != 0 &&\n    forall|x: int| #[trigger] scores.contains(x) && x % 10 != 0 ==> value <= x\n}\n\nspec fn correct_result(scores: Seq<int>, result: int) -> bool {\n    let total_sum = sum_seq(scores);\n    if total_sum % 10 != 0 {\n        result == total_sum\n    } else if all_multiples_of_10(scores) {\n        result == 0\n    } else {\n        exists|smallest_non_multiple: int| \n            is_smallest_non_multiple(scores, smallest_non_multiple) &&\n            result == total_sum - smallest_non_multiple\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(scores: Vec<i8>) -> (result: i8)\n    requires valid_input(scores@.map(|i, x| x as int))\n    ensures correct_result(scores@.map(|i, x| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4569_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_weather(weather: Seq<char>) -> bool {\n    weather == \"Sunny\"@ || weather == \"Cloudy\"@ || weather == \"Rainy\"@\n}\n\nspec fn trim_newline(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        input.subrange(0, input.len() as int - 1)\n    } else {\n        input\n    }\n}\n\nspec fn next_weather(weather: Seq<char>) -> Seq<char>\n    recommends valid_weather(weather)\n{\n    if weather == \"Sunny\"@ { \"Cloudy\"@ }\n    else if weather == \"Cloudy\"@ { \"Rainy\"@ }\n    else { \"Sunny\"@ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    ensures ({\n        let trimmed = trim_newline(input@);\n        if valid_weather(trimmed) {\n            result@ == next_weather(trimmed) + seq!['\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_weather(weather: Seq<char>) -> bool {\n    weather == \"Sunny\"@ || weather == \"Cloudy\"@ || weather == \"Rainy\"@\n}\n\nspec fn trim_newline(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        input.subrange(0, input.len() as int - 1)\n    } else {\n        input\n    }\n}\n\nspec fn next_weather(weather: Seq<char>) -> Seq<char>\n    recommends valid_weather(weather)\n{\n    if weather == \"Sunny\"@ { \"Cloudy\"@ }\n    else if weather == \"Cloudy\"@ { \"Rainy\"@ }\n    else { \"Sunny\"@ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    ensures ({\n        let trimmed = trim_newline(input@);\n        if valid_weather(trimmed) {\n            result@ == next_weather(trimmed) + seq!['\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4569.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 2617, "minimize_time_ms": 188268, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 7, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_weather(weather: Seq<char>) -> bool {\n\nspec fn trim_newline(input: Seq<char>) -> Seq<char> {\n\nspec fn next_weather(weather: Seq<char>) -> Seq<char>\n    recommends valid_weather(weather)\n{\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_weather(weather: Seq<char>) -> bool {\n    weather == \"Sunny\"@ || weather == \"Cloudy\"@ || weather == \"Rainy\"@\n}\n\nspec fn trim_newline(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        input.subrange(0, input.len() as int - 1)\n    } else {\n        input\n    }\n}\n\nspec fn next_weather(weather: Seq<char>) -> Seq<char>\n    recommends valid_weather(weather)\n{\n    if weather == \"Sunny\"@ { \"Cloudy\"@ }\n    else if weather == \"Cloudy\"@ { \"Rainy\"@ }\n    else { \"Sunny\"@ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    ensures ({\n        let trimmed = trim_newline(input@);\n        if valid_weather(trimmed) {\n            result@ == next_weather(trimmed) + seq!['\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4570_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true /* Simplified for now */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2'], seq!['3']] /* Simplified for now */\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    if s.len() > 0 && s[0] == '1' { 1 }\n    else if s.len() > 0 && s[0] == '2' { 2 }\n    else if s.len() > 0 && s[0] == '3' { 3 }\n    else { 0 }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else { seq!['0'] }\n}\n\nspec fn min_parking_cost(n: int, a: int, b: int) -> int {\n    let plan1_cost = n * a;\n    let plan2_cost = b;\n    if plan1_cost <= plan2_cost { plan1_cost } else { plan2_cost }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        ({\n            let parts = split_string_func(input);\n            let n = string_to_int_func(parts[0]);\n            let a = string_to_int_func(parts[1]);\n            let b = string_to_int_func(parts[2]);\n            result == int_to_string_func(min_parking_cost(n, a, b)) + seq!['\\n']\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true /* Simplified for now */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2'], seq!['3']] /* Simplified for now */\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    if s.len() > 0 && s[0] == '1' { 1 }\n    else if s.len() > 0 && s[0] == '2' { 2 }\n    else if s.len() > 0 && s[0] == '3' { 3 }\n    else { 0 }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else { seq!['0'] }\n}\n\nspec fn min_parking_cost(n: int, a: int, b: int) -> int {\n    let plan1_cost = n * a;\n    let plan2_cost = b;\n    if plan1_cost <= plan2_cost { plan1_cost } else { plan2_cost }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        ({\n            let parts = split_string_func(input);\n            let n = string_to_int_func(parts[0]);\n            let a = string_to_int_func(parts[1]);\n            let b = string_to_int_func(parts[2]);\n            result == int_to_string_func(min_parking_cost(n, a, b)) + seq!['\\n']\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4570.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 648, "minimize_time_ms": 215721, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n\nspec fn min_parking_cost(n: int, a: int, b: int) -> int {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true /* Simplified for now */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2'], seq!['3']] /* Simplified for now */\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    if s.len() > 0 && s[0] == '1' { 1 }\n    else if s.len() > 0 && s[0] == '2' { 2 }\n    else if s.len() > 0 && s[0] == '3' { 3 }\n    else { 0 }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else { seq!['0'] }\n}\n\nspec fn min_parking_cost(n: int, a: int, b: int) -> int {\n    let plan1_cost = n * a;\n    let plan2_cost = b;\n    if plan1_cost <= plan2_cost { plan1_cost } else { plan2_cost }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        ({\n            let parts = split_string_func(input);\n            let n = string_to_int_func(parts[0]);\n            let a = string_to_int_func(parts[1]);\n            let b = string_to_int_func(parts[2]);\n            result == int_to_string_func(min_parking_cost(n, a, b)) + seq!['\\n']\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4575_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_str(input, '\\n');\n    lines.len() >= 2 &&\n    parse_int(lines[0]) >= 1 &&\n    {\n        let n = parse_int(lines[0]);\n        let second_line_parts = split_str(lines[1], ' ');\n        second_line_parts.len() >= 2 &&\n        parse_int(second_line_parts[0]) >= 1 &&\n        parse_int(second_line_parts[1]) >= 0 &&\n        lines.len() >= 2 + n &&\n        forall|i: int| 0 <= i < n ==> #[trigger] parse_int(lines[2 + i]) >= 1\n    }\n}\n\nspec fn compute_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_str(input, '\\n');\n    let n = parse_int(lines[0]);\n    let second_line_parts = split_str(lines[1], ' ');\n    let d = parse_int(second_line_parts[0]);\n    let x = parse_int(second_line_parts[1]);\n    let total_eaten = sum_eaten_for_participants(lines, d, n);\n    int_to_string(x + total_eaten)\n}\n\nspec fn sum_eaten_for_participants(lines: Seq<Seq<char>>, d: int, count: int) -> int \n    recommends lines.len() >= 2 + count && d >= 1 && count >= 0\n    decreases count\n    when count >= 0\n{\n    if count == 0 {\n        0\n    } else {\n        let a = parse_int(lines[2 + count - 1]);\n        let eaten = if a > 0 { (d + a - 1) / a } else { 0 };\n        eaten + sum_eaten_for_participants(lines, d, count - 1)\n    }\n}\n\nspec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_helper(s, delimiter, 0, 0, seq![])\n    }\n}\n\nspec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= start <= current <= s.len()\n    decreases s.len() - current\n    when 0 <= current <= s.len()\n{\n    if current == s.len() {\n        if start == current {\n            acc\n        } else {\n            acc.push(s.subrange(start, current))\n        }\n    } else if s[current] == delimiter {\n        split_helper(s, delimiter, current + 1, current + 1, acc.push(s.subrange(start, current)))\n    } else {\n        split_helper(s, delimiter, start, current + 1, acc)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    recommends 0 <= index <= s.len()\n    decreases s.len() - index\n    when 0 <= index <= s.len()\n{\n    if index == s.len() {\n        acc\n    } else if '0' <= s[index] <= '9' {\n        parse_int_helper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n < 10 {\n        seq![(n + '0' as int) as char]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@ == compute_expected_result(input@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool ;\n       spec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>     recommends 0 <= start <= current <= s.len()     decreases s.len() - current     when 0 <= current <= s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int ;\n       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n       spec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4575.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1248, "minimize_time_ms": 310101, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 142, "minimized_LOC": 12, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.08450704225352113}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool ;\n       spec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>     recommends 0 <= start <= current <= s.len()     decreases s.len() - current     when 0 <= current <= s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int ;\n       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n       spec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n\nspec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>     recommends 0 <= start <= current <= s.len()     decreases s.len() - current     when 0 <= current <= s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int ;\n       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n       spec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n\nspec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>     recommends 0 <= start <= current <= s.len()     decreases s.len() - current     when 0 <= current <= s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int ;\n       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n       spec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n\nspec fn parse_int(s: Seq<char>) -> int ;\n       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n       spec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n\nspec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n       spec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n\nspec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n\nspec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n\n       spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>     recommends 0 <= start <= current <= s.len()     decreases s.len() - current     when 0 <= current <= s.len() ;\n\n       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_str(input, '\\n');\n    lines.len() >= 2 &&\n    parse_int(lines[0]) >= 1 &&\n    {\n        let n = parse_int(lines[0]);\n        let second_line_parts = split_str(lines[1], ' ');\n        second_line_parts.len() >= 2 &&\n        parse_int(second_line_parts[0]) >= 1 &&\n        parse_int(second_line_parts[1]) >= 0 &&\n        lines.len() >= 2 + n &&\n        forall|i: int| 0 <= i < n ==> #[trigger] parse_int(lines[2 + i]) >= 1\n    }\n}\n\nspec fn compute_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_str(input, '\\n');\n    let n = parse_int(lines[0]);\n    let second_line_parts = split_str(lines[1], ' ');\n    let d = parse_int(second_line_parts[0]);\n    let x = parse_int(second_line_parts[1]);\n    let total_eaten = sum_eaten_for_participants(lines, d, n);\n    int_to_string(x + total_eaten)\n}\n\nspec fn sum_eaten_for_participants(lines: Seq<Seq<char>>, d: int, count: int) -> int \n    recommends lines.len() >= 2 + count && d >= 1 && count >= 0\n    decreases count\n    when count >= 0\n{\n    if count == 0 {\n        0\n    } else {\n        let a = parse_int(lines[2 + count - 1]);\n        let eaten = if a > 0 { (d + a - 1) / a } else { 0 };\n        eaten + sum_eaten_for_participants(lines, d, count - 1)\n    }\n}\n\nspec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_helper(s, delimiter, 0, 0, seq![])\n    }\n}\n\nspec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= start <= current <= s.len()\n    decreases s.len() - current\n    when 0 <= current <= s.len()\n{\n    if current == s.len() {\n        if start == current {\n            acc\n        } else {\n            acc.push(s.subrange(start, current))\n        }\n    } else if s[current] == delimiter {\n        split_helper(s, delimiter, current + 1, current + 1, acc.push(s.subrange(start, current)))\n    } else {\n        split_helper(s, delimiter, start, current + 1, acc)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    recommends 0 <= index <= s.len()\n    decreases s.len() - index\n    when 0 <= index <= s.len()\n{\n    if index == s.len() {\n        acc\n    } else if '0' <= s[index] <= '9' {\n        parse_int_helper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n < 10 {\n        seq![(n + '0' as int) as char]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@ == compute_expected_result(input@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool ;\n       spec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>     recommends 0 <= start <= current <= s.len()     decreases s.len() - current     when 0 <= current <= s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int ;\n       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n       spec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4581_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'o' || s[i] == 'x'\n}\n\nspec fn count_o(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == 'o' { 1int } else { 0int }) + count_o(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn calculate_price(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    count_o(s) * 100int + 700int\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        int_to_string_helper_spec(n, seq![])\n    }\n}\n\nspec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n\n    when n >= 0\n{\n    if n == 0 {\n        acc\n    } else {\n        int_to_string_helper_spec(n / 10, seq![((n % 10) + 48) as char] + acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@)\n    ensures \n        result@ == int_to_string_spec(calculate_price(s@)) + seq!['\\n'],\n        calculate_price(s@) >= 700\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'o' || s[i] == 'x'\n}\n\nspec fn count_o(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == 'o' { 1int } else { 0int }) + count_o(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn calculate_price(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    count_o(s) * 100int + 700int\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        int_to_string_helper_spec(n, seq![])\n    }\n}\n\nspec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n\n    when n >= 0\n{\n    if n == 0 {\n        acc\n    } else {\n        int_to_string_helper_spec(n / 10, seq![((n % 10) + 48) as char] + acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@)\n    ensures \n        result@ == int_to_string_spec(calculate_price(s@)) + seq!['\\n'],\n        calculate_price(s@) >= 700\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4581.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1643, "minimize_time_ms": 184683, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn count_o(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn calculate_price(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n\nspec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n\n    when n >= 0\n{\n\n    decreases s.len()\n\n    decreases n\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'o' || s[i] == 'x'\n}\n\nspec fn count_o(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == 'o' { 1int } else { 0int }) + count_o(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn calculate_price(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    count_o(s) * 100int + 700int\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        int_to_string_helper_spec(n, seq![])\n    }\n}\n\nspec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n\n    when n >= 0\n{\n    if n == 0 {\n        acc\n    } else {\n        int_to_string_helper_spec(n / 10, seq![((n % 10) + 48) as char] + acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@)\n    ensures \n        result@ == int_to_string_spec(calculate_price(s@)) + seq!['\\n'],\n        calculate_price(s@) >= 700\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4583_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() == 5 && input.subrange(0, 4).len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> ('0' <= #[trigger] input[i] <= '9')) &&\n    input[4] == '\\n'\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as int) - ('0' as int)\n}\n\nspec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {\n    let b_val = if op1 == '+' { b } else { -b };\n    let c_val = if op2 == '+' { c } else { -c };\n    let d_val = if op3 == '+' { d } else { -d };\n    a + b_val + c_val + d_val\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        exists|op1: char, op2: char, op3: char| \n            (op1 == '+' || op1 == '-') &&\n            (op2 == '+' || op2 == '-') &&\n            (op3 == '+' || op3 == '-') &&\n            evaluate_expression(a, b, c, d, op1, op2, op3) == 7\n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& result.len() == 10 \n    &&& result.subrange(7, 9) =~= seq!['=', '7']\n    &&& result[9] == '\\n'\n    &&& result[0] == input[0] && result[2] == input[1] \n    &&& result[4] == input[2] && result[6] == input[3]\n    &&& (result[1] == '+' || result[1] == '-')\n    &&& (result[3] == '+' || result[3] == '-')\n    &&& (result[5] == '+' || result[5] == '-')\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        evaluate_expression(a, b, c, d, result[1], result[3], result[5]) == 7\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@),\n        solution_exists(input@),\n    ensures valid_output(result@, input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() == 5 && input.subrange(0, 4).len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> ('0' <= #[trigger] input[i] <= '9')) &&\n    input[4] == '\\n'\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as int) - ('0' as int)\n}\n\nspec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {\n    let b_val = if op1 == '+' { b } else { -b };\n    let c_val = if op2 == '+' { c } else { -c };\n    let d_val = if op3 == '+' { d } else { -d };\n    a + b_val + c_val + d_val\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        exists|op1: char, op2: char, op3: char| \n            (op1 == '+' || op1 == '-') &&\n            (op2 == '+' || op2 == '-') &&\n            (op3 == '+' || op3 == '-') &&\n            evaluate_expression(a, b, c, d, op1, op2, op3) == 7\n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& result.len() == 10 \n    &&& result.subrange(7, 9) =~= seq!['=', '7']\n    &&& result[9] == '\\n'\n    &&& result[0] == input[0] && result[2] == input[1] \n    &&& result[4] == input[2] && result[6] == input[3]\n    &&& (result[1] == '+' || result[1] == '-')\n    &&& (result[3] == '+' || result[3] == '-')\n    &&& (result[5] == '+' || result[5] == '-')\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        evaluate_expression(a, b, c, d, result[1], result[3], result[5]) == 7\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@),\n        solution_exists(input@),\n    ensures valid_output(result@, input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4583.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 875, "minimize_time_ms": 153964, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 77, "minimized_LOC": 77, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn char_to_digit(c: char) -> int {\n\nspec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {\n\n    requires \n\n    ensures valid_output(result@, input@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() == 5 && input.subrange(0, 4).len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> ('0' <= #[trigger] input[i] <= '9')) &&\n    input[4] == '\\n'\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as int) - ('0' as int)\n}\n\nspec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {\n    let b_val = if op1 == '+' { b } else { -b };\n    let c_val = if op2 == '+' { c } else { -c };\n    let d_val = if op3 == '+' { d } else { -d };\n    a + b_val + c_val + d_val\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        exists|op1: char, op2: char, op3: char| \n            (op1 == '+' || op1 == '-') &&\n            (op2 == '+' || op2 == '-') &&\n            (op3 == '+' || op3 == '-') &&\n            evaluate_expression(a, b, c, d, op1, op2, op3) == 7\n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& result.len() == 10 \n    &&& result.subrange(7, 9) =~= seq!['=', '7']\n    &&& result[9] == '\\n'\n    &&& result[0] == input[0] && result[2] == input[1] \n    &&& result[4] == input[2] && result[6] == input[3]\n    &&& (result[1] == '+' || result[1] == '-')\n    &&& (result[3] == '+' || result[3] == '-')\n    &&& (result[5] == '+' || result[5] == '-')\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        evaluate_expression(a, b, c, d, result[1], result[3], result[5]) == 7\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@),\n        solution_exists(input@),\n    ensures valid_output(result@, input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n               fn main() {\n     }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4614_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn contains_three_space_separated_integers(input: Seq<char>) -> bool {\n    exists|i: int, j: int, k: int| (0 <= i < j < k <= input.len() &&\n    is_valid_integer_substring(input, 0, i) &&\n    input[i] == ' ' &&\n    is_valid_integer_substring(input, i+1, j) &&\n    input[j] == ' ' &&\n    is_valid_integer_substring(input, j+1, k) &&\n    (k == input.len() || input[k] == '\\n'))\n}\n\nspec fn exactly_two_are_equal(input: Seq<char>) -> bool {\n    let nums = parse_three_numbers(input);\n    (nums.0 == nums.1 && nums.0 != nums.2) ||\n    (nums.0 == nums.2 && nums.0 != nums.1) ||\n    (nums.1 == nums.2 && nums.1 != nums.0)\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    if s.len() == 0 { false }\n    else if s.len() == 1 && s[0] == '0' { true }\n    else if s.len() > 0 && s[0] == '-' { \n        s.len() > 1 && is_digit_sequence(s.subrange(1, s.len() as int)) && s[1] != '0'\n    }\n    else { is_digit_sequence(s) && s[0] != '0' }\n}\n\nspec fn is_digit_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool {\n    if start == end { false }\n    else {\n        let substr = s.subrange(start, end);\n        is_valid_integer_string(substr)\n    }\n}\n\nspec fn find_different_number(input: Seq<char>) -> Seq<char> {\n    let nums = parse_three_numbers(input);\n    let different = if nums.0 == nums.1 { nums.2 }\n                    else if nums.0 == nums.2 { nums.1 }\n                    else { nums.0 };\n    int_to_string_pure(different)\n}\nspec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) {\n    (0, 0, 0) /* placeholder for parsing logic */\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char> {\n    Seq::<char>::new(1 as nat, |i: int| '0') /* placeholder for conversion logic */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        input@.len() > 0,\n        contains_three_space_separated_integers(input@),\n        exactly_two_are_equal(input@),\n    ensures\n        result@.len() > 0,\n        is_valid_integer_string(result@),\n        result@ == find_different_number(input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn is_digit_sequence(s: Seq<char>) -> bool ;\n       spec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool ;\n       spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) ;\n       spec fn int_to_string_pure(n: int) -> Seq<char> ;\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4614.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 836, "minimize_time_ms": 185217, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 84, "minimized_LOC": 10, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 6, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.11904761904761904}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn is_digit_sequence(s: Seq<char>) -> bool ;\n       spec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool ;\n       spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) ;\n       spec fn int_to_string_pure(n: int) -> Seq<char> ;\n       }\n        fn main() {\n\nspec fn is_digit_sequence(s: Seq<char>) -> bool ;\n       spec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool ;\n       spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) ;\n       spec fn int_to_string_pure(n: int) -> Seq<char> ;\n       }\n        fn main() {\n\nspec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool ;\n       spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) ;\n       spec fn int_to_string_pure(n: int) -> Seq<char> ;\n       }\n        fn main() {\n\nspec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) ;\n       spec fn int_to_string_pure(n: int) -> Seq<char> ;\n       }\n        fn main() {\n\nspec fn int_to_string_pure(n: int) -> Seq<char> ;\n       }\n        fn main() {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn contains_three_space_separated_integers(input: Seq<char>) -> bool {\n    exists|i: int, j: int, k: int| (0 <= i < j < k <= input.len() &&\n    is_valid_integer_substring(input, 0, i) &&\n    input[i] == ' ' &&\n    is_valid_integer_substring(input, i+1, j) &&\n    input[j] == ' ' &&\n    is_valid_integer_substring(input, j+1, k) &&\n    (k == input.len() || input[k] == '\\n'))\n}\n\nspec fn exactly_two_are_equal(input: Seq<char>) -> bool {\n    let nums = parse_three_numbers(input);\n    (nums.0 == nums.1 && nums.0 != nums.2) ||\n    (nums.0 == nums.2 && nums.0 != nums.1) ||\n    (nums.1 == nums.2 && nums.1 != nums.0)\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    if s.len() == 0 { false }\n    else if s.len() == 1 && s[0] == '0' { true }\n    else if s.len() > 0 && s[0] == '-' { \n        s.len() > 1 && is_digit_sequence(s.subrange(1, s.len() as int)) && s[1] != '0'\n    }\n    else { is_digit_sequence(s) && s[0] != '0' }\n}\n\nspec fn is_digit_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool {\n    if start == end { false }\n    else {\n        let substr = s.subrange(start, end);\n        is_valid_integer_string(substr)\n    }\n}\n\nspec fn find_different_number(input: Seq<char>) -> Seq<char> {\n    let nums = parse_three_numbers(input);\n    let different = if nums.0 == nums.1 { nums.2 }\n                    else if nums.0 == nums.2 { nums.1 }\n                    else { nums.0 };\n    int_to_string_pure(different)\n}\nspec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) {\n    (0, 0, 0) /* placeholder for parsing logic */\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char> {\n    Seq::<char>::new(1 as nat, |i: int| '0') /* placeholder for conversion logic */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        input@.len() > 0,\n        contains_three_space_separated_integers(input@),\n        exactly_two_are_equal(input@),\n    ensures\n        result@.len() > 0,\n        is_valid_integer_string(result@),\n        result@ == find_different_number(input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn is_digit_sequence(s: Seq<char>) -> bool ;\n       spec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool ;\n       spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) ;\n       spec fn int_to_string_pure(n: int) -> Seq<char> ;\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n               fn main() {\n     }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4615_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    1 <= a < b <= 30 &&\n    1 <= c < d <= 30 &&\n    1 <= e <= 100 &&\n    100 * a <= f <= 3000\n}\n\nspec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {\n    total_mass > 0 && sugar_mass >= 0 &&\n    total_mass <= f &&\n    sugar_mass <= total_mass\n}\n\nspec fn density(total_mass: int, sugar_mass: int) -> int\n    recommends total_mass >= 0 && sugar_mass >= 0\n{\n    if total_mass > 0 { (100 * sugar_mass) / total_mass } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)\n    ensures ({\n        let (total_mass, sugar_mass) = result;\n        valid_solution(a as int, b as int, c as int, d as int, e as int, f as int, total_mass as int, sugar_mass as int) &&\n        total_mass as int >= 0 && sugar_mass as int >= 0 &&\n        total_mass as int <= f as int &&\n        sugar_mass as int <= total_mass as int &&\n        (exists|water_units: int| water_units > 0 && total_mass as int == #[trigger] (water_units * 100) + sugar_mass as int) &&\n        (exists|water_units: int| water_units > 0 && sugar_mass as int <= #[trigger] (water_units * e as int)) &&\n        (exists|i1: int, j1: int, i2: int, j2: int| \n            i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&\n            i1 <= 30int / a as int && j1 <= 30int / b as int &&\n            i2 <= 3000int / c as int && j2 <= 3000int / d as int &&\n            total_mass as int == #[trigger] ((a as int * i1 + b as int * j1) * 100 + (c as int * i2 + d as int * j2)) &&\n            sugar_mass as int == #[trigger] (c as int * i2 + d as int * j2) &&\n            a as int * i1 + b as int * j1 > 0) &&\n        total_mass as int > 0\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    1 <= a < b <= 30 &&\n    1 <= c < d <= 30 &&\n    1 <= e <= 100 &&\n    100 * a <= f <= 3000\n}\n\nspec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {\n    total_mass > 0 && sugar_mass >= 0 &&\n    total_mass <= f &&\n    sugar_mass <= total_mass\n}\n\nspec fn density(total_mass: int, sugar_mass: int) -> int\n    recommends total_mass >= 0 && sugar_mass >= 0\n{\n    if total_mass > 0 { (100 * sugar_mass) / total_mass } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)\n    ensures ({\n        let (total_mass, sugar_mass) = result;\n        valid_solution(a as int, b as int, c as int, d as int, e as int, f as int, total_mass as int, sugar_mass as int) &&\n        total_mass as int >= 0 && sugar_mass as int >= 0 &&\n        total_mass as int <= f as int &&\n        sugar_mass as int <= total_mass as int &&\n        (exists|water_units: int| water_units > 0 && total_mass as int == #[trigger] (water_units * 100) + sugar_mass as int) &&\n        (exists|water_units: int| water_units > 0 && sugar_mass as int <= #[trigger] (water_units * e as int)) &&\n        (exists|i1: int, j1: int, i2: int, j2: int| \n            i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&\n            i1 <= 30int / a as int && j1 <= 30int / b as int &&\n            i2 <= 3000int / c as int && j2 <= 3000int / d as int &&\n            total_mass as int == #[trigger] ((a as int * i1 + b as int * j1) * 100 + (c as int * i2 + d as int * j2)) &&\n            sugar_mass as int == #[trigger] (c as int * i2 + d as int * j2) &&\n            a as int * i1 + b as int * j1 > 0) &&\n        total_mass as int > 0\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4615.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1129, "minimize_time_ms": 184553, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n\nspec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {\n\nspec fn density(total_mass: int, sugar_mass: int) -> int\n    recommends total_mass >= 0 && sugar_mass >= 0\n{\n\n    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    1 <= a < b <= 30 &&\n    1 <= c < d <= 30 &&\n    1 <= e <= 100 &&\n    100 * a <= f <= 3000\n}\n\nspec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {\n    total_mass > 0 && sugar_mass >= 0 &&\n    total_mass <= f &&\n    sugar_mass <= total_mass\n}\n\nspec fn density(total_mass: int, sugar_mass: int) -> int\n    recommends total_mass >= 0 && sugar_mass >= 0\n{\n    if total_mass > 0 { (100 * sugar_mass) / total_mass } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)\n    ensures ({\n        let (total_mass, sugar_mass) = result;\n        valid_solution(a as int, b as int, c as int, d as int, e as int, f as int, total_mass as int, sugar_mass as int) &&\n        total_mass as int >= 0 && sugar_mass as int >= 0 &&\n        total_mass as int <= f as int &&\n        sugar_mass as int <= total_mass as int &&\n        (exists|water_units: int| water_units > 0 && total_mass as int == #[trigger] (water_units * 100) + sugar_mass as int) &&\n        (exists|water_units: int| water_units > 0 && sugar_mass as int <= #[trigger] (water_units * e as int)) &&\n        (exists|i1: int, j1: int, i2: int, j2: int| \n            i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&\n            i1 <= 30int / a as int && j1 <= 30int / b as int &&\n            i2 <= 3000int / c as int && j2 <= 3000int / d as int &&\n            total_mass as int == #[trigger] ((a as int * i1 + b as int * j1) * 100 + (c as int * i2 + d as int * j2)) &&\n            sugar_mass as int == #[trigger] (c as int * i2 + d as int * j2) &&\n            a as int * i1 + b as int * j1 > 0) &&\n        total_mass as int > 0\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4616_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {\n    result.len() >= 3 &&\n    s.len() >= 3 &&\n    result[0] == s[0] &&\n    result[result.len() - 1] == s[s.len() - 1] &&\n    result == seq![s[0]].add(int_to_string(s.len() - 2)).add(seq![s[s.len() - 1]])\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases if n >= 0 { n } else { -n }\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'].add(int_to_string_helper(-n))\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 {\n        Seq::new(0 as nat, |_i: int| ' ')\n    } else {\n        int_to_string_helper(n / 10).add(seq![(('0' as int) + (n % 10)) as char])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures valid_abbreviation(s@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {\n    result.len() >= 3 &&\n    s.len() >= 3 &&\n    result[0] == s[0] &&\n    result[result.len() - 1] == s[s.len() - 1] &&\n    result == seq![s[0]].add(int_to_string(s.len() - 2)).add(seq![s[s.len() - 1]])\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases if n >= 0 { n } else { -n }\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'].add(int_to_string_helper(-n))\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 {\n        Seq::new(0 as nat, |_i: int| ' ')\n    } else {\n        int_to_string_helper(n / 10).add(seq![(('0' as int) + (n % 10)) as char])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures valid_abbreviation(s@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4616.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1038, "minimize_time_ms": 155802, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases if n >= 0 {\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n\n    decreases if n >= 0 { n } else { -n }\n\n    decreases n\n\n    requires valid_input(s@)\n\n    ensures valid_abbreviation(s@, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {\n    result.len() >= 3 &&\n    s.len() >= 3 &&\n    result[0] == s[0] &&\n    result[result.len() - 1] == s[s.len() - 1] &&\n    result == seq![s[0]].add(int_to_string(s.len() - 2)).add(seq![s[s.len() - 1]])\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases if n >= 0 { n } else { -n }\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'].add(int_to_string_helper(-n))\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 {\n        Seq::new(0 as nat, |_i: int| ' ')\n    } else {\n        int_to_string_helper(n / 10).add(seq![(('0' as int) + (n % 10)) as char])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures valid_abbreviation(s@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4617_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0\n}\n\nspec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {\n    reverse_seq(first_row) == second_row\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> \n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == '\\n' {\n        seq![seq![]] + split_lines(s.subrange(1, s.len() as int))\n    } else {\n        let rest = split_lines(s.subrange(1, s.len() as int));\n        if rest.len() == 0 {\n            seq![seq![s[0]]]\n        } else {\n            seq![rest[0].push(s[0])] + rest.subrange(1, rest.len() as int)\n        }\n    }\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0\n}\n\nspec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {\n    reverse_seq(first_row) == second_row\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> \n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == '\\n' {\n        seq![seq![]] + split_lines(s.subrange(1, s.len() as int))\n    } else {\n        let rest = split_lines(s.subrange(1, s.len() as int));\n        if rest.len() == 0 {\n            seq![seq![s[0]]]\n        } else {\n            seq![rest[0].push(s[0])] + rest.subrange(1, rest.len() as int)\n        }\n    }\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4617.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1345, "minimize_time_ms": 122843, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(lines: Seq<Seq<char>>) -> bool {\n\nspec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> \n    decreases s.len()\n{\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires stdin_input@.len() > 0\n\n    ensures result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0\n}\n\nspec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {\n    reverse_seq(first_row) == second_row\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> \n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == '\\n' {\n        seq![seq![]] + split_lines(s.subrange(1, s.len() as int))\n    } else {\n        let rest = split_lines(s.subrange(1, s.len() as int));\n        if rest.len() == 0 {\n            seq![seq![s[0]]]\n        } else {\n            seq![rest[0].push(s[0])] + rest.subrange(1, rest.len() as int)\n        }\n    }\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures result@ == \"YES\\n\"@ || result@ == \"NO\\n\"@\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4635_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    (exists|lines: Seq<Seq<char>>| lines == split_by_newline(input) && \n     lines.len() >= 1 && \n     is_valid_integer(lines[0]) &&\n     string_to_int_val(lines[0]) >= 0 &&\n     lines.len() >= string_to_int_val(lines[0]) + 1 &&\n     (forall|i: int| 1 <= i <= string_to_int_val(lines[0]) && i < lines.len() ==> valid_test_case_line(lines[i])))\n}\n\nspec fn valid_test_case_line(line: Seq<char>) -> bool {\n    exists|parts: Seq<Seq<char>>| (parts == split_by_space(line) &&\n                    parts.len() >= 2 &&\n                    is_valid_integer(parts[0]) &&\n                    is_valid_integer(parts[1]) &&\n                    string_to_int_val(parts[0]) > 0 &&\n                    string_to_int_val(parts[1]) > 0 &&\n                    string_to_int_val(parts[1]) <= 26)\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s.len() == 1 || s[0] != '0' || s == seq!['0']) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn string_to_int_val(s: Seq<char>) -> int \n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        (s[0] as int) - 48 \n    } else { \n        string_to_int_val(s.subrange(0, s.len() - 1 as int)) * 10 + ((s[s.len() - 1] as int) - 48)\n    }\n}\n\nspec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool \n    recommends n > 0 && k > 0 && k <= 26\n{\n    output.len() == n &&\n    (forall|j: int| 0 <= j < n ==> (#[trigger] output[j] == ((j % k) + 97) as char))\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]  /* Placeholder implementation for splitting by newlines */\n}\n\nspec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2']]  /* Placeholder implementation for splitting by spaces */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    (exists|lines: Seq<Seq<char>>| lines == split_by_newline(input) && \n     lines.len() >= 1 && \n     is_valid_integer(lines[0]) &&\n     string_to_int_val(lines[0]) >= 0 &&\n     lines.len() >= string_to_int_val(lines[0]) + 1 &&\n     (forall|i: int| 1 <= i <= string_to_int_val(lines[0]) && i < lines.len() ==> valid_test_case_line(lines[i])))\n}\n\nspec fn valid_test_case_line(line: Seq<char>) -> bool {\n    exists|parts: Seq<Seq<char>>| (parts == split_by_space(line) &&\n                    parts.len() >= 2 &&\n                    is_valid_integer(parts[0]) &&\n                    is_valid_integer(parts[1]) &&\n                    string_to_int_val(parts[0]) > 0 &&\n                    string_to_int_val(parts[1]) > 0 &&\n                    string_to_int_val(parts[1]) <= 26)\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s.len() == 1 || s[0] != '0' || s == seq!['0']) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn string_to_int_val(s: Seq<char>) -> int \n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        (s[0] as int) - 48 \n    } else { \n        string_to_int_val(s.subrange(0, s.len() - 1 as int)) * 10 + ((s[s.len() - 1] as int) - 48)\n    }\n}\n\nspec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool \n    recommends n > 0 && k > 0 && k <= 26\n{\n    output.len() == n &&\n    (forall|j: int| 0 <= j < n ==> (#[trigger] output[j] == ((j % k) + 97) as char))\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]  /* Placeholder implementation for splitting by newlines */\n}\n\nspec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2']]  /* Placeholder implementation for splitting by spaces */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4635.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1028, "minimize_time_ms": 155428, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 80, "minimized_LOC": 80, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_test_case_line(line: Seq<char>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn string_to_int_val(s: Seq<char>) -> int \n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n\nspec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool \n    recommends n > 0 && k > 0 && k <= 26\n{\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {\n\n    decreases s.len()\n\n    requires valid_input(stdin_input@)\n\n    ensures result@.len() >= 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    (exists|lines: Seq<Seq<char>>| lines == split_by_newline(input) && \n     lines.len() >= 1 && \n     is_valid_integer(lines[0]) &&\n     string_to_int_val(lines[0]) >= 0 &&\n     lines.len() >= string_to_int_val(lines[0]) + 1 &&\n     (forall|i: int| 1 <= i <= string_to_int_val(lines[0]) && i < lines.len() ==> valid_test_case_line(lines[i])))\n}\n\nspec fn valid_test_case_line(line: Seq<char>) -> bool {\n    exists|parts: Seq<Seq<char>>| (parts == split_by_space(line) &&\n                    parts.len() >= 2 &&\n                    is_valid_integer(parts[0]) &&\n                    is_valid_integer(parts[1]) &&\n                    string_to_int_val(parts[0]) > 0 &&\n                    string_to_int_val(parts[1]) > 0 &&\n                    string_to_int_val(parts[1]) <= 26)\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s.len() == 1 || s[0] != '0' || s == seq!['0']) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn string_to_int_val(s: Seq<char>) -> int \n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        (s[0] as int) - 48 \n    } else { \n        string_to_int_val(s.subrange(0, s.len() - 1 as int)) * 10 + ((s[s.len() - 1] as int) - 48)\n    }\n}\n\nspec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool \n    recommends n > 0 && k > 0 && k <= 26\n{\n    output.len() == n &&\n    (forall|j: int| 0 <= j < n ==> (#[trigger] output[j] == ((j % k) + 97) as char))\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]  /* Placeholder implementation for splitting by newlines */\n}\n\nspec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2']]  /* Placeholder implementation for splitting by spaces */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {\n      }\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4676_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    {\n        let o = lines[0];\n        let e = lines[1];\n        let a = o.len();\n        let b = e.len();\n        (a == b || a == b + 1) &&\n        (a > 0 || b == 0)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    /* Helper function to split input by newlines */\n    seq![]  /* Placeholder - would need actual implementation */\n}\n\nspec fn get_o(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[0]\n}\n\nspec fn get_e(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[1]\n}\n\nspec fn correct_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let o = get_o(input);\n    let e = get_e(input);\n    let a = o.len();\n    let b = e.len();\n    if a == b {\n        interleave_equal(o, e)\n    } else {\n        interleave_unequal(o, e)\n    }\n}\n\nspec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len()\n    decreases o.len()\n{\n    if o.len() == 0 {\n        seq![]\n    } else {\n        seq![o[0], e[0]] + interleave_equal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n\nspec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len() + 1\n    decreases e.len()\n{\n    if e.len() == 0 {\n        o\n    } else {\n        seq![o[0], e[0]] + interleave_unequal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == correct_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    {\n        let o = lines[0];\n        let e = lines[1];\n        let a = o.len();\n        let b = e.len();\n        (a == b || a == b + 1) &&\n        (a > 0 || b == 0)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    /* Helper function to split input by newlines */\n    seq![]  /* Placeholder - would need actual implementation */\n}\n\nspec fn get_o(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[0]\n}\n\nspec fn get_e(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[1]\n}\n\nspec fn correct_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let o = get_o(input);\n    let e = get_e(input);\n    let a = o.len();\n    let b = e.len();\n    if a == b {\n        interleave_equal(o, e)\n    } else {\n        interleave_unequal(o, e)\n    }\n}\n\nspec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len()\n    decreases o.len()\n{\n    if o.len() == 0 {\n        seq![]\n    } else {\n        seq![o[0], e[0]] + interleave_equal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n\nspec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len() + 1\n    decreases e.len()\n{\n    if e.len() == 0 {\n        o\n    } else {\n        seq![o[0], e[0]] + interleave_unequal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == correct_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4676.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 7772, "minimize_time_ms": 155644, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 92, "minimized_LOC": 92, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn get_o(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n\nspec fn get_e(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n\nspec fn correct_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n\nspec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len()\n    decreases o.len()\n{\n\nspec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len() + 1\n    decreases e.len()\n{\n\n    decreases o.len()\n\n    decreases e.len()\n\n    requires valid_input(input@)\n\n    ensures result@ == correct_result(input@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    {\n        let o = lines[0];\n        let e = lines[1];\n        let a = o.len();\n        let b = e.len();\n        (a == b || a == b + 1) &&\n        (a > 0 || b == 0)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    /* Helper function to split input by newlines */\n    seq![]  /* Placeholder - would need actual implementation */\n}\n\nspec fn get_o(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[0]\n}\n\nspec fn get_e(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[1]\n}\n\nspec fn correct_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let o = get_o(input);\n    let e = get_e(input);\n    let a = o.len();\n    let b = e.len();\n    if a == b {\n        interleave_equal(o, e)\n    } else {\n        interleave_unequal(o, e)\n    }\n}\n\nspec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len()\n    decreases o.len()\n{\n    if o.len() == 0 {\n        seq![]\n    } else {\n        seq![o[0], e[0]] + interleave_equal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n\nspec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len() + 1\n    decreases e.len()\n{\n    if e.len() == 0 {\n        o\n    } else {\n        seq![o[0], e[0]] + interleave_unequal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == correct_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4677_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 10 && \n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1' || s[i] == 'B'\n}\n\nspec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>\n    decreases keystrokes.len()\n{\n    if keystrokes.len() == 0 {\n        Seq::<char>::empty()\n    } else {\n        let prev = simulate_keystrokes(keystrokes.subrange(0, keystrokes.len() - 1));\n        let last_key = keystrokes[keystrokes.len() - 1];\n        if last_key == 'B' {\n            if prev.len() > 0 {\n                prev.subrange(0, prev.len() - 1)\n            } else {\n                prev\n            }\n        } else {\n            prev.push(last_key)\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < result.len() ==> result[i] == '0' || result[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@),\n    ensures \n        valid_output(result@),\n        result@ == simulate_keystrokes(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 10 && \n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1' || s[i] == 'B'\n}\n\nspec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>\n    decreases keystrokes.len()\n{\n    if keystrokes.len() == 0 {\n        Seq::<char>::empty()\n    } else {\n        let prev = simulate_keystrokes(keystrokes.subrange(0, keystrokes.len() - 1));\n        let last_key = keystrokes[keystrokes.len() - 1];\n        if last_key == 'B' {\n            if prev.len() > 0 {\n                prev.subrange(0, prev.len() - 1)\n            } else {\n                prev\n            }\n        } else {\n            prev.push(last_key)\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < result.len() ==> result[i] == '0' || result[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@),\n    ensures \n        valid_output(result@),\n        result@ == simulate_keystrokes(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4677.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1494, "minimize_time_ms": 124236, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>\n    decreases keystrokes.len()\n{\n\nspec fn valid_output(result: Seq<char>) -> bool {\n\n    decreases keystrokes.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 10 && \n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1' || s[i] == 'B'\n}\n\nspec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>\n    decreases keystrokes.len()\n{\n    if keystrokes.len() == 0 {\n        Seq::<char>::empty()\n    } else {\n        let prev = simulate_keystrokes(keystrokes.subrange(0, keystrokes.len() - 1));\n        let last_key = keystrokes[keystrokes.len() - 1];\n        if last_key == 'B' {\n            if prev.len() > 0 {\n                prev.subrange(0, prev.len() - 1)\n            } else {\n                prev\n            }\n        } else {\n            prev.push(last_key)\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < result.len() ==> result[i] == '0' || result[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@),\n    ensures \n        valid_output(result@),\n        result@ == simulate_keystrokes(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_470_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() == 5 && forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0\n}\n\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int \n    decreases index when index >= 0\n{\n    if index <= 0 {\n        sum(cards)\n    } else {\n        min_possible_sum_up_to_index(cards, index - 1)\n    }\n}\n\nspec fn min_possible_sum(cards: Seq<int>) -> int {\n    min_possible_sum_up_to_index(cards, 5)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(cards@.map(|_index, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int <= sum(cards@.map(|_index, x: i8| x as int)),\n        result as int == min_possible_sum(cards@.map(|_index, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() == 5 && forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0\n}\n\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int \n    decreases index when index >= 0\n{\n    if index <= 0 {\n        sum(cards)\n    } else {\n        min_possible_sum_up_to_index(cards, index - 1)\n    }\n}\n\nspec fn min_possible_sum(cards: Seq<int>) -> int {\n    min_possible_sum_up_to_index(cards, 5)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(cards@.map(|_index, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int <= sum(cards@.map(|_index, x: i8| x as int)),\n        result as int == min_possible_sum(cards@.map(|_index, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_470.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 992, "minimize_time_ms": 123101, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(cards: Seq<int>) -> bool {\n\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n\nspec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int \n    decreases index when index >= 0\n{\n\nspec fn min_possible_sum(cards: Seq<int>) -> int {\n\n    decreases cards.len()\n\n    decreases index when index >= 0\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() == 5 && forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0\n}\n\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int \n    decreases index when index >= 0\n{\n    if index <= 0 {\n        sum(cards)\n    } else {\n        min_possible_sum_up_to_index(cards, index - 1)\n    }\n}\n\nspec fn min_possible_sum(cards: Seq<int>) -> int {\n    min_possible_sum_up_to_index(cards, 5)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(cards@.map(|_index, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int <= sum(cards@.map(|_index, x: i8| x as int)),\n        result as int == min_possible_sum(cards@.map(|_index, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4713_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_value(s: Seq<char>) -> int {\n    max_value_up_to_index(s, s.len() as int)\n}\n\nspec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int\n    decreases up_to when 0 <= up_to <= s.len()\n{\n    if up_to == 0 { 0 }\n    else {\n        let current_value = current_value_at_index(s, up_to);\n        let max_before = max_value_up_to_index(s, up_to - 1);\n        if current_value > max_before { current_value } else { max_before }\n    }\n}\n\nspec fn current_value_at_index(s: Seq<char>, index: int) -> int\n    decreases index when 0 <= index <= s.len()\n{\n    if index == 0 { 0 }\n    else { \n        current_value_at_index(s, index - 1) + (if s[index - 1 as nat] == 'I' { 1 } else { -1 })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        1 <= n <= 100,\n        n as int == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'I' || s@[i] == 'D',\n    ensures \n        result >= 0,\n        result as int == max_value(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_value(s: Seq<char>) -> int {\n    max_value_up_to_index(s, s.len() as int)\n}\n\nspec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int\n    decreases up_to when 0 <= up_to <= s.len()\n{\n    if up_to == 0 { 0 }\n    else {\n        let current_value = current_value_at_index(s, up_to);\n        let max_before = max_value_up_to_index(s, up_to - 1);\n        if current_value > max_before { current_value } else { max_before }\n    }\n}\n\nspec fn current_value_at_index(s: Seq<char>, index: int) -> int\n    decreases index when 0 <= index <= s.len()\n{\n    if index == 0 { 0 }\n    else { \n        current_value_at_index(s, index - 1) + (if s[index - 1 as nat] == 'I' { 1 } else { -1 })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        1 <= n <= 100,\n        n as int == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'I' || s@[i] == 'D',\n    ensures \n        result >= 0,\n        result as int == max_value(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4713.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 859, "minimize_time_ms": 92299, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn max_value(s: Seq<char>) -> int {\n\nspec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int\n    decreases up_to when 0 <= up_to <= s.len()\n{\n\nspec fn current_value_at_index(s: Seq<char>, index: int) -> int\n    decreases index when 0 <= index <= s.len()\n{\n\n    decreases up_to when 0 <= up_to <= s.len()\n\n    decreases index when 0 <= index <= s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_value(s: Seq<char>) -> int {\n    max_value_up_to_index(s, s.len() as int)\n}\n\nspec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int\n    decreases up_to when 0 <= up_to <= s.len()\n{\n    if up_to == 0 { 0 }\n    else {\n        let current_value = current_value_at_index(s, up_to);\n        let max_before = max_value_up_to_index(s, up_to - 1);\n        if current_value > max_before { current_value } else { max_before }\n    }\n}\n\nspec fn current_value_at_index(s: Seq<char>, index: int) -> int\n    decreases index when 0 <= index <= s.len()\n{\n    if index == 0 { 0 }\n    else { \n        current_value_at_index(s, index - 1) + (if s[index - 1 as nat] == 'I' { 1 } else { -1 })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        1 <= n <= 100,\n        n as int == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'I' || s@[i] == 'D',\n    ensures \n        result >= 0,\n        result as int == max_value(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4715_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nspec fn count_distinct_colors(a: int, b: int, c: int) -> int {\n    if a == b && b == c { 1 }\n    else if a == b || b == c || a == c { 2 }\n    else { 3 }\n}\n\nspec fn all_same(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n\nspec fn exactly_two_same(a: int, b: int, c: int) -> bool {\n    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)\n}\n\nspec fn all_different(a: int, b: int, c: int) -> bool {\n    a != b && b != c && a != c\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int)\n    ensures \n        1 <= result as int <= 3,\n        result as int == count_distinct_colors(a as int, b as int, c as int),\n        result as int == 1 <==> all_same(a as int, b as int, c as int),\n        result as int == 2 <==> exactly_two_same(a as int, b as int, c as int),\n        result as int == 3 <==> all_different(a as int, b as int, c as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nspec fn count_distinct_colors(a: int, b: int, c: int) -> int {\n    if a == b && b == c { 1 }\n    else if a == b || b == c || a == c { 2 }\n    else { 3 }\n}\n\nspec fn all_same(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n\nspec fn exactly_two_same(a: int, b: int, c: int) -> bool {\n    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)\n}\n\nspec fn all_different(a: int, b: int, c: int) -> bool {\n    a != b && b != c && a != c\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int)\n    ensures \n        1 <= result as int <= 3,\n        result as int == count_distinct_colors(a as int, b as int, c as int),\n        result as int == 1 <==> all_same(a as int, b as int, c as int),\n        result as int == 2 <==> exactly_two_same(a as int, b as int, c as int),\n        result as int == 3 <==> all_different(a as int, b as int, c as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4715.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 879, "minimize_time_ms": 122253, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, c: int) -> bool {\n\nspec fn count_distinct_colors(a: int, b: int, c: int) -> int {\n\nspec fn all_same(a: int, b: int, c: int) -> bool {\n\nspec fn exactly_two_same(a: int, b: int, c: int) -> bool {\n\nspec fn all_different(a: int, b: int, c: int) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nspec fn count_distinct_colors(a: int, b: int, c: int) -> int {\n    if a == b && b == c { 1 }\n    else if a == b || b == c || a == c { 2 }\n    else { 3 }\n}\n\nspec fn all_same(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n\nspec fn exactly_two_same(a: int, b: int, c: int) -> bool {\n    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)\n}\n\nspec fn all_different(a: int, b: int, c: int) -> bool {\n    a != b && b != c && a != c\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int)\n    ensures \n        1 <= result as int <= 3,\n        result as int == count_distinct_colors(a as int, b as int, c as int),\n        result as int == 1 <==> all_same(a as int, b as int, c as int),\n        result as int == 2 <==> exactly_two_same(a as int, b as int, c as int),\n        result as int == 3 <==> all_different(a as int, b as int, c as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_473_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_time_format(time_str: Seq<char>) -> bool {\n    time_str.len() == 5 &&\n    time_str[2] == ':' &&\n    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&\n    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&\n    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&\n    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int {\n    choose|i: int| 0 <= i < s.len() && s[i] == '\\n'\n}\n\nspec fn find_second_newline(s: Seq<char>, first: int) -> int {\n    choose|i: int| first < i < s.len() && s[i] == '\\n'\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n' &&\n    exists|i: int, j: int| 0 <= i < j < stdin_input.len() && stdin_input[i] == '\\n' && stdin_input[j] == '\\n' &&\n    {\n        let first_nl = find_first_newline(stdin_input);\n        let second_nl = find_second_newline(stdin_input, first_nl);\n        let s = stdin_input.subrange(0, first_nl);\n        let t = stdin_input.subrange(first_nl + 1, second_nl);\n        valid_time_format(s) && valid_time_format(t)\n    }\n}\n\nspec fn parse_time(time_str: Seq<char>) -> (int, int) {\n    let h = (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);\n    let m = (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);\n    (h, m)\n}\n\nspec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {\n    let wake_total_min = wake_hour * 60 + wake_min;\n    let sleep_total_min = sleep_hour * 60 + sleep_min;\n    let diff = wake_total_min - sleep_total_min;\n    let bed_total_min = if diff >= 0 { diff } else { diff + 24 * 60 };\n    (bed_total_min / 60, bed_total_min % 60)\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() == 6 &&\n    result[result.len() - 1] == '\\n' &&\n    result[2] == ':' &&\n    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&\n    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&\n    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&\n    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59\n}\n\nspec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let first_nl = find_first_newline(stdin_input);\n    let second_nl = find_second_newline(stdin_input, first_nl);\n    let s = stdin_input.subrange(0, first_nl);\n    let t = stdin_input.subrange(first_nl + 1, second_nl);\n    let (wake_hour, wake_min) = parse_time(s);\n    let (sleep_hour, sleep_min) = parse_time(t);\n    let (bed_hour, bed_min) = calculate_bedtime(wake_hour, wake_min, sleep_hour, sleep_min);\n    let result_hour = (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);\n    let result_min = (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);\n    result_hour == bed_hour && result_min == bed_min\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        valid_output(result@) &&\n        correct_bedtime(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_time_format(time_str: Seq<char>) -> bool {\n    time_str.len() == 5 &&\n    time_str[2] == ':' &&\n    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&\n    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&\n    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&\n    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int {\n    choose|i: int| 0 <= i < s.len() && s[i] == '\\n'\n}\n\nspec fn find_second_newline(s: Seq<char>, first: int) -> int {\n    choose|i: int| first < i < s.len() && s[i] == '\\n'\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n' &&\n    exists|i: int, j: int| 0 <= i < j < stdin_input.len() && stdin_input[i] == '\\n' && stdin_input[j] == '\\n' &&\n    {\n        let first_nl = find_first_newline(stdin_input);\n        let second_nl = find_second_newline(stdin_input, first_nl);\n        let s = stdin_input.subrange(0, first_nl);\n        let t = stdin_input.subrange(first_nl + 1, second_nl);\n        valid_time_format(s) && valid_time_format(t)\n    }\n}\n\nspec fn parse_time(time_str: Seq<char>) -> (int, int) {\n    let h = (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);\n    let m = (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);\n    (h, m)\n}\n\nspec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {\n    let wake_total_min = wake_hour * 60 + wake_min;\n    let sleep_total_min = sleep_hour * 60 + sleep_min;\n    let diff = wake_total_min - sleep_total_min;\n    let bed_total_min = if diff >= 0 { diff } else { diff + 24 * 60 };\n    (bed_total_min / 60, bed_total_min % 60)\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() == 6 &&\n    result[result.len() - 1] == '\\n' &&\n    result[2] == ':' &&\n    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&\n    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&\n    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&\n    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59\n}\n\nspec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let first_nl = find_first_newline(stdin_input);\n    let second_nl = find_second_newline(stdin_input, first_nl);\n    let s = stdin_input.subrange(0, first_nl);\n    let t = stdin_input.subrange(first_nl + 1, second_nl);\n    let (wake_hour, wake_min) = parse_time(s);\n    let (sleep_hour, sleep_min) = parse_time(t);\n    let (bed_hour, bed_min) = calculate_bedtime(wake_hour, wake_min, sleep_hour, sleep_min);\n    let result_hour = (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);\n    let result_min = (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);\n    result_hour == bed_hour && result_min == bed_min\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        valid_output(result@) &&\n        correct_bedtime(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_473.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 805, "minimize_time_ms": 92389, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 95, "minimized_LOC": 95, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_time_format(time_str: Seq<char>) -> bool {\n\nspec fn find_first_newline(s: Seq<char>) -> int {\n\nspec fn find_second_newline(s: Seq<char>, first: int) -> int {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn parse_time(time_str: Seq<char>) -> (int, int) {\n\nspec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {\n\nspec fn valid_output(result: Seq<char>) -> bool {\n\nspec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_time_format(time_str: Seq<char>) -> bool {\n    time_str.len() == 5 &&\n    time_str[2] == ':' &&\n    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&\n    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&\n    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&\n    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int {\n    choose|i: int| 0 <= i < s.len() && s[i] == '\\n'\n}\n\nspec fn find_second_newline(s: Seq<char>, first: int) -> int {\n    choose|i: int| first < i < s.len() && s[i] == '\\n'\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n' &&\n    exists|i: int, j: int| 0 <= i < j < stdin_input.len() && stdin_input[i] == '\\n' && stdin_input[j] == '\\n' &&\n    {\n        let first_nl = find_first_newline(stdin_input);\n        let second_nl = find_second_newline(stdin_input, first_nl);\n        let s = stdin_input.subrange(0, first_nl);\n        let t = stdin_input.subrange(first_nl + 1, second_nl);\n        valid_time_format(s) && valid_time_format(t)\n    }\n}\n\nspec fn parse_time(time_str: Seq<char>) -> (int, int) {\n    let h = (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);\n    let m = (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);\n    (h, m)\n}\n\nspec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {\n    let wake_total_min = wake_hour * 60 + wake_min;\n    let sleep_total_min = sleep_hour * 60 + sleep_min;\n    let diff = wake_total_min - sleep_total_min;\n    let bed_total_min = if diff >= 0 { diff } else { diff + 24 * 60 };\n    (bed_total_min / 60, bed_total_min % 60)\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() == 6 &&\n    result[result.len() - 1] == '\\n' &&\n    result[2] == ':' &&\n    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&\n    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&\n    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&\n    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59\n}\n\nspec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let first_nl = find_first_newline(stdin_input);\n    let second_nl = find_second_newline(stdin_input, first_nl);\n    let s = stdin_input.subrange(0, first_nl);\n    let t = stdin_input.subrange(first_nl + 1, second_nl);\n    let (wake_hour, wake_min) = parse_time(s);\n    let (sleep_hour, sleep_min) = parse_time(t);\n    let (bed_hour, bed_min) = calculate_bedtime(wake_hour, wake_min, sleep_hour, sleep_min);\n    let result_hour = (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);\n    let result_min = (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);\n    result_hour == bed_hour && result_min == bed_min\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        valid_output(result@) &&\n        correct_bedtime(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_475_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat, m: nat, k: nat) -> bool {\n    n >= 1 && m >= 1 && k >= 0 && k <= n - 1\n}\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 }\n    else { n * factorial((n - 1) as nat) }\n}\n\nspec fn binomial(n: nat, k: nat) -> nat\n    decreases n\n{\n    if k > n { 0 }\n    else if factorial(k) == 0 || factorial((n - k) as nat) == 0 { 0 }\n    else { factorial(n) / (factorial(k) * factorial((n - k) as nat)) }\n}\n\nspec fn power(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 }\n    else { base * power(base, (exp - 1) as nat) }\n}\n\nspec fn expected_result(n: nat, m: nat, k: nat) -> nat {\n    if valid_input(n, m, k) {\n        (m * power((m - 1) as nat, k) * binomial((n - 1) as nat, k)) % 998244353\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u64, m: u64, k: u64) -> (result: u64)\n    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1\n    ensures result < 998244353\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat, m: nat, k: nat) -> bool {\n    n >= 1 && m >= 1 && k >= 0 && k <= n - 1\n}\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 }\n    else { n * factorial((n - 1) as nat) }\n}\n\nspec fn binomial(n: nat, k: nat) -> nat\n    decreases n\n{\n    if k > n { 0 }\n    else if factorial(k) == 0 || factorial((n - k) as nat) == 0 { 0 }\n    else { factorial(n) / (factorial(k) * factorial((n - k) as nat)) }\n}\n\nspec fn power(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 }\n    else { base * power(base, (exp - 1) as nat) }\n}\n\nspec fn expected_result(n: nat, m: nat, k: nat) -> nat {\n    if valid_input(n, m, k) {\n        (m * power((m - 1) as nat, k) * binomial((n - 1) as nat, k)) % 998244353\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u64, m: u64, k: u64) -> (result: u64)\n    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1\n    ensures result < 998244353\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_475.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 841, "minimize_time_ms": 92077, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: nat, m: nat, k: nat) -> bool {\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n\nspec fn binomial(n: nat, k: nat) -> nat\n    decreases n\n{\n\nspec fn power(base: nat, exp: nat) -> nat\n    decreases exp\n{\n\nspec fn expected_result(n: nat, m: nat, k: nat) -> nat {\n\n    decreases n\n\n    decreases n\n\n    decreases exp\n\n    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1\n\n    ensures result < 998244353"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat, m: nat, k: nat) -> bool {\n    n >= 1 && m >= 1 && k >= 0 && k <= n - 1\n}\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 }\n    else { n * factorial((n - 1) as nat) }\n}\n\nspec fn binomial(n: nat, k: nat) -> nat\n    decreases n\n{\n    if k > n { 0 }\n    else if factorial(k) == 0 || factorial((n - k) as nat) == 0 { 0 }\n    else { factorial(n) / (factorial(k) * factorial((n - k) as nat)) }\n}\n\nspec fn power(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 }\n    else { base * power(base, (exp - 1) as nat) }\n}\n\nspec fn expected_result(n: nat, m: nat, k: nat) -> nat {\n    if valid_input(n, m, k) {\n        (m * power((m - 1) as nat, k) * binomial((n - 1) as nat, k)) % 998244353\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u64, m: u64, k: u64) -> (result: u64)\n    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1\n    ensures result < 998244353\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_48_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_less_value(n: int, m: int, target: int) -> int\n  decreases n\n{\n  if n <= 0 {\n    0\n  } else {\n    let max_j = (target - 1) / n;\n    let actual_max_j = if max_j > m { m } else { max_j };\n    let contribution = if actual_max_j >= 1 { actual_max_j } else { 0 };\n    contribution + count_less_value(n - 1, m, target)\n  }\n}\n\nspec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {\n  if target <= 0 {\n    0\n  } else if target >= n * m {\n    n * m\n  } else {\n    count_less_value(n, m, target + 1)\n  }\n}\n\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int)\n  ensures \n    1 <= result as int <= (n as int) * (m as int),\n    count_less_or_equal_value(n as int, m as int, result as int) >= k as int,\n    result as int == 1 || count_less_or_equal_value(n as int, m as int, (result as int) - 1) < k as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_less_value(n: int, m: int, target: int) -> int\n  decreases n\n{\n  if n <= 0 {\n    0\n  } else {\n    let max_j = (target - 1) / n;\n    let actual_max_j = if max_j > m { m } else { max_j };\n    let contribution = if actual_max_j >= 1 { actual_max_j } else { 0 };\n    contribution + count_less_value(n - 1, m, target)\n  }\n}\n\nspec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {\n  if target <= 0 {\n    0\n  } else if target >= n * m {\n    n * m\n  } else {\n    count_less_value(n, m, target + 1)\n  }\n}\n\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int)\n  ensures \n    1 <= result as int <= (n as int) * (m as int),\n    count_less_or_equal_value(n as int, m as int, result as int) >= k as int,\n    result as int == 1 || count_less_or_equal_value(n as int, m as int, (result as int) - 1) < k as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_48.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 807, "minimize_time_ms": 92480, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_less_value(n: int, m: int, target: int) -> int\n  decreases n\n{\n\nspec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {\n\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n\n  decreases n\n\n  requires valid_input(n as int, m as int, k as int)\n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_less_value(n: int, m: int, target: int) -> int\n  decreases n\n{\n  if n <= 0 {\n    0\n  } else {\n    let max_j = (target - 1) / n;\n    let actual_max_j = if max_j > m { m } else { max_j };\n    let contribution = if actual_max_j >= 1 { actual_max_j } else { 0 };\n    contribution + count_less_value(n - 1, m, target)\n  }\n}\n\nspec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {\n  if target <= 0 {\n    0\n  } else if target >= n * m {\n    n * m\n  } else {\n    count_less_value(n, m, target + 1)\n  }\n}\n\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int)\n  ensures \n    1 <= result as int <= (n as int) * (m as int),\n    count_less_or_equal_value(n as int, m as int, result as int) >= k as int,\n    result as int == 1 || count_less_or_equal_value(n as int, m as int, (result as int) - 1) < k as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_483_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {\n    n >= 1 &&\n    directions.len() == n &&\n    positions.len() == n &&\n    (forall|i: int| 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&\n    (forall|i: int| 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> positions[i] < positions[j])\n}\n\nspec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {\n    0 <= i < directions.len()-1 && \n    directions[i] == 'R' && directions[i+1] == 'L'\n}\n\nspec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool \n    recommends directions.len() == positions.len()\n{\n    exists|i: int| #[trigger] has_collision_pair(i, directions)\n}\n\nspec fn collision_time(i: int, positions: Seq<int>) -> int\n    recommends 0 <= i < positions.len()-1\n{\n    (positions[i+1] - positions[i]) / 2\n}\n\nspec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool\n    recommends directions.len() == positions.len()\n{\n    (forall|i: int| has_collision_pair(i, directions) ==> \n        collision_time(i, positions) >= result) &&\n    (exists|i: int| #[trigger] has_collision_pair(i, directions) && \n        collision_time(i, positions) == result)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, directions: Vec<char>, positions: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n    ensures \n        result == -1 || result >= 0,\n        result != -1 ==> has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result == -1 ==> !has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result != -1 ==> is_minimal_collision_time(result as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {\n    n >= 1 &&\n    directions.len() == n &&\n    positions.len() == n &&\n    (forall|i: int| 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&\n    (forall|i: int| 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> positions[i] < positions[j])\n}\n\nspec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {\n    0 <= i < directions.len()-1 && \n    directions[i] == 'R' && directions[i+1] == 'L'\n}\n\nspec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool \n    recommends directions.len() == positions.len()\n{\n    exists|i: int| #[trigger] has_collision_pair(i, directions)\n}\n\nspec fn collision_time(i: int, positions: Seq<int>) -> int\n    recommends 0 <= i < positions.len()-1\n{\n    (positions[i+1] - positions[i]) / 2\n}\n\nspec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool\n    recommends directions.len() == positions.len()\n{\n    (forall|i: int| has_collision_pair(i, directions) ==> \n        collision_time(i, positions) >= result) &&\n    (exists|i: int| #[trigger] has_collision_pair(i, directions) && \n        collision_time(i, positions) == result)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, directions: Vec<char>, positions: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n    ensures \n        result == -1 || result >= 0,\n        result != -1 ==> has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result == -1 ==> !has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result != -1 ==> is_minimal_collision_time(result as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_483.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1062, "minimize_time_ms": 122537, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {\n\nspec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {\n\nspec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool \n    recommends directions.len() == positions.len()\n{\n\nspec fn collision_time(i: int, positions: Seq<int>) -> int\n    recommends 0 <= i < positions.len()-1\n{\n\nspec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool\n    recommends directions.len() == positions.len()\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {\n    n >= 1 &&\n    directions.len() == n &&\n    positions.len() == n &&\n    (forall|i: int| 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&\n    (forall|i: int| 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> positions[i] < positions[j])\n}\n\nspec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {\n    0 <= i < directions.len()-1 && \n    directions[i] == 'R' && directions[i+1] == 'L'\n}\n\nspec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool \n    recommends directions.len() == positions.len()\n{\n    exists|i: int| #[trigger] has_collision_pair(i, directions)\n}\n\nspec fn collision_time(i: int, positions: Seq<int>) -> int\n    recommends 0 <= i < positions.len()-1\n{\n    (positions[i+1] - positions[i]) / 2\n}\n\nspec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool\n    recommends directions.len() == positions.len()\n{\n    (forall|i: int| has_collision_pair(i, directions) ==> \n        collision_time(i, positions) >= result) &&\n    (exists|i: int| #[trigger] has_collision_pair(i, directions) && \n        collision_time(i, positions) == result)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, directions: Vec<char>, positions: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n    ensures \n        result == -1 || result >= 0,\n        result != -1 ==> has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result == -1 ==> !has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result != -1 ==> is_minimal_collision_time(result as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_484_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int\n{\n    let orientations = seq![(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];\n\n    let area0 = if can_fit(orientations[0].0, orientations[0].1, a, b) {\n        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1\n    } else {\n        0\n    };\n\n    let area1 = if can_fit(orientations[1].0, orientations[1].1, a, b) {\n        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1\n    } else {\n        0\n    };\n\n    let area2 = if can_fit(orientations[2].0, orientations[2].1, a, b) {\n        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1\n    } else {\n        0\n    };\n\n    let area3 = if can_fit(orientations[3].0, orientations[3].1, a, b) {\n        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1\n    } else {\n        0\n    };\n\n    max_spec(max_spec(area0, area1), max_spec(area2, area3))\n}\n\nspec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool\n{\n    (r1.0 + r2.0 <= a && max_spec(r1.1, r2.1) <= b) || (max_spec(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)\n}\n\nspec fn max_spec(x: int, y: int) -> int\n{\n    if x >= y { x } else { y }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, seals: Vec<(i8, i8)>) -> (result: i8)\n    requires n >= 0,\n            a >= 1 && b >= 1,\n            seals.len() == n as nat,\n            forall|i: int| 0 <= i < n as int ==> seals@[i].0 as int >= 1 && seals@[i].1 as int >= 1,\n    ensures result as int >= 0,\n            result as int == 0 ==> (forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == 0),\n            result as int > 0 ==> (exists|i: int, j: int| 0 <= i < n as int && i < j < n as int && check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == result as int),\n            forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) <= result as int,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int\n{\n    let orientations = seq![(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];\n\n    let area0 = if can_fit(orientations[0].0, orientations[0].1, a, b) {\n        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1\n    } else {\n        0\n    };\n\n    let area1 = if can_fit(orientations[1].0, orientations[1].1, a, b) {\n        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1\n    } else {\n        0\n    };\n\n    let area2 = if can_fit(orientations[2].0, orientations[2].1, a, b) {\n        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1\n    } else {\n        0\n    };\n\n    let area3 = if can_fit(orientations[3].0, orientations[3].1, a, b) {\n        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1\n    } else {\n        0\n    };\n\n    max_spec(max_spec(area0, area1), max_spec(area2, area3))\n}\n\nspec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool\n{\n    (r1.0 + r2.0 <= a && max_spec(r1.1, r2.1) <= b) || (max_spec(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)\n}\n\nspec fn max_spec(x: int, y: int) -> int\n{\n    if x >= y { x } else { y }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, seals: Vec<(i8, i8)>) -> (result: i8)\n    requires n >= 0,\n            a >= 1 && b >= 1,\n            seals.len() == n as nat,\n            forall|i: int| 0 <= i < n as int ==> seals@[i].0 as int >= 1 && seals@[i].1 as int >= 1,\n    ensures result as int >= 0,\n            result as int == 0 ==> (forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == 0),\n            result as int > 0 ==> (exists|i: int, j: int| 0 <= i < n as int && i < j < n as int && check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == result as int),\n            forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) <= result as int,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_484.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 922, "minimize_time_ms": 122580, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 74, "minimized_LOC": 74, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int\n{\n\nspec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool\n{\n\nspec fn max_spec(x: int, y: int) -> int\n{\n\n    requires n >= 0,\n\n    ensures result as int >= 0,"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int\n{\n    let orientations = seq![(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];\n\n    let area0 = if can_fit(orientations[0].0, orientations[0].1, a, b) {\n        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1\n    } else {\n        0\n    };\n\n    let area1 = if can_fit(orientations[1].0, orientations[1].1, a, b) {\n        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1\n    } else {\n        0\n    };\n\n    let area2 = if can_fit(orientations[2].0, orientations[2].1, a, b) {\n        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1\n    } else {\n        0\n    };\n\n    let area3 = if can_fit(orientations[3].0, orientations[3].1, a, b) {\n        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1\n    } else {\n        0\n    };\n\n    max_spec(max_spec(area0, area1), max_spec(area2, area3))\n}\n\nspec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool\n{\n    (r1.0 + r2.0 <= a && max_spec(r1.1, r2.1) <= b) || (max_spec(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)\n}\n\nspec fn max_spec(x: int, y: int) -> int\n{\n    if x >= y { x } else { y }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, seals: Vec<(i8, i8)>) -> (result: i8)\n    requires n >= 0,\n            a >= 1 && b >= 1,\n            seals.len() == n as nat,\n            forall|i: int| 0 <= i < n as int ==> seals@[i].0 as int >= 1 && seals@[i].1 as int >= 1,\n    ensures result as int >= 0,\n            result as int == 0 ==> (forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == 0),\n            result as int > 0 ==> (exists|i: int, j: int| 0 <= i < n as int && i < j < n as int && check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == result as int),\n            forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) <= result as int,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_486_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn product_of_digits(x: int) -> int\n  recommends x >= 0\n  decreases x\n{\n  if x == 0 { 1 }\n  else if x < 10 { x }\n  else { (x % 10) * product_of_digits(x / 10) }\n}\n\nspec fn max_product_of_digits_in_range(n: int) -> int\n  recommends n >= 1\n  decreases n\n  when n >= 1\n{\n  if n == 1 { 1 }\n  else {\n    let current = product_of_digits(n);\n    let rest = max_product_of_digits_in_range(n - 1);\n    if current > rest { current } else { rest }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n  requires \n    n >= 1\n  ensures \n    result as int == max_product_of_digits_in_range(n as int),\n    result >= 1,\n    forall|k: int| 1 <= k <= n as int ==> product_of_digits(k) <= result as int,\n    exists|k: int| 1 <= k <= n as int && product_of_digits(k) == result as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn product_of_digits(x: int) -> int\n  recommends x >= 0\n  decreases x\n{\n  if x == 0 { 1 }\n  else if x < 10 { x }\n  else { (x % 10) * product_of_digits(x / 10) }\n}\n\nspec fn max_product_of_digits_in_range(n: int) -> int\n  recommends n >= 1\n  decreases n\n  when n >= 1\n{\n  if n == 1 { 1 }\n  else {\n    let current = product_of_digits(n);\n    let rest = max_product_of_digits_in_range(n - 1);\n    if current > rest { current } else { rest }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n  requires \n    n >= 1\n  ensures \n    result as int == max_product_of_digits_in_range(n as int),\n    result >= 1,\n    forall|k: int| 1 <= k <= n as int ==> product_of_digits(k) <= result as int,\n    exists|k: int| 1 <= k <= n as int && product_of_digits(k) == result as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_486.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1036, "minimize_time_ms": 92229, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn product_of_digits(x: int) -> int\n  recommends x >= 0\n  decreases x\n{\n\nspec fn max_product_of_digits_in_range(n: int) -> int\n  recommends n >= 1\n  decreases n\n  when n >= 1\n{\n\n  decreases x\n\n  decreases n\n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn product_of_digits(x: int) -> int\n  recommends x >= 0\n  decreases x\n{\n  if x == 0 { 1 }\n  else if x < 10 { x }\n  else { (x % 10) * product_of_digits(x / 10) }\n}\n\nspec fn max_product_of_digits_in_range(n: int) -> int\n  recommends n >= 1\n  decreases n\n  when n >= 1\n{\n  if n == 1 { 1 }\n  else {\n    let current = product_of_digits(n);\n    let rest = max_product_of_digits_in_range(n - 1);\n    if current > rest { current } else { rest }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n  requires \n    n >= 1\n  ensures \n    result as int == max_product_of_digits_in_range(n as int),\n    result >= 1,\n    forall|k: int| 1 <= k <= n as int ==> product_of_digits(k) <= result as int,\n    exists|k: int| 1 <= k <= n as int && product_of_digits(k) == result as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_506_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 0 && b > 0\n}\n\nspec fn count_squares(a: int, b: int) -> int\n    recommends a >= 0 && b >= 0\n    decreases a + b when a > 0 && b > 0\n{\n    if a == 0 || b == 0 {\n        0\n    } else if a > b {\n        if b == 0 { 0 } else {\n            a / b + count_squares(a % b, b)\n        }\n    } else if b > a {\n        if a == 0 { 0 } else {\n            b / a + count_squares(a, b % a)\n        }\n    } else {\n        1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures \n        result >= 0,\n        a == b ==> result == 1,\n        a > b ==> result >= 1,\n        result as int == count_squares(a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 0 && b > 0\n}\n\nspec fn count_squares(a: int, b: int) -> int\n    recommends a >= 0 && b >= 0\n    decreases a + b when a > 0 && b > 0\n{\n    if a == 0 || b == 0 {\n        0\n    } else if a > b {\n        if b == 0 { 0 } else {\n            a / b + count_squares(a % b, b)\n        }\n    } else if b > a {\n        if a == 0 { 0 } else {\n            b / a + count_squares(a, b % a)\n        }\n    } else {\n        1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures \n        result >= 0,\n        a == b ==> result == 1,\n        a > b ==> result >= 1,\n        result as int == count_squares(a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_506.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 911, "minimize_time_ms": 122393, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int) -> bool {\n\nspec fn count_squares(a: int, b: int) -> int\n    recommends a >= 0 && b >= 0\n    decreases a + b when a > 0 && b > 0\n{\n\n    decreases a + b when a > 0 && b > 0\n\n    requires valid_input(a as int, b as int)\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 0 && b > 0\n}\n\nspec fn count_squares(a: int, b: int) -> int\n    recommends a >= 0 && b >= 0\n    decreases a + b when a > 0 && b > 0\n{\n    if a == 0 || b == 0 {\n        0\n    } else if a > b {\n        if b == 0 { 0 } else {\n            a / b + count_squares(a % b, b)\n        }\n    } else if b > a {\n        if a == 0 { 0 } else {\n            b / a + count_squares(a, b % a)\n        }\n    } else {\n        1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures \n        result >= 0,\n        a == b ==> result == 1,\n        a > b ==> result >= 1,\n        result as int == count_squares(a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_511_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == ' ') &&\n    (forall|j: int| 0 <= j < input.len() ==> \n        ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\\n'))\n}\n\nspec fn gcd(a: nat, b: nat) -> nat \n    decreases a + b\n{\n    if a == 0 { b }\n    else if b == 0 { a }\n    else if a > b { gcd((a - b) as nat, b) }\n    else { gcd(a, (b - a) as nat) }\n}\n\n#[verifier::opaque]\nspec fn f_mathematical(x: nat, y: nat) -> nat\n    decreases y\n{\n    y / 2\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (forall|i: int| 0 <= i < result.len() ==> \n        ('0' <= result[i] <= '9' || result[i] == '\\n')) &&\n    result[result.len() - 1] == '\\n'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == ' ') &&\n    (forall|j: int| 0 <= j < input.len() ==> \n        ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\\n'))\n}\n\nspec fn gcd(a: nat, b: nat) -> nat \n    decreases a + b\n{\n    if a == 0 { b }\n    else if b == 0 { a }\n    else if a > b { gcd((a - b) as nat, b) }\n    else { gcd(a, (b - a) as nat) }\n}\n\n#[verifier::opaque]\nspec fn f_mathematical(x: nat, y: nat) -> nat\n    decreases y\n{\n    y / 2\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (forall|i: int| 0 <= i < result.len() ==> \n        ('0' <= result[i] <= '9' || result[i] == '\\n')) &&\n    result[result.len() - 1] == '\\n'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_511.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 962, "minimize_time_ms": 122612, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn gcd(a: nat, b: nat) -> nat \n    decreases a + b\n{\n\nspec fn f_mathematical(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_output(result: Seq<char>) -> bool {\n\n    decreases a + b\n\n    decreases y\n\n    requires valid_input(input@)\n\n    ensures valid_output(result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == ' ') &&\n    (forall|j: int| 0 <= j < input.len() ==> \n        ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\\n'))\n}\n\nspec fn gcd(a: nat, b: nat) -> nat \n    decreases a + b\n{\n    if a == 0 { b }\n    else if b == 0 { a }\n    else if a > b { gcd((a - b) as nat, b) }\n    else { gcd(a, (b - a) as nat) }\n}\n\n#[verifier::opaque]\nspec fn f_mathematical(x: nat, y: nat) -> nat\n    decreases y\n{\n    y / 2\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (forall|i: int| 0 <= i < result.len() ==> \n        ('0' <= result[i] <= '9' || result[i] == '\\n')) &&\n    result[result.len() - 1] == '\\n'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_529_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>, n: int) -> bool {\n  0 <= n <= 26\n}\n\nspec fn get_comparison_char(n: int) -> char {\n  if n == 0 { 'a' }\n  else if n == 1 { 'b' }\n  else if n == 2 { 'c' }\n  else if n == 3 { 'd' }\n  else if n == 4 { 'e' }\n  else if n == 5 { 'f' }\n  else if n == 6 { 'g' }\n  else if n == 7 { 'h' }\n  else if n == 8 { 'i' }\n  else if n == 9 { 'j' }\n  else if n == 10 { 'k' }\n  else if n == 11 { 'l' }\n  else if n == 12 { 'm' }\n  else if n == 13 { 'n' }\n  else if n == 14 { 'o' }\n  else if n == 15 { 'p' }\n  else if n == 16 { 'q' }\n  else if n == 17 { 'r' }\n  else if n == 18 { 's' }\n  else if n == 19 { 't' }\n  else if n == 20 { 'u' }\n  else if n == 21 { 'v' }\n  else if n == 22 { 'w' }\n  else if n == 23 { 'x' }\n  else if n == 24 { 'y' }\n  else if n == 25 { 'z' }\n  else { '|' }\n}\n\nspec fn is_lowercase(c: char) -> bool {\n  'a' <= c && c <= 'z'\n}\n\nspec fn is_uppercase(c: char) -> bool {\n  'A' <= c && c <= 'Z'\n}\n\nspec fn to_lowercase(c: char) -> char {\n  if is_uppercase(c) {\n    ((c as u8) - ('A' as u8) + ('a' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn to_uppercase(c: char) -> char {\n  if is_lowercase(c) {\n    ((c as u8) - ('a' as u8) + ('A' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {\n  let comp_char = get_comparison_char(n);\n  transform_with_comp_char(to_lowercase_string(s), comp_char)\n}\n\nspec fn to_lowercase_string(s: Seq<char>) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else {\n    s.subrange(0, 1).map(|_i: int, c: char| to_lowercase(c)) + to_lowercase_string(s.skip(1))\n  }\n}\n\nspec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else if s[0] < comp_char {\n    s.subrange(0, 1).map(|_i: int, c: char| to_uppercase(c)) + transform_with_comp_char(s.skip(1), comp_char)\n  } else {\n    s.subrange(0, 1) + transform_with_comp_char(s.skip(1), comp_char)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, n: i8) -> (result: Vec<char>)\n  requires valid_input(s@, n as int)\n  ensures result@ == transform_string(s@, n as int)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  s\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>, n: int) -> bool {\n  0 <= n <= 26\n}\n\nspec fn get_comparison_char(n: int) -> char {\n  if n == 0 { 'a' }\n  else if n == 1 { 'b' }\n  else if n == 2 { 'c' }\n  else if n == 3 { 'd' }\n  else if n == 4 { 'e' }\n  else if n == 5 { 'f' }\n  else if n == 6 { 'g' }\n  else if n == 7 { 'h' }\n  else if n == 8 { 'i' }\n  else if n == 9 { 'j' }\n  else if n == 10 { 'k' }\n  else if n == 11 { 'l' }\n  else if n == 12 { 'm' }\n  else if n == 13 { 'n' }\n  else if n == 14 { 'o' }\n  else if n == 15 { 'p' }\n  else if n == 16 { 'q' }\n  else if n == 17 { 'r' }\n  else if n == 18 { 's' }\n  else if n == 19 { 't' }\n  else if n == 20 { 'u' }\n  else if n == 21 { 'v' }\n  else if n == 22 { 'w' }\n  else if n == 23 { 'x' }\n  else if n == 24 { 'y' }\n  else if n == 25 { 'z' }\n  else { '|' }\n}\n\nspec fn is_lowercase(c: char) -> bool {\n  'a' <= c && c <= 'z'\n}\n\nspec fn is_uppercase(c: char) -> bool {\n  'A' <= c && c <= 'Z'\n}\n\nspec fn to_lowercase(c: char) -> char {\n  if is_uppercase(c) {\n    ((c as u8) - ('A' as u8) + ('a' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn to_uppercase(c: char) -> char {\n  if is_lowercase(c) {\n    ((c as u8) - ('a' as u8) + ('A' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {\n  let comp_char = get_comparison_char(n);\n  transform_with_comp_char(to_lowercase_string(s), comp_char)\n}\n\nspec fn to_lowercase_string(s: Seq<char>) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else {\n    s.subrange(0, 1).map(|_i: int, c: char| to_lowercase(c)) + to_lowercase_string(s.skip(1))\n  }\n}\n\nspec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else if s[0] < comp_char {\n    s.subrange(0, 1).map(|_i: int, c: char| to_uppercase(c)) + transform_with_comp_char(s.skip(1), comp_char)\n  } else {\n    s.subrange(0, 1) + transform_with_comp_char(s.skip(1), comp_char)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, n: i8) -> (result: Vec<char>)\n  requires valid_input(s@, n as int)\n  ensures result@ == transform_string(s@, n as int)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  s\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_529.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 818, "minimize_time_ms": 92271, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 111, "minimized_LOC": 111, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>, n: int) -> bool {\n\nspec fn get_comparison_char(n: int) -> char {\n\nspec fn is_lowercase(c: char) -> bool {\n\nspec fn is_uppercase(c: char) -> bool {\n\nspec fn to_lowercase(c: char) -> char {\n\nspec fn to_uppercase(c: char) -> char {\n\nspec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {\n\nspec fn to_lowercase_string(s: Seq<char>) -> Seq<char>\n  decreases s.len()\n{\n\nspec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>\n  decreases s.len()\n{\n\n  decreases s.len()\n\n  decreases s.len()\n\n  requires valid_input(s@, n as int)\n\n  ensures result@ == transform_string(s@, n as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>, n: int) -> bool {\n  0 <= n <= 26\n}\n\nspec fn get_comparison_char(n: int) -> char {\n  if n == 0 { 'a' }\n  else if n == 1 { 'b' }\n  else if n == 2 { 'c' }\n  else if n == 3 { 'd' }\n  else if n == 4 { 'e' }\n  else if n == 5 { 'f' }\n  else if n == 6 { 'g' }\n  else if n == 7 { 'h' }\n  else if n == 8 { 'i' }\n  else if n == 9 { 'j' }\n  else if n == 10 { 'k' }\n  else if n == 11 { 'l' }\n  else if n == 12 { 'm' }\n  else if n == 13 { 'n' }\n  else if n == 14 { 'o' }\n  else if n == 15 { 'p' }\n  else if n == 16 { 'q' }\n  else if n == 17 { 'r' }\n  else if n == 18 { 's' }\n  else if n == 19 { 't' }\n  else if n == 20 { 'u' }\n  else if n == 21 { 'v' }\n  else if n == 22 { 'w' }\n  else if n == 23 { 'x' }\n  else if n == 24 { 'y' }\n  else if n == 25 { 'z' }\n  else { '|' }\n}\n\nspec fn is_lowercase(c: char) -> bool {\n  'a' <= c && c <= 'z'\n}\n\nspec fn is_uppercase(c: char) -> bool {\n  'A' <= c && c <= 'Z'\n}\n\nspec fn to_lowercase(c: char) -> char {\n  if is_uppercase(c) {\n    ((c as u8) - ('A' as u8) + ('a' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn to_uppercase(c: char) -> char {\n  if is_lowercase(c) {\n    ((c as u8) - ('a' as u8) + ('A' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {\n  let comp_char = get_comparison_char(n);\n  transform_with_comp_char(to_lowercase_string(s), comp_char)\n}\n\nspec fn to_lowercase_string(s: Seq<char>) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else {\n    s.subrange(0, 1).map(|_i: int, c: char| to_lowercase(c)) + to_lowercase_string(s.skip(1))\n  }\n}\n\nspec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else if s[0] < comp_char {\n    s.subrange(0, 1).map(|_i: int, c: char| to_uppercase(c)) + transform_with_comp_char(s.skip(1), comp_char)\n  } else {\n    s.subrange(0, 1) + transform_with_comp_char(s.skip(1), comp_char)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, n: i8) -> (result: Vec<char>)\n  requires valid_input(s@, n as int)\n  ensures result@ == transform_string(s@, n as int)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  s\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_530_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {\n    n > 0 && a.len() == 2 * n && b.len() == 2 * n &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] == '0' || a[i] == '1') &&\n    (forall|i: int| 0 <= i < b.len() ==> b[i] == '0' || b[i] == '1')\n}\n\nspec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int\n    recommends len >= 0 && len <= a.len() && len <= b.len(),\n               ac == '0' || ac == '1',\n               bc == '0' || bc == '1'\n{\n    Set::new(|i: int| 0 <= i < len && a[i] == ac && b[i] == bc).len() as int\n}\n\nspec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {\n    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2\n}\n\nspec fn correct_outcome(result: &str, d: int) -> bool {\n    (d > 0 ==> result == \"First\") &&\n    (d < 0 ==> result == \"Second\") &&\n    (d == 0 ==> result == \"Draw\")\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<char>, b: Vec<char>) -> (result: &'static str)\n    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&\n             (forall|i: int| 0 <= i < a@.len() ==> a@[i] == '0' || a@[i] == '1') &&\n             (forall|i: int| 0 <= i < b@.len() ==> b@[i] == '0' || b@[i] == '1')\n    ensures result == \"First\" || result == \"Second\" || result == \"Draw\"\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Draw\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {\n    n > 0 && a.len() == 2 * n && b.len() == 2 * n &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] == '0' || a[i] == '1') &&\n    (forall|i: int| 0 <= i < b.len() ==> b[i] == '0' || b[i] == '1')\n}\n\nspec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int\n    recommends len >= 0 && len <= a.len() && len <= b.len(),\n               ac == '0' || ac == '1',\n               bc == '0' || bc == '1'\n{\n    Set::new(|i: int| 0 <= i < len && a[i] == ac && b[i] == bc).len() as int\n}\n\nspec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {\n    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2\n}\n\nspec fn correct_outcome(result: &str, d: int) -> bool {\n    (d > 0 ==> result == \"First\") &&\n    (d < 0 ==> result == \"Second\") &&\n    (d == 0 ==> result == \"Draw\")\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<char>, b: Vec<char>) -> (result: &'static str)\n    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&\n             (forall|i: int| 0 <= i < a@.len() ==> a@[i] == '0' || a@[i] == '1') &&\n             (forall|i: int| 0 <= i < b@.len() ==> b@[i] == '0' || b@[i] == '1')\n    ensures result == \"First\" || result == \"Second\" || result == \"Draw\"\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Draw\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_530.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 789, "minimize_time_ms": 122727, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {\n\nspec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int\n    recommends len >= 0 && len <= a.len() && len <= b.len(),\n               ac == '0' || ac == '1',\n               bc == '0' || bc == '1'\n{\n\nspec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {\n\nspec fn correct_outcome(result: &str, d: int) -> bool {\n\n    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&\n\n    ensures result == \"First\" || result == \"Second\" || result == \"Draw\""}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {\n    n > 0 && a.len() == 2 * n && b.len() == 2 * n &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] == '0' || a[i] == '1') &&\n    (forall|i: int| 0 <= i < b.len() ==> b[i] == '0' || b[i] == '1')\n}\n\nspec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int\n    recommends len >= 0 && len <= a.len() && len <= b.len(),\n               ac == '0' || ac == '1',\n               bc == '0' || bc == '1'\n{\n    Set::new(|i: int| 0 <= i < len && a[i] == ac && b[i] == bc).len() as int\n}\n\nspec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {\n    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2\n}\n\nspec fn correct_outcome(result: &str, d: int) -> bool {\n    (d > 0 ==> result == \"First\") &&\n    (d < 0 ==> result == \"Second\") &&\n    (d == 0 ==> result == \"Draw\")\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<char>, b: Vec<char>) -> (result: &'static str)\n    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&\n             (forall|i: int| 0 <= i < a@.len() ==> a@[i] == '0' || a@[i] == '1') &&\n             (forall|i: int| 0 <= i < b@.len() ==> b@[i] == '0' || b@[i] == '1')\n    ensures result == \"First\" || result == \"Second\" || result == \"Draw\"\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Draw\"\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_533_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {\n    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1\n}\n\nspec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    let max_non_sendoff_cards = (k1 - 1) * a1 + (k2 - 1) * a2;\n    if n - max_non_sendoff_cards > 0 { n - max_non_sendoff_cards } else { 0 }\n}\n\nspec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    if k1 < k2 {\n        let team1_sent = if n / k1 < a1 { n / k1 } else { a1 };\n        let remaining_cards = n - team1_sent * k1;\n        team1_sent + remaining_cards / k2\n    } else {\n        let team2_sent = if n / k2 < a2 { n / k2 } else { a2 };\n        let remaining_cards = n - team2_sent * k2;\n        team2_sent + remaining_cards / k1\n    }\n}\n\nspec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    minimum >= 0 && maximum >= 0 &&\n    minimum <= maximum &&\n    maximum <= a1 + a2 &&\n    minimum <= n &&\n    maximum <= n &&\n    minimum == minimum_sent_off(a1, a2, k1, k2, n) &&\n    maximum == maximum_sent_off(a1, a2, k1, k2, n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a1: i8, a2: i8, k1: i8, k2: i8, n: i8) -> (ret: (i8, i8))\n    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)\n    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {\n    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1\n}\n\nspec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    let max_non_sendoff_cards = (k1 - 1) * a1 + (k2 - 1) * a2;\n    if n - max_non_sendoff_cards > 0 { n - max_non_sendoff_cards } else { 0 }\n}\n\nspec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    if k1 < k2 {\n        let team1_sent = if n / k1 < a1 { n / k1 } else { a1 };\n        let remaining_cards = n - team1_sent * k1;\n        team1_sent + remaining_cards / k2\n    } else {\n        let team2_sent = if n / k2 < a2 { n / k2 } else { a2 };\n        let remaining_cards = n - team2_sent * k2;\n        team2_sent + remaining_cards / k1\n    }\n}\n\nspec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    minimum >= 0 && maximum >= 0 &&\n    minimum <= maximum &&\n    maximum <= a1 + a2 &&\n    minimum <= n &&\n    maximum <= n &&\n    minimum == minimum_sent_off(a1, a2, k1, k2, n) &&\n    maximum == maximum_sent_off(a1, a2, k1, k2, n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a1: i8, a2: i8, k1: i8, k2: i8, n: i8) -> (ret: (i8, i8))\n    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)\n    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_533.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 703, "minimize_time_ms": 93005, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {\n\nspec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n\nspec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n\nspec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n\n    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)\n\n    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {\n    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1\n}\n\nspec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    let max_non_sendoff_cards = (k1 - 1) * a1 + (k2 - 1) * a2;\n    if n - max_non_sendoff_cards > 0 { n - max_non_sendoff_cards } else { 0 }\n}\n\nspec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    if k1 < k2 {\n        let team1_sent = if n / k1 < a1 { n / k1 } else { a1 };\n        let remaining_cards = n - team1_sent * k1;\n        team1_sent + remaining_cards / k2\n    } else {\n        let team2_sent = if n / k2 < a2 { n / k2 } else { a2 };\n        let remaining_cards = n - team2_sent * k2;\n        team2_sent + remaining_cards / k1\n    }\n}\n\nspec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    minimum >= 0 && maximum >= 0 &&\n    minimum <= maximum &&\n    maximum <= a1 + a2 &&\n    minimum <= n &&\n    maximum <= n &&\n    minimum == minimum_sent_off(a1, a2, k1, k2, n) &&\n    maximum == maximum_sent_off(a1, a2, k1, k2, n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a1: i8, a2: i8, k1: i8, k2: i8, n: i8) -> (ret: (i8, i8))\n    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)\n    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_553_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    6\n}\n\nspec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {\n    if s1 == s2 { 0 } else { 6 }\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {\n    output.len() >= 2 &&\n    output[output.len() - 1] == '\\n' &&\n    ({\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        ({\n            let n: int = 6;\n            n >= 1 && \n            n == 6 &&\n            lines.len() >= 1 &&\n            ({\n                let k: int = 6;\n                0 <= k <= 6 &&\n                k == 6 &&\n                parse_integer(output.subrange(0, output.len() - 1)) == k\n            })\n        })\n    })\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires valid_input(stdin_input@.map_values(|x: u8| x as char))\n    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    6\n}\n\nspec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {\n    if s1 == s2 { 0 } else { 6 }\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {\n    output.len() >= 2 &&\n    output[output.len() - 1] == '\\n' &&\n    ({\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        ({\n            let n: int = 6;\n            n >= 1 && \n            n == 6 &&\n            lines.len() >= 1 &&\n            ({\n                let k: int = 6;\n                0 <= k <= 6 &&\n                k == 6 &&\n                parse_integer(output.subrange(0, output.len() - 1)) == k\n            })\n        })\n    })\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires valid_input(stdin_input@.map_values(|x: u8| x as char))\n    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_553.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 979, "minimize_time_ms": 92272, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_integer(s: Seq<char>) -> int {\n\nspec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {\n\n    requires valid_input(stdin_input@.map_values(|x: u8| x as char))\n\n    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    6\n}\n\nspec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {\n    if s1 == s2 { 0 } else { 6 }\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {\n    output.len() >= 2 &&\n    output[output.len() - 1] == '\\n' &&\n    ({\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        ({\n            let n: int = 6;\n            n >= 1 && \n            n == 6 &&\n            lines.len() >= 1 &&\n            ({\n                let k: int = 6;\n                0 <= k <= 6 &&\n                k == 6 &&\n                parse_integer(output.subrange(0, output.len() - 1)) == k\n            })\n        })\n    })\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires valid_input(stdin_input@.map_values(|x: u8| x as char))\n    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_584_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_letter(c: char) -> bool {\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\nspec fn valid_parentheses(input: Seq<char>) -> bool {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        true\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        is_valid_parentheses_sequence(s, 0, 0)\n    }\n}\n\nspec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool\n    recommends 0 <= pos <= s.len(), balance >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        balance == 0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            balance - 1 \n        } else { \n            balance \n        };\n        new_balance >= 0 && is_valid_parentheses_sequence(s, pos + 1, new_balance)\n    }\n}\n\nspec fn longest_word_outside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_longest_outside(s, 0, 0, 0, 0)\n    }\n}\n\nspec fn count_words_inside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_count_inside(s, 0, 0, 0)\n    }\n}\n\nspec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {\n    len_out >= 0 && count_in >= 0 &&\n    len_out == longest_word_outside(input) &&\n    count_in == count_words_inside(input)\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    find_newline_helper(input, 0)\n}\n\nspec fn find_newline_helper(input: Seq<char>, pos: int) -> int\n    recommends 0 <= pos <= input.len()\n    decreases input.len() - pos\n{\n    if pos >= input.len() {\n        pos\n    } else if input[pos] == '\\n' {\n        pos\n    } else {\n        find_newline_helper(input, pos + 1)\n    }\n}\n\nspec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        if cur > best && balance == 0 { cur } else { best }\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let new_best = if !is_letter(c) && cur > 0 && balance == 0 {\n            if cur > best { cur } else { best }\n        } else { \n            best \n        };\n        compute_longest_outside(s, pos + 1, new_balance, new_cur, new_best)\n    }\n}\n\nspec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let word_ended = !is_letter(c) && cur > 0;\n        let count_increment: int = if word_ended && balance > 0 { 1 } else { 0 };\n        count_increment + compute_count_inside(s, pos + 1, new_balance, new_cur)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: (usize, usize))\n    requires\n        input@.len() > 0,\n        exists|i: int| 0 <= i < input@.len() && input@[i] == '\\n',\n        forall|i: int| 0 <= i < input@.len() ==> (is_letter(input@[i]) || input@[i] == '_' || input@[i] == '(' || input@[i] == ')' || input@[i] == '\\n' || input@[i] == '\\r' || ('0' <= input@[i] <= '9')),\n        valid_parentheses(input@)\n    ensures\n        result.0 >= 0 && result.1 >= 0,\n        result.0 as int == longest_word_outside(input@),\n        result.1 as int == count_words_inside(input@),\n        valid_output(input@, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_letter(c: char) -> bool {\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\nspec fn valid_parentheses(input: Seq<char>) -> bool {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        true\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        is_valid_parentheses_sequence(s, 0, 0)\n    }\n}\n\nspec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool\n    recommends 0 <= pos <= s.len(), balance >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        balance == 0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            balance - 1 \n        } else { \n            balance \n        };\n        new_balance >= 0 && is_valid_parentheses_sequence(s, pos + 1, new_balance)\n    }\n}\n\nspec fn longest_word_outside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_longest_outside(s, 0, 0, 0, 0)\n    }\n}\n\nspec fn count_words_inside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_count_inside(s, 0, 0, 0)\n    }\n}\n\nspec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {\n    len_out >= 0 && count_in >= 0 &&\n    len_out == longest_word_outside(input) &&\n    count_in == count_words_inside(input)\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    find_newline_helper(input, 0)\n}\n\nspec fn find_newline_helper(input: Seq<char>, pos: int) -> int\n    recommends 0 <= pos <= input.len()\n    decreases input.len() - pos\n{\n    if pos >= input.len() {\n        pos\n    } else if input[pos] == '\\n' {\n        pos\n    } else {\n        find_newline_helper(input, pos + 1)\n    }\n}\n\nspec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        if cur > best && balance == 0 { cur } else { best }\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let new_best = if !is_letter(c) && cur > 0 && balance == 0 {\n            if cur > best { cur } else { best }\n        } else { \n            best \n        };\n        compute_longest_outside(s, pos + 1, new_balance, new_cur, new_best)\n    }\n}\n\nspec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let word_ended = !is_letter(c) && cur > 0;\n        let count_increment: int = if word_ended && balance > 0 { 1 } else { 0 };\n        count_increment + compute_count_inside(s, pos + 1, new_balance, new_cur)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: (usize, usize))\n    requires\n        input@.len() > 0,\n        exists|i: int| 0 <= i < input@.len() && input@[i] == '\\n',\n        forall|i: int| 0 <= i < input@.len() ==> (is_letter(input@[i]) || input@[i] == '_' || input@[i] == '(' || input@[i] == ')' || input@[i] == '\\n' || input@[i] == '\\r' || ('0' <= input@[i] <= '9')),\n        valid_parentheses(input@)\n    ensures\n        result.0 >= 0 && result.1 >= 0,\n        result.0 as int == longest_word_outside(input@),\n        result.1 as int == count_words_inside(input@),\n        valid_output(input@, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_584.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 937, "minimize_time_ms": 92205, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 182, "minimized_LOC": 182, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_letter(c: char) -> bool {\n\nspec fn valid_parentheses(input: Seq<char>) -> bool {\n\nspec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool\n    recommends 0 <= pos <= s.len(), balance >= 0\n    decreases s.len() - pos\n{\n\nspec fn longest_word_outside(input: Seq<char>) -> int {\n\nspec fn count_words_inside(input: Seq<char>) -> int {\n\nspec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {\n\nspec fn find_newline(input: Seq<char>) -> int {\n\nspec fn find_newline_helper(input: Seq<char>, pos: int) -> int\n    recommends 0 <= pos <= input.len()\n    decreases input.len() - pos\n{\n\nspec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0\n    decreases s.len() - pos\n{\n\nspec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0\n    decreases s.len() - pos\n{\n\n    decreases s.len() - pos\n\n    decreases input.len() - pos\n\n    decreases s.len() - pos\n\n    decreases s.len() - pos\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_letter(c: char) -> bool {\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\nspec fn valid_parentheses(input: Seq<char>) -> bool {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        true\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        is_valid_parentheses_sequence(s, 0, 0)\n    }\n}\n\nspec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool\n    recommends 0 <= pos <= s.len(), balance >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        balance == 0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            balance - 1 \n        } else { \n            balance \n        };\n        new_balance >= 0 && is_valid_parentheses_sequence(s, pos + 1, new_balance)\n    }\n}\n\nspec fn longest_word_outside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_longest_outside(s, 0, 0, 0, 0)\n    }\n}\n\nspec fn count_words_inside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_count_inside(s, 0, 0, 0)\n    }\n}\n\nspec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {\n    len_out >= 0 && count_in >= 0 &&\n    len_out == longest_word_outside(input) &&\n    count_in == count_words_inside(input)\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    find_newline_helper(input, 0)\n}\n\nspec fn find_newline_helper(input: Seq<char>, pos: int) -> int\n    recommends 0 <= pos <= input.len()\n    decreases input.len() - pos\n{\n    if pos >= input.len() {\n        pos\n    } else if input[pos] == '\\n' {\n        pos\n    } else {\n        find_newline_helper(input, pos + 1)\n    }\n}\n\nspec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        if cur > best && balance == 0 { cur } else { best }\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let new_best = if !is_letter(c) && cur > 0 && balance == 0 {\n            if cur > best { cur } else { best }\n        } else { \n            best \n        };\n        compute_longest_outside(s, pos + 1, new_balance, new_cur, new_best)\n    }\n}\n\nspec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let word_ended = !is_letter(c) && cur > 0;\n        let count_increment: int = if word_ended && balance > 0 { 1 } else { 0 };\n        count_increment + compute_count_inside(s, pos + 1, new_balance, new_cur)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: (usize, usize))\n    requires\n        input@.len() > 0,\n        exists|i: int| 0 <= i < input@.len() && input@[i] == '\\n',\n        forall|i: int| 0 <= i < input@.len() ==> (is_letter(input@[i]) || input@[i] == '_' || input@[i] == '(' || input@[i] == ')' || input@[i] == '\\n' || input@[i] == '\\r' || ('0' <= input@[i] <= '9')),\n        valid_parentheses(input@)\n    ensures\n        result.0 >= 0 && result.1 >= 0,\n        result.0 as int == longest_word_outside(input@),\n        result.1 as int == count_words_inside(input@),\n        valid_output(input@, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_59_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {\n    n >= 2 &&\n    a.len() == n &&\n    p.len() == n - 1 &&\n    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] == '0' || #[trigger] p[i] == '1') &&\n    (forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= n) &&\n    a.to_set() =~= Set::new(|i: int| 1 <= i <= n)\n}\n\nspec fn max_up_to(a: Seq<int>, i: int) -> int\n    recommends 0 <= i < a.len()\n    decreases i when i >= 0\n{\n    if i == 0 { \n        a[0] \n    } else if i > 0 && a[i] > max_up_to(a, i-1) { \n        a[i] \n    } else if i > 0 { \n        max_up_to(a, i-1) \n    } else {\n        a[0]\n    }\n}\n\nspec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool\n    recommends valid_input(n, a, p)\n{\n    forall|i: int| 0 <= i < n - 1 ==> \n        (#[trigger] p[i] == '0' ==> max_up_to(a, i) <= i + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>, p: Vec<char>) -> (result: String)\n    requires\n        valid_input(n as int, a@.map(|i, x| x as int), p@),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> can_sort(n as int, a@.map(|i, x| x as int), p@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {\n    n >= 2 &&\n    a.len() == n &&\n    p.len() == n - 1 &&\n    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] == '0' || #[trigger] p[i] == '1') &&\n    (forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= n) &&\n    a.to_set() =~= Set::new(|i: int| 1 <= i <= n)\n}\n\nspec fn max_up_to(a: Seq<int>, i: int) -> int\n    recommends 0 <= i < a.len()\n    decreases i when i >= 0\n{\n    if i == 0 { \n        a[0] \n    } else if i > 0 && a[i] > max_up_to(a, i-1) { \n        a[i] \n    } else if i > 0 { \n        max_up_to(a, i-1) \n    } else {\n        a[0]\n    }\n}\n\nspec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool\n    recommends valid_input(n, a, p)\n{\n    forall|i: int| 0 <= i < n - 1 ==> \n        (#[trigger] p[i] == '0' ==> max_up_to(a, i) <= i + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>, p: Vec<char>) -> (result: String)\n    requires\n        valid_input(n as int, a@.map(|i, x| x as int), p@),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> can_sort(n as int, a@.map(|i, x| x as int), p@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_59.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 824, "minimize_time_ms": 123211, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {\n\nspec fn max_up_to(a: Seq<int>, i: int) -> int\n    recommends 0 <= i < a.len()\n    decreases i when i >= 0\n{\n\nspec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool\n    recommends valid_input(n, a, p)\n{\n\n    decreases i when i >= 0\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {\n    n >= 2 &&\n    a.len() == n &&\n    p.len() == n - 1 &&\n    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] == '0' || #[trigger] p[i] == '1') &&\n    (forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= n) &&\n    a.to_set() =~= Set::new(|i: int| 1 <= i <= n)\n}\n\nspec fn max_up_to(a: Seq<int>, i: int) -> int\n    recommends 0 <= i < a.len()\n    decreases i when i >= 0\n{\n    if i == 0 { \n        a[0] \n    } else if i > 0 && a[i] > max_up_to(a, i-1) { \n        a[i] \n    } else if i > 0 { \n        max_up_to(a, i-1) \n    } else {\n        a[0]\n    }\n}\n\nspec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool\n    recommends valid_input(n, a, p)\n{\n    forall|i: int| 0 <= i < n - 1 ==> \n        (#[trigger] p[i] == '0' ==> max_up_to(a, i) <= i + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>, p: Vec<char>) -> (result: String)\n    requires\n        valid_input(n as int, a@.map(|i, x| x as int), p@),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> can_sort(n as int, a@.map(|i, x| x as int), p@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::*;\nfn main() {}\n", "use vstd;\n   fn main() {\n }\n"]}
{"id": "apps_test_613_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(t: int, a: int, b: int) -> bool {\n    t > 0 && a > 0 && b > 0\n}\n\nspec fn valid_output(res: String) -> bool {\n    res@ == \"0\"@ || res@ == \"1\"@ || res@ == \"2\"@ || res@ == \"inf\"@\n}\n\nspec fn infinite_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a == 1\n}\n\nspec fn two_solutions_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a != 1\n}\n\nspec fn zero_solutions_case(t: int, a: int, b: int) -> bool {\n    (t == 2 && a == 3 && b > 10000) ||\n    (a == t && a != b) ||\n    (a != t && (a - b) % (t - a) == 0) ||\n    (a != t && (a - b) % (t - a) != 0 && t == b)\n}\n\nspec fn one_solution_case(t: int, a: int, b: int) -> bool {\n    a != t && (a - b) % (t - a) != 0 && t != b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: i8, a: i8, b: i8) -> (res: String)\n    requires \n        valid_input(t as int, a as int, b as int),\n    ensures \n        valid_output(res),\n        infinite_case(t as int, a as int, b as int) ==> res@ == \"inf\"@,\n        two_solutions_case(t as int, a as int, b as int) ==> res@ == \"2\"@,\n        zero_solutions_case(t as int, a as int, b as int) ==> res@ == \"0\"@,\n        one_solution_case(t as int, a as int, b as int) ==> res@ == \"1\"@\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(t: int, a: int, b: int) -> bool {\n    t > 0 && a > 0 && b > 0\n}\n\nspec fn valid_output(res: String) -> bool {\n    res@ == \"0\"@ || res@ == \"1\"@ || res@ == \"2\"@ || res@ == \"inf\"@\n}\n\nspec fn infinite_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a == 1\n}\n\nspec fn two_solutions_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a != 1\n}\n\nspec fn zero_solutions_case(t: int, a: int, b: int) -> bool {\n    (t == 2 && a == 3 && b > 10000) ||\n    (a == t && a != b) ||\n    (a != t && (a - b) % (t - a) == 0) ||\n    (a != t && (a - b) % (t - a) != 0 && t == b)\n}\n\nspec fn one_solution_case(t: int, a: int, b: int) -> bool {\n    a != t && (a - b) % (t - a) != 0 && t != b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: i8, a: i8, b: i8) -> (res: String)\n    requires \n        valid_input(t as int, a as int, b as int),\n    ensures \n        valid_output(res),\n        infinite_case(t as int, a as int, b as int) ==> res@ == \"inf\"@,\n        two_solutions_case(t as int, a as int, b as int) ==> res@ == \"2\"@,\n        zero_solutions_case(t as int, a as int, b as int) ==> res@ == \"0\"@,\n        one_solution_case(t as int, a as int, b as int) ==> res@ == \"1\"@\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_613.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 740, "minimize_time_ms": 92290, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(t: int, a: int, b: int) -> bool {\n\nspec fn valid_output(res: String) -> bool {\n\nspec fn infinite_case(t: int, a: int, b: int) -> bool {\n\nspec fn two_solutions_case(t: int, a: int, b: int) -> bool {\n\nspec fn zero_solutions_case(t: int, a: int, b: int) -> bool {\n\nspec fn one_solution_case(t: int, a: int, b: int) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(t: int, a: int, b: int) -> bool {\n    t > 0 && a > 0 && b > 0\n}\n\nspec fn valid_output(res: String) -> bool {\n    res@ == \"0\"@ || res@ == \"1\"@ || res@ == \"2\"@ || res@ == \"inf\"@\n}\n\nspec fn infinite_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a == 1\n}\n\nspec fn two_solutions_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a != 1\n}\n\nspec fn zero_solutions_case(t: int, a: int, b: int) -> bool {\n    (t == 2 && a == 3 && b > 10000) ||\n    (a == t && a != b) ||\n    (a != t && (a - b) % (t - a) == 0) ||\n    (a != t && (a - b) % (t - a) != 0 && t == b)\n}\n\nspec fn one_solution_case(t: int, a: int, b: int) -> bool {\n    a != t && (a - b) % (t - a) != 0 && t != b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: i8, a: i8, b: i8) -> (res: String)\n    requires \n        valid_input(t as int, a as int, b as int),\n    ensures \n        valid_output(res),\n        infinite_case(t as int, a as int, b as int) ==> res@ == \"inf\"@,\n        two_solutions_case(t as int, a as int, b as int) ==> res@ == \"2\"@,\n        zero_solutions_case(t as int, a as int, b as int) ==> res@ == \"0\"@,\n        one_solution_case(t as int, a as int, b as int) ==> res@ == \"1\"@\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_641_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    ({\n        let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n        let parts = split_on_space(trimmed);\n        parts.len() >= 1\n    })\n}\n\nspec fn get_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n    let parts = split_on_space(trimmed);\n    if parts[parts.len() as int - 1] == seq!['m', 'o', 'n', 't', 'h'] {\n        if parts[0] == seq!['3', '1'] { seq!['7', '\\n'] }\n        else if parts[0] == seq!['3', '0'] { seq!['1', '1', '\\n'] }\n        else { seq!['1', '2', '\\n'] }\n    } else {\n        if parts[0] == seq!['5'] || parts[0] == seq!['6'] { seq!['5', '3', '\\n'] }\n        else { seq!['5', '2', '\\n'] }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == get_expected_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    ({\n        let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n        let parts = split_on_space(trimmed);\n        parts.len() >= 1\n    })\n}\n\nspec fn get_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n    let parts = split_on_space(trimmed);\n    if parts[parts.len() as int - 1] == seq!['m', 'o', 'n', 't', 'h'] {\n        if parts[0] == seq!['3', '1'] { seq!['7', '\\n'] }\n        else if parts[0] == seq!['3', '0'] { seq!['1', '1', '\\n'] }\n        else { seq!['1', '2', '\\n'] }\n    } else {\n        if parts[0] == seq!['5'] || parts[0] == seq!['6'] { seq!['5', '3', '\\n'] }\n        else { seq!['5', '2', '\\n'] }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == get_expected_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_641.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 947, "minimize_time_ms": 92228, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn get_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n\n    requires valid_input(input@)\n\n    ensures result@ == get_expected_result(input@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    ({\n        let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n        let parts = split_on_space(trimmed);\n        parts.len() >= 1\n    })\n}\n\nspec fn get_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n    let parts = split_on_space(trimmed);\n    if parts[parts.len() as int - 1] == seq!['m', 'o', 'n', 't', 'h'] {\n        if parts[0] == seq!['3', '1'] { seq!['7', '\\n'] }\n        else if parts[0] == seq!['3', '0'] { seq!['1', '1', '\\n'] }\n        else { seq!['1', '2', '\\n'] }\n    } else {\n        if parts[0] == seq!['5'] || parts[0] == seq!['6'] { seq!['5', '3', '\\n'] }\n        else { seq!['5', '2', '\\n'] }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == get_expected_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_65_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn seq_min(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n    arr.len() >= 2 && \n    exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr[i] == #[trigger] arr[j] && arr[i] == seq_min(arr)\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {\n    arr@.map(|i, v| v as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(arr: Vec<i8>) -> (result: u8)\n    requires \n        valid_input(arr_to_seq(arr)),\n    ensures \n        result > 0,\n        result as int <= arr.len() - 1,\n        exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) && j - i == result as int,\n        forall|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) ==> j - i >= result as int,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn seq_min(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n    arr.len() >= 2 && \n    exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr[i] == #[trigger] arr[j] && arr[i] == seq_min(arr)\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {\n    arr@.map(|i, v| v as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(arr: Vec<i8>) -> (result: u8)\n    requires \n        valid_input(arr_to_seq(arr)),\n    ensures \n        result > 0,\n        result as int <= arr.len() - 1,\n        exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) && j - i == result as int,\n        forall|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) ==> j - i >= result as int,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_65.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 823, "minimize_time_ms": 123388, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn seq_min(s: Seq<int>) -> int \n    decreases s.len()\n{\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n\nspec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn seq_min(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n    arr.len() >= 2 && \n    exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr[i] == #[trigger] arr[j] && arr[i] == seq_min(arr)\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {\n    arr@.map(|i, v| v as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(arr: Vec<i8>) -> (result: u8)\n    requires \n        valid_input(arr_to_seq(arr)),\n    ensures \n        result > 0,\n        result as int <= arr.len() - 1,\n        exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) && j - i == result as int,\n        forall|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) ==> j - i >= result as int,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_66_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn gcd(a: int, b: int) -> int \n    decreases (if b == 0 { 0 } else { abs(b) })\n{\n    if b == 0 { abs(a) } else { gcd(b, a % b) }\n}\n\nspec fn valid_input(t: int, w: int, b: int) -> bool {\n    t > 0 && w > 0 && b > 0\n}\n\nspec fn valid_fraction(numerator: int, denominator: int) -> bool {\n    numerator >= 0 && denominator > 0 && numerator <= denominator\n}\n\nspec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool\n    recommends valid_fraction(numerator, denominator)\n{\n    gcd(numerator, denominator) == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: u64, w: u64, b: u64) -> (result: (u64, u64))\n    requires\n        t > 0 && w > 0 && b > 0,\n    ensures\n        result.1 > 0,\n        result.0 <= result.1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 1)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn gcd(a: int, b: int) -> int \n    decreases (if b == 0 { 0 } else { abs(b) })\n{\n    if b == 0 { abs(a) } else { gcd(b, a % b) }\n}\n\nspec fn valid_input(t: int, w: int, b: int) -> bool {\n    t > 0 && w > 0 && b > 0\n}\n\nspec fn valid_fraction(numerator: int, denominator: int) -> bool {\n    numerator >= 0 && denominator > 0 && numerator <= denominator\n}\n\nspec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool\n    recommends valid_fraction(numerator, denominator)\n{\n    gcd(numerator, denominator) == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: u64, w: u64, b: u64) -> (result: (u64, u64))\n    requires\n        t > 0 && w > 0 && b > 0,\n    ensures\n        result.1 > 0,\n        result.0 <= result.1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 1)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_66.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 870, "minimize_time_ms": 92349, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn abs(x: int) -> int {\n\nspec fn gcd(a: int, b: int) -> int \n    decreases (if b == 0 {\n\nspec fn valid_input(t: int, w: int, b: int) -> bool {\n\nspec fn valid_fraction(numerator: int, denominator: int) -> bool {\n\nspec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool\n    recommends valid_fraction(numerator, denominator)\n{\n\n    decreases (if b == 0 { 0 } else { abs(b) })\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn gcd(a: int, b: int) -> int \n    decreases (if b == 0 { 0 } else { abs(b) })\n{\n    if b == 0 { abs(a) } else { gcd(b, a % b) }\n}\n\nspec fn valid_input(t: int, w: int, b: int) -> bool {\n    t > 0 && w > 0 && b > 0\n}\n\nspec fn valid_fraction(numerator: int, denominator: int) -> bool {\n    numerator >= 0 && denominator > 0 && numerator <= denominator\n}\n\nspec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool\n    recommends valid_fraction(numerator, denominator)\n{\n    gcd(numerator, denominator) == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: u64, w: u64, b: u64) -> (result: (u64, u64))\n    requires\n        t > 0 && w > 0 && b > 0,\n    ensures\n        result.1 > 0,\n        result.0 <= result.1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 1)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_682_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_position(r: int, c: int) -> bool {\n    1 <= r <= 8 && 1 <= c <= 8\n}\n\nspec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else if r1 == r2 || c1 == c2 {\n        1\n    } else {\n        2\n    }\n}\n\nspec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else {\n        let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n        let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n        if row_diff == col_diff {\n            1\n        } else if (r1 + c1) % 2 == (r2 + c2) % 2 {\n            2\n        } else {\n            0\n        }\n    }\n}\n\nspec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n    let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n    if row_diff >= col_diff { row_diff } else { col_diff }\n}\n\nspec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    result.len() == 3 &&\n    result[0] == rook_moves(r1, c1, r2, c2) &&\n    result[1] == bishop_moves(r1, c1, r2, c2) &&\n    result[2] == king_moves(r1, c1, r2, c2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(r1: i8, c1: i8, r2: i8, c2: i8) -> (result: Vec<i8>)\n    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)\n    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_position(r: int, c: int) -> bool {\n    1 <= r <= 8 && 1 <= c <= 8\n}\n\nspec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else if r1 == r2 || c1 == c2 {\n        1\n    } else {\n        2\n    }\n}\n\nspec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else {\n        let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n        let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n        if row_diff == col_diff {\n            1\n        } else if (r1 + c1) % 2 == (r2 + c2) % 2 {\n            2\n        } else {\n            0\n        }\n    }\n}\n\nspec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n    let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n    if row_diff >= col_diff { row_diff } else { col_diff }\n}\n\nspec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    result.len() == 3 &&\n    result[0] == rook_moves(r1, c1, r2, c2) &&\n    result[1] == bishop_moves(r1, c1, r2, c2) &&\n    result[2] == king_moves(r1, c1, r2, c2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(r1: i8, c1: i8, r2: i8, c2: i8) -> (result: Vec<i8>)\n    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)\n    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_682.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 920, "minimize_time_ms": 92118, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 76, "minimized_LOC": 76, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_position(r: int, c: int) -> bool {\n\nspec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n\nspec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n\nspec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n\nspec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n\n    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)\n\n    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_position(r: int, c: int) -> bool {\n    1 <= r <= 8 && 1 <= c <= 8\n}\n\nspec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else if r1 == r2 || c1 == c2 {\n        1\n    } else {\n        2\n    }\n}\n\nspec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else {\n        let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n        let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n        if row_diff == col_diff {\n            1\n        } else if (r1 + c1) % 2 == (r2 + c2) % 2 {\n            2\n        } else {\n            0\n        }\n    }\n}\n\nspec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n    let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n    if row_diff >= col_diff { row_diff } else { col_diff }\n}\n\nspec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    result.len() == 3 &&\n    result[0] == rook_moves(r1, c1, r2, c2) &&\n    result[1] == bishop_moves(r1, c1, r2, c2) &&\n    result[2] == king_moves(r1, c1, r2, c2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(r1: i8, c1: i8, r2: i8, c2: i8) -> (result: Vec<i8>)\n    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)\n    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_703_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn valid_input(k: int, a: int, b: int, v: int) -> bool {\n    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000\n}\n\nspec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int\n    recommends num_boxes >= 0\n{\n    v * (num_boxes + min(b, (k - 1) * num_boxes))\n}\n\nspec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool\n    recommends num_boxes >= 0\n{\n    a <= box_capacity(num_boxes, k, b, v)\n}\n\nspec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool\n    recommends result >= 1\n{\n    can_store_nuts(result, k, a, b, v) &&\n    (result == 1 || !can_store_nuts(result - 1, k, a, b, v))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, a: i8, b: i8, v: i8) -> (result: i8)\n    requires\n        valid_input(k as int, a as int, b as int, v as int)\n    ensures\n        result >= 1,\n        result <= 127,\n        is_minimal_solution(result as int, k as int, a as int, b as int, v as int),\n        exists|i: int| 1 <= i <= 127 && can_store_nuts(i, k as int, a as int, b as int, v as int) && result as int == i && \n            (forall|j: int| 1 <= j < i ==> !can_store_nuts(j, k as int, a as int, b as int, v as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn valid_input(k: int, a: int, b: int, v: int) -> bool {\n    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000\n}\n\nspec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int\n    recommends num_boxes >= 0\n{\n    v * (num_boxes + min(b, (k - 1) * num_boxes))\n}\n\nspec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool\n    recommends num_boxes >= 0\n{\n    a <= box_capacity(num_boxes, k, b, v)\n}\n\nspec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool\n    recommends result >= 1\n{\n    can_store_nuts(result, k, a, b, v) &&\n    (result == 1 || !can_store_nuts(result - 1, k, a, b, v))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, a: i8, b: i8, v: i8) -> (result: i8)\n    requires\n        valid_input(k as int, a as int, b as int, v as int)\n    ensures\n        result >= 1,\n        result <= 127,\n        is_minimal_solution(result as int, k as int, a as int, b as int, v as int),\n        exists|i: int| 1 <= i <= 127 && can_store_nuts(i, k as int, a as int, b as int, v as int) && result as int == i && \n            (forall|j: int| 1 <= j < i ==> !can_store_nuts(j, k as int, a as int, b as int, v as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_703.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 734, "minimize_time_ms": 92821, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn min(x: int, y: int) -> int {\n\nspec fn valid_input(k: int, a: int, b: int, v: int) -> bool {\n\nspec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int\n    recommends num_boxes >= 0\n{\n\nspec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool\n    recommends num_boxes >= 0\n{\n\nspec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool\n    recommends result >= 1\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn valid_input(k: int, a: int, b: int, v: int) -> bool {\n    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000\n}\n\nspec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int\n    recommends num_boxes >= 0\n{\n    v * (num_boxes + min(b, (k - 1) * num_boxes))\n}\n\nspec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool\n    recommends num_boxes >= 0\n{\n    a <= box_capacity(num_boxes, k, b, v)\n}\n\nspec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool\n    recommends result >= 1\n{\n    can_store_nuts(result, k, a, b, v) &&\n    (result == 1 || !can_store_nuts(result - 1, k, a, b, v))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, a: i8, b: i8, v: i8) -> (result: i8)\n    requires\n        valid_input(k as int, a as int, b as int, v as int)\n    ensures\n        result >= 1,\n        result <= 127,\n        is_minimal_solution(result as int, k as int, a as int, b as int, v as int),\n        exists|i: int| 1 <= i <= 127 && can_store_nuts(i, k as int, a as int, b as int, v as int) && result as int == i && \n            (forall|j: int| 1 <= j < i ==> !can_store_nuts(j, k as int, a as int, b as int, v as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_719_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn int_to_string(n: int) -> Seq<char> {\n    unimplemented!()\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|k: int| k >= 1 && k <= 10000 && stdin_input == int_to_string(k).push('\\n')\n}\n\nspec fn kth_perfect_number(k: int) -> int\n    recommends k >= 1 && k <= 10000\n{\n    if k == 1 { 19 }\n    else if k == 2 { 28 }\n    else if k == 3 { 37 }\n    else if k == 4 { 46 }\n    else if k == 5 { 55 }\n    else if k == 6 { 64 }\n    else if k == 7 { 73 }\n    else if k == 8 { 82 }\n    else if k == 9 { 91 }\n    else if k == 10 { 109 }\n    else { 10 * (k - 9) + 99 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures (exists|k: int| k >= 1 && k <= 10000 && \n        stdin_input@ == int_to_string(k).push('\\n') &&\n        result@ == int_to_string(kth_perfect_number(k)).push('\\n')) &&\n        result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn int_to_string(n: int) -> Seq<char> {\n    unimplemented!()\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|k: int| k >= 1 && k <= 10000 && stdin_input == int_to_string(k).push('\\n')\n}\n\nspec fn kth_perfect_number(k: int) -> int\n    recommends k >= 1 && k <= 10000\n{\n    if k == 1 { 19 }\n    else if k == 2 { 28 }\n    else if k == 3 { 37 }\n    else if k == 4 { 46 }\n    else if k == 5 { 55 }\n    else if k == 6 { 64 }\n    else if k == 7 { 73 }\n    else if k == 8 { 82 }\n    else if k == 9 { 91 }\n    else if k == 10 { 109 }\n    else { 10 * (k - 9) + 99 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures (exists|k: int| k >= 1 && k <= 10000 && \n        stdin_input@ == int_to_string(k).push('\\n') &&\n        result@ == int_to_string(kth_perfect_number(k)).push('\\n')) &&\n        result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_719.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 779, "minimize_time_ms": 122287, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn kth_perfect_number(k: int) -> int\n    recommends k >= 1 && k <= 10000\n{\n\n    requires valid_input(stdin_input@)\n\n    ensures (exists|k: int| k >= 1 && k <= 10000 && "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn int_to_string(n: int) -> Seq<char> {\n    unimplemented!()\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|k: int| k >= 1 && k <= 10000 && stdin_input == int_to_string(k).push('\\n')\n}\n\nspec fn kth_perfect_number(k: int) -> int\n    recommends k >= 1 && k <= 10000\n{\n    if k == 1 { 19 }\n    else if k == 2 { 28 }\n    else if k == 3 { 37 }\n    else if k == 4 { 46 }\n    else if k == 5 { 55 }\n    else if k == 6 { 64 }\n    else if k == 7 { 73 }\n    else if k == 8 { 82 }\n    else if k == 9 { 91 }\n    else if k == 10 { 109 }\n    else { 10 * (k - 9) + 99 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures (exists|k: int| k >= 1 && k <= 10000 && \n        stdin_input@ == int_to_string(k).push('\\n') &&\n        result@ == int_to_string(kth_perfect_number(k)).push('\\n')) &&\n        result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_736_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    n > 0 && n <= 10000 && m > 1 && m <= 10\n}\n\nspec fn min_moves(n: int) -> int\n    recommends n > 0\n{\n    if n % 2 == 0 { n / 2 } else { n / 2 + 1 }\n}\n\nspec fn valid_move_count(n: int, k: int) -> bool\n    recommends n > 0\n{\n    min_moves(n) <= k <= n\n}\n\nspec fn is_valid_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 || (result > 0 && result % m == 0 && valid_move_count(n, result))\n}\n\nspec fn no_smaller_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 ==> forall|k: int| min_moves(n) <= k <= n ==> #[trigger] (k % m) != 0\n}\n\nspec fn is_minimal_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result != -1 ==> forall|k: int| (min_moves(n) <= k <= n && k < result) ==> #[trigger] (k % m) != 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        is_valid_solution(n as int, m as int, result as int) &&\n        no_smaller_solution(n as int, m as int, result as int) &&\n        is_minimal_solution(n as int, m as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    n > 0 && n <= 10000 && m > 1 && m <= 10\n}\n\nspec fn min_moves(n: int) -> int\n    recommends n > 0\n{\n    if n % 2 == 0 { n / 2 } else { n / 2 + 1 }\n}\n\nspec fn valid_move_count(n: int, k: int) -> bool\n    recommends n > 0\n{\n    min_moves(n) <= k <= n\n}\n\nspec fn is_valid_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 || (result > 0 && result % m == 0 && valid_move_count(n, result))\n}\n\nspec fn no_smaller_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 ==> forall|k: int| min_moves(n) <= k <= n ==> #[trigger] (k % m) != 0\n}\n\nspec fn is_minimal_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result != -1 ==> forall|k: int| (min_moves(n) <= k <= n && k < result) ==> #[trigger] (k % m) != 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        is_valid_solution(n as int, m as int, result as int) &&\n        no_smaller_solution(n as int, m as int, result as int) &&\n        is_minimal_solution(n as int, m as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_736.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 720, "minimize_time_ms": 122421, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int) -> bool {\n\nspec fn min_moves(n: int) -> int\n    recommends n > 0\n{\n\nspec fn valid_move_count(n: int, k: int) -> bool\n    recommends n > 0\n{\n\nspec fn is_valid_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n\nspec fn no_smaller_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n\nspec fn is_minimal_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    n > 0 && n <= 10000 && m > 1 && m <= 10\n}\n\nspec fn min_moves(n: int) -> int\n    recommends n > 0\n{\n    if n % 2 == 0 { n / 2 } else { n / 2 + 1 }\n}\n\nspec fn valid_move_count(n: int, k: int) -> bool\n    recommends n > 0\n{\n    min_moves(n) <= k <= n\n}\n\nspec fn is_valid_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 || (result > 0 && result % m == 0 && valid_move_count(n, result))\n}\n\nspec fn no_smaller_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 ==> forall|k: int| min_moves(n) <= k <= n ==> #[trigger] (k % m) != 0\n}\n\nspec fn is_minimal_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result != -1 ==> forall|k: int| (min_moves(n) <= k <= n && k < result) ==> #[trigger] (k % m) != 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        is_valid_solution(n as int, m as int, result as int) &&\n        no_smaller_solution(n as int, m as int, result as int) &&\n        is_minimal_solution(n as int, m as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_744_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_sf_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'F' && s[s.len()-2] != 'F' { 1int } else { 0int }) + count_sf_flights(s.subrange(0, s.len()-1))\n    }\n}\n\nspec fn count_fs_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'S' && s[s.len()-2] != 'S' { 1int } else { 0int }) + count_fs_flights(s.subrange(0, s.len()-1))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 2,\n        s@.len() == n,\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'S' || s@[i] == 'F',\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> count_sf_flights(s@) > count_fs_flights(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_sf_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'F' && s[s.len()-2] != 'F' { 1int } else { 0int }) + count_sf_flights(s.subrange(0, s.len()-1))\n    }\n}\n\nspec fn count_fs_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'S' && s[s.len()-2] != 'S' { 1int } else { 0int }) + count_fs_flights(s.subrange(0, s.len()-1))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 2,\n        s@.len() == n,\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'S' || s@[i] == 'F',\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> count_sf_flights(s@) > count_fs_flights(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_744.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 915, "minimize_time_ms": 123694, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_sf_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn count_fs_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_sf_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'F' && s[s.len()-2] != 'F' { 1int } else { 0int }) + count_sf_flights(s.subrange(0, s.len()-1))\n    }\n}\n\nspec fn count_fs_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'S' && s[s.len()-2] != 'S' { 1int } else { 0int }) + count_fs_flights(s.subrange(0, s.len()-1))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 2,\n        s@.len() == n,\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'S' || s@[i] == 'F',\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> count_sf_flights(s@) > count_fs_flights(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_748_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, numbers: Seq<int>) -> bool {\n    n >= 3 && n % 3 == 0 &&\n    numbers.len() == n &&\n    forall|i: int| 0 <= i < numbers.len() ==> 1 <= #[trigger] numbers[i] && #[trigger] numbers[i] <= 7\n}\n\nspec fn valid_triplet(triplet: Seq<int>) -> bool {\n    triplet.len() == 3 &&\n    triplet[0] < triplet[1] && triplet[1] < triplet[2] &&\n    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&\n    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0\n}\n\nspec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>\n    decreases result.len()\n{\n    if result.len() == 0 { \n        seq![]\n    } else {\n        result[0].add(flatten_partition(result.subrange(1, result.len() as int)))\n    }\n}\n\nspec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {\n    result.len() == numbers.len() / 3 &&\n    (forall|i: int| 0 <= i < result.len() ==> valid_triplet(#[trigger] result[i])) &&\n    numbers.to_multiset() == flatten_partition(result).to_multiset()\n}\n\nspec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {\n    result.len() == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, numbers: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, numbers: Seq<int>) -> bool {\n    n >= 3 && n % 3 == 0 &&\n    numbers.len() == n &&\n    forall|i: int| 0 <= i < numbers.len() ==> 1 <= #[trigger] numbers[i] && #[trigger] numbers[i] <= 7\n}\n\nspec fn valid_triplet(triplet: Seq<int>) -> bool {\n    triplet.len() == 3 &&\n    triplet[0] < triplet[1] && triplet[1] < triplet[2] &&\n    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&\n    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0\n}\n\nspec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>\n    decreases result.len()\n{\n    if result.len() == 0 { \n        seq![]\n    } else {\n        result[0].add(flatten_partition(result.subrange(1, result.len() as int)))\n    }\n}\n\nspec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {\n    result.len() == numbers.len() / 3 &&\n    (forall|i: int| 0 <= i < result.len() ==> valid_triplet(#[trigger] result[i])) &&\n    numbers.to_multiset() == flatten_partition(result).to_multiset()\n}\n\nspec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {\n    result.len() == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, numbers: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_748.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 803, "minimize_time_ms": 123394, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, numbers: Seq<int>) -> bool {\n\nspec fn valid_triplet(triplet: Seq<int>) -> bool {\n\nspec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>\n    decreases result.len()\n{\n\nspec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {\n\nspec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {\n\n    decreases result.len()\n\n    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))\n\n    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, numbers: Seq<int>) -> bool {\n    n >= 3 && n % 3 == 0 &&\n    numbers.len() == n &&\n    forall|i: int| 0 <= i < numbers.len() ==> 1 <= #[trigger] numbers[i] && #[trigger] numbers[i] <= 7\n}\n\nspec fn valid_triplet(triplet: Seq<int>) -> bool {\n    triplet.len() == 3 &&\n    triplet[0] < triplet[1] && triplet[1] < triplet[2] &&\n    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&\n    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0\n}\n\nspec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>\n    decreases result.len()\n{\n    if result.len() == 0 { \n        seq![]\n    } else {\n        result[0].add(flatten_partition(result.subrange(1, result.len() as int)))\n    }\n}\n\nspec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {\n    result.len() == numbers.len() / 3 &&\n    (forall|i: int| 0 <= i < result.len() ==> valid_triplet(#[trigger] result[i])) &&\n    numbers.to_multiset() == flatten_partition(result).to_multiset()\n}\n\nspec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {\n    result.len() == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, numbers: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n               fn main() {\n     }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_777_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 20 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn distinct_strings_count(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    s.len() as int * 25 + 26\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { seq!['0'] } // Simplified for termination\n}\n\nspec fn char_of_digit_spec(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n    requires valid_input(s@)\n    ensures result@ == int_to_string_spec(distinct_strings_count(s@))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 20 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn distinct_strings_count(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    s.len() as int * 25 + 26\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { seq!['0'] } // Simplified for termination\n}\n\nspec fn char_of_digit_spec(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n    requires valid_input(s@)\n    ensures result@ == int_to_string_spec(distinct_strings_count(s@))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_777.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 890, "minimize_time_ms": 122577, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn distinct_strings_count(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n\nspec fn char_of_digit_spec(d: int) -> char\n    recommends 0 <= d <= 9\n{\n\n    requires valid_input(s@)\n\n    ensures result@ == int_to_string_spec(distinct_strings_count(s@))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 20 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn distinct_strings_count(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    s.len() as int * 25 + 26\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { seq!['0'] } // Simplified for termination\n}\n\nspec fn char_of_digit_spec(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n    requires valid_input(s@)\n    ensures result@ == int_to_string_spec(distinct_strings_count(s@))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_789_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_lucky_number(n: Seq<char>) -> bool {\n    n.len() > 0 && forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n}\n\nspec fn convert_to_binary(n: Seq<char>) -> Seq<char>\n    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n    decreases n.len()\n{\n    if n.len() == 0 {\n        Seq::empty()\n    } else if n[0] == '4' {\n        seq!['0'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    } else {\n        seq!['1'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    }\n}\n\nspec fn pow2(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 2 * pow2((n - 1) as nat) }\n}\n\nspec fn binary_to_int(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        pow2((s.len() - 1) as nat) + binary_to_int(s.subrange(1, s.len() as int))\n    } else {\n        binary_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_result(n: Seq<char>, result: int) -> bool\n    recommends valid_lucky_number(n)\n{\n    result > 0 && result == 2 * (pow2((n.len() - 1) as nat) - 1) + binary_to_int(convert_to_binary(n)) + 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: Vec<char>) -> (result: i8)\n    requires valid_lucky_number(n@)\n    ensures valid_result(n@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_lucky_number(n: Seq<char>) -> bool {\n    n.len() > 0 && forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n}\n\nspec fn convert_to_binary(n: Seq<char>) -> Seq<char>\n    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n    decreases n.len()\n{\n    if n.len() == 0 {\n        Seq::empty()\n    } else if n[0] == '4' {\n        seq!['0'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    } else {\n        seq!['1'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    }\n}\n\nspec fn pow2(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 2 * pow2((n - 1) as nat) }\n}\n\nspec fn binary_to_int(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        pow2((s.len() - 1) as nat) + binary_to_int(s.subrange(1, s.len() as int))\n    } else {\n        binary_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_result(n: Seq<char>, result: int) -> bool\n    recommends valid_lucky_number(n)\n{\n    result > 0 && result == 2 * (pow2((n.len() - 1) as nat) - 1) + binary_to_int(convert_to_binary(n)) + 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: Vec<char>) -> (result: i8)\n    requires valid_lucky_number(n@)\n    ensures valid_result(n@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_789.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 794, "minimize_time_ms": 122891, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_lucky_number(n: Seq<char>) -> bool {\n\nspec fn convert_to_binary(n: Seq<char>) -> Seq<char>\n    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n    decreases n.len()\n{\n\nspec fn pow2(n: nat) -> nat\n    decreases n\n{\n\nspec fn binary_to_int(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n    decreases s.len()\n{\n\nspec fn valid_result(n: Seq<char>, result: int) -> bool\n    recommends valid_lucky_number(n)\n{\n\n    decreases n.len()\n\n    decreases n\n\n    decreases s.len()\n\n    requires valid_lucky_number(n@)\n\n    ensures valid_result(n@, result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_lucky_number(n: Seq<char>) -> bool {\n    n.len() > 0 && forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n}\n\nspec fn convert_to_binary(n: Seq<char>) -> Seq<char>\n    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n    decreases n.len()\n{\n    if n.len() == 0 {\n        Seq::empty()\n    } else if n[0] == '4' {\n        seq!['0'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    } else {\n        seq!['1'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    }\n}\n\nspec fn pow2(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 2 * pow2((n - 1) as nat) }\n}\n\nspec fn binary_to_int(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        pow2((s.len() - 1) as nat) + binary_to_int(s.subrange(1, s.len() as int))\n    } else {\n        binary_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_result(n: Seq<char>, result: int) -> bool\n    recommends valid_lucky_number(n)\n{\n    result > 0 && result == 2 * (pow2((n.len() - 1) as nat) - 1) + binary_to_int(convert_to_binary(n)) + 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: Vec<char>) -> (result: i8)\n    requires valid_lucky_number(n@)\n    ensures valid_result(n@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_792_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {\n  n >= 1 && d >= 1 &&\n  transactions.len() == n &&\n  forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000\n}\n\nspec fn prefix_sum(transactions: Seq<int>, index: int) -> int\n  decreases index\n{\n  if index < 0 || index >= transactions.len() { 0int }\n  else if index == 0 { transactions[0] }\n  else { prefix_sum(transactions, index - 1) + transactions[index] }\n}\n\nspec fn count_zero_transactions(transactions: Seq<int>) -> int\n  decreases transactions.len()\n{\n  if transactions.len() == 0 { 0int }\n  else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }\n}\n\nspec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int\n  decreases day\n{\n  if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }\n  else if day == 0 { deposits[0] + transactions[0] }\n  else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }\n}\n\nspec fn count_positive_deposits(deposits: Seq<int>) -> int\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { 0int }\n  else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }\n}\n\nspec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {\n  deposits_schedule.len() == transactions.len() &&\n  (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&\n  num_deposits == count_positive_deposits(deposits_schedule) &&\n  forall|i: int| 0 <= i < transactions.len() ==> \n    (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)\n}\n\nspec fn filter_positive(deposits: Seq<int>) -> Seq<int>\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { Seq::empty() }\n  else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }\n  else { filter_positive(deposits.drop_first()) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, transactions: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))\n  ensures result == -1 || result >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {\n  n >= 1 && d >= 1 &&\n  transactions.len() == n &&\n  forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000\n}\n\nspec fn prefix_sum(transactions: Seq<int>, index: int) -> int\n  decreases index\n{\n  if index < 0 || index >= transactions.len() { 0int }\n  else if index == 0 { transactions[0] }\n  else { prefix_sum(transactions, index - 1) + transactions[index] }\n}\n\nspec fn count_zero_transactions(transactions: Seq<int>) -> int\n  decreases transactions.len()\n{\n  if transactions.len() == 0 { 0int }\n  else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }\n}\n\nspec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int\n  decreases day\n{\n  if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }\n  else if day == 0 { deposits[0] + transactions[0] }\n  else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }\n}\n\nspec fn count_positive_deposits(deposits: Seq<int>) -> int\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { 0int }\n  else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }\n}\n\nspec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {\n  deposits_schedule.len() == transactions.len() &&\n  (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&\n  num_deposits == count_positive_deposits(deposits_schedule) &&\n  forall|i: int| 0 <= i < transactions.len() ==> \n    (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)\n}\n\nspec fn filter_positive(deposits: Seq<int>) -> Seq<int>\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { Seq::empty() }\n  else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }\n  else { filter_positive(deposits.drop_first()) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, transactions: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))\n  ensures result == -1 || result >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_792.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1207, "minimize_time_ms": 123388, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 76, "minimized_LOC": 76, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {\n\nspec fn prefix_sum(transactions: Seq<int>, index: int) -> int\n  decreases index\n{\n\nspec fn count_zero_transactions(transactions: Seq<int>) -> int\n  decreases transactions.len()\n{\n\nspec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int\n  decreases day\n{\n\nspec fn count_positive_deposits(deposits: Seq<int>) -> int\n  decreases deposits.len()\n{\n\nspec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {\n\nspec fn filter_positive(deposits: Seq<int>) -> Seq<int>\n  decreases deposits.len()\n{\n\n  decreases index\n\n  decreases transactions.len()\n\n  decreases day\n\n  decreases deposits.len()\n\n  decreases deposits.len()\n\n  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))\n\n  ensures result == -1 || result >= 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {\n  n >= 1 && d >= 1 &&\n  transactions.len() == n &&\n  forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000\n}\n\nspec fn prefix_sum(transactions: Seq<int>, index: int) -> int\n  decreases index\n{\n  if index < 0 || index >= transactions.len() { 0int }\n  else if index == 0 { transactions[0] }\n  else { prefix_sum(transactions, index - 1) + transactions[index] }\n}\n\nspec fn count_zero_transactions(transactions: Seq<int>) -> int\n  decreases transactions.len()\n{\n  if transactions.len() == 0 { 0int }\n  else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }\n}\n\nspec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int\n  decreases day\n{\n  if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }\n  else if day == 0 { deposits[0] + transactions[0] }\n  else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }\n}\n\nspec fn count_positive_deposits(deposits: Seq<int>) -> int\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { 0int }\n  else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }\n}\n\nspec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {\n  deposits_schedule.len() == transactions.len() &&\n  (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&\n  num_deposits == count_positive_deposits(deposits_schedule) &&\n  forall|i: int| 0 <= i < transactions.len() ==> \n    (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)\n}\n\nspec fn filter_positive(deposits: Seq<int>) -> Seq<int>\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { Seq::empty() }\n  else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }\n  else { filter_positive(deposits.drop_first()) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, transactions: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))\n  ensures result == -1 || result >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_795_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_n(n: int) -> bool {\n    n >= 1 && n <= 10000\n}\n\nspec fn integer_square_root(n: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn extract_integer(input: Seq<char>) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]  /* placeholder implementation */\n}\n\nspec fn count_pythagorean_triples_via_primitives(n: int) -> int {\n    let m = integer_square_root(n);\n    count_from_primitives(n, m, 1, 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        result@.len() > 0,\n        result@ == int_to_string(count_pythagorean_triples_via_primitives(extract_integer(stdin_input@)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_n(n: int) -> bool {\n    n >= 1 && n <= 10000\n}\n\nspec fn integer_square_root(n: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn extract_integer(input: Seq<char>) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]  /* placeholder implementation */\n}\n\nspec fn count_pythagorean_triples_via_primitives(n: int) -> int {\n    let m = integer_square_root(n);\n    count_from_primitives(n, m, 1, 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        result@.len() > 0,\n        result@ == int_to_string(count_pythagorean_triples_via_primitives(extract_integer(stdin_input@)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_795.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 654, "minimize_time_ms": 92747, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_n(n: int) -> bool {\n\nspec fn integer_square_root(n: int) -> int {\n\nspec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {\n\nspec fn extract_integer(input: Seq<char>) -> int {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn count_pythagorean_triples_via_primitives(n: int) -> int {\n\n    requires valid_input(stdin_input@)\n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_n(n: int) -> bool {\n    n >= 1 && n <= 10000\n}\n\nspec fn integer_square_root(n: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn extract_integer(input: Seq<char>) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]  /* placeholder implementation */\n}\n\nspec fn count_pythagorean_triples_via_primitives(n: int) -> int {\n    let m = integer_square_root(n);\n    count_from_primitives(n, m, 1, 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        result@.len() > 0,\n        result@ == int_to_string(count_pythagorean_triples_via_primitives(extract_integer(stdin_input@)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_821_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool\n{\n    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000\n}\n\nspec fn participant_time(s: int, v: int, t: int) -> int\n{\n    2 * t + s * v\n}\n\nspec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>\n{\n    let time1 = participant_time(s, v1, t1);\n    let time2 = participant_time(s, v2, t2);\n    if time1 < time2 { seq!['F','i','r','s','t'] }\n    else if time1 > time2 { seq!['S','e','c','o','n','d'] }\n    else { seq!['F','r','i','e','n','d','s','h','i','p'] }\n}\n\nspec fn valid_result(result: Seq<char>) -> bool\n{\n    result == seq!['F','i','r','s','t'] || result == seq!['S','e','c','o','n','d'] || result == seq!['F','r','i','e','n','d','s','h','i','p']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: i8, v1: i8, v2: i8, t1: i8, t2: i8) -> (result: Vec<char>)\n    requires \n        valid_input(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n    ensures \n        valid_result(result@) &&\n        result@ == correct_result(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool\n{\n    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000\n}\n\nspec fn participant_time(s: int, v: int, t: int) -> int\n{\n    2 * t + s * v\n}\n\nspec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>\n{\n    let time1 = participant_time(s, v1, t1);\n    let time2 = participant_time(s, v2, t2);\n    if time1 < time2 { seq!['F','i','r','s','t'] }\n    else if time1 > time2 { seq!['S','e','c','o','n','d'] }\n    else { seq!['F','r','i','e','n','d','s','h','i','p'] }\n}\n\nspec fn valid_result(result: Seq<char>) -> bool\n{\n    result == seq!['F','i','r','s','t'] || result == seq!['S','e','c','o','n','d'] || result == seq!['F','r','i','e','n','d','s','h','i','p']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: i8, v1: i8, v2: i8, t1: i8, t2: i8) -> (result: Vec<char>)\n    requires \n        valid_input(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n    ensures \n        valid_result(result@) &&\n        result@ == correct_result(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_821.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 788, "minimize_time_ms": 92314, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool\n{\n\nspec fn participant_time(s: int, v: int, t: int) -> int\n{\n\nspec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>\n{\n\nspec fn valid_result(result: Seq<char>) -> bool\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool\n{\n    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000\n}\n\nspec fn participant_time(s: int, v: int, t: int) -> int\n{\n    2 * t + s * v\n}\n\nspec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>\n{\n    let time1 = participant_time(s, v1, t1);\n    let time2 = participant_time(s, v2, t2);\n    if time1 < time2 { seq!['F','i','r','s','t'] }\n    else if time1 > time2 { seq!['S','e','c','o','n','d'] }\n    else { seq!['F','r','i','e','n','d','s','h','i','p'] }\n}\n\nspec fn valid_result(result: Seq<char>) -> bool\n{\n    result == seq!['F','i','r','s','t'] || result == seq!['S','e','c','o','n','d'] || result == seq!['F','r','i','e','n','d','s','h','i','p']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: i8, v1: i8, v2: i8, t1: i8, t2: i8) -> (result: Vec<char>)\n    requires \n        valid_input(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n    ensures \n        valid_result(result@) &&\n        result@ == correct_result(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_823_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, y: int) -> bool {\n    -100 <= x <= 100 && -100 <= y <= 100\n}\n\nspec fn is_origin_or_first_point(x: int, y: int) -> bool {\n    (x == 0 && y == 0) || (x == 1 && y == 0)\n}\n\nspec fn is_right_edge(x: int, y: int) -> bool {\n    x >= 1 && -x + 1 < y <= x\n}\n\nspec fn is_left_edge(x: int, y: int) -> bool {\n    x < 0 && x <= y < -x\n}\n\nspec fn is_top_edge(x: int, y: int) -> bool {\n    y > 0 && -y <= x < y\n}\n\nspec fn compute_turns(x: int, y: int) -> int\n    recommends valid_input(x, y)\n{\n    if is_origin_or_first_point(x, y) { \n        0\n    } else if is_right_edge(x, y) { \n        1 + 4 * (x - 1)\n    } else if is_left_edge(x, y) { \n        3 + 4 * (-x - 1)\n    } else if is_top_edge(x, y) { \n        2 + 4 * (y - 1)\n    } else { \n        -4 * y\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8, y: i8) -> (result: i8)\n    requires \n        valid_input(x as int, y as int)\n    ensures \n        result as int >= 0,\n        result as int == compute_turns(x as int, y as int),\n        is_origin_or_first_point(x as int, y as int) ==> result as int == 0,\n        is_right_edge(x as int, y as int) ==> result as int == 1 + 4 * (x as int - 1),\n        is_left_edge(x as int, y as int) ==> result as int == 3 + 4 * (-(x as int) - 1),\n        is_top_edge(x as int, y as int) ==> result as int == 2 + 4 * (y as int - 1),\n        !(is_origin_or_first_point(x as int, y as int) || is_right_edge(x as int, y as int) || is_left_edge(x as int, y as int) || is_top_edge(x as int, y as int)) ==> result as int == -4 * y as int,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, y: int) -> bool {\n    -100 <= x <= 100 && -100 <= y <= 100\n}\n\nspec fn is_origin_or_first_point(x: int, y: int) -> bool {\n    (x == 0 && y == 0) || (x == 1 && y == 0)\n}\n\nspec fn is_right_edge(x: int, y: int) -> bool {\n    x >= 1 && -x + 1 < y <= x\n}\n\nspec fn is_left_edge(x: int, y: int) -> bool {\n    x < 0 && x <= y < -x\n}\n\nspec fn is_top_edge(x: int, y: int) -> bool {\n    y > 0 && -y <= x < y\n}\n\nspec fn compute_turns(x: int, y: int) -> int\n    recommends valid_input(x, y)\n{\n    if is_origin_or_first_point(x, y) { \n        0\n    } else if is_right_edge(x, y) { \n        1 + 4 * (x - 1)\n    } else if is_left_edge(x, y) { \n        3 + 4 * (-x - 1)\n    } else if is_top_edge(x, y) { \n        2 + 4 * (y - 1)\n    } else { \n        -4 * y\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8, y: i8) -> (result: i8)\n    requires \n        valid_input(x as int, y as int)\n    ensures \n        result as int >= 0,\n        result as int == compute_turns(x as int, y as int),\n        is_origin_or_first_point(x as int, y as int) ==> result as int == 0,\n        is_right_edge(x as int, y as int) ==> result as int == 1 + 4 * (x as int - 1),\n        is_left_edge(x as int, y as int) ==> result as int == 3 + 4 * (-(x as int) - 1),\n        is_top_edge(x as int, y as int) ==> result as int == 2 + 4 * (y as int - 1),\n        !(is_origin_or_first_point(x as int, y as int) || is_right_edge(x as int, y as int) || is_left_edge(x as int, y as int) || is_top_edge(x as int, y as int)) ==> result as int == -4 * y as int,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_823.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 628, "minimize_time_ms": 92505, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 70, "minimized_LOC": 70, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(x: int, y: int) -> bool {\n\nspec fn is_origin_or_first_point(x: int, y: int) -> bool {\n\nspec fn is_right_edge(x: int, y: int) -> bool {\n\nspec fn is_left_edge(x: int, y: int) -> bool {\n\nspec fn is_top_edge(x: int, y: int) -> bool {\n\nspec fn compute_turns(x: int, y: int) -> int\n    recommends valid_input(x, y)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, y: int) -> bool {\n    -100 <= x <= 100 && -100 <= y <= 100\n}\n\nspec fn is_origin_or_first_point(x: int, y: int) -> bool {\n    (x == 0 && y == 0) || (x == 1 && y == 0)\n}\n\nspec fn is_right_edge(x: int, y: int) -> bool {\n    x >= 1 && -x + 1 < y <= x\n}\n\nspec fn is_left_edge(x: int, y: int) -> bool {\n    x < 0 && x <= y < -x\n}\n\nspec fn is_top_edge(x: int, y: int) -> bool {\n    y > 0 && -y <= x < y\n}\n\nspec fn compute_turns(x: int, y: int) -> int\n    recommends valid_input(x, y)\n{\n    if is_origin_or_first_point(x, y) { \n        0\n    } else if is_right_edge(x, y) { \n        1 + 4 * (x - 1)\n    } else if is_left_edge(x, y) { \n        3 + 4 * (-x - 1)\n    } else if is_top_edge(x, y) { \n        2 + 4 * (y - 1)\n    } else { \n        -4 * y\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8, y: i8) -> (result: i8)\n    requires \n        valid_input(x as int, y as int)\n    ensures \n        result as int >= 0,\n        result as int == compute_turns(x as int, y as int),\n        is_origin_or_first_point(x as int, y as int) ==> result as int == 0,\n        is_right_edge(x as int, y as int) ==> result as int == 1 + 4 * (x as int - 1),\n        is_left_edge(x as int, y as int) ==> result as int == 3 + 4 * (-(x as int) - 1),\n        is_top_edge(x as int, y as int) ==> result as int == 2 + 4 * (y as int - 1),\n        !(is_origin_or_first_point(x as int, y as int) || is_right_edge(x as int, y as int) || is_left_edge(x as int, y as int) || is_top_edge(x as int, y as int)) ==> result as int == -4 * y as int,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_826_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn is_optimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        savings >= 0 &&\n        (2 + savings) * (savings + 1) / 2 > n + 1 &&\n        (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)\n    )\n}\n\nspec fn is_minimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        is_optimal_savings(n, savings) &&\n        (forall|j: int| j >= 0 && j < savings ==> #[trigger] ((2 + j) * (j + 1) / 2) <= n + 1)\n    )\n}\n\nspec fn optimal_cost(n: int, savings: int) -> int {\n    if n >= 1 && is_optimal_savings(n, savings) {\n        n - savings + 1\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int)\n    ensures \n        result as int >= 1,\n        result as int <= n as int,\n        exists|savings: int| is_minimal_savings(n as int, savings) && result as int == optimal_cost(n as int, savings),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn is_optimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        savings >= 0 &&\n        (2 + savings) * (savings + 1) / 2 > n + 1 &&\n        (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)\n    )\n}\n\nspec fn is_minimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        is_optimal_savings(n, savings) &&\n        (forall|j: int| j >= 0 && j < savings ==> #[trigger] ((2 + j) * (j + 1) / 2) <= n + 1)\n    )\n}\n\nspec fn optimal_cost(n: int, savings: int) -> int {\n    if n >= 1 && is_optimal_savings(n, savings) {\n        n - savings + 1\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int)\n    ensures \n        result as int >= 1,\n        result as int <= n as int,\n        exists|savings: int| is_minimal_savings(n as int, savings) && result as int == optimal_cost(n as int, savings),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_826.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 769, "minimize_time_ms": 122518, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int) -> bool {\n\nspec fn is_optimal_savings(n: int, savings: int) -> bool {\n\nspec fn is_minimal_savings(n: int, savings: int) -> bool {\n\nspec fn optimal_cost(n: int, savings: int) -> int {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn is_optimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        savings >= 0 &&\n        (2 + savings) * (savings + 1) / 2 > n + 1 &&\n        (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)\n    )\n}\n\nspec fn is_minimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        is_optimal_savings(n, savings) &&\n        (forall|j: int| j >= 0 && j < savings ==> #[trigger] ((2 + j) * (j + 1) / 2) <= n + 1)\n    )\n}\n\nspec fn optimal_cost(n: int, savings: int) -> int {\n    if n >= 1 && is_optimal_savings(n, savings) {\n        n - savings + 1\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int)\n    ensures \n        result as int >= 1,\n        result as int <= n as int,\n        exists|savings: int| is_minimal_savings(n as int, savings) && result as int == optimal_cost(n as int, savings),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_838_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {\n    grid.len() * grid[0].len() + \n    sum_row_contributions(grid) + \n    sum_col_contributions(grid)\n}\n\nspec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_row_contributions_helper(grid, 0)\n}\n\nspec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }\n}\n\nspec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {\n    let cnt0 = count_in_row(grid, row, 0);\n    let cnt1 = count_in_row(grid, row, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_col_contributions_helper(grid, 0)\n}\n\nspec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int\n    decreases grid[0].len() - col\n{\n    if col >= grid[0].len() { 0 }\n    else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }\n}\n\nspec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {\n    let cnt0 = count_in_col(grid, col, 0);\n    let cnt1 = count_in_col(grid, col, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {\n    count_in_row_helper(grid, row, value, 0)\n}\n\nspec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int\n    decreases grid[row].len() - col\n{\n    if col >= grid[row].len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }\n}\n\nspec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {\n    if grid.len() == 0 { 0 }\n    else { count_col_helper(grid, col, value, 0) }\n}\n\nspec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 }\n    else { base * power(base, exp - 1) }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0'] /* placeholder implementation */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@),\n    ensures result@.len() > 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {\n    grid.len() * grid[0].len() + \n    sum_row_contributions(grid) + \n    sum_col_contributions(grid)\n}\n\nspec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_row_contributions_helper(grid, 0)\n}\n\nspec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }\n}\n\nspec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {\n    let cnt0 = count_in_row(grid, row, 0);\n    let cnt1 = count_in_row(grid, row, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_col_contributions_helper(grid, 0)\n}\n\nspec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int\n    decreases grid[0].len() - col\n{\n    if col >= grid[0].len() { 0 }\n    else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }\n}\n\nspec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {\n    let cnt0 = count_in_col(grid, col, 0);\n    let cnt1 = count_in_col(grid, col, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {\n    count_in_row_helper(grid, row, value, 0)\n}\n\nspec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int\n    decreases grid[row].len() - col\n{\n    if col >= grid[row].len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }\n}\n\nspec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {\n    if grid.len() == 0 { 0 }\n    else { count_col_helper(grid, col, value, 0) }\n}\n\nspec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 }\n    else { base * power(base, exp - 1) }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0'] /* placeholder implementation */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@),\n    ensures result@.len() > 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_838.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 813, "minimize_time_ms": 92687, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 114, "minimized_LOC": 114, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 25, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n\nspec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {\n\nspec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {\n\nspec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int\n    decreases grid.len() - row\n{\n\nspec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {\n\nspec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {\n\nspec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int\n    decreases grid[0].len() - col\n{\n\nspec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {\n\nspec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {\n\nspec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int\n    decreases grid[row].len() - col\n{\n\nspec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {\n\nspec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int\n    decreases grid.len() - row\n{\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\n    decreases grid.len() - row\n\n    decreases grid[0].len() - col\n\n    decreases grid[row].len() - col\n\n    decreases grid.len() - row\n\n    decreases exp\n\n    requires valid_input(stdin_input@),\n\n    ensures result@.len() > 0,"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {\n    grid.len() * grid[0].len() + \n    sum_row_contributions(grid) + \n    sum_col_contributions(grid)\n}\n\nspec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_row_contributions_helper(grid, 0)\n}\n\nspec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }\n}\n\nspec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {\n    let cnt0 = count_in_row(grid, row, 0);\n    let cnt1 = count_in_row(grid, row, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_col_contributions_helper(grid, 0)\n}\n\nspec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int\n    decreases grid[0].len() - col\n{\n    if col >= grid[0].len() { 0 }\n    else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }\n}\n\nspec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {\n    let cnt0 = count_in_col(grid, col, 0);\n    let cnt1 = count_in_col(grid, col, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {\n    count_in_row_helper(grid, row, value, 0)\n}\n\nspec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int\n    decreases grid[row].len() - col\n{\n    if col >= grid[row].len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }\n}\n\nspec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {\n    if grid.len() == 0 { 0 }\n    else { count_col_helper(grid, col, value, 0) }\n}\n\nspec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 }\n    else { base * power(base, exp - 1) }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0'] /* placeholder implementation */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@),\n    ensures result@.len() > 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_842_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn extract_first_line(s: Seq<char>) -> Seq<char>\n    recommends s.len() > 0\n{\n    let newline_pos = find_first_newline(s);\n    if newline_pos == -1 { s } else { s.subrange(0, newline_pos) }\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == '\\n' {\n        0\n    } else {\n        let rest_result = find_first_newline(s.subrange(1, s.len() as int));\n        if rest_result == -1 { -1 } else { rest_result + 1 }\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        Seq::empty() \n    } else { \n        reverse_string(s.subrange(1, s.len() as int)).push(s[0]) \n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    result.len() >= 1 &&\n    result[result.len() - 1] == '\\n' &&\n    exists|n: Seq<char>| \n        n == extract_first_line(input) &&\n        result == n.add(reverse_string(n)).push('\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn extract_first_line(s: Seq<char>) -> Seq<char>\n    recommends s.len() > 0\n{\n    let newline_pos = find_first_newline(s);\n    if newline_pos == -1 { s } else { s.subrange(0, newline_pos) }\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == '\\n' {\n        0\n    } else {\n        let rest_result = find_first_newline(s.subrange(1, s.len() as int));\n        if rest_result == -1 { -1 } else { rest_result + 1 }\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        Seq::empty() \n    } else { \n        reverse_string(s.subrange(1, s.len() as int)).push(s[0]) \n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    result.len() >= 1 &&\n    result[result.len() - 1] == '\\n' &&\n    exists|n: Seq<char>| \n        n == extract_first_line(input) &&\n        result == n.add(reverse_string(n)).push('\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_842.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 870, "minimize_time_ms": 92192, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn extract_first_line(s: Seq<char>) -> Seq<char>\n    recommends s.len() > 0\n{\n\nspec fn find_first_newline(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_input(stdin_input@)\n\n    ensures valid_output(result@, stdin_input@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn extract_first_line(s: Seq<char>) -> Seq<char>\n    recommends s.len() > 0\n{\n    let newline_pos = find_first_newline(s);\n    if newline_pos == -1 { s } else { s.subrange(0, newline_pos) }\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == '\\n' {\n        0\n    } else {\n        let rest_result = find_first_newline(s.subrange(1, s.len() as int));\n        if rest_result == -1 { -1 } else { rest_result + 1 }\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        Seq::empty() \n    } else { \n        reverse_string(s.subrange(1, s.len() as int)).push(s[0]) \n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    result.len() >= 1 &&\n    result[result.len() - 1] == '\\n' &&\n    exists|n: Seq<char>| \n        n == extract_first_line(input) &&\n        result == n.add(reverse_string(n)).push('\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_847_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn valid_input(cards: Seq<int>, x: int) -> bool {\n    x > 0 && cards.len() >= 1 && forall|i: int| 0 <= i < cards.len() ==> #[trigger] cards[i] >= -x && #[trigger] cards[i] <= x\n}\n\nspec fn solve_result(cards: Seq<int>, x: int) -> int {\n    if sum(cards) == 0 { 0 } else { (abs(sum(cards)) + x - 1) / x }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>, x: i8) -> (result: i8)\n    requires \n        valid_input(cards@.map(|i: int, v: i8| v as int), x as int),\n    ensures \n        result as int >= 0,\n        result as int == solve_result(cards@.map(|i: int, v: i8| v as int), x as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn valid_input(cards: Seq<int>, x: int) -> bool {\n    x > 0 && cards.len() >= 1 && forall|i: int| 0 <= i < cards.len() ==> #[trigger] cards[i] >= -x && #[trigger] cards[i] <= x\n}\n\nspec fn solve_result(cards: Seq<int>, x: int) -> int {\n    if sum(cards) == 0 { 0 } else { (abs(sum(cards)) + x - 1) / x }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>, x: i8) -> (result: i8)\n    requires \n        valid_input(cards@.map(|i: int, v: i8| v as int), x as int),\n    ensures \n        result as int >= 0,\n        result as int == solve_result(cards@.map(|i: int, v: i8| v as int), x as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_847.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 759, "minimize_time_ms": 122627, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n\nspec fn abs(x: int) -> int {\n\nspec fn valid_input(cards: Seq<int>, x: int) -> bool {\n\nspec fn solve_result(cards: Seq<int>, x: int) -> int {\n\n    decreases cards.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn valid_input(cards: Seq<int>, x: int) -> bool {\n    x > 0 && cards.len() >= 1 && forall|i: int| 0 <= i < cards.len() ==> #[trigger] cards[i] >= -x && #[trigger] cards[i] <= x\n}\n\nspec fn solve_result(cards: Seq<int>, x: int) -> int {\n    if sum(cards) == 0 { 0 } else { (abs(sum(cards)) + x - 1) / x }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>, x: i8) -> (result: i8)\n    requires \n        valid_input(cards@.map(|i: int, v: i8| v as int), x as int),\n    ensures \n        result as int >= 0,\n        result as int == solve_result(cards@.map(|i: int, v: i8| v as int), x as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_858_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_power_of_two(n: int) -> bool\n    decreases n\n{\n    if n <= 0 {\n        false\n    } else if n == 1 {\n        true\n    } else if n % 2 == 1 {\n        false\n    } else {\n        is_power_of_two(n / 2)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn correct_result(n: int, result: int) -> bool {\n    if n % 2 == 1 {\n        result == (n - 1) / 2\n    } else {\n        exists|z: int| 1 <= z <= n && is_power_of_two(z) && z <= n && z * 2 > n && result == (n - z) / 2\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures correct_result(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_power_of_two(n: int) -> bool\n    decreases n\n{\n    if n <= 0 {\n        false\n    } else if n == 1 {\n        true\n    } else if n % 2 == 1 {\n        false\n    } else {\n        is_power_of_two(n / 2)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn correct_result(n: int, result: int) -> bool {\n    if n % 2 == 1 {\n        result == (n - 1) / 2\n    } else {\n        exists|z: int| 1 <= z <= n && is_power_of_two(z) && z <= n && z * 2 > n && result == (n - z) / 2\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures correct_result(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_858.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 838, "minimize_time_ms": 122362, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_power_of_two(n: int) -> bool\n    decreases n\n{\n\nspec fn valid_input(n: int) -> bool {\n\nspec fn correct_result(n: int, result: int) -> bool {\n\n    decreases n\n\n    requires valid_input(n as int)\n\n    ensures correct_result(n as int, result as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_power_of_two(n: int) -> bool\n    decreases n\n{\n    if n <= 0 {\n        false\n    } else if n == 1 {\n        true\n    } else if n % 2 == 1 {\n        false\n    } else {\n        is_power_of_two(n / 2)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn correct_result(n: int, result: int) -> bool {\n    if n % 2 == 1 {\n        result == (n - 1) / 2\n    } else {\n        exists|z: int| 1 <= z <= n && is_power_of_two(z) && z <= n && z * 2 > n && result == (n - z) / 2\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures correct_result(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_862_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n  n >= 2 && a.len() == n && (forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0)\n}\n\nspec fn compute_b(a: Seq<int>, i: int) -> int\n  recommends 0 <= i < a.len()\n{\n  a[i] - i\n}\n\nspec fn compute_c(n: int, b: int) -> int\n  recommends n >= 2\n{\n  if b < 0 { b / n } else { (b + n - 1) / n }\n}\n\nspec fn compute_cc(n: int, a: Seq<int>, i: int) -> int\n  recommends valid_input(n, a) && 0 <= i < n\n{\n  let b = compute_b(a, i);\n  let c = compute_c(n, b);\n  n * c\n}\n\nspec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool\n  recommends valid_input(n, a) && 1 <= entrance <= n\n{\n  let i = entrance - 1;\n  forall|j: int| 0 <= j < n ==> {\n    let cci = compute_cc(n, a, i);\n    let ccj = #[trigger] compute_cc(n, a, j);\n    cci <= ccj && (cci < ccj || i <= j)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    valid_input(n as int, a@.map(|i, x: i8| x as int)),\n  ensures\n    1 <= result as int <= n as int,\n    is_optimal_entrance(n as int, a@.map(|i, x: i8| x as int), result as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n  n >= 2 && a.len() == n && (forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0)\n}\n\nspec fn compute_b(a: Seq<int>, i: int) -> int\n  recommends 0 <= i < a.len()\n{\n  a[i] - i\n}\n\nspec fn compute_c(n: int, b: int) -> int\n  recommends n >= 2\n{\n  if b < 0 { b / n } else { (b + n - 1) / n }\n}\n\nspec fn compute_cc(n: int, a: Seq<int>, i: int) -> int\n  recommends valid_input(n, a) && 0 <= i < n\n{\n  let b = compute_b(a, i);\n  let c = compute_c(n, b);\n  n * c\n}\n\nspec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool\n  recommends valid_input(n, a) && 1 <= entrance <= n\n{\n  let i = entrance - 1;\n  forall|j: int| 0 <= j < n ==> {\n    let cci = compute_cc(n, a, i);\n    let ccj = #[trigger] compute_cc(n, a, j);\n    cci <= ccj && (cci < ccj || i <= j)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    valid_input(n as int, a@.map(|i, x: i8| x as int)),\n  ensures\n    1 <= result as int <= n as int,\n    is_optimal_entrance(n as int, a@.map(|i, x: i8| x as int), result as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_862.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 777, "minimize_time_ms": 123941, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>) -> bool {\n\nspec fn compute_b(a: Seq<int>, i: int) -> int\n  recommends 0 <= i < a.len()\n{\n\nspec fn compute_c(n: int, b: int) -> int\n  recommends n >= 2\n{\n\nspec fn compute_cc(n: int, a: Seq<int>, i: int) -> int\n  recommends valid_input(n, a) && 0 <= i < n\n{\n\nspec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool\n  recommends valid_input(n, a) && 1 <= entrance <= n\n{\n\n  requires\n\n  ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n  n >= 2 && a.len() == n && (forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0)\n}\n\nspec fn compute_b(a: Seq<int>, i: int) -> int\n  recommends 0 <= i < a.len()\n{\n  a[i] - i\n}\n\nspec fn compute_c(n: int, b: int) -> int\n  recommends n >= 2\n{\n  if b < 0 { b / n } else { (b + n - 1) / n }\n}\n\nspec fn compute_cc(n: int, a: Seq<int>, i: int) -> int\n  recommends valid_input(n, a) && 0 <= i < n\n{\n  let b = compute_b(a, i);\n  let c = compute_c(n, b);\n  n * c\n}\n\nspec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool\n  recommends valid_input(n, a) && 1 <= entrance <= n\n{\n  let i = entrance - 1;\n  forall|j: int| 0 <= j < n ==> {\n    let cci = compute_cc(n, a, i);\n    let ccj = #[trigger] compute_cc(n, a, j);\n    cci <= ccj && (cci < ccj || i <= j)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    valid_input(n as int, a@.map(|i, x: i8| x as int)),\n  ensures\n    1 <= result as int <= n as int,\n    is_optimal_entrance(n as int, a@.map(|i, x: i8| x as int), result as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n              fn main() {\n    }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_869_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int) -> bool\n{\n  a >= 1 && b >= 1\n}\n\nspec fn max_different_days(a: int, b: int) -> int\n{\n  if a < b { a } else { b }\n}\n\nspec fn remaining_after_different(a: int, b: int) -> int\n{\n  if a > b { a - max_different_days(a, b) } else { b - max_different_days(a, b) }\n}\n\nspec fn same_days(a: int, b: int) -> int\n{\n  remaining_after_different(a, b) / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: (i8, i8))\n  requires valid_input(a as int, b as int)\n  ensures ({\n      let (days_different, days_same) = result;\n      days_different as int == max_different_days(a as int, b as int) &&\n      days_same as int == same_days(a as int, b as int) &&\n      days_different >= 0 &&\n      days_same >= 0 &&\n      days_different <= a && days_different <= b\n  })\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int) -> bool\n{\n  a >= 1 && b >= 1\n}\n\nspec fn max_different_days(a: int, b: int) -> int\n{\n  if a < b { a } else { b }\n}\n\nspec fn remaining_after_different(a: int, b: int) -> int\n{\n  if a > b { a - max_different_days(a, b) } else { b - max_different_days(a, b) }\n}\n\nspec fn same_days(a: int, b: int) -> int\n{\n  remaining_after_different(a, b) / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: (i8, i8))\n  requires valid_input(a as int, b as int)\n  ensures ({\n      let (days_different, days_same) = result;\n      days_different as int == max_different_days(a as int, b as int) &&\n      days_same as int == same_days(a as int, b as int) &&\n      days_different >= 0 &&\n      days_same >= 0 &&\n      days_different <= a && days_different <= b\n  })\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_869.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 853, "minimize_time_ms": 92007, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 52, "minimized_LOC": 52, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int) -> bool\n{\n\nspec fn max_different_days(a: int, b: int) -> int\n{\n\nspec fn remaining_after_different(a: int, b: int) -> int\n{\n\nspec fn same_days(a: int, b: int) -> int\n{\n\n  requires valid_input(a as int, b as int)\n\n  ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int) -> bool\n{\n  a >= 1 && b >= 1\n}\n\nspec fn max_different_days(a: int, b: int) -> int\n{\n  if a < b { a } else { b }\n}\n\nspec fn remaining_after_different(a: int, b: int) -> int\n{\n  if a > b { a - max_different_days(a, b) } else { b - max_different_days(a, b) }\n}\n\nspec fn same_days(a: int, b: int) -> int\n{\n  remaining_after_different(a, b) / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: (i8, i8))\n  requires valid_input(a as int, b as int)\n  ensures ({\n      let (days_different, days_same) = result;\n      days_different as int == max_different_days(a as int, b as int) &&\n      days_same as int == same_days(a as int, b as int) &&\n      days_different >= 0 &&\n      days_same >= 0 &&\n      days_different <= a && days_different <= b\n  })\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_883_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, friends: Seq<int>) -> bool {\n  n >= 1 && friends.len() == n && forall|i: int| 0 <= i < friends.len() ==> #[trigger] friends[i] >= 1 && #[trigger] friends[i] <= 5\n}\n\nspec fn sum_sequence(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 } else { s[0] + sum_sequence(s.subrange(1, s.len() as int)) }\n}\n\nspec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {\n  &&& valid_input(n, friends)\n  &&& 1 <= dima_fingers <= 5\n  &&& {\n    let total_sum = sum_sequence(friends) + dima_fingers;\n    let total_people = n + 1;\n    total_sum % total_people == 1\n  }\n}\n\nspec fn count_valid_choices(n: int, friends: Seq<int>) -> int {\n  if valid_input(n, friends) {\n    count_valid_choices_helper(n, friends, 1)\n  } else {\n    0\n  }\n}\n\nspec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int\n  decreases 6 - finger_count\n{\n  if !(valid_input(n, friends) && 1 <= finger_count <= 6) {\n    0\n  } else if finger_count > 5 {\n    0\n  } else if !dima_cleans(n, friends, finger_count) {\n    1 + count_valid_choices_helper(n, friends, finger_count + 1)\n  } else {\n    count_valid_choices_helper(n, friends, finger_count + 1)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, friends: Vec<i8>) -> (result: i8)\n  requires \n    valid_input(n as int, friends@.map_values(|x: i8| x as int))\n  ensures \n    0 <= result <= 5,\n    result as int == count_valid_choices(n as int, friends@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, friends: Seq<int>) -> bool {\n  n >= 1 && friends.len() == n && forall|i: int| 0 <= i < friends.len() ==> #[trigger] friends[i] >= 1 && #[trigger] friends[i] <= 5\n}\n\nspec fn sum_sequence(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 } else { s[0] + sum_sequence(s.subrange(1, s.len() as int)) }\n}\n\nspec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {\n  &&& valid_input(n, friends)\n  &&& 1 <= dima_fingers <= 5\n  &&& {\n    let total_sum = sum_sequence(friends) + dima_fingers;\n    let total_people = n + 1;\n    total_sum % total_people == 1\n  }\n}\n\nspec fn count_valid_choices(n: int, friends: Seq<int>) -> int {\n  if valid_input(n, friends) {\n    count_valid_choices_helper(n, friends, 1)\n  } else {\n    0\n  }\n}\n\nspec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int\n  decreases 6 - finger_count\n{\n  if !(valid_input(n, friends) && 1 <= finger_count <= 6) {\n    0\n  } else if finger_count > 5 {\n    0\n  } else if !dima_cleans(n, friends, finger_count) {\n    1 + count_valid_choices_helper(n, friends, finger_count + 1)\n  } else {\n    count_valid_choices_helper(n, friends, finger_count + 1)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, friends: Vec<i8>) -> (result: i8)\n  requires \n    valid_input(n as int, friends@.map_values(|x: i8| x as int))\n  ensures \n    0 <= result <= 5,\n    result as int == count_valid_choices(n as int, friends@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_883.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 867, "minimize_time_ms": 122402, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, friends: Seq<int>) -> bool {\n\nspec fn sum_sequence(s: Seq<int>) -> int\n  decreases s.len()\n{\n\nspec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {\n\nspec fn count_valid_choices(n: int, friends: Seq<int>) -> int {\n\nspec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int\n  decreases 6 - finger_count\n{\n\n  decreases s.len()\n\n  decreases 6 - finger_count\n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, friends: Seq<int>) -> bool {\n  n >= 1 && friends.len() == n && forall|i: int| 0 <= i < friends.len() ==> #[trigger] friends[i] >= 1 && #[trigger] friends[i] <= 5\n}\n\nspec fn sum_sequence(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 } else { s[0] + sum_sequence(s.subrange(1, s.len() as int)) }\n}\n\nspec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {\n  &&& valid_input(n, friends)\n  &&& 1 <= dima_fingers <= 5\n  &&& {\n    let total_sum = sum_sequence(friends) + dima_fingers;\n    let total_people = n + 1;\n    total_sum % total_people == 1\n  }\n}\n\nspec fn count_valid_choices(n: int, friends: Seq<int>) -> int {\n  if valid_input(n, friends) {\n    count_valid_choices_helper(n, friends, 1)\n  } else {\n    0\n  }\n}\n\nspec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int\n  decreases 6 - finger_count\n{\n  if !(valid_input(n, friends) && 1 <= finger_count <= 6) {\n    0\n  } else if finger_count > 5 {\n    0\n  } else if !dima_cleans(n, friends, finger_count) {\n    1 + count_valid_choices_helper(n, friends, finger_count + 1)\n  } else {\n    count_valid_choices_helper(n, friends, finger_count + 1)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, friends: Vec<i8>) -> (result: i8)\n  requires \n    valid_input(n as int, friends@.map_values(|x: i8| x as int))\n  ensures \n    0 <= result <= 5,\n    result as int == count_valid_choices(n as int, friends@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_895_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {\n    n >= 1 && times.len() == n && T >= 1 && \n    forall|i: int| 0 <= i < times.len() ==> 1 <= #[trigger] times[i] <= 1000\n}\n\nspec fn max_students_in_window(times: Seq<int>, T: int) -> int {\n    max_students_in_window_up_to(times, T, 1000)\n}\n\nspec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int\n    decreases max_start\n{\n    if max_start < 1 { \n        0\n    } else {\n        let count = count_students_in_window(times, max_start, T);\n        let rest_max = max_students_in_window_up_to(times, T, max_start - 1);\n        if count > rest_max { count } else { rest_max }\n    }\n}\n\nspec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {\n    if times.len() == 0 { \n        0 \n    } else { \n        count_students_in_window_helper(times, start, T, 0) \n    }\n}\n\nspec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int\n    decreases times.len() - index\n{\n    if index >= times.len() { \n        0\n    } else {\n        let count_rest = count_students_in_window_helper(times, start, T, index + 1);\n        if start <= times[index] <= start + T - 1 { \n            count_rest + 1 \n        } else { \n            count_rest \n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, times: Vec<i8>, T: i8) -> (result: i8)\n    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)\n    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    n\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {\n    n >= 1 && times.len() == n && T >= 1 && \n    forall|i: int| 0 <= i < times.len() ==> 1 <= #[trigger] times[i] <= 1000\n}\n\nspec fn max_students_in_window(times: Seq<int>, T: int) -> int {\n    max_students_in_window_up_to(times, T, 1000)\n}\n\nspec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int\n    decreases max_start\n{\n    if max_start < 1 { \n        0\n    } else {\n        let count = count_students_in_window(times, max_start, T);\n        let rest_max = max_students_in_window_up_to(times, T, max_start - 1);\n        if count > rest_max { count } else { rest_max }\n    }\n}\n\nspec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {\n    if times.len() == 0 { \n        0 \n    } else { \n        count_students_in_window_helper(times, start, T, 0) \n    }\n}\n\nspec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int\n    decreases times.len() - index\n{\n    if index >= times.len() { \n        0\n    } else {\n        let count_rest = count_students_in_window_helper(times, start, T, index + 1);\n        if start <= times[index] <= start + T - 1 { \n            count_rest + 1 \n        } else { \n            count_rest \n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, times: Vec<i8>, T: i8) -> (result: i8)\n    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)\n    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    n\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_895.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 669, "minimize_time_ms": 122615, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {\n\nspec fn max_students_in_window(times: Seq<int>, T: int) -> int {\n\nspec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int\n    decreases max_start\n{\n\nspec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {\n\nspec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int\n    decreases times.len() - index\n{\n\n    decreases max_start\n\n    decreases times.len() - index\n\n    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)\n\n    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {\n    n >= 1 && times.len() == n && T >= 1 && \n    forall|i: int| 0 <= i < times.len() ==> 1 <= #[trigger] times[i] <= 1000\n}\n\nspec fn max_students_in_window(times: Seq<int>, T: int) -> int {\n    max_students_in_window_up_to(times, T, 1000)\n}\n\nspec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int\n    decreases max_start\n{\n    if max_start < 1 { \n        0\n    } else {\n        let count = count_students_in_window(times, max_start, T);\n        let rest_max = max_students_in_window_up_to(times, T, max_start - 1);\n        if count > rest_max { count } else { rest_max }\n    }\n}\n\nspec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {\n    if times.len() == 0 { \n        0 \n    } else { \n        count_students_in_window_helper(times, start, T, 0) \n    }\n}\n\nspec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int\n    decreases times.len() - index\n{\n    if index >= times.len() { \n        0\n    } else {\n        let count_rest = count_students_in_window_helper(times, start, T, index + 1);\n        if start <= times[index] <= start + T - 1 { \n            count_rest + 1 \n        } else { \n            count_rest \n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, times: Vec<i8>, T: i8) -> (result: i8)\n    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)\n    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    n\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_909_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10\n}\n\nspec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {\n    seq![a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]\n}\n\nspec fn max_expression(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] { exprs[0] }\n    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] { exprs[1] }\n    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] { exprs[2] }\n    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] { exprs[3] }\n    else if exprs[4] >= exprs[5] { exprs[4] }\n    else { exprs[5] }\n}\n\nspec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    exprs.contains(result) && forall|i: int| 0 <= i < exprs.len() ==> result >= exprs[i]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int),\n    ensures \n        is_max_of_all_expressions(result as int, a as int, b as int, c as int),\n        result as int == max_expression(a as int, b as int, c as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10\n}\n\nspec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {\n    seq![a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]\n}\n\nspec fn max_expression(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] { exprs[0] }\n    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] { exprs[1] }\n    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] { exprs[2] }\n    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] { exprs[3] }\n    else if exprs[4] >= exprs[5] { exprs[4] }\n    else { exprs[5] }\n}\n\nspec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    exprs.contains(result) && forall|i: int| 0 <= i < exprs.len() ==> result >= exprs[i]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int),\n    ensures \n        is_max_of_all_expressions(result as int, a as int, b as int, c as int),\n        result as int == max_expression(a as int, b as int, c as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_909.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 768, "minimize_time_ms": 92187, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int, c: int) -> bool {\n\nspec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {\n\nspec fn max_expression(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n\nspec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool\n    recommends valid_input(a, b, c)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10\n}\n\nspec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {\n    seq![a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]\n}\n\nspec fn max_expression(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] { exprs[0] }\n    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] { exprs[1] }\n    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] { exprs[2] }\n    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] { exprs[3] }\n    else if exprs[4] >= exprs[5] { exprs[4] }\n    else { exprs[5] }\n}\n\nspec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    exprs.contains(result) && forall|i: int| 0 <= i < exprs.len() ==> result >= exprs[i]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int),\n    ensures \n        is_max_of_all_expressions(result as int, a as int, b as int, c as int),\n        result as int == max_expression(a as int, b as int, c as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_925_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 2 && \n    '0' <= input[0] <= '9' && \n    '0' <= input[1] <= '9' &&\n    (input[input.len() - 1] == '\\n' || (input[0] != '\\n' && input[1] != '\\n'))\n}\n\nspec fn good_digit_count(digit: char) -> int \n    recommends '0' <= digit <= '9'\n{\n    if digit == '0' { 2 }\n    else if digit == '1' { 7 }\n    else if digit == '2' { 2 }\n    else if digit == '3' { 3 }\n    else if digit == '4' { 3 }\n    else if digit == '5' { 4 }\n    else if digit == '6' { 2 }\n    else if digit == '7' { 5 }\n    else if digit == '8' { 1 }\n    else { 2 }\n}\n\nspec fn compute_total_good_count(input: Seq<char>) -> int \n    recommends valid_input(input)\n{\n    good_digit_count(input[0]) * good_digit_count(input[1])\n}\n\nspec fn valid_output(result: Seq<char>, expected_count: int) -> bool {\n    result.len() >= 2 && \n    result[result.len() - 1] == '\\n' &&\n    (forall|c: char| result.contains(c) ==> c == '\\n' || ('0' <= c <= '9')) &&\n    expected_count >= 1 && expected_count <= 49\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@, compute_total_good_count(input@))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 2 && \n    '0' <= input[0] <= '9' && \n    '0' <= input[1] <= '9' &&\n    (input[input.len() - 1] == '\\n' || (input[0] != '\\n' && input[1] != '\\n'))\n}\n\nspec fn good_digit_count(digit: char) -> int \n    recommends '0' <= digit <= '9'\n{\n    if digit == '0' { 2 }\n    else if digit == '1' { 7 }\n    else if digit == '2' { 2 }\n    else if digit == '3' { 3 }\n    else if digit == '4' { 3 }\n    else if digit == '5' { 4 }\n    else if digit == '6' { 2 }\n    else if digit == '7' { 5 }\n    else if digit == '8' { 1 }\n    else { 2 }\n}\n\nspec fn compute_total_good_count(input: Seq<char>) -> int \n    recommends valid_input(input)\n{\n    good_digit_count(input[0]) * good_digit_count(input[1])\n}\n\nspec fn valid_output(result: Seq<char>, expected_count: int) -> bool {\n    result.len() >= 2 && \n    result[result.len() - 1] == '\\n' &&\n    (forall|c: char| result.contains(c) ==> c == '\\n' || ('0' <= c <= '9')) &&\n    expected_count >= 1 && expected_count <= 49\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@, compute_total_good_count(input@))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_925.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 661, "minimize_time_ms": 92089, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn good_digit_count(digit: char) -> int \n    recommends '0' <= digit <= '9'\n{\n\nspec fn compute_total_good_count(input: Seq<char>) -> int \n    recommends valid_input(input)\n{\n\nspec fn valid_output(result: Seq<char>, expected_count: int) -> bool {\n\n    requires valid_input(input@)\n\n    ensures valid_output(result@, compute_total_good_count(input@))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 2 && \n    '0' <= input[0] <= '9' && \n    '0' <= input[1] <= '9' &&\n    (input[input.len() - 1] == '\\n' || (input[0] != '\\n' && input[1] != '\\n'))\n}\n\nspec fn good_digit_count(digit: char) -> int \n    recommends '0' <= digit <= '9'\n{\n    if digit == '0' { 2 }\n    else if digit == '1' { 7 }\n    else if digit == '2' { 2 }\n    else if digit == '3' { 3 }\n    else if digit == '4' { 3 }\n    else if digit == '5' { 4 }\n    else if digit == '6' { 2 }\n    else if digit == '7' { 5 }\n    else if digit == '8' { 1 }\n    else { 2 }\n}\n\nspec fn compute_total_good_count(input: Seq<char>) -> int \n    recommends valid_input(input)\n{\n    good_digit_count(input[0]) * good_digit_count(input[1])\n}\n\nspec fn valid_output(result: Seq<char>, expected_count: int) -> bool {\n    result.len() >= 2 && \n    result[result.len() - 1] == '\\n' &&\n    (forall|c: char| result.contains(c) ==> c == '\\n' || ('0' <= c <= '9')) &&\n    expected_count >= 1 && expected_count <= 49\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@, compute_total_good_count(input@))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_948_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    n >= 1 && m >= 1 && grid.len() == n &&\n    forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == m\n}\n\nspec fn count_face_squares(input: Seq<char>) -> int\n    decreases input.len()\n{\n    if input.len() == 0 {\n        0\n    } else {\n        /* Parse input and count valid face squares */\n        0  /* Placeholder - actual implementation would parse lines and count squares */\n    }\n}\n\nspec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {\n    /* Convert count to string representation */\n    seq!['0', '\\n']  /* Placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires \n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        result@ == count_face_squares_as_string(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    n >= 1 && m >= 1 && grid.len() == n &&\n    forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == m\n}\n\nspec fn count_face_squares(input: Seq<char>) -> int\n    decreases input.len()\n{\n    if input.len() == 0 {\n        0\n    } else {\n        /* Parse input and count valid face squares */\n        0  /* Placeholder - actual implementation would parse lines and count squares */\n    }\n}\n\nspec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {\n    /* Convert count to string representation */\n    seq!['0', '\\n']  /* Placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires \n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        result@ == count_face_squares_as_string(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_948.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 754, "minimize_time_ms": 92330, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::", "vstd::string::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n\nspec fn count_face_squares(input: Seq<char>) -> int\n    decreases input.len()\n{\n\nspec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {\n\n    decreases input.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    n >= 1 && m >= 1 && grid.len() == n &&\n    forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == m\n}\n\nspec fn count_face_squares(input: Seq<char>) -> int\n    decreases input.len()\n{\n    if input.len() == 0 {\n        0\n    } else {\n        /* Parse input and count valid face squares */\n        0  /* Placeholder - actual implementation would parse lines and count squares */\n    }\n}\n\nspec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {\n    /* Convert count to string representation */\n    seq!['0', '\\n']  /* Placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires \n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        result@ == count_face_squares_as_string(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_954_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>\n{\n    if s.len() > 0 { s.subrange(1, s.len() as int).add(seq![s[0]]) } else { s }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool\n{\n    s.len() > 0\n}\n\nspec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>\n    decreases steps\n{\n    if s.len() > 0 && steps > 0 { cyclic_shift_forward(apply_shifts(s, (steps - 1) as nat)) }\n    else if s.len() > 0 { s }\n    else { s }\n}\n\nspec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat\n{\n    if s.len() > 0 { s.len() } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        1 <= result <= s.len(),\n        result == all_distinct_cyclic_shifts(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>\n{\n    if s.len() > 0 { s.subrange(1, s.len() as int).add(seq![s[0]]) } else { s }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool\n{\n    s.len() > 0\n}\n\nspec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>\n    decreases steps\n{\n    if s.len() > 0 && steps > 0 { cyclic_shift_forward(apply_shifts(s, (steps - 1) as nat)) }\n    else if s.len() > 0 { s }\n    else { s }\n}\n\nspec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat\n{\n    if s.len() > 0 { s.len() } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        1 <= result <= s.len(),\n        result == all_distinct_cyclic_shifts(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_954.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 660, "minimize_time_ms": 92049, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>\n{\n\nspec fn valid_input(s: Seq<char>) -> bool\n{\n\nspec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>\n    decreases steps\n{\n\nspec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat\n{\n\n    decreases steps\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>\n{\n    if s.len() > 0 { s.subrange(1, s.len() as int).add(seq![s[0]]) } else { s }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool\n{\n    s.len() > 0\n}\n\nspec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>\n    decreases steps\n{\n    if s.len() > 0 && steps > 0 { cyclic_shift_forward(apply_shifts(s, (steps - 1) as nat)) }\n    else if s.len() > 0 { s }\n    else { s }\n}\n\nspec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat\n{\n    if s.len() > 0 { s.len() } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        1 <= result <= s.len(),\n        result == all_distinct_cyclic_shifts(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_963_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {\n    n >= 2 &&\n    k >= 1 &&\n    segments.len() == k &&\n    (forall|i: int| 0 <= i < k ==> segments[i].0 >= 1 && segments[i].1 <= n && segments[i].0 <= segments[i].1) &&\n    (forall|i: int, j: int| 0 <= i < j < k ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)\n}\n\nspec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {\n    let dp = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    let prefix_sum = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    compute_ways_dp_helper(n, k, segments, dp, prefix_sum, 2)\n}\n\nspec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int\n    decreases n - pos + 1\n{\n    if pos > n {\n        dp[n] % 998244353\n    } else {\n        let new_dp_val = compute_segment_contributions(pos, k, segments, prefix_sum, 0, 0);\n        let new_prefix_sum_val = (prefix_sum[pos-1] + new_dp_val) % 998244353;\n        let updated_dp = dp.insert(pos, new_dp_val);\n        let updated_prefix_sum = prefix_sum.insert(pos, new_prefix_sum_val);\n        compute_ways_dp_helper(n, k, segments, updated_dp, updated_prefix_sum, pos + 1)\n    }\n}\n\nspec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int\n    decreases k - seg_index\n{\n    if seg_index >= k {\n        acc\n    } else {\n        let start = segments[seg_index].0;\n        let end = segments[seg_index].1;\n        let i_s = if pos - start >= 0 { pos - start } else { 0 };\n        let i_e = if pos - end - 1 >= 0 { pos - end - 1 } else { 0 };\n        let contribution = (prefix_sum[i_s] - prefix_sum[i_e] + 998244353) % 998244353;\n        let new_acc = (acc + contribution) % 998244353;\n        compute_segment_contributions(pos, k, segments, prefix_sum, seg_index + 1, new_acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, segments: Vec<(i8, i8)>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n    ensures \n        result < 998244353 &&\n        result == compute_ways_dp(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {\n    n >= 2 &&\n    k >= 1 &&\n    segments.len() == k &&\n    (forall|i: int| 0 <= i < k ==> segments[i].0 >= 1 && segments[i].1 <= n && segments[i].0 <= segments[i].1) &&\n    (forall|i: int, j: int| 0 <= i < j < k ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)\n}\n\nspec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {\n    let dp = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    let prefix_sum = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    compute_ways_dp_helper(n, k, segments, dp, prefix_sum, 2)\n}\n\nspec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int\n    decreases n - pos + 1\n{\n    if pos > n {\n        dp[n] % 998244353\n    } else {\n        let new_dp_val = compute_segment_contributions(pos, k, segments, prefix_sum, 0, 0);\n        let new_prefix_sum_val = (prefix_sum[pos-1] + new_dp_val) % 998244353;\n        let updated_dp = dp.insert(pos, new_dp_val);\n        let updated_prefix_sum = prefix_sum.insert(pos, new_prefix_sum_val);\n        compute_ways_dp_helper(n, k, segments, updated_dp, updated_prefix_sum, pos + 1)\n    }\n}\n\nspec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int\n    decreases k - seg_index\n{\n    if seg_index >= k {\n        acc\n    } else {\n        let start = segments[seg_index].0;\n        let end = segments[seg_index].1;\n        let i_s = if pos - start >= 0 { pos - start } else { 0 };\n        let i_e = if pos - end - 1 >= 0 { pos - end - 1 } else { 0 };\n        let contribution = (prefix_sum[i_s] - prefix_sum[i_e] + 998244353) % 998244353;\n        let new_acc = (acc + contribution) % 998244353;\n        compute_segment_contributions(pos, k, segments, prefix_sum, seg_index + 1, new_acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, segments: Vec<(i8, i8)>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n    ensures \n        result < 998244353 &&\n        result == compute_ways_dp(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_963.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 849, "minimize_time_ms": 92324, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 72, "minimized_LOC": 72, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {\n\nspec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {\n\nspec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int\n    decreases n - pos + 1\n{\n\nspec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int\n    decreases k - seg_index\n{\n\n    decreases n - pos + 1\n\n    decreases k - seg_index\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {\n    n >= 2 &&\n    k >= 1 &&\n    segments.len() == k &&\n    (forall|i: int| 0 <= i < k ==> segments[i].0 >= 1 && segments[i].1 <= n && segments[i].0 <= segments[i].1) &&\n    (forall|i: int, j: int| 0 <= i < j < k ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)\n}\n\nspec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {\n    let dp = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    let prefix_sum = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    compute_ways_dp_helper(n, k, segments, dp, prefix_sum, 2)\n}\n\nspec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int\n    decreases n - pos + 1\n{\n    if pos > n {\n        dp[n] % 998244353\n    } else {\n        let new_dp_val = compute_segment_contributions(pos, k, segments, prefix_sum, 0, 0);\n        let new_prefix_sum_val = (prefix_sum[pos-1] + new_dp_val) % 998244353;\n        let updated_dp = dp.insert(pos, new_dp_val);\n        let updated_prefix_sum = prefix_sum.insert(pos, new_prefix_sum_val);\n        compute_ways_dp_helper(n, k, segments, updated_dp, updated_prefix_sum, pos + 1)\n    }\n}\n\nspec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int\n    decreases k - seg_index\n{\n    if seg_index >= k {\n        acc\n    } else {\n        let start = segments[seg_index].0;\n        let end = segments[seg_index].1;\n        let i_s = if pos - start >= 0 { pos - start } else { 0 };\n        let i_e = if pos - end - 1 >= 0 { pos - end - 1 } else { 0 };\n        let contribution = (prefix_sum[i_s] - prefix_sum[i_e] + 998244353) % 998244353;\n        let new_acc = (acc + contribution) % 998244353;\n        compute_segment_contributions(pos, k, segments, prefix_sum, seg_index + 1, new_acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, segments: Vec<(i8, i8)>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n    ensures \n        result < 998244353 &&\n        result == compute_ways_dp(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_965_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, statuses: Seq<char>) -> bool {\n    n >= 2 && statuses.len() == n && \n    forall|i: int| 0 <= i < statuses.len() ==> (statuses[i] == 'A' || statuses[i] == 'I' || statuses[i] == 'F')\n}\n\nspec fn count_status(statuses: Seq<char>, status: char) -> int {\n    seq_count(statuses, status)\n}\n\nspec fn seq_count(s: Seq<char>, target: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let rest_count = seq_count(s.drop_first(), target);\n        if s[0] == target {\n            rest_count + 1\n        } else {\n            rest_count\n        }\n    }\n}\n\nspec fn expected_result(statuses: Seq<char>) -> int {\n    let cnt_i = count_status(statuses, 'I');\n    let cnt_a = count_status(statuses, 'A');\n    if cnt_i == 0 { cnt_a }\n    else if cnt_i == 1 { 1 }\n    else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, statuses: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, statuses@)\n    ensures result as int == expected_result(statuses@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, statuses: Seq<char>) -> bool {\n    n >= 2 && statuses.len() == n && \n    forall|i: int| 0 <= i < statuses.len() ==> (statuses[i] == 'A' || statuses[i] == 'I' || statuses[i] == 'F')\n}\n\nspec fn count_status(statuses: Seq<char>, status: char) -> int {\n    seq_count(statuses, status)\n}\n\nspec fn seq_count(s: Seq<char>, target: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let rest_count = seq_count(s.drop_first(), target);\n        if s[0] == target {\n            rest_count + 1\n        } else {\n            rest_count\n        }\n    }\n}\n\nspec fn expected_result(statuses: Seq<char>) -> int {\n    let cnt_i = count_status(statuses, 'I');\n    let cnt_a = count_status(statuses, 'A');\n    if cnt_i == 0 { cnt_a }\n    else if cnt_i == 1 { 1 }\n    else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, statuses: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, statuses@)\n    ensures result as int == expected_result(statuses@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_965.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 880, "minimize_time_ms": 92266, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, statuses: Seq<char>) -> bool {\n\nspec fn count_status(statuses: Seq<char>, status: char) -> int {\n\nspec fn seq_count(s: Seq<char>, target: char) -> int\n    decreases s.len()\n{\n\nspec fn expected_result(statuses: Seq<char>) -> int {\n\n    decreases s.len()\n\n    requires valid_input(n as int, statuses@)\n\n    ensures result as int == expected_result(statuses@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, statuses: Seq<char>) -> bool {\n    n >= 2 && statuses.len() == n && \n    forall|i: int| 0 <= i < statuses.len() ==> (statuses[i] == 'A' || statuses[i] == 'I' || statuses[i] == 'F')\n}\n\nspec fn count_status(statuses: Seq<char>, status: char) -> int {\n    seq_count(statuses, status)\n}\n\nspec fn seq_count(s: Seq<char>, target: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let rest_count = seq_count(s.drop_first(), target);\n        if s[0] == target {\n            rest_count + 1\n        } else {\n            rest_count\n        }\n    }\n}\n\nspec fn expected_result(statuses: Seq<char>) -> int {\n    let cnt_i = count_status(statuses, 'I');\n    let cnt_a = count_status(statuses, 'A');\n    if cnt_i == 0 { cnt_a }\n    else if cnt_i == 1 { 1 }\n    else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, statuses: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, statuses@)\n    ensures result as int == expected_result(statuses@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_967_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    0 <= result <= n\n}\n\nspec fn reversed_array(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    Seq::new(a.len(), |i: int| a[a.len() - 1 - i])\n}\n\nspec fn has_increasing_pair(ar: Seq<int>) -> bool {\n    exists|i: int| 1 <= i < ar.len() && #[trigger] ar[i] > ar[i-1]\n}\n\nspec fn min_index(ar: Seq<int>, n: int) -> int {\n    0\n}\n\nspec fn correct_result(n: int, a: Seq<int>) -> int\n    recommends valid_input(n, a)\n{\n    let ar = reversed_array(a);\n    if has_increasing_pair(ar) {\n        let min_i = min_index(ar, n);\n        n - min_i\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map_values(|x: i8| x as int))\n    ensures \n        valid_output(n as int, result as int) &&\n        result as int == correct_result(n as int, a@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    0 <= result <= n\n}\n\nspec fn reversed_array(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    Seq::new(a.len(), |i: int| a[a.len() - 1 - i])\n}\n\nspec fn has_increasing_pair(ar: Seq<int>) -> bool {\n    exists|i: int| 1 <= i < ar.len() && #[trigger] ar[i] > ar[i-1]\n}\n\nspec fn min_index(ar: Seq<int>, n: int) -> int {\n    0\n}\n\nspec fn correct_result(n: int, a: Seq<int>) -> int\n    recommends valid_input(n, a)\n{\n    let ar = reversed_array(a);\n    if has_increasing_pair(ar) {\n        let min_i = min_index(ar, n);\n        n - min_i\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map_values(|x: i8| x as int))\n    ensures \n        valid_output(n as int, result as int) &&\n        result as int == correct_result(n as int, a@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_967.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 798, "minimize_time_ms": 122451, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 65, "minimized_LOC": 65, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>) -> bool {\n\nspec fn valid_output(n: int, result: int) -> bool {\n\nspec fn reversed_array(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n\nspec fn has_increasing_pair(ar: Seq<int>) -> bool {\n\nspec fn min_index(ar: Seq<int>, n: int) -> int {\n\nspec fn correct_result(n: int, a: Seq<int>) -> int\n    recommends valid_input(n, a)\n{\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    0 <= result <= n\n}\n\nspec fn reversed_array(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    Seq::new(a.len(), |i: int| a[a.len() - 1 - i])\n}\n\nspec fn has_increasing_pair(ar: Seq<int>) -> bool {\n    exists|i: int| 1 <= i < ar.len() && #[trigger] ar[i] > ar[i-1]\n}\n\nspec fn min_index(ar: Seq<int>, n: int) -> int {\n    0\n}\n\nspec fn correct_result(n: int, a: Seq<int>) -> int\n    recommends valid_input(n, a)\n{\n    let ar = reversed_array(a);\n    if has_increasing_pair(ar) {\n        let min_i = min_index(ar, n);\n        n - min_i\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map_values(|x: i8| x as int))\n    ensures \n        valid_output(n as int, result as int) &&\n        result as int == correct_result(n as int, a@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_968_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n  recommends input.len() > 0\n{\n  let parsed = parse_input(input);\n  parsed.valid && \n  parsed.n >= 1 && \n  parsed.names.len() == parsed.n &&\n  parsed.permutation.len() == parsed.n &&\n  permutation_values_in_range(parsed.permutation, parsed.n) &&\n  permutation_is_unique(parsed.permutation, parsed.n) &&\n  names_are_non_empty(parsed.names, parsed.n) &&\n  all_names_distinct(parsed.names)\n}\n\nspec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool {\n  forall|i: int| 0 <= i < n ==> {\n    let val = #[trigger] permutation[i];\n    1 <= val <= n\n  }\n}\n\nspec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool {\n  forall|i: int, j: int| 0 <= i < j < n ==> {\n    #[trigger] permutation[i] != #[trigger] permutation[j]\n  }\n}\n\nspec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool {\n  forall|i: int| 0 <= i < n ==> {\n    let name_pair = #[trigger] names[i];\n    name_pair.0.len() > 0 && name_pair.1.len() > 0\n  }\n}\n\nspec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool\n{\n  forall|i: int, j: int| 0 <= i < names.len() && 0 <= j < names.len() ==>\n    (i != j ==> {\n      let name_i = #[trigger] names[i];\n      let name_j = #[trigger] names[j];\n      name_i.0 != name_j.0 && name_i.0 != name_j.1 && \n      name_i.1 != name_j.0 && name_i.1 != name_j.1\n    })\n}\n\nspec fn can_assign_handles_greedy(input: Seq<char>) -> bool\n  recommends input.len() > 0 && valid_input(input)\n{\n  let parsed = parse_input(input);\n  let all_handles = create_all_handle_pairs(parsed.names);\n  let sorted_handles = sort_handle_pairs(all_handles);\n  greedy_assignment_works(sorted_handles, parsed.permutation, parsed.n)\n}\n\nstruct ParseResult {\n  valid: bool,\n  n: int,\n  names: Seq<(Seq<char>, Seq<char>)>,\n  permutation: Seq<int>,\n}\n\nstruct IntResult {\n  valid: bool,\n  value: int,\n}\n\nstruct IntSequenceResult {\n  valid: bool,\n  sequence: Seq<int>,\n}\n\nspec fn parse_input(input: Seq<char>) -> ParseResult\n  recommends input.len() > 0\n{\n  let lines = split_lines(input);\n  if lines.len() < 2 {\n    ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n  } else {\n    let n_result = parse_int(lines[0]);\n    if !n_result.valid || n_result.value <= 0 || lines.len() != n_result.value + 2 {\n      ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n    } else {\n      let names = parse_names(lines.subrange(1, n_result.value + 1));\n      let perm = parse_int_sequence(lines[n_result.value + 1]);\n      if names.len() == n_result.value && perm.valid && perm.sequence.len() == n_result.value {\n        ParseResult { valid: true, n: n_result.value, names: names, permutation: perm.sequence }\n      } else {\n        ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n      }\n    }\n  }\n}\n\nspec fn lex_less(a: Seq<char>, b: Seq<char>) -> bool\n  decreases a.len()\n{\n  if a.len() == 0 {\n    b.len() > 0\n  } else if b.len() == 0 {\n    false\n  } else if a[0] < b[0] {\n    true\n  } else if a[0] > b[0] {\n    false\n  } else {\n    lex_less(a.subrange(1, a.len() as int), b.subrange(1, b.len() as int))\n  }\n}\n\nspec fn lex_less_or_equal(a: Seq<char>, b: Seq<char>) -> bool\n{\n  lex_less(a, b) || a == b\n}\n\n/* Placeholder spec functions for missing dependencies */\nspec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n  seq![]\n}\n\nspec(checked) fn parse_int(line: Seq<char>) -> IntResult {\n  IntResult { valid: false, value: 0 }\n}\n\nspec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> {\n  seq![]\n}\n\nspec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult {\n  IntSequenceResult { valid: false, sequence: seq![] }\n}\n\nspec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> {\n  seq![]\n}\n\nspec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> {\n  handles\n}\n\nspec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool {\n  false\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n  requires\n    stdin_input@.len() > 0,\n    valid_input(stdin_input@),\n  ensures\n    result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n    (result@ == seq!['Y', 'E', 'S']) <==> can_assign_handles_greedy(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  vec!['N', 'O']\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool ;\n       spec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool ;\n       spec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool ;\n       spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool ;\n       struct ParseResult {\n        valid: bool,   n: int,   names: Seq<(Seq<char>, Seq<char>)>,   permutation: Seq<int>, }\n       struct IntResult {\n        valid: bool,   value: int, }\n       struct IntSequenceResult {\n        valid: bool,   sequence: Seq<int>, }\n       spec fn parse_input(input: Seq<char>) -> ParseResult   recommends input.len() > 0 ;\n       spec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec(checked) fn parse_int(line: Seq<char>) -> IntResult ;\n       spec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> ;\n       spec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult ;\n       spec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> ;\n       spec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> ;\n       spec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool ;\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_968.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 973, "minimize_time_ms": 184227, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 174, "minimized_LOC": 23, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.13218390804597702}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool ;\n       spec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool ;\n       spec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool ;\n       spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool ;\n       struct ParseResult {\n\nspec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool ;\n       spec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool ;\n       spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool ;\n       struct ParseResult {\n\nspec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool ;\n       spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool ;\n       struct ParseResult {\n\nspec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool ;\n       struct ParseResult {\n\nspec fn parse_input(input: Seq<char>) -> ParseResult   recommends input.len() > 0 ;\n       spec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec(checked) fn parse_int(line: Seq<char>) -> IntResult ;\n       spec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> ;\n       spec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult ;\n       spec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> ;\n       spec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> ;\n       spec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool ;\n       }\n        fn main() {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n  recommends input.len() > 0\n{\n  let parsed = parse_input(input);\n  parsed.valid && \n  parsed.n >= 1 && \n  parsed.names.len() == parsed.n &&\n  parsed.permutation.len() == parsed.n &&\n  permutation_values_in_range(parsed.permutation, parsed.n) &&\n  permutation_is_unique(parsed.permutation, parsed.n) &&\n  names_are_non_empty(parsed.names, parsed.n) &&\n  all_names_distinct(parsed.names)\n}\n\nspec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool {\n  forall|i: int| 0 <= i < n ==> {\n    let val = #[trigger] permutation[i];\n    1 <= val <= n\n  }\n}\n\nspec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool {\n  forall|i: int, j: int| 0 <= i < j < n ==> {\n    #[trigger] permutation[i] != #[trigger] permutation[j]\n  }\n}\n\nspec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool {\n  forall|i: int| 0 <= i < n ==> {\n    let name_pair = #[trigger] names[i];\n    name_pair.0.len() > 0 && name_pair.1.len() > 0\n  }\n}\n\nspec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool\n{\n  forall|i: int, j: int| 0 <= i < names.len() && 0 <= j < names.len() ==>\n    (i != j ==> {\n      let name_i = #[trigger] names[i];\n      let name_j = #[trigger] names[j];\n      name_i.0 != name_j.0 && name_i.0 != name_j.1 && \n      name_i.1 != name_j.0 && name_i.1 != name_j.1\n    })\n}\n\nspec fn can_assign_handles_greedy(input: Seq<char>) -> bool\n  recommends input.len() > 0 && valid_input(input)\n{\n  let parsed = parse_input(input);\n  let all_handles = create_all_handle_pairs(parsed.names);\n  let sorted_handles = sort_handle_pairs(all_handles);\n  greedy_assignment_works(sorted_handles, parsed.permutation, parsed.n)\n}\n\nstruct ParseResult {\n  valid: bool,\n  n: int,\n  names: Seq<(Seq<char>, Seq<char>)>,\n  permutation: Seq<int>,\n}\n\nstruct IntResult {\n  valid: bool,\n  value: int,\n}\n\nstruct IntSequenceResult {\n  valid: bool,\n  sequence: Seq<int>,\n}\n\nspec fn parse_input(input: Seq<char>) -> ParseResult\n  recommends input.len() > 0\n{\n  let lines = split_lines(input);\n  if lines.len() < 2 {\n    ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n  } else {\n    let n_result = parse_int(lines[0]);\n    if !n_result.valid || n_result.value <= 0 || lines.len() != n_result.value + 2 {\n      ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n    } else {\n      let names = parse_names(lines.subrange(1, n_result.value + 1));\n      let perm = parse_int_sequence(lines[n_result.value + 1]);\n      if names.len() == n_result.value && perm.valid && perm.sequence.len() == n_result.value {\n        ParseResult { valid: true, n: n_result.value, names: names, permutation: perm.sequence }\n      } else {\n        ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n      }\n    }\n  }\n}\n\nspec fn lex_less(a: Seq<char>, b: Seq<char>) -> bool\n  decreases a.len()\n{\n  if a.len() == 0 {\n    b.len() > 0\n  } else if b.len() == 0 {\n    false\n  } else if a[0] < b[0] {\n    true\n  } else if a[0] > b[0] {\n    false\n  } else {\n    lex_less(a.subrange(1, a.len() as int), b.subrange(1, b.len() as int))\n  }\n}\n\nspec fn lex_less_or_equal(a: Seq<char>, b: Seq<char>) -> bool\n{\n  lex_less(a, b) || a == b\n}\n\n/* Placeholder spec functions for missing dependencies */\nspec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n  seq![]\n}\n\nspec(checked) fn parse_int(line: Seq<char>) -> IntResult {\n  IntResult { valid: false, value: 0 }\n}\n\nspec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> {\n  seq![]\n}\n\nspec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult {\n  IntSequenceResult { valid: false, sequence: seq![] }\n}\n\nspec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> {\n  seq![]\n}\n\nspec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> {\n  handles\n}\n\nspec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool {\n  false\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n  requires\n    stdin_input@.len() > 0,\n    valid_input(stdin_input@),\n  ensures\n    result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n    (result@ == seq!['Y', 'E', 'S']) <==> can_assign_handles_greedy(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  vec!['N', 'O']\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool ;\n       spec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool ;\n       spec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool ;\n       spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool ;\n       struct ParseResult {\n        valid: bool,   n: int,   names: Seq<(Seq<char>, Seq<char>)>,   permutation: Seq<int>, }\n       struct IntResult {\n        valid: bool,   value: int, }\n       struct IntSequenceResult {\n        valid: bool,   sequence: Seq<int>, }\n       spec fn parse_input(input: Seq<char>) -> ParseResult   recommends input.len() > 0 ;\n       spec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec(checked) fn parse_int(line: Seq<char>) -> IntResult ;\n       spec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> ;\n       spec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult ;\n       spec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> ;\n       spec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> ;\n       spec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool ;\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n          fn main() {\n}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_983_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_prefix(s: Seq<int>, i: nat) -> int\n    recommends i < s.len()\n    decreases i\n{\n    if i == 0 { s[0] }\n    else if s[i as int] > max_prefix(s, (i-1) as nat) { s[i as int] }\n    else { max_prefix(s, (i-1) as nat) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { s[0] }\n    else {\n        let sub_seq = s.subrange(0, (s.len()-1) as int);\n        if s[(s.len()-1) as int] > max_seq(sub_seq) { s[(s.len()-1) as int] }\n        else { max_seq(sub_seq) }\n    }\n}\n\nspec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int\n    recommends n > 0 && a.len() == n\n{\n    let s1 = Seq::new(n as nat, |i: int| a[i] * p);\n    let s2 = Seq::new(n as nat, |i: int| max_prefix(s1, i as nat) + a[i] * q);\n    let s3 = Seq::new(n as nat, |i: int| max_prefix(s2, i as nat) + a[i] * r);\n    max_seq(s3)\n}\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool\n{\n    n > 0 && a.len() == n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, q: i8, r: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|i, x| x as int))\n    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_prefix(s: Seq<int>, i: nat) -> int\n    recommends i < s.len()\n    decreases i\n{\n    if i == 0 { s[0] }\n    else if s[i as int] > max_prefix(s, (i-1) as nat) { s[i as int] }\n    else { max_prefix(s, (i-1) as nat) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { s[0] }\n    else {\n        let sub_seq = s.subrange(0, (s.len()-1) as int);\n        if s[(s.len()-1) as int] > max_seq(sub_seq) { s[(s.len()-1) as int] }\n        else { max_seq(sub_seq) }\n    }\n}\n\nspec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int\n    recommends n > 0 && a.len() == n\n{\n    let s1 = Seq::new(n as nat, |i: int| a[i] * p);\n    let s2 = Seq::new(n as nat, |i: int| max_prefix(s1, i as nat) + a[i] * q);\n    let s3 = Seq::new(n as nat, |i: int| max_prefix(s2, i as nat) + a[i] * r);\n    max_seq(s3)\n}\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool\n{\n    n > 0 && a.len() == n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, q: i8, r: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|i, x| x as int))\n    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_983.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 705, "minimize_time_ms": 92455, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn max_prefix(s: Seq<int>, i: nat) -> int\n    recommends i < s.len()\n    decreases i\n{\n\nspec fn max_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n\nspec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int\n    recommends n > 0 && a.len() == n\n{\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool\n{\n\n    decreases i\n\n    decreases s.len()\n\n    requires valid_input(n as int, a@.map(|i, x| x as int))\n\n    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_prefix(s: Seq<int>, i: nat) -> int\n    recommends i < s.len()\n    decreases i\n{\n    if i == 0 { s[0] }\n    else if s[i as int] > max_prefix(s, (i-1) as nat) { s[i as int] }\n    else { max_prefix(s, (i-1) as nat) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { s[0] }\n    else {\n        let sub_seq = s.subrange(0, (s.len()-1) as int);\n        if s[(s.len()-1) as int] > max_seq(sub_seq) { s[(s.len()-1) as int] }\n        else { max_seq(sub_seq) }\n    }\n}\n\nspec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int\n    recommends n > 0 && a.len() == n\n{\n    let s1 = Seq::new(n as nat, |i: int| a[i] * p);\n    let s2 = Seq::new(n as nat, |i: int| max_prefix(s1, i as nat) + a[i] * q);\n    let s3 = Seq::new(n as nat, |i: int| max_prefix(s2, i as nat) + a[i] * r);\n    max_seq(s3)\n}\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool\n{\n    n > 0 && a.len() == n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, q: i8, r: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|i, x| x as int))\n    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_989_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 5 && has_valid_format(input)\n}\n\nspec fn has_valid_format(input: Seq<char>) -> bool {\n    exists|first_newline: int| \n        0 <= first_newline < input.len() \n        && #[trigger] input[first_newline] == '\\n'\n        && (input.len() == first_newline + 1 || input[input.len() - 1] == '\\n')\n}\n\nspec fn is_valid_result_string(result: Seq<char>) -> bool {\n    result.len() > 0 && \n    (result == seq!['0'] || (result[0] != '0' && forall|i: int| 0 <= i < result.len() ==> #[trigger] is_digit(result[i])))\n}\n\nspec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) && \n    is_valid_result_string(result) &&\n    result == seq!['0']\n}\n\nspec fn max(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_max = max(a.subrange(1, a.len() as int));\n        if a[0] >= tail_max { a[0] } else { tail_max }\n    }\n}\n\nspec fn min(a: Seq<int>) -> int  \n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_min = min(a.subrange(1, a.len() as int));\n        if a[0] <= tail_min { a[0] } else { tail_min }\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_helper(n)\n    } else {\n        seq!['-'].add(int_to_string_helper(-n))\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![(n + 48) as char]\n    } else {\n        int_to_string_helper(n / 10).add(seq![(n % 10 + 48) as char])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        is_valid_result_string(result@),\n        represents_minimum_difference(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 5 && has_valid_format(input)\n}\n\nspec fn has_valid_format(input: Seq<char>) -> bool {\n    exists|first_newline: int| \n        0 <= first_newline < input.len() \n        && #[trigger] input[first_newline] == '\\n'\n        && (input.len() == first_newline + 1 || input[input.len() - 1] == '\\n')\n}\n\nspec fn is_valid_result_string(result: Seq<char>) -> bool {\n    result.len() > 0 && \n    (result == seq!['0'] || (result[0] != '0' && forall|i: int| 0 <= i < result.len() ==> #[trigger] is_digit(result[i])))\n}\n\nspec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) && \n    is_valid_result_string(result) &&\n    result == seq!['0']\n}\n\nspec fn max(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_max = max(a.subrange(1, a.len() as int));\n        if a[0] >= tail_max { a[0] } else { tail_max }\n    }\n}\n\nspec fn min(a: Seq<int>) -> int  \n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_min = min(a.subrange(1, a.len() as int));\n        if a[0] <= tail_min { a[0] } else { tail_min }\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_helper(n)\n    } else {\n        seq!['-'].add(int_to_string_helper(-n))\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![(n + 48) as char]\n    } else {\n        int_to_string_helper(n / 10).add(seq![(n % 10 + 48) as char])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        is_valid_result_string(result@),\n        represents_minimum_difference(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_989.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 784, "minimize_time_ms": 122416, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 101, "minimized_LOC": 101, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn has_valid_format(input: Seq<char>) -> bool {\n\nspec fn is_valid_result_string(result: Seq<char>) -> bool {\n\nspec fn is_digit(c: char) -> bool {\n\nspec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {\n\nspec fn max(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n\nspec fn min(a: Seq<int>) -> int  \n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n\n    decreases a.len()\n\n    decreases a.len()\n\n    decreases n\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 5 && has_valid_format(input)\n}\n\nspec fn has_valid_format(input: Seq<char>) -> bool {\n    exists|first_newline: int| \n        0 <= first_newline < input.len() \n        && #[trigger] input[first_newline] == '\\n'\n        && (input.len() == first_newline + 1 || input[input.len() - 1] == '\\n')\n}\n\nspec fn is_valid_result_string(result: Seq<char>) -> bool {\n    result.len() > 0 && \n    (result == seq!['0'] || (result[0] != '0' && forall|i: int| 0 <= i < result.len() ==> #[trigger] is_digit(result[i])))\n}\n\nspec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) && \n    is_valid_result_string(result) &&\n    result == seq!['0']\n}\n\nspec fn max(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_max = max(a.subrange(1, a.len() as int));\n        if a[0] >= tail_max { a[0] } else { tail_max }\n    }\n}\n\nspec fn min(a: Seq<int>) -> int  \n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_min = min(a.subrange(1, a.len() as int));\n        if a[0] <= tail_min { a[0] } else { tail_min }\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_helper(n)\n    } else {\n        seq!['-'].add(int_to_string_helper(-n))\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![(n + 48) as char]\n    } else {\n        int_to_string_helper(n / 10).add(seq![(n % 10 + 48) as char])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        is_valid_result_string(result@),\n        represents_minimum_difference(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1013_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['d', 'u', 'm', 'm', 'y']]\n}\n\nspec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['d', 'u', 'm', 'm', 'y']]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_m(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn result_two_newline() -> Seq<char> {\n    seq!['2', '\\n']\n}\n\nspec fn result_four_newline() -> Seq<char> {\n    seq!['4', '\\n']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@)\n    ensures\n        result@ =~= result_two_newline() || result@ =~= result_four_newline(),\n        result@ =~= result_two_newline() <==> (exists|i: int, j: int| \n            0 <= i < get_n(input@) && 0 <= j < get_m(input@) && \n            get_grid_cell(input@, i, j) =~= seq!['1'] && \n            (i == 0 || j == 0 || i == get_n(input@) - 1 || j == get_m(input@) - 1))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"2\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['d', 'u', 'm', 'm', 'y']]\n}\n\nspec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['d', 'u', 'm', 'm', 'y']]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_m(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn result_two_newline() -> Seq<char> {\n    seq!['2', '\\n']\n}\n\nspec fn result_four_newline() -> Seq<char> {\n    seq!['4', '\\n']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@)\n    ensures\n        result@ =~= result_two_newline() || result@ =~= result_four_newline(),\n        result@ =~= result_two_newline() <==> (exists|i: int, j: int| \n            0 <= i < get_n(input@) && 0 <= j < get_m(input@) && \n            get_grid_cell(input@, i, j) =~= seq!['1'] && \n            (i == 0 || j == 0 || i == get_n(input@) - 1 || j == get_m(input@) - 1))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"2\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1013.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 765, "minimize_time_ms": 122981, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 73, "minimized_LOC": 73, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {\n\nspec fn get_n(input: Seq<char>) -> int {\n\nspec fn get_m(input: Seq<char>) -> int {\n\nspec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {\n\nspec fn result_two_newline() -> Seq<char> {\n\nspec fn result_four_newline() -> Seq<char> {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['d', 'u', 'm', 'm', 'y']]\n}\n\nspec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['d', 'u', 'm', 'm', 'y']]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_m(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn result_two_newline() -> Seq<char> {\n    seq!['2', '\\n']\n}\n\nspec fn result_four_newline() -> Seq<char> {\n    seq!['4', '\\n']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@)\n    ensures\n        result@ =~= result_two_newline() || result@ =~= result_four_newline(),\n        result@ =~= result_two_newline() <==> (exists|i: int, j: int| \n            0 <= i < get_n(input@) && 0 <= j < get_m(input@) && \n            get_grid_cell(input@, i, j) =~= seq!['1'] && \n            (i == 0 || j == 0 || i == get_n(input@) - 1 || j == get_m(input@) - 1))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"2\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1027_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_parse_to_board(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {\n    board.len() == 14\n}\n\nspec fn string_represents_int(s: Seq<char>, n: int) -> bool {\n    s.len() > 0 && n >= 0\n}\n\nspec fn max_achievable_score_from_input(input: Seq<char>) -> int {\n    0\n}\n\nspec fn max_score_from_range(board: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if up_to == 0 { \n        0 \n    } else if board.len() == 14 && 0 <= up_to <= 14 && (forall|i: int| 0 <= i < 14 ==> board[i] >= 0) { \n        let prev_max = max_score_from_range(board, up_to - 1);\n        let current_score = if board[up_to - 1] == 0 { -1 } else { 0 };\n        if current_score > prev_max { current_score } else { prev_max }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        can_parse_to_board(stdin_input@),\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_parse_to_board(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {\n    board.len() == 14\n}\n\nspec fn string_represents_int(s: Seq<char>, n: int) -> bool {\n    s.len() > 0 && n >= 0\n}\n\nspec fn max_achievable_score_from_input(input: Seq<char>) -> int {\n    0\n}\n\nspec fn max_score_from_range(board: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if up_to == 0 { \n        0 \n    } else if board.len() == 14 && 0 <= up_to <= 14 && (forall|i: int| 0 <= i < 14 ==> board[i] >= 0) { \n        let prev_max = max_score_from_range(board, up_to - 1);\n        let current_score = if board[up_to - 1] == 0 { -1 } else { 0 };\n        if current_score > prev_max { current_score } else { prev_max }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        can_parse_to_board(stdin_input@),\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1027.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 792, "minimize_time_ms": 92333, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn can_parse_to_board(input: Seq<char>) -> bool {\n\nspec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {\n\nspec fn string_represents_int(s: Seq<char>, n: int) -> bool {\n\nspec fn max_achievable_score_from_input(input: Seq<char>) -> int {\n\nspec fn max_score_from_range(board: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n\n    decreases up_to\n\n    requires\n\n    ensures result@.len() > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_parse_to_board(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {\n    board.len() == 14\n}\n\nspec fn string_represents_int(s: Seq<char>, n: int) -> bool {\n    s.len() > 0 && n >= 0\n}\n\nspec fn max_achievable_score_from_input(input: Seq<char>) -> int {\n    0\n}\n\nspec fn max_score_from_range(board: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if up_to == 0 { \n        0 \n    } else if board.len() == 14 && 0 <= up_to <= 14 && (forall|i: int| 0 <= i < 14 ==> board[i] >= 0) { \n        let prev_max = max_score_from_range(board, up_to - 1);\n        let current_score = if board[up_to - 1] == 0 { -1 } else { 0 };\n        if current_score > prev_max { current_score } else { prev_max }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        can_parse_to_board(stdin_input@),\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1035_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n  a > 0 && b > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a > 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn count_distinct_prime_factors(n: int) -> int\n  recommends n > 0\n{\n  if n == 1 { 0 } else { 0 }\n}\n\nspec fn count_distinct_prime_factors_helper(n: int, i: int) -> int\n  recommends n > 0 && i >= 2\n{\n  0\n}\n\nspec fn divide_out_factor(n: int, factor: int) -> int\n  recommends n > 0 && factor > 1 && n % factor == 0\n{\n  n / factor\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n  recommends a > 0 && b > 0\n{\n  result == count_distinct_prime_factors(gcd(a, b)) + 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int) -> (result: int)\n    requires \n        valid_input(a, b),\n    ensures\n        result > 0,\n        correct_result(a, b, result),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n  a > 0 && b > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a > 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn count_distinct_prime_factors(n: int) -> int\n  recommends n > 0\n{\n  if n == 1 { 0 } else { 0 }\n}\n\nspec fn count_distinct_prime_factors_helper(n: int, i: int) -> int\n  recommends n > 0 && i >= 2\n{\n  0\n}\n\nspec fn divide_out_factor(n: int, factor: int) -> int\n  recommends n > 0 && factor > 1 && n % factor == 0\n{\n  n / factor\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n  recommends a > 0 && b > 0\n{\n  result == count_distinct_prime_factors(gcd(a, b)) + 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int) -> (result: int)\n    requires \n        valid_input(a, b),\n    ensures\n        result > 0,\n        correct_result(a, b, result),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1035.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 651, "minimize_time_ms": 92316, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: int, b: int) -> bool {\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a > 0 && b >= 0\n  decreases b when b >= 0\n{\n\nspec fn count_distinct_prime_factors(n: int) -> int\n  recommends n > 0\n{\n\nspec fn count_distinct_prime_factors_helper(n: int, i: int) -> int\n  recommends n > 0 && i >= 2\n{\n\nspec fn divide_out_factor(n: int, factor: int) -> int\n  recommends n > 0 && factor > 1 && n % factor == 0\n{\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n  recommends a > 0 && b > 0\n{\n\n  decreases b when b >= 0\n\n    requires \n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n  a > 0 && b > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a > 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn count_distinct_prime_factors(n: int) -> int\n  recommends n > 0\n{\n  if n == 1 { 0 } else { 0 }\n}\n\nspec fn count_distinct_prime_factors_helper(n: int, i: int) -> int\n  recommends n > 0 && i >= 2\n{\n  0\n}\n\nspec fn divide_out_factor(n: int, factor: int) -> int\n  recommends n > 0 && factor > 1 && n % factor == 0\n{\n  n / factor\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n  recommends a > 0 && b > 0\n{\n  result == count_distinct_prime_factors(gcd(a, b)) + 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int) -> (result: int)\n    requires \n        valid_input(a, b),\n    ensures\n        result > 0,\n        correct_result(a, b, result),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1044_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(s);\n    lines.len() >= 2 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let n = parse_int_spec(lines[0]);\n        let numbers = split_by_space_spec(lines[1]);\n        numbers.len() == n &&\n        forall|i: int| 0 <= i < numbers.len() ==> is_valid_integer(numbers[i])\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![], seq![]]\n}\n\nspec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    computes_correct_players(numbers, output_lines)\n}\n\nspec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {\n    numbers.len() == outputs.len() &&\n    {\n        let players = compute_players_sequence(numbers);\n        players.len() == outputs.len() &&\n        forall|i: int| 0 <= i < outputs.len() ==> \n            (players[i] == 1 ==> outputs[i] == seq!['1']) &&\n            (players[i] == 2 ==> outputs[i] == seq!['2'])\n    }\n}\n\nspec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        seq![]\n    } else {\n        compute_players_helper(numbers, 0, 2)\n    }\n}\n\nspec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>\n    decreases numbers.len() - index\n{\n    if index >= numbers.len() {\n        seq![]\n    } else {\n        let num = parse_int_spec(numbers[index]);\n        let next_player = if num % 2 == 0 { 3 - current_player } else { current_player };\n        seq![next_player].add(compute_players_helper(numbers, index + 1, next_player))\n    }\n}\n\nspec fn count_lines(s: Seq<char>) -> int {\n    count_newlines(s, 0, 0)\n}\n\nspec fn count_newlines(s: Seq<char>, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s[index] == '\\n' {\n        count_newlines(s, index + 1, count + 1)\n    } else {\n        count_newlines(s, index + 1, count)\n    }\n}\n\nspec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    let computed_players = compute_players_sequence(numbers);\n    output_lines.len() == computed_players.len() &&\n    forall|i: int| 0 <= i < output_lines.len() ==>\n        (computed_players[i] == 1 ==> output_lines[i] == seq!['1']) &&\n        (computed_players[i] == 2 ==> output_lines[i] == seq!['2'])\n}\n\nspec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 ==> {\n        let numbers = split_by_space_spec(lines[1]);\n        let output_lines = split_by_newline_spec(output);\n        output_lines.len() == numbers.len() &&\n        computes_correct_players(numbers, output_lines)\n    }\n}\n\nspec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {\n    let output_lines = split_by_newline_spec(output);\n    output_lines.len() == processed &&\n    {\n        let partial_computed = compute_players_sequence(numbers.subrange(0, processed));\n        output_lines.len() == partial_computed.len() &&\n        forall|i: int| 0 <= i < output_lines.len() ==>\n            (partial_computed[i] == 1 ==> output_lines[i] == seq!['1']) &&\n            (partial_computed[i] == 2 ==> output_lines[i] == seq!['2'])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(s);\n    lines.len() >= 2 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let n = parse_int_spec(lines[0]);\n        let numbers = split_by_space_spec(lines[1]);\n        numbers.len() == n &&\n        forall|i: int| 0 <= i < numbers.len() ==> is_valid_integer(numbers[i])\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![], seq![]]\n}\n\nspec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    computes_correct_players(numbers, output_lines)\n}\n\nspec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {\n    numbers.len() == outputs.len() &&\n    {\n        let players = compute_players_sequence(numbers);\n        players.len() == outputs.len() &&\n        forall|i: int| 0 <= i < outputs.len() ==> \n            (players[i] == 1 ==> outputs[i] == seq!['1']) &&\n            (players[i] == 2 ==> outputs[i] == seq!['2'])\n    }\n}\n\nspec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        seq![]\n    } else {\n        compute_players_helper(numbers, 0, 2)\n    }\n}\n\nspec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>\n    decreases numbers.len() - index\n{\n    if index >= numbers.len() {\n        seq![]\n    } else {\n        let num = parse_int_spec(numbers[index]);\n        let next_player = if num % 2 == 0 { 3 - current_player } else { current_player };\n        seq![next_player].add(compute_players_helper(numbers, index + 1, next_player))\n    }\n}\n\nspec fn count_lines(s: Seq<char>) -> int {\n    count_newlines(s, 0, 0)\n}\n\nspec fn count_newlines(s: Seq<char>, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s[index] == '\\n' {\n        count_newlines(s, index + 1, count + 1)\n    } else {\n        count_newlines(s, index + 1, count)\n    }\n}\n\nspec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    let computed_players = compute_players_sequence(numbers);\n    output_lines.len() == computed_players.len() &&\n    forall|i: int| 0 <= i < output_lines.len() ==>\n        (computed_players[i] == 1 ==> output_lines[i] == seq!['1']) &&\n        (computed_players[i] == 2 ==> output_lines[i] == seq!['2'])\n}\n\nspec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 ==> {\n        let numbers = split_by_space_spec(lines[1]);\n        let output_lines = split_by_newline_spec(output);\n        output_lines.len() == numbers.len() &&\n        computes_correct_players(numbers, output_lines)\n    }\n}\n\nspec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {\n    let output_lines = split_by_newline_spec(output);\n    output_lines.len() == processed &&\n    {\n        let partial_computed = compute_players_sequence(numbers.subrange(0, processed));\n        output_lines.len() == partial_computed.len() &&\n        forall|i: int| 0 <= i < output_lines.len() ==>\n            (partial_computed[i] == 1 ==> output_lines[i] == seq!['1']) &&\n            (partial_computed[i] == 2 ==> output_lines[i] == seq!['2'])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1044.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 983, "minimize_time_ms": 92196, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 137, "minimized_LOC": 137, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 33, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n\nspec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n\nspec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {\n\nspec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>\n    decreases numbers.len()\n{\n\nspec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>\n    decreases numbers.len() - index\n{\n\nspec fn count_lines(s: Seq<char>) -> int {\n\nspec fn count_newlines(s: Seq<char>, index: int, count: int) -> int\n    decreases s.len() - index\n{\n\nspec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n\nspec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {\n\nspec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {\n\n    decreases numbers.len()\n\n    decreases numbers.len() - index\n\n    decreases s.len() - index"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(s);\n    lines.len() >= 2 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let n = parse_int_spec(lines[0]);\n        let numbers = split_by_space_spec(lines[1]);\n        numbers.len() == n &&\n        forall|i: int| 0 <= i < numbers.len() ==> is_valid_integer(numbers[i])\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![], seq![]]\n}\n\nspec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    computes_correct_players(numbers, output_lines)\n}\n\nspec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {\n    numbers.len() == outputs.len() &&\n    {\n        let players = compute_players_sequence(numbers);\n        players.len() == outputs.len() &&\n        forall|i: int| 0 <= i < outputs.len() ==> \n            (players[i] == 1 ==> outputs[i] == seq!['1']) &&\n            (players[i] == 2 ==> outputs[i] == seq!['2'])\n    }\n}\n\nspec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        seq![]\n    } else {\n        compute_players_helper(numbers, 0, 2)\n    }\n}\n\nspec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>\n    decreases numbers.len() - index\n{\n    if index >= numbers.len() {\n        seq![]\n    } else {\n        let num = parse_int_spec(numbers[index]);\n        let next_player = if num % 2 == 0 { 3 - current_player } else { current_player };\n        seq![next_player].add(compute_players_helper(numbers, index + 1, next_player))\n    }\n}\n\nspec fn count_lines(s: Seq<char>) -> int {\n    count_newlines(s, 0, 0)\n}\n\nspec fn count_newlines(s: Seq<char>, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s[index] == '\\n' {\n        count_newlines(s, index + 1, count + 1)\n    } else {\n        count_newlines(s, index + 1, count)\n    }\n}\n\nspec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    let computed_players = compute_players_sequence(numbers);\n    output_lines.len() == computed_players.len() &&\n    forall|i: int| 0 <= i < output_lines.len() ==>\n        (computed_players[i] == 1 ==> output_lines[i] == seq!['1']) &&\n        (computed_players[i] == 2 ==> output_lines[i] == seq!['2'])\n}\n\nspec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 ==> {\n        let numbers = split_by_space_spec(lines[1]);\n        let output_lines = split_by_newline_spec(output);\n        output_lines.len() == numbers.len() &&\n        computes_correct_players(numbers, output_lines)\n    }\n}\n\nspec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {\n    let output_lines = split_by_newline_spec(output);\n    output_lines.len() == processed &&\n    {\n        let partial_computed = compute_players_sequence(numbers.subrange(0, processed));\n        output_lines.len() == partial_computed.len() &&\n        forall|i: int| 0 <= i < output_lines.len() ==>\n            (partial_computed[i] == 1 ==> output_lines[i] == seq!['1']) &&\n            (partial_computed[i] == 2 ==> output_lines[i] == seq!['2'])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1046_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if s[0] == x { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), x)\n    }\n}\n\nspec fn count_pairs(s: Seq<int>) -> int\n{\n    let positive_sessions = filter_positive(s);\n    count_pairs_helper(positive_sessions)\n}\n\nspec fn filter_positive(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::empty()\n    } else if s[0] > 0 {\n        seq![s[0]].add(filter_positive(s.subrange(1, s.len() as int)))\n    } else {\n        filter_positive(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn remove_all_occurrences(s: Seq<int>, x: int) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::empty()\n    } else if s[0] == x {\n        remove_all_occurrences(s.subrange(1, s.len() as int), x)\n    } else {\n        seq![s[0]].add(remove_all_occurrences(s.subrange(1, s.len() as int), x))\n    }\n}\n\nspec fn count_pairs_helper(s: Seq<int>) -> int\n    decreases s.len()\n    when s.len() > 1 ==> remove_all_occurrences(s, s[0]).len() < s.len()\n{\n    if s.len() <= 1 {\n        0\n    } else {\n        let count = count_occurrences(s, s[0]);\n        let remaining = remove_all_occurrences(s, s[0]);\n        (if count == 2 { 1int } else { 0int }) + count_pairs_helper(remaining)\n    }\n}\n\nspec fn exists_index(s: Seq<int>, x: int) -> bool\n{\n    exists|i: int| 0 <= i < s.len() && s[i] == x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, sessions: Vec<i8>) -> (result: i8)\n    requires \n        n >= 1,\n        sessions.len() == n as nat,\n        forall|i: int| 0 <= i < sessions.len() ==> sessions[i] as int >= 0,\n    ensures \n        result == -1 || result >= 0,\n        result == -1 ==> (exists|id: int| id > 0 && #[trigger] count_occurrences(sessions@.map_values(|x: i8| x as int), id) > 2),\n        result >= 0 ==> forall|id: int| id > 0 ==> count_occurrences(sessions@.map_values(|x: i8| x as int), id) <= 2,\n        result >= 0 ==> result as int == count_pairs(sessions@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if s[0] == x { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), x)\n    }\n}\n\nspec fn count_pairs(s: Seq<int>) -> int\n{\n    let positive_sessions = filter_positive(s);\n    count_pairs_helper(positive_sessions)\n}\n\nspec fn filter_positive(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::empty()\n    } else if s[0] > 0 {\n        seq![s[0]].add(filter_positive(s.subrange(1, s.len() as int)))\n    } else {\n        filter_positive(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn remove_all_occurrences(s: Seq<int>, x: int) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::empty()\n    } else if s[0] == x {\n        remove_all_occurrences(s.subrange(1, s.len() as int), x)\n    } else {\n        seq![s[0]].add(remove_all_occurrences(s.subrange(1, s.len() as int), x))\n    }\n}\n\nspec fn count_pairs_helper(s: Seq<int>) -> int\n    decreases s.len()\n    when s.len() > 1 ==> remove_all_occurrences(s, s[0]).len() < s.len()\n{\n    if s.len() <= 1 {\n        0\n    } else {\n        let count = count_occurrences(s, s[0]);\n        let remaining = remove_all_occurrences(s, s[0]);\n        (if count == 2 { 1int } else { 0int }) + count_pairs_helper(remaining)\n    }\n}\n\nspec fn exists_index(s: Seq<int>, x: int) -> bool\n{\n    exists|i: int| 0 <= i < s.len() && s[i] == x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, sessions: Vec<i8>) -> (result: i8)\n    requires \n        n >= 1,\n        sessions.len() == n as nat,\n        forall|i: int| 0 <= i < sessions.len() ==> sessions[i] as int >= 0,\n    ensures \n        result == -1 || result >= 0,\n        result == -1 ==> (exists|id: int| id > 0 && #[trigger] count_occurrences(sessions@.map_values(|x: i8| x as int), id) > 2),\n        result >= 0 ==> forall|id: int| id > 0 ==> count_occurrences(sessions@.map_values(|x: i8| x as int), id) <= 2,\n        result >= 0 ==> result as int == count_pairs(sessions@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1046.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 541, "verus_errors": [{"error_type": "Other", "error_text": "triggers cannot contain let/forall/exists/lambda/choose ()", "message": "VerusErrorType.Other: triggers cannot contain let/forall/exists/lambda/choose ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpn2g4ic0c", "lines": [76, 76], "label": null, "text": [{"text": "        result == -1 ==> (exists|id: int| id > 0 && #[trigger] count_occurrences(sessions@.map_values(|x: i8| x as int), id) > 2),", "highlight_start": 103, "highlight_end": 119}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 92, "minimized_LOC": 92, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n\nspec fn count_pairs(s: Seq<int>) -> int\n{\n\nspec fn filter_positive(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n\nspec fn remove_all_occurrences(s: Seq<int>, x: int) -> Seq<int>\n    decreases s.len()\n{\n\nspec fn count_pairs_helper(s: Seq<int>) -> int\n    decreases s.len()\n    when s.len() > 1 ==> remove_all_occurrences(s, s[0]).len() < s.len()\n{\n\nspec fn exists_index(s: Seq<int>, x: int) -> bool\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_1049_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn input_well_formed(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    {\n        let first_line_parts = split_string(lines[0], ' ');\n        first_line_parts.len() == 2 &&\n        is_valid_int(first_line_parts[0]) &&\n        is_valid_int(first_line_parts[1]) &&\n        {\n            let n = string_to_int(first_line_parts[0]);\n            let d = string_to_int(first_line_parts[1]);\n            n >= 0 && d >= 0 &&\n            lines.len() >= d + 1 &&\n            forall|i: int| 1 <= i <= d ==> i < lines.len() && is_valid_binary_string(lines[i], n)\n        }\n    }\n}\n\nspec fn compute_max_consecutive_wins(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line_parts = split_string(lines[0], ' ');\n    let n = string_to_int(first_line_parts[0]);\n    let d = string_to_int(first_line_parts[1]);\n    max_consecutive_wins_up_to(lines, n, d)\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {\n    s.len() == expected_length && forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\n/* Helper function stubs - these would need proper implementations */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { Seq::empty() }\nspec fn string_to_int(s: Seq<char>) -> int { 0 }\nspec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int { 0 }\nspec fn int_to_string(n: int) -> Seq<char> { Seq::empty() }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        input_well_formed(input),\n    ensures \n        result == int_to_string(compute_max_consecutive_wins(input)).add(seq!['\\n']),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn input_well_formed(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    {\n        let first_line_parts = split_string(lines[0], ' ');\n        first_line_parts.len() == 2 &&\n        is_valid_int(first_line_parts[0]) &&\n        is_valid_int(first_line_parts[1]) &&\n        {\n            let n = string_to_int(first_line_parts[0]);\n            let d = string_to_int(first_line_parts[1]);\n            n >= 0 && d >= 0 &&\n            lines.len() >= d + 1 &&\n            forall|i: int| 1 <= i <= d ==> i < lines.len() && is_valid_binary_string(lines[i], n)\n        }\n    }\n}\n\nspec fn compute_max_consecutive_wins(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line_parts = split_string(lines[0], ' ');\n    let n = string_to_int(first_line_parts[0]);\n    let d = string_to_int(first_line_parts[1]);\n    max_consecutive_wins_up_to(lines, n, d)\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {\n    s.len() == expected_length && forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\n/* Helper function stubs - these would need proper implementations */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { Seq::empty() }\nspec fn string_to_int(s: Seq<char>) -> int { 0 }\nspec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int { 0 }\nspec fn int_to_string(n: int) -> Seq<char> { Seq::empty() }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        input_well_formed(input),\n    ensures \n        result == int_to_string(compute_max_consecutive_wins(input)).add(seq!['\\n']),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1049.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 729, "minimize_time_ms": 122619, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn input_well_formed(input: Seq<char>) -> bool {\n\nspec fn compute_max_consecutive_wins(input: Seq<char>) -> int {\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n\nspec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn input_well_formed(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    {\n        let first_line_parts = split_string(lines[0], ' ');\n        first_line_parts.len() == 2 &&\n        is_valid_int(first_line_parts[0]) &&\n        is_valid_int(first_line_parts[1]) &&\n        {\n            let n = string_to_int(first_line_parts[0]);\n            let d = string_to_int(first_line_parts[1]);\n            n >= 0 && d >= 0 &&\n            lines.len() >= d + 1 &&\n            forall|i: int| 1 <= i <= d ==> i < lines.len() && is_valid_binary_string(lines[i], n)\n        }\n    }\n}\n\nspec fn compute_max_consecutive_wins(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line_parts = split_string(lines[0], ' ');\n    let n = string_to_int(first_line_parts[0]);\n    let d = string_to_int(first_line_parts[1]);\n    max_consecutive_wins_up_to(lines, n, d)\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {\n    s.len() == expected_length && forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\n/* Helper function stubs - these would need proper implementations */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { Seq::empty() }\nspec fn string_to_int(s: Seq<char>) -> int { 0 }\nspec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int { 0 }\nspec fn int_to_string(n: int) -> Seq<char> { Seq::empty() }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        input_well_formed(input),\n    ensures \n        result == int_to_string(compute_max_consecutive_wins(input)).add(seq!['\\n']),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1063_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    if lines.len() < 1 { \n        false \n    } else {\n        let n = parse_int(lines[0]);\n        n >= 0 && lines.len() >= n + 1 &&\n        forall|i: int| #![trigger lines[i]] 1 <= i <= n && i < lines.len() ==> {\n            let line = lines[i];\n            line.len() >= 1 && line.len() <= 8 &&\n            forall|j: int| 0 <= j < line.len() ==> \n                ((#[trigger] line[j]) >= '0' && line[j] <= '9') || line[j] == '?'\n        }\n    }\n}\n\nspec fn has_valid_solution(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    if n <= 0 { \n        true \n    } else {\n        let input_strings = lines.subrange(1, n + 1);\n        exists|solution: Seq<Seq<char>>| is_valid_sequence_solution(input_strings, solution)\n    }\n}\n\nspec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {\n    input.len() == solution.len() &&\n    forall|i: int| #![trigger input[i], solution[i]] 0 <= i < input.len() ==> {\n        input[i].len() == solution[i].len() &&\n        forall|j: int| 0 <= j < input[i].len() ==> {\n            ((#[trigger] input[i][j]) != '?' ==> input[i][j] == solution[i][j]) &&\n            (input[i][j] == '?' ==> solution[i][j] >= '0' && solution[i][j] <= '9')\n        }\n    } &&\n    forall|i: int| #![trigger solution[i]] 0 <= i < solution.len() ==> is_valid_positive_integer(solution[i]) &&\n    is_strictly_increasing_sequence(solution)\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() >= 1 && \n    forall|i: int| 0 <= i < s.len() ==> ((#[trigger] s[i]) >= '0' && s[i] <= '9') &&\n    (s.len() == 1 || s[0] != '0')\n}\n\nspec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {\n    forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() - 1 ==> \n        is_lexicographically_smaller(nums[i], nums[(i + 1) as int])\n}\n\nspec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {\n    a.len() < b.len() || (a.len() == b.len() && lexicographic_compare(a, b))\n}\n\nspec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool \n    decreases a.len()\n{\n    if a.len() == 0 || b.len() == 0 {\n        a.len() < b.len()\n    } else if a[0] != b[0] {\n        a[0] < b[0]\n    } else {\n        lexicographic_compare(a.drop_first(), b.drop_first())\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        is_well_formed_input(stdin_input),\n    ensures \n        result.len() > 0,\n        result == \"NO\\n\"@ || (result.len() > 4 && result.subrange(0, 4) == \"YES\\n\"@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    if lines.len() < 1 { \n        false \n    } else {\n        let n = parse_int(lines[0]);\n        n >= 0 && lines.len() >= n + 1 &&\n        forall|i: int| #![trigger lines[i]] 1 <= i <= n && i < lines.len() ==> {\n            let line = lines[i];\n            line.len() >= 1 && line.len() <= 8 &&\n            forall|j: int| 0 <= j < line.len() ==> \n                ((#[trigger] line[j]) >= '0' && line[j] <= '9') || line[j] == '?'\n        }\n    }\n}\n\nspec fn has_valid_solution(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    if n <= 0 { \n        true \n    } else {\n        let input_strings = lines.subrange(1, n + 1);\n        exists|solution: Seq<Seq<char>>| is_valid_sequence_solution(input_strings, solution)\n    }\n}\n\nspec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {\n    input.len() == solution.len() &&\n    forall|i: int| #![trigger input[i], solution[i]] 0 <= i < input.len() ==> {\n        input[i].len() == solution[i].len() &&\n        forall|j: int| 0 <= j < input[i].len() ==> {\n            ((#[trigger] input[i][j]) != '?' ==> input[i][j] == solution[i][j]) &&\n            (input[i][j] == '?' ==> solution[i][j] >= '0' && solution[i][j] <= '9')\n        }\n    } &&\n    forall|i: int| #![trigger solution[i]] 0 <= i < solution.len() ==> is_valid_positive_integer(solution[i]) &&\n    is_strictly_increasing_sequence(solution)\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() >= 1 && \n    forall|i: int| 0 <= i < s.len() ==> ((#[trigger] s[i]) >= '0' && s[i] <= '9') &&\n    (s.len() == 1 || s[0] != '0')\n}\n\nspec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {\n    forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() - 1 ==> \n        is_lexicographically_smaller(nums[i], nums[(i + 1) as int])\n}\n\nspec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {\n    a.len() < b.len() || (a.len() == b.len() && lexicographic_compare(a, b))\n}\n\nspec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool \n    decreases a.len()\n{\n    if a.len() == 0 || b.len() == 0 {\n        a.len() < b.len()\n    } else if a[0] != b[0] {\n        a[0] < b[0]\n    } else {\n        lexicographic_compare(a.drop_first(), b.drop_first())\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        is_well_formed_input(stdin_input),\n    ensures \n        result.len() > 0,\n        result == \"NO\\n\"@ || (result.len() > 4 && result.subrange(0, 4) == \"YES\\n\"@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1063.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 942, "minimize_time_ms": 183664, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 106, "minimized_LOC": 106, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int(s: Seq<char>) -> int {\n\nspec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {\n\nspec fn has_valid_solution(stdin_input: Seq<char>) -> bool {\n\nspec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n\nspec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {\n\nspec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {\n\nspec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool \n    decreases a.len()\n{\n\n    decreases a.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    if lines.len() < 1 { \n        false \n    } else {\n        let n = parse_int(lines[0]);\n        n >= 0 && lines.len() >= n + 1 &&\n        forall|i: int| #![trigger lines[i]] 1 <= i <= n && i < lines.len() ==> {\n            let line = lines[i];\n            line.len() >= 1 && line.len() <= 8 &&\n            forall|j: int| 0 <= j < line.len() ==> \n                ((#[trigger] line[j]) >= '0' && line[j] <= '9') || line[j] == '?'\n        }\n    }\n}\n\nspec fn has_valid_solution(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    if n <= 0 { \n        true \n    } else {\n        let input_strings = lines.subrange(1, n + 1);\n        exists|solution: Seq<Seq<char>>| is_valid_sequence_solution(input_strings, solution)\n    }\n}\n\nspec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {\n    input.len() == solution.len() &&\n    forall|i: int| #![trigger input[i], solution[i]] 0 <= i < input.len() ==> {\n        input[i].len() == solution[i].len() &&\n        forall|j: int| 0 <= j < input[i].len() ==> {\n            ((#[trigger] input[i][j]) != '?' ==> input[i][j] == solution[i][j]) &&\n            (input[i][j] == '?' ==> solution[i][j] >= '0' && solution[i][j] <= '9')\n        }\n    } &&\n    forall|i: int| #![trigger solution[i]] 0 <= i < solution.len() ==> is_valid_positive_integer(solution[i]) &&\n    is_strictly_increasing_sequence(solution)\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() >= 1 && \n    forall|i: int| 0 <= i < s.len() ==> ((#[trigger] s[i]) >= '0' && s[i] <= '9') &&\n    (s.len() == 1 || s[0] != '0')\n}\n\nspec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {\n    forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() - 1 ==> \n        is_lexicographically_smaller(nums[i], nums[(i + 1) as int])\n}\n\nspec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {\n    a.len() < b.len() || (a.len() == b.len() && lexicographic_compare(a, b))\n}\n\nspec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool \n    decreases a.len()\n{\n    if a.len() == 0 || b.len() == 0 {\n        a.len() < b.len()\n    } else if a[0] != b[0] {\n        a[0] < b[0]\n    } else {\n        lexicographic_compare(a.drop_first(), b.drop_first())\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        is_well_formed_input(stdin_input),\n    ensures \n        result.len() > 0,\n        result == \"NO\\n\"@ || (result.len() > 4 && result.subrange(0, 4) == \"YES\\n\"@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1084_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() < 2 {\n        false\n    } else {\n        let first_line = lines[0];\n        let grid_lines = lines.subrange(1, lines.len() as int);\n        let dimensions = parse_dimensions(first_line);\n        let n = dimensions.0;\n        let m = dimensions.1;\n        if n <= 0 || m <= 0 || grid_lines.len() != n {\n            false\n        } else if !valid_grid(grid_lines, m) {\n            false\n        } else {\n            true /* simplified - column pattern constraint implementation omitted for spec purposes */\n        }\n    }\n}\n\nspec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {\n    (forall|i: int| 0 <= i < grid_lines.len() ==> #[trigger] grid_lines[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < grid_lines.len() && 0 <= j < grid_lines[i].len() ==> \n            #[trigger] grid_lines[i][j] == '.' || grid_lines[i][j] == '#')\n}\n\nspec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {\n    Set::new(|j: int| 0 <= j < m && row[j] == '#')\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(input, 0, Seq::empty())\n}\n\nspec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n    if start >= input.len() {\n        acc\n    } else {\n        acc.push(Seq::empty())\n    }\n}\n\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) {\n    let parts = split_on_space(line);\n    if parts.len() >= 2 {\n        (string_to_int(parts[0]), string_to_int(parts[1]))\n    } else {\n        (0, 0)\n    }\n}\n\nspec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        result@ == \"Yes\\n\"@ || result@ == \"No\\n\"@,\n        result@.len() > 0,\n        (result@ == \"Yes\\n\"@) <==> can_be_constructed_by_operations(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"No\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() < 2 {\n        false\n    } else {\n        let first_line = lines[0];\n        let grid_lines = lines.subrange(1, lines.len() as int);\n        let dimensions = parse_dimensions(first_line);\n        let n = dimensions.0;\n        let m = dimensions.1;\n        if n <= 0 || m <= 0 || grid_lines.len() != n {\n            false\n        } else if !valid_grid(grid_lines, m) {\n            false\n        } else {\n            true /* simplified - column pattern constraint implementation omitted for spec purposes */\n        }\n    }\n}\n\nspec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {\n    (forall|i: int| 0 <= i < grid_lines.len() ==> #[trigger] grid_lines[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < grid_lines.len() && 0 <= j < grid_lines[i].len() ==> \n            #[trigger] grid_lines[i][j] == '.' || grid_lines[i][j] == '#')\n}\n\nspec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {\n    Set::new(|j: int| 0 <= j < m && row[j] == '#')\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(input, 0, Seq::empty())\n}\n\nspec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n    if start >= input.len() {\n        acc\n    } else {\n        acc.push(Seq::empty())\n    }\n}\n\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) {\n    let parts = split_on_space(line);\n    if parts.len() >= 2 {\n        (string_to_int(parts[0]), string_to_int(parts[1]))\n    } else {\n        (0, 0)\n    }\n}\n\nspec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        result@ == \"Yes\\n\"@ || result@ == \"No\\n\"@,\n        result@.len() > 0,\n        (result@ == \"Yes\\n\"@) <==> can_be_constructed_by_operations(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"No\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1084.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 812, "minimize_time_ms": 123893, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 94, "minimized_LOC": 94, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {\n\nspec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {\n\nspec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) {\n\nspec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() < 2 {\n        false\n    } else {\n        let first_line = lines[0];\n        let grid_lines = lines.subrange(1, lines.len() as int);\n        let dimensions = parse_dimensions(first_line);\n        let n = dimensions.0;\n        let m = dimensions.1;\n        if n <= 0 || m <= 0 || grid_lines.len() != n {\n            false\n        } else if !valid_grid(grid_lines, m) {\n            false\n        } else {\n            true /* simplified - column pattern constraint implementation omitted for spec purposes */\n        }\n    }\n}\n\nspec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {\n    (forall|i: int| 0 <= i < grid_lines.len() ==> #[trigger] grid_lines[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < grid_lines.len() && 0 <= j < grid_lines[i].len() ==> \n            #[trigger] grid_lines[i][j] == '.' || grid_lines[i][j] == '#')\n}\n\nspec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {\n    Set::new(|j: int| 0 <= j < m && row[j] == '#')\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(input, 0, Seq::empty())\n}\n\nspec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n    if start >= input.len() {\n        acc\n    } else {\n        acc.push(Seq::empty())\n    }\n}\n\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) {\n    let parts = split_on_space(line);\n    if parts.len() >= 2 {\n        (string_to_int(parts[0]), string_to_int(parts[1]))\n    } else {\n        (0, 0)\n    }\n}\n\nspec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        result@ == \"Yes\\n\"@ || result@ == \"No\\n\"@,\n        result@.len() > 0,\n        (result@ == \"Yes\\n\"@) <==> can_be_constructed_by_operations(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"No\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n              fn main() {\n    }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1125_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_lines_func(s);\n    lines.len() >= 2 && \n    parse_int_func(lines[0]) >= 2 &&\n    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&\n    forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] >= 1\n}\n\nspec fn is_valid_output(s: Seq<char>) -> bool {\n    s == seq!['-', '1'] || (parse_int_func(s) >= 0)\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 2 ==>\n    {\n        let n = parse_int_func(lines[0]);\n        let a = parse_int_array_func(lines[1]);\n    \n        if n == 2 {\n            (output == seq!['-', '1'] <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&\n            (output != seq!['-', '1'] ==> parse_int_func(output) == (a[0] - a[1]) / 2)\n        } else {\n            let xor_rest = xor_range(a, 2, n);\n            let and_val = a[0] + a[1] - xor_rest;\n            let target_and = and_val / 2;\n    \n            if and_val % 2 != 0 || a[0] < target_and || and_op(target_and, xor_rest) != 0 {\n                output == seq!['-', '1']\n            } else {\n                let a0 = construct_a0(target_and, xor_rest, a[0]);\n                if a0 == 0 {\n                    output == seq!['-', '1']\n                } else {\n                    output != seq!['-', '1'] && parse_int_func(output) == a[0] - a0\n                }\n            }\n        }\n    }\n}\n\nspec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool\n    recommends\n        original_piles.len() >= 2,\n        0 <= stones_moved < original_piles[0],\n        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0\n{\n    let new_piles = original_piles.update(0, original_piles[0] - stones_moved).update(1, original_piles[1] + stones_moved);\n    nim_sum(new_piles) == 0\n}\n\nspec fn nim_sum(piles: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0\n    decreases piles.len()\n{\n    if piles.len() == 0 {\n        0\n    } else {\n        xor_op(piles[0], nim_sum(piles.subrange(1, piles.len() as int)))\n    }\n}\n\nspec fn xor_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise XOR operation */\n    } else {\n        0\n    }\n}\n\nspec fn and_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise AND operation */\n    } else {\n        0\n    }\n}\n\nspec fn xor_range(a: Seq<int>, start: int, end: int) -> int\n    recommends\n        0 <= start <= end <= a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else {\n        xor_op(a[start], xor_range(a, start + 1, end))\n    }\n}\n\nspec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int\n    recommends initial_and >= 0 && num >= 0\n{\n    let max_power = find_max_power(num);\n    construct_a0_helper(initial_and, num, max_pile, max_power)\n}\n\nspec fn find_max_power(num: int) -> int\n    recommends num >= 0\n{\n    if num == 0 {\n        1\n    } else {\n        find_max_power_helper(1, num)\n    }\n}\n\nspec fn find_max_power_helper(current_power: int, num: int) -> int\n    recommends current_power >= 1 && num >= 0\n{\n    if current_power > num {\n        if current_power / 2 >= 1 { current_power / 2 } else { 1 }\n    } else {\n        1  /* simplified to avoid recursion issues */\n    }\n}\n\nspec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int\n    recommends a0 >= 0 && num >= 0 && power >= 1\n    decreases power\n{\n    if power == 1 {\n        if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 }\n    } else {\n        let new_a0 = if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 };\n        if power / 2 >= 1 { construct_a0_helper(new_a0, num, max_pile, power / 2) } else { new_a0 }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    seq!['0']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures\n        result@.len() > 0,\n        is_valid_output(result@),\n        result@ == seq!['-', '1'] || (parse_int_func(result@) >= 0),\n        correct_solution(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_lines_func(s);\n    lines.len() >= 2 && \n    parse_int_func(lines[0]) >= 2 &&\n    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&\n    forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] >= 1\n}\n\nspec fn is_valid_output(s: Seq<char>) -> bool {\n    s == seq!['-', '1'] || (parse_int_func(s) >= 0)\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 2 ==>\n    {\n        let n = parse_int_func(lines[0]);\n        let a = parse_int_array_func(lines[1]);\n    \n        if n == 2 {\n            (output == seq!['-', '1'] <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&\n            (output != seq!['-', '1'] ==> parse_int_func(output) == (a[0] - a[1]) / 2)\n        } else {\n            let xor_rest = xor_range(a, 2, n);\n            let and_val = a[0] + a[1] - xor_rest;\n            let target_and = and_val / 2;\n    \n            if and_val % 2 != 0 || a[0] < target_and || and_op(target_and, xor_rest) != 0 {\n                output == seq!['-', '1']\n            } else {\n                let a0 = construct_a0(target_and, xor_rest, a[0]);\n                if a0 == 0 {\n                    output == seq!['-', '1']\n                } else {\n                    output != seq!['-', '1'] && parse_int_func(output) == a[0] - a0\n                }\n            }\n        }\n    }\n}\n\nspec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool\n    recommends\n        original_piles.len() >= 2,\n        0 <= stones_moved < original_piles[0],\n        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0\n{\n    let new_piles = original_piles.update(0, original_piles[0] - stones_moved).update(1, original_piles[1] + stones_moved);\n    nim_sum(new_piles) == 0\n}\n\nspec fn nim_sum(piles: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0\n    decreases piles.len()\n{\n    if piles.len() == 0 {\n        0\n    } else {\n        xor_op(piles[0], nim_sum(piles.subrange(1, piles.len() as int)))\n    }\n}\n\nspec fn xor_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise XOR operation */\n    } else {\n        0\n    }\n}\n\nspec fn and_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise AND operation */\n    } else {\n        0\n    }\n}\n\nspec fn xor_range(a: Seq<int>, start: int, end: int) -> int\n    recommends\n        0 <= start <= end <= a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else {\n        xor_op(a[start], xor_range(a, start + 1, end))\n    }\n}\n\nspec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int\n    recommends initial_and >= 0 && num >= 0\n{\n    let max_power = find_max_power(num);\n    construct_a0_helper(initial_and, num, max_pile, max_power)\n}\n\nspec fn find_max_power(num: int) -> int\n    recommends num >= 0\n{\n    if num == 0 {\n        1\n    } else {\n        find_max_power_helper(1, num)\n    }\n}\n\nspec fn find_max_power_helper(current_power: int, num: int) -> int\n    recommends current_power >= 1 && num >= 0\n{\n    if current_power > num {\n        if current_power / 2 >= 1 { current_power / 2 } else { 1 }\n    } else {\n        1  /* simplified to avoid recursion issues */\n    }\n}\n\nspec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int\n    recommends a0 >= 0 && num >= 0 && power >= 1\n    decreases power\n{\n    if power == 1 {\n        if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 }\n    } else {\n        let new_a0 = if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 };\n        if power / 2 >= 1 { construct_a0_helper(new_a0, num, max_pile, power / 2) } else { new_a0 }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    seq!['0']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures\n        result@.len() > 0,\n        is_valid_output(result@),\n        result@ == seq!['-', '1'] || (parse_int_func(result@) >= 0),\n        correct_solution(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1125.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 969, "minimize_time_ms": 92094, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 181, "minimized_LOC": 181, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 24, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn is_valid_output(s: Seq<char>) -> bool {\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n\nspec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool\n    recommends\n        original_piles.len() >= 2,\n        0 <= stones_moved < original_piles[0],\n        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0\n{\n\nspec fn nim_sum(piles: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0\n    decreases piles.len()\n{\n\nspec fn xor_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n\nspec fn and_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n\nspec fn xor_range(a: Seq<int>, start: int, end: int) -> int\n    recommends\n        0 <= start <= end <= a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n    decreases end - start\n{\n\nspec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int\n    recommends initial_and >= 0 && num >= 0\n{\n\nspec fn find_max_power(num: int) -> int\n    recommends num >= 0\n{\n\nspec fn find_max_power_helper(current_power: int, num: int) -> int\n    recommends current_power >= 1 && num >= 0\n{\n\nspec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int\n    recommends a0 >= 0 && num >= 0 && power >= 1\n    decreases power\n{\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n\n    decreases piles.len()\n\n    decreases end - start\n\n    decreases power\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_lines_func(s);\n    lines.len() >= 2 && \n    parse_int_func(lines[0]) >= 2 &&\n    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&\n    forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] >= 1\n}\n\nspec fn is_valid_output(s: Seq<char>) -> bool {\n    s == seq!['-', '1'] || (parse_int_func(s) >= 0)\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 2 ==>\n    {\n        let n = parse_int_func(lines[0]);\n        let a = parse_int_array_func(lines[1]);\n    \n        if n == 2 {\n            (output == seq!['-', '1'] <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&\n            (output != seq!['-', '1'] ==> parse_int_func(output) == (a[0] - a[1]) / 2)\n        } else {\n            let xor_rest = xor_range(a, 2, n);\n            let and_val = a[0] + a[1] - xor_rest;\n            let target_and = and_val / 2;\n    \n            if and_val % 2 != 0 || a[0] < target_and || and_op(target_and, xor_rest) != 0 {\n                output == seq!['-', '1']\n            } else {\n                let a0 = construct_a0(target_and, xor_rest, a[0]);\n                if a0 == 0 {\n                    output == seq!['-', '1']\n                } else {\n                    output != seq!['-', '1'] && parse_int_func(output) == a[0] - a0\n                }\n            }\n        }\n    }\n}\n\nspec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool\n    recommends\n        original_piles.len() >= 2,\n        0 <= stones_moved < original_piles[0],\n        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0\n{\n    let new_piles = original_piles.update(0, original_piles[0] - stones_moved).update(1, original_piles[1] + stones_moved);\n    nim_sum(new_piles) == 0\n}\n\nspec fn nim_sum(piles: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0\n    decreases piles.len()\n{\n    if piles.len() == 0 {\n        0\n    } else {\n        xor_op(piles[0], nim_sum(piles.subrange(1, piles.len() as int)))\n    }\n}\n\nspec fn xor_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise XOR operation */\n    } else {\n        0\n    }\n}\n\nspec fn and_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise AND operation */\n    } else {\n        0\n    }\n}\n\nspec fn xor_range(a: Seq<int>, start: int, end: int) -> int\n    recommends\n        0 <= start <= end <= a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else {\n        xor_op(a[start], xor_range(a, start + 1, end))\n    }\n}\n\nspec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int\n    recommends initial_and >= 0 && num >= 0\n{\n    let max_power = find_max_power(num);\n    construct_a0_helper(initial_and, num, max_pile, max_power)\n}\n\nspec fn find_max_power(num: int) -> int\n    recommends num >= 0\n{\n    if num == 0 {\n        1\n    } else {\n        find_max_power_helper(1, num)\n    }\n}\n\nspec fn find_max_power_helper(current_power: int, num: int) -> int\n    recommends current_power >= 1 && num >= 0\n{\n    if current_power > num {\n        if current_power / 2 >= 1 { current_power / 2 } else { 1 }\n    } else {\n        1  /* simplified to avoid recursion issues */\n    }\n}\n\nspec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int\n    recommends a0 >= 0 && num >= 0 && power >= 1\n    decreases power\n{\n    if power == 1 {\n        if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 }\n    } else {\n        let new_a0 = if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 };\n        if power / 2 >= 1 { construct_a0_helper(new_a0, num, max_pile, power / 2) } else { new_a0 }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    seq!['0']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures\n        result@.len() > 0,\n        is_valid_output(result@),\n        result@ == seq!['-', '1'] || (parse_int_func(result@) >= 0),\n        correct_solution(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_114_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n' &&\n    exists|lines: Seq<Seq<char>>| {\n        &&& lines == split_lines(input)\n        &&& lines.len() >= 3\n        &&& valid_dimension_line(lines[0])\n        &&& {\n            let parsed = parse_dimensions(lines[0]);\n            let (n, m) = (parsed.0, parsed.1);\n            &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50\n            &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)\n            &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==> \n                parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1\n        }\n    }\n}\n\nspec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n' &&\n    exists|lines: Seq<Seq<char>>| {\n        &&& lines == split_lines(output)\n        &&& lines.len() >= 1\n        &&& valid_number(lines[0])\n        &&& {\n            let k = parse_number(lines[0]);\n            &&& 0 <= k <= 2500\n            &&& lines.len() == k + 1\n            &&& {\n                let parsed = parse_input(original_input);\n                let (n, m) = (parsed.0, parsed.1);\n                forall|i: int| 1 <= i <= k ==> valid_coordinate_pair(lines[i], n-1, m-1)\n            }\n        }\n    }\n}\n\nspec fn valid_dimension_line(line: Seq<char>) -> bool { line.len() > 0 }\nspec fn valid_matrix_row(line: Seq<char>, m: int) -> bool { line.len() > 0 && m > 0 }\nspec fn valid_number(s: Seq<char>) -> bool { s.len() > 0 }\nspec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool { \n    s.len() > 0 && max_x > 0 && max_y > 0 \n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> { seq![s] }\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) { (2, 2) }\nspec fn parse_number(s: Seq<char>) -> int { 0 }\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) { \n    (2, 2, seq![seq![0, 0], seq![0, 0]]) \n}\nspec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> { seq![] }\nspec fn parse_matrix_element(line: Seq<char>, pos: int) -> int { 0 }\nspec fn to_string(n: int) -> Seq<char> { seq!['0'] }\n\nspec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) {\n    let b = Seq::new(n as nat, |i: int| Seq::new(m as nat, |j: int| 0));\n    let ops = seq![];\n    greedy_step(a, b, ops, 0, 0, n, m)\n}\n\nspec fn greedy_step(a: Seq<Seq<int>>, b: Seq<Seq<int>>, ops: Seq<(int, int)>, \n                   start_i: int, start_j: int, n: int, m: int) -> (Seq<Seq<int>>, Seq<(int, int)>) {\n    (b, ops)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),\n        result@ != \"-1\\n\"@ ==> {\n            let parsed = parse_input(stdin_input@);\n            let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n            let ops = parse_operations(result@);\n            let algorithm_result = apply_greedy_algorithm(n, m, a);\n            let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);\n            b == a && ops == expected_ops\n        },\n        result@ == \"-1\\n\"@ ==> {\n            let parsed = parse_input(stdin_input@);\n            let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n            let algorithm_result = apply_greedy_algorithm(n, m, a);\n            let b = algorithm_result.0;\n            b != a\n        },\n        result@ == \"-1\\n\"@ || exists|k: nat, lines: Seq<Seq<char>>| {\n            &&& lines == split_lines(result@)\n            &&& lines.len() == k + 1\n            &&& lines[0] == to_string(k as int)\n            &&& k <= 2500\n            &&& {\n                let parsed = parse_input(stdin_input@);\n                let (n, m) = (parsed.0, parsed.1);\n                forall|i: int| #[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {\n                    &&& 1 <= n-1 && 1 <= m-1\n                    &&& lines[i] == seq!['d', 'u', 'm', 'm', 'y']\n                }\n            }\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"-1\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n          input.len() > 0 && input[input.len() - 1] == '\\n' &&     exists|lines: Seq<Seq<char>>| {\n             &&& lines == split_lines(input)         &&& lines.len() >= 3         &&& valid_dimension_line(lines[0])         &&& {\n                let parsed = parse_dimensions(lines[0]);\n                let (n, m) = (parsed.0, parsed.1);\n                &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50             &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)             &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>                  parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1         }\n         }\n      }\n       spec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool ;\n       spec fn valid_dimension_line(line: Seq<char>) -> bool ;\n       spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool ;\n       spec fn valid_number(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;\n       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n      seq![s] }\n       spec fn parse_dimensions(line: Seq<char>) -> (int, int) ;\n       spec fn parse_number(s: Seq<char>) -> int ;\n       spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) ;\n       spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> ;\n       spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;\n       spec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n                  let parsed = parse_input(stdin_input@);\n                  let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n                  let ops = parse_operations(result@);\n                  let algorithm_result = apply_greedy_algorithm(n, m, a);\n                  let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);\n                  b == a && ops == expected_ops         }\n      ,         result@ == \"-1\\n\"@ || exists|k: nat, lines: Seq<Seq<char>>| {\n                  &&& lines == split_lines(result@)             &&& lines.len() == k + 1             &&& lines[0] == to_string(k as int)             &&& k <= 2500             &&& {\n                     let parsed = parse_input(stdin_input@);\n                     let (n, m) = (parsed.0, parsed.1);\n                     forall|i: int|        \n#[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {\n                    &&& 1 <= n-1 && 1 <= m-1                     &&& lines[i] == seq!['d', 'u', 'm', 'm', 'y']                 }\n                  }\n               }\n       , {\n           \"-1\\n\".to_string() }\n        }\n        fn main() {\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_114.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 988, "minimize_time_ms": 184830, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 124, "minimized_LOC": 45, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.3629032258064516}, "labeling": {"segments": {"exec": " fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n\n fn main() {", "spec": "spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool ;\n       spec fn valid_dimension_line(line: Seq<char>) -> bool ;\n       spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool ;\n       spec fn valid_number(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;\n       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn valid_dimension_line(line: Seq<char>) -> bool ;\n       spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool ;\n       spec fn valid_number(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;\n       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn valid_matrix_row(line: Seq<char>, m: int) -> bool ;\n       spec fn valid_number(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;\n       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn valid_number(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;\n       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;\n       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) ;\n       spec fn parse_number(s: Seq<char>) -> int ;\n       spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) ;\n       spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> ;\n       spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;\n       spec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n\nspec fn parse_number(s: Seq<char>) -> int ;\n       spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) ;\n       spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> ;\n       spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;\n       spec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) ;\n       spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> ;\n       spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;\n       spec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n\nspec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> ;\n       spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;\n       spec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n\nspec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;\n       spec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n\nspec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n\nspec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n' &&\n    exists|lines: Seq<Seq<char>>| {\n        &&& lines == split_lines(input)\n        &&& lines.len() >= 3\n        &&& valid_dimension_line(lines[0])\n        &&& {\n            let parsed = parse_dimensions(lines[0]);\n            let (n, m) = (parsed.0, parsed.1);\n            &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50\n            &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)\n            &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==> \n                parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1\n        }\n    }\n}\n\nspec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n' &&\n    exists|lines: Seq<Seq<char>>| {\n        &&& lines == split_lines(output)\n        &&& lines.len() >= 1\n        &&& valid_number(lines[0])\n        &&& {\n            let k = parse_number(lines[0]);\n            &&& 0 <= k <= 2500\n            &&& lines.len() == k + 1\n            &&& {\n                let parsed = parse_input(original_input);\n                let (n, m) = (parsed.0, parsed.1);\n                forall|i: int| 1 <= i <= k ==> valid_coordinate_pair(lines[i], n-1, m-1)\n            }\n        }\n    }\n}\n\nspec fn valid_dimension_line(line: Seq<char>) -> bool { line.len() > 0 }\nspec fn valid_matrix_row(line: Seq<char>, m: int) -> bool { line.len() > 0 && m > 0 }\nspec fn valid_number(s: Seq<char>) -> bool { s.len() > 0 }\nspec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool { \n    s.len() > 0 && max_x > 0 && max_y > 0 \n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> { seq![s] }\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) { (2, 2) }\nspec fn parse_number(s: Seq<char>) -> int { 0 }\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) { \n    (2, 2, seq![seq![0, 0], seq![0, 0]]) \n}\nspec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> { seq![] }\nspec fn parse_matrix_element(line: Seq<char>, pos: int) -> int { 0 }\nspec fn to_string(n: int) -> Seq<char> { seq!['0'] }\n\nspec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) {\n    let b = Seq::new(n as nat, |i: int| Seq::new(m as nat, |j: int| 0));\n    let ops = seq![];\n    greedy_step(a, b, ops, 0, 0, n, m)\n}\n\nspec fn greedy_step(a: Seq<Seq<int>>, b: Seq<Seq<int>>, ops: Seq<(int, int)>, \n                   start_i: int, start_j: int, n: int, m: int) -> (Seq<Seq<int>>, Seq<(int, int)>) {\n    (b, ops)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),\n        result@ != \"-1\\n\"@ ==> {\n            let parsed = parse_input(stdin_input@);\n            let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n            let ops = parse_operations(result@);\n            let algorithm_result = apply_greedy_algorithm(n, m, a);\n            let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);\n            b == a && ops == expected_ops\n        },\n        result@ == \"-1\\n\"@ ==> {\n            let parsed = parse_input(stdin_input@);\n            let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n            let algorithm_result = apply_greedy_algorithm(n, m, a);\n            let b = algorithm_result.0;\n            b != a\n        },\n        result@ == \"-1\\n\"@ || exists|k: nat, lines: Seq<Seq<char>>| {\n            &&& lines == split_lines(result@)\n            &&& lines.len() == k + 1\n            &&& lines[0] == to_string(k as int)\n            &&& k <= 2500\n            &&& {\n                let parsed = parse_input(stdin_input@);\n                let (n, m) = (parsed.0, parsed.1);\n                forall|i: int| #[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {\n                    &&& 1 <= n-1 && 1 <= m-1\n                    &&& lines[i] == seq!['d', 'u', 'm', 'm', 'y']\n                }\n            }\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"-1\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n          input.len() > 0 && input[input.len() - 1] == '\\n' &&     exists|lines: Seq<Seq<char>>| {\n             &&& lines == split_lines(input)         &&& lines.len() >= 3         &&& valid_dimension_line(lines[0])         &&& {\n                let parsed = parse_dimensions(lines[0]);\n                let (n, m) = (parsed.0, parsed.1);\n                &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50             &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)             &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>                  parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1         }\n         }\n      }\n       spec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool ;\n       spec fn valid_dimension_line(line: Seq<char>) -> bool ;\n       spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool ;\n       spec fn valid_number(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;\n       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n      seq![s] }\n       spec fn parse_dimensions(line: Seq<char>) -> (int, int) ;\n       spec fn parse_number(s: Seq<char>) -> int ;\n       spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) ;\n       spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> ;\n       spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;\n       spec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),         result@ != \"-1\\n\"@ ==> {\n                  let parsed = parse_input(stdin_input@);\n                  let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n                  let ops = parse_operations(result@);\n                  let algorithm_result = apply_greedy_algorithm(n, m, a);\n                  let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);\n                  b == a && ops == expected_ops         }\n      ,         result@ == \"-1\\n\"@ || exists|k: nat, lines: Seq<Seq<char>>| {\n                  &&& lines == split_lines(result@)             &&& lines.len() == k + 1             &&& lines[0] == to_string(k as int)             &&& k <= 2500             &&& {\n                     let parsed = parse_input(stdin_input@);\n                     let (n, m) = (parsed.0, parsed.1);\n                     forall|i: int|        \n#[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {\n                    &&& 1 <= n-1 && 1 <= m-1                     &&& lines[i] == seq!['d', 'u', 'm', 'm', 'y']                 }\n                  }\n               }\n       , {\n           \"-1\\n\".to_string() }\n        }\n        fn main() {\n       }\n", "use vstd::prelude::*;\n             fn main() {\n   }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1209_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool \n{\n    input.len() > 0 && contains_newline(input) && \n    has_valid_structure(input) && \n    first_line_is_valid_integer(input) &&\n    remaining_lines_are_valid_reals(input)\n}\n\nspec fn input_sum_is_zero(input: Seq<char>) -> bool\n{\n    has_valid_structure(input) ==> sum_of_input_reals(input) == 0.0\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool\n{\n    output.len() >= 0 && \n    (output.len() == 0 || (ends_with_newline(output) && all_lines_are_integers(output)))\n}\n\nspec fn output_has_correct_length(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    count_lines(output) == get_n_from_input(input)\n}\n\nspec fn each_output_is_floor_or_ceiling(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    forall|i: int| 0 <= i < get_n_from_input(input) ==> \n        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>\n        {\n            let input_val = get_ith_real(input, i);\n            let output_val = get_ith_integer(output, i);\n            output_val == floor_of(input_val) || output_val == ceiling_of(input_val)\n        }\n}\n\nspec fn output_sum_is_zero(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    sum_of_output_integers(output) == 0\n}\n\nspec fn output_preserves_integers(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    forall|i: int| 0 <= i < get_n_from_input(input) ==> \n        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>\n        {\n            let input_val = get_ith_real(input, i);\n            is_integer(input_val) ==> get_ith_integer(output, i) == int_value_of(input_val)\n        }\n}\n\nspec fn contains_newline(s: Seq<char>) -> bool\n{\n    exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == '\\n'\n}\n\nspec fn ends_with_newline(s: Seq<char>) -> bool\n{\n    s.len() > 0 && s[s.len()-1] == '\\n'\n}\n\nspec fn has_valid_structure(s: Seq<char>) -> bool { true }\nspec fn first_line_is_valid_integer(s: Seq<char>) -> bool { true }\nspec fn remaining_lines_are_valid_reals(s: Seq<char>) -> bool { true }\nspec fn all_lines_are_integers(s: Seq<char>) -> bool { true }\nspec fn is_integer(r: f64) -> bool { true }\n\nspec fn sum_of_input_reals(input: Seq<char>) -> f64 { 0.0 }\nspec fn sum_of_output_integers(output: Seq<char>) -> int { 0 }\nspec fn get_n_from_input(input: Seq<char>) -> nat { 1 }\nspec fn count_lines(s: Seq<char>) -> nat { if s == seq![48 as char, '\\n'] { 1 } else { 0 } }\nspec fn get_ith_real(input: Seq<char>, i: int) -> f64 { 0.0 }\nspec fn get_ith_integer(output: Seq<char>, i: int) -> int { 0 }\nspec fn floor_of(r: f64) -> int { 0 }\nspec fn ceiling_of(r: f64) -> int { 0 }\nspec fn int_value_of(r: f64) -> int { 0 }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (output: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        valid_input_format(stdin_input),\n        input_sum_is_zero(stdin_input),\n    ensures\n        valid_output_format(output),\n        output_has_correct_length(stdin_input, output),\n        each_output_is_floor_or_ceiling(stdin_input, output),\n        output_sum_is_zero(stdin_input, output),\n        output_preserves_integers(stdin_input, output),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool \n{\n    input.len() > 0 && contains_newline(input) && \n    has_valid_structure(input) && \n    first_line_is_valid_integer(input) &&\n    remaining_lines_are_valid_reals(input)\n}\n\nspec fn input_sum_is_zero(input: Seq<char>) -> bool\n{\n    has_valid_structure(input) ==> sum_of_input_reals(input) == 0.0\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool\n{\n    output.len() >= 0 && \n    (output.len() == 0 || (ends_with_newline(output) && all_lines_are_integers(output)))\n}\n\nspec fn output_has_correct_length(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    count_lines(output) == get_n_from_input(input)\n}\n\nspec fn each_output_is_floor_or_ceiling(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    forall|i: int| 0 <= i < get_n_from_input(input) ==> \n        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>\n        {\n            let input_val = get_ith_real(input, i);\n            let output_val = get_ith_integer(output, i);\n            output_val == floor_of(input_val) || output_val == ceiling_of(input_val)\n        }\n}\n\nspec fn output_sum_is_zero(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    sum_of_output_integers(output) == 0\n}\n\nspec fn output_preserves_integers(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    forall|i: int| 0 <= i < get_n_from_input(input) ==> \n        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>\n        {\n            let input_val = get_ith_real(input, i);\n            is_integer(input_val) ==> get_ith_integer(output, i) == int_value_of(input_val)\n        }\n}\n\nspec fn contains_newline(s: Seq<char>) -> bool\n{\n    exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == '\\n'\n}\n\nspec fn ends_with_newline(s: Seq<char>) -> bool\n{\n    s.len() > 0 && s[s.len()-1] == '\\n'\n}\n\nspec fn has_valid_structure(s: Seq<char>) -> bool { true }\nspec fn first_line_is_valid_integer(s: Seq<char>) -> bool { true }\nspec fn remaining_lines_are_valid_reals(s: Seq<char>) -> bool { true }\nspec fn all_lines_are_integers(s: Seq<char>) -> bool { true }\nspec fn is_integer(r: f64) -> bool { true }\n\nspec fn sum_of_input_reals(input: Seq<char>) -> f64 { 0.0 }\nspec fn sum_of_output_integers(output: Seq<char>) -> int { 0 }\nspec fn get_n_from_input(input: Seq<char>) -> nat { 1 }\nspec fn count_lines(s: Seq<char>) -> nat { if s == seq![48 as char, '\\n'] { 1 } else { 0 } }\nspec fn get_ith_real(input: Seq<char>, i: int) -> f64 { 0.0 }\nspec fn get_ith_integer(output: Seq<char>, i: int) -> int { 0 }\nspec fn floor_of(r: f64) -> int { 0 }\nspec fn ceiling_of(r: f64) -> int { 0 }\nspec fn int_value_of(r: f64) -> int { 0 }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (output: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        valid_input_format(stdin_input),\n        input_sum_is_zero(stdin_input),\n    ensures\n        valid_output_format(output),\n        output_has_correct_length(stdin_input, output),\n        each_output_is_floor_or_ceiling(stdin_input, output),\n        output_sum_is_zero(stdin_input, output),\n        output_preserves_integers(stdin_input, output),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1209.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 576, "verus_errors": [{"error_type": "TypeAnnotation", "error_text": "type annotations needed (cannot infer type of the type parameter `hint_please_add_suffix_on_literal_like_100f32_or_100real` declared on the function `spec_literal_decimal`)", "message": "VerusErrorType.TypeAnnotation: type annotations needed (cannot infer type of the type parameter `hint_please_add_suffix_on_literal_like_100f32_or_100real` declared on the function `spec_literal_decimal`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpgh00tmp1", "lines": [16, 16], "label": "cannot infer type of the type parameter `hint_please_add_suffix_on_literal_like_100f32_or_100real` declared on the function `spec_literal_decimal`", "text": [{"text": "    has_valid_structure(input) ==> sum_of_input_reals(input) == 0.0", "highlight_start": 65, "highlight_end": 68}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 115, "minimized_LOC": 115, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 28, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(input: Seq<char>) -> bool \n{\n\nspec fn input_sum_is_zero(input: Seq<char>) -> bool\n{\n\nspec fn valid_output_format(output: Seq<char>) -> bool\n{\n\nspec fn output_has_correct_length(input: Seq<char>, output: Seq<char>) -> bool\n{\n\nspec fn each_output_is_floor_or_ceiling(input: Seq<char>, output: Seq<char>) -> bool\n{\n\nspec fn output_sum_is_zero(input: Seq<char>, output: Seq<char>) -> bool\n{\n\nspec fn output_preserves_integers(input: Seq<char>, output: Seq<char>) -> bool\n{\n\nspec fn contains_newline(s: Seq<char>) -> bool\n{\n\nspec fn ends_with_newline(s: Seq<char>) -> bool\n{\n\nspec fn has_valid_structure(s: Seq<char>) -> bool {\n\nspec fn first_line_is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn remaining_lines_are_valid_reals(s: Seq<char>) -> bool {\n\nspec fn all_lines_are_integers(s: Seq<char>) -> bool {\n\nspec fn is_integer(r: f64) -> bool {\n\nspec fn sum_of_input_reals(input: Seq<char>) -> f64 {\n\nspec fn sum_of_output_integers(output: Seq<char>) -> int {\n\nspec fn get_n_from_input(input: Seq<char>) -> nat {\n\nspec fn count_lines(s: Seq<char>) -> nat {\n\nspec fn get_ith_real(input: Seq<char>, i: int) -> f64 {\n\nspec fn get_ith_integer(output: Seq<char>, i: int) -> int {\n\nspec fn floor_of(r: f64) -> int {\n\nspec fn ceiling_of(r: f64) -> int {\n\nspec fn int_value_of(r: f64) -> int {\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_1268_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {\n    a.len() == b.len() && a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> 0 <= #[trigger] a[i] <= #[trigger] b[i]\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_two_largest_sum(s: Seq<int>) -> int\n    recommends s.len() >= 2\n{\n    0\n}\n\nspec fn find_max(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nspec fn find_max_excluding(s: Seq<int>, exclude: int) -> int\n    recommends s.len() >= 2 && 0 <= exclude < s.len()\n{\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Seq<int>, b: Seq<int>) -> (result: String)\n    requires \n        valid_input(a, b),\n    ensures \n        result@ == seq!['Y','E','S'] || result@ == seq!['N','O'],\n        (result@ == seq!['Y','E','S']) <==> find_two_largest_sum(b) >= sum_seq(a),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {\n    a.len() == b.len() && a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> 0 <= #[trigger] a[i] <= #[trigger] b[i]\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_two_largest_sum(s: Seq<int>) -> int\n    recommends s.len() >= 2\n{\n    0\n}\n\nspec fn find_max(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nspec fn find_max_excluding(s: Seq<int>, exclude: int) -> int\n    recommends s.len() >= 2 && 0 <= exclude < s.len()\n{\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Seq<int>, b: Seq<int>) -> (result: String)\n    requires \n        valid_input(a, b),\n    ensures \n        result@ == seq!['Y','E','S'] || result@ == seq!['N','O'],\n        (result@ == seq!['Y','E','S']) <==> find_two_largest_sum(b) >= sum_seq(a),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1268.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 872, "minimize_time_ms": 122438, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn find_two_largest_sum(s: Seq<int>) -> int\n    recommends s.len() >= 2\n{\n\nspec fn find_max(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n\nspec fn find_max_excluding(s: Seq<int>, exclude: int) -> int\n    recommends s.len() >= 2 && 0 <= exclude < s.len()\n{\n\n    decreases s.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {\n    a.len() == b.len() && a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> 0 <= #[trigger] a[i] <= #[trigger] b[i]\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_two_largest_sum(s: Seq<int>) -> int\n    recommends s.len() >= 2\n{\n    0\n}\n\nspec fn find_max(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nspec fn find_max_excluding(s: Seq<int>, exclude: int) -> int\n    recommends s.len() >= 2 && 0 <= exclude < s.len()\n{\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Seq<int>, b: Seq<int>) -> (result: String)\n    requires \n        valid_input(a, b),\n    ensures \n        result@ == seq!['Y','E','S'] || result@ == seq!['N','O'],\n        (result@ == seq!['Y','E','S']) <==> find_two_largest_sum(b) >= sum_seq(a),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_131_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && \n    parse_int(lines[0]) > 0 &&\n    parse_int_array(lines[1]).len() == parse_int(lines[0]) &&\n    parse_int_array(lines[2]).len() == parse_int(lines[0])\n}\n\nspec fn get_initial_sum(input: &str) -> int\n    recommends is_valid_input(input)\n{\n    let lines = split_lines(input);\n    sum_seq(parse_int_array(lines[1]))\n}\n\nspec fn get_target_sum(input: &str) -> int\n    recommends is_valid_input(input)\n{\n    let lines = split_lines(input);\n    sum_seq(parse_int_array(lines[2]))\n}\n\nspec fn sum_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        0\n    } else {\n        nums[0] + sum_seq(nums.subrange(1, nums.len() as int))\n    }\n}\n\nuninterp spec fn split_lines(input: &str) -> Seq<&str>;\nuninterp spec fn parse_int(s: &str) -> int;\nuninterp spec fn parse_int_array(s: &str) -> Seq<int>;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires is_valid_input(input)\n    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && \n    parse_int(lines[0]) > 0 &&\n    parse_int_array(lines[1]).len() == parse_int(lines[0]) &&\n    parse_int_array(lines[2]).len() == parse_int(lines[0])\n}\n\nspec fn get_initial_sum(input: &str) -> int\n    recommends is_valid_input(input)\n{\n    let lines = split_lines(input);\n    sum_seq(parse_int_array(lines[1]))\n}\n\nspec fn get_target_sum(input: &str) -> int\n    recommends is_valid_input(input)\n{\n    let lines = split_lines(input);\n    sum_seq(parse_int_array(lines[2]))\n}\n\nspec fn sum_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        0\n    } else {\n        nums[0] + sum_seq(nums.subrange(1, nums.len() as int))\n    }\n}\n\nuninterp spec fn split_lines(input: &str) -> Seq<&str>;\nuninterp spec fn parse_int(s: &str) -> int;\nuninterp spec fn parse_int_array(s: &str) -> Seq<int>;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires is_valid_input(input)\n    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_131.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 524, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types; types must be compatible to use == or != (this is `alloc::string::String`; this is `StrSlice`)", "message": "VerusErrorType.MismatchedType: mismatched types; types must be compatible to use == or != (this is `alloc::string::String`; this is `StrSlice`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp9ur235ic", "lines": [49, 49], "label": "this is `alloc::string::String`", "text": [{"text": "    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)", "highlight_start": 14, "highlight_end": 20}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp9ur235ic", "lines": [49, 49], "label": "this is `StrSlice`", "text": [{"text": "    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)", "highlight_start": 24, "highlight_end": 29}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp9ur235ic", "lines": [49, 49], "label": null, "text": [{"text": "    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)", "highlight_start": 13, "highlight_end": 30}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn is_valid_input(input: &str) -> bool {\n\nspec fn get_initial_sum(input: &str) -> int\n    recommends is_valid_input(input)\n{\n\nspec fn get_target_sum(input: &str) -> int\n    recommends is_valid_input(input)\n{\n\nspec fn sum_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n\nspec fn split_lines(input: &str) -> Seq<&str>;\nuninterp spec fn parse_int(s: &str) -> int;\nuninterp spec fn parse_int_array(s: &str) -> Seq<int>;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires is_valid_input(input)\n    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)\n// </vc-spec>\n// <vc-code>\n{\n\nspec fn parse_int(s: &str) -> int;\nuninterp spec fn parse_int_array(s: &str) -> Seq<int>;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires is_valid_input(input)\n    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)\n// </vc-spec>\n// <vc-code>\n{\n\nspec fn parse_int_array(s: &str) -> Seq<int>;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires is_valid_input(input)\n    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)\n// </vc-spec>\n// <vc-code>\n{\n\n    decreases nums.len()\n\n    requires is_valid_input(input)\n\n    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)"}}}, "all_snapshots": []}
{"id": "apps_test_1339_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: int, segments: Seq<(int, int)>) -> bool {\n    n >= 1 && segments.len() == n && \n    forall|i: int| 0 <= i < n ==> segments[i].0 <= segments[i].1\n}\n\nspec fn covers_all(segments: Seq<(int, int)>, idx: int) -> bool {\n    0 <= idx < segments.len() &&\n    forall|j: int| 0 <= j < segments.len() ==> \n        segments[idx].0 <= segments[j].0 && segments[j].1 <= segments[idx].1\n}\n\nspec fn has_min_left_and_max_right(segments: Seq<(int, int)>, idx: int) -> bool {\n    0 <= idx < segments.len() &&\n    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].0 <= segments[j].0) &&\n    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].1 >= segments[j].1)\n}\n\nspec fn min_left(segments: Seq<(int, int)>) -> int\n    requires segments.len() > 0\n    decreases segments.len()\n{\n    if segments.len() == 1 { \n        segments[0].0\n    } else if segments[0].0 <= min_left(segments.subrange(1, segments.len() as int)) { \n        segments[0].0\n    } else { \n        min_left(segments.subrange(1, segments.len() as int))\n    }\n}\n\nspec fn max_right(segments: Seq<(int, int)>) -> int\n    requires segments.len() > 0\n    decreases segments.len()\n{\n    if segments.len() == 1 { \n        segments[0].1\n    } else if segments[0].1 >= max_right(segments.subrange(1, segments.len() as int)) { \n        segments[0].1\n    } else { \n        max_right(segments.subrange(1, segments.len() as int))\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i32, segments: &[i32]) -> (result: i32)\n    requires \n        n >= 1 && segments.len() == n && \n        forall|i: int| 0 <= i < n ==> i % 2 == 0 ==> segments[i] <= segments[i + 1]\n    ensures \n        result == -1 || (1 <= result <= n)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: int, segments: Seq<(int, int)>) -> bool {\n    n >= 1 && segments.len() == n && \n    forall|i: int| 0 <= i < n ==> segments[i].0 <= segments[i].1\n}\n\nspec fn covers_all(segments: Seq<(int, int)>, idx: int) -> bool {\n    0 <= idx < segments.len() &&\n    forall|j: int| 0 <= j < segments.len() ==> \n        segments[idx].0 <= segments[j].0 && segments[j].1 <= segments[idx].1\n}\n\nspec fn has_min_left_and_max_right(segments: Seq<(int, int)>, idx: int) -> bool {\n    0 <= idx < segments.len() &&\n    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].0 <= segments[j].0) &&\n    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].1 >= segments[j].1)\n}\n\nspec fn min_left(segments: Seq<(int, int)>) -> int\n    requires segments.len() > 0\n    decreases segments.len()\n{\n    if segments.len() == 1 { \n        segments[0].0\n    } else if segments[0].0 <= min_left(segments.subrange(1, segments.len() as int)) { \n        segments[0].0\n    } else { \n        min_left(segments.subrange(1, segments.len() as int))\n    }\n}\n\nspec fn max_right(segments: Seq<(int, int)>) -> int\n    requires segments.len() > 0\n    decreases segments.len()\n{\n    if segments.len() == 1 { \n        segments[0].1\n    } else if segments[0].1 >= max_right(segments.subrange(1, segments.len() as int)) { \n        segments[0].1\n    } else { \n        max_right(segments.subrange(1, segments.len() as int))\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i32, segments: &[i32]) -> (result: i32)\n    requires \n        n >= 1 && segments.len() == n && \n        forall|i: int| 0 <= i < n ==> i % 2 == 0 ==> segments[i] <= segments[i + 1]\n    ensures \n        result == -1 || (1 <= result <= n)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1339.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 671, "verus_errors": [{"error_type": "Other", "error_text": "spec functions cannot have requires/ensures ()", "message": "VerusErrorType.Other: spec functions cannot have requires/ensures ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp7vc94p8y", "lines": [25, 25], "label": null, "text": [{"text": "spec fn min_left(segments: Seq<(int, int)>) -> int", "highlight_start": 6, "highlight_end": 51}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 70, "minimized_LOC": 70, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, segments: Seq<(int, int)>) -> bool {\n\nspec fn covers_all(segments: Seq<(int, int)>, idx: int) -> bool {\n\nspec fn has_min_left_and_max_right(segments: Seq<(int, int)>, idx: int) -> bool {\n\nspec fn min_left(segments: Seq<(int, int)>) -> int\n    requires segments.len() > 0\n    decreases segments.len()\n{\n\nspec fn max_right(segments: Seq<(int, int)>) -> int\n    requires segments.len() > 0\n    decreases segments.len()\n{\n\n    requires segments.len() > 0\n\n    decreases segments.len()\n\n    requires segments.len() > 0\n\n    decreases segments.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_1354_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {\n    n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&\n    (forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n)\n}\n\nspec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool\n    recommends\n        n > 0 && k > 0 && a > 0 && num_shots >= 0,\n        num_shots <= shots.len(),\n        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n\n{\n    let hit_cells = Set::new(|cell: int| exists|i: int| 0 <= i < num_shots && i < shots.len() && shots[i] == cell);\n    greedy_ship_placement(n, k, a, hit_cells) >= k\n}\n\nspec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        n > 0 && k > 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    greedy_place_ships_from_position(1, n, k, a, hit_cells)\n}\n\nspec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        pos >= 1 && n > 0 && k >= 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    if k == 0 || pos > n {\n        0\n    } else {\n        // Simplified implementation without termination issues\n        if pos + a - 1 <= n { 1 } else { 0 }\n    }\n}\n\nspec fn is_natural_number_string(s: Seq<char>) -> bool {\n    s.len() > 0 && s[0] != '0' && (forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> '0' <= s[i] <= '9')\n}\n\nspec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>\n    recommends input.len() > 0\n{\n    seq![]\n}\n\nspec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {\n    (1, 1, 1)\n}\n\nspec fn parse_int_spec(line: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_spec(value: int) -> Seq<char>\n    recommends value >= 1\n{\n    seq!['1']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len()-1] == '\\n'\n    ensures\n        result.len() > 0,\n        result[result.len()-1] == '\\n',\n        result == seq!['-', '1', '\\n'] || (exists|shot_num_str: Seq<char>| #![auto] shot_num_str.len() > 0 && \n                             result == shot_num_str + seq!['\\n'] && \n                             is_natural_number_string(shot_num_str)),\n        ({\n            let lines = parse_input_spec(stdin_input);\n            if lines.len() >= 3 {\n                let first_line = parse_three_ints_spec(lines[0]);\n                let (n, k, a) = (first_line.0, first_line.1, first_line.2);\n                let m = parse_int_spec(lines[1]);\n                let shots = parse_int_array_spec(lines[2]);\n                if valid_input(n, k, a, m, shots) {\n                    if can_place_ships_func(n, k, a, shots, m) {\n                        result == seq!['-', '1', '\\n']\n                    } else {\n                        exists|shot_idx: int| #![auto] 1 <= shot_idx <= m && \n                                            result == int_to_string_spec(shot_idx) + seq!['\\n'] &&\n                                            !can_place_ships_func(n, k, a, shots, shot_idx) &&\n                                            (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))\n                    }\n                } else {\n                    true\n                }\n            } else {\n                true\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {\n    n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&\n    (forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n)\n}\n\nspec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool\n    recommends\n        n > 0 && k > 0 && a > 0 && num_shots >= 0,\n        num_shots <= shots.len(),\n        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n\n{\n    let hit_cells = Set::new(|cell: int| exists|i: int| 0 <= i < num_shots && i < shots.len() && shots[i] == cell);\n    greedy_ship_placement(n, k, a, hit_cells) >= k\n}\n\nspec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        n > 0 && k > 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    greedy_place_ships_from_position(1, n, k, a, hit_cells)\n}\n\nspec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        pos >= 1 && n > 0 && k >= 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    if k == 0 || pos > n {\n        0\n    } else {\n        // Simplified implementation without termination issues\n        if pos + a - 1 <= n { 1 } else { 0 }\n    }\n}\n\nspec fn is_natural_number_string(s: Seq<char>) -> bool {\n    s.len() > 0 && s[0] != '0' && (forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> '0' <= s[i] <= '9')\n}\n\nspec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>\n    recommends input.len() > 0\n{\n    seq![]\n}\n\nspec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {\n    (1, 1, 1)\n}\n\nspec fn parse_int_spec(line: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_spec(value: int) -> Seq<char>\n    recommends value >= 1\n{\n    seq!['1']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len()-1] == '\\n'\n    ensures\n        result.len() > 0,\n        result[result.len()-1] == '\\n',\n        result == seq!['-', '1', '\\n'] || (exists|shot_num_str: Seq<char>| #![auto] shot_num_str.len() > 0 && \n                             result == shot_num_str + seq!['\\n'] && \n                             is_natural_number_string(shot_num_str)),\n        ({\n            let lines = parse_input_spec(stdin_input);\n            if lines.len() >= 3 {\n                let first_line = parse_three_ints_spec(lines[0]);\n                let (n, k, a) = (first_line.0, first_line.1, first_line.2);\n                let m = parse_int_spec(lines[1]);\n                let shots = parse_int_array_spec(lines[2]);\n                if valid_input(n, k, a, m, shots) {\n                    if can_place_ships_func(n, k, a, shots, m) {\n                        result == seq!['-', '1', '\\n']\n                    } else {\n                        exists|shot_idx: int| #![auto] 1 <= shot_idx <= m && \n                                            result == int_to_string_spec(shot_idx) + seq!['\\n'] &&\n                                            !can_place_ships_func(n, k, a, shots, shot_idx) &&\n                                            (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))\n                    }\n                } else {\n                    true\n                }\n            } else {\n                true\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1354.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 882, "minimize_time_ms": 153531, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 120, "minimized_LOC": 120, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 25, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {\n\nspec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool\n    recommends\n        n > 0 && k > 0 && a > 0 && num_shots >= 0,\n        num_shots <= shots.len(),\n        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n\n{\n\nspec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        n > 0 && k > 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n\nspec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        pos >= 1 && n > 0 && k >= 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n\nspec fn is_natural_number_string(s: Seq<char>) -> bool {\n\nspec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>\n    recommends input.len() > 0\n{\n\nspec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {\n\nspec fn parse_int_spec(line: Seq<char>) -> int {\n\nspec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {\n\nspec fn int_to_string_spec(value: int) -> Seq<char>\n    recommends value >= 1\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {\n    n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&\n    (forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n)\n}\n\nspec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool\n    recommends\n        n > 0 && k > 0 && a > 0 && num_shots >= 0,\n        num_shots <= shots.len(),\n        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n\n{\n    let hit_cells = Set::new(|cell: int| exists|i: int| 0 <= i < num_shots && i < shots.len() && shots[i] == cell);\n    greedy_ship_placement(n, k, a, hit_cells) >= k\n}\n\nspec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        n > 0 && k > 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    greedy_place_ships_from_position(1, n, k, a, hit_cells)\n}\n\nspec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        pos >= 1 && n > 0 && k >= 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    if k == 0 || pos > n {\n        0\n    } else {\n        // Simplified implementation without termination issues\n        if pos + a - 1 <= n { 1 } else { 0 }\n    }\n}\n\nspec fn is_natural_number_string(s: Seq<char>) -> bool {\n    s.len() > 0 && s[0] != '0' && (forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> '0' <= s[i] <= '9')\n}\n\nspec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>\n    recommends input.len() > 0\n{\n    seq![]\n}\n\nspec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {\n    (1, 1, 1)\n}\n\nspec fn parse_int_spec(line: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_spec(value: int) -> Seq<char>\n    recommends value >= 1\n{\n    seq!['1']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len()-1] == '\\n'\n    ensures\n        result.len() > 0,\n        result[result.len()-1] == '\\n',\n        result == seq!['-', '1', '\\n'] || (exists|shot_num_str: Seq<char>| #![auto] shot_num_str.len() > 0 && \n                             result == shot_num_str + seq!['\\n'] && \n                             is_natural_number_string(shot_num_str)),\n        ({\n            let lines = parse_input_spec(stdin_input);\n            if lines.len() >= 3 {\n                let first_line = parse_three_ints_spec(lines[0]);\n                let (n, k, a) = (first_line.0, first_line.1, first_line.2);\n                let m = parse_int_spec(lines[1]);\n                let shots = parse_int_array_spec(lines[2]);\n                if valid_input(n, k, a, m, shots) {\n                    if can_place_ships_func(n, k, a, shots, m) {\n                        result == seq!['-', '1', '\\n']\n                    } else {\n                        exists|shot_idx: int| #![auto] 1 <= shot_idx <= m && \n                                            result == int_to_string_spec(shot_idx) + seq!['\\n'] &&\n                                            !can_place_ships_func(n, k, a, shots, shot_idx) &&\n                                            (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))\n                    }\n                } else {\n                    true\n                }\n            } else {\n                true\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1386_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|i: int| 0 < i < input.len() - 1 && input[i] == ' ' &&\n    (forall|j: int| 0 <= j < i ==> '0' <= input[j] <= '9') &&\n    (forall|j: int| i < j < input.len() ==> '0' <= input[j] <= '9')\n}\n\nspec fn valid_dimensions(w: int, h: int) -> bool {\n    w >= 1 && h >= 1 && w <= 1000 && h <= 1000\n}\n\nspec fn parse_two_ints(input: Seq<char>) -> (int, int) {\n    let space_index = find_space_spec(input, 0);\n    let w = string_to_int_spec(input.subrange(0, space_index));\n    let h = string_to_int_spec(input.subrange(space_index + 1, input.len() as int));\n    (w, h)\n}\n\nspec fn find_space_spec(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n    if s[start] == ' ' {\n        start\n    } else {\n        find_space_spec(s, start + 1)\n    }\n}\n\nspec fn string_to_int_spec(s: Seq<char>) -> int {\n    if s.len() == 1 {\n        s[0] as int - '0' as int\n    } else {\n        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    }\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_spec(n / 10).add(int_to_string_spec(n % 10))\n    }\n}\n\nspec fn mod_pow_spec(base: int, exp: int, mod_val: int) -> int {\n    if exp == 0 {\n        1int % mod_val\n    } else if exp % 2 == 0 {\n        let half = mod_pow_spec(base, exp / 2, mod_val);\n        (half * half) % mod_val\n    } else {\n        (base * mod_pow_spec(base, exp - 1, mod_val)) % mod_val\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn main_function() -> (result: int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|i: int| 0 < i < input.len() - 1 && input[i] == ' ' &&\n    (forall|j: int| 0 <= j < i ==> '0' <= input[j] <= '9') &&\n    (forall|j: int| i < j < input.len() ==> '0' <= input[j] <= '9')\n}\n\nspec fn valid_dimensions(w: int, h: int) -> bool {\n    w >= 1 && h >= 1 && w <= 1000 && h <= 1000\n}\n\nspec fn parse_two_ints(input: Seq<char>) -> (int, int) {\n    let space_index = find_space_spec(input, 0);\n    let w = string_to_int_spec(input.subrange(0, space_index));\n    let h = string_to_int_spec(input.subrange(space_index + 1, input.len() as int));\n    (w, h)\n}\n\nspec fn find_space_spec(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n    if s[start] == ' ' {\n        start\n    } else {\n        find_space_spec(s, start + 1)\n    }\n}\n\nspec fn string_to_int_spec(s: Seq<char>) -> int {\n    if s.len() == 1 {\n        s[0] as int - '0' as int\n    } else {\n        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    }\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_spec(n / 10).add(int_to_string_spec(n % 10))\n    }\n}\n\nspec fn mod_pow_spec(base: int, exp: int, mod_val: int) -> int {\n    if exp == 0 {\n        1int % mod_val\n    } else if exp % 2 == 0 {\n        let half = mod_pow_spec(base, exp / 2, mod_val);\n        (half * half) % mod_val\n    } else {\n        (base * mod_pow_spec(base, exp - 1, mod_val)) % mod_val\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn main_function() -> (result: int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1386.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 574, "verus_errors": [{"error_type": "Other", "error_text": "recursive function must have a decreases clause ()", "message": "VerusErrorType.Other: recursive function must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpsheftrb5", "lines": [33, 33], "label": null, "text": [{"text": "spec fn string_to_int_spec(s: Seq<char>) -> int {", "highlight_start": 6, "highlight_end": 48}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 79, "minimized_LOC": 79, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 24, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_dimensions(w: int, h: int) -> bool {\n\nspec fn parse_two_ints(input: Seq<char>) -> (int, int) {\n\nspec fn find_space_spec(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n\nspec fn string_to_int_spec(s: Seq<char>) -> int {\n\nspec fn int_to_string_spec(n: int) -> Seq<char> {\n\nspec fn mod_pow_spec(base: int, exp: int, mod_val: int) -> int {\n\n    decreases s.len() - start"}}}, "all_snapshots": []}
{"id": "apps_test_144_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_partition_into_equal_sum_segments(input: Seq<char>) -> bool {\n    if input.len() == 0 {\n        false\n    } else {\n        let lines = split_lines(input);\n        if lines.len() < 2 {\n            false\n        } else {\n            let n_str = trim(lines[0]);\n            let digits_str = trim(lines[1]);\n            let n = parse_int(n_str);\n            if n < 2 || n > 100 || digits_str.len() != n {\n                false\n            } else {\n                let digits = parse_digits(digits_str);\n                if digits.len() != n {\n                    false\n                } else {\n                    exists|i: int| 0 <= i < n - 1 && {\n                        let first_sum = sum(digits.subrange(0, i + 1));\n                        first_sum >= 0 &&\n                        can_partition_remainder(digits, i + 1, first_sum)\n                    }\n                }\n            }\n        }\n    }\n}\n\nspec fn can_partition_remainder(digits: Seq<int>, start: int, target_sum: int) -> bool \n    decreases digits.len() - start\n{\n    if start < 0 || start > digits.len() || target_sum < 0 {\n        false\n    } else if start >= digits.len() {\n        true\n    } else {\n        exists|segment_end: int| start < segment_end <= digits.len() && \n            sum(digits.subrange(start, segment_end)) == target_sum &&\n            can_partition_remainder(digits, segment_end, target_sum)\n    }\n}\n\nspec fn sum(s: Seq<int>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        char_to_digit(s[0])\n    } else {\n        char_to_digit(s[0]) * power10(s.len() - 1) + parse_int(s.skip(1))\n    }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    if '0' <= c && c <= '9' {\n        (c as int) - ('0' as int)\n    } else {\n        0\n    }\n}\n\nspec fn power10(n: int) -> int {\n    if n <= 0 {\n        1\n    } else {\n        10 * power10(n - 1)\n    }\n}\n\nspec fn parse_digits(s: Seq<char>) -> Seq<int> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![char_to_digit(s[0])] + parse_digits(s.skip(1))\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    split_by_char(s, '\\n')\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![seq![]]\n    } else if s[0] == delimiter {\n        seq![seq![]] + split_by_char(s.skip(1), delimiter)\n    } else {\n        let rest = split_by_char(s.skip(1), delimiter);\n        if rest.len() == 0 {\n            seq![s.subrange(0, 1)]\n        } else {\n            seq![s.subrange(0, 1) + rest[0]] + rest.skip(1)\n        }\n    }\n}\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n    trim_left(trim_right(s))\n}\n\nspec fn trim_left(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' {\n        trim_left(s.skip(1))\n    } else {\n        s\n    }\n}\n\nspec fn trim_right(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[s.len() - 1] == ' ' || s[s.len() - 1] == '\\t' || s[s.len() - 1] == '\\n' || s[s.len() - 1] == '\\r' {\n        trim_right(s.subrange(0, s.len() - 1))\n    } else {\n        s\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Seq<char>) -> (result: Seq<char>)\n    requires s.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    Seq::new(3 as nat, |i: nat| match i {\n        0 => 'N',\n        1 => 'O',\n        2 => '\\n',\n        _ => 'N'\n    })\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_partition_into_equal_sum_segments(input: Seq<char>) -> bool {\n    if input.len() == 0 {\n        false\n    } else {\n        let lines = split_lines(input);\n        if lines.len() < 2 {\n            false\n        } else {\n            let n_str = trim(lines[0]);\n            let digits_str = trim(lines[1]);\n            let n = parse_int(n_str);\n            if n < 2 || n > 100 || digits_str.len() != n {\n                false\n            } else {\n                let digits = parse_digits(digits_str);\n                if digits.len() != n {\n                    false\n                } else {\n                    exists|i: int| 0 <= i < n - 1 && {\n                        let first_sum = sum(digits.subrange(0, i + 1));\n                        first_sum >= 0 &&\n                        can_partition_remainder(digits, i + 1, first_sum)\n                    }\n                }\n            }\n        }\n    }\n}\n\nspec fn can_partition_remainder(digits: Seq<int>, start: int, target_sum: int) -> bool \n    decreases digits.len() - start\n{\n    if start < 0 || start > digits.len() || target_sum < 0 {\n        false\n    } else if start >= digits.len() {\n        true\n    } else {\n        exists|segment_end: int| start < segment_end <= digits.len() && \n            sum(digits.subrange(start, segment_end)) == target_sum &&\n            can_partition_remainder(digits, segment_end, target_sum)\n    }\n}\n\nspec fn sum(s: Seq<int>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        char_to_digit(s[0])\n    } else {\n        char_to_digit(s[0]) * power10(s.len() - 1) + parse_int(s.skip(1))\n    }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    if '0' <= c && c <= '9' {\n        (c as int) - ('0' as int)\n    } else {\n        0\n    }\n}\n\nspec fn power10(n: int) -> int {\n    if n <= 0 {\n        1\n    } else {\n        10 * power10(n - 1)\n    }\n}\n\nspec fn parse_digits(s: Seq<char>) -> Seq<int> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![char_to_digit(s[0])] + parse_digits(s.skip(1))\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    split_by_char(s, '\\n')\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![seq![]]\n    } else if s[0] == delimiter {\n        seq![seq![]] + split_by_char(s.skip(1), delimiter)\n    } else {\n        let rest = split_by_char(s.skip(1), delimiter);\n        if rest.len() == 0 {\n            seq![s.subrange(0, 1)]\n        } else {\n            seq![s.subrange(0, 1) + rest[0]] + rest.skip(1)\n        }\n    }\n}\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n    trim_left(trim_right(s))\n}\n\nspec fn trim_left(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' {\n        trim_left(s.skip(1))\n    } else {\n        s\n    }\n}\n\nspec fn trim_right(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[s.len() - 1] == ' ' || s[s.len() - 1] == '\\t' || s[s.len() - 1] == '\\n' || s[s.len() - 1] == '\\r' {\n        trim_right(s.subrange(0, s.len() - 1))\n    } else {\n        s\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Seq<char>) -> (result: Seq<char>)\n    requires s.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    Seq::new(3 as nat, |i: nat| match i {\n        0 => 'N',\n        1 => 'O',\n        2 => '\\n',\n        _ => 'N'\n    })\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_144.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 203, "verus_errors": [{"error_type": "Other", "error_text": "The Verus types 'nat' and 'int' can only be used in ghost code (e.g., in a 'spec' or 'proof' function, inside a 'proof' block, or when assigning to a 'ghost' or 'tracked' variable) ()", "message": "VerusErrorType.Other: The Verus types 'nat' and 'int' can only be used in ghost code (e.g., in a 'spec' or 'proof' function, inside a 'proof' block, or when assigning to a 'ghost' or 'tracked' variable) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpnbd62ngu", "lines": [146, 146], "label": null, "text": [{"text": "    Seq::new(3 as nat, |i: nat| match i {", "highlight_start": 14, "highlight_end": 22}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 159, "minimized_LOC": 159, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn can_partition_into_equal_sum_segments(input: Seq<char>) -> bool {\n\nspec fn can_partition_remainder(digits: Seq<int>, start: int, target_sum: int) -> bool \n    decreases digits.len() - start\n{\n\nspec fn sum(s: Seq<int>) -> int {\n\nspec fn parse_int(s: Seq<char>) -> int {\n\nspec fn char_to_digit(c: char) -> int {\n\nspec fn power10(n: int) -> int {\n\nspec fn parse_digits(s: Seq<char>) -> Seq<int> {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n\nspec fn trim_left(s: Seq<char>) -> Seq<char> {\n\nspec fn trim_right(s: Seq<char>) -> Seq<char> {\n\n    decreases digits.len() - start\n\n    requires s.len() > 0"}}}, "all_snapshots": []}
{"id": "apps_test_1448_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && \n    valid_first_line(lines[0]) &&\n    valid_second_line(lines[1]) &&\n    valid_grasshopper_lines_simple(lines) &&\n    ({\n        let first_line = split_spaces(lines[0]);\n        let n = string_to_int(first_line[0]);\n        let d = string_to_int(first_line[1]);\n        let m = string_to_int(lines[1]);\n        d >= 1 && d < n && n <= 100 &&\n        m >= 1 && m <= 100 &&\n        lines.len() >= 2 + m &&\n        forall|i: int| #[trigger] valid_grasshopper_line(lines[2 + i], n) && 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)\n    })\n}\n\nspec fn valid_first_line(line: Seq<char>) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])\n}\n\nspec fn valid_second_line(line: Seq<char>) -> bool {\n    is_valid_integer(line)\n}\n\nspec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 3 &&\n    ({\n        let m = string_to_int(lines[1]);\n        lines.len() >= 2 + m\n    })\n}\n\nspec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&\n    string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&\n    string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[0])\n}\n\nspec fn get_d(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[1])\n}\n\nspec fn get_number_of_grasshoppers(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    string_to_int(lines[1])\n}\n\nspec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {\n    let lines = split_lines(input);\n    let coords = split_spaces(lines[2 + i]);\n    (string_to_int(coords[0]), string_to_int(coords[1]))\n}\n\nspec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {\n    let (x, y) = grasshopper;\n    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d\n}\n\n/* Helper functions for string processing */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: Vec<String>)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && \n    valid_first_line(lines[0]) &&\n    valid_second_line(lines[1]) &&\n    valid_grasshopper_lines_simple(lines) &&\n    ({\n        let first_line = split_spaces(lines[0]);\n        let n = string_to_int(first_line[0]);\n        let d = string_to_int(first_line[1]);\n        let m = string_to_int(lines[1]);\n        d >= 1 && d < n && n <= 100 &&\n        m >= 1 && m <= 100 &&\n        lines.len() >= 2 + m &&\n        forall|i: int| #[trigger] valid_grasshopper_line(lines[2 + i], n) && 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)\n    })\n}\n\nspec fn valid_first_line(line: Seq<char>) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])\n}\n\nspec fn valid_second_line(line: Seq<char>) -> bool {\n    is_valid_integer(line)\n}\n\nspec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 3 &&\n    ({\n        let m = string_to_int(lines[1]);\n        lines.len() >= 2 + m\n    })\n}\n\nspec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&\n    string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&\n    string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[0])\n}\n\nspec fn get_d(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[1])\n}\n\nspec fn get_number_of_grasshoppers(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    string_to_int(lines[1])\n}\n\nspec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {\n    let lines = split_lines(input);\n    let coords = split_spaces(lines[2 + i]);\n    (string_to_int(coords[0]), string_to_int(coords[1]))\n}\n\nspec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {\n    let (x, y) = grasshopper;\n    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d\n}\n\n/* Helper functions for string processing */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: Vec<String>)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1448.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 857, "minimize_time_ms": 122328, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 112, "minimized_LOC": 112, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_first_line(line: Seq<char>) -> bool {\n\nspec fn valid_second_line(line: Seq<char>) -> bool {\n\nspec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {\n\nspec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn get_n(input: Seq<char>) -> int {\n\nspec fn get_d(input: Seq<char>) -> int {\n\nspec fn get_number_of_grasshoppers(input: Seq<char>) -> int {\n\nspec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {\n\nspec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && \n    valid_first_line(lines[0]) &&\n    valid_second_line(lines[1]) &&\n    valid_grasshopper_lines_simple(lines) &&\n    ({\n        let first_line = split_spaces(lines[0]);\n        let n = string_to_int(first_line[0]);\n        let d = string_to_int(first_line[1]);\n        let m = string_to_int(lines[1]);\n        d >= 1 && d < n && n <= 100 &&\n        m >= 1 && m <= 100 &&\n        lines.len() >= 2 + m &&\n        forall|i: int| #[trigger] valid_grasshopper_line(lines[2 + i], n) && 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)\n    })\n}\n\nspec fn valid_first_line(line: Seq<char>) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])\n}\n\nspec fn valid_second_line(line: Seq<char>) -> bool {\n    is_valid_integer(line)\n}\n\nspec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 3 &&\n    ({\n        let m = string_to_int(lines[1]);\n        lines.len() >= 2 + m\n    })\n}\n\nspec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&\n    string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&\n    string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[0])\n}\n\nspec fn get_d(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[1])\n}\n\nspec fn get_number_of_grasshoppers(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    string_to_int(lines[1])\n}\n\nspec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {\n    let lines = split_lines(input);\n    let coords = split_spaces(lines[2 + i]);\n    (string_to_int(coords[0]), string_to_int(coords[1]))\n}\n\nspec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {\n    let (x, y) = grasshopper;\n    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d\n}\n\n/* Helper functions for string processing */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: Vec<String>)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1512_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_permutation(p: Seq<int>, n: int) -> bool {\n  p.len() == n && n >= 1 &&\n  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&\n  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn count_records(s: Seq<int>) -> int {\n  if s.len() == 0 { 0 }\n  else { 1 + count_records_from_index(s, 1, s[0]) }\n}\n\nspec fn count_records_after_removal(p: Seq<int>, to_remove: int) -> int {\n  let filtered = Seq::new((p.len() - 1) as nat, |i: int| \n    if index_of(p, to_remove) <= i { p[i + 1] } else { p[i] });\n  count_records(filtered)\n}\nspec fn count_records_from_index(s: Seq<int>, idx: int, max_so_far: int) -> int\n  decreases s.len() - idx\n{\n  if idx >= s.len() { 0 }\n  else if s[idx] > max_so_far { \n    1 + count_records_from_index(s, idx + 1, s[idx])\n  } else { \n    count_records_from_index(s, idx + 1, max_so_far)\n  }\n}\n\nspec fn index_of(s: Seq<int>, elem: int) -> int {\n  choose|i: int| 0 <= i < s.len() && s[i] == elem\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: Vec<i8>) -> (result: i8)\n  requires \n    valid_permutation(p@.map(|i, x: i8| x as int), n as int)\n  ensures \n    1 <= result as int <= n as int,\n    p@.map(|i, x: i8| x as int).contains(result as int),\n    {\n      let p_int = p@.map(|i, x: i8| x as int);\n      forall|x: int| p_int.contains(x) ==> count_records_after_removal(p_int, result as int) >= count_records_after_removal(p_int, x)\n    },\n    {\n      let p_int = p@.map(|i, x: i8| x as int);\n      forall|x: int| p_int.contains(x) && count_records_after_removal(p_int, x) == count_records_after_removal(p_int, result as int) ==> result as int <= x\n    }\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_permutation(p: Seq<int>, n: int) -> bool {\n  p.len() == n && n >= 1 &&\n  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&\n  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn count_records(s: Seq<int>) -> int {\n  if s.len() == 0 { 0 }\n  else { 1 + count_records_from_index(s, 1, s[0]) }\n}\n\nspec fn count_records_after_removal(p: Seq<int>, to_remove: int) -> int {\n  let filtered = Seq::new((p.len() - 1) as nat, |i: int| \n    if index_of(p, to_remove) <= i { p[i + 1] } else { p[i] });\n  count_records(filtered)\n}\nspec fn count_records_from_index(s: Seq<int>, idx: int, max_so_far: int) -> int\n  decreases s.len() - idx\n{\n  if idx >= s.len() { 0 }\n  else if s[idx] > max_so_far { \n    1 + count_records_from_index(s, idx + 1, s[idx])\n  } else { \n    count_records_from_index(s, idx + 1, max_so_far)\n  }\n}\n\nspec fn index_of(s: Seq<int>, elem: int) -> int {\n  choose|i: int| 0 <= i < s.len() && s[i] == elem\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: Vec<i8>) -> (result: i8)\n  requires \n    valid_permutation(p@.map(|i, x: i8| x as int), n as int)\n  ensures \n    1 <= result as int <= n as int,\n    p@.map(|i, x: i8| x as int).contains(result as int),\n    {\n      let p_int = p@.map(|i, x: i8| x as int);\n      forall|x: int| p_int.contains(x) ==> count_records_after_removal(p_int, result as int) >= count_records_after_removal(p_int, x)\n    },\n    {\n      let p_int = p@.map(|i, x: i8| x as int);\n      forall|x: int| p_int.contains(x) && count_records_after_removal(p_int, x) == count_records_after_removal(p_int, result as int) ==> result as int <= x\n    }\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1512.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 244, "verus_errors": [{"error_type": "Other", "error_text": "This block would be parsed as the function/loop body, but it is followed immediately by a comma (if you meant this block to be part of the specification, try parenthesizing it) ()", "message": "VerusErrorType.Other: This block would be parsed as the function/loop body, but it is followed immediately by a comma (if you meant this block to be part of the specification, try parenthesizing it) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpwkm_9aly", "lines": [48, 51], "label": null, "text": [{"text": "    {", "highlight_start": 5, "highlight_end": 6}, {"text": "      let p_int = p@.map(|i, x: i8| x as int);", "highlight_start": 1, "highlight_end": 47}, {"text": "      forall|x: int| p_int.contains(x) ==> count_records_after_removal(p_int, result as int) >= count_records_after_removal(p_int, x)", "highlight_start": 1, "highlight_end": 134}, {"text": "    },", "highlight_start": 1, "highlight_end": 6}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_permutation(p: Seq<int>, n: int) -> bool {\n\nspec fn count_records(s: Seq<int>) -> int {\n\nspec fn count_records_after_removal(p: Seq<int>, to_remove: int) -> int {\n\nspec fn count_records_from_index(s: Seq<int>, idx: int, max_so_far: int) -> int\n  decreases s.len() - idx\n{\n\nspec fn index_of(s: Seq<int>, elem: int) -> int {\n\n  decreases s.len() - idx\n\n  requires \n\n  ensures "}}}, "all_snapshots": []}
{"id": "apps_test_1547_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 && split_string(&lines[0], ' ').len() == 3 &&\n    {\n        let n = string_to_int(&split_string(&lines[0], ' ')[0]);\n        let m = string_to_int(&split_string(&lines[0], ' ')[1]);\n        let k = string_to_int(&split_string(&lines[0], ' ')[2]);\n        n > 0 && m > 0 && k >= 0 && lines.len() >= k + 1\n    }\n}\n\nspec fn get_dimensions(input: &str) -> (int, int, int)\n{\n    let lines = split_lines(input);\n    let first_line = split_string(&lines[0], ' ');\n    (string_to_int(&first_line[0]), string_to_int(&first_line[1]), string_to_int(&first_line[2]))\n}\n\nspec fn compute_grid(lines: Seq<String>, n: int, m: int, k: int) -> Seq<Seq<int>>\n{\n    let row = Seq::new(n as nat, |i: int| (0, -1));\n    let col = Seq::new(m as nat, |i: int| (0, -1));\n    let processed_arrays = process_operations(lines, n, m, k, 0, row, col);\n    build_grid(n, m, processed_arrays.0, processed_arrays.1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n/* Helper functions would be defined here */\nspec fn split_lines(input: &str) -> Seq<String> {\n    Seq::empty()\n}\n\nspec fn split_string(s: &str, delimiter: char) -> Seq<String> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: &str) -> int {\n    0\n}\n\nspec fn process_operations(lines: Seq<String>, n: int, m: int, k: int, index: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> (Seq<(int, int)>, Seq<(int, int)>) {\n    (Seq::empty(), Seq::empty())\n}\n\nspec fn build_grid(n: int, m: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> Seq<Seq<int>> {\n    Seq::empty()\n}\n\nspec fn format_grid(grid: Seq<Seq<int>>) -> String {\n    \"\".to_string()\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures !valid_input(input) ==> result@ == \"\"@\n    ensures valid_input(input) ==> (\n        let (n, m, k) = get_dimensions(input);\n        let lines = split_lines(input);\n        result == format_grid(compute_grid(lines, n, m, k))\n    )\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 && split_string(&lines[0], ' ').len() == 3 &&\n    {\n        let n = string_to_int(&split_string(&lines[0], ' ')[0]);\n        let m = string_to_int(&split_string(&lines[0], ' ')[1]);\n        let k = string_to_int(&split_string(&lines[0], ' ')[2]);\n        n > 0 && m > 0 && k >= 0 && lines.len() >= k + 1\n    }\n}\n\nspec fn get_dimensions(input: &str) -> (int, int, int)\n{\n    let lines = split_lines(input);\n    let first_line = split_string(&lines[0], ' ');\n    (string_to_int(&first_line[0]), string_to_int(&first_line[1]), string_to_int(&first_line[2]))\n}\n\nspec fn compute_grid(lines: Seq<String>, n: int, m: int, k: int) -> Seq<Seq<int>>\n{\n    let row = Seq::new(n as nat, |i: int| (0, -1));\n    let col = Seq::new(m as nat, |i: int| (0, -1));\n    let processed_arrays = process_operations(lines, n, m, k, 0, row, col);\n    build_grid(n, m, processed_arrays.0, processed_arrays.1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n/* Helper functions would be defined here */\nspec fn split_lines(input: &str) -> Seq<String> {\n    Seq::empty()\n}\n\nspec fn split_string(s: &str, delimiter: char) -> Seq<String> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: &str) -> int {\n    0\n}\n\nspec fn process_operations(lines: Seq<String>, n: int, m: int, k: int, index: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> (Seq<(int, int)>, Seq<(int, int)>) {\n    (Seq::empty(), Seq::empty())\n}\n\nspec fn build_grid(n: int, m: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> Seq<Seq<int>> {\n    Seq::empty()\n}\n\nspec fn format_grid(grid: Seq<Seq<int>>) -> String {\n    \"\".to_string()\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures !valid_input(input) ==> result@ == \"\"@\n    ensures valid_input(input) ==> (\n        let (n, m, k) = get_dimensions(input);\n        let lines = split_lines(input);\n        result == format_grid(compute_grid(lines, n, m, k))\n    )\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1547.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 193, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpptwndyn1", "lines": [64, 64], "label": null, "text": [{"text": "    ensures valid_input(input) ==> (", "highlight_start": 5, "highlight_end": 12}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 80, "minimized_LOC": 80, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: &str) -> bool {\n\nspec fn get_dimensions(input: &str) -> (int, int, int)\n{\n\nspec fn compute_grid(lines: Seq<String>, n: int, m: int, k: int) -> Seq<Seq<int>>\n{\n\nspec fn split_lines(input: &str) -> Seq<String> {\n\nspec fn split_string(s: &str, delimiter: char) -> Seq<String> {\n\nspec fn string_to_int(s: &str) -> int {\n\nspec fn process_operations(lines: Seq<String>, n: int, m: int, k: int, index: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> (Seq<(int, int)>, Seq<(int, int)>) {\n\nspec fn build_grid(n: int, m: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> Seq<Seq<int>> {\n\nspec fn format_grid(grid: Seq<Seq<int>>) -> String {\n\n    requires input.len() > 0\n\n    ensures !valid_input(input) ==> result@ == \"\"@\n\n    ensures valid_input(input) ==> ("}}}, "all_snapshots": []}
{"id": "apps_test_155_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n    n >= 2 && m >= 2 && n % 2 == 0 && k >= 0 && k < n * m\n}\n\nspec fn valid_output(result: &Vec<int>, n: int, m: int) -> bool {\n    result.len() == 2 && result[0] >= 1 && result[0] <= n && result[1] >= 1 && result[1] <= m\n}\n\nspec fn correct_position(result: &Vec<int>, n: int, m: int, k: int) -> bool\n    recommends valid_input(n, m, k) && result.len() == 2\n{\n    if k < n {\n        result[0] == k + 1 && result[1] == 1\n    } else {\n        let k_remaining = k - n;\n        let r = n - k_remaining / (m - 1);\n        result[0] == r &&\n        (r % 2 == 1 ==> result[1] == m - k_remaining % (m - 1)) &&\n        (r % 2 == 0 ==> result[1] == 2 + k_remaining % (m - 1))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8) -> (result: Vec<i8>)\n    requires\n        valid_input(n as int, m as int, k as int)\n    ensures\n        result.len() == 2,\n        {\n            let spec_result: Vec<int> = result@.map(|i, x: i8| x as int);\n            valid_output(&spec_result, n as int, m as int) && correct_position(&spec_result, n as int, m as int, k as int)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n    n >= 2 && m >= 2 && n % 2 == 0 && k >= 0 && k < n * m\n}\n\nspec fn valid_output(result: &Vec<int>, n: int, m: int) -> bool {\n    result.len() == 2 && result[0] >= 1 && result[0] <= n && result[1] >= 1 && result[1] <= m\n}\n\nspec fn correct_position(result: &Vec<int>, n: int, m: int, k: int) -> bool\n    recommends valid_input(n, m, k) && result.len() == 2\n{\n    if k < n {\n        result[0] == k + 1 && result[1] == 1\n    } else {\n        let k_remaining = k - n;\n        let r = n - k_remaining / (m - 1);\n        result[0] == r &&\n        (r % 2 == 1 ==> result[1] == m - k_remaining % (m - 1)) &&\n        (r % 2 == 0 ==> result[1] == 2 + k_remaining % (m - 1))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8) -> (result: Vec<i8>)\n    requires\n        valid_input(n as int, m as int, k as int)\n    ensures\n        result.len() == 2,\n        {\n            let spec_result: Vec<int> = result@.map(|i, x: i8| x as int);\n            valid_output(&spec_result, n as int, m as int) && correct_position(&spec_result, n as int, m as int, k as int)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_155.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 354, "verus_errors": [{"error_type": "Other", "error_text": "This block would be parsed as the function/loop body, but it is followed immediately by another block (if you meant this block to be part of the specification, try parenthesizing it) ()", "message": "VerusErrorType.Other: This block would be parsed as the function/loop body, but it is followed immediately by another block (if you meant this block to be part of the specification, try parenthesizing it) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp8ljhhnhn", "lines": [37, 40], "label": null, "text": [{"text": "        {", "highlight_start": 9, "highlight_end": 10}, {"text": "            let spec_result: Vec<int> = result@.map(|i, x: i8| x as int);", "highlight_start": 1, "highlight_end": 74}, {"text": "            valid_output(&spec_result, n as int, m as int) && correct_position(&spec_result, n as int, m as int, k as int)", "highlight_start": 1, "highlight_end": 123}, {"text": "        }", "highlight_start": 1, "highlight_end": 10}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, k: int) -> bool {\n\nspec fn valid_output(result: &Vec<int>, n: int, m: int) -> bool {\n\nspec fn correct_position(result: &Vec<int>, n: int, m: int, k: int) -> bool\n    recommends valid_input(n, m, k) && result.len() == 2\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_1615_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input_format(s: Seq<u8>) -> bool {\n    let lines = split_lines(s);\n    lines.len() >= 1 &&\n    exists|n: nat, k: nat| \n        parses_as_integers_pair(lines[0], n as int, k as int) && n > 0 && k > 0 && lines.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i] == lines[i] && \n            exists|a: int, b: int| parses_as_integers_pair(lines[i], a, b)\n}\n\nspec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= n + 1 && segments.len() == n &&\n    parses_as_integers_pair(lines[0], n as int, k as int) &&\n    forall|i: int| 0 <= i < n && i + 1 < lines.len() ==> #[trigger] segments[i] == segments[i] && \n        parses_as_integers_pair(lines[i + 1], segments[i].0, segments[i].1)\n}\n\nspec fn is_valid_output(s: Seq<u8>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == 10u8 && \n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] == s[i] && s[i] != 10u8 &&\n    is_numeric_output(s.subrange(0, s.len() - 1))\n}\n\nspec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat\n    recommends k > 0\n{\n    let total_coverage = total_coverage(segments);\n    let remainder = total_coverage % k;\n    if remainder == 0 { 0 } else { (k - remainder) as nat }\n}\n\nspec fn total_coverage(segments: Seq<(int, int)>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { \n        0 \n    } else { \n        segment_length(segments[0]) + total_coverage(segments.subrange(1, segments.len() as int))\n    }\n}\n\nspec fn segment_length(segment: (int, int)) -> nat {\n    let max_val = if segment.0 >= segment.1 { segment.0 } else { segment.1 };\n    let min_val = if segment.0 <= segment.1 { segment.0 } else { segment.1 };\n    if max_val >= min_val { (max_val - min_val + 1) as nat } else { 1 }\n}\n\n/* Helper functions that would need to be implemented */\nspec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {\n    seq![seq![]]\n}\n\nspec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {\n    true\n}\n\nspec fn is_numeric_output(s: Seq<u8>) -> bool {\n    true\n}\n\nspec fn contains_newline(s: Seq<u8>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == 10u8\n}\n\nspec fn int_to_string(n: nat) -> Seq<u8> {\n    seq![48u8]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == 10u8 || !contains_newline(stdin_input@),\n    ensures\n        result.len() == 0 || result[result.len() - 1] == 10u8,\n        valid_input_format(stdin_input@) ==> \n            exists|n: nat, k: nat, segments: Seq<(int, int)>|\n                n > 0 && k > 0 && segments.len() == n &&\n                parsed_correctly(stdin_input@, n, k, segments) &&\n                result@ == int_to_string(min_moves_to_divisible(segments, k)).add(seq![10u8]),\n        valid_input_format(stdin_input@) ==> is_valid_output(result@),\n        !valid_input_format(stdin_input@) ==> \n            (result.len() == 0 || (result.len() > 0 && result[result.len() - 1] == 10u8)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input_format(s: Seq<u8>) -> bool {\n    let lines = split_lines(s);\n    lines.len() >= 1 &&\n    exists|n: nat, k: nat| \n        parses_as_integers_pair(lines[0], n as int, k as int) && n > 0 && k > 0 && lines.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i] == lines[i] && \n            exists|a: int, b: int| parses_as_integers_pair(lines[i], a, b)\n}\n\nspec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= n + 1 && segments.len() == n &&\n    parses_as_integers_pair(lines[0], n as int, k as int) &&\n    forall|i: int| 0 <= i < n && i + 1 < lines.len() ==> #[trigger] segments[i] == segments[i] && \n        parses_as_integers_pair(lines[i + 1], segments[i].0, segments[i].1)\n}\n\nspec fn is_valid_output(s: Seq<u8>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == 10u8 && \n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] == s[i] && s[i] != 10u8 &&\n    is_numeric_output(s.subrange(0, s.len() - 1))\n}\n\nspec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat\n    recommends k > 0\n{\n    let total_coverage = total_coverage(segments);\n    let remainder = total_coverage % k;\n    if remainder == 0 { 0 } else { (k - remainder) as nat }\n}\n\nspec fn total_coverage(segments: Seq<(int, int)>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { \n        0 \n    } else { \n        segment_length(segments[0]) + total_coverage(segments.subrange(1, segments.len() as int))\n    }\n}\n\nspec fn segment_length(segment: (int, int)) -> nat {\n    let max_val = if segment.0 >= segment.1 { segment.0 } else { segment.1 };\n    let min_val = if segment.0 <= segment.1 { segment.0 } else { segment.1 };\n    if max_val >= min_val { (max_val - min_val + 1) as nat } else { 1 }\n}\n\n/* Helper functions that would need to be implemented */\nspec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {\n    seq![seq![]]\n}\n\nspec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {\n    true\n}\n\nspec fn is_numeric_output(s: Seq<u8>) -> bool {\n    true\n}\n\nspec fn contains_newline(s: Seq<u8>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == 10u8\n}\n\nspec fn int_to_string(n: nat) -> Seq<u8> {\n    seq![48u8]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == 10u8 || !contains_newline(stdin_input@),\n    ensures\n        result.len() == 0 || result[result.len() - 1] == 10u8,\n        valid_input_format(stdin_input@) ==> \n            exists|n: nat, k: nat, segments: Seq<(int, int)>|\n                n > 0 && k > 0 && segments.len() == n &&\n                parsed_correctly(stdin_input@, n, k, segments) &&\n                result@ == int_to_string(min_moves_to_divisible(segments, k)).add(seq![10u8]),\n        valid_input_format(stdin_input@) ==> is_valid_output(result@),\n        !valid_input_format(stdin_input@) ==> \n            (result.len() == 0 || (result.len() > 0 && result[result.len() - 1] == 10u8)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1615.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 970, "minimize_time_ms": 123226, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 103, "minimized_LOC": 103, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(s: Seq<u8>) -> bool {\n\nspec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {\n\nspec fn is_valid_output(s: Seq<u8>) -> bool {\n\nspec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat\n    recommends k > 0\n{\n\nspec fn total_coverage(segments: Seq<(int, int)>) -> nat\n    decreases segments.len()\n{\n\nspec fn segment_length(segment: (int, int)) -> nat {\n\nspec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {\n\nspec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {\n\nspec fn is_numeric_output(s: Seq<u8>) -> bool {\n\nspec fn contains_newline(s: Seq<u8>) -> bool {\n\nspec fn int_to_string(n: nat) -> Seq<u8> {\n\n    decreases segments.len()\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input_format(s: Seq<u8>) -> bool {\n    let lines = split_lines(s);\n    lines.len() >= 1 &&\n    exists|n: nat, k: nat| \n        parses_as_integers_pair(lines[0], n as int, k as int) && n > 0 && k > 0 && lines.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i] == lines[i] && \n            exists|a: int, b: int| parses_as_integers_pair(lines[i], a, b)\n}\n\nspec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= n + 1 && segments.len() == n &&\n    parses_as_integers_pair(lines[0], n as int, k as int) &&\n    forall|i: int| 0 <= i < n && i + 1 < lines.len() ==> #[trigger] segments[i] == segments[i] && \n        parses_as_integers_pair(lines[i + 1], segments[i].0, segments[i].1)\n}\n\nspec fn is_valid_output(s: Seq<u8>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == 10u8 && \n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] == s[i] && s[i] != 10u8 &&\n    is_numeric_output(s.subrange(0, s.len() - 1))\n}\n\nspec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat\n    recommends k > 0\n{\n    let total_coverage = total_coverage(segments);\n    let remainder = total_coverage % k;\n    if remainder == 0 { 0 } else { (k - remainder) as nat }\n}\n\nspec fn total_coverage(segments: Seq<(int, int)>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { \n        0 \n    } else { \n        segment_length(segments[0]) + total_coverage(segments.subrange(1, segments.len() as int))\n    }\n}\n\nspec fn segment_length(segment: (int, int)) -> nat {\n    let max_val = if segment.0 >= segment.1 { segment.0 } else { segment.1 };\n    let min_val = if segment.0 <= segment.1 { segment.0 } else { segment.1 };\n    if max_val >= min_val { (max_val - min_val + 1) as nat } else { 1 }\n}\n\n/* Helper functions that would need to be implemented */\nspec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {\n    seq![seq![]]\n}\n\nspec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {\n    true\n}\n\nspec fn is_numeric_output(s: Seq<u8>) -> bool {\n    true\n}\n\nspec fn contains_newline(s: Seq<u8>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == 10u8\n}\n\nspec fn int_to_string(n: nat) -> Seq<u8> {\n    seq![48u8]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == 10u8 || !contains_newline(stdin_input@),\n    ensures\n        result.len() == 0 || result[result.len() - 1] == 10u8,\n        valid_input_format(stdin_input@) ==> \n            exists|n: nat, k: nat, segments: Seq<(int, int)>|\n                n > 0 && k > 0 && segments.len() == n &&\n                parsed_correctly(stdin_input@, n, k, segments) &&\n                result@ == int_to_string(min_moves_to_divisible(segments, k)).add(seq![10u8]),\n        valid_input_format(stdin_input@) ==> is_valid_output(result@),\n        !valid_input_format(stdin_input@) ==> \n            (result.len() == 0 || (result.len() > 0 && result[result.len() - 1] == 10u8)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n           fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_162_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && a.len() == n &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1) &&\n    (exists|i: int| 0 <= i < a.len() && k % a[i] == 0)\n}\n\nspec fn valid_bucket(k: int, bucket_size: int) -> bool {\n    bucket_size >= 1 && k % bucket_size == 0\n}\n\nspec fn hours_needed(k: int, bucket_size: int) -> int\n    recommends valid_bucket(k, bucket_size)\n{\n    k / bucket_size\n}\n\nspec fn is_optimal_choice(k: int, a: Seq<int>, chosen_bucket: int) -> bool {\n    0 <= chosen_bucket < a.len() &&\n    valid_bucket(k, a[chosen_bucket]) &&\n    (forall|i: int| 0 <= i < a.len() && valid_bucket(k, a[i]) ==> a[i] <= a[chosen_bucket])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, a@.map(|i, x| x as int)),\n    ensures \n        result >= 1,\n        #[trigger] exists|i: int| is_optimal_choice(k as int, a@.map(|i, x| x as int), i) && result as int == hours_needed(k as int, a@.map(|i, x| x as int)[i]),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && a.len() == n &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1) &&\n    (exists|i: int| 0 <= i < a.len() && k % a[i] == 0)\n}\n\nspec fn valid_bucket(k: int, bucket_size: int) -> bool {\n    bucket_size >= 1 && k % bucket_size == 0\n}\n\nspec fn hours_needed(k: int, bucket_size: int) -> int\n    recommends valid_bucket(k, bucket_size)\n{\n    k / bucket_size\n}\n\nspec fn is_optimal_choice(k: int, a: Seq<int>, chosen_bucket: int) -> bool {\n    0 <= chosen_bucket < a.len() &&\n    valid_bucket(k, a[chosen_bucket]) &&\n    (forall|i: int| 0 <= i < a.len() && valid_bucket(k, a[i]) ==> a[i] <= a[chosen_bucket])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, a@.map(|i, x| x as int)),\n    ensures \n        result >= 1,\n        #[trigger] exists|i: int| is_optimal_choice(k as int, a@.map(|i, x| x as int), i) && result as int == hours_needed(k as int, a@.map(|i, x| x as int)[i]),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_162.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 260, "verus_errors": [{"error_type": "Other", "error_text": "cannot find attribute `trigger` in this scope ()", "message": "VerusErrorType.Other: cannot find attribute `trigger` in this scope ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpg51ew1f7", "lines": [37, 37], "label": null, "text": [{"text": "        #[trigger] exists|i: int| is_optimal_choice(k as int, a@.map(|i, x| x as int), i) && result as int == hours_needed(k as int, a@.map(|i, x| x as int)[i]),", "highlight_start": 11, "highlight_end": 18}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n\nspec fn valid_bucket(k: int, bucket_size: int) -> bool {\n\nspec fn hours_needed(k: int, bucket_size: int) -> int\n    recommends valid_bucket(k, bucket_size)\n{\n\nspec fn is_optimal_choice(k: int, a: Seq<int>, chosen_bucket: int) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_163_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {\n    n >= 2 &&\n    1 <= k < n &&\n    s.len() == n &&\n    (exists|i: int| 0 <= i < s.len() && s[i] == 'G') &&\n    (exists|i: int| 0 <= i < s.len() && s[i] == 'T') &&\n    (forall|i: int| 0 <= i < s.len() ==> (s[i] == 'G' || s[i] == 'T' || s[i] == '.' || s[i] == '#')) &&\n    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'G' ==> s[j] != 'G') &&\n    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'T' ==> s[j] != 'T')\n}\n\nspec fn find_first_g_or_t(s: Seq<char>) -> int\n    recommends exists|i: int| 0 <= i < s.len() && (s[i] == 'G' || s[i] == 'T')\n    decreases s.len()\n{\n    if s.len() > 0 && (s[0] == 'G' || s[0] == 'T') {\n        0\n    } else if s.len() > 1 {\n        find_first_g_or_t(s.subrange(1, s.len() as int)) + 1\n    } else {\n        0\n    }\n}\n\nspec fn can_reach_target(s: Seq<char>, k: int) -> bool\n    recommends k > 0\n{\n    exists|start: int| \n        0 <= start < s.len() && \n        (s[start] == 'G' || s[start] == 'T') &&\n        (forall|j: int| 0 <= j < start ==> !(s[j] == 'G' || s[j] == 'T')) &&\n        (exists|final_pos: int| \n            start < final_pos < s.len() &&\n            (s[final_pos] == 'G' || s[final_pos] == 'T') &&\n            (final_pos - start) % k == 0 &&\n            (forall|pos: int| start < pos < final_pos && (pos - start) % k == 0 ==> !(s[pos] == 'G' || s[pos] == 'T' || s[pos] == '#'))\n        )\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, k: int, s: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(n, k, s)\n    ensures \n        result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O'],\n        (result == seq!['Y', 'E', 'S']) <==> can_reach_target(s, k)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    seq!['N', 'O']\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {\n    n >= 2 &&\n    1 <= k < n &&\n    s.len() == n &&\n    (exists|i: int| 0 <= i < s.len() && s[i] == 'G') &&\n    (exists|i: int| 0 <= i < s.len() && s[i] == 'T') &&\n    (forall|i: int| 0 <= i < s.len() ==> (s[i] == 'G' || s[i] == 'T' || s[i] == '.' || s[i] == '#')) &&\n    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'G' ==> s[j] != 'G') &&\n    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'T' ==> s[j] != 'T')\n}\n\nspec fn find_first_g_or_t(s: Seq<char>) -> int\n    recommends exists|i: int| 0 <= i < s.len() && (s[i] == 'G' || s[i] == 'T')\n    decreases s.len()\n{\n    if s.len() > 0 && (s[0] == 'G' || s[0] == 'T') {\n        0\n    } else if s.len() > 1 {\n        find_first_g_or_t(s.subrange(1, s.len() as int)) + 1\n    } else {\n        0\n    }\n}\n\nspec fn can_reach_target(s: Seq<char>, k: int) -> bool\n    recommends k > 0\n{\n    exists|start: int| \n        0 <= start < s.len() && \n        (s[start] == 'G' || s[start] == 'T') &&\n        (forall|j: int| 0 <= j < start ==> !(s[j] == 'G' || s[j] == 'T')) &&\n        (exists|final_pos: int| \n            start < final_pos < s.len() &&\n            (s[final_pos] == 'G' || s[final_pos] == 'T') &&\n            (final_pos - start) % k == 0 &&\n            (forall|pos: int| start < pos < final_pos && (pos - start) % k == 0 ==> !(s[pos] == 'G' || s[pos] == 'T' || s[pos] == '#'))\n        )\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, k: int, s: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(n, k, s)\n    ensures \n        result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O'],\n        (result == seq!['Y', 'E', 'S']) <==> can_reach_target(s, k)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    seq!['N', 'O']\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_163.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 741, "verus_errors": [{"error_type": "CannotCallFunc", "error_text": "cannot call function `vstd::view::View::view` with mode spec ()", "message": "VerusErrorType.CannotCallFunc: cannot call function `vstd::view::View::view` with mode spec ()", "spans": [{"file_name": "/Users/runner/work/verus/verus/source/vstd/seq.rs", "lines": [521, 521], "label": null, "text": []}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 65, "minimized_LOC": 65, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {\n\nspec fn find_first_g_or_t(s: Seq<char>) -> int\n    recommends exists|i: int| 0 <= i < s.len() && (s[i] == 'G' || s[i] == 'T')\n    decreases s.len()\n{\n\nspec fn can_reach_target(s: Seq<char>, k: int) -> bool\n    recommends k > 0\n{\n\n    decreases s.len()\n\n    requires valid_input(n, k, s)\n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_1631_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>, n: int) -> bool {\n    exists|lines: Seq<Seq<char>>| (parse_input(stdin_input) == lines &&\n    lines.len() >= 1 &&\n    lines.len() == n + 1 &&\n    parse_int(lines[0]) == n &&\n    n >= 1 && n <= 100 &&\n    (forall|i: int| 1 <= i < lines.len() ==> \n        1 <= lines[i].len() <= 100 && \n        forall|j: int| 0 <= j < lines[i].len() ==> 'a' <= lines[i][j] <= 'z'))\n}\n\nspec fn valid_alphabet_ordering(stdin_input: Seq<char>, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]\n{\n    exists|lines: Seq<Seq<char>>, n: int| (parse_input(stdin_input) == lines &&\n    lines.len() >= 1 &&\n    lines.len() == n + 1 &&\n    parse_int(lines[0]) == n &&\n    (forall|i: int| 1 <= i < n ==> lexicographically_less_or_equal(lines[i], lines[i+1], alphabet)))\n}\n\nspec fn lexicographically_less_or_equal(s1: Seq<char>, s2: Seq<char>, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]\n{\n    if s1 == s2 {\n        true\n    } else if s1.len() <= s2.len() && s1 == s2.subrange(0, s1.len() as int) {\n        true\n    } else if s2.len() < s1.len() && s2 == s1.subrange(0, s2.len() as int) {\n        false\n    } else {\n        exists|i: int| (0 <= i < s1.len() && i < s2.len() && s1[i] != s2[i] &&\n        (forall|j: int| 0 <= j < i ==> s1[j] == s2[j]) &&\n        'a' <= s1[i] <= 'z' && 'a' <= s2[i] <= 'z' &&\n        alphabet_order(s1[i], s2[i], alphabet))\n    }\n}\n\nspec fn alphabet_order(c1: char, c2: char, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j],\n              'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'\n{\n    exists|i: int, j: int| 0 <= i < j < alphabet.len() && alphabet[i] == c1 && alphabet[j] == c2\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::<Seq<char>>::empty()\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n{\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        exists|n: int| n >= 1 && valid_input(stdin_input@, n),\n    ensures\n        result@ == \"Impossible\"@ || (result@.len() == 26 && forall|i: int| 0 <= i < result@.len() ==> 'a' <= result@[i] <= 'z'),\n        result@ != \"Impossible\"@ ==> (forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] != result@[j]),\n        result@ != \"Impossible\"@ ==> valid_alphabet_ordering(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"Impossible\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>, n: int) -> bool {\n    exists|lines: Seq<Seq<char>>| (parse_input(stdin_input) == lines &&\n    lines.len() >= 1 &&\n    lines.len() == n + 1 &&\n    parse_int(lines[0]) == n &&\n    n >= 1 && n <= 100 &&\n    (forall|i: int| 1 <= i < lines.len() ==> \n        1 <= lines[i].len() <= 100 && \n        forall|j: int| 0 <= j < lines[i].len() ==> 'a' <= lines[i][j] <= 'z'))\n}\n\nspec fn valid_alphabet_ordering(stdin_input: Seq<char>, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]\n{\n    exists|lines: Seq<Seq<char>>, n: int| (parse_input(stdin_input) == lines &&\n    lines.len() >= 1 &&\n    lines.len() == n + 1 &&\n    parse_int(lines[0]) == n &&\n    (forall|i: int| 1 <= i < n ==> lexicographically_less_or_equal(lines[i], lines[i+1], alphabet)))\n}\n\nspec fn lexicographically_less_or_equal(s1: Seq<char>, s2: Seq<char>, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]\n{\n    if s1 == s2 {\n        true\n    } else if s1.len() <= s2.len() && s1 == s2.subrange(0, s1.len() as int) {\n        true\n    } else if s2.len() < s1.len() && s2 == s1.subrange(0, s2.len() as int) {\n        false\n    } else {\n        exists|i: int| (0 <= i < s1.len() && i < s2.len() && s1[i] != s2[i] &&\n        (forall|j: int| 0 <= j < i ==> s1[j] == s2[j]) &&\n        'a' <= s1[i] <= 'z' && 'a' <= s2[i] <= 'z' &&\n        alphabet_order(s1[i], s2[i], alphabet))\n    }\n}\n\nspec fn alphabet_order(c1: char, c2: char, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j],\n              'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'\n{\n    exists|i: int, j: int| 0 <= i < j < alphabet.len() && alphabet[i] == c1 && alphabet[j] == c2\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::<Seq<char>>::empty()\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n{\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        exists|n: int| n >= 1 && valid_input(stdin_input@, n),\n    ensures\n        result@ == \"Impossible\"@ || (result@.len() == 26 && forall|i: int| 0 <= i < result@.len() ==> 'a' <= result@[i] <= 'z'),\n        result@ != \"Impossible\"@ ==> (forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] != result@[j]),\n        result@ != \"Impossible\"@ ==> valid_alphabet_ordering(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"Impossible\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1631.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 597, "verus_errors": [{"error_type": "Other", "error_text": "Could not automatically infer triggers for this quantifier.  Use #[trigger] annotations to manually mark trigger terms instead. ()", "message": "VerusErrorType.Other: Could not automatically infer triggers for this quantifier.  Use #[trigger] annotations to manually mark trigger terms instead. ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp9u3hxj21", "lines": [13, 13], "label": null, "text": [{"text": "        forall|j: int| 0 <= j < lines[i].len() ==> 'a' <= lines[i][j] <= 'z'))", "highlight_start": 9, "highlight_end": 55}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 92, "minimized_LOC": 92, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(stdin_input: Seq<char>, n: int) -> bool {\n\nspec fn valid_alphabet_ordering(stdin_input: Seq<char>, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]\n{\n\nspec fn lexicographically_less_or_equal(s1: Seq<char>, s2: Seq<char>, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]\n{\n\nspec fn alphabet_order(c1: char, c2: char, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j],\n              'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'\n{\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n{\n\nspec fn parse_int(s: Seq<char>) -> int\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_1634_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_costs(c: &[int]) -> bool {\n  c.len() == 4 &&\n  c[0] >= 1 && c[1] >= 1 && c[2] >= 1 && c[3] >= 1 &&\n  c[0] <= 1000 && c[1] <= 1000 && c[2] <= 1000 && c[3] <= 1000\n}\n\nspec fn valid_rides(rides: &[int]) -> bool {\n  rides.len() >= 1 && rides.len() <= 1000 &&\n  forall|i: int| #![trigger rides[i]] 0 <= i < rides.len() ==> 0 <= rides[i] <= 1000\n}\n\nspec fn sum_array(arr: Seq<int>) -> int\n  decreases arr.len(),\n{\n  if arr.len() == 0 { \n    0 \n  } else { \n    arr[0] + sum_array(arr.drop_first()) \n  }\n}\n\nspec fn optimized_cost(rides: Seq<int>, individual_cost: int, unlimited_cost: int) -> int {\n  let initial_cost = sum_array(rides) * individual_cost;\n  min_with_unlimited(rides, initial_cost, individual_cost, unlimited_cost, 0)\n}\n\nspec fn min_with_unlimited(rides: Seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int) -> int\n  decreases rides.len() - index,\n{\n  if index >= rides.len() { \n    current_cost \n  } else {\n    let new_cost = current_cost - rides[index] * individual_cost + unlimited_cost;\n    let updated_cost = if new_cost < current_cost && new_cost >= 0 { new_cost } else { current_cost };\n    min_with_unlimited(rides, updated_cost, individual_cost, unlimited_cost, index + 1)\n  }\n}\n\nspec fn min5(a: int, b: int, c: int, d: int, e: int) -> int {\n  let min_ab = if a <= b { a } else { b };\n  let min_cd = if c <= d { c } else { d };\n  let min_abcd = if min_ab <= min_cd { min_ab } else { min_cd };\n  if min_abcd <= e { min_abcd } else { e }\n}\n\nspec fn correct_result(c: &[int], a: &[int], b: &[int], result: int) -> bool {\n  result == min5(optimized_cost(a@, c[0], c[1]) + optimized_cost(b@, c[0], c[1]),\n                 optimized_cost(a@, c[0], c[1]) + c[2],\n                 optimized_cost(b@, c[0], c[1]) + c[2],\n                 c[2] + c[2],\n                 c[3])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(c: &Vec<i8>, a: &Vec<i8>, b: &Vec<i8>) -> (result: i8)\n  requires \n    c.len() == 4,\n    c@[0] as int >= 1 && c@[1] as int >= 1 && c@[2] as int >= 1 && c@[3] as int >= 1,\n    c@[0] as int <= 1000 && c@[1] as int <= 1000 && c@[2] as int <= 1000 && c@[3] as int <= 1000,\n    a.len() >= 1 && a.len() <= 1000,\n    b.len() >= 1 && b.len() <= 1000,\n    forall|i: int| #![trigger a@[i]] 0 <= i < a.len() ==> 0 <= a@[i] as int <= 1000,\n    forall|i: int| #![trigger b@[i]] 0 <= i < b.len() ==> 0 <= b@[i] as int <= 1000,\n  ensures \n    result >= 0,\n    result as int <= min5(sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int), \n                  sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),\n                  sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),\n                  (c@[2] as int) + (c@[2] as int),\n                  c@[3] as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_costs(c: &[int]) -> bool {\n  c.len() == 4 &&\n  c[0] >= 1 && c[1] >= 1 && c[2] >= 1 && c[3] >= 1 &&\n  c[0] <= 1000 && c[1] <= 1000 && c[2] <= 1000 && c[3] <= 1000\n}\n\nspec fn valid_rides(rides: &[int]) -> bool {\n  rides.len() >= 1 && rides.len() <= 1000 &&\n  forall|i: int| #![trigger rides[i]] 0 <= i < rides.len() ==> 0 <= rides[i] <= 1000\n}\n\nspec fn sum_array(arr: Seq<int>) -> int\n  decreases arr.len(),\n{\n  if arr.len() == 0 { \n    0 \n  } else { \n    arr[0] + sum_array(arr.drop_first()) \n  }\n}\n\nspec fn optimized_cost(rides: Seq<int>, individual_cost: int, unlimited_cost: int) -> int {\n  let initial_cost = sum_array(rides) * individual_cost;\n  min_with_unlimited(rides, initial_cost, individual_cost, unlimited_cost, 0)\n}\n\nspec fn min_with_unlimited(rides: Seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int) -> int\n  decreases rides.len() - index,\n{\n  if index >= rides.len() { \n    current_cost \n  } else {\n    let new_cost = current_cost - rides[index] * individual_cost + unlimited_cost;\n    let updated_cost = if new_cost < current_cost && new_cost >= 0 { new_cost } else { current_cost };\n    min_with_unlimited(rides, updated_cost, individual_cost, unlimited_cost, index + 1)\n  }\n}\n\nspec fn min5(a: int, b: int, c: int, d: int, e: int) -> int {\n  let min_ab = if a <= b { a } else { b };\n  let min_cd = if c <= d { c } else { d };\n  let min_abcd = if min_ab <= min_cd { min_ab } else { min_cd };\n  if min_abcd <= e { min_abcd } else { e }\n}\n\nspec fn correct_result(c: &[int], a: &[int], b: &[int], result: int) -> bool {\n  result == min5(optimized_cost(a@, c[0], c[1]) + optimized_cost(b@, c[0], c[1]),\n                 optimized_cost(a@, c[0], c[1]) + c[2],\n                 optimized_cost(b@, c[0], c[1]) + c[2],\n                 c[2] + c[2],\n                 c[3])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(c: &Vec<i8>, a: &Vec<i8>, b: &Vec<i8>) -> (result: i8)\n  requires \n    c.len() == 4,\n    c@[0] as int >= 1 && c@[1] as int >= 1 && c@[2] as int >= 1 && c@[3] as int >= 1,\n    c@[0] as int <= 1000 && c@[1] as int <= 1000 && c@[2] as int <= 1000 && c@[3] as int <= 1000,\n    a.len() >= 1 && a.len() <= 1000,\n    b.len() >= 1 && b.len() <= 1000,\n    forall|i: int| #![trigger a@[i]] 0 <= i < a.len() ==> 0 <= a@[i] as int <= 1000,\n    forall|i: int| #![trigger b@[i]] 0 <= i < b.len() ==> 0 <= b@[i] as int <= 1000,\n  ensures \n    result >= 0,\n    result as int <= min5(sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int), \n                  sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),\n                  sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),\n                  (c@[2] as int) + (c@[2] as int),\n                  c@[3] as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1634.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 676, "verus_errors": [{"error_type": "Other", "error_text": "The verifier does not yet support the following Rust feature: only variables are supported here, not general patterns ()", "message": "VerusErrorType.Other: The verifier does not yet support the following Rust feature: only variables are supported here, not general patterns ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpx3_2rd6a", "lines": [75, 75], "label": null, "text": [{"text": "    result as int <= min5(sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int), ", "highlight_start": 45, "highlight_end": 46}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 91, "minimized_LOC": 91, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_costs(c: &[int]) -> bool {\n\nspec fn valid_rides(rides: &[int]) -> bool {\n\nspec fn sum_array(arr: Seq<int>) -> int\n  decreases arr.len(),\n{\n\nspec fn optimized_cost(rides: Seq<int>, individual_cost: int, unlimited_cost: int) -> int {\n\nspec fn min_with_unlimited(rides: Seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int) -> int\n  decreases rides.len() - index,\n{\n\nspec fn min5(a: int, b: int, c: int, d: int, e: int) -> int {\n\nspec fn correct_result(c: &[int], a: &[int], b: &[int], result: int) -> bool {\n\n  decreases arr.len(),\n\n  decreases rides.len() - index,\n\n  requires \n\n  ensures "}}}, "all_snapshots": []}
{"id": "apps_test_1661_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_buyable_games(games: Seq<int>, bills: Seq<int>) -> int\n    decreases games.len()\n{\n    if games.len() == 0 {\n        0\n    } else if bills.len() == 0 {\n        0\n    } else if bills[0] >= games[0] {\n        1 + count_buyable_games(games.subrange(1, games.len() as int), bills.subrange(1, bills.len() as int))\n    } else {\n        count_buyable_games(games.subrange(1, games.len() as int), bills)\n    }\n}\n\nspec fn valid_input(n: int, m: int, games: Seq<int>, bills: Seq<int>) -> bool {\n    n >= 1 && m >= 1 &&\n    games.len() == n && bills.len() == m &&\n    (forall|i: int| 0 <= i < games.len() ==> #[trigger] games[i] >= 1 && #[trigger] games[i] <= 1000) &&\n    (forall|i: int| 0 <= i < bills.len() ==> #[trigger] bills[i] >= 1 && #[trigger] bills[i] <= 1000)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, games: Vec<i8>, bills: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),\n    ensures \n        0 <= result as int <= n as int,\n        result as int <= m as int,\n        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_buyable_games(games: Seq<int>, bills: Seq<int>) -> int\n    decreases games.len()\n{\n    if games.len() == 0 {\n        0\n    } else if bills.len() == 0 {\n        0\n    } else if bills[0] >= games[0] {\n        1 + count_buyable_games(games.subrange(1, games.len() as int), bills.subrange(1, bills.len() as int))\n    } else {\n        count_buyable_games(games.subrange(1, games.len() as int), bills)\n    }\n}\n\nspec fn valid_input(n: int, m: int, games: Seq<int>, bills: Seq<int>) -> bool {\n    n >= 1 && m >= 1 &&\n    games.len() == n && bills.len() == m &&\n    (forall|i: int| 0 <= i < games.len() ==> #[trigger] games[i] >= 1 && #[trigger] games[i] <= 1000) &&\n    (forall|i: int| 0 <= i < bills.len() ==> #[trigger] bills[i] >= 1 && #[trigger] bills[i] <= 1000)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, games: Vec<i8>, bills: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),\n    ensures \n        0 <= result as int <= n as int,\n        result as int <= m as int,\n        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1661.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 511, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpinsu909f", "lines": [34, 34], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "highlight_start": 52, "highlight_end": 68}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpinsu909f", "lines": [34, 34], "label": "arguments to this method are incorrect", "text": [{"text": "        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "highlight_start": 48, "highlight_end": 51}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpinsu909f", "lines": [34, 34], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "highlight_start": 82, "highlight_end": 98}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpinsu909f", "lines": [34, 34], "label": "arguments to this method are incorrect", "text": [{"text": "        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "highlight_start": 78, "highlight_end": 81}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpinsu909f", "lines": [38, 38], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "highlight_start": 57, "highlight_end": 73}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpinsu909f", "lines": [38, 38], "label": "arguments to this method are incorrect", "text": [{"text": "        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "highlight_start": 53, "highlight_end": 56}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpinsu909f", "lines": [38, 38], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "highlight_start": 87, "highlight_end": 103}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpinsu909f", "lines": [38, 38], "label": "arguments to this method are incorrect", "text": [{"text": "        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "highlight_start": 83, "highlight_end": 86}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_buyable_games(games: Seq<int>, bills: Seq<int>) -> int\n    decreases games.len()\n{\n\nspec fn valid_input(n: int, m: int, games: Seq<int>, bills: Seq<int>) -> bool {\n\n    decreases games.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_1684_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub struct InputData {\n    pub n: int,\n    pub m: int,\n    pub segments: Set<(int, int)>,\n}\n\nspec fn valid_input_format(stdin_input: &str) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn parse_input(stdin_input: &str) -> InputData\n    requires valid_input_format(stdin_input)\n{\n    InputData {\n        n: 2,\n        m: 0,\n        segments: Set::empty(),\n    }\n}\n\nspec fn rotate_segment(seg: (int, int), k: int, n: int) -> (int, int)\n    requires 1 <= seg.0 <= n && 1 <= seg.1 <= n && k >= 0 && n > 0\n{\n    let temp_a = (seg.0 + k) % n;\n    let a = if temp_a == 0 { n } else { temp_a };\n    let temp_b = (seg.1 + k) % n;\n    let b = if temp_b == 0 { n } else { temp_b };\n    (a, b)\n}\n\nspec fn exists_rotational_symmetry(data: InputData) -> bool {\n    exists|k: int| 1 <= k < data.n && \n        data.n % k == 0 &&\n        (forall|seg: (int, int)| data.segments.contains(seg) ==> \n            seg.0 >= 1 && seg.0 <= data.n && seg.1 >= 1 && seg.1 <= data.n &&\n            data.segments.contains(rotate_segment(seg, k, data.n)))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0\n    requires valid_input_format(stdin_input)\n    ensures result == \"Yes\" || result == \"No\"\n    ensures (result == \"Yes\") == exists_rotational_symmetry(parse_input(stdin_input))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub struct InputData {\n    pub n: int,\n    pub m: int,\n    pub segments: Set<(int, int)>,\n}\n\nspec fn valid_input_format(stdin_input: &str) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn parse_input(stdin_input: &str) -> InputData\n    requires valid_input_format(stdin_input)\n{\n    InputData {\n        n: 2,\n        m: 0,\n        segments: Set::empty(),\n    }\n}\n\nspec fn rotate_segment(seg: (int, int), k: int, n: int) -> (int, int)\n    requires 1 <= seg.0 <= n && 1 <= seg.1 <= n && k >= 0 && n > 0\n{\n    let temp_a = (seg.0 + k) % n;\n    let a = if temp_a == 0 { n } else { temp_a };\n    let temp_b = (seg.1 + k) % n;\n    let b = if temp_b == 0 { n } else { temp_b };\n    (a, b)\n}\n\nspec fn exists_rotational_symmetry(data: InputData) -> bool {\n    exists|k: int| 1 <= k < data.n && \n        data.n % k == 0 &&\n        (forall|seg: (int, int)| data.segments.contains(seg) ==> \n            seg.0 >= 1 && seg.0 <= data.n && seg.1 >= 1 && seg.1 <= data.n &&\n            data.segments.contains(rotate_segment(seg, k, data.n)))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0\n    requires valid_input_format(stdin_input)\n    ensures result == \"Yes\" || result == \"No\"\n    ensures (result == \"Yes\") == exists_rotational_symmetry(parse_input(stdin_input))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1684.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 149, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpjnmbgh_9", "lines": [52, 52], "label": null, "text": [{"text": "    requires valid_input_format(stdin_input)", "highlight_start": 5, "highlight_end": 13}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(stdin_input: &str) -> bool {\n\nspec fn parse_input(stdin_input: &str) -> InputData\n    requires valid_input_format(stdin_input)\n{\n\nspec fn rotate_segment(seg: (int, int), k: int, n: int) -> (int, int)\n    requires 1 <= seg.0 <= n && 1 <= seg.1 <= n && k >= 0 && n > 0\n{\n\nspec fn exists_rotational_symmetry(data: InputData) -> bool {\n\n    requires valid_input_format(stdin_input)\n\n    requires 1 <= seg.0 <= n && 1 <= seg.1 <= n && k >= 0 && n > 0\n\n    requires stdin_input.len() > 0\n\n    requires valid_input_format(stdin_input)\n\n    ensures result == \"Yes\" || result == \"No\"\n\n    ensures (result == \"Yes\") == exists_rotational_symmetry(parse_input(stdin_input))"}}}, "all_snapshots": []}
{"id": "apps_test_1724_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: int, a: Seq<int>, k: Seq<char>) -> bool {\n  n >= 1 && a.len() == n && k.len() == n && \n  (forall|i: int| 0 <= i < n ==> a[i] >= 0) &&\n  is_binary_string(k)\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn pow(base: int, exp: int) -> int\n  decreases exp\n{\n  if exp == 0 { 1 }\n  else if exp > 0 { base * pow(base, exp - 1) }\n  else { 1 }\n}\n\nspec fn binary_string_to_int(s: Seq<char>) -> int\n  requires is_binary_string(s)\n  ensures binary_string_to_int(s) >= 0\n  decreases s.len()\n{\n  if s.len() == 0 { 0 }\n  else { (if s[0] == '1' { 1 } else { 0 }) * pow(2, s.len() as int - 1) + binary_string_to_int(s.subrange(1, s.len() as int)) }\n}\n\nspec fn f(a: Seq<int>, x: int, n: int) -> int\n  requires n >= 0 && a.len() == n\n  ensures (forall|i: int| 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0\n  decreases n\n{\n  if n == 0 { 0 }\n  else { (if (x / pow(2, n-1)) % 2 == 1 { a[n-1] } else { 0 }) + f(a.subrange(0, n-1), x % pow(2, n-1), n-1) }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, a: Seq<int>, k: Seq<char>) -> (result: int)\n  requires valid_input(n, a, k)\n  ensures result >= 0,\n  ensures exists|x: int| 0 <= x <= binary_string_to_int(k) && result == f(a, x, n),\n  ensures forall|x: int| 0 <= x <= binary_string_to_int(k) ==> f(a, x, n) <= result\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: int, a: Seq<int>, k: Seq<char>) -> bool {\n  n >= 1 && a.len() == n && k.len() == n && \n  (forall|i: int| 0 <= i < n ==> a[i] >= 0) &&\n  is_binary_string(k)\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn pow(base: int, exp: int) -> int\n  decreases exp\n{\n  if exp == 0 { 1 }\n  else if exp > 0 { base * pow(base, exp - 1) }\n  else { 1 }\n}\n\nspec fn binary_string_to_int(s: Seq<char>) -> int\n  requires is_binary_string(s)\n  ensures binary_string_to_int(s) >= 0\n  decreases s.len()\n{\n  if s.len() == 0 { 0 }\n  else { (if s[0] == '1' { 1 } else { 0 }) * pow(2, s.len() as int - 1) + binary_string_to_int(s.subrange(1, s.len() as int)) }\n}\n\nspec fn f(a: Seq<int>, x: int, n: int) -> int\n  requires n >= 0 && a.len() == n\n  ensures (forall|i: int| 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0\n  decreases n\n{\n  if n == 0 { 0 }\n  else { (if (x / pow(2, n-1)) % 2 == 1 { a[n-1] } else { 0 }) + f(a.subrange(0, n-1), x % pow(2, n-1), n-1) }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, a: Seq<int>, k: Seq<char>) -> (result: int)\n  requires valid_input(n, a, k)\n  ensures result >= 0,\n  ensures exists|x: int| 0 <= x <= binary_string_to_int(k) && result == f(a, x, n),\n  ensures forall|x: int| 0 <= x <= binary_string_to_int(k) ==> f(a, x, n) <= result\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1724.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 142, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpuucbvu5x", "lines": [49, 49], "label": null, "text": [{"text": "  ensures exists|x: int| 0 <= x <= binary_string_to_int(k) && result == f(a, x, n),", "highlight_start": 3, "highlight_end": 10}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>, k: Seq<char>) -> bool {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n\nspec fn pow(base: int, exp: int) -> int\n  decreases exp\n{\n\nspec fn binary_string_to_int(s: Seq<char>) -> int\n  requires is_binary_string(s)\n  ensures binary_string_to_int(s) >= 0\n  decreases s.len()\n{\n\nspec fn f(a: Seq<int>, x: int, n: int) -> int\n  requires n >= 0 && a.len() == n\n  ensures (forall|i: int| 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0\n  decreases n\n{\n\n  decreases exp\n\n  requires is_binary_string(s)\n\n  ensures binary_string_to_int(s) >= 0\n\n  decreases s.len()\n\n  requires n >= 0 && a.len() == n\n\n  ensures (forall|i: int| 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0\n\n  decreases n\n\n  requires valid_input(n, a, k)\n\n  ensures result >= 0,\n\n  ensures exists|x: int| 0 <= x <= binary_string_to_int(k) && result == f(a, x, n),\n\n  ensures forall|x: int| 0 <= x <= binary_string_to_int(k) ==> f(a, x, n) <= result"}}}, "all_snapshots": []}
{"id": "apps_test_1745_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.index(input.len() - 1) == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output.index(output.len() - 1) == '\\n'\n}\n\nspec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {\n    (seq![], 0, 0)\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn find_newline(s: Seq<char>, start: int) -> int {\n    -1\n}\n\nspec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {\n    grid.len() == rows &&\n    rows >= 0 && cols >= 0 &&\n    (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&\n    (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> \n        grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')\n}\n\nspec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    i == 0 || i == rows - 1 || j == 0 || j == cols - 1\n}\n\nspec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||\n    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)\n}\n\nspec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(output)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.index(input.len() - 1) == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output.index(output.len() - 1) == '\\n'\n}\n\nspec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {\n    (seq![], 0, 0)\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn find_newline(s: Seq<char>, start: int) -> int {\n    -1\n}\n\nspec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {\n    grid.len() == rows &&\n    rows >= 0 && cols >= 0 &&\n    (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&\n    (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> \n        grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')\n}\n\nspec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    i == 0 || i == rows - 1 || j == 0 || j == cols - 1\n}\n\nspec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||\n    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)\n}\n\nspec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(output)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1745.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 634, "minimize_time_ms": 122279, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>) -> bool {\n\nspec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn find_newline(s: Seq<char>, start: int) -> int {\n\nspec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {\n\nspec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {\n\nspec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {\n\nspec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {\n\n    requires valid_input(input)\n\n    ensures valid_output(output)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.index(input.len() - 1) == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output.index(output.len() - 1) == '\\n'\n}\n\nspec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {\n    (seq![], 0, 0)\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn find_newline(s: Seq<char>, start: int) -> int {\n    -1\n}\n\nspec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {\n    grid.len() == rows &&\n    rows >= 0 && cols >= 0 &&\n    (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&\n    (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> \n        grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')\n}\n\nspec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    i == 0 || i == rows - 1 || j == 0 || j == cols - 1\n}\n\nspec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||\n    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)\n}\n\nspec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(output)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1780_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['0']]\n}\n\nspec fn extract_m_from_line(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_n(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_query(line: Seq<char>) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_ones(line: Seq<char>) -> int {\n    0\n}\n\nspec fn count_dashes(line: Seq<char>) -> int {\n    0\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    contains_valid_first_line(lines[0]) &&\n    contains_valid_second_line(lines[1]) &&\n    lines.len() == 2 + extract_m_from_line(lines[0]) &&\n    (forall|i: int| 2 <= i < lines.len() ==> contains_valid_query(lines[i])) &&\n    extract_n(lines[0]) == lines[1].len()\n}\n\nspec fn contains_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn contains_valid_second_line(line: Seq<char>) -> bool {\n    line.len() >= 0 &&\n    forall|i: int| 0 <= i < line.len() ==> line[i] == '1' || line[i] == '-'\n}\n\nspec fn contains_valid_query(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn compute_correct_result(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let first_line = lines[0];\n    let n = extract_n(first_line);\n    let m = extract_m(input);\n    let array_line = lines[1];\n    let positives = count_ones(array_line);\n    let negatives = count_dashes(array_line);\n    let max_balanceable = 2 * min(positives, negatives);\n\n    let outputs: Seq<Seq<char>> = Seq::new(m as nat, |i: int| {\n        let query = extract_query(lines[i + 2]);\n        let l = query.0;\n        let r = query.1;\n        let range_length = r - l + 1;\n        if range_length % 2 == 0 && range_length <= max_balanceable {\n            seq!['1']\n        } else {\n            seq!['0']\n        }\n    });\n\n    join_with_newlines(outputs)\n}\n\nspec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {\n    s.len() == 0 || (s.len() > 0 && s[s.len() - 1] == '\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        result == compute_correct_result(stdin_input),\n        forall|line: Seq<char>| split_lines(result).contains(line) ==> line == seq!['0'] || line == seq!['1'],\n        split_lines(result).len() == extract_m(stdin_input),\n        ends_with_newline_if_non_empty(result),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['0']]\n}\n\nspec fn extract_m_from_line(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_n(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_query(line: Seq<char>) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_ones(line: Seq<char>) -> int {\n    0\n}\n\nspec fn count_dashes(line: Seq<char>) -> int {\n    0\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    contains_valid_first_line(lines[0]) &&\n    contains_valid_second_line(lines[1]) &&\n    lines.len() == 2 + extract_m_from_line(lines[0]) &&\n    (forall|i: int| 2 <= i < lines.len() ==> contains_valid_query(lines[i])) &&\n    extract_n(lines[0]) == lines[1].len()\n}\n\nspec fn contains_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn contains_valid_second_line(line: Seq<char>) -> bool {\n    line.len() >= 0 &&\n    forall|i: int| 0 <= i < line.len() ==> line[i] == '1' || line[i] == '-'\n}\n\nspec fn contains_valid_query(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn compute_correct_result(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let first_line = lines[0];\n    let n = extract_n(first_line);\n    let m = extract_m(input);\n    let array_line = lines[1];\n    let positives = count_ones(array_line);\n    let negatives = count_dashes(array_line);\n    let max_balanceable = 2 * min(positives, negatives);\n\n    let outputs: Seq<Seq<char>> = Seq::new(m as nat, |i: int| {\n        let query = extract_query(lines[i + 2]);\n        let l = query.0;\n        let r = query.1;\n        let range_length = r - l + 1;\n        if range_length % 2 == 0 && range_length <= max_balanceable {\n            seq!['1']\n        } else {\n            seq!['0']\n        }\n    });\n\n    join_with_newlines(outputs)\n}\n\nspec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {\n    s.len() == 0 || (s.len() > 0 && s[s.len() - 1] == '\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        result == compute_correct_result(stdin_input),\n        forall|line: Seq<char>| split_lines(result).contains(line) ==> line == seq!['0'] || line == seq!['1'],\n        split_lines(result).len() == extract_m(stdin_input),\n        ends_with_newline_if_non_empty(result),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1780.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 738, "minimize_time_ms": 92546, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 122, "minimized_LOC": 122, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn extract_m_from_line(line: Seq<char>) -> int {\n\nspec fn extract_n(line: Seq<char>) -> int {\n\nspec fn extract_m(input: Seq<char>) -> int {\n\nspec fn extract_query(line: Seq<char>) -> (int, int) {\n\nspec fn count_ones(line: Seq<char>) -> int {\n\nspec fn count_dashes(line: Seq<char>) -> int {\n\nspec fn min(a: int, b: int) -> int {\n\nspec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn contains_valid_first_line(line: Seq<char>) -> bool {\n\nspec fn contains_valid_second_line(line: Seq<char>) -> bool {\n\nspec fn contains_valid_query(line: Seq<char>) -> bool {\n\nspec fn compute_correct_result(input: Seq<char>) -> Seq<char> {\n\nspec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['0']]\n}\n\nspec fn extract_m_from_line(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_n(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_query(line: Seq<char>) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_ones(line: Seq<char>) -> int {\n    0\n}\n\nspec fn count_dashes(line: Seq<char>) -> int {\n    0\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    contains_valid_first_line(lines[0]) &&\n    contains_valid_second_line(lines[1]) &&\n    lines.len() == 2 + extract_m_from_line(lines[0]) &&\n    (forall|i: int| 2 <= i < lines.len() ==> contains_valid_query(lines[i])) &&\n    extract_n(lines[0]) == lines[1].len()\n}\n\nspec fn contains_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn contains_valid_second_line(line: Seq<char>) -> bool {\n    line.len() >= 0 &&\n    forall|i: int| 0 <= i < line.len() ==> line[i] == '1' || line[i] == '-'\n}\n\nspec fn contains_valid_query(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn compute_correct_result(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let first_line = lines[0];\n    let n = extract_n(first_line);\n    let m = extract_m(input);\n    let array_line = lines[1];\n    let positives = count_ones(array_line);\n    let negatives = count_dashes(array_line);\n    let max_balanceable = 2 * min(positives, negatives);\n\n    let outputs: Seq<Seq<char>> = Seq::new(m as nat, |i: int| {\n        let query = extract_query(lines[i + 2]);\n        let l = query.0;\n        let r = query.1;\n        let range_length = r - l + 1;\n        if range_length % 2 == 0 && range_length <= max_balanceable {\n            seq!['1']\n        } else {\n            seq!['0']\n        }\n    });\n\n    join_with_newlines(outputs)\n}\n\nspec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {\n    s.len() == 0 || (s.len() > 0 && s[s.len() - 1] == '\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        result == compute_correct_result(stdin_input),\n        forall|line: Seq<char>| split_lines(result).contains(line) ==> line == seq!['0'] || line == seq!['1'],\n        split_lines(result).len() == extract_m(stdin_input),\n        ends_with_newline_if_non_empty(result),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1824_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_by_newline(input);\n    lines.len() >= 4 && \n    is_valid_integer(lines[0]) &&\n    string_to_int(lines[0]) >= 3 &&\n    split_by_space(lines[1]).len() == string_to_int(lines[0]) &&\n    split_by_space(lines[2]).len() == string_to_int(lines[0]) - 1 &&\n    split_by_space(lines[3]).len() == string_to_int(lines[0]) - 2 &&\n    (forall|i: int| 0 <= i < split_by_space(lines[1]).len() ==> is_valid_integer(split_by_space(lines[1])[i])) &&\n    (forall|i: int| 0 <= i < split_by_space(lines[2]).len() ==> is_valid_integer(split_by_space(lines[2])[i])) &&\n    (forall|i: int| 0 <= i < split_by_space(lines[3]).len() ==> is_valid_integer(split_by_space(lines[3])[i]))\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (s[0] == '-' ==> s.len() > 1) && \n    (forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9')\n}\n\nspec fn get_first_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let first_line = split_by_space(lines[1]);\n    sum_sequence(first_line)\n}\n\nspec fn get_second_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let second_line = split_by_space(lines[2]);\n    sum_sequence(second_line)\n}\n\nspec fn get_third_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let third_line = split_by_space(lines[3]);\n    sum_sequence(third_line)\n}\n\nspec fn sum_sequence(numbers: Seq<Seq<char>>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 { 0 }\n    else { string_to_int(numbers[0]) + sum_sequence(numbers.drop_first()) }\n}\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else if s[0] == '\\n' { split_by_newline(s.drop_first()) }\n    else {\n        let rest = split_by_newline(s.drop_first());\n        if rest.len() == 0 { seq![s] }\n        else { seq![seq![s[0]].add(rest[0])].add(rest.drop_first()) }\n    }\n}\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>> {\n    split_by_char(s, ' ')\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else {\n        let pos = find_char(s, delimiter, 0);\n        if pos == -1 { seq![s] }\n        else if pos == 0 { split_by_char(s.drop_first(), delimiter) }\n        else { seq![s.take(pos)].add(split_by_char(s.skip(pos + 1), delimiter)) }\n    }\n}\n\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start] == c { start }\n    else { find_char(s, c, start + 1) }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s[0] == '-' { -string_to_int_helper(s.drop_first(), 0) }\n    else { string_to_int_helper(s, 0) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, acc: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { acc }\n    else if '0' <= s[0] <= '9' {\n        string_to_int_helper(s.drop_first(), acc * 10 + (s[0] as int - '0' as int))\n    } else { acc }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'].add(int_to_string_helper(-n)) }\n    else { int_to_string_helper(n) }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 { seq![] }\n    else { int_to_string_helper(n / 10).add(seq![((n % 10) + '0' as int) as char]) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    requires valid_input(input@)\n    ensures result@ == int_to_string(get_first_sum(input@) - get_second_sum(input@)).add(seq!['\\n']).add(int_to_string(get_second_sum(input@) - get_third_sum(input@))).add(seq!['\\n'])\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_by_newline(input);\n    lines.len() >= 4 && \n    is_valid_integer(lines[0]) &&\n    string_to_int(lines[0]) >= 3 &&\n    split_by_space(lines[1]).len() == string_to_int(lines[0]) &&\n    split_by_space(lines[2]).len() == string_to_int(lines[0]) - 1 &&\n    split_by_space(lines[3]).len() == string_to_int(lines[0]) - 2 &&\n    (forall|i: int| 0 <= i < split_by_space(lines[1]).len() ==> is_valid_integer(split_by_space(lines[1])[i])) &&\n    (forall|i: int| 0 <= i < split_by_space(lines[2]).len() ==> is_valid_integer(split_by_space(lines[2])[i])) &&\n    (forall|i: int| 0 <= i < split_by_space(lines[3]).len() ==> is_valid_integer(split_by_space(lines[3])[i]))\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (s[0] == '-' ==> s.len() > 1) && \n    (forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9')\n}\n\nspec fn get_first_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let first_line = split_by_space(lines[1]);\n    sum_sequence(first_line)\n}\n\nspec fn get_second_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let second_line = split_by_space(lines[2]);\n    sum_sequence(second_line)\n}\n\nspec fn get_third_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let third_line = split_by_space(lines[3]);\n    sum_sequence(third_line)\n}\n\nspec fn sum_sequence(numbers: Seq<Seq<char>>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 { 0 }\n    else { string_to_int(numbers[0]) + sum_sequence(numbers.drop_first()) }\n}\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else if s[0] == '\\n' { split_by_newline(s.drop_first()) }\n    else {\n        let rest = split_by_newline(s.drop_first());\n        if rest.len() == 0 { seq![s] }\n        else { seq![seq![s[0]].add(rest[0])].add(rest.drop_first()) }\n    }\n}\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>> {\n    split_by_char(s, ' ')\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else {\n        let pos = find_char(s, delimiter, 0);\n        if pos == -1 { seq![s] }\n        else if pos == 0 { split_by_char(s.drop_first(), delimiter) }\n        else { seq![s.take(pos)].add(split_by_char(s.skip(pos + 1), delimiter)) }\n    }\n}\n\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start] == c { start }\n    else { find_char(s, c, start + 1) }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s[0] == '-' { -string_to_int_helper(s.drop_first(), 0) }\n    else { string_to_int_helper(s, 0) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, acc: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { acc }\n    else if '0' <= s[0] <= '9' {\n        string_to_int_helper(s.drop_first(), acc * 10 + (s[0] as int - '0' as int))\n    } else { acc }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'].add(int_to_string_helper(-n)) }\n    else { int_to_string_helper(n) }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 { seq![] }\n    else { int_to_string_helper(n / 10).add(seq![((n % 10) + '0' as int) as char]) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    requires valid_input(input@)\n    ensures result@ == int_to_string(get_first_sum(input@) - get_second_sum(input@)).add(seq!['\\n']).add(int_to_string(get_second_sum(input@) - get_third_sum(input@))).add(seq!['\\n'])\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1824.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 172, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp7cpmrzfd", "lines": [120, 120], "label": null, "text": [{"text": "    requires valid_input(input@)", "highlight_start": 5, "highlight_end": 13}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 133, "minimized_LOC": 133, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 26, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn get_first_sum(input: Seq<char>) -> int {\n\nspec fn get_second_sum(input: Seq<char>) -> int {\n\nspec fn get_third_sum(input: Seq<char>) -> int {\n\nspec fn sum_sequence(numbers: Seq<Seq<char>>) -> int\n    decreases numbers.len()\n{\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn string_to_int_helper(s: Seq<char>, acc: int) -> int\n    decreases s.len()\n{\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n\n{\n\n    decreases numbers.len()\n\n    decreases s.len()\n\n    decreases s.len()\n\n    decreases s.len() - start\n\n    decreases s.len()\n\n    decreases n\n\n    requires input.len() > 0\n\n    requires valid_input(input@)\n\n    ensures result@ == int_to_string(get_first_sum(input@) - get_second_sum(input@)).add(seq!['\\n']).add(int_to_string(get_second_sum(input@) - get_third_sum(input@))).add(seq!['\\n'])"}}}, "all_snapshots": []}
{"id": "apps_test_1835_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_test_cases(input: Seq<char>) -> nat\n    recommends valid_input_format(input)\n{\n    1\n}\n\nspec fn count_lines(s: Seq<char>) -> nat {\n    1\n}\n\nspec fn get_line(s: Seq<char>, i: nat) -> Seq<char>\n    recommends i < count_lines(s)\n{\n    seq!['1']\n}\n\nspec fn get_string_count(input: Seq<char>, test_case: nat) -> nat\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    1\n}\n\nspec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    seq![seq!['0']]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    1\n}\n\nspec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    0\n}\n\nspec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    greedy_palindrome_count(strings)\n}\n\nspec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()\n{\n    k <= greedy_palindrome_count(strings)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_test_cases(input: Seq<char>) -> nat\n    recommends valid_input_format(input)\n{\n    1\n}\n\nspec fn count_lines(s: Seq<char>) -> nat {\n    1\n}\n\nspec fn get_line(s: Seq<char>, i: nat) -> Seq<char>\n    recommends i < count_lines(s)\n{\n    seq!['1']\n}\n\nspec fn get_string_count(input: Seq<char>, test_case: nat) -> nat\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    1\n}\n\nspec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    seq![seq!['0']]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    1\n}\n\nspec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    0\n}\n\nspec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    greedy_palindrome_count(strings)\n}\n\nspec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()\n{\n    k <= greedy_palindrome_count(strings)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1835.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 758, "minimize_time_ms": 92165, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 83, "minimized_LOC": 83, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n\nspec fn count_test_cases(input: Seq<char>) -> nat\n    recommends valid_input_format(input)\n{\n\nspec fn count_lines(s: Seq<char>) -> nat {\n\nspec fn get_line(s: Seq<char>, i: nat) -> Seq<char>\n    recommends i < count_lines(s)\n{\n\nspec fn get_string_count(input: Seq<char>, test_case: nat) -> nat\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n\nspec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n\nspec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n\nspec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()\n{"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_test_cases(input: Seq<char>) -> nat\n    recommends valid_input_format(input)\n{\n    1\n}\n\nspec fn count_lines(s: Seq<char>) -> nat {\n    1\n}\n\nspec fn get_line(s: Seq<char>, i: nat) -> Seq<char>\n    recommends i < count_lines(s)\n{\n    seq!['1']\n}\n\nspec fn get_string_count(input: Seq<char>, test_case: nat) -> nat\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    1\n}\n\nspec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    seq![seq!['0']]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    1\n}\n\nspec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    0\n}\n\nspec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    greedy_palindrome_count(strings)\n}\n\nspec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()\n{\n    k <= greedy_palindrome_count(strings)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1912_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() as int - 1] == '\\n' &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    output.len() == 0 || output[output.len() as int - 1] == '\\n'\n}\n\nspec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input) && valid_output_format(output)\n{\n    true\n}\n\nspec fn process_input(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    input.subrange(0, 0)\n}\n\nspec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1 || \n    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))\n}\n\nspec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() as int - 1] == '\\n' || \n        !stdin_input.subrange(0, stdin_input.len() as int - 1).contains('\\n'),\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == 'Y' || result[i] == 'e' || result[i] == 's' || \n            result[i] == 'N' || result[i] == 'o' || result[i] == '\\n' || result[i] == ' ',\n        result.len() == 0 || result[result.len() as int - 1] == '\\n',\n        valid_output_format(result),\n        input_output_correspondence(stdin_input, result),\n        result == process_input(stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() as int - 1] == '\\n' &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    output.len() == 0 || output[output.len() as int - 1] == '\\n'\n}\n\nspec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input) && valid_output_format(output)\n{\n    true\n}\n\nspec fn process_input(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    input.subrange(0, 0)\n}\n\nspec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1 || \n    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))\n}\n\nspec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() as int - 1] == '\\n' || \n        !stdin_input.subrange(0, stdin_input.len() as int - 1).contains('\\n'),\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == 'Y' || result[i] == 'e' || result[i] == 's' || \n            result[i] == 'N' || result[i] == 'o' || result[i] == '\\n' || result[i] == ' ',\n        result.len() == 0 || result[result.len() as int - 1] == '\\n',\n        valid_output_format(result),\n        input_output_correspondence(stdin_input, result),\n        result == process_input(stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1912.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 658, "minimize_time_ms": 92106, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 84, "minimized_LOC": 84, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n\nspec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input) && valid_output_format(output)\n{\n\nspec fn process_input(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n\nspec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n\nspec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() as int - 1] == '\\n' &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    output.len() == 0 || output[output.len() as int - 1] == '\\n'\n}\n\nspec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input) && valid_output_format(output)\n{\n    true\n}\n\nspec fn process_input(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    input.subrange(0, 0)\n}\n\nspec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1 || \n    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))\n}\n\nspec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() as int - 1] == '\\n' || \n        !stdin_input.subrange(0, stdin_input.len() as int - 1).contains('\\n'),\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == 'Y' || result[i] == 'e' || result[i] == 's' || \n            result[i] == 'N' || result[i] == 'o' || result[i] == '\\n' || result[i] == ' ',\n        result.len() == 0 || result[result.len() as int - 1] == '\\n',\n        valid_output_format(result),\n        input_output_correspondence(stdin_input, result),\n        result == process_input(stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1932_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(input: String) -> bool {\n        input.len() > 0 && \n        {\n            let lines = split_lines_func(input);\n            lines.len() >= 2 && \n            string_to_int_func(lines[0]) >= 1 &&\n            string_to_int_func(lines[0]) <= (lines.len() as int) - 1\n        }\n    }\n    \n    spec fn get_faces(polyhedron: String) -> int {\n        if polyhedron == \"Tetrahedron\" { 4 }\n        else if polyhedron == \"Cube\" { 6 }\n        else if polyhedron == \"Octahedron\" { 8 }\n        else if polyhedron == \"Dodecahedron\" { 12 }\n        else if polyhedron == \"Icosahedron\" { 20 }\n        else { 0 }\n    }\n    \n    spec fn split_lines_func(s: String) -> Seq<String> {\n        split_lines_helper(s, 0, 0, seq![])\n    }\n    \n    spec fn split_lines_helper(s: String, start: int, i: int, acc: Seq<String>) -> Seq<String>\n        decreases s.len() - i\n    {\n        if i >= s.len() {\n            if start < s.len() { acc.push(s.substring_char(start as usize, s.len()).to_string()) }\n            else { acc }\n        } else if s.get_char(i as usize) == '\\n' {\n            let new_acc = if start <= i { acc.push(s.substring_char(start as usize, i as usize).to_string()) } else { acc };\n            split_lines_helper(s, i + 1, i + 1, new_acc)\n        } else {\n            split_lines_helper(s, start, i + 1, acc)\n        }\n    }\n    \n    spec fn string_to_int_func(s: String) -> int {\n        let trimmed = trim_func(s);\n        if trimmed.len() == 0 { 0 }\n        else { string_to_int_helper(trimmed, 0, 0) }\n    }\n    \n    spec fn string_to_int_helper(s: String, i: int, acc: int) -> int\n        decreases s.len() - i\n    {\n        if i >= s.len() { acc }\n        else if '0' <= s.get_char(i as usize) <= '9' {\n            string_to_int_helper(s, i + 1, acc * 10 + (s.get_char(i as usize) as int - '0' as int))\n        } else {\n            string_to_int_helper(s, i + 1, acc)\n        }\n    }\n    \n    spec fn int_to_string_func(n: int) -> String {\n        if n == 0 { \"0\".to_string() }\n        else { int_to_string_helper(n) }\n    }\n    \n    spec fn int_to_string_helper(n: int) -> String\n        decreases n\n    {\n        if n < 10 { \n            char::from_u32((n + ('0' as int)) as u32).unwrap().to_string()\n        } else { \n            int_to_string_helper(n / 10) + char::from_u32((n % 10 + ('0' as int)) as u32).unwrap().to_string()\n        }\n    }\n    \n    spec fn trim_func(s: String) -> String {\n        let start = trim_start(s, 0);\n        let end = trim_end(s, s.len() as int, start);\n        if start < end { s.substring_char(start as usize, end as usize).to_string() } else { \"\".to_string() }\n    }\n    \n    spec fn trim_start(s: String, i: int) -> int\n        decreases s.len() - i\n    {\n        if i >= s.len() { i }\n        else if s.get_char(i as usize) == ' ' || s.get_char(i as usize) == '\\t' || s.get_char(i as usize) == '\\r' || s.get_char(i as usize) == '\\n' {\n            trim_start(s, i + 1)\n        } else { i }\n    }\n    \n    spec fn trim_end(s: String, j: int, start: int) -> int\n        decreases j - start\n    {\n        if j <= start { start }\n        else if s.get_char((j-1) as usize) == ' ' || s.get_char((j-1) as usize) == '\\t' || s.get_char((j-1) as usize) == '\\r' || s.get_char((j-1) as usize) == '\\n' {\n            trim_end(s, j - 1, start)\n        } else { j }\n    }\n    \n    spec fn compute_total_up_to(lines: Seq<String>, count: int) -> int {\n        if count == 0 { 0 }\n        else if count >= lines.len() { 0 }\n        else { get_faces(trim_func(lines[count])) + compute_total_up_to(lines, count - 1) }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires\n        valid_input(input),\n    ensures\n        result.len() > 0,\n        result.get_char((result.len() - 1) as usize) == '\\n',\n        exists|total_faces: int| total_faces >= 0 && result == int_to_string_func(total_faces) + \"\\n\",\n        valid_input(input) ==> {\n            let lines = split_lines_func(input);\n            let n = string_to_int_func(lines[0]);\n            let expected_total = compute_total_up_to(lines, n);\n            result == int_to_string_func(expected_total) + \"\\n\"\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"0\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(input: String) -> bool {\n        input.len() > 0 && \n        {\n            let lines = split_lines_func(input);\n            lines.len() >= 2 && \n            string_to_int_func(lines[0]) >= 1 &&\n            string_to_int_func(lines[0]) <= (lines.len() as int) - 1\n        }\n    }\n    \n    spec fn get_faces(polyhedron: String) -> int {\n        if polyhedron == \"Tetrahedron\" { 4 }\n        else if polyhedron == \"Cube\" { 6 }\n        else if polyhedron == \"Octahedron\" { 8 }\n        else if polyhedron == \"Dodecahedron\" { 12 }\n        else if polyhedron == \"Icosahedron\" { 20 }\n        else { 0 }\n    }\n    \n    spec fn split_lines_func(s: String) -> Seq<String> {\n        split_lines_helper(s, 0, 0, seq![])\n    }\n    \n    spec fn split_lines_helper(s: String, start: int, i: int, acc: Seq<String>) -> Seq<String>\n        decreases s.len() - i\n    {\n        if i >= s.len() {\n            if start < s.len() { acc.push(s.substring_char(start as usize, s.len()).to_string()) }\n            else { acc }\n        } else if s.get_char(i as usize) == '\\n' {\n            let new_acc = if start <= i { acc.push(s.substring_char(start as usize, i as usize).to_string()) } else { acc };\n            split_lines_helper(s, i + 1, i + 1, new_acc)\n        } else {\n            split_lines_helper(s, start, i + 1, acc)\n        }\n    }\n    \n    spec fn string_to_int_func(s: String) -> int {\n        let trimmed = trim_func(s);\n        if trimmed.len() == 0 { 0 }\n        else { string_to_int_helper(trimmed, 0, 0) }\n    }\n    \n    spec fn string_to_int_helper(s: String, i: int, acc: int) -> int\n        decreases s.len() - i\n    {\n        if i >= s.len() { acc }\n        else if '0' <= s.get_char(i as usize) <= '9' {\n            string_to_int_helper(s, i + 1, acc * 10 + (s.get_char(i as usize) as int - '0' as int))\n        } else {\n            string_to_int_helper(s, i + 1, acc)\n        }\n    }\n    \n    spec fn int_to_string_func(n: int) -> String {\n        if n == 0 { \"0\".to_string() }\n        else { int_to_string_helper(n) }\n    }\n    \n    spec fn int_to_string_helper(n: int) -> String\n        decreases n\n    {\n        if n < 10 { \n            char::from_u32((n + ('0' as int)) as u32).unwrap().to_string()\n        } else { \n            int_to_string_helper(n / 10) + char::from_u32((n % 10 + ('0' as int)) as u32).unwrap().to_string()\n        }\n    }\n    \n    spec fn trim_func(s: String) -> String {\n        let start = trim_start(s, 0);\n        let end = trim_end(s, s.len() as int, start);\n        if start < end { s.substring_char(start as usize, end as usize).to_string() } else { \"\".to_string() }\n    }\n    \n    spec fn trim_start(s: String, i: int) -> int\n        decreases s.len() - i\n    {\n        if i >= s.len() { i }\n        else if s.get_char(i as usize) == ' ' || s.get_char(i as usize) == '\\t' || s.get_char(i as usize) == '\\r' || s.get_char(i as usize) == '\\n' {\n            trim_start(s, i + 1)\n        } else { i }\n    }\n    \n    spec fn trim_end(s: String, j: int, start: int) -> int\n        decreases j - start\n    {\n        if j <= start { start }\n        else if s.get_char((j-1) as usize) == ' ' || s.get_char((j-1) as usize) == '\\t' || s.get_char((j-1) as usize) == '\\r' || s.get_char((j-1) as usize) == '\\n' {\n            trim_end(s, j - 1, start)\n        } else { j }\n    }\n    \n    spec fn compute_total_up_to(lines: Seq<String>, count: int) -> int {\n        if count == 0 { 0 }\n        else if count >= lines.len() { 0 }\n        else { get_faces(trim_func(lines[count])) + compute_total_up_to(lines, count - 1) }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires\n        valid_input(input),\n    ensures\n        result.len() > 0,\n        result.get_char((result.len() - 1) as usize) == '\\n',\n        exists|total_faces: int| total_faces >= 0 && result == int_to_string_func(total_faces) + \"\\n\",\n        valid_input(input) ==> {\n            let lines = split_lines_func(input);\n            let n = string_to_int_func(lines[0]);\n            let expected_total = compute_total_up_to(lines, n);\n            result == int_to_string_func(expected_total) + \"\\n\"\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"0\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1932.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 841, "verus_errors": [{"error_type": "Other", "error_text": "no method named `spec_add` found for struct `std::string::String` in the current scope (method not found in `std::string::String`)", "message": "VerusErrorType.Other: no method named `spec_add` found for struct `std::string::String` in the current scope (method not found in `std::string::String`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpkd362x8a", "lines": [70, 70], "label": "method not found in `std::string::String`", "text": [{"text": "            int_to_string_helper(n / 10) + char::from_u32((n % 10 + ('0' as int)) as u32).unwrap().to_string()", "highlight_start": 13, "highlight_end": 111}]}]}, {"error_type": "Other", "error_text": "no method named `spec_add` found for struct `std::string::String` in the current scope (method not found in `std::string::String`)", "message": "VerusErrorType.Other: no method named `spec_add` found for struct `std::string::String` in the current scope (method not found in `std::string::String`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpkd362x8a", "lines": [115, 115], "label": "method not found in `std::string::String`", "text": [{"text": "        exists|total_faces: int| total_faces >= 0 && result == int_to_string_func(total_faces) + \"\\n\",", "highlight_start": 64, "highlight_end": 102}]}]}, {"error_type": "Other", "error_text": "no method named `spec_add` found for struct `std::string::String` in the current scope (method not found in `std::string::String`)", "message": "VerusErrorType.Other: no method named `spec_add` found for struct `std::string::String` in the current scope (method not found in `std::string::String`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpkd362x8a", "lines": [120, 120], "label": "method not found in `std::string::String`", "text": [{"text": "            result == int_to_string_func(expected_total) + \"\\n\"", "highlight_start": 23, "highlight_end": 64}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 135, "minimized_LOC": 135, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 22, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: String) -> bool {\n\nspec fn get_faces(polyhedron: String) -> int {\n\nspec fn split_lines_func(s: String) -> Seq<String> {\n\nspec fn split_lines_helper(s: String, start: int, i: int, acc: Seq<String>) -> Seq<String>\n        decreases s.len() - i\n    {\n\nspec fn string_to_int_func(s: String) -> int {\n\nspec fn string_to_int_helper(s: String, i: int, acc: int) -> int\n        decreases s.len() - i\n    {\n\nspec fn int_to_string_func(n: int) -> String {\n\nspec fn int_to_string_helper(n: int) -> String\n        decreases n\n    {\n\nspec fn trim_func(s: String) -> String {\n\nspec fn trim_start(s: String, i: int) -> int\n        decreases s.len() - i\n    {\n\nspec fn trim_end(s: String, j: int, start: int) -> int\n        decreases j - start\n    {\n\nspec fn compute_total_up_to(lines: Seq<String>, count: int) -> int {\n\n        decreases s.len() - i\n\n        decreases s.len() - i\n\n        decreases n\n\n        decreases s.len() - i\n\n        decreases j - start\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_1948_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, x: int, edges: Seq<(int, int)>) -> bool {\n  n > 0 && 1 <= x <= n && edges.len() == n - 1 &&\n  forall|e: (int, int)| #[trigger] edges.contains(e) ==> 0 <= e.0 < n && 0 <= e.1 < n\n}\n\nspec fn valid_distances(way_a: Seq<int>, way_b: Seq<int>, n: int, x: int) -> bool {\n  way_a.len() == n && way_b.len() == n && n > 0 && 1 <= x <= n &&\n  way_a[0] == 0 && way_b[x-1] == 0 &&\n  forall|i: int| 0 <= i < n ==> #[trigger] way_a[i] >= 0 && #[trigger] way_b[i] >= 0\n}\n\nspec fn valid_leaves(leaves: Seq<int>, edges: Seq<(int, int)>, n: int) -> bool {\n  valid_input(n, 1, edges) ==>\n  (forall|i: int| 0 <= i < leaves.len() ==> 0 <= #[trigger] leaves[i] < n) &&\n  (forall|i: int| 0 <= i < leaves.len() ==> is_leaf_node(#[trigger] leaves[i], edges, n)) &&\n  (forall|i: int| 0 <= i < n ==> is_leaf_node(i, edges, n) ==> #[trigger] leaves.contains(i)) &&\n  no_duplicates(leaves)\n}\n\nspec fn optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {\n  2 * compute_optimal_moves(way_a, way_b, leaves, x-1)\n}\nspec fn is_leaf_node(node: int, edges: Seq<(int, int)>, n: int) -> bool {\n  if 0 <= node < n {\n    let degree = edges.filter(|e: (int, int)| e.0 == node || e.1 == node).len();\n    degree <= 1\n  } else {\n    false\n  }\n}\n\nspec fn no_duplicates(s: Seq<int>) -> bool {\n  forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j ==> #[trigger] s[i] != #[trigger] s[j]\n}\n\nspec fn compute_optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {\n  if leaves.len() == 0 {\n    0\n  } else {\n    let max_leaf = leaves.fold_left(0, |acc: int, leaf: int| \n      if way_a[leaf] + way_b[leaf] > acc { way_a[leaf] + way_b[leaf] } else { acc }\n    );\n    max_leaf\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, x: i8, edges: Vec<(i8, i8)>, leaves: Vec<i8>, way_a: Vec<i8>, way_b: Vec<i8>) -> (result: i8)\n  requires \n    valid_input(n as int, x as int, edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int))) &&\n    valid_distances(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), n as int, x as int) &&\n    valid_leaves(leaves@.map(|l: i8| l as int), edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int)), n as int) &&\n    (forall|i: int| 0 <= i < leaves@.len() ==> \n      (0 <= leaves@[i] as int < way_a@.len()) && \n      (0 <= leaves@[i] as int < way_b@.len()))\n  ensures \n    result >= 0 &&\n    result as int == optimal_moves(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), leaves@.map(|l: i8| l as int), x as int) &&\n    (result as int) % 2 == 0 &&\n    result as int >= 2 * way_a@[(x-1) as int] as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, x: int, edges: Seq<(int, int)>) -> bool {\n  n > 0 && 1 <= x <= n && edges.len() == n - 1 &&\n  forall|e: (int, int)| #[trigger] edges.contains(e) ==> 0 <= e.0 < n && 0 <= e.1 < n\n}\n\nspec fn valid_distances(way_a: Seq<int>, way_b: Seq<int>, n: int, x: int) -> bool {\n  way_a.len() == n && way_b.len() == n && n > 0 && 1 <= x <= n &&\n  way_a[0] == 0 && way_b[x-1] == 0 &&\n  forall|i: int| 0 <= i < n ==> #[trigger] way_a[i] >= 0 && #[trigger] way_b[i] >= 0\n}\n\nspec fn valid_leaves(leaves: Seq<int>, edges: Seq<(int, int)>, n: int) -> bool {\n  valid_input(n, 1, edges) ==>\n  (forall|i: int| 0 <= i < leaves.len() ==> 0 <= #[trigger] leaves[i] < n) &&\n  (forall|i: int| 0 <= i < leaves.len() ==> is_leaf_node(#[trigger] leaves[i], edges, n)) &&\n  (forall|i: int| 0 <= i < n ==> is_leaf_node(i, edges, n) ==> #[trigger] leaves.contains(i)) &&\n  no_duplicates(leaves)\n}\n\nspec fn optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {\n  2 * compute_optimal_moves(way_a, way_b, leaves, x-1)\n}\nspec fn is_leaf_node(node: int, edges: Seq<(int, int)>, n: int) -> bool {\n  if 0 <= node < n {\n    let degree = edges.filter(|e: (int, int)| e.0 == node || e.1 == node).len();\n    degree <= 1\n  } else {\n    false\n  }\n}\n\nspec fn no_duplicates(s: Seq<int>) -> bool {\n  forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j ==> #[trigger] s[i] != #[trigger] s[j]\n}\n\nspec fn compute_optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {\n  if leaves.len() == 0 {\n    0\n  } else {\n    let max_leaf = leaves.fold_left(0, |acc: int, leaf: int| \n      if way_a[leaf] + way_b[leaf] > acc { way_a[leaf] + way_b[leaf] } else { acc }\n    );\n    max_leaf\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, x: i8, edges: Vec<(i8, i8)>, leaves: Vec<i8>, way_a: Vec<i8>, way_b: Vec<i8>) -> (result: i8)\n  requires \n    valid_input(n as int, x as int, edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int))) &&\n    valid_distances(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), n as int, x as int) &&\n    valid_leaves(leaves@.map(|l: i8| l as int), edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int)), n as int) &&\n    (forall|i: int| 0 <= i < leaves@.len() ==> \n      (0 <= leaves@[i] as int < way_a@.len()) && \n      (0 <= leaves@[i] as int < way_b@.len()))\n  ensures \n    result >= 0 &&\n    result as int == optimal_moves(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), leaves@.map(|l: i8| l as int), x as int) &&\n    (result as int) % 2 == 0 &&\n    result as int >= 2 * way_a@[(x-1) as int] as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1948.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 356, "verus_errors": [{"error_type": "Other", "error_text": "expected `,` ()", "message": "VerusErrorType.Other: expected `,` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp4spjbayv", "lines": [63, 63], "label": null, "text": [{"text": "      (0 <= leaves@[i] as int < way_a@.len()) && ", "highlight_start": 38, "highlight_end": 39}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 81, "minimized_LOC": 81, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, x: int, edges: Seq<(int, int)>) -> bool {\n\nspec fn valid_distances(way_a: Seq<int>, way_b: Seq<int>, n: int, x: int) -> bool {\n\nspec fn valid_leaves(leaves: Seq<int>, edges: Seq<(int, int)>, n: int) -> bool {\n\nspec fn optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {\n\nspec fn is_leaf_node(node: int, edges: Seq<(int, int)>, n: int) -> bool {\n\nspec fn no_duplicates(s: Seq<int>) -> bool {\n\nspec fn compute_optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {\n\n  requires \n\n  ensures "}}}, "all_snapshots": []}
{"id": "apps_test_1966_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn contains_valid_input_format(input: Seq<char>) -> bool {\n    exists|n: int| 1 <= n <= 100 && n % 2 == 1 && \n        input_has_correct_structure_for_n(input, n) &&\n        input_contains_exactly_four_pieces_of_size_n(input, n) &&\n        all_pieces_contain_only_binary_chars(input, n)\n}\n\nspec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    is_valid_integer_string(lines[0]) &&\n    string_to_int(lines[0]) == n &&\n    (lines.len() > n+1 ==> equal(lines[n+1], seq![])) && \n    (lines.len() > 2*n+2 ==> equal(lines[2*n+2], seq![])) && \n    (lines.len() > 3*n+3 ==> equal(lines[3*n+3], seq![]))\n}\n\nspec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    (forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| n+2 <= i <= 2*n+1 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() ==> #[trigger] lines[i].len() == n)\n}\n\nspec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    (forall|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| n+2 <= i <= 2*n+1 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1'))\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s[0] != '0' || s.len() == 1) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && #[trigger] s[i] <= '9')\n}\n\nspec fn represents_minimum_recoloring_count(input: Seq<char>, output: Seq<char>) -> bool {\n    is_valid_integer_string(output) &&\n    contains_valid_input_format(input) &&\n    {\n        let n = extract_n_from_input(input);\n        let pieces = extract_pieces_from_input(input);\n        pieces.len() == 4 &&\n        (forall|piece: Seq<Seq<char>>| pieces.contains(piece) ==> \n            piece.len() == n && \n            (forall|row: Seq<char>| piece.contains(row) ==> \n                row.len() == n &&\n                (forall|i: int| 0 <= i < row.len() ==> (row[i] == '0' || row[i] == '1')))) &&\n        string_to_int(output) == minimum_recoloring_for_pieces(pieces, n)\n    }\n}\n\nspec fn extract_n_from_input(input: Seq<char>) -> int\n    recommends contains_valid_input_format(input)\n{\n    let lines = split_by_newline(input);\n    if lines.len() > 0 && is_valid_integer_string(lines[0]) {\n        string_to_int(lines[0])\n    } else {\n        1\n    }\n}\n\nspec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>\n    recommends contains_valid_input_format(input)\n{\n    let lines = split_by_newline(input);\n    let n = extract_n_from_input(input);\n    seq![\n        lines.subrange(1, n+1),\n        lines.subrange(n+2, 2*n+2), \n        lines.subrange(2*n+3, 3*n+3),\n        lines.subrange(3*n+4, 4*n+4)\n    ]\n}\n\nspec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {\n    0\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn contains_valid_input_format(input: Seq<char>) -> bool ;\n       spec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n          let lines = split_by_newline(input);\n          if lines.len() > 0 && is_valid_integer_string(lines[0]) {\n             string_to_int(lines[0])     }\n      else {\n             1     }\n      }\n       spec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>     recommends contains_valid_input_format(input) {\n          let lines = split_by_newline(input);\n          let n = extract_n_from_input(input);\n          seq![         lines.subrange(1, n+1),         lines.subrange(n+2, 2*n+2),          lines.subrange(2*n+3, 3*n+3),         lines.subrange(3*n+4, 4*n+4)     ] }\n       spec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {\n          0 }\n       spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n          seq![] }\n       spec fn string_to_int(s: Seq<char>) -> int {\n          0 }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1966.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 918, "minimize_time_ms": 154770, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 127, "minimized_LOC": 27, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.2125984251968504}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn contains_valid_input_format(input: Seq<char>) -> bool ;\n       spec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n\nspec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n\nspec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n\nspec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n\nspec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n\nspec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>     recommends contains_valid_input_format(input) {\n\nspec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn contains_valid_input_format(input: Seq<char>) -> bool {\n    exists|n: int| 1 <= n <= 100 && n % 2 == 1 && \n        input_has_correct_structure_for_n(input, n) &&\n        input_contains_exactly_four_pieces_of_size_n(input, n) &&\n        all_pieces_contain_only_binary_chars(input, n)\n}\n\nspec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    is_valid_integer_string(lines[0]) &&\n    string_to_int(lines[0]) == n &&\n    (lines.len() > n+1 ==> equal(lines[n+1], seq![])) && \n    (lines.len() > 2*n+2 ==> equal(lines[2*n+2], seq![])) && \n    (lines.len() > 3*n+3 ==> equal(lines[3*n+3], seq![]))\n}\n\nspec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    (forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| n+2 <= i <= 2*n+1 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() ==> #[trigger] lines[i].len() == n)\n}\n\nspec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    (forall|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| n+2 <= i <= 2*n+1 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1'))\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s[0] != '0' || s.len() == 1) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && #[trigger] s[i] <= '9')\n}\n\nspec fn represents_minimum_recoloring_count(input: Seq<char>, output: Seq<char>) -> bool {\n    is_valid_integer_string(output) &&\n    contains_valid_input_format(input) &&\n    {\n        let n = extract_n_from_input(input);\n        let pieces = extract_pieces_from_input(input);\n        pieces.len() == 4 &&\n        (forall|piece: Seq<Seq<char>>| pieces.contains(piece) ==> \n            piece.len() == n && \n            (forall|row: Seq<char>| piece.contains(row) ==> \n                row.len() == n &&\n                (forall|i: int| 0 <= i < row.len() ==> (row[i] == '0' || row[i] == '1')))) &&\n        string_to_int(output) == minimum_recoloring_for_pieces(pieces, n)\n    }\n}\n\nspec fn extract_n_from_input(input: Seq<char>) -> int\n    recommends contains_valid_input_format(input)\n{\n    let lines = split_by_newline(input);\n    if lines.len() > 0 && is_valid_integer_string(lines[0]) {\n        string_to_int(lines[0])\n    } else {\n        1\n    }\n}\n\nspec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>\n    recommends contains_valid_input_format(input)\n{\n    let lines = split_by_newline(input);\n    let n = extract_n_from_input(input);\n    seq![\n        lines.subrange(1, n+1),\n        lines.subrange(n+2, 2*n+2), \n        lines.subrange(2*n+3, 3*n+3),\n        lines.subrange(3*n+4, 4*n+4)\n    ]\n}\n\nspec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {\n    0\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn contains_valid_input_format(input: Seq<char>) -> bool ;\n       spec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n          let lines = split_by_newline(input);\n          if lines.len() > 0 && is_valid_integer_string(lines[0]) {\n             string_to_int(lines[0])     }\n      else {\n             1     }\n      }\n       spec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>     recommends contains_valid_input_format(input) {\n          let lines = split_by_newline(input);\n          let n = extract_n_from_input(input);\n          seq![         lines.subrange(1, n+1),         lines.subrange(n+2, 2*n+2),          lines.subrange(2*n+3, 3*n+3),         lines.subrange(3*n+4, 4*n+4)     ] }\n       spec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {\n          0 }\n       spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n          seq![] }\n       spec fn string_to_int(s: Seq<char>) -> int {\n          0 }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n             fn main() {\n   }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1968_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, v: int, sellers: Seq<Seq<int>>) -> bool {\n    n >= 0 && v >= 0 && sellers.len() == n && \n    forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0\n}\n\nspec fn valid_output(count: int, indices: Seq<int>, n: int) -> bool {\n    count == indices.len() && count >= 0 && count <= n &&\n    (forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= n) &&\n    (forall|i: int| 0 <= i < indices.len() - 1 ==> indices[i] < indices[i+1])\n}\n\nspec fn correct_solution(v: int, sellers: Seq<Seq<int>>, indices: Seq<int>) -> bool \n    recommends forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0,\n              forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= sellers.len()\n{\n    (forall|i: int| 0 <= i < indices.len() ==> v > seq_min(sellers[indices[i] - 1])) &&\n    (forall|i: int| 0 <= i < sellers.len() ==> (v > seq_min(sellers[i]) <==> indices.contains(i + 1)))\n}\n\nspec fn seq_min(s: Seq<int>) -> int\n    recommends s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        let first = s[0];\n        let rest_min = seq_min(s.subrange(1, s.len() as int));\n        if first < rest_min { first } else { rest_min }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i32, v: i32, sellers: Vec<Vec<i32>>) -> (result: (i32, Vec<i32>))\n    requires valid_input(n as int, v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)))\n    ensures ({\n        let (count, indices) = result;\n        valid_output(count as int, indices@.map(|i: int, x: i32| x as int), n as int) && \n        correct_solution(v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)), indices@.map(|i: int, x: i32| x as int))\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    (0, Vec::new())\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, v: int, sellers: Seq<Seq<int>>) -> bool {\n    n >= 0 && v >= 0 && sellers.len() == n && \n    forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0\n}\n\nspec fn valid_output(count: int, indices: Seq<int>, n: int) -> bool {\n    count == indices.len() && count >= 0 && count <= n &&\n    (forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= n) &&\n    (forall|i: int| 0 <= i < indices.len() - 1 ==> indices[i] < indices[i+1])\n}\n\nspec fn correct_solution(v: int, sellers: Seq<Seq<int>>, indices: Seq<int>) -> bool \n    recommends forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0,\n              forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= sellers.len()\n{\n    (forall|i: int| 0 <= i < indices.len() ==> v > seq_min(sellers[indices[i] - 1])) &&\n    (forall|i: int| 0 <= i < sellers.len() ==> (v > seq_min(sellers[i]) <==> indices.contains(i + 1)))\n}\n\nspec fn seq_min(s: Seq<int>) -> int\n    recommends s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        let first = s[0];\n        let rest_min = seq_min(s.subrange(1, s.len() as int));\n        if first < rest_min { first } else { rest_min }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i32, v: i32, sellers: Vec<Vec<i32>>) -> (result: (i32, Vec<i32>))\n    requires valid_input(n as int, v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)))\n    ensures ({\n        let (count, indices) = result;\n        valid_output(count as int, indices@.map(|i: int, x: i32| x as int), n as int) && \n        correct_solution(v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)), indices@.map(|i: int, x: i32| x as int))\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    (0, Vec::new())\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1968.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 645, "verus_errors": [{"error_type": "Other", "error_text": "recursive function must have a decreases clause ()", "message": "VerusErrorType.Other: recursive function must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp7cw8aoc6", "lines": [24, 24], "label": null, "text": [{"text": "spec fn seq_min(s: Seq<int>) -> int", "highlight_start": 6, "highlight_end": 36}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, v: int, sellers: Seq<Seq<int>>) -> bool {\n\nspec fn valid_output(count: int, indices: Seq<int>, n: int) -> bool {\n\nspec fn correct_solution(v: int, sellers: Seq<Seq<int>>, indices: Seq<int>) -> bool \n    recommends forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0,\n              forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= sellers.len()\n{\n\nspec fn seq_min(s: Seq<int>) -> int\n    recommends s.len() > 0\n{\n\n    requires valid_input(n as int, v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)))\n\n    ensures ({"}}}, "all_snapshots": []}
{"id": "apps_test_1972_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {\n    true\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 { \n        seq![]\n    } else { \n        seq![seq!['1'], seq!['q', 'u', 'e', 'r', 'y', '1']] \n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {\n    0\n}\n\nspec fn int_to_string(x: int) -> Seq<char> {\n    seq!['1']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input(input),\n    ensures \n        valid_output(output, input),\n        output.len() > 0 && output[output.len() - 1] == '\\n',\n        correct_incremental_query_processing(input, output),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {\n    true\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 { \n        seq![]\n    } else { \n        seq![seq!['1'], seq!['q', 'u', 'e', 'r', 'y', '1']] \n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {\n    0\n}\n\nspec fn int_to_string(x: int) -> Seq<char> {\n    seq!['1']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input(input),\n    ensures \n        valid_output(output, input),\n        output.len() > 0 && output[output.len() - 1] == '\\n',\n        correct_incremental_query_processing(input, output),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1972.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 955, "minimize_time_ms": 92120, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {\n\nspec fn int_to_string(x: int) -> Seq<char> {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {\n    true\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 { \n        seq![]\n    } else { \n        seq![seq!['1'], seq!['q', 'u', 'e', 'r', 'y', '1']] \n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {\n    0\n}\n\nspec fn int_to_string(x: int) -> Seq<char> {\n    seq!['1']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input(input),\n    ensures \n        valid_output(output, input),\n        output.len() > 0 && output[output.len() - 1] == '\\n',\n        correct_incremental_query_processing(input, output),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1980_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 1 && \n    split_whitespace_spec(lines[0]).len() >= 2 &&\n    {\n        let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n        let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n        n > 0 && k > 0 && lines.len() >= n + 1 &&\n        (forall|i: int| 1 <= i <= n ==> \n            i < lines.len() && split_whitespace_spec(lines[i]).len() >= 2)\n    }\n}\n\nspec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {\n    let lines = split_lines_spec(input);\n    let difficulties = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[0]));\n    let costs = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[1]));\n\n    max_subsegment_profit(difficulties, costs, k)\n}\n\nspec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {\n    if difficulties.len() == 0 {\n        0\n    } else {\n        let all_segment_profits = Seq::new(difficulties.len(), |l: int| \n            Seq::new((difficulties.len() - l) as nat, |len: int|\n                subsegment_profit(difficulties, costs, k, l as nat, (l + len) as nat)));\n        max_value(0, max_in_nested_seq(all_segment_profits))\n    }\n}\n\nspec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {\n    let length = r - l + 1;\n    let revenue = length * k;\n    let cost_sum = sum_range(costs, l, r);\n    let gap = if l == r { 0 } else { max_gap_squared(difficulties, l, r) };\n    revenue - cost_sum - gap\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string_result(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_value(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n    ensures\n        result@.len() > 0,\n        result@.last() == '\\n',\n        ({\n            let lines = split_lines_spec(input@);\n            (lines.len() == 0 || lines.len() == 1 || \n             split_whitespace_spec(lines[0]).len() < 2 ||\n             parse_int_spec(split_whitespace_spec(lines[0])[0]) <= 0) ==> \n            result@ == \"0\\n\"@\n        }),\n        (valid_input(input@) ==> {\n            let lines = split_lines_spec(input@);\n            let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n            let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n            exists|profit: int| \n                profit >= 0 && \n                result@ == int_to_string_result(profit) + \"\\n\"@ &&\n                profit == optimal_segment_profit(input@, n as nat, k)\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 1 && \n    split_whitespace_spec(lines[0]).len() >= 2 &&\n    {\n        let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n        let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n        n > 0 && k > 0 && lines.len() >= n + 1 &&\n        (forall|i: int| 1 <= i <= n ==> \n            i < lines.len() && split_whitespace_spec(lines[i]).len() >= 2)\n    }\n}\n\nspec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {\n    let lines = split_lines_spec(input);\n    let difficulties = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[0]));\n    let costs = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[1]));\n\n    max_subsegment_profit(difficulties, costs, k)\n}\n\nspec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {\n    if difficulties.len() == 0 {\n        0\n    } else {\n        let all_segment_profits = Seq::new(difficulties.len(), |l: int| \n            Seq::new((difficulties.len() - l) as nat, |len: int|\n                subsegment_profit(difficulties, costs, k, l as nat, (l + len) as nat)));\n        max_value(0, max_in_nested_seq(all_segment_profits))\n    }\n}\n\nspec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {\n    let length = r - l + 1;\n    let revenue = length * k;\n    let cost_sum = sum_range(costs, l, r);\n    let gap = if l == r { 0 } else { max_gap_squared(difficulties, l, r) };\n    revenue - cost_sum - gap\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string_result(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_value(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n    ensures\n        result@.len() > 0,\n        result@.last() == '\\n',\n        ({\n            let lines = split_lines_spec(input@);\n            (lines.len() == 0 || lines.len() == 1 || \n             split_whitespace_spec(lines[0]).len() < 2 ||\n             parse_int_spec(split_whitespace_spec(lines[0])[0]) <= 0) ==> \n            result@ == \"0\\n\"@\n        }),\n        (valid_input(input@) ==> {\n            let lines = split_lines_spec(input@);\n            let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n            let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n            exists|profit: int| \n                profit >= 0 && \n                result@ == int_to_string_result(profit) + \"\\n\"@ &&\n                profit == optimal_segment_profit(input@, n as nat, k)\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1980.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 699, "minimize_time_ms": 92156, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 120, "minimized_LOC": 120, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 41, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {\n\nspec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {\n\nspec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n\nspec fn int_to_string_result(n: int) -> Seq<char> {\n\nspec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {\n\nspec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {\n\nspec fn max_value(a: int, b: int) -> int {\n\nspec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 1 && \n    split_whitespace_spec(lines[0]).len() >= 2 &&\n    {\n        let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n        let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n        n > 0 && k > 0 && lines.len() >= n + 1 &&\n        (forall|i: int| 1 <= i <= n ==> \n            i < lines.len() && split_whitespace_spec(lines[i]).len() >= 2)\n    }\n}\n\nspec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {\n    let lines = split_lines_spec(input);\n    let difficulties = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[0]));\n    let costs = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[1]));\n\n    max_subsegment_profit(difficulties, costs, k)\n}\n\nspec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {\n    if difficulties.len() == 0 {\n        0\n    } else {\n        let all_segment_profits = Seq::new(difficulties.len(), |l: int| \n            Seq::new((difficulties.len() - l) as nat, |len: int|\n                subsegment_profit(difficulties, costs, k, l as nat, (l + len) as nat)));\n        max_value(0, max_in_nested_seq(all_segment_profits))\n    }\n}\n\nspec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {\n    let length = r - l + 1;\n    let revenue = length * k;\n    let cost_sum = sum_range(costs, l, r);\n    let gap = if l == r { 0 } else { max_gap_squared(difficulties, l, r) };\n    revenue - cost_sum - gap\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string_result(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_value(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n    ensures\n        result@.len() > 0,\n        result@.last() == '\\n',\n        ({\n            let lines = split_lines_spec(input@);\n            (lines.len() == 0 || lines.len() == 1 || \n             split_whitespace_spec(lines[0]).len() < 2 ||\n             parse_int_spec(split_whitespace_spec(lines[0])[0]) <= 0) ==> \n            result@ == \"0\\n\"@\n        }),\n        (valid_input(input@) ==> {\n            let lines = split_lines_spec(input@);\n            let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n            let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n            exists|profit: int| \n                profit >= 0 && \n                result@ == int_to_string_result(profit) + \"\\n\"@ &&\n                profit == optimal_segment_profit(input@, n as nat, k)\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_1984_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {\n    (1, 1, 1, 1)\n}\n\nspec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {\n    seq![]\n}\n\nspec fn int_to_string(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {\n    (1, 0)\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input[stdin_input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        lines.len() > 0 &&\n        1 <= parse_first_line(lines[0]).0 <= 10 &&\n        1 <= parse_first_line(lines[0]).1 <= 10 &&\n        1 <= parse_first_line(lines[0]).2 <= 1000 &&\n        1 <= parse_first_line(lines[0]).3 <= 1000\n    }\n}\n\nspec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {\n    result.len() > 0 &&\n    result[result.len() as int - 1] == '\\n' &&\n    {\n        let result_lines = split_lines(result);\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        result_lines.len() >= 1 &&\n        is_valid_spanning_tree(result_lines, parse_first_line(lines[0]).2)\n    }\n}\n\nspec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {\n    0\n}\n\nspec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {\n    true\n}\n\nspec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {\n    (1, 1, 1, 1)\n}\n\nspec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {\n    seq![]\n}\n\nspec fn int_to_string(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {\n    (1, 0)\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input[stdin_input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        lines.len() > 0 &&\n        1 <= parse_first_line(lines[0]).0 <= 10 &&\n        1 <= parse_first_line(lines[0]).1 <= 10 &&\n        1 <= parse_first_line(lines[0]).2 <= 1000 &&\n        1 <= parse_first_line(lines[0]).3 <= 1000\n    }\n}\n\nspec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {\n    result.len() > 0 &&\n    result[result.len() as int - 1] == '\\n' &&\n    {\n        let result_lines = split_lines(result);\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        result_lines.len() >= 1 &&\n        is_valid_spanning_tree(result_lines, parse_first_line(lines[0]).2)\n    }\n}\n\nspec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {\n    0\n}\n\nspec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {\n    true\n}\n\nspec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1984.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 919, "minimize_time_ms": 92182, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 85, "minimized_LOC": 85, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {\n\nspec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {\n\nspec fn int_to_string(n: nat) -> Seq<char> {\n\nspec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {\n\nspec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {\n\nspec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {\n\nspec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {\n\n    requires valid_input(stdin_input@)\n\n    ensures valid_output(result@, stdin_input@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {\n    (1, 1, 1, 1)\n}\n\nspec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {\n    seq![]\n}\n\nspec fn int_to_string(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {\n    (1, 0)\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input[stdin_input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        lines.len() > 0 &&\n        1 <= parse_first_line(lines[0]).0 <= 10 &&\n        1 <= parse_first_line(lines[0]).1 <= 10 &&\n        1 <= parse_first_line(lines[0]).2 <= 1000 &&\n        1 <= parse_first_line(lines[0]).3 <= 1000\n    }\n}\n\nspec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {\n    result.len() > 0 &&\n    result[result.len() as int - 1] == '\\n' &&\n    {\n        let result_lines = split_lines(result);\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        result_lines.len() >= 1 &&\n        is_valid_spanning_tree(result_lines, parse_first_line(lines[0]).2)\n    }\n}\n\nspec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {\n    0\n}\n\nspec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {\n    true\n}\n\nspec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2086_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>, s: int, f: int) -> bool {\n  n >= 2 && a.len() == n && s >= 1 && f > s && f <= n &&\n  forall|i: int| 0 <= i < n ==> a[i] >= 1\n}\n\nspec fn participant_count(a: Seq<int>, s: int, f: int, n: int, start: int) -> int {\n  participant_count_helper(a, s, f, n, start, 0)\n}\n\nspec fn participant_count_helper(a: Seq<int>, s: int, f: int, n: int, start: int, i: int) -> int\n  decreases n - i\n{\n  if i >= n {\n    0\n  } else {\n    let local_hour = (start + i - 1) % n + 1;\n    let contribution = if s <= local_hour < f { a[i] } else { 0 };\n    contribution + participant_count_helper(a, s, f, n, start, i + 1)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>, s: i8, f: i8) -> (result: i8)\n  requires \n    valid_input(n as int, a@.map(|i, x| x as int), s as int, f as int),\n  ensures \n    1 <= result <= n &&\n    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) \n      && 1 <= start <= n as int ==> \n      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) >= participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)) &&\n    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)\n      && 1 <= start <= n as int && \n      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) == participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) \n      ==> result as int <= start)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>, s: int, f: int) -> bool {\n  n >= 2 && a.len() == n && s >= 1 && f > s && f <= n &&\n  forall|i: int| 0 <= i < n ==> a[i] >= 1\n}\n\nspec fn participant_count(a: Seq<int>, s: int, f: int, n: int, start: int) -> int {\n  participant_count_helper(a, s, f, n, start, 0)\n}\n\nspec fn participant_count_helper(a: Seq<int>, s: int, f: int, n: int, start: int, i: int) -> int\n  decreases n - i\n{\n  if i >= n {\n    0\n  } else {\n    let local_hour = (start + i - 1) % n + 1;\n    let contribution = if s <= local_hour < f { a[i] } else { 0 };\n    contribution + participant_count_helper(a, s, f, n, start, i + 1)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>, s: i8, f: i8) -> (result: i8)\n  requires \n    valid_input(n as int, a@.map(|i, x| x as int), s as int, f as int),\n  ensures \n    1 <= result <= n &&\n    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) \n      && 1 <= start <= n as int ==> \n      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) >= participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)) &&\n    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)\n      && 1 <= start <= n as int && \n      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) == participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) \n      ==> result as int <= start)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2086.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 561, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types (expected `bool`, found `int`)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `bool`, found `int`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp12w05pk7", "lines": [37, 37], "label": "expected `bool`, found `int`", "text": [{"text": "    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) ", "highlight_start": 36, "highlight_end": 115}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `bool`, found `int`)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `bool`, found `int`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp12w05pk7", "lines": [40, 40], "label": "expected `bool`, found `int`", "text": [{"text": "    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)", "highlight_start": 36, "highlight_end": 115}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>, s: int, f: int) -> bool {\n\nspec fn participant_count(a: Seq<int>, s: int, f: int, n: int, start: int) -> int {\n\nspec fn participant_count_helper(a: Seq<int>, s: int, f: int, n: int, start: int, i: int) -> int\n  decreases n - i\n{\n\n  decreases n - i\n\n  requires \n\n  ensures "}}}, "all_snapshots": []}
{"id": "apps_test_2100_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    is_valid_number(lines[0]) &&\n    {\n        let n = string_to_int(lines[0]);\n        n >= 0 && n + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==>\n            {\n                let parts = split_spaces(#[trigger] lines[i as int]);\n                parts.len() >= 2 && is_valid_door_state(parts[0]) && is_valid_door_state(parts[1])\n            }\n    }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    is_valid_number(output)\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] >= '0' && #[trigger] s[i] <= '9')\n}\n\nspec fn is_valid_door_state(s: Seq<char>) -> bool {\n    s == seq!['0'] || s == seq!['1']\n}\n\nspec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let n = string_to_int(lines[0]);\n    if n == 0 {\n        seq!['0']\n    } else {\n        let left_zeros = count_left_zeros(lines, 1, n);\n        let right_zeros = count_right_zeros(lines, 1, n);\n        let left_ops = if left_zeros < n - left_zeros { left_zeros } else { n - left_zeros };\n        let right_ops = if right_zeros < n - right_zeros { right_zeros } else { n - right_zeros };\n        int_to_string(left_ops + right_ops)\n    }\n}\n\n/* Helper functions for string operations */\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n\nspec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        valid_output(result@),\n        result@ == calculate_min_operations(input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    is_valid_number(lines[0]) &&\n    {\n        let n = string_to_int(lines[0]);\n        n >= 0 && n + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==>\n            {\n                let parts = split_spaces(#[trigger] lines[i as int]);\n                parts.len() >= 2 && is_valid_door_state(parts[0]) && is_valid_door_state(parts[1])\n            }\n    }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    is_valid_number(output)\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] >= '0' && #[trigger] s[i] <= '9')\n}\n\nspec fn is_valid_door_state(s: Seq<char>) -> bool {\n    s == seq!['0'] || s == seq!['1']\n}\n\nspec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let n = string_to_int(lines[0]);\n    if n == 0 {\n        seq!['0']\n    } else {\n        let left_zeros = count_left_zeros(lines, 1, n);\n        let right_zeros = count_right_zeros(lines, 1, n);\n        let left_ops = if left_zeros < n - left_zeros { left_zeros } else { n - left_zeros };\n        let right_ops = if right_zeros < n - right_zeros { right_zeros } else { n - right_zeros };\n        int_to_string(left_ops + right_ops)\n    }\n}\n\n/* Helper functions for string operations */\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n\nspec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        valid_output(result@),\n        result@ == calculate_min_operations(input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2100.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1030, "minimize_time_ms": 123161, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 96, "minimized_LOC": 96, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>) -> bool {\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n\nspec fn is_valid_door_state(s: Seq<char>) -> bool {\n\nspec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n\nspec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    is_valid_number(lines[0]) &&\n    {\n        let n = string_to_int(lines[0]);\n        n >= 0 && n + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==>\n            {\n                let parts = split_spaces(#[trigger] lines[i as int]);\n                parts.len() >= 2 && is_valid_door_state(parts[0]) && is_valid_door_state(parts[1])\n            }\n    }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    is_valid_number(output)\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] >= '0' && #[trigger] s[i] <= '9')\n}\n\nspec fn is_valid_door_state(s: Seq<char>) -> bool {\n    s == seq!['0'] || s == seq!['1']\n}\n\nspec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let n = string_to_int(lines[0]);\n    if n == 0 {\n        seq!['0']\n    } else {\n        let left_zeros = count_left_zeros(lines, 1, n);\n        let right_zeros = count_right_zeros(lines, 1, n);\n        let left_ops = if left_zeros < n - left_zeros { left_zeros } else { n - left_zeros };\n        let right_ops = if right_zeros < n - right_zeros { right_zeros } else { n - right_zeros };\n        int_to_string(left_ops + right_ops)\n    }\n}\n\n/* Helper functions for string operations */\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n\nspec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        valid_output(result@),\n        result@ == calculate_min_operations(input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2113_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn is_connected_tree(n: int, edges: Seq<(int, int)>) -> bool {\n        n >= 1 && edges.len() == n - 1 &&\n        (n == 1 ==> edges.len() == 0) &&\n        (n > 1 ==> is_connected_graph(n, edges))\n    }\n    \n    spec fn is_connected_graph(n: int, edges: Seq<(int, int)>) -> bool {\n        n > 1 ==>\n        (forall|node: int| 2 <= node <= n ==> \n            can_reach_node_one(node, edges, n))\n    }\n    \n    spec fn can_reach_node_one(target: int, edges: Seq<(int, int)>, max_depth: int) -> bool\n        decreases max_depth\n    {\n        if max_depth <= 0 { \n            false\n        } else if target == 1 { \n            true\n        } else {\n            exists|i: int| 0 <= i < edges.len() && \n                ((edges[i].0 == target && can_reach_node_one(edges[i].1, edges, max_depth - 1)) ||\n                 (edges[i].1 == target && can_reach_node_one(edges[i].0, edges, max_depth - 1)))\n        }\n    }\n    \n    spec fn valid_tree_input(n: int, edges: Seq<(int, int)>) -> bool {\n        n >= 1 &&\n        edges.len() == n - 1 &&\n        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n) &&\n        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> edges[i].0 != edges[i].1) &&\n        (forall|i: int, j: int| #[trigger] edges.index(i).0 == edges[i].0 && #[trigger] edges.index(j).0 == edges[j].0 && 0 <= i < j < edges.len() ==> \n            !(edges[i].0 == edges[j].0 && edges[i].1 == edges[j].1) && \n            !(edges[i].0 == edges[j].1 && edges[i].1 == edges[j].0)) &&\n        (n == 1 ==> edges.len() == 0) &&\n        (n > 1 ==> (forall|node: int| #[trigger] (node + 1 - 1) == node && 1 <= node <= n ==> \n            (exists|i: int| 0 <= i < edges.len() && (edges[i].0 == node || edges[i].1 == node)))) &&\n        is_connected_tree(n, edges)\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, edges: Vec<(i8, i8)>) -> (result: i8)\n    requires\n        valid_tree_input(n as int, Seq::from_vec(edges).map(|i, e| (e.0 as int, e.1 as int))),\n    ensures\n        result >= 0,\n        exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&\n            blue >= 0 && red >= 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),\n        n == 1 ==> result == 0,\n        n == 2 ==> result == 0,\n        n > 2 ==> exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&\n            blue > 0 && red > 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),\n        result as int <= (n as int * n as int) / 4 - (n as int - 1) + (if n % 2 == 0 { 0int } else { 1int }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn is_connected_tree(n: int, edges: Seq<(int, int)>) -> bool {\n        n >= 1 && edges.len() == n - 1 &&\n        (n == 1 ==> edges.len() == 0) &&\n        (n > 1 ==> is_connected_graph(n, edges))\n    }\n    \n    spec fn is_connected_graph(n: int, edges: Seq<(int, int)>) -> bool {\n        n > 1 ==>\n        (forall|node: int| 2 <= node <= n ==> \n            can_reach_node_one(node, edges, n))\n    }\n    \n    spec fn can_reach_node_one(target: int, edges: Seq<(int, int)>, max_depth: int) -> bool\n        decreases max_depth\n    {\n        if max_depth <= 0 { \n            false\n        } else if target == 1 { \n            true\n        } else {\n            exists|i: int| 0 <= i < edges.len() && \n                ((edges[i].0 == target && can_reach_node_one(edges[i].1, edges, max_depth - 1)) ||\n                 (edges[i].1 == target && can_reach_node_one(edges[i].0, edges, max_depth - 1)))\n        }\n    }\n    \n    spec fn valid_tree_input(n: int, edges: Seq<(int, int)>) -> bool {\n        n >= 1 &&\n        edges.len() == n - 1 &&\n        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n) &&\n        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> edges[i].0 != edges[i].1) &&\n        (forall|i: int, j: int| #[trigger] edges.index(i).0 == edges[i].0 && #[trigger] edges.index(j).0 == edges[j].0 && 0 <= i < j < edges.len() ==> \n            !(edges[i].0 == edges[j].0 && edges[i].1 == edges[j].1) && \n            !(edges[i].0 == edges[j].1 && edges[i].1 == edges[j].0)) &&\n        (n == 1 ==> edges.len() == 0) &&\n        (n > 1 ==> (forall|node: int| #[trigger] (node + 1 - 1) == node && 1 <= node <= n ==> \n            (exists|i: int| 0 <= i < edges.len() && (edges[i].0 == node || edges[i].1 == node)))) &&\n        is_connected_tree(n, edges)\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, edges: Vec<(i8, i8)>) -> (result: i8)\n    requires\n        valid_tree_input(n as int, Seq::from_vec(edges).map(|i, e| (e.0 as int, e.1 as int))),\n    ensures\n        result >= 0,\n        exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&\n            blue >= 0 && red >= 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),\n        n == 1 ==> result == 0,\n        n == 2 ==> result == 0,\n        n > 2 ==> exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&\n            blue > 0 && red > 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),\n        result as int <= (n as int * n as int) / 4 - (n as int - 1) + (if n % 2 == 0 { 0int } else { 1int }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2113.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 603, "verus_errors": [{"error_type": "Other", "error_text": "no function or associated item named `from_vec` found for struct `vstd::seq::Seq<A>` in the current scope (function or associated item not found in `vstd::seq::Seq<_>`)", "message": "VerusErrorType.Other: no function or associated item named `from_vec` found for struct `vstd::seq::Seq<A>` in the current scope (function or associated item not found in `vstd::seq::Seq<_>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpyky2gc7y", "lines": [52, 52], "label": "function or associated item not found in `vstd::seq::Seq<_>`", "text": [{"text": "        valid_tree_input(n as int, Seq::from_vec(edges).map(|i, e| (e.0 as int, e.1 as int))),", "highlight_start": 41, "highlight_end": 49}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 73, "minimized_LOC": 73, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_connected_tree(n: int, edges: Seq<(int, int)>) -> bool {\n\nspec fn is_connected_graph(n: int, edges: Seq<(int, int)>) -> bool {\n\nspec fn can_reach_node_one(target: int, edges: Seq<(int, int)>, max_depth: int) -> bool\n        decreases max_depth\n    {\n\nspec fn valid_tree_input(n: int, edges: Seq<(int, int)>) -> bool {\n\n        decreases max_depth\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_2133_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_tree_input(input: Seq<char>) -> bool {\n  let lines = split_lines(input);\n  lines.len() >= 2 &&\n  {\n    let n = parse_int(lines[0]);\n    n >= 1 && n <= 200000 &&\n    lines.len() == n + 1 &&\n    valid_color_line(lines[1], n) &&\n    valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&\n    {\n      let edges = Seq::new((lines.len() - 2) as nat, |i: int| {\n        let edge = parse_int_seq(lines[i + 2]);\n        (edge[0], edge[1])\n      });\n      is_valid_tree(n, edges)\n    }\n  }\n}\n\nspec fn valid_color_line(line: Seq<char>, n: int) -> bool {\n  let colors = parse_int_seq(line);\n  colors.len() == n &&\n  forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == 0 || colors[i] == 1\n}\n\nspec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool {\n  lines.len() == n - 1 &&\n  forall|i: int| #![trigger lines[i]] 0 <= i < lines.len() ==> {\n    let edge = parse_int_seq(lines[i]);\n    edge.len() == 2 && \n    1 <= edge[0] <= n && \n    1 <= edge[1] <= n && \n    edge[0] != edge[1]\n  }\n}\n\nspec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool {\n  n >= 1 &&\n  edges.len() == n - 1 &&\n  is_connected(n, edges) &&\n  (forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1) &&\n  no_duplicate_edges(edges)\n}\n\nspec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool {\n  true\n}\n\nspec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool {\n  forall|i: int, j: int| #![trigger edges[i], edges[j]] 0 <= i < j < edges.len() ==> \n    edges[i] != edges[j] && \n    (edges[i].0, edges[i].1) != (edges[j].1, edges[j].0)\n}\n\nspec fn valid_integer_output(output: Seq<char>) -> bool {\n  let trimmed = trim_whitespace(output);\n  trimmed.len() > 0 &&\n  forall|c: char| trimmed.contains(c) ==> '0' <= c <= '9'\n}\n\nspec fn all_same_color(colors: Seq<int>) -> bool {\n  colors.len() > 0 ==> forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == colors[0]\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<int>, Seq<(int, int)>) {\n  let lines = split_lines(input);\n  let n = parse_int(lines[0]);\n  let colors = parse_int_seq(lines[1]);\n  let edges = Seq::new((lines.len() - 2) as nat, |i: int| {\n    let edge = parse_int_seq(lines[i + 2]);\n    (edge[0], edge[1])\n  });\n  (n, colors, edges)\n}\n\nspec fn parse_output(output: Seq<char>) -> int {\n  parse_int(trim_whitespace(output))\n}\n\nspec fn compute_min_paint_ops(n: int, colors: Seq<int>, edges: Seq<(int, int)>) -> int {\n  if all_same_color(colors) {\n    0\n  } else {\n    let components = build_same_color_components(colors, edges);\n    let component_graph = build_component_graph(components, colors, edges);\n    (tree_diameter(component_graph) + 1) / 2\n  }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn parse_int(line: Seq<char>) -> int { 0 }\nspec fn parse_int_seq(line: Seq<char>) -> Seq<int> { Seq::empty() }\nspec fn trim_whitespace(output: Seq<char>) -> Seq<char> { output }\nspec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> { Seq::empty() }\nspec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> { Seq::empty() }\nspec fn tree_diameter(graph: Seq<(int, int)>) -> int { 0 }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n  requires \n    stdin_input@ .len() > 0,\n    valid_tree_input(stdin_input@),\n  ensures \n    output@ .len() > 0,\n    valid_integer_output(output@),\n    ({\n      let result = parse_output(output@);\n      result >= 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      n >= 1 ==> {\n        let result = parse_output(output@);\n        result <= n\n      }\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      all_same_color(colors) ==> parse_output(output@) == 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      n == 1 ==> parse_output(output@) == 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      is_valid_tree(n, edges) && n >= 1\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      let result = parse_output(output@);\n      result == compute_min_paint_ops(n, colors, edges)\n    }),\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_tree_input(input: Seq<char>) -> bool {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&   {\n         let n = parse_int(lines[0]);\n         n >= 1 && n <= 200000 &&     lines.len() == n + 1 &&     valid_color_line(lines[1], n) &&     valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&     {\n          let edges = Seq::new(0 as nat, |i: int| {\n           let edge = parse_int_seq(lines[i + 2]);\n           (edge[0], edge[1])       }\n   );\n          is_valid_tree(n, edges)     }\n       }\n      }\n       spec fn valid_color_line(line: Seq<char>, n: int) -> bool ;\n       spec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool ;\n        spec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;\n        spec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n       0 }\n        spec fn parse_int_seq(line: Seq<char>) -> Seq<int> ;\n        spec fn trim_whitespace(output: Seq<char>) -> Seq<char> ;\n        spec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> ;\n        spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> ;\n        spec fn tree_diameter(graph: Seq<(int, int)>) -> int ;\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n             let result = parse_output(output@);\n             result >= 0     }\n       ), {\n         unreached() }\n        }\n        fn main() {\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2133.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1054, "minimize_time_ms": 184761, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 156, "minimized_LOC": 38, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.24358974358974358}, "labeling": {"segments": {"exec": " fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n\n fn main() {", "spec": "spec fn valid_tree_input(input: Seq<char>) -> bool {\n\nspec fn valid_color_line(line: Seq<char>, n: int) -> bool ;\n       spec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool ;\n        spec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;\n        spec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool ;\n        spec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;\n        spec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;\n        spec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;\n        spec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;\n        spec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n\nspec fn parse_int(line: Seq<char>) -> int {\n\nspec fn parse_int_seq(line: Seq<char>) -> Seq<int> ;\n        spec fn trim_whitespace(output: Seq<char>) -> Seq<char> ;\n        spec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> ;\n        spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> ;\n        spec fn tree_diameter(graph: Seq<(int, int)>) -> int ;\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n\nspec fn trim_whitespace(output: Seq<char>) -> Seq<char> ;\n        spec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> ;\n        spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> ;\n        spec fn tree_diameter(graph: Seq<(int, int)>) -> int ;\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n\nspec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> ;\n        spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> ;\n        spec fn tree_diameter(graph: Seq<(int, int)>) -> int ;\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n\nspec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> ;\n        spec fn tree_diameter(graph: Seq<(int, int)>) -> int ;\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n\nspec fn tree_diameter(graph: Seq<(int, int)>) -> int ;\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_tree_input(input: Seq<char>) -> bool {\n  let lines = split_lines(input);\n  lines.len() >= 2 &&\n  {\n    let n = parse_int(lines[0]);\n    n >= 1 && n <= 200000 &&\n    lines.len() == n + 1 &&\n    valid_color_line(lines[1], n) &&\n    valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&\n    {\n      let edges = Seq::new((lines.len() - 2) as nat, |i: int| {\n        let edge = parse_int_seq(lines[i + 2]);\n        (edge[0], edge[1])\n      });\n      is_valid_tree(n, edges)\n    }\n  }\n}\n\nspec fn valid_color_line(line: Seq<char>, n: int) -> bool {\n  let colors = parse_int_seq(line);\n  colors.len() == n &&\n  forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == 0 || colors[i] == 1\n}\n\nspec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool {\n  lines.len() == n - 1 &&\n  forall|i: int| #![trigger lines[i]] 0 <= i < lines.len() ==> {\n    let edge = parse_int_seq(lines[i]);\n    edge.len() == 2 && \n    1 <= edge[0] <= n && \n    1 <= edge[1] <= n && \n    edge[0] != edge[1]\n  }\n}\n\nspec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool {\n  n >= 1 &&\n  edges.len() == n - 1 &&\n  is_connected(n, edges) &&\n  (forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1) &&\n  no_duplicate_edges(edges)\n}\n\nspec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool {\n  true\n}\n\nspec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool {\n  forall|i: int, j: int| #![trigger edges[i], edges[j]] 0 <= i < j < edges.len() ==> \n    edges[i] != edges[j] && \n    (edges[i].0, edges[i].1) != (edges[j].1, edges[j].0)\n}\n\nspec fn valid_integer_output(output: Seq<char>) -> bool {\n  let trimmed = trim_whitespace(output);\n  trimmed.len() > 0 &&\n  forall|c: char| trimmed.contains(c) ==> '0' <= c <= '9'\n}\n\nspec fn all_same_color(colors: Seq<int>) -> bool {\n  colors.len() > 0 ==> forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == colors[0]\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<int>, Seq<(int, int)>) {\n  let lines = split_lines(input);\n  let n = parse_int(lines[0]);\n  let colors = parse_int_seq(lines[1]);\n  let edges = Seq::new((lines.len() - 2) as nat, |i: int| {\n    let edge = parse_int_seq(lines[i + 2]);\n    (edge[0], edge[1])\n  });\n  (n, colors, edges)\n}\n\nspec fn parse_output(output: Seq<char>) -> int {\n  parse_int(trim_whitespace(output))\n}\n\nspec fn compute_min_paint_ops(n: int, colors: Seq<int>, edges: Seq<(int, int)>) -> int {\n  if all_same_color(colors) {\n    0\n  } else {\n    let components = build_same_color_components(colors, edges);\n    let component_graph = build_component_graph(components, colors, edges);\n    (tree_diameter(component_graph) + 1) / 2\n  }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn parse_int(line: Seq<char>) -> int { 0 }\nspec fn parse_int_seq(line: Seq<char>) -> Seq<int> { Seq::empty() }\nspec fn trim_whitespace(output: Seq<char>) -> Seq<char> { output }\nspec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> { Seq::empty() }\nspec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> { Seq::empty() }\nspec fn tree_diameter(graph: Seq<(int, int)>) -> int { 0 }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n  requires \n    stdin_input@ .len() > 0,\n    valid_tree_input(stdin_input@),\n  ensures \n    output@ .len() > 0,\n    valid_integer_output(output@),\n    ({\n      let result = parse_output(output@);\n      result >= 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      n >= 1 ==> {\n        let result = parse_output(output@);\n        result <= n\n      }\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      all_same_color(colors) ==> parse_output(output@) == 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      n == 1 ==> parse_output(output@) == 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      is_valid_tree(n, edges) && n >= 1\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      let result = parse_output(output@);\n      result == compute_min_paint_ops(n, colors, edges)\n    }),\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_tree_input(input: Seq<char>) -> bool {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&   {\n         let n = parse_int(lines[0]);\n         n >= 1 && n <= 200000 &&     lines.len() == n + 1 &&     valid_color_line(lines[1], n) &&     valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&     {\n          let edges = Seq::new(0 as nat, |i: int| {\n           let edge = parse_int_seq(lines[i + 2]);\n           (edge[0], edge[1])       }\n   );\n          is_valid_tree(n, edges)     }\n       }\n      }\n       spec fn valid_color_line(line: Seq<char>, n: int) -> bool ;\n       spec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool ;\n        spec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;\n        spec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n       0 }\n        spec fn parse_int_seq(line: Seq<char>) -> Seq<int> ;\n        spec fn trim_whitespace(output: Seq<char>) -> Seq<char> ;\n        spec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> ;\n        spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> ;\n        spec fn tree_diameter(graph: Seq<(int, int)>) -> int ;\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n             let result = parse_output(output@);\n             result >= 0     }\n       ), {\n         unreached() }\n        }\n        fn main() {\n       }\n", "use vstd::*;\nfn main() {}\n", "use vstd;\n  fn main() {\n}\n"]}
{"id": "apps_test_2168_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_company_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 1 && \n    is_valid_positive_int(lines[0]) &&\n    {\n        let n = parse_int_func(lines[0]);\n        n >= 1 && lines.len() >= n + 1 &&\n        (forall|i: int| #![auto] 1 <= i <= n ==> valid_company_line(lines[i]))\n    }\n}\n\nspec fn valid_company_line(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() >= 1 && is_valid_positive_int(parts[0]) &&\n    {\n        let m = parse_int_func(parts[0]);\n        m >= 1 && parts.len() == m + 1 &&\n        (forall|j: int| #![auto] 1 <= j <= m ==> is_valid_positive_int(parts[j]))\n    }\n}\n\nspec fn is_valid_positive_int(s: Seq<char>) -> bool {\n    s.len() >= 1 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {\n    let lines = split_lines_func(input);\n    let n = parse_int_func(lines[0]);\n    Seq::new(n as nat, |i: int| {\n        let parts = split_spaces_func(lines[i + 1]);\n        let m = parse_int_func(parts[0]);\n        Seq::new(m as nat, |j: int| parse_int_func(parts[j + 1]))\n    })\n}\n\nspec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {\n    let global_max = global_max_salary(companies);\n    sum_over_companies(companies, global_max)\n}\n\nspec fn global_max_salary(companies: Seq<Seq<int>>) -> int {\n    max_in_seq_of_seq(Seq::new(companies.len(), |i: int| max_in_seq_func(companies[i])))\n}\n\nspec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int\n    decreases companies.len()\n{\n    if companies.len() == 0 {\n        0\n    } else if companies.len() == 1 {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len()\n    } else {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len() + sum_over_companies(companies.subrange(1, companies.len() as int), global_max)\n    }\n}\n\nspec fn max_in_seq_func(s: Seq<int>) -> int {\n    if s.len() > 0 {\n        max_in_seq(s)\n    } else {\n        0\n    }\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn max_in_seq_of_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq_of_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: int)\n    requires\n        input@.len() > 0,\n        valid_company_input(input@),\n    ensures\n        result >= 0,\n        result == calculate_minimum_increase(parse_companies(input@)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_company_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 1 && \n    is_valid_positive_int(lines[0]) &&\n    {\n        let n = parse_int_func(lines[0]);\n        n >= 1 && lines.len() >= n + 1 &&\n        (forall|i: int| #![auto] 1 <= i <= n ==> valid_company_line(lines[i]))\n    }\n}\n\nspec fn valid_company_line(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() >= 1 && is_valid_positive_int(parts[0]) &&\n    {\n        let m = parse_int_func(parts[0]);\n        m >= 1 && parts.len() == m + 1 &&\n        (forall|j: int| #![auto] 1 <= j <= m ==> is_valid_positive_int(parts[j]))\n    }\n}\n\nspec fn is_valid_positive_int(s: Seq<char>) -> bool {\n    s.len() >= 1 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {\n    let lines = split_lines_func(input);\n    let n = parse_int_func(lines[0]);\n    Seq::new(n as nat, |i: int| {\n        let parts = split_spaces_func(lines[i + 1]);\n        let m = parse_int_func(parts[0]);\n        Seq::new(m as nat, |j: int| parse_int_func(parts[j + 1]))\n    })\n}\n\nspec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {\n    let global_max = global_max_salary(companies);\n    sum_over_companies(companies, global_max)\n}\n\nspec fn global_max_salary(companies: Seq<Seq<int>>) -> int {\n    max_in_seq_of_seq(Seq::new(companies.len(), |i: int| max_in_seq_func(companies[i])))\n}\n\nspec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int\n    decreases companies.len()\n{\n    if companies.len() == 0 {\n        0\n    } else if companies.len() == 1 {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len()\n    } else {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len() + sum_over_companies(companies.subrange(1, companies.len() as int), global_max)\n    }\n}\n\nspec fn max_in_seq_func(s: Seq<int>) -> int {\n    if s.len() > 0 {\n        max_in_seq(s)\n    } else {\n        0\n    }\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn max_in_seq_of_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq_of_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: int)\n    requires\n        input@.len() > 0,\n        valid_company_input(input@),\n    ensures\n        result >= 0,\n        result == calculate_minimum_increase(parse_companies(input@)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2168.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 895, "minimize_time_ms": 123572, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 145, "minimized_LOC": 145, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 21, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_company_input(input: Seq<char>) -> bool {\n\nspec fn valid_company_line(line: Seq<char>) -> bool {\n\nspec fn is_valid_positive_int(s: Seq<char>) -> bool {\n\nspec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {\n\nspec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {\n\nspec fn global_max_salary(companies: Seq<Seq<int>>) -> int {\n\nspec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int\n    decreases companies.len()\n{\n\nspec fn max_in_seq_func(s: Seq<int>) -> int {\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn max_in_seq_of_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n\n    decreases companies.len()\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_company_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 1 && \n    is_valid_positive_int(lines[0]) &&\n    {\n        let n = parse_int_func(lines[0]);\n        n >= 1 && lines.len() >= n + 1 &&\n        (forall|i: int| #![auto] 1 <= i <= n ==> valid_company_line(lines[i]))\n    }\n}\n\nspec fn valid_company_line(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() >= 1 && is_valid_positive_int(parts[0]) &&\n    {\n        let m = parse_int_func(parts[0]);\n        m >= 1 && parts.len() == m + 1 &&\n        (forall|j: int| #![auto] 1 <= j <= m ==> is_valid_positive_int(parts[j]))\n    }\n}\n\nspec fn is_valid_positive_int(s: Seq<char>) -> bool {\n    s.len() >= 1 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {\n    let lines = split_lines_func(input);\n    let n = parse_int_func(lines[0]);\n    Seq::new(n as nat, |i: int| {\n        let parts = split_spaces_func(lines[i + 1]);\n        let m = parse_int_func(parts[0]);\n        Seq::new(m as nat, |j: int| parse_int_func(parts[j + 1]))\n    })\n}\n\nspec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {\n    let global_max = global_max_salary(companies);\n    sum_over_companies(companies, global_max)\n}\n\nspec fn global_max_salary(companies: Seq<Seq<int>>) -> int {\n    max_in_seq_of_seq(Seq::new(companies.len(), |i: int| max_in_seq_func(companies[i])))\n}\n\nspec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int\n    decreases companies.len()\n{\n    if companies.len() == 0 {\n        0\n    } else if companies.len() == 1 {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len()\n    } else {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len() + sum_over_companies(companies.subrange(1, companies.len() as int), global_max)\n    }\n}\n\nspec fn max_in_seq_func(s: Seq<int>) -> int {\n    if s.len() > 0 {\n        max_in_seq(s)\n    } else {\n        0\n    }\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn max_in_seq_of_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq_of_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: int)\n    requires\n        input@.len() > 0,\n        valid_company_input(input@),\n    ensures\n        result >= 0,\n        result == calculate_minimum_increase(parse_companies(input@)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n         verus! {}\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2195_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let t = string_to_int(lines[0]);\n        t >= 0 &&\n        lines.len() >= 1 + 2 * t &&\n        forall|i: int| 0 <= i < t ==> {\n            let line1_idx = 1 + 2 * i;\n            let line2_idx = 1 + 2 * i + 1;\n            line1_idx < lines.len() && line2_idx < lines.len() &&\n            {\n                let xy_parts = split_whitespace(lines[line1_idx]);\n                let ab_parts = split_whitespace(lines[line2_idx]);\n                xy_parts.len() >= 2 && ab_parts.len() >= 2 &&\n                is_valid_integer(xy_parts[0]) &&\n                is_valid_integer(xy_parts[1]) &&\n                is_valid_integer(ab_parts[0]) &&\n                is_valid_integer(ab_parts[1]) &&\n                string_to_int(xy_parts[0]) >= 0 &&\n                string_to_int(xy_parts[1]) >= 0 &&\n                string_to_int(ab_parts[0]) >= 1 &&\n                string_to_int(ab_parts[1]) >= 1\n            }\n        }\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() == 0 {\n        output.len() == 0\n    } else {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == (if t == 0 { 0 } else { t }) &&\n        forall|i: int| 0 <= i < output_lines.len() ==> is_valid_integer(output_lines[i])\n    }\n}\n\nspec fn correct_computation(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() == 0 {\n        output.len() == 0\n    } else {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == (if t == 0 { 0 } else { t }) &&\n        forall|i: int| 0 <= i < t && 1 + 2 * i + 1 < lines.len() ==> {\n            let xy_line = split_whitespace(lines[1 + 2 * i]);\n            let ab_line = split_whitespace(lines[1 + 2 * i + 1]);\n            (xy_line.len() >= 2 && ab_line.len() >= 2) ==> {\n                let x = string_to_int(xy_line[0]);\n                let y = string_to_int(xy_line[1]);\n                let a = string_to_int(ab_line[0]);\n                let b = string_to_int(ab_line[1]);\n                let expected_result = if b <= 2 * a {\n                    b * (if x <= y { x } else { y }) + (if x >= y { x } else { y } - if x <= y { x } else { y }) * a\n                } else {\n                    a * (x + y)\n                };\n                i < output_lines.len() && string_to_int(output_lines[i]) == expected_result\n            }\n        }\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 &&\n    (s[0] == '-' ==> s.len() > 1) &&\n    forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        Seq::empty()\n    } else {\n        split_by_char(s, '\\n')\n    }\n}\n\nspec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        Seq::empty()\n    } else {\n        split_by_char(s, ' ')\n    }\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![Seq::empty()]\n    } else if s[0] == delimiter {\n        seq![Seq::empty()].add(split_by_char(s.subrange(1, s.len() as int), delimiter))\n    } else {\n        let rest = split_by_char(s.subrange(1, s.len() as int), delimiter);\n        if rest.len() == 0 {\n            seq![s]\n        } else {\n            seq![s.subrange(0, 1).add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' && s.len() > 1 {\n        -string_to_int_helper(s.subrange(1, s.len() as int))\n    } else {\n        string_to_int_helper(s)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        if '0' <= s[0] <= '9' { s[0] as int - '0' as int } else { 0 }\n    } else {\n        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 +\n        (if '0' <= s[s.len() - 1] <= '9' { s[s.len() - 1] as int - '0' as int } else { 0 })\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'].add(int_to_string_helper(-n))\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        Seq::empty()\n    } else {\n        let digit_char = ((n % 10) + ('0' as int)) as char;\n        int_to_string_helper(n / 10).push(digit_char)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (output: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@),\n    ensures\n        valid_output(output@, input@),\n        correct_computation(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let t = string_to_int(lines[0]);\n        t >= 0 &&\n        lines.len() >= 1 + 2 * t &&\n        forall|i: int| 0 <= i < t ==> {\n            let line1_idx = 1 + 2 * i;\n            let line2_idx = 1 + 2 * i + 1;\n            line1_idx < lines.len() && line2_idx < lines.len() &&\n            {\n                let xy_parts = split_whitespace(lines[line1_idx]);\n                let ab_parts = split_whitespace(lines[line2_idx]);\n                xy_parts.len() >= 2 && ab_parts.len() >= 2 &&\n                is_valid_integer(xy_parts[0]) &&\n                is_valid_integer(xy_parts[1]) &&\n                is_valid_integer(ab_parts[0]) &&\n                is_valid_integer(ab_parts[1]) &&\n                string_to_int(xy_parts[0]) >= 0 &&\n                string_to_int(xy_parts[1]) >= 0 &&\n                string_to_int(ab_parts[0]) >= 1 &&\n                string_to_int(ab_parts[1]) >= 1\n            }\n        }\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() == 0 {\n        output.len() == 0\n    } else {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == (if t == 0 { 0 } else { t }) &&\n        forall|i: int| 0 <= i < output_lines.len() ==> is_valid_integer(output_lines[i])\n    }\n}\n\nspec fn correct_computation(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() == 0 {\n        output.len() == 0\n    } else {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == (if t == 0 { 0 } else { t }) &&\n        forall|i: int| 0 <= i < t && 1 + 2 * i + 1 < lines.len() ==> {\n            let xy_line = split_whitespace(lines[1 + 2 * i]);\n            let ab_line = split_whitespace(lines[1 + 2 * i + 1]);\n            (xy_line.len() >= 2 && ab_line.len() >= 2) ==> {\n                let x = string_to_int(xy_line[0]);\n                let y = string_to_int(xy_line[1]);\n                let a = string_to_int(ab_line[0]);\n                let b = string_to_int(ab_line[1]);\n                let expected_result = if b <= 2 * a {\n                    b * (if x <= y { x } else { y }) + (if x >= y { x } else { y } - if x <= y { x } else { y }) * a\n                } else {\n                    a * (x + y)\n                };\n                i < output_lines.len() && string_to_int(output_lines[i]) == expected_result\n            }\n        }\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 &&\n    (s[0] == '-' ==> s.len() > 1) &&\n    forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        Seq::empty()\n    } else {\n        split_by_char(s, '\\n')\n    }\n}\n\nspec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        Seq::empty()\n    } else {\n        split_by_char(s, ' ')\n    }\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![Seq::empty()]\n    } else if s[0] == delimiter {\n        seq![Seq::empty()].add(split_by_char(s.subrange(1, s.len() as int), delimiter))\n    } else {\n        let rest = split_by_char(s.subrange(1, s.len() as int), delimiter);\n        if rest.len() == 0 {\n            seq![s]\n        } else {\n            seq![s.subrange(0, 1).add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' && s.len() > 1 {\n        -string_to_int_helper(s.subrange(1, s.len() as int))\n    } else {\n        string_to_int_helper(s)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        if '0' <= s[0] <= '9' { s[0] as int - '0' as int } else { 0 }\n    } else {\n        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 +\n        (if '0' <= s[s.len() - 1] <= '9' { s[s.len() - 1] as int - '0' as int } else { 0 })\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'].add(int_to_string_helper(-n))\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        Seq::empty()\n    } else {\n        let digit_char = ((n % 10) + ('0' as int)) as char;\n        int_to_string_helper(n / 10).push(digit_char)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (output: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@),\n    ensures\n        valid_output(output@, input@),\n        correct_computation(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2195.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 632, "verus_errors": [{"error_type": "Other", "error_text": "recursive function must have a decreases clause ()", "message": "VerusErrorType.Other: recursive function must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpt18ykey4", "lines": [96, 96], "label": null, "text": [{"text": "spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {", "highlight_start": 6, "highlight_end": 71}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 178, "minimized_LOC": 178, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn correct_computation(input: Seq<char>, output: Seq<char>) -> bool {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn string_to_int_helper(s: Seq<char>) -> int {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n{\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_2219_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn min_steps_to_zero(n: nat, k: nat) -> nat {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    {\n        let lines = split_lines_func(input);\n        lines.len() >= 1 &&\n        is_valid_number(lines[0]) && {\n            let t = string_to_int_func(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() >= t + 1 &&\n            forall|i: int| 1 <= i <= t ==> valid_test_case(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn valid_test_case(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() == 2 &&\n    is_valid_number(parts[0]) &&\n    is_valid_number(parts[1]) && {\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        n >= 1 && k >= 2\n    }\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() >= 1 &&\n    (s =~= seq!['0'] || (s[0] != '0' && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9')) &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_lines_func(input);\n    let t = string_to_int_func(lines[0]);\n    let results = Seq::new(t as nat, |i: int| {\n        let parts = split_spaces_func(lines[i+1]);\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        nat_to_string_func(min_steps_to_zero(n as nat, k as nat))\n    });\n    join_lines_seq(results)\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn nat_to_string_func(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn min_steps_to_zero(n: nat, k: nat) -> nat {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    {\n        let lines = split_lines_func(input);\n        lines.len() >= 1 &&\n        is_valid_number(lines[0]) && {\n            let t = string_to_int_func(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() >= t + 1 &&\n            forall|i: int| 1 <= i <= t ==> valid_test_case(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn valid_test_case(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() == 2 &&\n    is_valid_number(parts[0]) &&\n    is_valid_number(parts[1]) && {\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        n >= 1 && k >= 2\n    }\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() >= 1 &&\n    (s =~= seq!['0'] || (s[0] != '0' && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9')) &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_lines_func(input);\n    let t = string_to_int_func(lines[0]);\n    let results = Seq::new(t as nat, |i: int| {\n        let parts = split_spaces_func(lines[i+1]);\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        nat_to_string_func(min_steps_to_zero(n as nat, k as nat))\n    });\n    join_lines_seq(results)\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn nat_to_string_func(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2219.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 764, "minimize_time_ms": 153408, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 94, "minimized_LOC": 94, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn min_steps_to_zero(n: nat, k: nat) -> nat {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_test_case(line: Seq<char>) -> bool {\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n\nspec fn nat_to_string_func(n: nat) -> Seq<char> {\n\nspec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn min_steps_to_zero(n: nat, k: nat) -> nat {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    {\n        let lines = split_lines_func(input);\n        lines.len() >= 1 &&\n        is_valid_number(lines[0]) && {\n            let t = string_to_int_func(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() >= t + 1 &&\n            forall|i: int| 1 <= i <= t ==> valid_test_case(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn valid_test_case(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() == 2 &&\n    is_valid_number(parts[0]) &&\n    is_valid_number(parts[1]) && {\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        n >= 1 && k >= 2\n    }\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() >= 1 &&\n    (s =~= seq!['0'] || (s[0] != '0' && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9')) &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_lines_func(input);\n    let t = string_to_int_func(lines[0]);\n    let results = Seq::new(t as nat, |i: int| {\n        let parts = split_spaces_func(lines[i+1]);\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        nat_to_string_func(min_steps_to_zero(n as nat, k as nat))\n    });\n    join_lines_seq(results)\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn nat_to_string_func(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2252_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && \n    {\n        let first_line = parse_integers(lines[0]);\n        first_line.len() == 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 0 &&\n            parse_integers(lines[1]).len() == n &&\n            is_valid_permutation(parse_integers(lines[1]), n) &&\n            lines.len() == 2 + m &&\n            (forall|i: int| 2 <= i < lines.len() ==> {\n                let query = parse_integers(#[trigger] lines[i]);\n                query.len() == 3 &&\n                {\n                    let l = query[0];\n                    let r = query[1];\n                    let x = query[2];\n                    1 <= l <= x <= r <= n\n                }\n            })\n        }\n    }\n}\n\nspec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {\n    p.len() == n && \n    (forall|i: int| 0 <= i < p.len() ==> 1 <= #[trigger] p[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < p.len() ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    let lines = split_lines(output);\n    forall|line: Seq<char>| #[trigger] lines.contains(line) ==> (seq_equals(line, seq!['Y','e','s']) || seq_equals(line, seq!['N','o']))\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == s2[i]\n}\n\nspec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_lines(input);\n    let output_lines = split_lines(output);\n    if input_lines.len() < 2 { false }\n    else {\n        let first_line = parse_integers(input_lines[0]);\n        if first_line.len() != 2 { false }\n        else {\n            let n = first_line[0];\n            let m = first_line[1];\n            input_lines.len() == 2 + m &&\n            output_lines.len() == m &&\n            {\n                let p = parse_integers(input_lines[1]);\n                forall|i: int| 0 <= i < m ==> {\n                    let query = parse_integers(input_lines[2 + i]);\n                    let l = query[0];\n                    let r = query[1]; \n                    let x = query[2];\n                    let px = p[x - 1];\n                    let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);\n                    seq_equals(#[trigger] output_lines[i], if cnt == x { seq!['Y','e','s'] } else { seq!['N','o'] })\n                }\n            }\n        }\n    }\n}\n\nspec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int\n    decreases if start <= end { end - start + 1 } else { 0 }\n{\n    if start > end { 0int }\n    else if start < 0 || start >= p.len() { 0int }\n    else { (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value) }\n}\n\nspec fn parse_integers(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else {\n        let idx = find_newline(s, 0);\n        if idx == -1 { seq![s] }\n        else if idx >= 0 && idx < s.len() && idx + 1 <= s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx+1, s.len() as int)))\n        } else { seq![s] }\n    }\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start as int] == '\\n' { start as int }\n    else { find_newline(s, start + 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && \n    {\n        let first_line = parse_integers(lines[0]);\n        first_line.len() == 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 0 &&\n            parse_integers(lines[1]).len() == n &&\n            is_valid_permutation(parse_integers(lines[1]), n) &&\n            lines.len() == 2 + m &&\n            (forall|i: int| 2 <= i < lines.len() ==> {\n                let query = parse_integers(#[trigger] lines[i]);\n                query.len() == 3 &&\n                {\n                    let l = query[0];\n                    let r = query[1];\n                    let x = query[2];\n                    1 <= l <= x <= r <= n\n                }\n            })\n        }\n    }\n}\n\nspec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {\n    p.len() == n && \n    (forall|i: int| 0 <= i < p.len() ==> 1 <= #[trigger] p[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < p.len() ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    let lines = split_lines(output);\n    forall|line: Seq<char>| #[trigger] lines.contains(line) ==> (seq_equals(line, seq!['Y','e','s']) || seq_equals(line, seq!['N','o']))\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == s2[i]\n}\n\nspec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_lines(input);\n    let output_lines = split_lines(output);\n    if input_lines.len() < 2 { false }\n    else {\n        let first_line = parse_integers(input_lines[0]);\n        if first_line.len() != 2 { false }\n        else {\n            let n = first_line[0];\n            let m = first_line[1];\n            input_lines.len() == 2 + m &&\n            output_lines.len() == m &&\n            {\n                let p = parse_integers(input_lines[1]);\n                forall|i: int| 0 <= i < m ==> {\n                    let query = parse_integers(input_lines[2 + i]);\n                    let l = query[0];\n                    let r = query[1]; \n                    let x = query[2];\n                    let px = p[x - 1];\n                    let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);\n                    seq_equals(#[trigger] output_lines[i], if cnt == x { seq!['Y','e','s'] } else { seq!['N','o'] })\n                }\n            }\n        }\n    }\n}\n\nspec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int\n    decreases if start <= end { end - start + 1 } else { 0 }\n{\n    if start > end { 0int }\n    else if start < 0 || start >= p.len() { 0int }\n    else { (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value) }\n}\n\nspec fn parse_integers(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else {\n        let idx = find_newline(s, 0);\n        if idx == -1 { seq![s] }\n        else if idx >= 0 && idx < s.len() && idx + 1 <= s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx+1, s.len() as int)))\n        } else { seq![s] }\n    }\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start as int] == '\\n' { start as int }\n    else { find_newline(s, start + 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2252.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 899, "minimize_time_ms": 183813, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 128, "minimized_LOC": 128, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n\nspec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {\n\nspec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int\n    decreases if start <= end {\n\nspec fn parse_integers(line: Seq<char>) -> Seq<int> {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n\nspec fn find_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n\n    decreases if start <= end { end - start + 1 } else { 0 }\n\n    decreases s.len()\n\n    decreases s.len() - start"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && \n    {\n        let first_line = parse_integers(lines[0]);\n        first_line.len() == 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 0 &&\n            parse_integers(lines[1]).len() == n &&\n            is_valid_permutation(parse_integers(lines[1]), n) &&\n            lines.len() == 2 + m &&\n            (forall|i: int| 2 <= i < lines.len() ==> {\n                let query = parse_integers(#[trigger] lines[i]);\n                query.len() == 3 &&\n                {\n                    let l = query[0];\n                    let r = query[1];\n                    let x = query[2];\n                    1 <= l <= x <= r <= n\n                }\n            })\n        }\n    }\n}\n\nspec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {\n    p.len() == n && \n    (forall|i: int| 0 <= i < p.len() ==> 1 <= #[trigger] p[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < p.len() ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    let lines = split_lines(output);\n    forall|line: Seq<char>| #[trigger] lines.contains(line) ==> (seq_equals(line, seq!['Y','e','s']) || seq_equals(line, seq!['N','o']))\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == s2[i]\n}\n\nspec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_lines(input);\n    let output_lines = split_lines(output);\n    if input_lines.len() < 2 { false }\n    else {\n        let first_line = parse_integers(input_lines[0]);\n        if first_line.len() != 2 { false }\n        else {\n            let n = first_line[0];\n            let m = first_line[1];\n            input_lines.len() == 2 + m &&\n            output_lines.len() == m &&\n            {\n                let p = parse_integers(input_lines[1]);\n                forall|i: int| 0 <= i < m ==> {\n                    let query = parse_integers(input_lines[2 + i]);\n                    let l = query[0];\n                    let r = query[1]; \n                    let x = query[2];\n                    let px = p[x - 1];\n                    let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);\n                    seq_equals(#[trigger] output_lines[i], if cnt == x { seq!['Y','e','s'] } else { seq!['N','o'] })\n                }\n            }\n        }\n    }\n}\n\nspec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int\n    decreases if start <= end { end - start + 1 } else { 0 }\n{\n    if start > end { 0int }\n    else if start < 0 || start >= p.len() { 0int }\n    else { (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value) }\n}\n\nspec fn parse_integers(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else {\n        let idx = find_newline(s, 0);\n        if idx == -1 { seq![s] }\n        else if idx >= 0 && idx < s.len() && idx + 1 <= s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx+1, s.len() as int)))\n        } else { seq![s] }\n    }\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start as int] == '\\n' { start as int }\n    else { find_newline(s, start + 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_232_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(s: Seq<nat>, value: nat) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == value {\n        1 + count_occurrences(s.subrange(1, s.len() as int), value)\n    } else {\n        count_occurrences(s.subrange(1, s.len() as int), value)\n    }\n}\n\nspec fn sum_seq(s: Seq<nat>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn subarray_matches_desired(subarray: Seq<nat>, desired: Seq<nat>, m: nat) -> bool\n{\n    desired.len() == m &&\n    forall|color: nat| #[trigger] count_occurrences(subarray, color) == desired[color as int - 1] && 1 <= color <= m\n}\n\nspec fn valid_input(n: nat, m: nat, colors: Seq<nat>, desired: Seq<nat>) -> bool\n{\n    colors.len() == n &&\n    desired.len() == m &&\n    (forall|i: int| #[trigger] colors[i] >= 1 && colors[i] <= m && 0 <= i < colors.len()) &&\n    (forall|i: int| #[trigger] desired[i] >= 0 && 0 <= i < desired.len()) &&\n    sum_seq(desired) <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, m: u8, colors: Vec<u8>, desired: Vec<u8>) -> (result: String)\n    requires\n        valid_input(n as nat, m as nat, colors@.map(|i, x| x as nat), desired@.map(|i, x| x as nat)),\n    ensures\n        result@ == seq!['Y' as char, 'E' as char, 'S' as char] <==> exists|i: int, j: int| 0 <= i <= j < n as int && #[trigger] subarray_matches_desired(colors@.map(|k, x| x as nat).subrange(i, j + 1), desired@.map(|k, x| x as nat), m as nat),\n        result@ == seq!['Y' as char, 'E' as char, 'S' as char] || result@ == seq!['N' as char, 'O' as char],\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(s: Seq<nat>, value: nat) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == value {\n        1 + count_occurrences(s.subrange(1, s.len() as int), value)\n    } else {\n        count_occurrences(s.subrange(1, s.len() as int), value)\n    }\n}\n\nspec fn sum_seq(s: Seq<nat>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn subarray_matches_desired(subarray: Seq<nat>, desired: Seq<nat>, m: nat) -> bool\n{\n    desired.len() == m &&\n    forall|color: nat| #[trigger] count_occurrences(subarray, color) == desired[color as int - 1] && 1 <= color <= m\n}\n\nspec fn valid_input(n: nat, m: nat, colors: Seq<nat>, desired: Seq<nat>) -> bool\n{\n    colors.len() == n &&\n    desired.len() == m &&\n    (forall|i: int| #[trigger] colors[i] >= 1 && colors[i] <= m && 0 <= i < colors.len()) &&\n    (forall|i: int| #[trigger] desired[i] >= 0 && 0 <= i < desired.len()) &&\n    sum_seq(desired) <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, m: u8, colors: Vec<u8>, desired: Vec<u8>) -> (result: String)\n    requires\n        valid_input(n as nat, m as nat, colors@.map(|i, x| x as nat), desired@.map(|i, x| x as nat)),\n    ensures\n        result@ == seq!['Y' as char, 'E' as char, 'S' as char] <==> exists|i: int, j: int| 0 <= i <= j < n as int && #[trigger] subarray_matches_desired(colors@.map(|k, x| x as nat).subrange(i, j + 1), desired@.map(|k, x| x as nat), m as nat),\n        result@ == seq!['Y' as char, 'E' as char, 'S' as char] || result@ == seq!['N' as char, 'O' as char],\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_232.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 603, "verus_errors": [{"error_type": "Other", "error_text": "triggers cannot contain let/forall/exists/lambda/choose ()", "message": "VerusErrorType.Other: triggers cannot contain let/forall/exists/lambda/choose ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpkv685n4k", "lines": [51, 51], "label": null, "text": [{"text": "        result@ == seq!['Y' as char, 'E' as char, 'S' as char] <==> exists|i: int, j: int| 0 <= i <= j < n as int && #[trigger] subarray_matches_desired(colors@.map(|k, x| x as nat).subrange(i, j + 1), desired@.map(|k, x| x as nat), m as nat),", "highlight_start": 166, "highlight_end": 181}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_occurrences(s: Seq<nat>, value: nat) -> nat\n    decreases s.len()\n{\n\nspec fn sum_seq(s: Seq<nat>) -> nat\n    decreases s.len()\n{\n\nspec fn subarray_matches_desired(subarray: Seq<nat>, desired: Seq<nat>, m: nat) -> bool\n{\n\nspec fn valid_input(n: nat, m: nat, colors: Seq<nat>, desired: Seq<nat>) -> bool\n{\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_2321_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_string(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn is_valid_problem_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == '>' || #[trigger] s[i] == '<'\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if is_valid_integer_string(s) {\n        string_to_int_helper(s, s.len() as int)\n    } else {\n        0\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos <= 0 || pos > s.len() { \n        0 \n    } else if !forall|i: int| 0 <= i < pos ==> '0' <= #[trigger] s[i] <= '9' {\n        0\n    } else if pos == 0 { \n        0 \n    } else { \n        string_to_int_helper(s, pos - 1) * 10 + (s[pos - 1] as int - '0' as int) \n    }\n}\n\nspec fn min_deletions_needed(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        let first_greater = first_greater_from_left(s);\n        let first_less_from_right = first_less_from_right(s);\n        if first_greater < first_less_from_right { first_greater } else { first_less_from_right }\n    } else {\n        0\n    }\n}\n\nspec fn first_greater_from_left(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        first_greater_from_left_helper(s, 0)\n    } else {\n        s.len() as int\n    }\n}\n\nspec fn first_greater_from_left_helper(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if !is_valid_problem_string(s) || pos < 0 || pos > s.len() {\n        s.len() as int\n    } else if pos >= s.len() { \n        s.len() as int \n    } else if s[pos] == '>' { \n        pos \n    } else { \n        first_greater_from_left_helper(s, pos + 1) \n    }\n}\n\nspec fn first_less_from_right(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        first_less_from_right_helper(s, s.len() as int - 1)\n    } else {\n        s.len() as int\n    }\n}\n\nspec fn first_less_from_right_helper(s: Seq<char>, pos: int) -> int\n    decreases pos + 1\n{\n    if !is_valid_problem_string(s) || pos >= s.len() || pos < -1 {\n        s.len() as int\n    } else if pos < 0 { \n        s.len() as int \n    } else if s[pos] == '<' { \n        s.len() as int - 1 - pos \n    } else { \n        first_less_from_right_helper(s, pos - 1) \n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a < b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(lines: Vec<Vec<char>>) -> (results: Vec<i8>)\n    requires \n        lines@.len() > 0,\n        forall|i: int| 0 <= i < lines@.len() ==> is_valid_string(lines@[i]),\n        is_valid_integer_string(lines@[0]),\n        ({let t = string_to_int(lines@[0]); lines@.len() >= 1 + 2 * t}),\n        forall|i: int| 0 <= i < string_to_int(lines@[0]) ==> \n            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])\n    ensures \n        results@.len() == string_to_int(lines@[0]),\n        forall|r: i8| #[trigger] results@.contains(r) ==> r as int >= 0,\n        forall|i: int| 0 <= i < results@.len() ==> \n            #[trigger] results@[i] as int == min_deletions_needed(lines@[2 + 2*i])\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_string(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn is_valid_problem_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == '>' || #[trigger] s[i] == '<'\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if is_valid_integer_string(s) {\n        string_to_int_helper(s, s.len() as int)\n    } else {\n        0\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos <= 0 || pos > s.len() { \n        0 \n    } else if !forall|i: int| 0 <= i < pos ==> '0' <= #[trigger] s[i] <= '9' {\n        0\n    } else if pos == 0 { \n        0 \n    } else { \n        string_to_int_helper(s, pos - 1) * 10 + (s[pos - 1] as int - '0' as int) \n    }\n}\n\nspec fn min_deletions_needed(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        let first_greater = first_greater_from_left(s);\n        let first_less_from_right = first_less_from_right(s);\n        if first_greater < first_less_from_right { first_greater } else { first_less_from_right }\n    } else {\n        0\n    }\n}\n\nspec fn first_greater_from_left(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        first_greater_from_left_helper(s, 0)\n    } else {\n        s.len() as int\n    }\n}\n\nspec fn first_greater_from_left_helper(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if !is_valid_problem_string(s) || pos < 0 || pos > s.len() {\n        s.len() as int\n    } else if pos >= s.len() { \n        s.len() as int \n    } else if s[pos] == '>' { \n        pos \n    } else { \n        first_greater_from_left_helper(s, pos + 1) \n    }\n}\n\nspec fn first_less_from_right(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        first_less_from_right_helper(s, s.len() as int - 1)\n    } else {\n        s.len() as int\n    }\n}\n\nspec fn first_less_from_right_helper(s: Seq<char>, pos: int) -> int\n    decreases pos + 1\n{\n    if !is_valid_problem_string(s) || pos >= s.len() || pos < -1 {\n        s.len() as int\n    } else if pos < 0 { \n        s.len() as int \n    } else if s[pos] == '<' { \n        s.len() as int - 1 - pos \n    } else { \n        first_less_from_right_helper(s, pos - 1) \n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a < b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(lines: Vec<Vec<char>>) -> (results: Vec<i8>)\n    requires \n        lines@.len() > 0,\n        forall|i: int| 0 <= i < lines@.len() ==> is_valid_string(lines@[i]),\n        is_valid_integer_string(lines@[0]),\n        ({let t = string_to_int(lines@[0]); lines@.len() >= 1 + 2 * t}),\n        forall|i: int| 0 <= i < string_to_int(lines@[0]) ==> \n            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])\n    ensures \n        results@.len() == string_to_int(lines@[0]),\n        forall|r: i8| #[trigger] results@.contains(r) ==> r as int >= 0,\n        forall|i: int| 0 <= i < results@.len() ==> \n            #[trigger] results@[i] as int == min_deletions_needed(lines@[2 + 2*i])\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2321.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 577, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [106, 106], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "        forall|i: int| 0 <= i < lines@.len() ==> is_valid_string(lines@[i]),", "highlight_start": 66, "highlight_end": 75}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [106, 106], "label": "arguments to this function are incorrect", "text": [{"text": "        forall|i: int| 0 <= i < lines@.len() ==> is_valid_string(lines@[i]),", "highlight_start": 50, "highlight_end": 65}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [107, 107], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "        is_valid_integer_string(lines@[0]),", "highlight_start": 33, "highlight_end": 42}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [107, 107], "label": "arguments to this function are incorrect", "text": [{"text": "        is_valid_integer_string(lines@[0]),", "highlight_start": 9, "highlight_end": 32}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [108, 108], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "        ({let t = string_to_int(lines@[0]); lines@.len() >= 1 + 2 * t}),", "highlight_start": 33, "highlight_end": 42}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [108, 108], "label": "arguments to this function are incorrect", "text": [{"text": "        ({let t = string_to_int(lines@[0]); lines@.len() >= 1 + 2 * t}),", "highlight_start": 19, "highlight_end": 32}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [109, 109], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "        forall|i: int| 0 <= i < string_to_int(lines@[0]) ==> ", "highlight_start": 47, "highlight_end": 56}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [109, 109], "label": "arguments to this function are incorrect", "text": [{"text": "        forall|i: int| 0 <= i < string_to_int(lines@[0]) ==> ", "highlight_start": 33, "highlight_end": 46}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [110, 110], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])", "highlight_start": 37, "highlight_end": 52}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [110, 110], "label": "arguments to this function are incorrect", "text": [{"text": "            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])", "highlight_start": 13, "highlight_end": 36}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [110, 110], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])", "highlight_start": 81, "highlight_end": 96}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [110, 110], "label": "arguments to this function are incorrect", "text": [{"text": "            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])", "highlight_start": 57, "highlight_end": 80}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [112, 112], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "        results@.len() == string_to_int(lines@[0]),", "highlight_start": 41, "highlight_end": 50}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [112, 112], "label": "arguments to this function are incorrect", "text": [{"text": "        results@.len() == string_to_int(lines@[0]),", "highlight_start": 27, "highlight_end": 40}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [115, 115], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "            #[trigger] results@[i] as int == min_deletions_needed(lines@[2 + 2*i])", "highlight_start": 67, "highlight_end": 82}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpln9eo4u_", "lines": [115, 115], "label": "arguments to this function are incorrect", "text": [{"text": "            #[trigger] results@[i] as int == min_deletions_needed(lines@[2 + 2*i])", "highlight_start": 46, "highlight_end": 66}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 129, "minimized_LOC": 129, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_valid_string(s: Seq<char>) -> bool {\n\nspec fn is_valid_problem_string(s: Seq<char>) -> bool {\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn string_to_int_helper(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n\nspec fn min_deletions_needed(s: Seq<char>) -> int {\n\nspec fn first_greater_from_left(s: Seq<char>) -> int {\n\nspec fn first_greater_from_left_helper(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n\nspec fn first_less_from_right(s: Seq<char>) -> int {\n\nspec fn first_less_from_right_helper(s: Seq<char>, pos: int) -> int\n    decreases pos + 1\n{\n\nspec fn min(a: int, b: int) -> int {\n\n    decreases pos\n\n    decreases s.len() - pos\n\n    decreases pos + 1\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_2362_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n  stdin_input.len() > 0 && \n  has_valid_tree_structure(stdin_input) &&\n  all_vertex_values_in_range(stdin_input) &&\n  vertex_count_in_range(stdin_input)\n}\n\nspec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)\n}\n\nspec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && exists_path_with_common_prime_factor(stdin_input)\n}\n\nspec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && !has_common_prime_paths(stdin_input)\n}\n\nspec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) && has_common_prime_paths(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {\n  0\n}\n\nspec fn get_vertex_count(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn int_to_string_spec(x: int) -> Seq<char>\n  decreases x\n{\n  if x >= 0 {\n    if x == 0 { seq!['0'] }\n    else if x < 10 { seq![char_of_digit(x)] }\n    else { int_to_string_spec(x / 10).add(seq![char_of_digit(x % 10)]) }\n  } else {\n    seq!['0']\n  }\n}\n\nspec fn char_of_digit(d: int) -> char {\n  if 0 <= d && d <= 9 {\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else { '9' }\n  } else {\n    '0'\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n  stdin_input.len() > 0 && \n  has_valid_tree_structure(stdin_input) &&\n  all_vertex_values_in_range(stdin_input) &&\n  vertex_count_in_range(stdin_input)\n}\n\nspec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)\n}\n\nspec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && exists_path_with_common_prime_factor(stdin_input)\n}\n\nspec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && !has_common_prime_paths(stdin_input)\n}\n\nspec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) && has_common_prime_paths(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {\n  0\n}\n\nspec fn get_vertex_count(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn int_to_string_spec(x: int) -> Seq<char>\n  decreases x\n{\n  if x >= 0 {\n    if x == 0 { seq!['0'] }\n    else if x < 10 { seq![char_of_digit(x)] }\n    else { int_to_string_spec(x / 10).add(seq![char_of_digit(x % 10)]) }\n  } else {\n    seq!['0']\n  }\n}\n\nspec fn char_of_digit(d: int) -> char {\n  if 0 <= d && d <= 9 {\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else { '9' }\n  } else {\n    '0'\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2362.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 940, "minimize_time_ms": 92094, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 109, "minimized_LOC": 109, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n\nspec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {\n\nspec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {\n\nspec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {\n\nspec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {\n\nspec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {\n\nspec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {\n\nspec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {\n\nspec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {\n\nspec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {\n\nspec fn get_vertex_count(stdin_input: Seq<char>) -> int {\n\nspec fn int_to_string_spec(x: int) -> Seq<char>\n  decreases x\n{\n\nspec fn char_of_digit(d: int) -> char {\n\n  decreases x"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n  stdin_input.len() > 0 && \n  has_valid_tree_structure(stdin_input) &&\n  all_vertex_values_in_range(stdin_input) &&\n  vertex_count_in_range(stdin_input)\n}\n\nspec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)\n}\n\nspec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && exists_path_with_common_prime_factor(stdin_input)\n}\n\nspec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && !has_common_prime_paths(stdin_input)\n}\n\nspec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) && has_common_prime_paths(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {\n  0\n}\n\nspec fn get_vertex_count(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn int_to_string_spec(x: int) -> Seq<char>\n  decreases x\n{\n  if x >= 0 {\n    if x == 0 { seq!['0'] }\n    else if x < 10 { seq![char_of_digit(x)] }\n    else { int_to_string_spec(x / 10).add(seq![char_of_digit(x % 10)]) }\n  } else {\n    seq!['0']\n  }\n}\n\nspec fn char_of_digit(d: int) -> char {\n  if 0 <= d && d <= 9 {\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else { '9' }\n  } else {\n    '0'\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2411_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n    0\n}\n\nspec fn is_valid_coordinate_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> {\n    seq![]\n}\n\nspec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> {\n    seq![]\n}\n\nspec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat {\n    0\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 3 && lines.len() <= 1001 &&\n        is_valid_first_line(lines[0]) &&\n        {\n            let n = parse_first_line_as_nat(lines[0]);\n            n >= 2 && n <= 1000 && lines.len() == n + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn is_non_negative_numeric_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn valid_coordinate(point: (int, int)) -> bool {\n    let (x, y) = point;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000\n}\n\nspec fn extract_n(input: Seq<char>) -> nat {\n    if valid_input_format(input) {\n        let lines = split_lines(input);\n        parse_first_line_as_nat(lines[0])\n    } else {\n        0\n    }\n}\n\nspec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n    if valid_input_format(input) {\n        seq![(0, 0), (1, 1)]\n    } else {\n        seq![]\n    }\n}\n\nspec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {\n    if points.len() >= 2 &&\n       forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j] &&\n       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i]) {\n        let distinct_lines = get_distinct_lines(points);\n        let slope_groups = group_lines_by_slope(distinct_lines);\n        let total_lines = distinct_lines.len();\n        (sum_over_slope_groups(slope_groups, total_lines)) / 2\n    } else {\n        0\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    if is_non_negative_numeric_string(s) {\n        0\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0 &&\n        valid_input_format(stdin_input)\n    ensures \n        result.len() > 0 &&\n        is_non_negative_numeric_string(result) &&\n        ({\n            let n = extract_n(stdin_input);\n            let points = extract_points(stdin_input);\n            points.len() == n && n >= 2 && n <= 1000 &&\n            (forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i])) &&\n            (forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j]) &&\n            string_to_int(result) == count_intersecting_line_pairs(points)\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn is_valid_first_line(line: Seq<char>) -> bool ;\n       spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n          0 }\n       spec fn is_valid_coordinate_line(line: Seq<char>) -> bool ;\n       spec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> ;\n       spec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> ;\n       spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat ;\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n          input.len() > 0 && input[input.len() as int - 1] == '\\n' &&     {\n             let lines = split_lines(input);\n             lines.len() >= 3 && lines.len() <= 1001 &&         is_valid_first_line(lines[0]) &&         {\n                let n = parse_first_line_as_nat(lines[0]);\n                n >= 2 && n <= 1000 && lines.len() == n + 1 &&             forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(       \n#[trigger] lines[i])\n        }\n         }\n      }\n       spec fn is_non_negative_numeric_string(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate(point: (int, int)) -> bool ;\n       spec fn extract_n(input: Seq<char>) -> nat ;\n       spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n          if valid_input_format(input) {\n             seq![(0, 0), (1, 1)]     }\n      else {\n             seq![]     }\n      }\n       spec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {\n          if points.len() >= 2 &&        forall|i: int, j: int| 0 <= i < j < points.len() ==>        \n#[trigger] points[i] != #[trigger] points[j] &&\n       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(       \n#[trigger] points[i]) {\n        let distinct_lines = get_distinct_lines(points);\n              let slope_groups = group_lines_by_slope(distinct_lines);\n              let total_lines = distinct_lines.len();\n              (sum_over_slope_groups(slope_groups, total_lines)) / 2     }\n       else {\n              0     }\n       }\n        spec fn string_to_int(s: Seq<char>) -> nat {\n           if is_non_negative_numeric_string(s) {\n              0     }\n       else {\n              0     }\n       }\n        fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)     requires          stdin_input.len() > 0 &&         valid_input_format(stdin_input)     ensures          result.len() > 0 &&         is_non_negative_numeric_string(result) &&         ({\n                   let points = extract_points(stdin_input);\n                 string_to_int(result) == count_intersecting_line_pairs(points)         }\n       ) {\n           unreached() }\n        }\n        fn main() {\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2411.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 921, "minimize_time_ms": 215086, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 126, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.4365079365079365}, "labeling": {"segments": {"exec": " fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)     requires          stdin_input.len() > 0 &&         valid_input_format(stdin_input)     ensures          result.len() > 0 &&         is_non_negative_numeric_string(result) &&         ({\n\n fn main() {", "spec": "spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn is_valid_first_line(line: Seq<char>) -> bool ;\n       spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n\nspec fn is_valid_first_line(line: Seq<char>) -> bool ;\n       spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n\nspec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n\nspec fn is_valid_coordinate_line(line: Seq<char>) -> bool ;\n       spec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> ;\n       spec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> ;\n       spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat ;\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> ;\n       spec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> ;\n       spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat ;\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> ;\n       spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat ;\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat ;\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn is_non_negative_numeric_string(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate(point: (int, int)) -> bool ;\n       spec fn extract_n(input: Seq<char>) -> nat ;\n       spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n\nspec fn valid_coordinate(point: (int, int)) -> bool ;\n       spec fn extract_n(input: Seq<char>) -> nat ;\n       spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n\nspec fn extract_n(input: Seq<char>) -> nat ;\n       spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n\nspec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n\nspec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n\n        fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)     requires          stdin_input.len() > 0 &&         valid_input_format(stdin_input)     ensures          result.len() > 0 &&         is_non_negative_numeric_string(result) &&         ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n    0\n}\n\nspec fn is_valid_coordinate_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> {\n    seq![]\n}\n\nspec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> {\n    seq![]\n}\n\nspec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat {\n    0\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 3 && lines.len() <= 1001 &&\n        is_valid_first_line(lines[0]) &&\n        {\n            let n = parse_first_line_as_nat(lines[0]);\n            n >= 2 && n <= 1000 && lines.len() == n + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn is_non_negative_numeric_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn valid_coordinate(point: (int, int)) -> bool {\n    let (x, y) = point;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000\n}\n\nspec fn extract_n(input: Seq<char>) -> nat {\n    if valid_input_format(input) {\n        let lines = split_lines(input);\n        parse_first_line_as_nat(lines[0])\n    } else {\n        0\n    }\n}\n\nspec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n    if valid_input_format(input) {\n        seq![(0, 0), (1, 1)]\n    } else {\n        seq![]\n    }\n}\n\nspec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {\n    if points.len() >= 2 &&\n       forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j] &&\n       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i]) {\n        let distinct_lines = get_distinct_lines(points);\n        let slope_groups = group_lines_by_slope(distinct_lines);\n        let total_lines = distinct_lines.len();\n        (sum_over_slope_groups(slope_groups, total_lines)) / 2\n    } else {\n        0\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    if is_non_negative_numeric_string(s) {\n        0\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0 &&\n        valid_input_format(stdin_input)\n    ensures \n        result.len() > 0 &&\n        is_non_negative_numeric_string(result) &&\n        ({\n            let n = extract_n(stdin_input);\n            let points = extract_points(stdin_input);\n            points.len() == n && n >= 2 && n <= 1000 &&\n            (forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i])) &&\n            (forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j]) &&\n            string_to_int(result) == count_intersecting_line_pairs(points)\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn is_valid_first_line(line: Seq<char>) -> bool ;\n       spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n          0 }\n       spec fn is_valid_coordinate_line(line: Seq<char>) -> bool ;\n       spec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> ;\n       spec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> ;\n       spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat ;\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n          input.len() > 0 && input[input.len() as int - 1] == '\\n' &&     {\n             let lines = split_lines(input);\n             lines.len() >= 3 && lines.len() <= 1001 &&         is_valid_first_line(lines[0]) &&         {\n                let n = parse_first_line_as_nat(lines[0]);\n                n >= 2 && n <= 1000 && lines.len() == n + 1 &&             forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(       \n#[trigger] lines[i])\n        }\n         }\n      }\n       spec fn is_non_negative_numeric_string(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate(point: (int, int)) -> bool ;\n       spec fn extract_n(input: Seq<char>) -> nat ;\n       spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n          if valid_input_format(input) {\n             seq![(0, 0), (1, 1)]     }\n      else {\n             seq![]     }\n      }\n       spec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {\n          if points.len() >= 2 &&        forall|i: int, j: int| 0 <= i < j < points.len() ==>        \n#[trigger] points[i] != #[trigger] points[j] &&\n       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(       \n#[trigger] points[i]) {\n        let distinct_lines = get_distinct_lines(points);\n              let slope_groups = group_lines_by_slope(distinct_lines);\n              let total_lines = distinct_lines.len();\n              (sum_over_slope_groups(slope_groups, total_lines)) / 2     }\n       else {\n              0     }\n       }\n        spec fn string_to_int(s: Seq<char>) -> nat {\n           if is_non_negative_numeric_string(s) {\n              0     }\n       else {\n              0     }\n       }\n        fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)     requires          stdin_input.len() > 0 &&         valid_input_format(stdin_input)     ensures          result.len() > 0 &&         is_non_negative_numeric_string(result) &&         ({\n                   let points = extract_points(stdin_input);\n                 string_to_int(result) == count_intersecting_line_pairs(points)         }\n       ) {\n           unreached() }\n        }\n        fn main() {\n       }\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2431_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nstruct TestCase {\n    n: nat,\n    x: nat,\n    y: nat,\n    z: nat,\n    castles: Seq<nat>,\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    true /* TODO: implement input validation */\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    output.len() > 0 &&\n    valid_output_structure(input, output)\n}\n\nspec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {\n    true /* TODO: implement output validation */\n}\n\nspec fn get_test_count(s: Seq<char>) -> nat\n    recommends valid_input(s)\n{\n    1 /* TODO: implement test count parsing */\n}\n\nspec fn get_test_case(s: Seq<char>, i: nat) -> TestCase\n    recommends valid_input(s) && i < get_test_count(s)\n{\n    TestCase {\n        n: 1,\n        x: 1,\n        y: 1,\n        z: 1,\n        castles: seq![1],\n    }\n}\n\nspec fn count_winning_first_moves(tc: TestCase) -> nat {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nstruct TestCase {\n    n: nat,\n    x: nat,\n    y: nat,\n    z: nat,\n    castles: Seq<nat>,\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    true /* TODO: implement input validation */\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    output.len() > 0 &&\n    valid_output_structure(input, output)\n}\n\nspec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {\n    true /* TODO: implement output validation */\n}\n\nspec fn get_test_count(s: Seq<char>) -> nat\n    recommends valid_input(s)\n{\n    1 /* TODO: implement test count parsing */\n}\n\nspec fn get_test_case(s: Seq<char>, i: nat) -> TestCase\n    recommends valid_input(s) && i < get_test_count(s)\n{\n    TestCase {\n        n: 1,\n        x: 1,\n        y: 1,\n        z: 1,\n        castles: seq![1],\n    }\n}\n\nspec fn count_winning_first_moves(tc: TestCase) -> nat {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2431.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 817, "minimize_time_ms": 92237, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 77, "minimized_LOC": 77, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n\nspec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {\n\nspec fn get_test_count(s: Seq<char>) -> nat\n    recommends valid_input(s)\n{\n\nspec fn get_test_case(s: Seq<char>, i: nat) -> TestCase\n    recommends valid_input(s) && i < get_test_count(s)\n{\n\nspec fn count_winning_first_moves(tc: TestCase) -> nat {\n\n    requires valid_input(stdin_input@)\n\n    ensures valid_output(stdin_input@, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nstruct TestCase {\n    n: nat,\n    x: nat,\n    y: nat,\n    z: nat,\n    castles: Seq<nat>,\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    true /* TODO: implement input validation */\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    output.len() > 0 &&\n    valid_output_structure(input, output)\n}\n\nspec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {\n    true /* TODO: implement output validation */\n}\n\nspec fn get_test_count(s: Seq<char>) -> nat\n    recommends valid_input(s)\n{\n    1 /* TODO: implement test count parsing */\n}\n\nspec fn get_test_case(s: Seq<char>, i: nat) -> TestCase\n    recommends valid_input(s) && i < get_test_count(s)\n{\n    TestCase {\n        n: 1,\n        x: 1,\n        y: 1,\n        z: 1,\n        castles: seq![1],\n    }\n}\n\nspec fn count_winning_first_moves(tc: TestCase) -> nat {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2446_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 3 &&\n    parse_int_func(lines[0]) > 0 &&\n    parse_int_func(lines[2]) >= 0 &&\n    lines.len() >= 3 + parse_int_func(lines[2]) &&\n    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&\n    (forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] > 0) &&\n    forall|i: int| 0 <= i < parse_int_func(lines[2]) ==> parse_int_func(lines[3 + i]) > 0\n}\n\nspec fn get_expected_results(input: Seq<char>) -> Seq<int> {\n    let lines = split_lines_func(input);\n    let arr = parse_int_array_func(lines[1]);\n    let q = parse_int_func(lines[2]);\n    Seq::new(q as nat, |i: int| count_subarrays_with_gcd(arr, parse_int_func(lines[3 + i])))\n}\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n    if results.len() == 0 { seq![] }\n    else if results.len() == 1 { \n        int_to_string_func(results[0])\n    }\n    else {\n        int_to_string_func(results[0]) + seq!['\\n'] + format_output(results.subrange(1, results.len() as int))\n    }\n}\n\nspec fn count_subarrays_with_gcd(arr: Seq<int>, target: int) -> int {\n    let pairs = subarray_pairs(arr);\n    pairs.filter(|pair: (int, int)| subarray_gcd(arr, pair.0, pair.1) == target).len() as int\n}\n\nspec fn subarray_pairs(arr: Seq<int>) -> Set<(int, int)> {\n    Set::new(|pair: (int, int)| 0 <= pair.0 <= pair.1 < arr.len())\n}\n\nspec fn subarray_gcd(arr: Seq<int>, start: int, end: int) -> int\n    decreases end - start\n{\n    if start == end { arr[start] }\n    else {\n        let rest = subarray_gcd(arr, start + 1, end);\n        gcd(arr[start], rest)\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(s, 0, seq![], seq![])\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    parse_int_helper(s, 0, 0)\n}\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n    parse_int_array_helper(s, 0, seq![], seq![])\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n, seq![]) }\n}\n\nspec fn split_lines_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n    if pos >= s.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else {\n        if s[pos] == '\\n' {\n            split_lines_helper(s, pos + 1, seq![], acc.push(current))\n        } else {\n            split_lines_helper(s, pos + 1, current.push(s[pos]), acc)\n        }\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, pos: int, acc: int) -> int {\n    if pos >= s.len() { acc }\n    else {\n        let c = s[pos];\n        if c >= '0' && c <= '9' {\n            parse_int_helper(s, pos + 1, acc * 10 + (c as int - '0' as int))\n        } else {\n            acc\n        }\n    }\n}\n\nspec fn parse_int_array_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<int>) -> Seq<int> {\n    if pos >= s.len() {\n        if current.len() > 0 { acc.push(parse_int_func(current)) } else { acc }\n    } else {\n        let c = s[pos];\n        if c == ' ' || c == '\\t' {\n            if current.len() > 0 {\n                parse_int_array_helper(s, pos + 1, seq![], acc.push(parse_int_func(current)))\n            } else {\n                parse_int_array_helper(s, pos + 1, current, acc)\n            }\n        } else {\n            parse_int_array_helper(s, pos + 1, current.push(c), acc)\n        }\n    }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char> {\n    if n == 0 { acc }\n    else { int_to_string_helper(n / 10, seq![(n % 10) as char] + acc) }\n}\n\nspec fn gcd(a: int, b: int) -> int {\n    if b == 0 { a } else { gcd(b, a % b) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input(input),\n    ensures \n        result == format_output(get_expected_results(input)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 3 &&\n    parse_int_func(lines[0]) > 0 &&\n    parse_int_func(lines[2]) >= 0 &&\n    lines.len() >= 3 + parse_int_func(lines[2]) &&\n    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&\n    (forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] > 0) &&\n    forall|i: int| 0 <= i < parse_int_func(lines[2]) ==> parse_int_func(lines[3 + i]) > 0\n}\n\nspec fn get_expected_results(input: Seq<char>) -> Seq<int> {\n    let lines = split_lines_func(input);\n    let arr = parse_int_array_func(lines[1]);\n    let q = parse_int_func(lines[2]);\n    Seq::new(q as nat, |i: int| count_subarrays_with_gcd(arr, parse_int_func(lines[3 + i])))\n}\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n    if results.len() == 0 { seq![] }\n    else if results.len() == 1 { \n        int_to_string_func(results[0])\n    }\n    else {\n        int_to_string_func(results[0]) + seq!['\\n'] + format_output(results.subrange(1, results.len() as int))\n    }\n}\n\nspec fn count_subarrays_with_gcd(arr: Seq<int>, target: int) -> int {\n    let pairs = subarray_pairs(arr);\n    pairs.filter(|pair: (int, int)| subarray_gcd(arr, pair.0, pair.1) == target).len() as int\n}\n\nspec fn subarray_pairs(arr: Seq<int>) -> Set<(int, int)> {\n    Set::new(|pair: (int, int)| 0 <= pair.0 <= pair.1 < arr.len())\n}\n\nspec fn subarray_gcd(arr: Seq<int>, start: int, end: int) -> int\n    decreases end - start\n{\n    if start == end { arr[start] }\n    else {\n        let rest = subarray_gcd(arr, start + 1, end);\n        gcd(arr[start], rest)\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(s, 0, seq![], seq![])\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    parse_int_helper(s, 0, 0)\n}\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n    parse_int_array_helper(s, 0, seq![], seq![])\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n, seq![]) }\n}\n\nspec fn split_lines_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n    if pos >= s.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else {\n        if s[pos] == '\\n' {\n            split_lines_helper(s, pos + 1, seq![], acc.push(current))\n        } else {\n            split_lines_helper(s, pos + 1, current.push(s[pos]), acc)\n        }\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, pos: int, acc: int) -> int {\n    if pos >= s.len() { acc }\n    else {\n        let c = s[pos];\n        if c >= '0' && c <= '9' {\n            parse_int_helper(s, pos + 1, acc * 10 + (c as int - '0' as int))\n        } else {\n            acc\n        }\n    }\n}\n\nspec fn parse_int_array_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<int>) -> Seq<int> {\n    if pos >= s.len() {\n        if current.len() > 0 { acc.push(parse_int_func(current)) } else { acc }\n    } else {\n        let c = s[pos];\n        if c == ' ' || c == '\\t' {\n            if current.len() > 0 {\n                parse_int_array_helper(s, pos + 1, seq![], acc.push(parse_int_func(current)))\n            } else {\n                parse_int_array_helper(s, pos + 1, current, acc)\n            }\n        } else {\n            parse_int_array_helper(s, pos + 1, current.push(c), acc)\n        }\n    }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char> {\n    if n == 0 { acc }\n    else { int_to_string_helper(n / 10, seq![(n % 10) as char] + acc) }\n}\n\nspec fn gcd(a: int, b: int) -> int {\n    if b == 0 { a } else { gcd(b, a % b) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input(input),\n    ensures \n        result == format_output(get_expected_results(input)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2446.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 533, "verus_errors": [{"error_type": "Other", "error_text": "recursive function must have a decreases clause ()", "message": "VerusErrorType.Other: recursive function must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxpn_nsa1", "lines": [24, 24], "label": null, "text": [{"text": "spec fn format_output(results: Seq<int>) -> Seq<char> {", "highlight_start": 6, "highlight_end": 54}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 144, "minimized_LOC": 144, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 21, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn get_expected_results(input: Seq<char>) -> Seq<int> {\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n\nspec fn count_subarrays_with_gcd(arr: Seq<int>, target: int) -> int {\n\nspec fn subarray_pairs(arr: Seq<int>) -> Set<(int, int)> {\n\nspec fn subarray_gcd(arr: Seq<int>, start: int, end: int) -> int\n    decreases end - start\n{\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n\nspec fn split_lines_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n\nspec fn parse_int_helper(s: Seq<char>, pos: int, acc: int) -> int {\n\nspec fn parse_int_array_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<int>) -> Seq<int> {\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char> {\n\nspec fn gcd(a: int, b: int) -> int {\n\n    decreases end - start\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_2447_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    recommends is_valid_number(s)\n{\n    0\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn ends_with_newline(s: Seq<char>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&\n        is_valid_number(lines[0]) &&\n        {\n            let t = parse_int(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() == t + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> \n                is_binary_string(lines[i]) && lines[i].len() >= 1 && lines[i].len() <= 1000\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (ends_with_newline(result) || result.len() == 0) &&\n    {\n        let output_lines = split_lines(result);\n        output_lines.len() >= 1 &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> is_valid_number(output_lines[i])) &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> parse_int(output_lines[i]) >= 0)\n    }\n}\n\nspec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    {\n        let input_lines = split_lines(input);\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_lines(result);\n        output_lines.len() == t + 1 &&\n        forall|test_case: int| 0 <= test_case < t ==> #[trigger] parse_int(output_lines[test_case]) == min_operations_to_make_good(input_lines[test_case + 1])\n    }\n}\n\nspec fn min_operations_to_make_good(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    if s.len() == 0 { 0 } else { min_ops_helper(s, 0, s.len() as int) }\n}\n\nspec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        correct_result(input, result),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    recommends is_valid_number(s)\n{\n    0\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn ends_with_newline(s: Seq<char>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&\n        is_valid_number(lines[0]) &&\n        {\n            let t = parse_int(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() == t + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> \n                is_binary_string(lines[i]) && lines[i].len() >= 1 && lines[i].len() <= 1000\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (ends_with_newline(result) || result.len() == 0) &&\n    {\n        let output_lines = split_lines(result);\n        output_lines.len() >= 1 &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> is_valid_number(output_lines[i])) &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> parse_int(output_lines[i]) >= 0)\n    }\n}\n\nspec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    {\n        let input_lines = split_lines(input);\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_lines(result);\n        output_lines.len() == t + 1 &&\n        forall|test_case: int| 0 <= test_case < t ==> #[trigger] parse_int(output_lines[test_case]) == min_operations_to_make_good(input_lines[test_case + 1])\n    }\n}\n\nspec fn min_operations_to_make_good(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    if s.len() == 0 { 0 } else { min_ops_helper(s, 0, s.len() as int) }\n}\n\nspec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        correct_result(input, result),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2447.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 870, "minimize_time_ms": 153573, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 102, "minimized_LOC": 102, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n\nspec fn parse_int(s: Seq<char>) -> int\n    recommends is_valid_number(s)\n{\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n\nspec fn ends_with_newline(s: Seq<char>) -> bool {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(result: Seq<char>) -> bool {\n\nspec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n\nspec fn min_operations_to_make_good(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n\nspec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    recommends is_valid_number(s)\n{\n    0\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn ends_with_newline(s: Seq<char>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&\n        is_valid_number(lines[0]) &&\n        {\n            let t = parse_int(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() == t + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> \n                is_binary_string(lines[i]) && lines[i].len() >= 1 && lines[i].len() <= 1000\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (ends_with_newline(result) || result.len() == 0) &&\n    {\n        let output_lines = split_lines(result);\n        output_lines.len() >= 1 &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> is_valid_number(output_lines[i])) &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> parse_int(output_lines[i]) >= 0)\n    }\n}\n\nspec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    {\n        let input_lines = split_lines(input);\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_lines(result);\n        output_lines.len() == t + 1 &&\n        forall|test_case: int| 0 <= test_case < t ==> #[trigger] parse_int(output_lines[test_case]) == min_operations_to_make_good(input_lines[test_case + 1])\n    }\n}\n\nspec fn min_operations_to_make_good(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    if s.len() == 0 { 0 } else { min_ops_helper(s, 0, s.len() as int) }\n}\n\nspec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        correct_result(input, result),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2457_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    a >= 0 && a <= 1000 &&\n    b >= 0 && b < a &&\n    c >= 0 && c <= 1000 &&\n    d >= 0 && d < c\n}\n\nspec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {\n    let min_weight = (a - b) * n;\n    let max_weight = (a + b) * n;\n    let target_min = c - d;\n    let target_max = c + d;\n    !(min_weight > target_max || max_weight < target_min)\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        (input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> result.len() == 0,\n        !(input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> \n            (result.len() > 0 ==> \n                result[result.len() - 1] == '\\n' || \n                (result.len() > 3 && (result.subrange(result.len() - 4, result.len() as int) == seq!['Y', 'e', 's', '\\n'] || \n                                     result.subrange(result.len() - 3, result.len() as int) == seq!['N', 'o', '\\n']))),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    a >= 0 && a <= 1000 &&\n    b >= 0 && b < a &&\n    c >= 0 && c <= 1000 &&\n    d >= 0 && d < c\n}\n\nspec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {\n    let min_weight = (a - b) * n;\n    let max_weight = (a + b) * n;\n    let target_min = c - d;\n    let target_max = c + d;\n    !(min_weight > target_max || max_weight < target_min)\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        (input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> result.len() == 0,\n        !(input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> \n            (result.len() > 0 ==> \n                result[result.len() - 1] == '\\n' || \n                (result.len() > 3 && (result.subrange(result.len() - 4, result.len() as int) == seq!['Y', 'e', 's', '\\n'] || \n                                     result.subrange(result.len() - 3, result.len() as int) == seq!['N', 'o', '\\n']))),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2457.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 884, "minimize_time_ms": 92183, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {\n\nspec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {\n\nspec fn valid_output(output: Seq<char>) -> bool {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    a >= 0 && a <= 1000 &&\n    b >= 0 && b < a &&\n    c >= 0 && c <= 1000 &&\n    d >= 0 && d < c\n}\n\nspec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {\n    let min_weight = (a - b) * n;\n    let max_weight = (a + b) * n;\n    let target_min = c - d;\n    let target_max = c + d;\n    !(min_weight > target_max || max_weight < target_min)\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        (input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> result.len() == 0,\n        !(input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> \n            (result.len() > 0 ==> \n                result[result.len() - 1] == '\\n' || \n                (result.len() > 3 && (result.subrange(result.len() - 4, result.len() as int) == seq!['Y', 'e', 's', '\\n'] || \n                                     result.subrange(result.len() - 3, result.len() as int) == seq!['N', 'o', '\\n']))),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2522_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>) -> bool {\n        a.len() == n && b.len() == n && n >= 1 &&\n        (forall|i: int| 0 <= i < n-1 ==> a[i] <= a[i+1]) &&\n        (forall|i: int| 0 <= i < n-1 ==> b[i] <= b[i+1])\n    }\n    \n    spec fn valid_reordering(a: Seq<int>, reordered_b: Seq<int>) -> bool\n        recommends a.len() == reordered_b.len()\n    {\n        forall|i: int| 0 <= i < a.len() ==> a[i] != reordered_b[i]\n    }\n    \n    spec fn is_reordering_of(original: Seq<int>, reordered: Seq<int>) -> bool {\n        original.len() == reordered.len() && original.to_multiset() == reordered.to_multiset()\n    }\n    \n    spec fn is_rotation(original: Seq<int>, rotated: Seq<int>) -> bool {\n        original.len() == rotated.len() && \n        (exists|k: int| 0 <= k < original.len() && rotated == original.subrange(k, original.len() as int) + original.subrange(0, k))\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, a: Seq<int>, b: Seq<int>) -> (result: (bool, Seq<int>))\n    requires \n        valid_input(n, a, b)\n    ensures \n        result.0 ==> result.1.len() == n,\n        result.0 ==> is_reordering_of(b, result.1),\n        result.0 ==> valid_reordering(a, result.1),\n        !result.0 ==> result.1 == seq![],\n        result.0 ==> is_rotation(b, result.1),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (false, seq![])\n}\n// </vc-code>\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>) -> bool {\n        a.len() == n && b.len() == n && n >= 1 &&\n        (forall|i: int| 0 <= i < n-1 ==> a[i] <= a[i+1]) &&\n        (forall|i: int| 0 <= i < n-1 ==> b[i] <= b[i+1])\n    }\n    \n    spec fn valid_reordering(a: Seq<int>, reordered_b: Seq<int>) -> bool\n        recommends a.len() == reordered_b.len()\n    {\n        forall|i: int| 0 <= i < a.len() ==> a[i] != reordered_b[i]\n    }\n    \n    spec fn is_reordering_of(original: Seq<int>, reordered: Seq<int>) -> bool {\n        original.len() == reordered.len() && original.to_multiset() == reordered.to_multiset()\n    }\n    \n    spec fn is_rotation(original: Seq<int>, rotated: Seq<int>) -> bool {\n        original.len() == rotated.len() && \n        (exists|k: int| 0 <= k < original.len() && rotated == original.subrange(k, original.len() as int) + original.subrange(0, k))\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, a: Seq<int>, b: Seq<int>) -> (result: (bool, Seq<int>))\n    requires \n        valid_input(n, a, b)\n    ensures \n        result.0 ==> result.1.len() == n,\n        result.0 ==> is_reordering_of(b, result.1),\n        result.0 ==> valid_reordering(a, result.1),\n        !result.0 ==> result.1 == seq![],\n        result.0 ==> is_rotation(b, result.1),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (false, seq![])\n}\n// </vc-code>\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2522.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 522, "verus_errors": [{"error_type": "TypeAnnotation", "error_text": "type annotations needed (cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`)", "message": "VerusErrorType.TypeAnnotation: type annotations needed (cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmphup2h0sk", "lines": [38, 38], "label": "cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`", "text": [{"text": "        !result.0 ==> result.1 == seq![],", "highlight_start": 23, "highlight_end": 41}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 50, "minimized_LOC": 50, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>) -> bool {\n\nspec fn valid_reordering(a: Seq<int>, reordered_b: Seq<int>) -> bool\n        recommends a.len() == reordered_b.len()\n    {\n\nspec fn is_reordering_of(original: Seq<int>, reordered: Seq<int>) -> bool {\n\nspec fn is_rotation(original: Seq<int>, rotated: Seq<int>) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_2553_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() as int - 1] == '\\n' &&\n    count_lines(input) >= 1 &&\n    exists|q: nat| (1 <= q <= 100 && \n        parse_first_line(input) == q &&\n        count_lines(input) == 1 + 2 * q &&\n        valid_test_cases_format(input, q))\n}\n\nspec fn valid_test_cases_format(input: Seq<char>, q: nat) -> bool\n    recommends 1 <= q <= 100,\n              count_lines(input) >= 1 + 2 * q\n{\n    forall|i: int| 0 <= i < q ==> \n        exists|n: nat, x: nat| (1 <= x <= n <= 1000 &&\n        get_test_case_n(input, i) == n &&\n        get_test_case_x(input, i) == x &&\n        get_test_case_array(input, i).len() == n &&\n        forall|j: int| 0 <= j < n ==> 1 <= get_test_case_array(input, i)[j] <= 1000)\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() >= 0 && \n    (output.len() == 0 || output[output.len() as int - 1] == '\\n') &&\n    forall|i: int| 0 <= i < count_lines(output) ==> \n        (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])\n}\n\nspec fn output_matches_algorithm(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let q = parse_first_line(input);\n    count_lines(output) == q &&\n    forall|i: int| 0 <= i < q ==> {\n        let arr = get_test_case_array(input, i);\n        let x = get_test_case_x(input, i);\n        let expected = if can_select_odd_sum(arr, x) { seq!['Y', 'e', 's'] } else { seq!['N', 'o'] };\n        get_line(output, i) == expected\n    }\n}\n\nspec fn can_select_odd_sum(arr: Seq<int>, x: nat) -> bool\n    recommends x <= arr.len()\n{\n    let odd_count = count_odd_elements(arr);\n    let even_count = arr.len() - odd_count;\n\n    if x == arr.len() {\n        odd_count % 2 == 1\n    } else if odd_count > 0 && even_count > 0 {\n        true\n    } else if even_count == 0 {\n        x % 2 == 1\n    } else {\n        false\n    }\n}\n\nspec fn count_odd_elements(arr: Seq<int>) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else if arr[0] % 2 == 1 {\n        1 + count_odd_elements(arr.subrange(1, arr.len() as int))\n    } else {\n        count_odd_elements(arr.subrange(1, arr.len() as int))\n    }\n}\n\nspec fn parse_first_line(input: Seq<char>) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1\n{\n    1\n}\n\nspec fn get_test_case_n(input: Seq<char>, case_index: int) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    1\n}\n\nspec fn get_test_case_x(input: Seq<char>, case_index: int) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    1\n}\n\nspec fn get_test_case_array(input: Seq<char>, case_index: int) -> Seq<int>\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    seq![1]\n}\n\nspec fn count_lines(s: Seq<char>) -> nat {\n    if s.len() == 0 { 0 } else { 1 }\n}\n\nspec fn get_line(s: Seq<char>, line_index: int) -> Seq<char>\n    recommends line_index < count_lines(s)\n{\n    if line_index == 0 { seq!['N', 'o'] } else { seq![] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (output: Seq<char>)\n    requires \n        valid_input(stdin_input),\n    ensures \n        valid_output(output),\n        output_matches_algorithm(stdin_input, output),\n        count_lines(output) == parse_first_line(stdin_input),\n        forall|i: int| 0 <= i < count_lines(output) ==> \n            (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() as int - 1] == '\\n' &&\n    count_lines(input) >= 1 &&\n    exists|q: nat| (1 <= q <= 100 && \n        parse_first_line(input) == q &&\n        count_lines(input) == 1 + 2 * q &&\n        valid_test_cases_format(input, q))\n}\n\nspec fn valid_test_cases_format(input: Seq<char>, q: nat) -> bool\n    recommends 1 <= q <= 100,\n              count_lines(input) >= 1 + 2 * q\n{\n    forall|i: int| 0 <= i < q ==> \n        exists|n: nat, x: nat| (1 <= x <= n <= 1000 &&\n        get_test_case_n(input, i) == n &&\n        get_test_case_x(input, i) == x &&\n        get_test_case_array(input, i).len() == n &&\n        forall|j: int| 0 <= j < n ==> 1 <= get_test_case_array(input, i)[j] <= 1000)\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() >= 0 && \n    (output.len() == 0 || output[output.len() as int - 1] == '\\n') &&\n    forall|i: int| 0 <= i < count_lines(output) ==> \n        (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])\n}\n\nspec fn output_matches_algorithm(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let q = parse_first_line(input);\n    count_lines(output) == q &&\n    forall|i: int| 0 <= i < q ==> {\n        let arr = get_test_case_array(input, i);\n        let x = get_test_case_x(input, i);\n        let expected = if can_select_odd_sum(arr, x) { seq!['Y', 'e', 's'] } else { seq!['N', 'o'] };\n        get_line(output, i) == expected\n    }\n}\n\nspec fn can_select_odd_sum(arr: Seq<int>, x: nat) -> bool\n    recommends x <= arr.len()\n{\n    let odd_count = count_odd_elements(arr);\n    let even_count = arr.len() - odd_count;\n\n    if x == arr.len() {\n        odd_count % 2 == 1\n    } else if odd_count > 0 && even_count > 0 {\n        true\n    } else if even_count == 0 {\n        x % 2 == 1\n    } else {\n        false\n    }\n}\n\nspec fn count_odd_elements(arr: Seq<int>) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else if arr[0] % 2 == 1 {\n        1 + count_odd_elements(arr.subrange(1, arr.len() as int))\n    } else {\n        count_odd_elements(arr.subrange(1, arr.len() as int))\n    }\n}\n\nspec fn parse_first_line(input: Seq<char>) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1\n{\n    1\n}\n\nspec fn get_test_case_n(input: Seq<char>, case_index: int) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    1\n}\n\nspec fn get_test_case_x(input: Seq<char>, case_index: int) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    1\n}\n\nspec fn get_test_case_array(input: Seq<char>, case_index: int) -> Seq<int>\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    seq![1]\n}\n\nspec fn count_lines(s: Seq<char>) -> nat {\n    if s.len() == 0 { 0 } else { 1 }\n}\n\nspec fn get_line(s: Seq<char>, line_index: int) -> Seq<char>\n    recommends line_index < count_lines(s)\n{\n    if line_index == 0 { seq!['N', 'o'] } else { seq![] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (output: Seq<char>)\n    requires \n        valid_input(stdin_input),\n    ensures \n        valid_output(output),\n        output_matches_algorithm(stdin_input, output),\n        count_lines(output) == parse_first_line(stdin_input),\n        forall|i: int| 0 <= i < count_lines(output) ==> \n            (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2553.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 754, "verus_errors": [{"error_type": "Other", "error_text": "Could not automatically infer triggers for this quantifier.  Use #[trigger] annotations to manually mark trigger terms instead. ()", "message": "VerusErrorType.Other: Could not automatically infer triggers for this quantifier.  Use #[trigger] annotations to manually mark trigger terms instead. ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmptd_io7s6", "lines": [24, 24], "label": null, "text": [{"text": "        forall|j: int| 0 <= j < n ==> 1 <= get_test_case_array(input, i)[j] <= 1000)", "highlight_start": 9, "highlight_end": 40}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 141, "minimized_LOC": 141, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_test_cases_format(input: Seq<char>, q: nat) -> bool\n    recommends 1 <= q <= 100,\n              count_lines(input) >= 1 + 2 * q\n{\n\nspec fn valid_output(output: Seq<char>) -> bool {\n\nspec fn output_matches_algorithm(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n\nspec fn can_select_odd_sum(arr: Seq<int>, x: nat) -> bool\n    recommends x <= arr.len()\n{\n\nspec fn count_odd_elements(arr: Seq<int>) -> nat\n    decreases arr.len()\n{\n\nspec fn parse_first_line(input: Seq<char>) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1\n{\n\nspec fn get_test_case_n(input: Seq<char>, case_index: int) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n\nspec fn get_test_case_x(input: Seq<char>, case_index: int) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n\nspec fn get_test_case_array(input: Seq<char>, case_index: int) -> Seq<int>\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n\nspec fn count_lines(s: Seq<char>) -> nat {\n\nspec fn get_line(s: Seq<char>, line_index: int) -> Seq<char>\n    recommends line_index < count_lines(s)\n{\n\n    decreases arr.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_2556_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let input_pairs = get_input_pairs(input);\n        let expected_results = Seq::new(input_pairs.len(), |i: int| \n            if input_pairs[i].0 > 0 && input_pairs[i].1 >= 0 {\n                compute_minimum_cost(input_pairs[i].0, input_pairs[i].1)\n            } else {\n                0\n            });\n        output == format_results(expected_results)\n    }\n}\n\nspec fn compute_minimum_cost(c: int, s: int) -> int {\n    if c > 0 && s >= 0 {\n        let a = s / c;\n        let r = s % c;\n        (c - r) * a * a + r * (a + 1) * (a + 1)\n    } else {\n        0\n    }\n}\n\nspec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {\n    if input.len() > 0 {\n        let lines = split_lines(input);\n        if lines.len() == 0 {\n            Seq::new(0, |i: int| (0, 0))\n        } else {\n            let n = parse_int(lines[0]);\n            get_pairs_from_lines(lines, 1, n)\n        }\n    } else {\n        Seq::new(0, |i: int| (0, 0))\n    }\n}\n\nspec fn format_results(results: Seq<int>) -> Seq<char> {\n    if forall|j: int| 0 <= j < results.len() ==> results[j] >= 0 {\n        format_results_helper(results, 0, Seq::new(0, |i: int| 'a'))\n    } else {\n        Seq::new(0, |i: int| 'a')\n    }\n}\n\n#[verifier::external_body]\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::new(0, |i: int| Seq::new(0, |j: int| 'a'))\n}\n\n#[verifier::external_body]\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {\n    Seq::new(0, |i: int| (0, 0))\n}\n\n#[verifier::external_body]\nspec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {\n    Seq::new(0, |i: int| 'a')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(input, result)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let input_pairs = get_input_pairs(input);\n        let expected_results = Seq::new(input_pairs.len(), |i: int| \n            if input_pairs[i].0 > 0 && input_pairs[i].1 >= 0 {\n                compute_minimum_cost(input_pairs[i].0, input_pairs[i].1)\n            } else {\n                0\n            });\n        output == format_results(expected_results)\n    }\n}\n\nspec fn compute_minimum_cost(c: int, s: int) -> int {\n    if c > 0 && s >= 0 {\n        let a = s / c;\n        let r = s % c;\n        (c - r) * a * a + r * (a + 1) * (a + 1)\n    } else {\n        0\n    }\n}\n\nspec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {\n    if input.len() > 0 {\n        let lines = split_lines(input);\n        if lines.len() == 0 {\n            Seq::new(0, |i: int| (0, 0))\n        } else {\n            let n = parse_int(lines[0]);\n            get_pairs_from_lines(lines, 1, n)\n        }\n    } else {\n        Seq::new(0, |i: int| (0, 0))\n    }\n}\n\nspec fn format_results(results: Seq<int>) -> Seq<char> {\n    if forall|j: int| 0 <= j < results.len() ==> results[j] >= 0 {\n        format_results_helper(results, 0, Seq::new(0, |i: int| 'a'))\n    } else {\n        Seq::new(0, |i: int| 'a')\n    }\n}\n\n#[verifier::external_body]\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::new(0, |i: int| Seq::new(0, |j: int| 'a'))\n}\n\n#[verifier::external_body]\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {\n    Seq::new(0, |i: int| (0, 0))\n}\n\n#[verifier::external_body]\nspec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {\n    Seq::new(0, |i: int| 'a')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(input, result)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2556.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 719, "minimize_time_ms": 92140, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 97, "minimized_LOC": 97, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {\n\nspec fn compute_minimum_cost(c: int, s: int) -> int {\n\nspec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {\n\nspec fn format_results(results: Seq<int>) -> Seq<char> {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int(line: Seq<char>) -> int {\n\nspec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {\n\nspec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {\n\n    requires valid_input(input)\n\n    ensures valid_output(input, result)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let input_pairs = get_input_pairs(input);\n        let expected_results = Seq::new(input_pairs.len(), |i: int| \n            if input_pairs[i].0 > 0 && input_pairs[i].1 >= 0 {\n                compute_minimum_cost(input_pairs[i].0, input_pairs[i].1)\n            } else {\n                0\n            });\n        output == format_results(expected_results)\n    }\n}\n\nspec fn compute_minimum_cost(c: int, s: int) -> int {\n    if c > 0 && s >= 0 {\n        let a = s / c;\n        let r = s % c;\n        (c - r) * a * a + r * (a + 1) * (a + 1)\n    } else {\n        0\n    }\n}\n\nspec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {\n    if input.len() > 0 {\n        let lines = split_lines(input);\n        if lines.len() == 0 {\n            Seq::new(0, |i: int| (0, 0))\n        } else {\n            let n = parse_int(lines[0]);\n            get_pairs_from_lines(lines, 1, n)\n        }\n    } else {\n        Seq::new(0, |i: int| (0, 0))\n    }\n}\n\nspec fn format_results(results: Seq<int>) -> Seq<char> {\n    if forall|j: int| 0 <= j < results.len() ==> results[j] >= 0 {\n        format_results_helper(results, 0, Seq::new(0, |i: int| 'a'))\n    } else {\n        Seq::new(0, |i: int| 'a')\n    }\n}\n\n#[verifier::external_body]\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::new(0, |i: int| Seq::new(0, |j: int| 'a'))\n}\n\n#[verifier::external_body]\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {\n    Seq::new(0, |i: int| (0, 0))\n}\n\n#[verifier::external_body]\nspec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {\n    Seq::new(0, |i: int| 'a')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(input, result)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_256_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn split_lines(input: &str) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn split_by_char(line: &str, c: char) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn char_at(s: &str, i: int) -> char {\n    ' '\n}\n\n#[verifier::external_body]\nspec fn str_len(s: &str) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn empty_string() -> String {\n    String::new()\n}\n\n#[verifier::external_body]\nspec fn team1_string() -> String {\n    \"Team 1\\n\".to_string()\n}\n\n#[verifier::external_body]\nspec fn team2_string() -> String {\n    \"Team 2\\n\".to_string()\n}\n\n#[verifier::external_body]\nspec fn draw_string() -> String {\n    \"Draw\\n\".to_string()\n}\n\nspec fn is_valid_integer(s: &str) -> bool {\n    str_len(s) > 0 && forall|i: int| 0 <= i < str_len(s) ==> ('0' <= char_at(s, i) && char_at(s, i) <= '9')\n}\n\nspec fn valid_player_line(line: &str) -> bool {\n    let parts = split_by_char(line, ' ');\n    parts.len() == 2 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1])\n}\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 4 &&\n    forall|i: int| 0 <= i < 4 ==> valid_player_line(lines[i])\n}\n\n#[verifier::external_body]\nspec fn parse_line(line: &str) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn compute_result(input: &str) -> String {\n    let lines = split_lines(input);\n    if lines.len() < 4 {\n        empty_string()\n    } else {\n        let player1 = parse_line(lines[0]);\n        let player2 = parse_line(lines[1]);\n        let player3 = parse_line(lines[2]);\n        let player4 = parse_line(lines[3]);\n\n        if player1.len() != 2 || player2.len() != 2 || player3.len() != 2 || player4.len() != 2 {\n            empty_string()\n        } else {\n            let a = player1[0];\n            let b = player1[1];\n            let c = player2[0];\n            let d = player2[1];\n            let x = player3[0];\n            let y = player3[1];\n            let z = player4[0];\n            let w = player4[1];\n\n            let team1 = (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);\n            let team2 = ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));\n\n            if team1 {\n                team1_string()\n            } else if team2 {\n                team2_string()\n            } else {\n                draw_string()\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input)\n    ensures \n        result == compute_result(input),\n        (result@ == \"Team 1\\n\"@) || (result@ == \"Team 2\\n\"@) || (result@ == \"Draw\\n\"@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Draw\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn split_lines(input: &str) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn split_by_char(line: &str, c: char) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn char_at(s: &str, i: int) -> char {\n    ' '\n}\n\n#[verifier::external_body]\nspec fn str_len(s: &str) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn empty_string() -> String {\n    String::new()\n}\n\n#[verifier::external_body]\nspec fn team1_string() -> String {\n    \"Team 1\\n\".to_string()\n}\n\n#[verifier::external_body]\nspec fn team2_string() -> String {\n    \"Team 2\\n\".to_string()\n}\n\n#[verifier::external_body]\nspec fn draw_string() -> String {\n    \"Draw\\n\".to_string()\n}\n\nspec fn is_valid_integer(s: &str) -> bool {\n    str_len(s) > 0 && forall|i: int| 0 <= i < str_len(s) ==> ('0' <= char_at(s, i) && char_at(s, i) <= '9')\n}\n\nspec fn valid_player_line(line: &str) -> bool {\n    let parts = split_by_char(line, ' ');\n    parts.len() == 2 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1])\n}\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 4 &&\n    forall|i: int| 0 <= i < 4 ==> valid_player_line(lines[i])\n}\n\n#[verifier::external_body]\nspec fn parse_line(line: &str) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn compute_result(input: &str) -> String {\n    let lines = split_lines(input);\n    if lines.len() < 4 {\n        empty_string()\n    } else {\n        let player1 = parse_line(lines[0]);\n        let player2 = parse_line(lines[1]);\n        let player3 = parse_line(lines[2]);\n        let player4 = parse_line(lines[3]);\n\n        if player1.len() != 2 || player2.len() != 2 || player3.len() != 2 || player4.len() != 2 {\n            empty_string()\n        } else {\n            let a = player1[0];\n            let b = player1[1];\n            let c = player2[0];\n            let d = player2[1];\n            let x = player3[0];\n            let y = player3[1];\n            let z = player4[0];\n            let w = player4[1];\n\n            let team1 = (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);\n            let team2 = ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));\n\n            if team1 {\n                team1_string()\n            } else if team2 {\n                team2_string()\n            } else {\n                draw_string()\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input)\n    ensures \n        result == compute_result(input),\n        (result@ == \"Team 1\\n\"@) || (result@ == \"Team 2\\n\"@) || (result@ == \"Draw\\n\"@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Draw\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_256.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 803, "minimize_time_ms": 123299, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 126, "minimized_LOC": 126, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(input: &str) -> Seq<&str> {\n\nspec fn split_by_char(line: &str, c: char) -> Seq<&str> {\n\nspec fn char_at(s: &str, i: int) -> char {\n\nspec fn str_len(s: &str) -> int {\n\nspec fn empty_string() -> String {\n\nspec fn team1_string() -> String {\n\nspec fn team2_string() -> String {\n\nspec fn draw_string() -> String {\n\nspec fn is_valid_integer(s: &str) -> bool {\n\nspec fn valid_player_line(line: &str) -> bool {\n\nspec fn valid_input(input: &str) -> bool {\n\nspec fn parse_line(line: &str) -> Seq<int> {\n\nspec fn compute_result(input: &str) -> String {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn split_lines(input: &str) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn split_by_char(line: &str, c: char) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn char_at(s: &str, i: int) -> char {\n    ' '\n}\n\n#[verifier::external_body]\nspec fn str_len(s: &str) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn empty_string() -> String {\n    String::new()\n}\n\n#[verifier::external_body]\nspec fn team1_string() -> String {\n    \"Team 1\\n\".to_string()\n}\n\n#[verifier::external_body]\nspec fn team2_string() -> String {\n    \"Team 2\\n\".to_string()\n}\n\n#[verifier::external_body]\nspec fn draw_string() -> String {\n    \"Draw\\n\".to_string()\n}\n\nspec fn is_valid_integer(s: &str) -> bool {\n    str_len(s) > 0 && forall|i: int| 0 <= i < str_len(s) ==> ('0' <= char_at(s, i) && char_at(s, i) <= '9')\n}\n\nspec fn valid_player_line(line: &str) -> bool {\n    let parts = split_by_char(line, ' ');\n    parts.len() == 2 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1])\n}\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 4 &&\n    forall|i: int| 0 <= i < 4 ==> valid_player_line(lines[i])\n}\n\n#[verifier::external_body]\nspec fn parse_line(line: &str) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn compute_result(input: &str) -> String {\n    let lines = split_lines(input);\n    if lines.len() < 4 {\n        empty_string()\n    } else {\n        let player1 = parse_line(lines[0]);\n        let player2 = parse_line(lines[1]);\n        let player3 = parse_line(lines[2]);\n        let player4 = parse_line(lines[3]);\n\n        if player1.len() != 2 || player2.len() != 2 || player3.len() != 2 || player4.len() != 2 {\n            empty_string()\n        } else {\n            let a = player1[0];\n            let b = player1[1];\n            let c = player2[0];\n            let d = player2[1];\n            let x = player3[0];\n            let y = player3[1];\n            let z = player4[0];\n            let w = player4[1];\n\n            let team1 = (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);\n            let team2 = ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));\n\n            if team1 {\n                team1_string()\n            } else if team2 {\n                team2_string()\n            } else {\n                draw_string()\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input)\n    ensures \n        result == compute_result(input),\n        (result@ == \"Team 1\\n\"@) || (result@ == \"Team 2\\n\"@) || (result@ == \"Draw\\n\"@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"Draw\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n           fn main() {\n }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_2616_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {\n    forall|i: int| 0 <= i < test_cases.len() ==> \n        test_cases[i].len() >= 1 && \n        forall|j: int| 0 <= j < test_cases[i].len() ==> test_cases[i][j] >= 1\n}\n\nspec fn valid_results(results: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < results.len() ==> \n        results[i] == seq!['F', 'i', 'r', 's', 't'] || results[i] == seq!['S', 'e', 'c', 'o', 'n', 'd']\n}\n\nspec fn count_leading_ones(piles: Seq<int>) -> nat\n    decreases piles.len()\n{\n    if piles.len() == 0 {\n        0\n    } else if piles[0] != 1 {\n        0\n    } else {\n        1 + count_leading_ones(piles.subrange(1, piles.len() as int))\n    }\n}\n\nspec fn count_ones_in_seq(piles: Seq<int>) -> nat {\n    piles.filter(|x: int| x == 1).len()\n}\n\nspec fn correct_game_result(piles: Seq<int>, result: Seq<char>) -> bool {\n    &&& piles.len() >= 1\n    &&& (forall|j: int| 0 <= j < piles.len() ==> piles[j] >= 1)\n    &&& (result == seq!['F', 'i', 'r', 's', 't'] || result == seq!['S', 'e', 'c', 'o', 'n', 'd'])\n    &&& {\n        let ones_count = count_ones_in_seq(piles);\n        let all_ones = (ones_count == piles.len());\n        let leading_ones = count_leading_ones(piles);\n        if all_ones {\n            if ones_count % 2 == 1 {\n                result == seq!['F', 'i', 'r', 's', 't']\n            } else {\n                result == seq!['S', 'e', 'c', 'o', 'n', 'd']\n            }\n        } else {\n            if leading_ones % 2 == 1 {\n                result == seq!['S', 'e', 'c', 'o', 'n', 'd']\n            } else {\n                result == seq!['F', 'i', 'r', 's', 't']\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(test_cases: Vec<Vec<i8>>) -> (results: Vec<Vec<char>>)\n    requires \n        valid_input(test_cases@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)))\n    ensures \n        results.len() == test_cases.len(),\n        valid_results(results@.map(|i: int, v: Vec<char>| v@)),\n        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {\n    forall|i: int| 0 <= i < test_cases.len() ==> \n        test_cases[i].len() >= 1 && \n        forall|j: int| 0 <= j < test_cases[i].len() ==> test_cases[i][j] >= 1\n}\n\nspec fn valid_results(results: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < results.len() ==> \n        results[i] == seq!['F', 'i', 'r', 's', 't'] || results[i] == seq!['S', 'e', 'c', 'o', 'n', 'd']\n}\n\nspec fn count_leading_ones(piles: Seq<int>) -> nat\n    decreases piles.len()\n{\n    if piles.len() == 0 {\n        0\n    } else if piles[0] != 1 {\n        0\n    } else {\n        1 + count_leading_ones(piles.subrange(1, piles.len() as int))\n    }\n}\n\nspec fn count_ones_in_seq(piles: Seq<int>) -> nat {\n    piles.filter(|x: int| x == 1).len()\n}\n\nspec fn correct_game_result(piles: Seq<int>, result: Seq<char>) -> bool {\n    &&& piles.len() >= 1\n    &&& (forall|j: int| 0 <= j < piles.len() ==> piles[j] >= 1)\n    &&& (result == seq!['F', 'i', 'r', 's', 't'] || result == seq!['S', 'e', 'c', 'o', 'n', 'd'])\n    &&& {\n        let ones_count = count_ones_in_seq(piles);\n        let all_ones = (ones_count == piles.len());\n        let leading_ones = count_leading_ones(piles);\n        if all_ones {\n            if ones_count % 2 == 1 {\n                result == seq!['F', 'i', 'r', 's', 't']\n            } else {\n                result == seq!['S', 'e', 'c', 'o', 'n', 'd']\n            }\n        } else {\n            if leading_ones % 2 == 1 {\n                result == seq!['S', 'e', 'c', 'o', 'n', 'd']\n            } else {\n                result == seq!['F', 'i', 'r', 's', 't']\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(test_cases: Vec<Vec<i8>>) -> (results: Vec<Vec<char>>)\n    requires \n        valid_input(test_cases@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)))\n    ensures \n        results.len() == test_cases.len(),\n        valid_results(results@.map(|i: int, v: Vec<char>| v@)),\n        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2616.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 764, "verus_errors": [{"error_type": "Other", "error_text": "no method named `map` found for struct `std::vec::Vec<i8>` in the current scope (`std::vec::Vec<i8>` is not an iterator)", "message": "VerusErrorType.Other: no method named `map` found for struct `std::vec::Vec<i8>` in the current scope (`std::vec::Vec<i8>` is not an iterator)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmps5l1t8tl", "lines": [67, 67], "label": "`std::vec::Vec<i8>` is not an iterator", "text": [{"text": "        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])", "highlight_start": 89, "highlight_end": 92}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `Seq<char>`, found `Vec<char>`; arguments to this function are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmps5l1t8tl", "lines": [67, 67], "label": "expected `Seq<char>`, found `Vec<char>`", "text": [{"text": "        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])", "highlight_start": 120, "highlight_end": 131}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmps5l1t8tl", "lines": [67, 67], "label": "arguments to this function are incorrect", "text": [{"text": "        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])", "highlight_start": 54, "highlight_end": 73}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 79, "minimized_LOC": 79, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {\n\nspec fn valid_results(results: Seq<Seq<char>>) -> bool {\n\nspec fn count_leading_ones(piles: Seq<int>) -> nat\n    decreases piles.len()\n{\n\nspec fn count_ones_in_seq(piles: Seq<int>) -> nat {\n\nspec fn correct_game_result(piles: Seq<int>, result: Seq<char>) -> bool {\n\n    decreases piles.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_2621_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {\n    n >= 1 && n == h.len() && m >= 0 && k >= 0 && \n    (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n}\n\nspec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool\n{\n    &&& valid_input(n, m, k, h)\n    &&& simulate_game(0, m, n, k, h)\n}\n\nspec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool\n    decreases n - pos\n{\n    &&& 0 <= pos < n\n    &&& n == h.len()\n    &&& k >= 0\n    &&& blocks >= 0\n    &&& (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n    &&& if pos == n - 1 {\n        true\n    } else {\n        let h1 = h[pos];\n        let h2 = h[pos + 1];\n        if h1 >= h2 {\n            let new_blocks = if h2 >= k { blocks + (h1 - h2) + k } else { blocks + h1 };\n            simulate_game(pos + 1, new_blocks, n, k, h)\n        } else {\n            if h2 > h1 + blocks + k {\n                false\n            } else {\n                let new_blocks = \n                    if h2 <= k { blocks + h1 }\n                    else if (h2 - h1) <= k { blocks + k - (h2 - h1) }\n                    else { blocks - (h2 - h1 - k) };\n                new_blocks >= 0 && simulate_game(pos + 1, new_blocks, n, k, h)\n            }\n        }\n    }\n}\n\nspec fn valid_complete_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() >= 0 && \n    (output.len() == 0 || output[output.len() - 1] == '\\n') &&\n    (forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n')\n}\n\nspec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n\nspec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == '\\n',\n        valid_complete_input_format(stdin_input),\n    ensures \n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\\n',\n        result.len() == 0 || result[result.len() - 1] == '\\n',\n        valid_output_format(result, stdin_input),\n        correct_game_results(result, stdin_input),\n        output_matches_test_case_count(result, stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {\n    n >= 1 && n == h.len() && m >= 0 && k >= 0 && \n    (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n}\n\nspec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool\n{\n    &&& valid_input(n, m, k, h)\n    &&& simulate_game(0, m, n, k, h)\n}\n\nspec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool\n    decreases n - pos\n{\n    &&& 0 <= pos < n\n    &&& n == h.len()\n    &&& k >= 0\n    &&& blocks >= 0\n    &&& (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n    &&& if pos == n - 1 {\n        true\n    } else {\n        let h1 = h[pos];\n        let h2 = h[pos + 1];\n        if h1 >= h2 {\n            let new_blocks = if h2 >= k { blocks + (h1 - h2) + k } else { blocks + h1 };\n            simulate_game(pos + 1, new_blocks, n, k, h)\n        } else {\n            if h2 > h1 + blocks + k {\n                false\n            } else {\n                let new_blocks = \n                    if h2 <= k { blocks + h1 }\n                    else if (h2 - h1) <= k { blocks + k - (h2 - h1) }\n                    else { blocks - (h2 - h1 - k) };\n                new_blocks >= 0 && simulate_game(pos + 1, new_blocks, n, k, h)\n            }\n        }\n    }\n}\n\nspec fn valid_complete_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() >= 0 && \n    (output.len() == 0 || output[output.len() - 1] == '\\n') &&\n    (forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n')\n}\n\nspec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n\nspec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == '\\n',\n        valid_complete_input_format(stdin_input),\n    ensures \n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\\n',\n        result.len() == 0 || result[result.len() - 1] == '\\n',\n        valid_output_format(result, stdin_input),\n        correct_game_results(result, stdin_input),\n        output_matches_test_case_count(result, stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2621.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 652, "minimize_time_ms": 92495, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 94, "minimized_LOC": 94, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {\n\nspec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool\n{\n\nspec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool\n    decreases n - pos\n{\n\nspec fn valid_complete_input_format(input: Seq<char>) -> bool {\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {\n\n    decreases n - pos\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {\n    n >= 1 && n == h.len() && m >= 0 && k >= 0 && \n    (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n}\n\nspec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool\n{\n    &&& valid_input(n, m, k, h)\n    &&& simulate_game(0, m, n, k, h)\n}\n\nspec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool\n    decreases n - pos\n{\n    &&& 0 <= pos < n\n    &&& n == h.len()\n    &&& k >= 0\n    &&& blocks >= 0\n    &&& (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n    &&& if pos == n - 1 {\n        true\n    } else {\n        let h1 = h[pos];\n        let h2 = h[pos + 1];\n        if h1 >= h2 {\n            let new_blocks = if h2 >= k { blocks + (h1 - h2) + k } else { blocks + h1 };\n            simulate_game(pos + 1, new_blocks, n, k, h)\n        } else {\n            if h2 > h1 + blocks + k {\n                false\n            } else {\n                let new_blocks = \n                    if h2 <= k { blocks + h1 }\n                    else if (h2 - h1) <= k { blocks + k - (h2 - h1) }\n                    else { blocks - (h2 - h1 - k) };\n                new_blocks >= 0 && simulate_game(pos + 1, new_blocks, n, k, h)\n            }\n        }\n    }\n}\n\nspec fn valid_complete_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() >= 0 && \n    (output.len() == 0 || output[output.len() - 1] == '\\n') &&\n    (forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n')\n}\n\nspec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n\nspec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == '\\n',\n        valid_complete_input_format(stdin_input),\n    ensures \n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\\n',\n        result.len() == 0 || result[result.len() - 1] == '\\n',\n        valid_output_format(result, stdin_input),\n        correct_game_results(result, stdin_input),\n        output_matches_test_case_count(result, stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_263_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: nat, m: nat, benches: Seq<nat>) -> bool {\n    n > 0 && m > 0 && benches.len() == n && forall|i: int| 0 <= i < n ==> benches[i] > 0\n}\n\nspec fn max_seq(s: Seq<nat>) -> nat\n    recommends s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) {\n        s[0]\n    } else {\n        max_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn sum_seq(s: Seq<nat>) -> nat {\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: nat, m: nat, benches: Seq<nat>) -> (result: (nat, nat))\n    requires valid_input(n, m, benches)\n    ensures result.1 == max_seq(benches) + m\n    ensures {\n        let total = sum_seq(benches) + m;\n        let current_max = max_seq(benches);\n        if total <= current_max * n { result.0 == current_max } \n        else { result.0 == (total + n - 1) / n }\n    }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: nat, m: nat, benches: Seq<nat>) -> bool {\n    n > 0 && m > 0 && benches.len() == n && forall|i: int| 0 <= i < n ==> benches[i] > 0\n}\n\nspec fn max_seq(s: Seq<nat>) -> nat\n    recommends s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) {\n        s[0]\n    } else {\n        max_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn sum_seq(s: Seq<nat>) -> nat {\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: nat, m: nat, benches: Seq<nat>) -> (result: (nat, nat))\n    requires valid_input(n, m, benches)\n    ensures result.1 == max_seq(benches) + m\n    ensures {\n        let total = sum_seq(benches) + m;\n        let current_max = max_seq(benches);\n        if total <= current_max * n { result.0 == current_max } \n        else { result.0 == (total + n - 1) / n }\n    }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_263.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 180, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpwaym6xnz", "lines": [37, 37], "label": null, "text": [{"text": "    ensures {", "highlight_start": 5, "highlight_end": 12}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: nat, m: nat, benches: Seq<nat>) -> bool {\n\nspec fn max_seq(s: Seq<nat>) -> nat\n    recommends s.len() > 0\n{\n\nspec fn sum_seq(s: Seq<nat>) -> nat {\n\n    requires valid_input(n, m, benches)\n\n    ensures result.1 == max_seq(benches) + m\n\n    ensures {"}}}, "all_snapshots": []}
{"id": "apps_test_2647_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    true\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    (output == seq!['-', '1', '\\n'] || \n     (output != seq!['-', '1', '\\n'] && output.len() > 1 && output.last() == '\\n'))\n}\n\nstruct GridData {\n    h: int,\n    w: int,\n    cells: Seq<Seq<char>>,\n}\n\nspec fn valid_grid(grid: GridData) -> bool {\n    grid.h > 0 && grid.w > 0 && \n    grid.cells.len() == grid.h &&\n    (forall|i: int| 0 <= i < grid.h ==> grid.cells[i].len() == grid.w) &&\n    (forall|i: int, j: int| 0 <= i < grid.h && 0 <= j < grid.w ==> \n        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&\n    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'\n}\n\nspec fn parse_input(input: Seq<char>) -> GridData {\n    GridData {\n        h: 1,\n        w: 1,\n        cells: seq![seq!['.']]\n    }\n}\n\nspec fn path_exists(grid: GridData) -> bool {\n    true\n}\n\nspec fn max_changeable_white_cells(grid: GridData) -> int {\n    0\n}\n\nspec fn count_white_cells(grid: GridData) -> int {\n    2\n}\n\nspec fn min_cut_size(grid: GridData) -> int {\n    2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    true\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    (output == seq!['-', '1', '\\n'] || \n     (output != seq!['-', '1', '\\n'] && output.len() > 1 && output.last() == '\\n'))\n}\n\nstruct GridData {\n    h: int,\n    w: int,\n    cells: Seq<Seq<char>>,\n}\n\nspec fn valid_grid(grid: GridData) -> bool {\n    grid.h > 0 && grid.w > 0 && \n    grid.cells.len() == grid.h &&\n    (forall|i: int| 0 <= i < grid.h ==> grid.cells[i].len() == grid.w) &&\n    (forall|i: int, j: int| 0 <= i < grid.h && 0 <= j < grid.w ==> \n        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&\n    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'\n}\n\nspec fn parse_input(input: Seq<char>) -> GridData {\n    GridData {\n        h: 1,\n        w: 1,\n        cells: seq![seq!['.']]\n    }\n}\n\nspec fn path_exists(grid: GridData) -> bool {\n    true\n}\n\nspec fn max_changeable_white_cells(grid: GridData) -> int {\n    0\n}\n\nspec fn count_white_cells(grid: GridData) -> int {\n    2\n}\n\nspec fn min_cut_size(grid: GridData) -> int {\n    2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2647.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 773, "minimize_time_ms": 122500, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 75, "minimized_LOC": 75, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_valid_input(input: Seq<char>) -> bool {\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n\nspec fn valid_grid(grid: GridData) -> bool {\n\nspec fn parse_input(input: Seq<char>) -> GridData {\n\nspec fn path_exists(grid: GridData) -> bool {\n\nspec fn max_changeable_white_cells(grid: GridData) -> int {\n\nspec fn count_white_cells(grid: GridData) -> int {\n\nspec fn min_cut_size(grid: GridData) -> int {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    true\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    (output == seq!['-', '1', '\\n'] || \n     (output != seq!['-', '1', '\\n'] && output.len() > 1 && output.last() == '\\n'))\n}\n\nstruct GridData {\n    h: int,\n    w: int,\n    cells: Seq<Seq<char>>,\n}\n\nspec fn valid_grid(grid: GridData) -> bool {\n    grid.h > 0 && grid.w > 0 && \n    grid.cells.len() == grid.h &&\n    (forall|i: int| 0 <= i < grid.h ==> grid.cells[i].len() == grid.w) &&\n    (forall|i: int, j: int| 0 <= i < grid.h && 0 <= j < grid.w ==> \n        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&\n    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'\n}\n\nspec fn parse_input(input: Seq<char>) -> GridData {\n    GridData {\n        h: 1,\n        w: 1,\n        cells: seq![seq!['.']]\n    }\n}\n\nspec fn path_exists(grid: GridData) -> bool {\n    true\n}\n\nspec fn max_changeable_white_cells(grid: GridData) -> int {\n    0\n}\n\nspec fn count_white_cells(grid: GridData) -> int {\n    2\n}\n\nspec fn min_cut_size(grid: GridData) -> int {\n    2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_29_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn char_to_int(c: char) -> int {\n    c as int - '0' as int\n}\n\nspec fn is_lucky(digits: Seq<int>) -> bool {\n    digits.len() == 6 ==> {\n        let sum1 = digits[0] + digits[1] + digits[2];\n        let sum2 = digits[3] + digits[4] + digits[5];\n        sum1 == sum2\n    }\n}\n\nspec fn valid_ticket(ticket: Seq<char>) -> bool {\n    ticket.len() == 6 && forall|i: int| 0 <= i < ticket.len() ==> '0' <= ticket[i] <= '9'\n}\n\nspec fn can_make_lucky_with_0_changes(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> is_lucky(digits)\n}\n\nspec fn can_make_lucky_with_1_change(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {\n        exists|pos: int| 0 <= pos < 6 &&\n            exists|new_digit: int| 0 <= new_digit <= 9 && {\n                let new_digits = digits.subrange(0, pos).add(seq![new_digit]).add(digits.subrange(pos + 1, digits.len() as int));\n                is_lucky(new_digits)\n            }\n    }\n}\n\nspec fn can_make_lucky_with_2_changes(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {\n        exists|i: int, j: int| 0 <= j < i < 6 &&\n            exists|k: int, l: int| 0 <= k <= 9 && 0 <= l <= 9 && {\n                let new_digits = digits.subrange(0, i).add(seq![k]).add(digits.subrange(i + 1, digits.len() as int));\n                let final_digits = new_digits.subrange(0, j).add(seq![l]).add(new_digits.subrange(j + 1, new_digits.len() as int));\n                is_lucky(final_digits)\n            }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(ticket: &Vec<char>) -> (result: u32)\n    requires valid_ticket(ticket@)\n    ensures 0 <= result <= 3\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn char_to_int(c: char) -> int {\n    c as int - '0' as int\n}\n\nspec fn is_lucky(digits: Seq<int>) -> bool {\n    digits.len() == 6 ==> {\n        let sum1 = digits[0] + digits[1] + digits[2];\n        let sum2 = digits[3] + digits[4] + digits[5];\n        sum1 == sum2\n    }\n}\n\nspec fn valid_ticket(ticket: Seq<char>) -> bool {\n    ticket.len() == 6 && forall|i: int| 0 <= i < ticket.len() ==> '0' <= ticket[i] <= '9'\n}\n\nspec fn can_make_lucky_with_0_changes(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> is_lucky(digits)\n}\n\nspec fn can_make_lucky_with_1_change(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {\n        exists|pos: int| 0 <= pos < 6 &&\n            exists|new_digit: int| 0 <= new_digit <= 9 && {\n                let new_digits = digits.subrange(0, pos).add(seq![new_digit]).add(digits.subrange(pos + 1, digits.len() as int));\n                is_lucky(new_digits)\n            }\n    }\n}\n\nspec fn can_make_lucky_with_2_changes(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {\n        exists|i: int, j: int| 0 <= j < i < 6 &&\n            exists|k: int, l: int| 0 <= k <= 9 && 0 <= l <= 9 && {\n                let new_digits = digits.subrange(0, i).add(seq![k]).add(digits.subrange(i + 1, digits.len() as int));\n                let final_digits = new_digits.subrange(0, j).add(seq![l]).add(new_digits.subrange(j + 1, new_digits.len() as int));\n                is_lucky(final_digits)\n            }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(ticket: &Vec<char>) -> (result: u32)\n    requires valid_ticket(ticket@)\n    ensures 0 <= result <= 3\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_29.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 539, "verus_errors": [{"error_type": "Other", "error_text": "Could not automatically infer triggers for this quantifier.  Use #[trigger] annotations to manually mark trigger terms instead. ()", "message": "VerusErrorType.Other: Could not automatically infer triggers for this quantifier.  Use #[trigger] annotations to manually mark trigger terms instead. ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpjixg0cw9", "lines": [18, 18], "label": null, "text": [{"text": "    ticket.len() == 6 && forall|i: int| 0 <= i < ticket.len() ==> '0' <= ticket[i] <= '9'", "highlight_start": 26, "highlight_end": 70}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn char_to_int(c: char) -> int {\n\nspec fn is_lucky(digits: Seq<int>) -> bool {\n\nspec fn valid_ticket(ticket: Seq<char>) -> bool {\n\nspec fn can_make_lucky_with_0_changes(digits: Seq<int>) -> bool {\n\nspec fn can_make_lucky_with_1_change(digits: Seq<int>) -> bool {\n\nspec fn can_make_lucky_with_2_changes(digits: Seq<int>) -> bool {\n\n    requires valid_ticket(ticket@)\n\n    ensures 0 <= result <= 3"}}}, "all_snapshots": []}
{"id": "apps_test_4147_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {\n    true\n}\n\nspec fn has_all_three_groups(assignment: Seq<nat>) -> bool {\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)\n}\n\nspec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    composition_cost(assignment) + adjustment_cost(input, assignment)\n}\n\nspec fn composition_cost(assignment: Seq<nat>) -> nat {\n    let group_a_size = count_group_members(assignment, 1);\n    let group_b_size = count_group_members(assignment, 2);\n    let group_c_size = count_group_members(assignment, 3);\n    (if group_a_size > 0 { ((group_a_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_b_size > 0 { ((group_b_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_c_size > 0 { ((group_c_size - 1) * 10) as nat } else { 0nat })\n}\n\nspec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    let lines = split_lines(input);\n    let (n, a, b, c) = parse_first_line_bamboo(lines[0]);\n    let sum_a = calculate_group_sum(input, assignment, 1);\n    let sum_b = calculate_group_sum(input, assignment, 2);\n    let sum_c = calculate_group_sum(input, assignment, 3);\n    abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)\n}\n\nspec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat\n    decreases assignment.len()\n{\n    if assignment.len() == 0 {\n        0nat\n    } else {\n        (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.drop_first(), group)\n    }\n}\n\nspec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {\n    0nat\n}\n\nspec fn abs_diff(a: nat, b: nat) -> nat {\n    if a >= b { (a - b) as nat } else { (b - a) as nat }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::<Seq<char>>::empty()\n}\n\nspec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {\n    (0nat, 0nat, 0nat, 0nat)\n}\n\nspec fn parse_bamboo_length(line: Seq<char>) -> nat {\n    0nat\n}\n\nfn int_to_string(n: nat) -> String {\n    \"\".to_string()\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    0nat\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {\n    true\n}\n\nspec fn has_all_three_groups(assignment: Seq<nat>) -> bool {\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)\n}\n\nspec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    composition_cost(assignment) + adjustment_cost(input, assignment)\n}\n\nspec fn composition_cost(assignment: Seq<nat>) -> nat {\n    let group_a_size = count_group_members(assignment, 1);\n    let group_b_size = count_group_members(assignment, 2);\n    let group_c_size = count_group_members(assignment, 3);\n    (if group_a_size > 0 { ((group_a_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_b_size > 0 { ((group_b_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_c_size > 0 { ((group_c_size - 1) * 10) as nat } else { 0nat })\n}\n\nspec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    let lines = split_lines(input);\n    let (n, a, b, c) = parse_first_line_bamboo(lines[0]);\n    let sum_a = calculate_group_sum(input, assignment, 1);\n    let sum_b = calculate_group_sum(input, assignment, 2);\n    let sum_c = calculate_group_sum(input, assignment, 3);\n    abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)\n}\n\nspec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat\n    decreases assignment.len()\n{\n    if assignment.len() == 0 {\n        0nat\n    } else {\n        (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.drop_first(), group)\n    }\n}\n\nspec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {\n    0nat\n}\n\nspec fn abs_diff(a: nat, b: nat) -> nat {\n    if a >= b { (a - b) as nat } else { (b - a) as nat }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::<Seq<char>>::empty()\n}\n\nspec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {\n    (0nat, 0nat, 0nat, 0nat)\n}\n\nspec fn parse_bamboo_length(line: Seq<char>) -> nat {\n    0nat\n}\n\nfn int_to_string(n: nat) -> String {\n    \"\".to_string()\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    0nat\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4147.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 688, "minimize_time_ms": 186567, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 97, "minimized_LOC": 97, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn int_to_string(n: nat) -> String {\n\n\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {\n\nspec fn has_all_three_groups(assignment: Seq<nat>) -> bool {\n\nspec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n\nspec fn composition_cost(assignment: Seq<nat>) -> nat {\n\nspec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n\nspec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat\n    decreases assignment.len()\n{\n\nspec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {\n\nspec fn abs_diff(a: nat, b: nat) -> nat {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {\n\nspec fn parse_bamboo_length(line: Seq<char>) -> nat {\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n\n    decreases assignment.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {\n    true\n}\n\nspec fn has_all_three_groups(assignment: Seq<nat>) -> bool {\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)\n}\n\nspec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    composition_cost(assignment) + adjustment_cost(input, assignment)\n}\n\nspec fn composition_cost(assignment: Seq<nat>) -> nat {\n    let group_a_size = count_group_members(assignment, 1);\n    let group_b_size = count_group_members(assignment, 2);\n    let group_c_size = count_group_members(assignment, 3);\n    (if group_a_size > 0 { ((group_a_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_b_size > 0 { ((group_b_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_c_size > 0 { ((group_c_size - 1) * 10) as nat } else { 0nat })\n}\n\nspec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    let lines = split_lines(input);\n    let (n, a, b, c) = parse_first_line_bamboo(lines[0]);\n    let sum_a = calculate_group_sum(input, assignment, 1);\n    let sum_b = calculate_group_sum(input, assignment, 2);\n    let sum_c = calculate_group_sum(input, assignment, 3);\n    abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)\n}\n\nspec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat\n    decreases assignment.len()\n{\n    if assignment.len() == 0 {\n        0nat\n    } else {\n        (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.drop_first(), group)\n    }\n}\n\nspec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {\n    0nat\n}\n\nspec fn abs_diff(a: nat, b: nat) -> nat {\n    if a >= b { (a - b) as nat } else { (b - a) as nat }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::<Seq<char>>::empty()\n}\n\nspec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {\n    (0nat, 0nat, 0nat, 0nat)\n}\n\nspec fn parse_bamboo_length(line: Seq<char>) -> nat {\n    0nat\n}\n\nfn int_to_string(n: nat) -> String {\n    \"\".to_string()\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    0nat\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4148_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>\n    requires input.len() > 0\n{\n    let newline_pos = find_newline(input, 0);\n    if newline_pos == -1 {\n        seq![input]\n    } else if newline_pos >= 0 && newline_pos < input.len() {\n        if newline_pos + 1 >= input.len() {\n            seq![input.subrange(0, newline_pos), seq![]]\n        } else {\n            seq![input.subrange(0, newline_pos), input.subrange(newline_pos + 1, input.len() as int)]\n        }\n    } else {\n        seq![input]\n    }\n}\n\nspec fn find_newline(input: Seq<char>, start: int) -> int\n    requires 0 <= start <= input.len()\n    ensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < input.len())\n    decreases input.len() - start\n{\n    if start >= input.len() {\n        -1\n    } else if input[start] == '\\n' {\n        start\n    } else {\n        find_newline(input, start + 1)\n    }\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    requires is_valid_number(s)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int - '0' as int) as nat\n    } else {\n        (s[0] as int - '0' as int) as nat * 10 + string_to_nat(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn caesar_shift(s: Seq<char>, n: nat) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let shifted_val = (s[0] as int - 'A' as int + n) % 26;\n        let shifted_char = ('A' as int + shifted_val) as char;\n        seq![shifted_char].add(caesar_shift(s.subrange(1, s.len() as int), n))\n    }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == '\\n') &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&\n        is_valid_number(lines[0]) &&\n        string_to_nat(lines[0]) <= 26 &&\n        lines[1].len() >= 1 && lines[1].len() <= 10000 &&\n        (forall|j: int| 0 <= j < lines[1].len() ==> 'A' <= lines[1][j] <= 'Z')\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures ({\n        let lines = split_lines(input);\n        let n = string_to_nat(lines[0]);\n        let s = lines[1];\n        result == caesar_shift(s, n).add(seq!['\\n'])\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>\n    requires input.len() > 0\n{\n    let newline_pos = find_newline(input, 0);\n    if newline_pos == -1 {\n        seq![input]\n    } else if newline_pos >= 0 && newline_pos < input.len() {\n        if newline_pos + 1 >= input.len() {\n            seq![input.subrange(0, newline_pos), seq![]]\n        } else {\n            seq![input.subrange(0, newline_pos), input.subrange(newline_pos + 1, input.len() as int)]\n        }\n    } else {\n        seq![input]\n    }\n}\n\nspec fn find_newline(input: Seq<char>, start: int) -> int\n    requires 0 <= start <= input.len()\n    ensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < input.len())\n    decreases input.len() - start\n{\n    if start >= input.len() {\n        -1\n    } else if input[start] == '\\n' {\n        start\n    } else {\n        find_newline(input, start + 1)\n    }\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    requires is_valid_number(s)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int - '0' as int) as nat\n    } else {\n        (s[0] as int - '0' as int) as nat * 10 + string_to_nat(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn caesar_shift(s: Seq<char>, n: nat) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let shifted_val = (s[0] as int - 'A' as int + n) % 26;\n        let shifted_char = ('A' as int + shifted_val) as char;\n        seq![shifted_char].add(caesar_shift(s.subrange(1, s.len() as int), n))\n    }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == '\\n') &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&\n        is_valid_number(lines[0]) &&\n        string_to_nat(lines[0]) <= 26 &&\n        lines[1].len() >= 1 && lines[1].len() <= 10000 &&\n        (forall|j: int| 0 <= j < lines[1].len() ==> 'A' <= lines[1][j] <= 'Z')\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures ({\n        let lines = split_lines(input);\n        let n = string_to_nat(lines[0]);\n        let s = lines[1];\n        result == caesar_shift(s, n).add(seq!['\\n'])\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4148.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1261, "verus_errors": [{"error_type": "Other", "error_text": "spec functions cannot have requires/ensures ()", "message": "VerusErrorType.Other: spec functions cannot have requires/ensures ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmprnecsg9l", "lines": [8, 8], "label": null, "text": [{"text": "spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>", "highlight_start": 6, "highlight_end": 56}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 102, "minimized_LOC": 102, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>\n    requires input.len() > 0\n{\n\nspec fn find_newline(input: Seq<char>, start: int) -> int\n    requires 0 <= start <= input.len()\n    ensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < input.len())\n    decreases input.len() - start\n{\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    requires is_valid_number(s)\n    decreases s.len()\n{\n\nspec fn caesar_shift(s: Seq<char>, n: nat) -> Seq<char>\n    decreases s.len()\n{\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\n    requires input.len() > 0\n\n    requires 0 <= start <= input.len()\n\n    ensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < input.len())\n\n    decreases input.len() - start\n\n    requires is_valid_number(s)\n\n    decreases s.len()\n\n    decreases s.len()\n\n    requires valid_input(input)\n\n    ensures ({"}}}, "all_snapshots": []}
{"id": "apps_test_4165_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(sides: Seq<int>) -> bool {\n    sides.len() >= 3 && forall|i: int| 0 <= i < sides.len() ==> sides[i] > 0\n}\n\nspec fn can_form_polygon(sides: Seq<int>) -> bool\n    recommends valid_input(sides)\n{\n    let sorted_sides = quicksort(sides);\n    let longest = sorted_sides[sorted_sides.len() - 1];\n    let sum_of_others = sum_except_last(sorted_sides);\n    sum_of_others > longest\n}\n\nspec fn quicksort(s: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {\n    seq![]\n}\n\nspec fn sum_except_last(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nproof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)\n    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(sides: Seq<int>) -> (result: String)\n    requires\n        valid_input(sides),\n    ensures\n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        (result@ == seq!['Y', 'e', 's']) == can_form_polygon(sides),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(sides: Seq<int>) -> bool {\n    sides.len() >= 3 && forall|i: int| 0 <= i < sides.len() ==> sides[i] > 0\n}\n\nspec fn can_form_polygon(sides: Seq<int>) -> bool\n    recommends valid_input(sides)\n{\n    let sorted_sides = quicksort(sides);\n    let longest = sorted_sides[sorted_sides.len() - 1];\n    let sum_of_others = sum_except_last(sorted_sides);\n    sum_of_others > longest\n}\n\nspec fn quicksort(s: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {\n    seq![]\n}\n\nspec fn sum_except_last(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nproof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)\n    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(sides: Seq<int>) -> (result: String)\n    requires\n        valid_input(sides),\n    ensures\n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        (result@ == seq!['Y', 'e', 's']) == can_form_polygon(sides),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4165.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 4502, "minimize_time_ms": 252297, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(sides: Seq<int>) -> bool {\n\nspec fn can_form_polygon(sides: Seq<int>) -> bool\n    recommends valid_input(sides)\n{\n\nspec fn quicksort(s: Seq<int>) -> Seq<int> {\n\nspec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {\n\nspec fn sum_except_last(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n\n    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)\n\n    requires\n\n    ensures", "proof": "proof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)\n    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)\n{"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(sides: Seq<int>) -> bool {\n    sides.len() >= 3 && forall|i: int| 0 <= i < sides.len() ==> sides[i] > 0\n}\n\nspec fn can_form_polygon(sides: Seq<int>) -> bool\n    recommends valid_input(sides)\n{\n    let sorted_sides = quicksort(sides);\n    let longest = sorted_sides[sorted_sides.len() - 1];\n    let sum_of_others = sum_except_last(sorted_sides);\n    sum_of_others > longest\n}\n\nspec fn quicksort(s: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {\n    seq![]\n}\n\nspec fn sum_except_last(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nproof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)\n    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(sides: Seq<int>) -> (result: String)\n    requires\n        valid_input(sides),\n    ensures\n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        (result@ == seq!['Y', 'e', 's']) == can_form_polygon(sides),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd::prelude::*;\n              fn main() {\n    }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4229_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn int_to_string(i: int) -> Seq<char>\n    recommends i >= 0\n{\n    seq!['1']\n}\n\nspec fn parse_int_from_string(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    1\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool\n{\n    stdin_input.len() > 0\n}\n\nspec fn sum_of_non_fizzbuzz_numbers(n: int) -> int\n    recommends n >= 0\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        0\n    } else {\n        let num = n;\n        if num % 3 != 0 && num % 5 != 0 {\n            sum_of_non_fizzbuzz_numbers(n - 1) + num\n        } else {\n            sum_of_non_fizzbuzz_numbers(n - 1)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(stdin_input)\n    ensures result.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn int_to_string(i: int) -> Seq<char>\n    recommends i >= 0\n{\n    seq!['1']\n}\n\nspec fn parse_int_from_string(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    1\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool\n{\n    stdin_input.len() > 0\n}\n\nspec fn sum_of_non_fizzbuzz_numbers(n: int) -> int\n    recommends n >= 0\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        0\n    } else {\n        let num = n;\n        if num % 3 != 0 && num % 5 != 0 {\n            sum_of_non_fizzbuzz_numbers(n - 1) + num\n        } else {\n            sum_of_non_fizzbuzz_numbers(n - 1)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(stdin_input)\n    ensures result.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4229.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 2358, "minimize_time_ms": 218029, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 58, "minimized_LOC": 58, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn int_to_string(i: int) -> Seq<char>\n    recommends i >= 0\n{\n\nspec fn parse_int_from_string(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool\n{\n\nspec fn sum_of_non_fizzbuzz_numbers(n: int) -> int\n    recommends n >= 0\n    decreases n when n >= 0\n{\n\n    decreases n when n >= 0\n\n    requires valid_input(stdin_input)\n\n    ensures result.len() > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn int_to_string(i: int) -> Seq<char>\n    recommends i >= 0\n{\n    seq!['1']\n}\n\nspec fn parse_int_from_string(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    1\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool\n{\n    stdin_input.len() > 0\n}\n\nspec fn sum_of_non_fizzbuzz_numbers(n: int) -> int\n    recommends n >= 0\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        0\n    } else {\n        let num = n;\n        if num % 3 != 0 && num % 5 != 0 {\n            sum_of_non_fizzbuzz_numbers(n - 1) + num\n        } else {\n            sum_of_non_fizzbuzz_numbers(n - 1)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(stdin_input)\n    ensures result.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        fn main() {}\n", "use vstd::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4233_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn min_int(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_input(input: Seq<u8>) -> bool {\n    input.len() >= 1 && \n    parse_grid_dimensions(input).is_some() &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => n >= 3 && m >= 3 && grid_has_valid_format(input, n, m),\n        None => false\n    })\n}\n\nspec fn parse_grid_dimensions(input: Seq<u8>) -> Option<(int, int)> {\n    Some((3, 3)) /* Placeholder - actual parsing would be complex */\n}\n\nspec fn grid_has_valid_format(input: Seq<u8>, n: int, m: int) -> bool {\n    true /* Placeholder - check that grid has n rows of m characters each, containing only '*' and '.' */\n}\n\nspec fn exists_valid_star_decomposition(input: Seq<u8>) -> bool {\n    valid_input(input) &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => exists|k: int, stars: Seq<(int, int, int)>| \n            0 <= k <= n * m && stars.len() == k &&\n            (forall|s: (int, int, int)| stars.contains(s) ==> \n                1 <= s.0 <= n && 1 <= s.1 <= m && 1 <= s.2 <= min_int(n, m)) &&\n            valid_star_decomposition(input, stars),\n        None => false\n    })\n}\n\nspec fn valid_star_decomposition(input: Seq<u8>, stars: Seq<(int, int, int)>) -> bool {\n    valid_input(input) &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => \n            (forall|s: (int, int, int)| stars.contains(s) ==> \n                s.0 >= 1 && s.0 <= n && s.1 >= 1 && s.1 <= m && s.2 > 0 &&\n                valid_star(n, m, s.0, s.1, s.2)) &&\n            (forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>\n                (grid_char_at(input, i, j) == b'*') <==> covered_by_stars(stars, i, j)),\n        None => false\n    })\n}\n\nspec fn valid_star(n: int, m: int, x: int, y: int, s: int) -> bool {\n    x >= 1 && x <= n && y >= 1 && y <= m && s > 0 &&\n    x - s >= 1 && x + s <= n && y - s >= 1 && y + s <= m\n}\n\nspec fn covered_by_stars(stars: Seq<(int, int, int)>, i: int, j: int) -> bool {\n    exists|s: (int, int, int)| stars.contains(s) && covered_by_star(s.0, s.1, s.2, i, j)\n}\n\nspec fn covered_by_star(x: int, y: int, size: int, i: int, j: int) -> bool {\n    (i == x && j == y) ||\n    (i == x && 1 <= abs_int(j - y) <= size) ||\n    (j == y && 1 <= abs_int(i - x) <= size)\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn grid_char_at(input: Seq<u8>, i: int, j: int) -> u8 {\n    b'*' /* Placeholder - actual grid parsing would be complex */\n}\n\nspec fn starts_with_int_and_valid_format(s: Seq<u8>, k: int) -> bool {\n    s.len() > 0 && \n    int_to_string_len(k) <= s.len() && \n    s.subrange(0, int_to_string_len(k) as int) == int_to_string_seq(k)\n}\n\nspec fn int_to_string_len(k: int) -> nat {\n    1 /* Placeholder */\n}\n\nspec fn int_to_string_seq(k: int) -> Seq<u8> {\n    seq![b'0'] /* Placeholder */\n}\n\nspec fn format_star_output(k: int, stars: Seq<(int, int, int)>) -> Seq<u8> {\n    if k >= 0 && stars.len() == k {\n        let result = int_to_string_seq(k).add(seq![b'\\n']);\n        format_star_output_helper(result, stars, 0)\n    } else {\n        seq![]\n    }\n}\n\nspec fn format_star_output_helper(result: Seq<u8>, stars: Seq<(int, int, int)>, idx: int) -> Seq<u8> \n    decreases stars.len() - idx\n{\n    if 0 <= idx <= stars.len() {\n        if idx >= stars.len() { \n            result \n        } else { \n            let new_result = result.add(int_to_string_seq(stars[idx].0))\n                .add(seq![b' ']).add(int_to_string_seq(stars[idx].1))\n                .add(seq![b' ']).add(int_to_string_seq(stars[idx].2))\n                .add(seq![b'\\n']);\n            format_star_output_helper(new_result, stars, idx + 1)\n        }\n    } else {\n        result\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures\n        valid_input(input.as_bytes()@) ==> \n            (result.as_bytes()@ == seq![b'-', b'1', b'\\n']) <==> !exists_valid_star_decomposition(input.as_bytes()@),\n        valid_input(input.as_bytes()@) && result.as_bytes()@ != seq![b'-', b'1', b'\\n'] ==>\n            (exists|k: int, stars: Seq<(int, int, int)>|\n                k >= 0 && stars.len() == k &&\n                valid_star_decomposition(input.as_bytes()@, stars) &&\n                result.as_bytes()@ == format_star_output(k, stars)),\n        valid_input(input.as_bytes()@) ==> result.as_bytes()@ != seq![],\n        !valid_input(input.as_bytes()@) ==> result.as_bytes()@ == seq![b'-', b'1', b'\\n'],\n        result.as_bytes()@ == seq![b'-', b'1', b'\\n'] || (exists|k: int| k >= 0 && starts_with_int_and_valid_format(result.as_bytes()@, k)),\n        result.as_bytes()@ == seq![] || result.as_bytes()@[result.as_bytes()@.len()-1] == b'\\n',\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"-1\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn min_int(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_input(input: Seq<u8>) -> bool {\n    input.len() >= 1 && \n    parse_grid_dimensions(input).is_some() &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => n >= 3 && m >= 3 && grid_has_valid_format(input, n, m),\n        None => false\n    })\n}\n\nspec fn parse_grid_dimensions(input: Seq<u8>) -> Option<(int, int)> {\n    Some((3, 3)) /* Placeholder - actual parsing would be complex */\n}\n\nspec fn grid_has_valid_format(input: Seq<u8>, n: int, m: int) -> bool {\n    true /* Placeholder - check that grid has n rows of m characters each, containing only '*' and '.' */\n}\n\nspec fn exists_valid_star_decomposition(input: Seq<u8>) -> bool {\n    valid_input(input) &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => exists|k: int, stars: Seq<(int, int, int)>| \n            0 <= k <= n * m && stars.len() == k &&\n            (forall|s: (int, int, int)| stars.contains(s) ==> \n                1 <= s.0 <= n && 1 <= s.1 <= m && 1 <= s.2 <= min_int(n, m)) &&\n            valid_star_decomposition(input, stars),\n        None => false\n    })\n}\n\nspec fn valid_star_decomposition(input: Seq<u8>, stars: Seq<(int, int, int)>) -> bool {\n    valid_input(input) &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => \n            (forall|s: (int, int, int)| stars.contains(s) ==> \n                s.0 >= 1 && s.0 <= n && s.1 >= 1 && s.1 <= m && s.2 > 0 &&\n                valid_star(n, m, s.0, s.1, s.2)) &&\n            (forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>\n                (grid_char_at(input, i, j) == b'*') <==> covered_by_stars(stars, i, j)),\n        None => false\n    })\n}\n\nspec fn valid_star(n: int, m: int, x: int, y: int, s: int) -> bool {\n    x >= 1 && x <= n && y >= 1 && y <= m && s > 0 &&\n    x - s >= 1 && x + s <= n && y - s >= 1 && y + s <= m\n}\n\nspec fn covered_by_stars(stars: Seq<(int, int, int)>, i: int, j: int) -> bool {\n    exists|s: (int, int, int)| stars.contains(s) && covered_by_star(s.0, s.1, s.2, i, j)\n}\n\nspec fn covered_by_star(x: int, y: int, size: int, i: int, j: int) -> bool {\n    (i == x && j == y) ||\n    (i == x && 1 <= abs_int(j - y) <= size) ||\n    (j == y && 1 <= abs_int(i - x) <= size)\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn grid_char_at(input: Seq<u8>, i: int, j: int) -> u8 {\n    b'*' /* Placeholder - actual grid parsing would be complex */\n}\n\nspec fn starts_with_int_and_valid_format(s: Seq<u8>, k: int) -> bool {\n    s.len() > 0 && \n    int_to_string_len(k) <= s.len() && \n    s.subrange(0, int_to_string_len(k) as int) == int_to_string_seq(k)\n}\n\nspec fn int_to_string_len(k: int) -> nat {\n    1 /* Placeholder */\n}\n\nspec fn int_to_string_seq(k: int) -> Seq<u8> {\n    seq![b'0'] /* Placeholder */\n}\n\nspec fn format_star_output(k: int, stars: Seq<(int, int, int)>) -> Seq<u8> {\n    if k >= 0 && stars.len() == k {\n        let result = int_to_string_seq(k).add(seq![b'\\n']);\n        format_star_output_helper(result, stars, 0)\n    } else {\n        seq![]\n    }\n}\n\nspec fn format_star_output_helper(result: Seq<u8>, stars: Seq<(int, int, int)>, idx: int) -> Seq<u8> \n    decreases stars.len() - idx\n{\n    if 0 <= idx <= stars.len() {\n        if idx >= stars.len() { \n            result \n        } else { \n            let new_result = result.add(int_to_string_seq(stars[idx].0))\n                .add(seq![b' ']).add(int_to_string_seq(stars[idx].1))\n                .add(seq![b' ']).add(int_to_string_seq(stars[idx].2))\n                .add(seq![b'\\n']);\n            format_star_output_helper(new_result, stars, idx + 1)\n        }\n    } else {\n        result\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures\n        valid_input(input.as_bytes()@) ==> \n            (result.as_bytes()@ == seq![b'-', b'1', b'\\n']) <==> !exists_valid_star_decomposition(input.as_bytes()@),\n        valid_input(input.as_bytes()@) && result.as_bytes()@ != seq![b'-', b'1', b'\\n'] ==>\n            (exists|k: int, stars: Seq<(int, int, int)>|\n                k >= 0 && stars.len() == k &&\n                valid_star_decomposition(input.as_bytes()@, stars) &&\n                result.as_bytes()@ == format_star_output(k, stars)),\n        valid_input(input.as_bytes()@) ==> result.as_bytes()@ != seq![],\n        !valid_input(input.as_bytes()@) ==> result.as_bytes()@ == seq![b'-', b'1', b'\\n'],\n        result.as_bytes()@ == seq![b'-', b'1', b'\\n'] || (exists|k: int| k >= 0 && starts_with_int_and_valid_format(result.as_bytes()@, k)),\n        result.as_bytes()@ == seq![] || result.as_bytes()@[result.as_bytes()@.len()-1] == b'\\n',\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"-1\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4233.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1382, "verus_errors": [{"error_type": "TypeAnnotation", "error_text": "type annotations needed (cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`)", "message": "VerusErrorType.TypeAnnotation: type annotations needed (cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmptu97jtjh", "lines": [130, 130], "label": "cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`", "text": [{"text": "        valid_input(input.as_bytes()@) ==> result.as_bytes()@ != seq![],", "highlight_start": 44, "highlight_end": 72}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 147, "minimized_LOC": 147, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 22, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn min_int(a: int, b: int) -> int {\n\nspec fn valid_input(input: Seq<u8>) -> bool {\n\nspec fn parse_grid_dimensions(input: Seq<u8>) -> Option<(int, int)> {\n\nspec fn grid_has_valid_format(input: Seq<u8>, n: int, m: int) -> bool {\n\nspec fn exists_valid_star_decomposition(input: Seq<u8>) -> bool {\n\nspec fn valid_star_decomposition(input: Seq<u8>, stars: Seq<(int, int, int)>) -> bool {\n\nspec fn valid_star(n: int, m: int, x: int, y: int, s: int) -> bool {\n\nspec fn covered_by_stars(stars: Seq<(int, int, int)>, i: int, j: int) -> bool {\n\nspec fn covered_by_star(x: int, y: int, size: int, i: int, j: int) -> bool {\n\nspec fn abs_int(x: int) -> int {\n\nspec fn grid_char_at(input: Seq<u8>, i: int, j: int) -> u8 {\n\nspec fn starts_with_int_and_valid_format(s: Seq<u8>, k: int) -> bool {\n\nspec fn int_to_string_len(k: int) -> nat {\n\nspec fn int_to_string_seq(k: int) -> Seq<u8> {\n\nspec fn format_star_output(k: int, stars: Seq<(int, int, int)>) -> Seq<u8> {\n\nspec fn format_star_output_helper(result: Seq<u8>, stars: Seq<(int, int, int)>, idx: int) -> Seq<u8> \n    decreases stars.len() - idx\n{\n\n    decreases stars.len() - idx\n\n    requires input.len() > 0\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_4271_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>, b: Seq<int>, c: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    b.len() == n &&\n    c.len() == n - 1 &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] a[i] != #[trigger] a[j])\n}\n\nspec fn sum_satisfaction(a: Seq<int>, b: Seq<int>, c: Seq<int>, n: int) -> int\n    recommends\n        n >= 1,\n        a.len() == n,\n        b.len() == n,\n        c.len() == n - 1,\n        forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n\n{\n    sum_satisfaction_up_to(a, b, c, n)\n}\n\nspec fn sum_satisfaction_up_to(a: Seq<int>, b: Seq<int>, c: Seq<int>, k: int) -> int\n    recommends\n        0 <= k <= a.len(),\n        b.len() == a.len(),\n        c.len() == a.len() - 1,\n        forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= a.len()\n    decreases k\n{\n    if k <= 0 {\n        0\n    } else {\n        let prev_sum = sum_satisfaction_up_to(a, b, c, k - 1);\n        let base_contrib = b[a[k - 1] - 1];\n        let bonus_contrib = if k > 1 && a[k - 1] == a[k - 2] + 1 {\n            c[a[k - 1] - 2]\n        } else {\n            0\n        };\n        prev_sum + base_contrib + bonus_contrib\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>, b: Vec<i8>, c: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))\n    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>, b: Seq<int>, c: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    b.len() == n &&\n    c.len() == n - 1 &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] a[i] != #[trigger] a[j])\n}\n\nspec fn sum_satisfaction(a: Seq<int>, b: Seq<int>, c: Seq<int>, n: int) -> int\n    recommends\n        n >= 1,\n        a.len() == n,\n        b.len() == n,\n        c.len() == n - 1,\n        forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n\n{\n    sum_satisfaction_up_to(a, b, c, n)\n}\n\nspec fn sum_satisfaction_up_to(a: Seq<int>, b: Seq<int>, c: Seq<int>, k: int) -> int\n    recommends\n        0 <= k <= a.len(),\n        b.len() == a.len(),\n        c.len() == a.len() - 1,\n        forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= a.len()\n    decreases k\n{\n    if k <= 0 {\n        0\n    } else {\n        let prev_sum = sum_satisfaction_up_to(a, b, c, k - 1);\n        let base_contrib = b[a[k - 1] - 1];\n        let bonus_contrib = if k > 1 && a[k - 1] == a[k - 2] + 1 {\n            c[a[k - 1] - 2]\n        } else {\n            0\n        };\n        prev_sum + base_contrib + bonus_contrib\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>, b: Vec<i8>, c: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))\n    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4271.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1855, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [53, 53], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))", "highlight_start": 43, "highlight_end": 55}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [53, 53], "label": "arguments to this method are incorrect", "text": [{"text": "    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))", "highlight_start": 39, "highlight_end": 42}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [53, 53], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))", "highlight_start": 65, "highlight_end": 77}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [53, 53], "label": "arguments to this method are incorrect", "text": [{"text": "    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))", "highlight_start": 61, "highlight_end": 64}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [53, 53], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))", "highlight_start": 87, "highlight_end": 99}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [53, 53], "label": "arguments to this method are incorrect", "text": [{"text": "    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))", "highlight_start": 83, "highlight_end": 86}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [54, 54], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)", "highlight_start": 54, "highlight_end": 66}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [54, 54], "label": "arguments to this method are incorrect", "text": [{"text": "    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)", "highlight_start": 50, "highlight_end": 53}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [54, 54], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)", "highlight_start": 76, "highlight_end": 88}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [54, 54], "label": "arguments to this method are incorrect", "text": [{"text": "    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)", "highlight_start": 72, "highlight_end": 75}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [54, 54], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)", "highlight_start": 98, "highlight_end": 110}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5wpjysqp", "lines": [54, 54], "label": "arguments to this method are incorrect", "text": [{"text": "    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)", "highlight_start": 94, "highlight_end": 97}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>, c: Seq<int>) -> bool {\n\nspec fn sum_satisfaction(a: Seq<int>, b: Seq<int>, c: Seq<int>, n: int) -> int\n    recommends\n        n >= 1,\n        a.len() == n,\n        b.len() == n,\n        c.len() == n - 1,\n        forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n\n{\n\nspec fn sum_satisfaction_up_to(a: Seq<int>, b: Seq<int>, c: Seq<int>, k: int) -> int\n    recommends\n        0 <= k <= a.len(),\n        b.len() == a.len(),\n        c.len() == a.len() - 1,\n        forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= a.len()\n    decreases k\n{\n\n    decreases k\n\n    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))\n\n    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)"}}}, "all_snapshots": []}
{"id": "apps_test_4274_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { seq![] }\n\nspec fn str_to_int(s: Seq<char>) -> int { 0 }\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|lines: Seq<Seq<char>>| lines == split_string(input, '\\n') && lines.len() > 0 &&\n    exists|parts: Seq<Seq<char>>| parts == split_string(lines[0], ' ') && parts.len() == 2 &&\n    {\n        let n = str_to_int(parts[0]);\n        let m = str_to_int(parts[1]);\n        1 <= n <= 100 && 0 <= m <= n\n    }\n}\n\nspec fn extract_n(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[0])\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[1])\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let n = extract_n(input);\n    let m = extract_m(input);\n    (n == m ==> result == seq!['Y', 'e', 's']) && (n != m ==> result == seq!['N', 'o'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\nrequires \n    valid_input(input@)\nensures \n    correct_output(input@, result@),\n    result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { seq![] }\n\nspec fn str_to_int(s: Seq<char>) -> int { 0 }\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|lines: Seq<Seq<char>>| lines == split_string(input, '\\n') && lines.len() > 0 &&\n    exists|parts: Seq<Seq<char>>| parts == split_string(lines[0], ' ') && parts.len() == 2 &&\n    {\n        let n = str_to_int(parts[0]);\n        let m = str_to_int(parts[1]);\n        1 <= n <= 100 && 0 <= m <= n\n    }\n}\n\nspec fn extract_n(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[0])\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[1])\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let n = extract_n(input);\n    let m = extract_m(input);\n    (n == m ==> result == seq!['Y', 'e', 's']) && (n != m ==> result == seq!['N', 'o'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\nrequires \n    valid_input(input@)\nensures \n    correct_output(input@, result@),\n    result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4274.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 3409, "minimize_time_ms": 215815, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n\nspec fn str_to_int(s: Seq<char>) -> int {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn extract_n(input: Seq<char>) -> int {\n\nspec fn extract_m(input: Seq<char>) -> int {\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n\nrequires \n\nensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { seq![] }\n\nspec fn str_to_int(s: Seq<char>) -> int { 0 }\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|lines: Seq<Seq<char>>| lines == split_string(input, '\\n') && lines.len() > 0 &&\n    exists|parts: Seq<Seq<char>>| parts == split_string(lines[0], ' ') && parts.len() == 2 &&\n    {\n        let n = str_to_int(parts[0]);\n        let m = str_to_int(parts[1]);\n        1 <= n <= 100 && 0 <= m <= n\n    }\n}\n\nspec fn extract_n(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[0])\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[1])\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let n = extract_n(input);\n    let m = extract_m(input);\n    (n == m ==> result == seq!['Y', 'e', 's']) && (n != m ==> result == seq!['N', 'o'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\nrequires \n    valid_input(input@)\nensures \n    correct_output(input@, result@),\n    result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4307_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn is_odd(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn count_divisors(n: nat) -> nat\n    recommends n > 0\n{\n    Set::new(|d: nat| 1 <= d <= n && n % d == 0).len()\n}\n\nspec fn has_eight_divisors(n: nat) -> bool\n    recommends n > 0\n{\n    count_divisors(n) == 8\n}\n\nspec fn count_odd_with_eight_divisors(n: nat) -> nat {\n    Set::new(|i: nat| 1 <= i <= n && is_odd(i as int) && i > 0 && has_eight_divisors(i)).len()\n}\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 200\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int) -> (count: int)\n    requires \n        valid_input(n)\n    ensures \n        n < 105 ==> count == 0,\n        105 <= n && n < 135 ==> count == 1,\n        135 <= n && n < 165 ==> count == 2,\n        165 <= n && n < 189 ==> count == 3,\n        189 <= n && n < 195 ==> count == 4,\n        n >= 195 ==> count == 5,\n        0 <= count && count <= 5,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0int\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn is_odd(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn count_divisors(n: nat) -> nat\n    recommends n > 0\n{\n    Set::new(|d: nat| 1 <= d <= n && n % d == 0).len()\n}\n\nspec fn has_eight_divisors(n: nat) -> bool\n    recommends n > 0\n{\n    count_divisors(n) == 8\n}\n\nspec fn count_odd_with_eight_divisors(n: nat) -> nat {\n    Set::new(|i: nat| 1 <= i <= n && is_odd(i as int) && i > 0 && has_eight_divisors(i)).len()\n}\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 200\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int) -> (count: int)\n    requires \n        valid_input(n)\n    ensures \n        n < 105 ==> count == 0,\n        105 <= n && n < 135 ==> count == 1,\n        135 <= n && n < 165 ==> count == 2,\n        165 <= n && n < 189 ==> count == 3,\n        189 <= n && n < 195 ==> count == 4,\n        n >= 195 ==> count == 5,\n        0 <= count && count <= 5,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0int\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4307.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1170, "verus_errors": [{"error_type": "Other", "error_text": "invalid suffix `int` for number literal (invalid suffix `int`)", "message": "VerusErrorType.Other: invalid suffix `int` for number literal (invalid suffix `int`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpx84hexiy", "lines": [49, 49], "label": "invalid suffix `int`", "text": [{"text": "    0int", "highlight_start": 5, "highlight_end": 9}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_odd(n: int) -> bool {\n\nspec fn count_divisors(n: nat) -> nat\n    recommends n > 0\n{\n\nspec fn has_eight_divisors(n: nat) -> bool\n    recommends n > 0\n{\n\nspec fn count_odd_with_eight_divisors(n: nat) -> nat {\n\nspec fn valid_input(n: int) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_4346_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn join_lines(lines: Seq<Seq<char>>) -> Seq<char> {\n    seq![]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let t = parse_int(lines[0]);\n        t >= 0 && lines.len() >= t + 1 &&\n        forall|i: int| 1 <= i <= t ==> {\n            let line_parts = split_spaces(lines[i]);\n            line_parts.len() >= 4 &&\n            forall|j: int| 0 <= j < 4 ==> is_valid_integer(line_parts[j]) &&\n            {\n                let parts = split_spaces(lines[i]);\n                let L = parse_int(parts[0]);\n                let v = parse_int(parts[1]);\n                let l = parse_int(parts[2]);\n                let r = parse_int(parts[3]);\n                L >= 1 && v >= 1 && l >= 1 && r >= l && r <= L\n            }\n        }\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    forall|c: char| output.contains(c) ==> (c >= '0' && c <= '9') || c == '-' || c == '\\n'\n}\n\nspec fn output_matches_algorithm(output: Seq<char>, input: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let t = parse_int(lines[0]);\n    t >= 0 &&\n    {\n        let expected_lines = Seq::new(t as nat, |i: int| {\n            if i + 1 < lines.len() && split_spaces(lines[i + 1]).len() >= 4 {\n                let parts = split_spaces(lines[i + 1]);\n                let L = parse_int(parts[0]);\n                let v = parse_int(parts[1]);\n                let l = parse_int(parts[2]);\n                let r = parse_int(parts[3]);\n                let total_lanterns = L / v;\n                let blocked_lanterns = r / v - (l - 1) / v;\n                let visible_lanterns = total_lanterns - blocked_lanterns;\n                int_to_string(visible_lanterns)\n            } else {\n                seq!['0']\n            }\n        });\n        output == join_lines(expected_lines)\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (\n        (s[0] == '-' && s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9') ||\n        (s[0] != '-' && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9')\n    )\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (output: String)\n    requires \n        input.len() > 0,\n        valid_input(input@),\n    ensures \n        valid_output(output@, input@),\n        output_matches_algorithm(output@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn join_lines(lines: Seq<Seq<char>>) -> Seq<char> {\n    seq![]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let t = parse_int(lines[0]);\n        t >= 0 && lines.len() >= t + 1 &&\n        forall|i: int| 1 <= i <= t ==> {\n            let line_parts = split_spaces(lines[i]);\n            line_parts.len() >= 4 &&\n            forall|j: int| 0 <= j < 4 ==> is_valid_integer(line_parts[j]) &&\n            {\n                let parts = split_spaces(lines[i]);\n                let L = parse_int(parts[0]);\n                let v = parse_int(parts[1]);\n                let l = parse_int(parts[2]);\n                let r = parse_int(parts[3]);\n                L >= 1 && v >= 1 && l >= 1 && r >= l && r <= L\n            }\n        }\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    forall|c: char| output.contains(c) ==> (c >= '0' && c <= '9') || c == '-' || c == '\\n'\n}\n\nspec fn output_matches_algorithm(output: Seq<char>, input: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let t = parse_int(lines[0]);\n    t >= 0 &&\n    {\n        let expected_lines = Seq::new(t as nat, |i: int| {\n            if i + 1 < lines.len() && split_spaces(lines[i + 1]).len() >= 4 {\n                let parts = split_spaces(lines[i + 1]);\n                let L = parse_int(parts[0]);\n                let v = parse_int(parts[1]);\n                let l = parse_int(parts[2]);\n                let r = parse_int(parts[3]);\n                let total_lanterns = L / v;\n                let blocked_lanterns = r / v - (l - 1) / v;\n                let visible_lanterns = total_lanterns - blocked_lanterns;\n                int_to_string(visible_lanterns)\n            } else {\n                seq!['0']\n            }\n        });\n        output == join_lines(expected_lines)\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (\n        (s[0] == '-' && s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9') ||\n        (s[0] != '-' && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9')\n    )\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (output: String)\n    requires \n        input.len() > 0,\n        valid_input(input@),\n    ensures \n        valid_output(output@, input@),\n        output_matches_algorithm(output@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4346.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 2019, "verus_errors": [{"error_type": "Other", "error_text": "`alloc::string::impl&%0::new` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "message": "VerusErrorType.Other: `alloc::string::impl&%0::new` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpmexp58oe", "lines": [101, 101], "label": null, "text": [{"text": "    String::new()", "highlight_start": 5, "highlight_end": 18}]}]}, {"error_type": "Other", "error_text": "`core::str::impl&%0::len` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "message": "VerusErrorType.Other: `core::str::impl&%0::len` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpmexp58oe", "lines": [92, 92], "label": null, "text": [{"text": "        input.len() > 0,", "highlight_start": 9, "highlight_end": 20}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 108, "minimized_LOC": 108, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int(s: Seq<char>) -> int {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn join_lines(lines: Seq<Seq<char>>) -> Seq<char> {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn output_matches_algorithm(output: Seq<char>, input: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_4364_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<u8>) -> bool {\n    s.len() >= 4 && forall|i: int| 0 <= i < 4 ==> b'0' <= s[i] <= b'9'\n}\n\nspec fn char_pair_to_int(c1: u8, c2: u8) -> int \n    recommends b'0' <= c1 <= b'9' && b'0' <= c2 <= b'9'\n{\n    (c1 as int - b'0' as int) * 10 + (c2 as int - b'0' as int)\n}\n\nspec fn valid_month(n: int) -> bool {\n    1 <= n <= 12\n}\n\nspec fn get_first_pair(s: Seq<u8>) -> int \n    recommends valid_input(s)\n{\n    char_pair_to_int(s[0], s[1])\n}\n\nspec fn get_second_pair(s: Seq<u8>) -> int \n    recommends valid_input(s)\n{\n    char_pair_to_int(s[2], s[3])\n}\n\nspec fn correct_result(s: Seq<u8>, result: Seq<u8>) -> bool \n    recommends valid_input(s)\n{\n    let s1 = get_first_pair(s);\n    let s2 = get_second_pair(s);\n    let s1_valid = valid_month(s1);\n    let s2_valid = valid_month(s2);\n    (s1_valid && s2_valid ==> result == \"AMBIGUOUS\\n\".as_bytes()) &&\n    (s1_valid && !s2_valid ==> result == \"MMYY\\n\".as_bytes()) &&\n    (!s1_valid && s2_valid ==> result == \"YYMM\\n\".as_bytes()) &&\n    (!s1_valid && !s2_valid ==> result == \"NA\\n\".as_bytes())\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(stdin_input@),\n    ensures (result@ == \"AMBIGUOUS\\n\".as_bytes() || \n             result@ == \"MMYY\\n\".as_bytes() || \n             result@ == \"YYMM\\n\".as_bytes() || \n             result@ == \"NA\\n\".as_bytes()) &&\n            correct_result(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<u8>) -> bool {\n    s.len() >= 4 && forall|i: int| 0 <= i < 4 ==> b'0' <= s[i] <= b'9'\n}\n\nspec fn char_pair_to_int(c1: u8, c2: u8) -> int \n    recommends b'0' <= c1 <= b'9' && b'0' <= c2 <= b'9'\n{\n    (c1 as int - b'0' as int) * 10 + (c2 as int - b'0' as int)\n}\n\nspec fn valid_month(n: int) -> bool {\n    1 <= n <= 12\n}\n\nspec fn get_first_pair(s: Seq<u8>) -> int \n    recommends valid_input(s)\n{\n    char_pair_to_int(s[0], s[1])\n}\n\nspec fn get_second_pair(s: Seq<u8>) -> int \n    recommends valid_input(s)\n{\n    char_pair_to_int(s[2], s[3])\n}\n\nspec fn correct_result(s: Seq<u8>, result: Seq<u8>) -> bool \n    recommends valid_input(s)\n{\n    let s1 = get_first_pair(s);\n    let s2 = get_second_pair(s);\n    let s1_valid = valid_month(s1);\n    let s2_valid = valid_month(s2);\n    (s1_valid && s2_valid ==> result == \"AMBIGUOUS\\n\".as_bytes()) &&\n    (s1_valid && !s2_valid ==> result == \"MMYY\\n\".as_bytes()) &&\n    (!s1_valid && s2_valid ==> result == \"YYMM\\n\".as_bytes()) &&\n    (!s1_valid && !s2_valid ==> result == \"NA\\n\".as_bytes())\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(stdin_input@),\n    ensures (result@ == \"AMBIGUOUS\\n\".as_bytes() || \n             result@ == \"MMYY\\n\".as_bytes() || \n             result@ == \"YYMM\\n\".as_bytes() || \n             result@ == \"NA\\n\".as_bytes()) &&\n            correct_result(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4364.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1740, "verus_errors": [{"error_type": "Other", "error_text": "Unsupported constant type ()", "message": "VerusErrorType.Other: Unsupported constant type ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfszrn87h", "lines": [7, 7], "label": null, "text": [{"text": "    s.len() >= 4 && forall|i: int| 0 <= i < 4 ==> b'0' <= s[i] <= b'9'", "highlight_start": 51, "highlight_end": 55}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<u8>) -> bool {\n\nspec fn char_pair_to_int(c1: u8, c2: u8) -> int \n    recommends b'0' <= c1 <= b'9' && b'0' <= c2 <= b'9'\n{\n\nspec fn valid_month(n: int) -> bool {\n\nspec fn get_first_pair(s: Seq<u8>) -> int \n    recommends valid_input(s)\n{\n\nspec fn get_second_pair(s: Seq<u8>) -> int \n    recommends valid_input(s)\n{\n\nspec fn correct_result(s: Seq<u8>, result: Seq<u8>) -> bool \n    recommends valid_input(s)\n{\n\n    requires valid_input(stdin_input@),\n\n    ensures (result@ == \"AMBIGUOUS\\n\".as_bytes() || "}}}, "all_snapshots": []}
{"id": "apps_test_4398_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n/* Helper functions for string processing - these would need to be defined elsewhere */\nspec fn split_lines(input: &str) -> Seq<&str>;\nspec fn string_to_int(s: &str) -> int;\nspec fn split_by_space(s: &str) -> Seq<&str>;\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && {\n        let n = string_to_int(lines[0]);\n        let parts = split_by_space(lines[1]);\n        parts.len() >= 2 &&\n        n >= 0 &&\n        n <= parts[0].len() && n <= parts[1].len()\n    }\n}\n\nspec fn get_n(input: &str) -> int\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    string_to_int(lines[0])\n}\n\nspec fn get_s(input: &str) -> &str\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let parts = split_by_space(lines[1]);\n    parts[0]\n}\n\nspec fn get_t(input: &str) -> &str\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let parts = split_by_space(lines[1]);\n    parts[1]\n}\n\nspec fn alternate_chars(s: &str, t: &str, n: int) -> Seq<char>\n    recommends n >= 0 && n <= s.len() && n <= t.len()\n{\n    if n == 0 {\n        seq![]\n    } else {\n        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures\n        valid_input(input) ==> {\n            let n = get_n(input);\n            let s = get_s(input);\n            let t = get_t(input);\n            result.len() == 2 * n + 1 &&\n            result.get_char((result.len() - 1) as int) == '\\n' &&\n            result.substring_char(0, (result.len() - 1) as int).view() == alternate_chars(s, t, n)\n        } && !valid_input(input) ==> result == \"\"\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n/* Helper functions for string processing - these would need to be defined elsewhere */\nspec fn split_lines(input: &str) -> Seq<&str>;\nspec fn string_to_int(s: &str) -> int;\nspec fn split_by_space(s: &str) -> Seq<&str>;\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && {\n        let n = string_to_int(lines[0]);\n        let parts = split_by_space(lines[1]);\n        parts.len() >= 2 &&\n        n >= 0 &&\n        n <= parts[0].len() && n <= parts[1].len()\n    }\n}\n\nspec fn get_n(input: &str) -> int\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    string_to_int(lines[0])\n}\n\nspec fn get_s(input: &str) -> &str\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let parts = split_by_space(lines[1]);\n    parts[0]\n}\n\nspec fn get_t(input: &str) -> &str\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let parts = split_by_space(lines[1]);\n    parts[1]\n}\n\nspec fn alternate_chars(s: &str, t: &str, n: int) -> Seq<char>\n    recommends n >= 0 && n <= s.len() && n <= t.len()\n{\n    if n == 0 {\n        seq![]\n    } else {\n        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures\n        valid_input(input) ==> {\n            let n = get_n(input);\n            let s = get_s(input);\n            let t = get_t(input);\n            result.len() == 2 * n + 1 &&\n            result.get_char((result.len() - 1) as int) == '\\n' &&\n            result.substring_char(0, (result.len() - 1) as int).view() == alternate_chars(s, t, n)\n        } && !valid_input(input) ==> result == \"\"\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4398.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1905, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types (expected `usize`, found `int`; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `usize`, found `int`; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpe5h6xwk1", "lines": [51, 51], "label": "expected `usize`, found `int`", "text": [{"text": "        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)", "highlight_start": 83, "highlight_end": 97}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpe5h6xwk1", "lines": [51, 51], "label": "arguments to this method are incorrect", "text": [{"text": "        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)", "highlight_start": 65, "highlight_end": 79}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `usize`, found `int`; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `usize`, found `int`; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpe5h6xwk1", "lines": [51, 51], "label": "expected `usize`, found `int`", "text": [{"text": "        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)", "highlight_start": 121, "highlight_end": 135}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpe5h6xwk1", "lines": [51, 51], "label": "arguments to this method are incorrect", "text": [{"text": "        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)", "highlight_start": 103, "highlight_end": 117}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `usize`, found `int`; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `usize`, found `int`; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpe5h6xwk1", "lines": [68, 68], "label": "expected `usize`, found `int`", "text": [{"text": "            result.get_char((result.len() - 1) as int) == '\\n' &&", "highlight_start": 29, "highlight_end": 54}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpe5h6xwk1", "lines": [68, 68], "label": "arguments to this method are incorrect", "text": [{"text": "            result.get_char((result.len() - 1) as int) == '\\n' &&", "highlight_start": 20, "highlight_end": 28}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected `usize`, found `int`; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected `usize`, found `int`; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpe5h6xwk1", "lines": [69, 69], "label": "expected `usize`, found `int`", "text": [{"text": "            result.substring_char(0, (result.len() - 1) as int).view() == alternate_chars(s, t, n)", "highlight_start": 38, "highlight_end": 63}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpe5h6xwk1", "lines": [69, 69], "label": "arguments to this method are incorrect", "text": [{"text": "            result.substring_char(0, (result.len() - 1) as int).view() == alternate_chars(s, t, n)", "highlight_start": 20, "highlight_end": 34}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 82, "minimized_LOC": 82, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(input: &str) -> Seq<&str>;\nspec fn string_to_int(s: &str) -> int;\nspec fn split_by_space(s: &str) -> Seq<&str>;\n\nspec fn valid_input(input: &str) -> bool {\n\nspec fn string_to_int(s: &str) -> int;\nspec fn split_by_space(s: &str) -> Seq<&str>;\n\nspec fn valid_input(input: &str) -> bool {\n\nspec fn split_by_space(s: &str) -> Seq<&str>;\n\nspec fn valid_input(input: &str) -> bool {\n\nspec fn valid_input(input: &str) -> bool {\n\nspec fn get_n(input: &str) -> int\n    recommends valid_input(input)\n{\n\nspec fn get_s(input: &str) -> &str\n    recommends valid_input(input)\n{\n\nspec fn get_t(input: &str) -> &str\n    recommends valid_input(input)\n{\n\nspec fn alternate_chars(s: &str, t: &str, n: int) -> Seq<char>\n    recommends n >= 0 && n <= s.len() && n <= t.len()\n{\n\n    requires input.len() > 0\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_4418_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 0 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> \n        #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || \n        #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int\n}\n\nspec fn number_of_complete_subsequences(n: int, a: Seq<int>) -> int {\n    let k = seq![4int, 8int, 15int, 16int, 23int, 42int];\n    let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];\n    let final_s = process_array(s, a, k, 0int);\n    final_s[6int]\n}\n\nspec fn process_array(s: Seq<int>, a: Seq<int>, k: Seq<int>, index: int) -> Seq<int>\n    decreases a.len() - index\n{\n    if s.len() == 7 && k.len() == 6 && 0 <= index <= a.len() &&\n       (forall|i: int| 0 <= i < a.len() ==> \n            #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || \n            #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int) &&\n       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&\n       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {\n        if index == a.len() {\n            s\n        } else {\n            let ai = a[index];\n            let new_s = update_state(s, ai, k);\n            process_array(new_s, a, k, index + 1)\n        }\n    } else {\n        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]\n    }\n}\n\nspec fn update_state(s: Seq<int>, ai: int, k: Seq<int>) -> Seq<int> {\n    if s.len() == 7 && k.len() == 6 &&\n       (ai == 4int || ai == 8int || ai == 15int || ai == 16int || ai == 23int || ai == 42int) &&\n       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&\n       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {\n        if ai == k[5int] && s[5int] > 0 {\n            s.update(6int, s[6int] + 1).update(5int, s[5int] - 1)\n        } else if ai == k[4int] && s[4int] > 0 {\n            s.update(5int, s[5int] + 1).update(4int, s[4int] - 1)\n        } else if ai == k[3int] && s[3int] > 0 {\n            s.update(4int, s[4int] + 1).update(3int, s[3int] - 1)\n        } else if ai == k[2int] && s[2int] > 0 {\n            s.update(3int, s[3int] + 1).update(2int, s[2int] - 1)\n        } else if ai == k[1int] && s[1int] > 0 {\n            s.update(2int, s[2int] + 1).update(1int, s[1int] - 1)\n        } else if ai == k[0int] && s[0int] > 0 {\n            s.update(1int, s[1int] + 1).update(0int, s[0int] - 1)\n        } else {\n            s\n        }\n    } else {\n        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]\n    }\n}\n\nspec fn number_of_complete_subsequences_partial(n: int, a: Seq<int>, k: Seq<int>, index: int) -> int {\n    if valid_input(n, a) && k.len() == 6 && k == seq![4int, 8int, 15int, 16int, 23int, 42int] && 0 <= index <= a.len() {\n        let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];\n        let partial_a = if index == 0 { seq![] } else { a.subrange(0int, index) };\n        let final_s = process_array(s, partial_a, k, 0int);\n        final_s[6int]\n    } else {\n        0int\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    valid_input(n as int, a@.map(|x: i8| x as int)),\n  ensures\n    0 <= result as int <= n as int,\n    result as int == n as int - 6 * number_of_complete_subsequences(n as int, a@.map(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 0 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> \n        #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || \n        #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int\n}\n\nspec fn number_of_complete_subsequences(n: int, a: Seq<int>) -> int {\n    let k = seq![4int, 8int, 15int, 16int, 23int, 42int];\n    let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];\n    let final_s = process_array(s, a, k, 0int);\n    final_s[6int]\n}\n\nspec fn process_array(s: Seq<int>, a: Seq<int>, k: Seq<int>, index: int) -> Seq<int>\n    decreases a.len() - index\n{\n    if s.len() == 7 && k.len() == 6 && 0 <= index <= a.len() &&\n       (forall|i: int| 0 <= i < a.len() ==> \n            #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || \n            #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int) &&\n       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&\n       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {\n        if index == a.len() {\n            s\n        } else {\n            let ai = a[index];\n            let new_s = update_state(s, ai, k);\n            process_array(new_s, a, k, index + 1)\n        }\n    } else {\n        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]\n    }\n}\n\nspec fn update_state(s: Seq<int>, ai: int, k: Seq<int>) -> Seq<int> {\n    if s.len() == 7 && k.len() == 6 &&\n       (ai == 4int || ai == 8int || ai == 15int || ai == 16int || ai == 23int || ai == 42int) &&\n       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&\n       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {\n        if ai == k[5int] && s[5int] > 0 {\n            s.update(6int, s[6int] + 1).update(5int, s[5int] - 1)\n        } else if ai == k[4int] && s[4int] > 0 {\n            s.update(5int, s[5int] + 1).update(4int, s[4int] - 1)\n        } else if ai == k[3int] && s[3int] > 0 {\n            s.update(4int, s[4int] + 1).update(3int, s[3int] - 1)\n        } else if ai == k[2int] && s[2int] > 0 {\n            s.update(3int, s[3int] + 1).update(2int, s[2int] - 1)\n        } else if ai == k[1int] && s[1int] > 0 {\n            s.update(2int, s[2int] + 1).update(1int, s[1int] - 1)\n        } else if ai == k[0int] && s[0int] > 0 {\n            s.update(1int, s[1int] + 1).update(0int, s[0int] - 1)\n        } else {\n            s\n        }\n    } else {\n        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]\n    }\n}\n\nspec fn number_of_complete_subsequences_partial(n: int, a: Seq<int>, k: Seq<int>, index: int) -> int {\n    if valid_input(n, a) && k.len() == 6 && k == seq![4int, 8int, 15int, 16int, 23int, 42int] && 0 <= index <= a.len() {\n        let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];\n        let partial_a = if index == 0 { seq![] } else { a.subrange(0int, index) };\n        let final_s = process_array(s, partial_a, k, 0int);\n        final_s[6int]\n    } else {\n        0int\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    valid_input(n as int, a@.map(|x: i8| x as int)),\n  ensures\n    0 <= result as int <= n as int,\n    result as int == n as int - 6 * number_of_complete_subsequences(n as int, a@.map(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4418.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1672, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp1rts3385", "lines": [83, 83], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    valid_input(n as int, a@.map(|x: i8| x as int)),", "highlight_start": 34, "highlight_end": 50}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp1rts3385", "lines": [83, 83], "label": "arguments to this method are incorrect", "text": [{"text": "    valid_input(n as int, a@.map(|x: i8| x as int)),", "highlight_start": 30, "highlight_end": 33}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp1rts3385", "lines": [86, 86], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    result as int == n as int - 6 * number_of_complete_subsequences(n as int, a@.map(|x: i8| x as int)),", "highlight_start": 86, "highlight_end": 102}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp1rts3385", "lines": [86, 86], "label": "arguments to this method are incorrect", "text": [{"text": "    result as int == n as int - 6 * number_of_complete_subsequences(n as int, a@.map(|x: i8| x as int)),", "highlight_start": 82, "highlight_end": 85}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 98, "minimized_LOC": 98, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>) -> bool {\n\nspec fn number_of_complete_subsequences(n: int, a: Seq<int>) -> int {\n\nspec fn process_array(s: Seq<int>, a: Seq<int>, k: Seq<int>, index: int) -> Seq<int>\n    decreases a.len() - index\n{\n\nspec fn update_state(s: Seq<int>, ai: int, k: Seq<int>) -> Seq<int> {\n\nspec fn number_of_complete_subsequences_partial(n: int, a: Seq<int>, k: Seq<int>, index: int) -> int {\n\n    decreases a.len() - index\n\n  requires\n\n  ensures"}}}, "all_snapshots": []}
{"id": "apps_test_4460_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> \n        s[i] == ' ' || s[i] == '\\n' || ('0' <= s[i] <= '9') || s[i] == '-')\n}\n\nspec fn valid_number(s: Seq<char>) -> bool {\n    s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> \n        '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))\n}\n\nspec fn count_zeros(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        0int\n    } else {\n        (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))\n    }\n}\n\nspec fn find_zero_index(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() > 0 && count_zeros(numbers) == 1 {\n        if numbers[0] == 0 {\n            0int\n        } else if numbers.len() > 1 {\n            1int + find_zero_index(numbers.subrange(1, numbers.len() as int))\n        } else {\n            0int\n        }\n    } else {\n        0int\n    }\n}\n\nspec fn parse_ints(s: Seq<char>) -> Seq<int> {\n    if s.len() > 0 && valid_input(s) {\n        parse_ints_helper(s, 0, seq![], seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>\n    decreases s.len() - pos\n{\n    seq![]\n}\n\nspec fn generate_output(numbers: Seq<int>) -> Seq<char> {\n    generate_output_helper(numbers, 0, seq![])\n}\n\nspec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input@),\n        input@.len() > 0,\n    ensures \n        ({\n            let numbers = parse_ints(input@);\n            result@ == generate_output(numbers)\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> \n        s[i] == ' ' || s[i] == '\\n' || ('0' <= s[i] <= '9') || s[i] == '-')\n}\n\nspec fn valid_number(s: Seq<char>) -> bool {\n    s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> \n        '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))\n}\n\nspec fn count_zeros(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        0int\n    } else {\n        (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))\n    }\n}\n\nspec fn find_zero_index(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() > 0 && count_zeros(numbers) == 1 {\n        if numbers[0] == 0 {\n            0int\n        } else if numbers.len() > 1 {\n            1int + find_zero_index(numbers.subrange(1, numbers.len() as int))\n        } else {\n            0int\n        }\n    } else {\n        0int\n    }\n}\n\nspec fn parse_ints(s: Seq<char>) -> Seq<int> {\n    if s.len() > 0 && valid_input(s) {\n        parse_ints_helper(s, 0, seq![], seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>\n    decreases s.len() - pos\n{\n    seq![]\n}\n\nspec fn generate_output(numbers: Seq<int>) -> Seq<char> {\n    generate_output_helper(numbers, 0, seq![])\n}\n\nspec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input@),\n        input@.len() > 0,\n    ensures \n        ({\n            let numbers = parse_ints(input@);\n            result@ == generate_output(numbers)\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4460.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1877, "minimize_time_ms": 216487, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 88, "minimized_LOC": 88, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool {\n\nspec fn valid_number(s: Seq<char>) -> bool {\n\nspec fn count_zeros(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n\nspec fn find_zero_index(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n\nspec fn parse_ints(s: Seq<char>) -> Seq<int> {\n\nspec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>\n    decreases s.len() - pos\n{\n\nspec fn generate_output(numbers: Seq<int>) -> Seq<char> {\n\nspec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {\n\n    decreases numbers.len()\n\n    decreases numbers.len()\n\n    decreases s.len() - pos\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> \n        s[i] == ' ' || s[i] == '\\n' || ('0' <= s[i] <= '9') || s[i] == '-')\n}\n\nspec fn valid_number(s: Seq<char>) -> bool {\n    s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> \n        '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))\n}\n\nspec fn count_zeros(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        0int\n    } else {\n        (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))\n    }\n}\n\nspec fn find_zero_index(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() > 0 && count_zeros(numbers) == 1 {\n        if numbers[0] == 0 {\n            0int\n        } else if numbers.len() > 1 {\n            1int + find_zero_index(numbers.subrange(1, numbers.len() as int))\n        } else {\n            0int\n        }\n    } else {\n        0int\n    }\n}\n\nspec fn parse_ints(s: Seq<char>) -> Seq<int> {\n    if s.len() > 0 && valid_input(s) {\n        parse_ints_helper(s, 0, seq![], seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>\n    decreases s.len() - pos\n{\n    seq![]\n}\n\nspec fn generate_output(numbers: Seq<int>) -> Seq<char> {\n    generate_output_helper(numbers, 0, seq![])\n}\n\nspec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input@),\n        input@.len() > 0,\n    ensures \n        ({\n            let numbers = parse_ints(input@);\n            result@ == generate_output(numbers)\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4492_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n/* Helper spec functions for string parsing */\nspec fn split_by_newline_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn split_by_space_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn parse_int_spec(s: &str) -> int { 0 }\nspec fn int_to_string_spec(n: int) -> Seq<char> { Seq::empty() }\nspec fn string_len_spec(s: &str) -> nat { 0 }\nspec fn string_result_len_spec(s: String) -> nat { 0 }\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_by_space_spec(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = parse_int_spec(first_line[0]);\n            let x = parse_int_spec(first_line[1]);\n            n >= 2 && x >= 0 &&\n            {\n                let second_line = split_by_space_spec(lines[1]);\n                second_line.len() == n &&\n                forall|i: int| 0 <= i < n ==> parse_int_spec(second_line[i]) >= 0\n            }\n        }\n    }\n}\n\nspec fn minimum_candies_needed(input: &str) -> int\n    recommends valid_input(input)\n{\n    let lines = split_by_newline_spec(input);\n    let first_line = split_by_space_spec(lines[0]);\n    let n = parse_int_spec(first_line[0]);\n    let x = parse_int_spec(first_line[1]);\n    let second_line = split_by_space_spec(lines[1]);\n    let a = Seq::new(n as nat, |i: int| parse_int_spec(second_line[i]));\n    compute_minimum_operations(a, x)\n}\n\nspec fn compute_minimum_operations(a: Seq<int>, x: int) -> int\n    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n{\n    let a0 = if a[0] > x { x } else { a[0] };\n    let cnt0 = if a[0] > x { a[0] - x } else { 0 };\n    let new_a = a.update(0, a0);\n    compute_operations_from_index(a, x, 1, new_a, cnt0)\n}\n\nspec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int\n    recommends \n        original_a.len() >= 2 &&\n        x >= 0 &&\n        1 <= index <= original_a.len() &&\n        current_a.len() == original_a.len() &&\n        current_count >= 0 &&\n        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0\n    decreases original_a.len() - index\n{\n    if index >= original_a.len() {\n        current_count\n    } else {\n        let new_value = if current_a[index] + current_a[index - 1] > x {\n            x - current_a[index - 1]\n        } else {\n            current_a[index]\n        };\n        let additional_ops = if current_a[index] + current_a[index - 1] > x {\n            current_a[index] + current_a[index - 1] - x\n        } else {\n            0\n        };\n        let new_a = current_a.update(index, new_value);\n        compute_operations_from_index(original_a, x, index + 1, new_a, current_count + additional_ops)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        string_len_spec(input) > 0,\n        valid_input(input),\n    ensures \n        string_result_len_spec(result) > 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n/* Helper spec functions for string parsing */\nspec fn split_by_newline_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn split_by_space_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn parse_int_spec(s: &str) -> int { 0 }\nspec fn int_to_string_spec(n: int) -> Seq<char> { Seq::empty() }\nspec fn string_len_spec(s: &str) -> nat { 0 }\nspec fn string_result_len_spec(s: String) -> nat { 0 }\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_by_space_spec(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = parse_int_spec(first_line[0]);\n            let x = parse_int_spec(first_line[1]);\n            n >= 2 && x >= 0 &&\n            {\n                let second_line = split_by_space_spec(lines[1]);\n                second_line.len() == n &&\n                forall|i: int| 0 <= i < n ==> parse_int_spec(second_line[i]) >= 0\n            }\n        }\n    }\n}\n\nspec fn minimum_candies_needed(input: &str) -> int\n    recommends valid_input(input)\n{\n    let lines = split_by_newline_spec(input);\n    let first_line = split_by_space_spec(lines[0]);\n    let n = parse_int_spec(first_line[0]);\n    let x = parse_int_spec(first_line[1]);\n    let second_line = split_by_space_spec(lines[1]);\n    let a = Seq::new(n as nat, |i: int| parse_int_spec(second_line[i]));\n    compute_minimum_operations(a, x)\n}\n\nspec fn compute_minimum_operations(a: Seq<int>, x: int) -> int\n    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n{\n    let a0 = if a[0] > x { x } else { a[0] };\n    let cnt0 = if a[0] > x { a[0] - x } else { 0 };\n    let new_a = a.update(0, a0);\n    compute_operations_from_index(a, x, 1, new_a, cnt0)\n}\n\nspec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int\n    recommends \n        original_a.len() >= 2 &&\n        x >= 0 &&\n        1 <= index <= original_a.len() &&\n        current_a.len() == original_a.len() &&\n        current_count >= 0 &&\n        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0\n    decreases original_a.len() - index\n{\n    if index >= original_a.len() {\n        current_count\n    } else {\n        let new_value = if current_a[index] + current_a[index - 1] > x {\n            x - current_a[index - 1]\n        } else {\n            current_a[index]\n        };\n        let additional_ops = if current_a[index] + current_a[index - 1] > x {\n            current_a[index] + current_a[index - 1] - x\n        } else {\n            0\n        };\n        let new_a = current_a.update(index, new_value);\n        compute_operations_from_index(original_a, x, index + 1, new_a, current_count + additional_ops)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        string_len_spec(input) > 0,\n        valid_input(input),\n    ensures \n        string_result_len_spec(result) > 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4492.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1231, "minimize_time_ms": 186616, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 106, "minimized_LOC": 106, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 37, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_by_newline_spec(s: &str) -> Seq<&str> {\n\nspec fn split_by_space_spec(s: &str) -> Seq<&str> {\n\nspec fn parse_int_spec(s: &str) -> int {\n\nspec fn int_to_string_spec(n: int) -> Seq<char> {\n\nspec fn string_len_spec(s: &str) -> nat {\n\nspec fn string_result_len_spec(s: String) -> nat {\n\nspec fn valid_input(input: &str) -> bool {\n\nspec fn minimum_candies_needed(input: &str) -> int\n    recommends valid_input(input)\n{\n\nspec fn compute_minimum_operations(a: Seq<int>, x: int) -> int\n    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n{\n\nspec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int\n    recommends \n        original_a.len() >= 2 &&\n        x >= 0 &&\n        1 <= index <= original_a.len() &&\n        current_a.len() == original_a.len() &&\n        current_count >= 0 &&\n        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0\n    decreases original_a.len() - index\n{\n\n    decreases original_a.len() - index\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n/* Helper spec functions for string parsing */\nspec fn split_by_newline_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn split_by_space_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn parse_int_spec(s: &str) -> int { 0 }\nspec fn int_to_string_spec(n: int) -> Seq<char> { Seq::empty() }\nspec fn string_len_spec(s: &str) -> nat { 0 }\nspec fn string_result_len_spec(s: String) -> nat { 0 }\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_by_space_spec(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = parse_int_spec(first_line[0]);\n            let x = parse_int_spec(first_line[1]);\n            n >= 2 && x >= 0 &&\n            {\n                let second_line = split_by_space_spec(lines[1]);\n                second_line.len() == n &&\n                forall|i: int| 0 <= i < n ==> parse_int_spec(second_line[i]) >= 0\n            }\n        }\n    }\n}\n\nspec fn minimum_candies_needed(input: &str) -> int\n    recommends valid_input(input)\n{\n    let lines = split_by_newline_spec(input);\n    let first_line = split_by_space_spec(lines[0]);\n    let n = parse_int_spec(first_line[0]);\n    let x = parse_int_spec(first_line[1]);\n    let second_line = split_by_space_spec(lines[1]);\n    let a = Seq::new(n as nat, |i: int| parse_int_spec(second_line[i]));\n    compute_minimum_operations(a, x)\n}\n\nspec fn compute_minimum_operations(a: Seq<int>, x: int) -> int\n    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n{\n    let a0 = if a[0] > x { x } else { a[0] };\n    let cnt0 = if a[0] > x { a[0] - x } else { 0 };\n    let new_a = a.update(0, a0);\n    compute_operations_from_index(a, x, 1, new_a, cnt0)\n}\n\nspec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int\n    recommends \n        original_a.len() >= 2 &&\n        x >= 0 &&\n        1 <= index <= original_a.len() &&\n        current_a.len() == original_a.len() &&\n        current_count >= 0 &&\n        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0\n    decreases original_a.len() - index\n{\n    if index >= original_a.len() {\n        current_count\n    } else {\n        let new_value = if current_a[index] + current_a[index - 1] > x {\n            x - current_a[index - 1]\n        } else {\n            current_a[index]\n        };\n        let additional_ops = if current_a[index] + current_a[index - 1] > x {\n            current_a[index] + current_a[index - 1] - x\n        } else {\n            0\n        };\n        let new_a = current_a.update(index, new_value);\n        compute_operations_from_index(original_a, x, index + 1, new_a, current_count + additional_ops)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        string_len_spec(input) > 0,\n        valid_input(input),\n    ensures \n        string_result_len_spec(result) > 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n          fn main() {\n}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4501_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool\n{\n    true\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int\n{\n    0\n}\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines_func(stdin_input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_spaces_func(lines[0]);\n        let second_line = split_spaces_func(lines[1]);\n        first_line.len() == 2 &&\n        is_valid_integer(first_line[0]) &&\n        is_valid_integer(first_line[1]) &&\n        {\n            let N = string_to_int_func(first_line[0]);\n            let A = string_to_int_func(first_line[1]);\n            1 <= N <= 50 &&\n            1 <= A <= 50 &&\n            second_line.len() == N &&\n            (forall|j: int| 0 <= j < second_line.len() ==> \n                is_valid_integer(second_line[j]) &&\n                1 <= string_to_int_func(second_line[j]) <= 50)\n        }\n    }\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 1 && \n    output[output.len() as int - 1] == '\\n' &&\n    {\n        let result_str = output.subrange(0, output.len() as int - 1);\n        is_valid_integer(result_str) &&\n        string_to_int_func(result_str) >= 0\n    }\n}\n\nspec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool\n    recommends\n        valid_input_format(stdin_input),\n        is_valid_output(output)\n{\n    let lines = split_lines_func(stdin_input);\n    let first_line = split_spaces_func(lines[0]);\n    let second_line = split_spaces_func(lines[1]);\n    let N = string_to_int_func(first_line[0]);\n    let A = string_to_int_func(first_line[1]);\n    let cards = Seq::new(N as nat, |i: int| string_to_int_func(second_line[i]));\n    let result = string_to_int_func(output.subrange(0, output.len() as int - 1));\n    result == count_valid_selections(cards, A)\n}\n\nspec fn count_valid_selections(cards: Seq<int>, A: int) -> int {\n    let differences = Seq::new(cards.len(), |i: int| cards[i] - A);\n    let total = count_zero_sum_subsets(differences);\n    if total > 0 { total - 1 } else { 0 }\n}\n\nspec fn count_zero_sum_subsets(differences: Seq<int>) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        1\n    } else {\n        let rest_count = count_zero_sum_subsets(differences.subrange(1, differences.len() as int));\n        rest_count + count_subsets_with_sum(differences.subrange(1, differences.len() as int), -differences[0])\n    }\n}\n\nspec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        if target == 0 { 1 } else { 0 }\n    } else {\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target) +\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target - differences[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        output@.len() > 0,\n        output@[output@.len() as int - 1] == '\\n',\n        is_valid_output(output@),\n        output_represents_correct_count(stdin_input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool\n{\n    true\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int\n{\n    0\n}\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines_func(stdin_input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_spaces_func(lines[0]);\n        let second_line = split_spaces_func(lines[1]);\n        first_line.len() == 2 &&\n        is_valid_integer(first_line[0]) &&\n        is_valid_integer(first_line[1]) &&\n        {\n            let N = string_to_int_func(first_line[0]);\n            let A = string_to_int_func(first_line[1]);\n            1 <= N <= 50 &&\n            1 <= A <= 50 &&\n            second_line.len() == N &&\n            (forall|j: int| 0 <= j < second_line.len() ==> \n                is_valid_integer(second_line[j]) &&\n                1 <= string_to_int_func(second_line[j]) <= 50)\n        }\n    }\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 1 && \n    output[output.len() as int - 1] == '\\n' &&\n    {\n        let result_str = output.subrange(0, output.len() as int - 1);\n        is_valid_integer(result_str) &&\n        string_to_int_func(result_str) >= 0\n    }\n}\n\nspec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool\n    recommends\n        valid_input_format(stdin_input),\n        is_valid_output(output)\n{\n    let lines = split_lines_func(stdin_input);\n    let first_line = split_spaces_func(lines[0]);\n    let second_line = split_spaces_func(lines[1]);\n    let N = string_to_int_func(first_line[0]);\n    let A = string_to_int_func(first_line[1]);\n    let cards = Seq::new(N as nat, |i: int| string_to_int_func(second_line[i]));\n    let result = string_to_int_func(output.subrange(0, output.len() as int - 1));\n    result == count_valid_selections(cards, A)\n}\n\nspec fn count_valid_selections(cards: Seq<int>, A: int) -> int {\n    let differences = Seq::new(cards.len(), |i: int| cards[i] - A);\n    let total = count_zero_sum_subsets(differences);\n    if total > 0 { total - 1 } else { 0 }\n}\n\nspec fn count_zero_sum_subsets(differences: Seq<int>) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        1\n    } else {\n        let rest_count = count_zero_sum_subsets(differences.subrange(1, differences.len() as int));\n        rest_count + count_subsets_with_sum(differences.subrange(1, differences.len() as int), -differences[0])\n    }\n}\n\nspec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        if target == 0 { 1 } else { 0 }\n    } else {\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target) +\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target - differences[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        output@.len() > 0,\n        output@[output@.len() as int - 1] == '\\n',\n        is_valid_output(output@),\n        output_represents_correct_count(stdin_input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4501.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1395, "minimize_time_ms": 185383, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 128, "minimized_LOC": 128, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>\n{\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>\n{\n\nspec fn is_valid_integer(s: Seq<char>) -> bool\n{\n\nspec fn string_to_int_func(s: Seq<char>) -> int\n{\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n\nspec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool\n    recommends\n        valid_input_format(stdin_input),\n        is_valid_output(output)\n{\n\nspec fn count_valid_selections(cards: Seq<int>, A: int) -> int {\n\nspec fn count_zero_sum_subsets(differences: Seq<int>) -> nat\n    decreases differences.len()\n{\n\nspec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat\n    decreases differences.len()\n{\n\n    decreases differences.len()\n\n    decreases differences.len()\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool\n{\n    true\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int\n{\n    0\n}\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines_func(stdin_input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_spaces_func(lines[0]);\n        let second_line = split_spaces_func(lines[1]);\n        first_line.len() == 2 &&\n        is_valid_integer(first_line[0]) &&\n        is_valid_integer(first_line[1]) &&\n        {\n            let N = string_to_int_func(first_line[0]);\n            let A = string_to_int_func(first_line[1]);\n            1 <= N <= 50 &&\n            1 <= A <= 50 &&\n            second_line.len() == N &&\n            (forall|j: int| 0 <= j < second_line.len() ==> \n                is_valid_integer(second_line[j]) &&\n                1 <= string_to_int_func(second_line[j]) <= 50)\n        }\n    }\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 1 && \n    output[output.len() as int - 1] == '\\n' &&\n    {\n        let result_str = output.subrange(0, output.len() as int - 1);\n        is_valid_integer(result_str) &&\n        string_to_int_func(result_str) >= 0\n    }\n}\n\nspec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool\n    recommends\n        valid_input_format(stdin_input),\n        is_valid_output(output)\n{\n    let lines = split_lines_func(stdin_input);\n    let first_line = split_spaces_func(lines[0]);\n    let second_line = split_spaces_func(lines[1]);\n    let N = string_to_int_func(first_line[0]);\n    let A = string_to_int_func(first_line[1]);\n    let cards = Seq::new(N as nat, |i: int| string_to_int_func(second_line[i]));\n    let result = string_to_int_func(output.subrange(0, output.len() as int - 1));\n    result == count_valid_selections(cards, A)\n}\n\nspec fn count_valid_selections(cards: Seq<int>, A: int) -> int {\n    let differences = Seq::new(cards.len(), |i: int| cards[i] - A);\n    let total = count_zero_sum_subsets(differences);\n    if total > 0 { total - 1 } else { 0 }\n}\n\nspec fn count_zero_sum_subsets(differences: Seq<int>) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        1\n    } else {\n        let rest_count = count_zero_sum_subsets(differences.subrange(1, differences.len() as int));\n        rest_count + count_subsets_with_sum(differences.subrange(1, differences.len() as int), -differences[0])\n    }\n}\n\nspec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        if target == 0 { 1 } else { 0 }\n    } else {\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target) +\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target - differences[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        output@.len() > 0,\n        output@[output@.len() as int - 1] == '\\n',\n        is_valid_output(output@),\n        output_represents_correct_count(stdin_input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4550_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());\n        nums.len() >= 3 && \n        (forall|i: int| 0 <= i < 3 ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100)\n    }\n}\n\nspec fn parse_three_ints_func(input: Seq<char>) -> (int, int, int) {\n    let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());\n    (nums[0], nums[1], nums[2])\n}\n\nspec fn can_distribute_equally(a: int, b: int, c: int) -> bool {\n    a + b == c || b + c == a || c + a == b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input_format(input),\n    ensures \n        result == seq!['Y', 'e', 's', '\\n'] || result == seq!['N', 'o', '\\n'],\n        ({\n            let numbers = parse_three_ints_func(input);\n            let a = numbers.0;\n            let b = numbers.1; \n            let c = numbers.2;\n            (result == seq!['Y', 'e', 's', '\\n']) <==> can_distribute_equally(a, b, c)\n        }),\n        ({\n            let numbers = parse_three_ints_func(input);\n            numbers.0 >= 1 && numbers.1 >= 1 && numbers.2 >= 1 &&\n            numbers.0 <= 100 && numbers.1 <= 100 && numbers.2 <= 100\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> ;\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4550.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 2030, "minimize_time_ms": 220052, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 63, "minimized_LOC": 7, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 3, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 0.1111111111111111}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> ;\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       }\n        fn main() {\n\nspec fn valid_input_format(input: Seq<char>) -> bool ;\n       }\n        fn main() {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());\n        nums.len() >= 3 && \n        (forall|i: int| 0 <= i < 3 ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100)\n    }\n}\n\nspec fn parse_three_ints_func(input: Seq<char>) -> (int, int, int) {\n    let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());\n    (nums[0], nums[1], nums[2])\n}\n\nspec fn can_distribute_equally(a: int, b: int, c: int) -> bool {\n    a + b == c || b + c == a || c + a == b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input_format(input),\n    ensures \n        result == seq!['Y', 'e', 's', '\\n'] || result == seq!['N', 'o', '\\n'],\n        ({\n            let numbers = parse_three_ints_func(input);\n            let a = numbers.0;\n            let b = numbers.1; \n            let c = numbers.2;\n            (result == seq!['Y', 'e', 's', '\\n']) <==> can_distribute_equally(a, b, c)\n        }),\n        ({\n            let numbers = parse_three_ints_func(input);\n            numbers.0 >= 1 && numbers.1 >= 1 && numbers.2 >= 1 &&\n            numbers.0 <= 100 && numbers.1 <= 100 && numbers.2 <= 100\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> ;\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n          fn main() {\n}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4602_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newlines(s);\n    lines.len() >= 3 &&\n    is_positive_integer(lines[0]) &&\n    is_positive_integer(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        1 <= n <= 100 &&\n        1 <= k <= 100 &&\n        is_valid_x_array(lines[2], n, k)\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 2 &&\n    result[result.len() - 1] == '\\n' &&\n    is_non_negative_integer(result.subrange(0, result.len() - 1))\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    valid_input(input) && valid_output(output) ==>\n        {\n            let lines = split_by_newlines(input);\n            let n = string_to_int(lines[0]);\n            let k = string_to_int(lines[1]);\n            let x = parse_int_array(lines[2]);\n            x.len() == n &&\n            (forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k) &&\n            {\n                let expected_sum = compute_min_distance(x, k);\n                string_to_int(output.subrange(0, output.len() - 1)) == expected_sum\n            }\n        }\n}\n\nspec fn is_positive_integer(s: Seq<char>) -> bool {\n    is_non_negative_integer(s) && s.len() > 0 && \n    (s.len() > 1 || s[0] != '0') && \n    string_to_int(s) > 0\n}\n\nspec fn is_non_negative_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    forall|i: int| #[trigger] s[i] == s[i] && 0 <= i < s.len() ==> {\n        let c = s[i];\n        '0' <= c && c <= '9'\n    }\n}\n\nspec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool {\n    let x = parse_int_array(s);\n    x.len() == n && \n    forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k\n}\n\nspec fn compute_min_distance(x: Seq<int>, k: int) -> int {\n    /* requires forall|i: int| 0 <= i < x.len() ==> 0 < x[i] < k */\n    /* ensures compute_min_distance(x, k) >= 0 */\n    sum_seq(Seq::new(x.len(), |i: int| 2 * min(k - x[i], x[i])))\n}\n\nspec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> { \n    seq![]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int { \n    0\n}\n\nspec fn parse_int_array(s: Seq<char>) -> Seq<int> { \n    seq![]\n}\n\nspec fn sum_seq(seq: Seq<int>) -> int { \n    0\n}\n\nspec fn min(a: int, b: int) -> int { \n    if a <= b { a } else { b } \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\nrequires\n    s@.len() > 0,\n    valid_input(s@),\nensures\n    result@.len() > 0,\n    result@[result@.len() - 1] == '\\n',\n    valid_output(result@),\n    correct_solution(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(s: Seq<char>) -> bool ;\n       spec fn valid_output(result: Seq<char>) -> bool ;\n       spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool ;\n       spec fn is_positive_integer(s: Seq<char>) -> bool ;\n       spec fn is_non_negative_integer(s: Seq<char>) -> bool ;\n        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n            if a <= b {\n      a }\n       else {\n      b }\n        }\n        }\n        fn main() {\n       }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4602.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1359, "minimize_time_ms": 308396, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 113, "minimized_LOC": 22, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.19469026548672566}, "labeling": {"segments": {"exec": " fn main() {", "spec": "spec fn valid_input(s: Seq<char>) -> bool ;\n       spec fn valid_output(result: Seq<char>) -> bool ;\n       spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool ;\n       spec fn is_positive_integer(s: Seq<char>) -> bool ;\n       spec fn is_non_negative_integer(s: Seq<char>) -> bool ;\n        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn valid_output(result: Seq<char>) -> bool ;\n       spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool ;\n       spec fn is_positive_integer(s: Seq<char>) -> bool ;\n       spec fn is_non_negative_integer(s: Seq<char>) -> bool ;\n        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool ;\n       spec fn is_positive_integer(s: Seq<char>) -> bool ;\n       spec fn is_non_negative_integer(s: Seq<char>) -> bool ;\n        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn is_positive_integer(s: Seq<char>) -> bool ;\n       spec fn is_non_negative_integer(s: Seq<char>) -> bool ;\n        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn is_non_negative_integer(s: Seq<char>) -> bool ;\n        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n\nspec fn min(a: int, b: int) -> int {"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newlines(s);\n    lines.len() >= 3 &&\n    is_positive_integer(lines[0]) &&\n    is_positive_integer(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        1 <= n <= 100 &&\n        1 <= k <= 100 &&\n        is_valid_x_array(lines[2], n, k)\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 2 &&\n    result[result.len() - 1] == '\\n' &&\n    is_non_negative_integer(result.subrange(0, result.len() - 1))\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    valid_input(input) && valid_output(output) ==>\n        {\n            let lines = split_by_newlines(input);\n            let n = string_to_int(lines[0]);\n            let k = string_to_int(lines[1]);\n            let x = parse_int_array(lines[2]);\n            x.len() == n &&\n            (forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k) &&\n            {\n                let expected_sum = compute_min_distance(x, k);\n                string_to_int(output.subrange(0, output.len() - 1)) == expected_sum\n            }\n        }\n}\n\nspec fn is_positive_integer(s: Seq<char>) -> bool {\n    is_non_negative_integer(s) && s.len() > 0 && \n    (s.len() > 1 || s[0] != '0') && \n    string_to_int(s) > 0\n}\n\nspec fn is_non_negative_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    forall|i: int| #[trigger] s[i] == s[i] && 0 <= i < s.len() ==> {\n        let c = s[i];\n        '0' <= c && c <= '9'\n    }\n}\n\nspec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool {\n    let x = parse_int_array(s);\n    x.len() == n && \n    forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k\n}\n\nspec fn compute_min_distance(x: Seq<int>, k: int) -> int {\n    /* requires forall|i: int| 0 <= i < x.len() ==> 0 < x[i] < k */\n    /* ensures compute_min_distance(x, k) >= 0 */\n    sum_seq(Seq::new(x.len(), |i: int| 2 * min(k - x[i], x[i])))\n}\n\nspec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> { \n    seq![]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int { \n    0\n}\n\nspec fn parse_int_array(s: Seq<char>) -> Seq<int> { \n    seq![]\n}\n\nspec fn sum_seq(seq: Seq<int>) -> int { \n    0\n}\n\nspec fn min(a: int, b: int) -> int { \n    if a <= b { a } else { b } \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\nrequires\n    s@.len() > 0,\n    valid_input(s@),\nensures\n    result@.len() > 0,\n    result@[result@.len() - 1] == '\\n',\n    valid_output(result@),\n    correct_solution(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(s: Seq<char>) -> bool ;\n       spec fn valid_output(result: Seq<char>) -> bool ;\n       spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool ;\n       spec fn is_positive_integer(s: Seq<char>) -> bool ;\n       spec fn is_non_negative_integer(s: Seq<char>) -> bool ;\n        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n            if a <= b {\n      a }\n       else {\n      b }\n        }\n        }\n        fn main() {\n       }\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4611_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Checkpoint {\n    t: int,\n    x: int,\n    y: int,\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 && is_valid_integer(lines[0]) && \n    ({\n        let n = parse_int(lines[0]);\n        n >= 0 && n + 1 == lines.len() &&\n        (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(lines[i]))\n    })\n}\n\nspec fn can_visit_all_checkpoints(input: Seq<char>) -> bool\n    recommends valid_input_format(input)\n{\n    let lines = split_lines(input);\n    let n = parse_int(lines[0]);\n    if n == 0 { \n        true \n    } else {\n        let checkpoints = parse_checkpoints(lines.subrange(1, lines.len() as int));\n        checkpoints.len() == n &&\n        checkpoints_feasible(checkpoints, 0, 0, 0)\n    }\n}\n\nspec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool\n    decreases checkpoints.len()\n{\n    if checkpoints.len() == 0 { \n        true \n    } else {\n        let cp = checkpoints[0];\n        let dt = cp.t - current_t;\n        let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };\n        let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };\n        let dis = dx + dy;\n        if dt < dis { \n            false \n        } else if (dt - dis) % 2 != 0 { \n            false \n        } else { \n            checkpoints_feasible(checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) \n        }\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\nspec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'],\n        (result@ == seq!['Y', 'e', 's', '\\n']) <==> can_visit_all_checkpoints(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Checkpoint {\n    t: int,\n    x: int,\n    y: int,\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 && is_valid_integer(lines[0]) && \n    ({\n        let n = parse_int(lines[0]);\n        n >= 0 && n + 1 == lines.len() &&\n        (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(lines[i]))\n    })\n}\n\nspec fn can_visit_all_checkpoints(input: Seq<char>) -> bool\n    recommends valid_input_format(input)\n{\n    let lines = split_lines(input);\n    let n = parse_int(lines[0]);\n    if n == 0 { \n        true \n    } else {\n        let checkpoints = parse_checkpoints(lines.subrange(1, lines.len() as int));\n        checkpoints.len() == n &&\n        checkpoints_feasible(checkpoints, 0, 0, 0)\n    }\n}\n\nspec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool\n    decreases checkpoints.len()\n{\n    if checkpoints.len() == 0 { \n        true \n    } else {\n        let cp = checkpoints[0];\n        let dt = cp.t - current_t;\n        let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };\n        let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };\n        let dis = dx + dy;\n        if dt < dis { \n            false \n        } else if (dt - dis) % 2 != 0 { \n            false \n        } else { \n            checkpoints_feasible(checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) \n        }\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\nspec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'],\n        (result@ == seq!['Y', 'e', 's', '\\n']) <==> can_visit_all_checkpoints(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4611.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1548, "minimize_time_ms": 186721, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 101, "minimized_LOC": 101, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(input: Seq<char>) -> bool {\n\nspec fn can_visit_all_checkpoints(input: Seq<char>) -> bool\n    recommends valid_input_format(input)\n{\n\nspec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool\n    decreases checkpoints.len()\n{\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn is_valid_integer(line: Seq<char>) -> bool {\n\nspec fn parse_int(line: Seq<char>) -> int {\n\nspec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {\n\nspec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {\n\n    decreases checkpoints.len()\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Checkpoint {\n    t: int,\n    x: int,\n    y: int,\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 && is_valid_integer(lines[0]) && \n    ({\n        let n = parse_int(lines[0]);\n        n >= 0 && n + 1 == lines.len() &&\n        (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(lines[i]))\n    })\n}\n\nspec fn can_visit_all_checkpoints(input: Seq<char>) -> bool\n    recommends valid_input_format(input)\n{\n    let lines = split_lines(input);\n    let n = parse_int(lines[0]);\n    if n == 0 { \n        true \n    } else {\n        let checkpoints = parse_checkpoints(lines.subrange(1, lines.len() as int));\n        checkpoints.len() == n &&\n        checkpoints_feasible(checkpoints, 0, 0, 0)\n    }\n}\n\nspec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool\n    decreases checkpoints.len()\n{\n    if checkpoints.len() == 0 { \n        true \n    } else {\n        let cp = checkpoints[0];\n        let dt = cp.t - current_t;\n        let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };\n        let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };\n        let dis = dx + dy;\n        if dt < dis { \n            false \n        } else if (dt - dis) % 2 != 0 { \n            false \n        } else { \n            checkpoints_feasible(checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) \n        }\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\nspec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'],\n        (result@ == seq!['Y', 'e', 's', '\\n']) <==> can_visit_all_checkpoints(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"No\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n         fn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4695_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(input: &str) -> bool\n        recommends input.len() > 0\n    {\n        let parts = split_string_pure(input);\n        parts.len() >= 2 && is_valid_int(&parts[0]) && is_valid_int(&parts[1])\n    }\n    \n    spec fn same_group(a: int, b: int) -> bool {\n        let n1 = seq![1, 3, 5, 7, 8, 10, 12];\n        let n2 = seq![4, 6, 9, 11];\n        (n1.contains(a) && n1.contains(b)) || (n2.contains(a) && n2.contains(b)) || (a == 2 && b == 2)\n    }\n    \n    spec fn correct_output(input: &str, result: Seq<char>) -> bool\n        recommends input.len() > 0\n    {\n        if valid_input(input) {\n            let parts = split_string_pure(input);\n            let a = string_to_int_pure(&parts[0]);\n            let b = string_to_int_pure(&parts[1]);\n            let yes_str = seq!['Y', 'e', 's', '\\n'];\n            let no_str = seq!['N', 'o', '\\n'];\n            (result == yes_str <==> same_group(a, b)) && (result == no_str <==> !same_group(a, b))\n        } else {\n            result == seq![]\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n/* Helper functions for string parsing */\nspec fn split_string_pure(s: &str) -> Seq<String> {\n    Seq::empty() /* placeholder for string splitting */\n}\n\nspec fn is_valid_int(s: &str) -> bool {\n    true /* placeholder for integer validation */\n}\n\nspec fn string_to_int_pure(s: &str) -> int {\n    0 /* placeholder for string to int conversion */\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input.len() > 0,\n    ensures\n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'] || result@ == seq![],\n        correct_output(input, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(input: &str) -> bool\n        recommends input.len() > 0\n    {\n        let parts = split_string_pure(input);\n        parts.len() >= 2 && is_valid_int(&parts[0]) && is_valid_int(&parts[1])\n    }\n    \n    spec fn same_group(a: int, b: int) -> bool {\n        let n1 = seq![1, 3, 5, 7, 8, 10, 12];\n        let n2 = seq![4, 6, 9, 11];\n        (n1.contains(a) && n1.contains(b)) || (n2.contains(a) && n2.contains(b)) || (a == 2 && b == 2)\n    }\n    \n    spec fn correct_output(input: &str, result: Seq<char>) -> bool\n        recommends input.len() > 0\n    {\n        if valid_input(input) {\n            let parts = split_string_pure(input);\n            let a = string_to_int_pure(&parts[0]);\n            let b = string_to_int_pure(&parts[1]);\n            let yes_str = seq!['Y', 'e', 's', '\\n'];\n            let no_str = seq!['N', 'o', '\\n'];\n            (result == yes_str <==> same_group(a, b)) && (result == no_str <==> !same_group(a, b))\n        } else {\n            result == seq![]\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n/* Helper functions for string parsing */\nspec fn split_string_pure(s: &str) -> Seq<String> {\n    Seq::empty() /* placeholder for string splitting */\n}\n\nspec fn is_valid_int(s: &str) -> bool {\n    true /* placeholder for integer validation */\n}\n\nspec fn string_to_int_pure(s: &str) -> int {\n    0 /* placeholder for string to int conversion */\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input.len() > 0,\n    ensures\n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'] || result@ == seq![],\n        correct_output(input, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4695.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 945, "verus_errors": [{"error_type": "TypeAnnotation", "error_text": "type annotations needed (cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`)", "message": "VerusErrorType.TypeAnnotation: type annotations needed (cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxe2kv2av", "lines": [29, 29], "label": "cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`", "text": [{"text": "            result == seq![]", "highlight_start": 13, "highlight_end": 29}]}]}, {"error_type": "TypeAnnotation", "error_text": "type annotations needed (cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`)", "message": "VerusErrorType.TypeAnnotation: type annotations needed (cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxe2kv2av", "lines": [54, 54], "label": "cannot infer type of the type parameter `Rhs` declared on the function `spec_eq`", "text": [{"text": "        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'] || result@ == seq![],", "highlight_start": 84, "highlight_end": 101}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: &str) -> bool\n        recommends input.len() > 0\n    {\n\nspec fn same_group(a: int, b: int) -> bool {\n\nspec fn correct_output(input: &str, result: Seq<char>) -> bool\n        recommends input.len() > 0\n    {\n\nspec fn split_string_pure(s: &str) -> Seq<String> {\n\nspec fn is_valid_int(s: &str) -> bool {\n\nspec fn string_to_int_pure(s: &str) -> int {\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_4708_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    lines.len() >= 4 &&\n    is_valid_integer(lines[0]) &&\n    is_valid_integer(lines[1]) &&\n    is_valid_integer(lines[2]) &&\n    is_valid_integer(lines[3]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        1 <= n <= 10000 && 1 <= k <= 10000 && 1 <= y < x <= 10000\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    if lines.len() >= 4 && \n       is_valid_integer(lines[0]) &&\n       is_valid_integer(lines[1]) &&\n       is_valid_integer(lines[2]) &&\n       is_valid_integer(lines[3]) {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        let expected_ans = if k < n { k * x + (n - k) * y } else { n * x };\n        output == int_to_string(expected_ans) + seq!['\\n']\n    } else {\n        output.len() == 0\n    }\n}\n\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires input.len() > 0\n    ensures valid_output(output, input)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    lines.len() >= 4 &&\n    is_valid_integer(lines[0]) &&\n    is_valid_integer(lines[1]) &&\n    is_valid_integer(lines[2]) &&\n    is_valid_integer(lines[3]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        1 <= n <= 10000 && 1 <= k <= 10000 && 1 <= y < x <= 10000\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    if lines.len() >= 4 && \n       is_valid_integer(lines[0]) &&\n       is_valid_integer(lines[1]) &&\n       is_valid_integer(lines[2]) &&\n       is_valid_integer(lines[3]) {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        let expected_ans = if k < n { k * x + (n - k) * y } else { n * x };\n        output == int_to_string(expected_ans) + seq!['\\n']\n    } else {\n        output.len() == 0\n    }\n}\n\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires input.len() > 0\n    ensures valid_output(output, input)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4708.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1694, "minimize_time_ms": 186564, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 74, "minimized_LOC": 74, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\n    requires input.len() > 0\n\n    ensures valid_output(output, input)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    lines.len() >= 4 &&\n    is_valid_integer(lines[0]) &&\n    is_valid_integer(lines[1]) &&\n    is_valid_integer(lines[2]) &&\n    is_valid_integer(lines[3]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        1 <= n <= 10000 && 1 <= k <= 10000 && 1 <= y < x <= 10000\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    if lines.len() >= 4 && \n       is_valid_integer(lines[0]) &&\n       is_valid_integer(lines[1]) &&\n       is_valid_integer(lines[2]) &&\n       is_valid_integer(lines[3]) {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        let expected_ans = if k < n { k * x + (n - k) * y } else { n * x };\n        output == int_to_string(expected_ans) + seq!['\\n']\n    } else {\n        output.len() == 0\n    }\n}\n\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires input.len() > 0\n    ensures valid_output(output, input)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_4714_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn is_palindromic(n: int) -> bool\n  recommends n >= 0\n{\n  let s = int_to_string(n);\n  forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]\n}\n\nspec fn count_palindromic_numbers(a: int, b: int) -> int\n  recommends 10000 <= a <= b <= 99999\n  decreases b - a + 1\n{\n  if a > b { \n    0\n  } else if a == b { \n    if is_palindromic(a) { 1 } else { 0 }\n  } else {\n    (if is_palindromic(a) { 1 } else { 0 }) + count_palindromic_numbers(a + 1, b)\n  }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n  s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n  stdin_input.len() > 0 &&\n  exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == ' ' &&\n  {\n    let parts = split_on_space(stdin_input);\n    parts.len() == 2 && \n    is_valid_integer(parts[0]) && \n    is_valid_integer(parts[1]) &&\n    string_to_int(parts[0]) >= 10000 &&\n    string_to_int(parts[1]) >= 10000 &&\n    string_to_int(parts[0]) <= 99999 &&\n    string_to_int(parts[1]) <= 99999 &&\n    string_to_int(parts[0]) <= string_to_int(parts[1])\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n  requires \n    valid_input(stdin_input@)\n  ensures \n    result@.len() > 0\n  ensures \n    result@[result@.len() as int - 1] == '\\n'\n  ensures {\n    let parts = split_on_space(stdin_input@);\n    let a = string_to_int(parts[0]);\n    let b = string_to_int(parts[1]);\n    result@ == int_to_string(count_palindromic_numbers(a, b)) + seq!['\\n']\n  }\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn is_palindromic(n: int) -> bool\n  recommends n >= 0\n{\n  let s = int_to_string(n);\n  forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]\n}\n\nspec fn count_palindromic_numbers(a: int, b: int) -> int\n  recommends 10000 <= a <= b <= 99999\n  decreases b - a + 1\n{\n  if a > b { \n    0\n  } else if a == b { \n    if is_palindromic(a) { 1 } else { 0 }\n  } else {\n    (if is_palindromic(a) { 1 } else { 0 }) + count_palindromic_numbers(a + 1, b)\n  }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n  s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n  stdin_input.len() > 0 &&\n  exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == ' ' &&\n  {\n    let parts = split_on_space(stdin_input);\n    parts.len() == 2 && \n    is_valid_integer(parts[0]) && \n    is_valid_integer(parts[1]) &&\n    string_to_int(parts[0]) >= 10000 &&\n    string_to_int(parts[1]) >= 10000 &&\n    string_to_int(parts[0]) <= 99999 &&\n    string_to_int(parts[1]) <= 99999 &&\n    string_to_int(parts[0]) <= string_to_int(parts[1])\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n  requires \n    valid_input(stdin_input@)\n  ensures \n    result@.len() > 0\n  ensures \n    result@[result@.len() as int - 1] == '\\n'\n  ensures {\n    let parts = split_on_space(stdin_input@);\n    let a = string_to_int(parts[0]);\n    let b = string_to_int(parts[1]);\n    result@ == int_to_string(count_palindromic_numbers(a, b)) + seq!['\\n']\n  }\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4714.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 271, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpav1bbnht", "lines": [55, 55], "label": null, "text": [{"text": "  ensures ", "highlight_start": 3, "highlight_end": 10}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 74, "minimized_LOC": 74, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_palindromic(n: int) -> bool\n  recommends n >= 0\n{\n\nspec fn count_palindromic_numbers(a: int, b: int) -> int\n  recommends 10000 <= a <= b <= 99999\n  decreases b - a + 1\n{\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n\n  decreases b - a + 1\n\n  requires \n\n  ensures \n\n  ensures \n\n  ensures {"}}}, "all_snapshots": []}
{"id": "apps_test_5_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, pos: int, l: int, r: int) -> bool {\n    1 <= n <= 100 && 1 <= pos <= n && 1 <= l <= r <= n\n}\n\nspec fn no_tabs_to_close(l: int, r: int, n: int) -> bool {\n    l == 1 && r == n\n}\n\nspec fn only_close_right(l: int, r: int, n: int) -> bool {\n    l == 1 && r < n\n}\n\nspec fn only_close_left(l: int, r: int, n: int) -> bool {\n    l > 1 && r == n\n}\n\nspec fn close_both_sides(l: int, r: int, n: int) -> bool {\n    l > 1 && r < n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, pos: i8, l: i8, r: i8) -> (result: i8)\n    requires \n        valid_input(n as int, pos as int, l as int, r as int)\n    ensures \n        result as int >= 0,\n        no_tabs_to_close(l as int, r as int, n as int) ==> result as int == 0,\n        only_close_right(l as int, r as int, n as int) ==> result as int == if pos as int >= r as int { pos as int - r as int } else { r as int - pos as int } + 1,\n        only_close_left(l as int, r as int, n as int) ==> result as int == if pos as int >= l as int { pos as int - l as int } else { l as int - pos as int } + 1,\n        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) < (r as int - pos as int) ==> result as int == (pos as int - l as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) >= (r as int - pos as int) ==> result as int == (r as int - pos as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && pos as int > r as int ==> result as int == (pos as int - r as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && pos as int < l as int ==> result as int == (l as int - pos as int) + 1 + (r as int - l as int) + 1,\n        result as int <= 2 * n as int\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, pos: int, l: int, r: int) -> bool {\n    1 <= n <= 100 && 1 <= pos <= n && 1 <= l <= r <= n\n}\n\nspec fn no_tabs_to_close(l: int, r: int, n: int) -> bool {\n    l == 1 && r == n\n}\n\nspec fn only_close_right(l: int, r: int, n: int) -> bool {\n    l == 1 && r < n\n}\n\nspec fn only_close_left(l: int, r: int, n: int) -> bool {\n    l > 1 && r == n\n}\n\nspec fn close_both_sides(l: int, r: int, n: int) -> bool {\n    l > 1 && r < n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, pos: i8, l: i8, r: i8) -> (result: i8)\n    requires \n        valid_input(n as int, pos as int, l as int, r as int)\n    ensures \n        result as int >= 0,\n        no_tabs_to_close(l as int, r as int, n as int) ==> result as int == 0,\n        only_close_right(l as int, r as int, n as int) ==> result as int == if pos as int >= r as int { pos as int - r as int } else { r as int - pos as int } + 1,\n        only_close_left(l as int, r as int, n as int) ==> result as int == if pos as int >= l as int { pos as int - l as int } else { l as int - pos as int } + 1,\n        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) < (r as int - pos as int) ==> result as int == (pos as int - l as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) >= (r as int - pos as int) ==> result as int == (r as int - pos as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && pos as int > r as int ==> result as int == (pos as int - r as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && pos as int < l as int ==> result as int == (l as int - pos as int) + 1 + (r as int - l as int) + 1,\n        result as int <= 2 * n as int\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_5.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 237, "verus_errors": [{"error_type": "Other", "error_text": "expected `,` ()", "message": "VerusErrorType.Other: expected `,` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp0d1se407", "lines": [42, 42], "label": null, "text": [{"text": "        close_both_sides(l as int, r as int, n as int) && pos as int < l as int ==> result as int == (l as int - pos as int) + 1 + (r as int - l as int) + 1,", "highlight_start": 74, "highlight_end": 76}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, pos: int, l: int, r: int) -> bool {\n\nspec fn no_tabs_to_close(l: int, r: int, n: int) -> bool {\n\nspec fn only_close_right(l: int, r: int, n: int) -> bool {\n\nspec fn only_close_left(l: int, r: int, n: int) -> bool {\n\nspec fn close_both_sides(l: int, r: int, n: int) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_502_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn length_sqr(p1: (int, int), p2: (int, int)) -> int {\n    (p1.0 - p2.0) * (p1.0 - p2.0) + (p1.1 - p2.1) * (p1.1 - p2.1)\n}\n\nspec fn valid_rotation_exists(a: (int, int), b: (int, int), c: (int, int)) -> bool {\n    let dist_ab_sqr = length_sqr(a, b);\n    let dist_bc_sqr = length_sqr(b, c);\n    let dx1 = c.0 - b.0;\n    let dy1 = c.1 - b.1;\n    let dx2 = b.0 - a.0;\n    let dy2 = b.1 - a.1;\n    dist_ab_sqr == dist_bc_sqr && dx1 * dy2 != dy1 * dx2\n}\n\nspec fn parse_input_func(input: Seq<char>) -> Seq<int>\n    recommends input.len() > 0\n{\n    parse_input_helper(input, 0, seq![], seq![])\n}\n\nspec fn parse_input_helper(input: Seq<char>, i: int, result: Seq<int>, current: Seq<char>) -> Seq<int>\n    recommends 0 <= i <= input.len()\n    decreases input.len() - i\n{\n    if i == input.len() {\n        if current.len() > 0 { result.push(string_to_int(current)) }\n        else { result }\n    } else {\n        let ch = input[i];\n        if ch == ' ' || ch == '\\n' || ch == '\\t' {\n            if current.len() > 0 {\n                parse_input_helper(input, i + 1, result.push(string_to_int(current)), seq![])\n            } else {\n                parse_input_helper(input, i + 1, result, seq![])\n            }\n        } else if ('0' <= ch <= '9') || ch == '-' {\n            parse_input_helper(input, i + 1, result, current.push(ch))\n        } else {\n            parse_input_helper(input, i + 1, result, current)\n        }\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 && s[0] == '-' { 0 }\n    else if s[0] == '-' && s.len() > 1 && is_digit_string(s.subrange(1, s.len() as int)) { -string_to_int_helper(s.subrange(1, s.len() as int)) }\n    else if is_digit_string(s) { string_to_int_helper(s) }\n    else { 0 }\n}\n\nspec fn is_digit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n{\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 { char_to_digit(s[0]) }\n    else { string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + char_to_digit(s[s.len() - 1]) }\n}\n\nspec fn char_to_digit(c: char) -> int\n    recommends '0' <= c <= '9'\n{\n    (c as int) - ('0' as int)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures result@ == \"Yes\"@ || result@ == \"No\"@ || result@ == \"\"@\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn length_sqr(p1: (int, int), p2: (int, int)) -> int {\n    (p1.0 - p2.0) * (p1.0 - p2.0) + (p1.1 - p2.1) * (p1.1 - p2.1)\n}\n\nspec fn valid_rotation_exists(a: (int, int), b: (int, int), c: (int, int)) -> bool {\n    let dist_ab_sqr = length_sqr(a, b);\n    let dist_bc_sqr = length_sqr(b, c);\n    let dx1 = c.0 - b.0;\n    let dy1 = c.1 - b.1;\n    let dx2 = b.0 - a.0;\n    let dy2 = b.1 - a.1;\n    dist_ab_sqr == dist_bc_sqr && dx1 * dy2 != dy1 * dx2\n}\n\nspec fn parse_input_func(input: Seq<char>) -> Seq<int>\n    recommends input.len() > 0\n{\n    parse_input_helper(input, 0, seq![], seq![])\n}\n\nspec fn parse_input_helper(input: Seq<char>, i: int, result: Seq<int>, current: Seq<char>) -> Seq<int>\n    recommends 0 <= i <= input.len()\n    decreases input.len() - i\n{\n    if i == input.len() {\n        if current.len() > 0 { result.push(string_to_int(current)) }\n        else { result }\n    } else {\n        let ch = input[i];\n        if ch == ' ' || ch == '\\n' || ch == '\\t' {\n            if current.len() > 0 {\n                parse_input_helper(input, i + 1, result.push(string_to_int(current)), seq![])\n            } else {\n                parse_input_helper(input, i + 1, result, seq![])\n            }\n        } else if ('0' <= ch <= '9') || ch == '-' {\n            parse_input_helper(input, i + 1, result, current.push(ch))\n        } else {\n            parse_input_helper(input, i + 1, result, current)\n        }\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 && s[0] == '-' { 0 }\n    else if s[0] == '-' && s.len() > 1 && is_digit_string(s.subrange(1, s.len() as int)) { -string_to_int_helper(s.subrange(1, s.len() as int)) }\n    else if is_digit_string(s) { string_to_int_helper(s) }\n    else { 0 }\n}\n\nspec fn is_digit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n{\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 { char_to_digit(s[0]) }\n    else { string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + char_to_digit(s[s.len() - 1]) }\n}\n\nspec fn char_to_digit(c: char) -> int\n    recommends '0' <= c <= '9'\n{\n    (c as int) - ('0' as int)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures result@ == \"Yes\"@ || result@ == \"No\"@ || result@ == \"\"@\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_502.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 988, "verus_errors": [{"error_type": "Other", "error_text": "recursive function must have a decreases clause ()", "message": "VerusErrorType.Other: recursive function must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp2du9rppz", "lines": [61, 61], "label": null, "text": [{"text": "spec fn string_to_int_helper(s: Seq<char>) -> int", "highlight_start": 6, "highlight_end": 50}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 94, "minimized_LOC": 94, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn length_sqr(p1: (int, int), p2: (int, int)) -> int {\n\nspec fn valid_rotation_exists(a: (int, int), b: (int, int), c: (int, int)) -> bool {\n\nspec fn parse_input_func(input: Seq<char>) -> Seq<int>\n    recommends input.len() > 0\n{\n\nspec fn parse_input_helper(input: Seq<char>, i: int, result: Seq<int>, current: Seq<char>) -> Seq<int>\n    recommends 0 <= i <= input.len()\n    decreases input.len() - i\n{\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn is_digit_string(s: Seq<char>) -> bool {\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n{\n\nspec fn char_to_digit(c: char) -> int\n    recommends '0' <= c <= '9'\n{\n\n    decreases input.len() - i\n\n    requires input@.len() > 0\n\n    ensures result@ == \"Yes\"@ || result@ == \"No\"@ || result@ == \"\"@"}}}, "all_snapshots": []}
{"id": "apps_test_505_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, k: int, grid: Seq<Seq<char>>) -> bool {\n    n > 0 && m > 0 && k >= 0 &&\n    grid.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] grid[i].len() == m) &&\n    (exists|i: int, j: int| 0 <= i < n && 0 <= j < m && grid[i][j] == 'X')\n}\n\nspec fn get_next_position(x: int, y: int, move_char: char) -> (int, int) {\n    match move_char {\n        'D' => (x + 1, y),\n        'L' => (x, y - 1),\n        'R' => (x, y + 1),\n        'U' => (x - 1, y),\n        _ => (x, y)\n    }\n}\n\nspec fn simulate_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> (int, int)\n    decreases path.len()\n{\n    if path.len() == 0 {\n        (start_x, start_y)\n    } else {\n        let next_pos = get_next_position(start_x, start_y, path[0]);\n        simulate_path(next_pos.0, next_pos.1, path.subrange(1, path.len() as int), grid, n, m)\n    }\n}\n\nspec fn valid_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    forall|i: int| #![trigger simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m)] \n        0 <= i <= path.len() ==> {\n            let pos = simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m);\n            0 <= pos.0 < n && 0 <= pos.1 < m && \n            pos.0 < grid.len() && pos.1 < grid[pos.0].len() &&\n            grid[pos.0][pos.1] != '*'\n        }\n}\n\nspec fn path_returns_to_start(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    let final_pos = simulate_path(start_x, start_y, path, grid, n, m);\n    final_pos.0 == start_x && final_pos.1 == start_y\n}\n\nspec fn valid_directions(path: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < path.len() ==> \n        #[trigger] path[i] == 'D' || path[i] == 'L' || path[i] == 'R' || path[i] == 'U'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, m: usize, k: usize, grid: Vec<Vec<char>>) -> (result: String)\n    requires\n        valid_input(n as int, m as int, k as int, grid@.map_values(|row: Vec<char>| row@))\n    ensures\n        result == \"IMPOSSIBLE\" || (\n            result.len() == k &&\n            valid_directions(result@) &&\n            {\n                let mut start_x = 0;\n                let mut start_y = 0;\n                let mut found = false;\n                let mut i = 0;\n                while i < n {\n                    let mut j = 0;\n                    while j < m {\n                        if grid[i][j] == 'X' {\n                            start_x = i as int;\n                            start_y = j as int;\n                            found = true;\n                        }\n                        j += 1;\n                    }\n                    i += 1;\n                }\n                found\n            } ==> {\n                let start_x = {\n                    let mut sx = 0;\n                    let mut i = 0;\n                    while i < n {\n                        let mut j = 0;\n                        while j < m {\n                            if grid[i][j] == 'X' {\n                                sx = i as int;\n                            }\n                            j += 1;\n                        }\n                        i += 1;\n                    }\n                    sx\n                };\n                let start_y = {\n                    let mut sy = 0;\n                    let mut i = 0;\n                    while i < n {\n                        let mut j = 0;\n                        while j < m {\n                            if grid[i][j] == 'X' {\n                                sy = j as int;\n                            }\n                            j += 1;\n                        }\n                        i += 1;\n                    }\n                    sy\n                };\n                valid_path(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int) &&\n                path_returns_to_start(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int)\n            }\n        )\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"IMPOSSIBLE\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, k: int, grid: Seq<Seq<char>>) -> bool {\n    n > 0 && m > 0 && k >= 0 &&\n    grid.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] grid[i].len() == m) &&\n    (exists|i: int, j: int| 0 <= i < n && 0 <= j < m && grid[i][j] == 'X')\n}\n\nspec fn get_next_position(x: int, y: int, move_char: char) -> (int, int) {\n    match move_char {\n        'D' => (x + 1, y),\n        'L' => (x, y - 1),\n        'R' => (x, y + 1),\n        'U' => (x - 1, y),\n        _ => (x, y)\n    }\n}\n\nspec fn simulate_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> (int, int)\n    decreases path.len()\n{\n    if path.len() == 0 {\n        (start_x, start_y)\n    } else {\n        let next_pos = get_next_position(start_x, start_y, path[0]);\n        simulate_path(next_pos.0, next_pos.1, path.subrange(1, path.len() as int), grid, n, m)\n    }\n}\n\nspec fn valid_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    forall|i: int| #![trigger simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m)] \n        0 <= i <= path.len() ==> {\n            let pos = simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m);\n            0 <= pos.0 < n && 0 <= pos.1 < m && \n            pos.0 < grid.len() && pos.1 < grid[pos.0].len() &&\n            grid[pos.0][pos.1] != '*'\n        }\n}\n\nspec fn path_returns_to_start(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    let final_pos = simulate_path(start_x, start_y, path, grid, n, m);\n    final_pos.0 == start_x && final_pos.1 == start_y\n}\n\nspec fn valid_directions(path: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < path.len() ==> \n        #[trigger] path[i] == 'D' || path[i] == 'L' || path[i] == 'R' || path[i] == 'U'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, m: usize, k: usize, grid: Vec<Vec<char>>) -> (result: String)\n    requires\n        valid_input(n as int, m as int, k as int, grid@.map_values(|row: Vec<char>| row@))\n    ensures\n        result == \"IMPOSSIBLE\" || (\n            result.len() == k &&\n            valid_directions(result@) &&\n            {\n                let mut start_x = 0;\n                let mut start_y = 0;\n                let mut found = false;\n                let mut i = 0;\n                while i < n {\n                    let mut j = 0;\n                    while j < m {\n                        if grid[i][j] == 'X' {\n                            start_x = i as int;\n                            start_y = j as int;\n                            found = true;\n                        }\n                        j += 1;\n                    }\n                    i += 1;\n                }\n                found\n            } ==> {\n                let start_x = {\n                    let mut sx = 0;\n                    let mut i = 0;\n                    while i < n {\n                        let mut j = 0;\n                        while j < m {\n                            if grid[i][j] == 'X' {\n                                sx = i as int;\n                            }\n                            j += 1;\n                        }\n                        i += 1;\n                    }\n                    sx\n                };\n                let start_y = {\n                    let mut sy = 0;\n                    let mut i = 0;\n                    while i < n {\n                        let mut j = 0;\n                        while j < m {\n                            if grid[i][j] == 'X' {\n                                sy = j as int;\n                            }\n                            j += 1;\n                        }\n                        i += 1;\n                    }\n                    sy\n                };\n                valid_path(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int) &&\n                path_returns_to_start(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int)\n            }\n        )\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"IMPOSSIBLE\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_505.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1132, "verus_errors": [{"error_type": "TypeAnnotation", "error_text": "type annotations needed (type must be known at this point)", "message": "VerusErrorType.TypeAnnotation: type annotations needed (type must be known at this point)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp988wq64r", "lines": [71, 71], "label": "type must be known at this point", "text": [{"text": "                while i < n {", "highlight_start": 23, "highlight_end": 24}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp988wq64r", "lines": [70, 70], "label": null, "text": [{"text": "                let mut i = 0;", "highlight_start": 21, "highlight_end": 26}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 130, "minimized_LOC": 130, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, k: int, grid: Seq<Seq<char>>) -> bool {\n\nspec fn get_next_position(x: int, y: int, move_char: char) -> (int, int) {\n\nspec fn simulate_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> (int, int)\n    decreases path.len()\n{\n\nspec fn valid_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n\nspec fn path_returns_to_start(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n\nspec fn valid_directions(path: Seq<char>) -> bool {\n\n    decreases path.len()\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_510_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn pos1(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            a\n        } else if b <= a && b <= c {\n            b\n        } else {\n            c\n        }\n    }\n    \n    spec fn pos2(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            if b <= c { b } else { c }\n        } else if b <= a && b <= c {\n            if a <= c { a } else { c }\n        } else {\n            if a <= b { a } else { b }\n        }\n    }\n    \n    spec fn pos3(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            if b <= c { c } else { b }\n        } else if b <= a && b <= c {\n            if a <= c { c } else { a }\n        } else {\n            if a <= b { b } else { a }\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int, c: int, d: int) -> (result: int)\n    requires 1 <= a && a <= 1_000_000_000\n    requires 1 <= b && b <= 1_000_000_000\n    requires 1 <= c && c <= 1_000_000_000\n    requires 1 <= d && d <= 1_000_000_000\n    ensures result >= 0\n    ensures result == (if d > (pos2(a, b, c) - pos1(a, b, c)) { d - (pos2(a, b, c) - pos1(a, b, c)) } else { 0 }) +\n                     (if d > (pos3(a, b, c) - pos2(a, b, c)) { d - (pos3(a, b, c) - pos2(a, b, c)) } else { 0 })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn pos1(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            a\n        } else if b <= a && b <= c {\n            b\n        } else {\n            c\n        }\n    }\n    \n    spec fn pos2(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            if b <= c { b } else { c }\n        } else if b <= a && b <= c {\n            if a <= c { a } else { c }\n        } else {\n            if a <= b { a } else { b }\n        }\n    }\n    \n    spec fn pos3(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            if b <= c { c } else { b }\n        } else if b <= a && b <= c {\n            if a <= c { c } else { a }\n        } else {\n            if a <= b { b } else { a }\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int, c: int, d: int) -> (result: int)\n    requires 1 <= a && a <= 1_000_000_000\n    requires 1 <= b && b <= 1_000_000_000\n    requires 1 <= c && c <= 1_000_000_000\n    requires 1 <= d && d <= 1_000_000_000\n    ensures result >= 0\n    ensures result == (if d > (pos2(a, b, c) - pos1(a, b, c)) { d - (pos2(a, b, c) - pos1(a, b, c)) } else { 0 }) +\n                     (if d > (pos3(a, b, c) - pos2(a, b, c)) { d - (pos3(a, b, c) - pos2(a, b, c)) } else { 0 })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_510.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 242, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpzatqtojt", "lines": [42, 42], "label": null, "text": [{"text": "    requires 1 <= b && b <= 1_000_000_000", "highlight_start": 5, "highlight_end": 13}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn pos1(a: int, b: int, c: int) -> int {\n\nspec fn pos2(a: int, b: int, c: int) -> int {\n\nspec fn pos3(a: int, b: int, c: int) -> int {\n\n    requires 1 <= a && a <= 1_000_000_000\n\n    requires 1 <= b && b <= 1_000_000_000\n\n    requires 1 <= c && c <= 1_000_000_000\n\n    requires 1 <= d && d <= 1_000_000_000\n\n    ensures result >= 0\n\n    ensures result == (if d > (pos2(a, b, c) - pos1(a, b, c)) { d - (pos2(a, b, c) - pos1(a, b, c)) } else { 0 }) +"}}}, "all_snapshots": []}
{"id": "apps_test_540_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input.len() >= 7 &&\n    contains_required_newlines(stdin_input) &&\n    ends_with_newline_or_can_append(stdin_input) &&\n    has_valid_structure(stdin_input) &&\n    all_grid_characters_valid(stdin_input) &&\n    has_exactly_required_lines(stdin_input)\n}\n\nspec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {\n    let parsed = parse_dimensions(stdin_input);\n    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500\n}\n\nspec fn valid_coordinates(stdin_input: Seq<char>) -> bool {\n    let dims = parse_dimensions(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&\n    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1\n}\n\nspec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    valid_grid_index(grid, coords.0-1, coords.1-1) &&\n    grid.index(coords.0-1).index(coords.1-1) == 'X'\n}\n\nspec fn well_formed_input(stdin_input: Seq<char>) -> bool {\n    valid_input_format(stdin_input) &&\n    valid_grid_bounds(stdin_input) &&\n    valid_coordinates(stdin_input) &&\n    starting_cell_is_cracked(stdin_input) &&\n    grid_contains_only_valid_chars(stdin_input) &&\n    coordinates_within_bounds(stdin_input)\n}\n\nspec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    let r1 = coords.0-1;\n    let c1 = coords.1-1;\n    let r2 = coords.2-1;\n    let c2 = coords.3-1;\n    let target_is_cracked = grid.index(r2).index(c2) == 'X';\n    let surrounding_dots = count_surrounding_intact_ice(grid, r2, c2);\n\n    if target_is_cracked {\n        if r1 == r2 && c1 == c2 {\n            surrounding_dots >= 1\n        } else {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        }\n    } else {\n        if surrounding_dots >= 2 {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        } else if surrounding_dots == 0 {\n            false\n        } else {\n            is_adjacent(r1+1, c1+1, r2+1, c2+1)\n        }\n    }\n}\n\nspec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {\n    (1, 1)\n}\n\nspec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['X']]\n}\n\nspec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {\n    (1, 1, 1, 1)\n}\n\nspec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {\n    0 <= r < grid.len() && 0 <= c < grid.index(r).len()\n}\n\n/* Helper functions that are referenced but not defined */\nspec fn contains_required_newlines(input: Seq<char>) -> bool { true }\nspec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool { true }\nspec fn has_valid_structure(input: Seq<char>) -> bool { true }\nspec fn all_grid_characters_valid(input: Seq<char>) -> bool { true }\nspec fn has_exactly_required_lines(input: Seq<char>) -> bool { true }\nspec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool { true }\nspec fn coordinates_within_bounds(input: Seq<char>) -> bool { true }\nspec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int { 0 }\nspec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool { true }\nspec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool { \n    (r1 == r2 && (c1 == c2 + 1 || c1 == c2 - 1)) ||\n    (c1 == c2 && (r1 == r2 + 1 || r1 == r2 - 1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        valid_input_format(stdin_input),\n        valid_grid_bounds(stdin_input),\n        valid_coordinates(stdin_input),\n        starting_cell_is_cracked(stdin_input),\n        well_formed_input(stdin_input),\n    ensures \n        result == seq!['Y', 'E', 'S', '\\n'] || result == seq!['N', 'O', '\\n'],\n        result.len() > 0,\n        (result == seq!['Y', 'E', 'S', '\\n']) <==> can_solve_ice_maze(stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input.len() >= 7 &&\n    contains_required_newlines(stdin_input) &&\n    ends_with_newline_or_can_append(stdin_input) &&\n    has_valid_structure(stdin_input) &&\n    all_grid_characters_valid(stdin_input) &&\n    has_exactly_required_lines(stdin_input)\n}\n\nspec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {\n    let parsed = parse_dimensions(stdin_input);\n    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500\n}\n\nspec fn valid_coordinates(stdin_input: Seq<char>) -> bool {\n    let dims = parse_dimensions(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&\n    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1\n}\n\nspec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    valid_grid_index(grid, coords.0-1, coords.1-1) &&\n    grid.index(coords.0-1).index(coords.1-1) == 'X'\n}\n\nspec fn well_formed_input(stdin_input: Seq<char>) -> bool {\n    valid_input_format(stdin_input) &&\n    valid_grid_bounds(stdin_input) &&\n    valid_coordinates(stdin_input) &&\n    starting_cell_is_cracked(stdin_input) &&\n    grid_contains_only_valid_chars(stdin_input) &&\n    coordinates_within_bounds(stdin_input)\n}\n\nspec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    let r1 = coords.0-1;\n    let c1 = coords.1-1;\n    let r2 = coords.2-1;\n    let c2 = coords.3-1;\n    let target_is_cracked = grid.index(r2).index(c2) == 'X';\n    let surrounding_dots = count_surrounding_intact_ice(grid, r2, c2);\n\n    if target_is_cracked {\n        if r1 == r2 && c1 == c2 {\n            surrounding_dots >= 1\n        } else {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        }\n    } else {\n        if surrounding_dots >= 2 {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        } else if surrounding_dots == 0 {\n            false\n        } else {\n            is_adjacent(r1+1, c1+1, r2+1, c2+1)\n        }\n    }\n}\n\nspec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {\n    (1, 1)\n}\n\nspec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['X']]\n}\n\nspec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {\n    (1, 1, 1, 1)\n}\n\nspec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {\n    0 <= r < grid.len() && 0 <= c < grid.index(r).len()\n}\n\n/* Helper functions that are referenced but not defined */\nspec fn contains_required_newlines(input: Seq<char>) -> bool { true }\nspec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool { true }\nspec fn has_valid_structure(input: Seq<char>) -> bool { true }\nspec fn all_grid_characters_valid(input: Seq<char>) -> bool { true }\nspec fn has_exactly_required_lines(input: Seq<char>) -> bool { true }\nspec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool { true }\nspec fn coordinates_within_bounds(input: Seq<char>) -> bool { true }\nspec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int { 0 }\nspec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool { true }\nspec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool { \n    (r1 == r2 && (c1 == c2 + 1 || c1 == c2 - 1)) ||\n    (c1 == c2 && (r1 == r2 + 1 || r1 == r2 - 1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        valid_input_format(stdin_input),\n        valid_grid_bounds(stdin_input),\n        valid_coordinates(stdin_input),\n        starting_cell_is_cracked(stdin_input),\n        well_formed_input(stdin_input),\n    ensures \n        result == seq!['Y', 'E', 'S', '\\n'] || result == seq!['N', 'O', '\\n'],\n        result.len() > 0,\n        (result == seq!['Y', 'E', 'S', '\\n']) <==> can_solve_ice_maze(stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_540.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1285, "minimize_time_ms": 220501, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 132, "minimized_LOC": 132, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 25, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n\nspec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {\n\nspec fn valid_coordinates(stdin_input: Seq<char>) -> bool {\n\nspec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {\n\nspec fn well_formed_input(stdin_input: Seq<char>) -> bool {\n\nspec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {\n\nspec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {\n\nspec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {\n\nspec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {\n\nspec fn contains_required_newlines(input: Seq<char>) -> bool {\n\nspec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool {\n\nspec fn has_valid_structure(input: Seq<char>) -> bool {\n\nspec fn all_grid_characters_valid(input: Seq<char>) -> bool {\n\nspec fn has_exactly_required_lines(input: Seq<char>) -> bool {\n\nspec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool {\n\nspec fn coordinates_within_bounds(input: Seq<char>) -> bool {\n\nspec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int {\n\nspec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool {\n\nspec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input.len() >= 7 &&\n    contains_required_newlines(stdin_input) &&\n    ends_with_newline_or_can_append(stdin_input) &&\n    has_valid_structure(stdin_input) &&\n    all_grid_characters_valid(stdin_input) &&\n    has_exactly_required_lines(stdin_input)\n}\n\nspec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {\n    let parsed = parse_dimensions(stdin_input);\n    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500\n}\n\nspec fn valid_coordinates(stdin_input: Seq<char>) -> bool {\n    let dims = parse_dimensions(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&\n    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1\n}\n\nspec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    valid_grid_index(grid, coords.0-1, coords.1-1) &&\n    grid.index(coords.0-1).index(coords.1-1) == 'X'\n}\n\nspec fn well_formed_input(stdin_input: Seq<char>) -> bool {\n    valid_input_format(stdin_input) &&\n    valid_grid_bounds(stdin_input) &&\n    valid_coordinates(stdin_input) &&\n    starting_cell_is_cracked(stdin_input) &&\n    grid_contains_only_valid_chars(stdin_input) &&\n    coordinates_within_bounds(stdin_input)\n}\n\nspec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    let r1 = coords.0-1;\n    let c1 = coords.1-1;\n    let r2 = coords.2-1;\n    let c2 = coords.3-1;\n    let target_is_cracked = grid.index(r2).index(c2) == 'X';\n    let surrounding_dots = count_surrounding_intact_ice(grid, r2, c2);\n\n    if target_is_cracked {\n        if r1 == r2 && c1 == c2 {\n            surrounding_dots >= 1\n        } else {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        }\n    } else {\n        if surrounding_dots >= 2 {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        } else if surrounding_dots == 0 {\n            false\n        } else {\n            is_adjacent(r1+1, c1+1, r2+1, c2+1)\n        }\n    }\n}\n\nspec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {\n    (1, 1)\n}\n\nspec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['X']]\n}\n\nspec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {\n    (1, 1, 1, 1)\n}\n\nspec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {\n    0 <= r < grid.len() && 0 <= c < grid.index(r).len()\n}\n\n/* Helper functions that are referenced but not defined */\nspec fn contains_required_newlines(input: Seq<char>) -> bool { true }\nspec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool { true }\nspec fn has_valid_structure(input: Seq<char>) -> bool { true }\nspec fn all_grid_characters_valid(input: Seq<char>) -> bool { true }\nspec fn has_exactly_required_lines(input: Seq<char>) -> bool { true }\nspec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool { true }\nspec fn coordinates_within_bounds(input: Seq<char>) -> bool { true }\nspec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int { 0 }\nspec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool { true }\nspec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool { \n    (r1 == r2 && (c1 == c2 + 1 || c1 == c2 - 1)) ||\n    (c1 == c2 && (r1 == r2 + 1 || r1 == r2 - 1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        valid_input_format(stdin_input),\n        valid_grid_bounds(stdin_input),\n        valid_coordinates(stdin_input),\n        starting_cell_is_cracked(stdin_input),\n        well_formed_input(stdin_input),\n    ensures \n        result == seq!['Y', 'E', 'S', '\\n'] || result == seq!['N', 'O', '\\n'],\n        result.len() > 0,\n        (result == seq!['Y', 'E', 'S', '\\n']) <==> can_solve_ice_maze(stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        fn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_543_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(pizzas: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] >= 0\n}\n\nspec fn validate_pizza_solution(pizzas: Seq<int>, index: int, d: bool, p: int) -> bool\n    decreases pizzas.len() - index\n    when 0 <= index <= pizzas.len() && (p == 0 || p == 1)\n{\n    if index == pizzas.len() {\n        d && p == 0\n    } else {\n        let requirement = pizzas[index];\n        let new_p = if requirement % 2 == 1 { 1 - p } else { p };\n        let new_d = if requirement % 2 == 0 && p == 1 && requirement == 0 { false } else { d };\n        validate_pizza_solution(pizzas, index + 1, new_d, new_p)\n    }\n}\n\nspec fn can_fulfill_requirements(pizzas: Seq<int>) -> bool {\n    validate_pizza_solution(pizzas, 0, true, 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(pizzas: Vec<i8>) -> (result: String)\n    requires\n        forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] as int >= 0,\n        valid_input(pizzas@.map(|i, x| x as int)),\n    ensures\n        result == \"YES\" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),\n        result == \"NO\" ==> !can_fulfill_requirements(pizzas@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(pizzas: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] >= 0\n}\n\nspec fn validate_pizza_solution(pizzas: Seq<int>, index: int, d: bool, p: int) -> bool\n    decreases pizzas.len() - index\n    when 0 <= index <= pizzas.len() && (p == 0 || p == 1)\n{\n    if index == pizzas.len() {\n        d && p == 0\n    } else {\n        let requirement = pizzas[index];\n        let new_p = if requirement % 2 == 1 { 1 - p } else { p };\n        let new_d = if requirement % 2 == 0 && p == 1 && requirement == 0 { false } else { d };\n        validate_pizza_solution(pizzas, index + 1, new_d, new_p)\n    }\n}\n\nspec fn can_fulfill_requirements(pizzas: Seq<int>) -> bool {\n    validate_pizza_solution(pizzas, 0, true, 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(pizzas: Vec<i8>) -> (result: String)\n    requires\n        forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] as int >= 0,\n        valid_input(pizzas@.map(|i, x| x as int)),\n    ensures\n        result == \"YES\" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),\n        result == \"NO\" ==> !can_fulfill_requirements(pizzas@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_543.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 730, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types; types must be compatible to use == or != (this is `alloc::string::String`; this is `StrSlice`)", "message": "VerusErrorType.MismatchedType: mismatched types; types must be compatible to use == or != (this is `alloc::string::String`; this is `StrSlice`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpb3kercls", "lines": [38, 38], "label": "this is `alloc::string::String`", "text": [{"text": "        result == \"YES\" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),", "highlight_start": 9, "highlight_end": 15}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpb3kercls", "lines": [38, 38], "label": "this is `StrSlice`", "text": [{"text": "        result == \"YES\" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),", "highlight_start": 19, "highlight_end": 24}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpb3kercls", "lines": [38, 38], "label": null, "text": [{"text": "        result == \"YES\" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),", "highlight_start": 9, "highlight_end": 24}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(pizzas: Seq<int>) -> bool {\n\nspec fn validate_pizza_solution(pizzas: Seq<int>, index: int, d: bool, p: int) -> bool\n    decreases pizzas.len() - index\n    when 0 <= index <= pizzas.len() && (p == 0 || p == 1)\n{\n\nspec fn can_fulfill_requirements(pizzas: Seq<int>) -> bool {\n\n    decreases pizzas.len() - index\n\n    requires\n\n    ensures"}}}, "all_snapshots": []}
{"id": "apps_test_601_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {\n    seq![]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let lines = split_func(input, '\\n');\n        lines.len() >= 1 &&\n        parse_int_func(lines[0]) >= 0 &&\n        lines.len() >= 1 + 3 * parse_int_func(lines[0])\n    }\n}\n\nspec fn process_test_cases(input: Seq<char>) -> Seq<int> {\n    if valid_input(input) {\n        let lines = split_func(input, '\\n');\n        let t = parse_int_func(lines[0]);\n        process_test_cases_helper(input, lines, 1, 0, t, seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n    format_output_helper(results, 0, seq![])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        result.len() >= 0,\n        result == format_output(process_test_cases(input)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {\n    seq![]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let lines = split_func(input, '\\n');\n        lines.len() >= 1 &&\n        parse_int_func(lines[0]) >= 0 &&\n        lines.len() >= 1 + 3 * parse_int_func(lines[0])\n    }\n}\n\nspec fn process_test_cases(input: Seq<char>) -> Seq<int> {\n    if valid_input(input) {\n        let lines = split_func(input, '\\n');\n        let t = parse_int_func(lines[0]);\n        process_test_cases_helper(input, lines, 1, 0, t, seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n    format_output_helper(results, 0, seq![])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        result.len() >= 0,\n        result == format_output(process_test_cases(input)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_601.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1053, "minimize_time_ms": 185849, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n\nspec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {\n\nspec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn process_test_cases(input: Seq<char>) -> Seq<int> {\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n\n    requires\n\n    ensures"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {\n    seq![]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let lines = split_func(input, '\\n');\n        lines.len() >= 1 &&\n        parse_int_func(lines[0]) >= 0 &&\n        lines.len() >= 1 + 3 * parse_int_func(lines[0])\n    }\n}\n\nspec fn process_test_cases(input: Seq<char>) -> Seq<int> {\n    if valid_input(input) {\n        let lines = split_func(input, '\\n');\n        let t = parse_int_func(lines[0]);\n        process_test_cases_helper(input, lines, 1, 0, t, seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n    format_output_helper(results, 0, seq![])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        result.len() >= 0,\n        result == format_output(process_test_cases(input)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n          fn main() {\n}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_631_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(s: Seq<char>) -> bool {\n    s.len() >= 7 && \n    exists|pos: int| 0 < pos < s.len() && s[pos] == '\\n'\n}\n\nspec fn get_test_count(stdin_input: Seq<char>) -> int {\n    1\n}\n\nspec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn count_responses(result: Seq<char>) -> int {\n    0\n}\n\nspec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {\n    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))\n}\n\nspec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let T = get_test_count(stdin_input);\n    count_responses(result) == T &&\n    (forall|i: int| #![trigger get_array_sum(stdin_input, i)] 0 <= i < T ==> {\n        let array_sum = get_array_sum(stdin_input, i);\n        let target_m = get_target_m(stdin_input, i);\n        let response = get_response_at_index(result, i);\n        let yes_response = seq![\n            'Y' as char, 'E' as char, 'S' as char, '\\n' as char\n        ];\n        let no_response = seq![\n            'N' as char, 'O' as char, '\\n' as char\n        ];\n        (array_sum == target_m <==> response == yes_response) &&\n        (array_sum != target_m <==> response == no_response)\n    })\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input_format(stdin_input@)\n    ensures behavioral_correctness(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(s: Seq<char>) -> bool {\n    s.len() >= 7 && \n    exists|pos: int| 0 < pos < s.len() && s[pos] == '\\n'\n}\n\nspec fn get_test_count(stdin_input: Seq<char>) -> int {\n    1\n}\n\nspec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn count_responses(result: Seq<char>) -> int {\n    0\n}\n\nspec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {\n    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))\n}\n\nspec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let T = get_test_count(stdin_input);\n    count_responses(result) == T &&\n    (forall|i: int| #![trigger get_array_sum(stdin_input, i)] 0 <= i < T ==> {\n        let array_sum = get_array_sum(stdin_input, i);\n        let target_m = get_target_m(stdin_input, i);\n        let response = get_response_at_index(result, i);\n        let yes_response = seq![\n            'Y' as char, 'E' as char, 'S' as char, '\\n' as char\n        ];\n        let no_response = seq![\n            'N' as char, 'O' as char, '\\n' as char\n        ];\n        (array_sum == target_m <==> response == yes_response) &&\n        (array_sum != target_m <==> response == no_response)\n    })\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input_format(stdin_input@)\n    ensures behavioral_correctness(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_631.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1497, "minimize_time_ms": 248085, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 76, "minimized_LOC": 76, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input_format(s: Seq<char>) -> bool {\n\nspec fn get_test_count(stdin_input: Seq<char>) -> int {\n\nspec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {\n\nspec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {\n\nspec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {\n\nspec fn count_responses(result: Seq<char>) -> int {\n\nspec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {\n\nspec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {\n\nspec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n\n    requires valid_input_format(stdin_input@)\n\n    ensures behavioral_correctness(stdin_input@, result@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(s: Seq<char>) -> bool {\n    s.len() >= 7 && \n    exists|pos: int| 0 < pos < s.len() && s[pos] == '\\n'\n}\n\nspec fn get_test_count(stdin_input: Seq<char>) -> int {\n    1\n}\n\nspec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn count_responses(result: Seq<char>) -> int {\n    0\n}\n\nspec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {\n    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))\n}\n\nspec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let T = get_test_count(stdin_input);\n    count_responses(result) == T &&\n    (forall|i: int| #![trigger get_array_sum(stdin_input, i)] 0 <= i < T ==> {\n        let array_sum = get_array_sum(stdin_input, i);\n        let target_m = get_target_m(stdin_input, i);\n        let response = get_response_at_index(result, i);\n        let yes_response = seq![\n            'Y' as char, 'E' as char, 'S' as char, '\\n' as char\n        ];\n        let no_response = seq![\n            'N' as char, 'O' as char, '\\n' as char\n        ];\n        (array_sum == target_m <==> response == yes_response) &&\n        (array_sum != target_m <==> response == no_response)\n    })\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input_format(stdin_input@)\n    ensures behavioral_correctness(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_651_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, n: int, m: int, c: char) -> int {\n    0\n}\n\nspec fn find_start(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {\n    (0, 0)\n}\n\nspec fn find_end(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_permutations_reaching_goal(lines: Seq<Seq<char>>, n: int, m: int, path: Seq<char>, start: (int, int), end: (int, int)) -> int {\n    0\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 &&\n    has_valid_dimensions(lines) &&\n    has_valid_grid(lines) &&\n    has_start_and_end(lines) &&\n    has_valid_path(lines)\n}\n\nspec fn has_valid_dimensions(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2\n}\n\nspec fn has_valid_grid(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    forall|i: int| 1 <= i <= n && i < lines.len() ==>\n        forall|j: int| 0 <= j < lines[i].len() && j < m ==>\n            lines[i][j] == '.' || lines[i][j] == '#' || \n            lines[i][j] == 'S' || lines[i][j] == 'E'\n}\n\nspec fn has_start_and_end(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'S') &&\n    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'E') &&\n    count_occurrences(lines, n, m, 'S') == 1 &&\n    count_occurrences(lines, n, m, 'E') == 1\n}\n\nspec fn has_valid_path(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    valid_path_string(lines[n + 1])\n}\n\nspec fn valid_path_string(path: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < path.len() ==> \n        '0' <= path[i] && path[i] <= '3'\n}\n\nspec fn valid_result(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    forall|c: char| result.contains(c) ==> \n        ('0' <= c && c <= '9') || c == '\\n'\n}\n\nspec fn count_valid_ways(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    let start = find_start(lines, n, m);\n    let end = find_end(lines, n, m);\n    let path = lines[n + 1];\n    count_permutations_reaching_goal(lines, n, m, path, start, end)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    String::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, n: int, m: int, c: char) -> int {\n    0\n}\n\nspec fn find_start(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {\n    (0, 0)\n}\n\nspec fn find_end(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_permutations_reaching_goal(lines: Seq<Seq<char>>, n: int, m: int, path: Seq<char>, start: (int, int), end: (int, int)) -> int {\n    0\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 &&\n    has_valid_dimensions(lines) &&\n    has_valid_grid(lines) &&\n    has_start_and_end(lines) &&\n    has_valid_path(lines)\n}\n\nspec fn has_valid_dimensions(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2\n}\n\nspec fn has_valid_grid(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    forall|i: int| 1 <= i <= n && i < lines.len() ==>\n        forall|j: int| 0 <= j < lines[i].len() && j < m ==>\n            lines[i][j] == '.' || lines[i][j] == '#' || \n            lines[i][j] == 'S' || lines[i][j] == 'E'\n}\n\nspec fn has_start_and_end(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'S') &&\n    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'E') &&\n    count_occurrences(lines, n, m, 'S') == 1 &&\n    count_occurrences(lines, n, m, 'E') == 1\n}\n\nspec fn has_valid_path(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    valid_path_string(lines[n + 1])\n}\n\nspec fn valid_path_string(path: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < path.len() ==> \n        '0' <= path[i] && path[i] <= '3'\n}\n\nspec fn valid_result(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    forall|c: char| result.contains(c) ==> \n        ('0' <= c && c <= '9') || c == '\\n'\n}\n\nspec fn count_valid_ways(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    let start = find_start(lines, n, m);\n    let end = find_end(lines, n, m);\n    let path = lines[n + 1];\n    count_permutations_reaching_goal(lines, n, m, path, start, end)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    String::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_651.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 884, "verus_errors": [{"error_type": "Other", "error_text": "`alloc::string::impl&%0::new` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "message": "VerusErrorType.Other: `alloc::string::impl&%0::new` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmppzlcdeb3", "lines": [114, 114], "label": null, "text": [{"text": "    String::new()", "highlight_start": 5, "highlight_end": 18}]}]}, {"error_type": "Other", "error_text": "`core::str::impl&%0::len` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "message": "VerusErrorType.Other: `core::str::impl&%0::len` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmppzlcdeb3", "lines": [108, 108], "label": null, "text": [{"text": "    requires stdin_input.len() > 0", "highlight_start": 14, "highlight_end": 31}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 122, "minimized_LOC": 122, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, n: int, m: int, c: char) -> int {\n\nspec fn find_start(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {\n\nspec fn find_end(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {\n\nspec fn count_permutations_reaching_goal(lines: Seq<Seq<char>>, n: int, m: int, path: Seq<char>, start: (int, int), end: (int, int)) -> int {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn has_valid_dimensions(lines: Seq<Seq<char>>) -> bool {\n\nspec fn has_valid_grid(lines: Seq<Seq<char>>) -> bool {\n\nspec fn has_start_and_end(lines: Seq<Seq<char>>) -> bool {\n\nspec fn has_valid_path(lines: Seq<Seq<char>>) -> bool {\n\nspec fn valid_path_string(path: Seq<char>) -> bool {\n\nspec fn valid_result(result: Seq<char>) -> bool {\n\nspec fn count_valid_ways(input: Seq<char>) -> int {\n\n    requires stdin_input.len() > 0"}}}, "all_snapshots": []}
{"id": "apps_test_701_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_lines(stdin_input: Seq<char>) -> Seq<Seq<char>>\n    decreases stdin_input.len()\n{\n    if stdin_input.len() == 0 {\n        seq![]\n    } else {\n        let newline_pos = find_newline(stdin_input, 0);\n        if newline_pos == -1 {\n            seq![stdin_input]\n        } else if newline_pos == 0 {\n            parse_lines(stdin_input.subrange(1, stdin_input.len() as int))\n        } else if newline_pos < stdin_input.len() && newline_pos >= 0 {\n            seq![stdin_input.subrange(0, newline_pos)] + parse_lines(stdin_input.subrange(newline_pos + 1, stdin_input.len() as int))\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn find_newline(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        -1\n    } else if s[start] == '\\n' {\n        start\n    } else {\n        find_newline(s, start + 1)\n    }\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    let lines = parse_lines(stdin_input);\n    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0 &&\n    (forall|i: int| 0 <= i < lines[0].len() ==> 'a' <= lines[0][i] <= 'z') &&\n    (forall|i: int| 0 <= i < lines[1].len() ==> 'a' <= lines[1][i] <= 'z')\n}\n\nspec fn is_subsequence(s: Seq<char>, t: Seq<char>) -> bool {\n    if s.len() == 0 {\n        true\n    } else if t.len() == 0 {\n        false\n    } else if s[0] == t[0] {\n        is_subsequence(s.subrange(1, s.len() as int), t.subrange(1, t.len() as int))\n    } else {\n        is_subsequence(s, t.subrange(1, t.len() as int))\n    }\n}\n\nspec fn sort_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        let pivot = s[0];\n        let smaller = filter_chars(s.subrange(1, s.len() as int), pivot, true, false);\n        let equal = filter_chars(s, pivot, false, true);\n        let larger = filter_chars(s.subrange(1, s.len() as int), pivot, false, false);\n        sort_string(smaller) + equal + sort_string(larger)\n    }\n}\n\nspec fn filter_chars(s: Seq<char>, pivot: char, take_less: bool, take_equal: bool) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let first = s[0];\n        let rest = filter_chars(s.subrange(1, s.len() as int), pivot, take_less, take_equal);\n        if (take_less && first < pivot) || (take_equal && first == pivot) || (!take_less && !take_equal && first > pivot) {\n            seq![first] + rest\n        } else {\n            rest\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: &'static str)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"array\"\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_lines(stdin_input: Seq<char>) -> Seq<Seq<char>>\n    decreases stdin_input.len()\n{\n    if stdin_input.len() == 0 {\n        seq![]\n    } else {\n        let newline_pos = find_newline(stdin_input, 0);\n        if newline_pos == -1 {\n            seq![stdin_input]\n        } else if newline_pos == 0 {\n            parse_lines(stdin_input.subrange(1, stdin_input.len() as int))\n        } else if newline_pos < stdin_input.len() && newline_pos >= 0 {\n            seq![stdin_input.subrange(0, newline_pos)] + parse_lines(stdin_input.subrange(newline_pos + 1, stdin_input.len() as int))\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn find_newline(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        -1\n    } else if s[start] == '\\n' {\n        start\n    } else {\n        find_newline(s, start + 1)\n    }\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    let lines = parse_lines(stdin_input);\n    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0 &&\n    (forall|i: int| 0 <= i < lines[0].len() ==> 'a' <= lines[0][i] <= 'z') &&\n    (forall|i: int| 0 <= i < lines[1].len() ==> 'a' <= lines[1][i] <= 'z')\n}\n\nspec fn is_subsequence(s: Seq<char>, t: Seq<char>) -> bool {\n    if s.len() == 0 {\n        true\n    } else if t.len() == 0 {\n        false\n    } else if s[0] == t[0] {\n        is_subsequence(s.subrange(1, s.len() as int), t.subrange(1, t.len() as int))\n    } else {\n        is_subsequence(s, t.subrange(1, t.len() as int))\n    }\n}\n\nspec fn sort_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        let pivot = s[0];\n        let smaller = filter_chars(s.subrange(1, s.len() as int), pivot, true, false);\n        let equal = filter_chars(s, pivot, false, true);\n        let larger = filter_chars(s.subrange(1, s.len() as int), pivot, false, false);\n        sort_string(smaller) + equal + sort_string(larger)\n    }\n}\n\nspec fn filter_chars(s: Seq<char>, pivot: char, take_less: bool, take_equal: bool) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let first = s[0];\n        let rest = filter_chars(s.subrange(1, s.len() as int), pivot, take_less, take_equal);\n        if (take_less && first < pivot) || (take_equal && first == pivot) || (!take_less && !take_equal && first > pivot) {\n            seq![first] + rest\n        } else {\n            rest\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: &'static str)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"array\"\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_701.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 908, "verus_errors": [{"error_type": "Other", "error_text": "recursive function must have a decreases clause ()", "message": "VerusErrorType.Other: recursive function must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp9nx8gy5e", "lines": [44, 44], "label": null, "text": [{"text": "spec fn is_subsequence(s: Seq<char>, t: Seq<char>) -> bool {", "highlight_start": 6, "highlight_end": 59}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 105, "minimized_LOC": 105, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn parse_lines(stdin_input: Seq<char>) -> Seq<Seq<char>>\n    decreases stdin_input.len()\n{\n\nspec fn find_newline(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n\nspec fn is_subsequence(s: Seq<char>, t: Seq<char>) -> bool {\n\nspec fn sort_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n\nspec fn filter_chars(s: Seq<char>, pivot: char, take_less: bool, take_equal: bool) -> Seq<char>\n    decreases s.len()\n{\n\n    decreases stdin_input.len()\n\n    decreases s.len() - start\n\n    decreases s.len()\n\n    decreases s.len()"}}}, "all_snapshots": []}
{"id": "apps_test_72_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result =~= seq!['K','u','r','o'] || result =~= seq!['S','h','i','r','o'] || result =~= seq!['K','a','t','i','e'] || result =~= seq!['D','r','a','w'] || result.len() == 0\n}\n\nspec fn optimal_score(ribbon: Seq<char>, turns: int) -> int \n    recommends ribbon.len() >= 0 && turns >= 0\n{\n    let max_freq = max_char_freq(ribbon);\n    let length = ribbon.len() as int;\n    if turns == 1 && max_freq == length {\n        if max_freq > 0 { max_freq - 1 } else { 0 }\n    } else if length < max_freq + turns {\n        length\n    } else {\n        max_freq + turns\n    }\n}\nspec fn max_char_freq(s: Seq<char>) -> int {\n    0\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a } else if b >= c { b } else { c }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(result)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result =~= seq!['K','u','r','o'] || result =~= seq!['S','h','i','r','o'] || result =~= seq!['K','a','t','i','e'] || result =~= seq!['D','r','a','w'] || result.len() == 0\n}\n\nspec fn optimal_score(ribbon: Seq<char>, turns: int) -> int \n    recommends ribbon.len() >= 0 && turns >= 0\n{\n    let max_freq = max_char_freq(ribbon);\n    let length = ribbon.len() as int;\n    if turns == 1 && max_freq == length {\n        if max_freq > 0 { max_freq - 1 } else { 0 }\n    } else if length < max_freq + turns {\n        length\n    } else {\n        max_freq + turns\n    }\n}\nspec fn max_char_freq(s: Seq<char>) -> int {\n    0\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a } else if b >= c { b } else { c }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(result)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_72.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1400, "minimize_time_ms": 184594, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 62, "minimized_LOC": 62, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(result: Seq<char>) -> bool {\n\nspec fn optimal_score(ribbon: Seq<char>, turns: int) -> int \n    recommends ribbon.len() >= 0 && turns >= 0\n{\n\nspec fn max_char_freq(s: Seq<char>) -> int {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int(s: Seq<char>) -> int {\n\nspec fn max3(a: int, b: int, c: int) -> int {\n\n    requires valid_input(input)\n\n    ensures valid_output(result)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result =~= seq!['K','u','r','o'] || result =~= seq!['S','h','i','r','o'] || result =~= seq!['K','a','t','i','e'] || result =~= seq!['D','r','a','w'] || result.len() == 0\n}\n\nspec fn optimal_score(ribbon: Seq<char>, turns: int) -> int \n    recommends ribbon.len() >= 0 && turns >= 0\n{\n    let max_freq = max_char_freq(ribbon);\n    let length = ribbon.len() as int;\n    if turns == 1 && max_freq == length {\n        if max_freq > 0 { max_freq - 1 } else { 0 }\n    } else if length < max_freq + turns {\n        length\n    } else {\n        max_freq + turns\n    }\n}\nspec fn max_char_freq(s: Seq<char>) -> int {\n    0\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a } else if b >= c { b } else { c }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(result)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_726_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_sorted(hotels: Seq<int>, n: int) -> bool\n    decreases n\n{\n    if n <= 1 {\n        true\n    } else {\n        hotels[n-2] < hotels[n-1] && is_sorted(hotels, n-1)\n    }\n}\n\nspec fn valid_input(n: int, d: int, hotels: Seq<int>) -> bool {\n    n > 0 && d > 0 && hotels.len() == n && is_sorted(hotels, n)\n}\n\nspec fn sum_contributions(hotels: Seq<int>, d: int, i: int) -> int\n    recommends 0 <= i && i <= hotels.len() - 1,\n                d > 0,\n                is_sorted(hotels, hotels.len() as int)\n    decreases i\n    when i >= 0\n{\n    if i == 0 { \n        0 \n    } else {\n        let gap = hotels[i as int] - hotels[(i-1) as int];\n        let contribution: int = if gap == 2*d { 1 } else if gap > 2*d { 2 } else { 0 };\n        contribution + sum_contributions(hotels, d, i-1)\n    }\n}\n\nspec fn correct_result(n: int, d: int, hotels: Seq<int>, result: int) -> bool\n    recommends valid_input(n, d, hotels)\n{\n    result == 2 + sum_contributions(hotels, d, n-1) && result >= 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, hotels: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, d as int, hotels@.map(|_, x: i8| x as int))\n    ensures correct_result(n as int, d as int, hotels@.map(|_, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_sorted(hotels: Seq<int>, n: int) -> bool\n    decreases n\n{\n    if n <= 1 {\n        true\n    } else {\n        hotels[n-2] < hotels[n-1] && is_sorted(hotels, n-1)\n    }\n}\n\nspec fn valid_input(n: int, d: int, hotels: Seq<int>) -> bool {\n    n > 0 && d > 0 && hotels.len() == n && is_sorted(hotels, n)\n}\n\nspec fn sum_contributions(hotels: Seq<int>, d: int, i: int) -> int\n    recommends 0 <= i && i <= hotels.len() - 1,\n                d > 0,\n                is_sorted(hotels, hotels.len() as int)\n    decreases i\n    when i >= 0\n{\n    if i == 0 { \n        0 \n    } else {\n        let gap = hotels[i as int] - hotels[(i-1) as int];\n        let contribution: int = if gap == 2*d { 1 } else if gap > 2*d { 2 } else { 0 };\n        contribution + sum_contributions(hotels, d, i-1)\n    }\n}\n\nspec fn correct_result(n: int, d: int, hotels: Seq<int>, result: int) -> bool\n    recommends valid_input(n, d, hotels)\n{\n    result == 2 + sum_contributions(hotels, d, n-1) && result >= 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, hotels: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, d as int, hotels@.map(|_, x: i8| x as int))\n    ensures correct_result(n as int, d as int, hotels@.map(|_, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_726.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1064, "verus_errors": [{"error_type": "Other", "error_text": "The verifier does not yet support the following Rust feature: only variables are supported here, not general patterns ()", "message": "VerusErrorType.Other: The verifier does not yet support the following Rust feature: only variables are supported here, not general patterns ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmptk8cw2km", "lines": [47, 47], "label": null, "text": [{"text": "    requires valid_input(n as int, d as int, hotels@.map(|_, x: i8| x as int))", "highlight_start": 59, "highlight_end": 60}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 60, "minimized_LOC": 60, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn is_sorted(hotels: Seq<int>, n: int) -> bool\n    decreases n\n{\n\nspec fn valid_input(n: int, d: int, hotels: Seq<int>) -> bool {\n\nspec fn sum_contributions(hotels: Seq<int>, d: int, i: int) -> int\n    recommends 0 <= i && i <= hotels.len() - 1,\n                d > 0,\n                is_sorted(hotels, hotels.len() as int)\n    decreases i\n    when i >= 0\n{\n\nspec fn correct_result(n: int, d: int, hotels: Seq<int>, result: int) -> bool\n    recommends valid_input(n, d, hotels)\n{\n\n    decreases n\n\n    decreases i\n\n    requires valid_input(n as int, d as int, hotels@.map(|_, x: i8| x as int))\n\n    ensures correct_result(n as int, d as int, hotels@.map(|_, x: i8| x as int), result as int)"}}}, "all_snapshots": []}
{"id": "apps_test_743_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: int, ar: Seq<int>) -> bool {\n    n >= 2 && ar.len() == n && (forall|i: int| 0 <= i < n ==> ar[i] > 0)\n}\n\nspec fn gcd(x: int, y: int) -> int\n    requires x > 0 && y > 0,\n    ensures gcd(x, y) > 0,\n    decreases if x < y { y } else { x },\n{\n    if x == y { x }\n    else if x < y { gcd(x, y - x) }\n    else { gcd(x - y, y) }\n}\n\nspec fn gcd_of_sequence(ar: Seq<int>) -> int\n    requires ar.len() >= 1,\n    requires (forall|i: int| 0 <= i < ar.len() ==> ar[i] > 0),\n    ensures gcd_of_sequence(ar) > 0,\n    decreases ar.len(),\n{\n    if ar.len() == 1 { ar[0] }\n    else { gcd(ar[0], gcd_of_sequence(ar.subrange(1, ar.len() as int))) }\n}\n\nspec fn minimal_sum(n: int, ar: Seq<int>) -> int\n    requires valid_input(n, ar),\n{\n    gcd_of_sequence(ar) * n\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, ar: Seq<int>) -> (result: int)\n    requires valid_input(n, ar),\n    ensures result == minimal_sum(n, ar),\n    ensures result > 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn valid_input(n: int, ar: Seq<int>) -> bool {\n    n >= 2 && ar.len() == n && (forall|i: int| 0 <= i < n ==> ar[i] > 0)\n}\n\nspec fn gcd(x: int, y: int) -> int\n    requires x > 0 && y > 0,\n    ensures gcd(x, y) > 0,\n    decreases if x < y { y } else { x },\n{\n    if x == y { x }\n    else if x < y { gcd(x, y - x) }\n    else { gcd(x - y, y) }\n}\n\nspec fn gcd_of_sequence(ar: Seq<int>) -> int\n    requires ar.len() >= 1,\n    requires (forall|i: int| 0 <= i < ar.len() ==> ar[i] > 0),\n    ensures gcd_of_sequence(ar) > 0,\n    decreases ar.len(),\n{\n    if ar.len() == 1 { ar[0] }\n    else { gcd(ar[0], gcd_of_sequence(ar.subrange(1, ar.len() as int))) }\n}\n\nspec fn minimal_sum(n: int, ar: Seq<int>) -> int\n    requires valid_input(n, ar),\n{\n    gcd_of_sequence(ar) * n\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, ar: Seq<int>) -> (result: int)\n    requires valid_input(n, ar),\n    ensures result == minimal_sum(n, ar),\n    ensures result > 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_743.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 373, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp6yg_4qsv", "lines": [43, 43], "label": null, "text": [{"text": "    ensures result > 0,", "highlight_start": 5, "highlight_end": 12}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 55, "minimized_LOC": 55, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"requires_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, ar: Seq<int>) -> bool {\n\nspec fn gcd(x: int, y: int) -> int\n    requires x > 0 && y > 0,\n    ensures gcd(x, y) > 0,\n    decreases if x < y {\n\nspec fn gcd_of_sequence(ar: Seq<int>) -> int\n    requires ar.len() >= 1,\n    requires (forall|i: int| 0 <= i < ar.len() ==> ar[i] > 0),\n    ensures gcd_of_sequence(ar) > 0,\n    decreases ar.len(),\n{\n\nspec fn minimal_sum(n: int, ar: Seq<int>) -> int\n    requires valid_input(n, ar),\n{\n\n    requires x > 0 && y > 0,\n\n    ensures gcd(x, y) > 0,\n\n    decreases if x < y { y } else { x },\n\n    requires ar.len() >= 1,\n\n    requires (forall|i: int| 0 <= i < ar.len() ==> ar[i] > 0),\n\n    ensures gcd_of_sequence(ar) > 0,\n\n    decreases ar.len(),\n\n    requires valid_input(n, ar),\n\n    requires valid_input(n, ar),\n\n    ensures result == minimal_sum(n, ar),\n\n    ensures result > 0,"}}}, "all_snapshots": []}
{"id": "apps_test_752_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: &str) -> Seq<&str>\n    uninterp;\n\nspec fn parse_integer(s: &str) -> int\n    uninterp;\n\nspec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>\n    uninterp;\n\nspec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat\n    uninterp;\n\nspec fn int_to_string(n: nat) -> String\n    uninterp;\n\nspec fn valid_input(stdin_input: &str) -> bool {\n    let lines = split_lines(stdin_input);\n    lines.len() >= 1 && {\n        let n = parse_integer(lines[0]);\n        n >= 0 && lines.len() >= (2 * n + 1) && \n        (forall|i: int| 1 <= i <= 2 * n ==> \n            i < lines.len() && lines[i].len() > 0)\n    }\n}\n\nspec fn compute_mismatches(stdin_input: &str) -> nat\n    decreases stdin_input.len()\n{\n    let lines = split_lines(stdin_input);\n    let n = parse_integer(lines[0]);\n    if n == 0 { \n        0 \n    } else {\n        let prev_sizes = count_sizes(lines.subrange(1, n + 1));\n        let current_sizes = lines.subrange(n + 1, 2 * n + 1);\n        count_unmatched_sizes(prev_sizes, current_sizes)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input.len() > 0,\n        valid_input(stdin_input),\n    ensures \n        result.len() > 0,\n        result.as_bytes()[result.len()-1] == b'\\n' || \n            (result.len() > 1 && result.as_bytes().subrange(result.len()-2, result.len()) == seq![b'\\r', b'\\n']),\n        exists|mismatches: nat| \n            result == int_to_string(mismatches) + \"\\n\" && \n            mismatches == compute_mismatches(stdin_input),\n        ({\n            let lines = split_lines(stdin_input);\n            let n = parse_integer(lines[0]);\n            n >= 0 ==> {\n                let mismatches = compute_mismatches(stdin_input);\n                mismatches <= n &&\n                result == int_to_string(mismatches) + \"\\n\"\n            }\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    String::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: &str) -> Seq<&str>\n    uninterp;\n\nspec fn parse_integer(s: &str) -> int\n    uninterp;\n\nspec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>\n    uninterp;\n\nspec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat\n    uninterp;\n\nspec fn int_to_string(n: nat) -> String\n    uninterp;\n\nspec fn valid_input(stdin_input: &str) -> bool {\n    let lines = split_lines(stdin_input);\n    lines.len() >= 1 && {\n        let n = parse_integer(lines[0]);\n        n >= 0 && lines.len() >= (2 * n + 1) && \n        (forall|i: int| 1 <= i <= 2 * n ==> \n            i < lines.len() && lines[i].len() > 0)\n    }\n}\n\nspec fn compute_mismatches(stdin_input: &str) -> nat\n    decreases stdin_input.len()\n{\n    let lines = split_lines(stdin_input);\n    let n = parse_integer(lines[0]);\n    if n == 0 { \n        0 \n    } else {\n        let prev_sizes = count_sizes(lines.subrange(1, n + 1));\n        let current_sizes = lines.subrange(n + 1, 2 * n + 1);\n        count_unmatched_sizes(prev_sizes, current_sizes)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input.len() > 0,\n        valid_input(stdin_input),\n    ensures \n        result.len() > 0,\n        result.as_bytes()[result.len()-1] == b'\\n' || \n            (result.len() > 1 && result.as_bytes().subrange(result.len()-2, result.len()) == seq![b'\\r', b'\\n']),\n        exists|mismatches: nat| \n            result == int_to_string(mismatches) + \"\\n\" && \n            mismatches == compute_mismatches(stdin_input),\n        ({\n            let lines = split_lines(stdin_input);\n            let n = parse_integer(lines[0]);\n            n >= 0 ==> {\n                let mismatches = compute_mismatches(stdin_input);\n                mismatches <= n &&\n                result == int_to_string(mismatches) + \"\\n\"\n            }\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    String::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_752.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 400, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp_4oyfzyt", "lines": [7, 7], "label": null, "text": [{"text": "    uninterp;", "highlight_start": 5, "highlight_end": 13}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 83, "minimized_LOC": 83, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(input: &str) -> Seq<&str>\n    uninterp;\n\nspec fn parse_integer(s: &str) -> int\n    uninterp;\n\nspec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>\n    uninterp;\n\nspec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat\n    uninterp;\n\nspec fn int_to_string(n: nat) -> String\n    uninterp;\n\nspec fn valid_input(stdin_input: &str) -> bool {\n\nspec fn parse_integer(s: &str) -> int\n    uninterp;\n\nspec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>\n    uninterp;\n\nspec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat\n    uninterp;\n\nspec fn int_to_string(n: nat) -> String\n    uninterp;\n\nspec fn valid_input(stdin_input: &str) -> bool {\n\nspec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>\n    uninterp;\n\nspec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat\n    uninterp;\n\nspec fn int_to_string(n: nat) -> String\n    uninterp;\n\nspec fn valid_input(stdin_input: &str) -> bool {\n\nspec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat\n    uninterp;\n\nspec fn int_to_string(n: nat) -> String\n    uninterp;\n\nspec fn valid_input(stdin_input: &str) -> bool {\n\nspec fn int_to_string(n: nat) -> String\n    uninterp;\n\nspec fn valid_input(stdin_input: &str) -> bool {\n\nspec fn valid_input(stdin_input: &str) -> bool {\n\nspec fn compute_mismatches(stdin_input: &str) -> nat\n    decreases stdin_input.len()\n{\n\n    decreases stdin_input.len()\n\n    requires \n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_753_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })\n{\n    if b == 0 {\n        if a >= 0 { a } else { -a }\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a > 0 && b > 0 && c > 0 && d > 0\n}\n\nspec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {\n    num >= 0 && den > 0 && \n    gcd(num, den) == 1\n    /* && s == int_to_string(num) + \"/\" + int_to_string(den) */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int, c: int, d: int) -> (result: Seq<char>)\n    requires valid_input(a, b, c, d)\n    ensures ({\n        let equal_case = a * d == b * c;\n        let greater_case = a * d > b * c;\n        let less_case = a * d < b * c;\n        \n        (equal_case ==> result == seq!['0', '/', '1']) &&\n        (greater_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * a * d == (a * d - b * c) * denominator) &&\n        (less_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * b * c == (b * c - a * d) * denominator)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })\n{\n    if b == 0 {\n        if a >= 0 { a } else { -a }\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a > 0 && b > 0 && c > 0 && d > 0\n}\n\nspec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {\n    num >= 0 && den > 0 && \n    gcd(num, den) == 1\n    /* && s == int_to_string(num) + \"/\" + int_to_string(den) */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int, c: int, d: int) -> (result: Seq<char>)\n    requires valid_input(a, b, c, d)\n    ensures ({\n        let equal_case = a * d == b * c;\n        let greater_case = a * d > b * c;\n        let less_case = a * d < b * c;\n        \n        (equal_case ==> result == seq!['0', '/', '1']) &&\n        (greater_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * a * d == (a * d - b * c) * denominator) &&\n        (less_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * b * c == (b * c - a * d) * denominator)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_753.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1516, "minimize_time_ms": 187005, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn gcd(a: int, b: int) -> int\n    decreases (if b == 0 {\n\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n\nspec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {\n\n    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })\n\n    requires valid_input(a, b, c, d)\n\n    ensures ({"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })\n{\n    if b == 0 {\n        if a >= 0 { a } else { -a }\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a > 0 && b > 0 && c > 0 && d > 0\n}\n\nspec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {\n    num >= 0 && den > 0 && \n    gcd(num, den) == 1\n    /* && s == int_to_string(num) + \"/\" + int_to_string(den) */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int, c: int, d: int) -> (result: Seq<char>)\n    requires valid_input(a, b, c, d)\n    ensures ({\n        let equal_case = a * d == b * c;\n        let greater_case = a * d > b * c;\n        let less_case = a * d < b * c;\n        \n        (equal_case ==> result == seq!['0', '/', '1']) &&\n        (greater_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * a * d == (a * d - b * c) * denominator) &&\n        (less_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * b * c == (b * c - a * d) * denominator)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_756_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && n <= 90 &&\n    a.len() == n &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= 90) &&\n    (forall|i: int, j: int| i + 1 == j && 0 <= i < n - 1 ==> #[trigger] a[i] < #[trigger] a[j])\n}\n\nspec fn find_cutoff(a: Seq<int>, index: int, cutoff: int) -> int\n    decreases a.len() - index\n    when 0 <= index <= a.len()\n{\n    if index >= a.len() {\n        cutoff\n    } else if a[index] > cutoff {\n        cutoff\n    } else {\n        find_cutoff(a, index + 1, a[index] + 15)\n    }\n}\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn valid_output(result: int, n: int, a: Seq<int>) -> bool {\n    valid_input(n, a) ==>\n    (1 <= result <= 90 &&\n     result == min(90, find_cutoff(a, 0, 15)))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|x| x as int))\n    ensures valid_output(result as int, n as int, a@.map(|x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && n <= 90 &&\n    a.len() == n &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= 90) &&\n    (forall|i: int, j: int| i + 1 == j && 0 <= i < n - 1 ==> #[trigger] a[i] < #[trigger] a[j])\n}\n\nspec fn find_cutoff(a: Seq<int>, index: int, cutoff: int) -> int\n    decreases a.len() - index\n    when 0 <= index <= a.len()\n{\n    if index >= a.len() {\n        cutoff\n    } else if a[index] > cutoff {\n        cutoff\n    } else {\n        find_cutoff(a, index + 1, a[index] + 15)\n    }\n}\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn valid_output(result: int, n: int, a: Seq<int>) -> bool {\n    valid_input(n, a) ==>\n    (1 <= result <= 90 &&\n     result == min(90, find_cutoff(a, 0, 15)))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|x| x as int))\n    ensures valid_output(result as int, n as int, a@.map(|x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_756.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1095, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpv6t58pb2", "lines": [41, 41], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    requires valid_input(n as int, a@.map(|x| x as int))", "highlight_start": 43, "highlight_end": 55}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpv6t58pb2", "lines": [41, 41], "label": "arguments to this method are incorrect", "text": [{"text": "    requires valid_input(n as int, a@.map(|x| x as int))", "highlight_start": 39, "highlight_end": 42}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpv6t58pb2", "lines": [42, 42], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    ensures valid_output(result as int, n as int, a@.map(|x| x as int))", "highlight_start": 58, "highlight_end": 70}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpv6t58pb2", "lines": [42, 42], "label": "arguments to this method are incorrect", "text": [{"text": "    ensures valid_output(result as int, n as int, a@.map(|x| x as int))", "highlight_start": 54, "highlight_end": 57}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 56, "minimized_LOC": 56, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, a: Seq<int>) -> bool {\n\nspec fn find_cutoff(a: Seq<int>, index: int, cutoff: int) -> int\n    decreases a.len() - index\n    when 0 <= index <= a.len()\n{\n\nspec fn min(x: int, y: int) -> int {\n\nspec fn valid_output(result: int, n: int, a: Seq<int>) -> bool {\n\n    decreases a.len() - index\n\n    requires valid_input(n as int, a@.map(|x| x as int))\n\n    ensures valid_output(result as int, n as int, a@.map(|x| x as int))"}}}, "all_snapshots": []}
{"id": "apps_test_807_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, c: int, prices: Seq<int>) -> bool {\n    n >= 2 && prices.len() == n && c >= 0 &&\n    (forall|i: int| 0 <= i < prices.len() ==> prices[i] >= 0)\n}\n\nspec fn profit_for_day(prices: Seq<int>, day: int, c: int) -> int {\n    if 0 <= day < prices.len() - 1 {\n        prices[day] - prices[day + 1] - c\n    } else {\n        0\n    }\n}\n\nspec fn max_possible_profit(prices: Seq<int>, c: int) -> int {\n    if prices.len() >= 2 {\n        let profits = Seq::new((prices.len() - 1) as nat, |i: int| profit_for_day(prices, i, c));\n        if profits.len() == 0 { \n            0 \n        } else {\n            let max_profit = profits[0];\n            if profits.len() == 1 { \n                max_profit \n            } else { \n                seq_max(profits) \n            }\n        }\n    } else {\n        0\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() > 0 {\n        if s.len() == 1 { \n            s[0] \n        } else if s[0] >= seq_max(s.subrange(1, s.len() as int)) { \n            s[0] \n        } else { \n            seq_max(s.subrange(1, s.len() as int)) \n        }\n    } else {\n        0\n    }\n}\n\nspec fn correct_result(n: int, c: int, prices: Seq<int>, result: int) -> bool {\n    valid_input(n, c, prices) ==>\n    (result >= 0 &&\n     (result == 0 <==> (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= 0)) &&\n     (result > 0 ==> (exists|i: int| 0 <= i < n - 1 && profit_for_day(prices, i, c) == result)) &&\n     (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= result))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, c: i8, prices: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, c as int, prices@.map(|v| v as int))\n    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, c: int, prices: Seq<int>) -> bool {\n    n >= 2 && prices.len() == n && c >= 0 &&\n    (forall|i: int| 0 <= i < prices.len() ==> prices[i] >= 0)\n}\n\nspec fn profit_for_day(prices: Seq<int>, day: int, c: int) -> int {\n    if 0 <= day < prices.len() - 1 {\n        prices[day] - prices[day + 1] - c\n    } else {\n        0\n    }\n}\n\nspec fn max_possible_profit(prices: Seq<int>, c: int) -> int {\n    if prices.len() >= 2 {\n        let profits = Seq::new((prices.len() - 1) as nat, |i: int| profit_for_day(prices, i, c));\n        if profits.len() == 0 { \n            0 \n        } else {\n            let max_profit = profits[0];\n            if profits.len() == 1 { \n                max_profit \n            } else { \n                seq_max(profits) \n            }\n        }\n    } else {\n        0\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() > 0 {\n        if s.len() == 1 { \n            s[0] \n        } else if s[0] >= seq_max(s.subrange(1, s.len() as int)) { \n            s[0] \n        } else { \n            seq_max(s.subrange(1, s.len() as int)) \n        }\n    } else {\n        0\n    }\n}\n\nspec fn correct_result(n: int, c: int, prices: Seq<int>, result: int) -> bool {\n    valid_input(n, c, prices) ==>\n    (result >= 0 &&\n     (result == 0 <==> (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= 0)) &&\n     (result > 0 ==> (exists|i: int| 0 <= i < n - 1 && profit_for_day(prices, i, c) == result)) &&\n     (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= result))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, c: i8, prices: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, c as int, prices@.map(|v| v as int))\n    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_807.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1242, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpltxagoru", "lines": [66, 66], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    requires valid_input(n as int, c as int, prices@.map(|v| v as int))", "highlight_start": 58, "highlight_end": 70}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpltxagoru", "lines": [66, 66], "label": "arguments to this method are incorrect", "text": [{"text": "    requires valid_input(n as int, c as int, prices@.map(|v| v as int))", "highlight_start": 54, "highlight_end": 57}]}]}, {"error_type": "MismatchedType", "error_text": "mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "message": "VerusErrorType.MismatchedType: mismatched types (expected a tuple with 2 elements, found one with 1 element; arguments to this method are incorrect)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpltxagoru", "lines": [67, 67], "label": "expected a tuple with 2 elements, found one with 1 element", "text": [{"text": "    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)", "highlight_start": 60, "highlight_end": 72}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpltxagoru", "lines": [67, 67], "label": "arguments to this method are incorrect", "text": [{"text": "    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)", "highlight_start": 56, "highlight_end": 59}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 79, "minimized_LOC": 79, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, c: int, prices: Seq<int>) -> bool {\n\nspec fn profit_for_day(prices: Seq<int>, day: int, c: int) -> int {\n\nspec fn max_possible_profit(prices: Seq<int>, c: int) -> int {\n\nspec fn seq_max(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn correct_result(n: int, c: int, prices: Seq<int>, result: int) -> bool {\n\n    decreases s.len()\n\n    requires valid_input(n as int, c as int, prices@.map(|v| v as int))\n\n    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)"}}}, "all_snapshots": []}
{"id": "apps_test_813_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&\n    {\n        let n = parse_int(split_spaces(lines[0])[0]);\n        n > 0\n    }\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    let n = parse_int(split_spaces(lines[0])[0]);\n    result.len() == 2 * n - 1 &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[2*i] == '1' || result[2*i] == '2') &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[2*i+1] == ' ')\n}\n\nspec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    let n = parse_int(split_spaces(lines[0])[0]);\n    let arthur_apples = parse_int_seq(split_spaces(lines[1]));\n    let arthur_set = Set::new(|x: int| arthur_apples.contains(x));\n    forall|i: int| 1 <= i <= n ==> \n        (arthur_set.contains(i) ==> #[trigger] result[2*(i-1)] == '1') &&\n        (!arthur_set.contains(i) ==> result[2*(i-1)] == '2')\n}\n\n/* Helper functions for parsing (spec functions) */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> {\n    Seq::empty()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n    ensures \n        !valid_input(input@) ==> result.len() == 0,\n        valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool {\n          let lines = split_lines(input);\n          lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&     {\n             let n = parse_int(split_spaces(lines[0])[0]);\n             n > 0     }\n      }\n       spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_int(s: Seq<char>) -> int {\n          0 }\n       spec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires input.len() > 0     ensures          !valid_input(input@) ==> result.len() == 0,         valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),         forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',\n{\n          Vec::new() }\n       }\n        fn main() {\n      }\n", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_813.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1411, "minimize_time_ms": 311649, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 22, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 0.30985915492957744}, "labeling": {"segments": {"exec": " fn solve(input: Vec<char>) -> (result: Vec<char>)     requires input.len() > 0     ensures          !valid_input(input@) ==> result.len() == 0,         valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),         forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',\n{\n\n fn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_int(s: Seq<char>) -> int {\n\nspec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_int(s: Seq<char>) -> int {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_int(s: Seq<char>) -> int {\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_int(s: Seq<char>) -> int {\n\nspec fn parse_int(s: Seq<char>) -> int {\n\nspec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires input.len() > 0     ensures          !valid_input(input@) ==> result.len() == 0,         valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),         forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',\n{\n\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires input.len() > 0     ensures          !valid_input(input@) ==> result.len() == 0,         valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),         forall|i: int| 0 <= i < result.len() ==>        "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&\n    {\n        let n = parse_int(split_spaces(lines[0])[0]);\n        n > 0\n    }\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    let n = parse_int(split_spaces(lines[0])[0]);\n    result.len() == 2 * n - 1 &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[2*i] == '1' || result[2*i] == '2') &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[2*i+1] == ' ')\n}\n\nspec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    let n = parse_int(split_spaces(lines[0])[0]);\n    let arthur_apples = parse_int_seq(split_spaces(lines[1]));\n    let arthur_set = Set::new(|x: int| arthur_apples.contains(x));\n    forall|i: int| 1 <= i <= n ==> \n        (arthur_set.contains(i) ==> #[trigger] result[2*(i-1)] == '1') &&\n        (!arthur_set.contains(i) ==> result[2*(i-1)] == '2')\n}\n\n/* Helper functions for parsing (spec functions) */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> {\n    Seq::empty()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n    ensures \n        !valid_input(input@) ==> result.len() == 0,\n        valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool {\n          let lines = split_lines(input);\n          lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&     {\n             let n = parse_int(split_spaces(lines[0])[0]);\n             n > 0     }\n      }\n       spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_int(s: Seq<char>) -> int {\n          0 }\n       spec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires input.len() > 0     ensures          !valid_input(input@) ==> result.len() == 0,         valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),         forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',\n{\n          Vec::new() }\n       }\n        fn main() {\n      }\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd::prelude::*;\n            fn main() {\n  }\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_864_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn possible(n: int, food_types: Seq<int>, days: int) -> bool\n    recommends n >= 0, days >= 0, forall|i: int| 0 <= i < food_types.len() ==> food_types[i] >= 1\n{\n    if days == 0 { true }\n    else {\n        let total_participants = count_total_participants(food_types, days, 1);\n        total_participants >= n\n    }\n}\n\nspec fn count_total_participants(food_types: Seq<int>, days: int, current_type: int) -> int\n    recommends days >= 0, current_type >= 1\n    decreases 101 - current_type\n{\n    if current_type > 100 { 0 }\n    else {\n        let packages_of_this_type = count_packages(food_types, current_type);\n        let participants_for_this_type = if days > 0 { packages_of_this_type / days } else { 0 };\n        participants_for_this_type + count_total_participants(food_types, days, current_type + 1)\n    }\n}\n\nspec fn count_packages(food_types: Seq<int>, target_type: int) -> int\n    recommends target_type >= 1\n    decreases food_types.len()\n{\n    if food_types.len() == 0 { 0 }\n    else if food_types[0] == target_type { 1 + count_packages(food_types.subrange(1, food_types.len() as int), target_type) }\n    else { count_packages(food_types.subrange(1, food_types.len() as int), target_type) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, food_types: Vec<i8>) -> (result: i8)\n    requires 1 <= n <= 100,\n             1 <= m <= 100,\n             food_types@.len() == m as int,\n             forall|i: int| 0 <= i < food_types@.len() ==> #[trigger] food_types@[i] >= 1 && #[trigger] food_types@[i] <= 100\n    ensures result >= 0,\n            result <= m,\n            result > 0 ==> possible(n as int, food_types@.map(|i, x: i8| x as int), result as int),\n            !possible(n as int, food_types@.map(|i, x: i8| x as int), result as int + 1),\n            forall|d: int| #[trigger] possible(n as int, food_types@.map(|i, x: i8| x as int), d) ==> d <= result as int\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn possible(n: int, food_types: Seq<int>, days: int) -> bool\n    recommends n >= 0, days >= 0, forall|i: int| 0 <= i < food_types.len() ==> food_types[i] >= 1\n{\n    if days == 0 { true }\n    else {\n        let total_participants = count_total_participants(food_types, days, 1);\n        total_participants >= n\n    }\n}\n\nspec fn count_total_participants(food_types: Seq<int>, days: int, current_type: int) -> int\n    recommends days >= 0, current_type >= 1\n    decreases 101 - current_type\n{\n    if current_type > 100 { 0 }\n    else {\n        let packages_of_this_type = count_packages(food_types, current_type);\n        let participants_for_this_type = if days > 0 { packages_of_this_type / days } else { 0 };\n        participants_for_this_type + count_total_participants(food_types, days, current_type + 1)\n    }\n}\n\nspec fn count_packages(food_types: Seq<int>, target_type: int) -> int\n    recommends target_type >= 1\n    decreases food_types.len()\n{\n    if food_types.len() == 0 { 0 }\n    else if food_types[0] == target_type { 1 + count_packages(food_types.subrange(1, food_types.len() as int), target_type) }\n    else { count_packages(food_types.subrange(1, food_types.len() as int), target_type) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, food_types: Vec<i8>) -> (result: i8)\n    requires 1 <= n <= 100,\n             1 <= m <= 100,\n             food_types@.len() == m as int,\n             forall|i: int| 0 <= i < food_types@.len() ==> #[trigger] food_types@[i] >= 1 && #[trigger] food_types@[i] <= 100\n    ensures result >= 0,\n            result <= m,\n            result > 0 ==> possible(n as int, food_types@.map(|i, x: i8| x as int), result as int),\n            !possible(n as int, food_types@.map(|i, x: i8| x as int), result as int + 1),\n            forall|d: int| #[trigger] possible(n as int, food_types@.map(|i, x: i8| x as int), d) ==> d <= result as int\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_864.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1019, "verus_errors": [{"error_type": "Other", "error_text": "triggers cannot contain let/forall/exists/lambda/choose ()", "message": "VerusErrorType.Other: triggers cannot contain let/forall/exists/lambda/choose ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp0coj7anh", "lines": [51, 51], "label": null, "text": [{"text": "            forall|d: int| #[trigger] possible(n as int, food_types@.map(|i, x: i8| x as int), d) ==> d <= result as int", "highlight_start": 74, "highlight_end": 93}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn possible(n: int, food_types: Seq<int>, days: int) -> bool\n    recommends n >= 0, days >= 0, forall|i: int| 0 <= i < food_types.len() ==> food_types[i] >= 1\n{\n\nspec fn count_total_participants(food_types: Seq<int>, days: int, current_type: int) -> int\n    recommends days >= 0, current_type >= 1\n    decreases 101 - current_type\n{\n\nspec fn count_packages(food_types: Seq<int>, target_type: int) -> int\n    recommends target_type >= 1\n    decreases food_types.len()\n{\n\n    decreases 101 - current_type\n\n    decreases food_types.len()\n\n    requires 1 <= n <= 100,\n\n    ensures result >= 0,"}}}, "all_snapshots": []}
{"id": "apps_test_877_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, pairs: Seq<(int, int)>) -> bool {\n    n >= 2 && \n    m >= 0 && \n    pairs.len() == m &&\n    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 >= 1 && #[trigger] pairs[i].0 <= n && #[trigger] pairs[i].1 >= 1 && #[trigger] pairs[i].1 <= n) &&\n    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 != #[trigger] pairs[i].1)\n}\n\nspec fn compute_final_l(pairs: Seq<(int, int)>) -> int\n    decreases pairs.len()\n{\n    if pairs.len() == 0 { 1 }\n    else {\n        let x = pairs[pairs.len() - 1].0;\n        let y = pairs[pairs.len() - 1].1;\n        let min_val = if x < y { x } else { y };\n        let rest_l = compute_final_l(pairs.subrange(0, pairs.len() - 1));\n        if rest_l > min_val { rest_l } else { min_val }\n    }\n}\n\nspec fn compute_final_r(n: int, pairs: Seq<(int, int)>) -> int\n    decreases pairs.len()\n{\n    if pairs.len() == 0 { n }\n    else {\n        let x = pairs[pairs.len() - 1].0;\n        let y = pairs[pairs.len() - 1].1;\n        let max_val = if x > y { x } else { y };\n        let rest_r = compute_final_r(n, pairs.subrange(0, pairs.len() - 1));\n        if rest_r < max_val { rest_r } else { max_val }\n    }\n}\n\nspec fn max(a: int, b: int) -> int {\n    if a > b { a } else { b }\n}\n\nspec fn valid_result(n: int, pairs: Seq<(int, int)>, result: int) -> bool {\n    result >= 0 &&\n    result <= n - 1 &&\n    result == max(compute_final_r(n, pairs) - compute_final_l(pairs), 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, pairs: Vec<(i8, i8)>) -> (result: i8)\n    requires valid_input(n as int, m as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)))\n    ensures valid_result(n as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, pairs: Seq<(int, int)>) -> bool {\n    n >= 2 && \n    m >= 0 && \n    pairs.len() == m &&\n    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 >= 1 && #[trigger] pairs[i].0 <= n && #[trigger] pairs[i].1 >= 1 && #[trigger] pairs[i].1 <= n) &&\n    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 != #[trigger] pairs[i].1)\n}\n\nspec fn compute_final_l(pairs: Seq<(int, int)>) -> int\n    decreases pairs.len()\n{\n    if pairs.len() == 0 { 1 }\n    else {\n        let x = pairs[pairs.len() - 1].0;\n        let y = pairs[pairs.len() - 1].1;\n        let min_val = if x < y { x } else { y };\n        let rest_l = compute_final_l(pairs.subrange(0, pairs.len() - 1));\n        if rest_l > min_val { rest_l } else { min_val }\n    }\n}\n\nspec fn compute_final_r(n: int, pairs: Seq<(int, int)>) -> int\n    decreases pairs.len()\n{\n    if pairs.len() == 0 { n }\n    else {\n        let x = pairs[pairs.len() - 1].0;\n        let y = pairs[pairs.len() - 1].1;\n        let max_val = if x > y { x } else { y };\n        let rest_r = compute_final_r(n, pairs.subrange(0, pairs.len() - 1));\n        if rest_r < max_val { rest_r } else { max_val }\n    }\n}\n\nspec fn max(a: int, b: int) -> int {\n    if a > b { a } else { b }\n}\n\nspec fn valid_result(n: int, pairs: Seq<(int, int)>, result: int) -> bool {\n    result >= 0 &&\n    result <= n - 1 &&\n    result == max(compute_final_r(n, pairs) - compute_final_l(pairs), 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, pairs: Vec<(i8, i8)>) -> (result: i8)\n    requires valid_input(n as int, m as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)))\n    ensures valid_result(n as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_877.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 479, "verus_errors": [{"error_type": "Other", "error_text": "expected an expression ()", "message": "VerusErrorType.Other: expected an expression ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpqs1ygxqv", "lines": [55, 55], "label": null, "text": [{"text": "    requires valid_input(n as int, m as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)))", "highlight_start": 57, "highlight_end": 59}]}]}, {"error_type": "Other", "error_text": "expected an expression ()", "message": "VerusErrorType.Other: expected an expression ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpqs1ygxqv", "lines": [56, 56], "label": null, "text": [{"text": "    ensures valid_result(n as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)), result as int)", "highlight_start": 47, "highlight_end": 49}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, m: int, pairs: Seq<(int, int)>) -> bool {\n\nspec fn compute_final_l(pairs: Seq<(int, int)>) -> int\n    decreases pairs.len()\n{\n\nspec fn compute_final_r(n: int, pairs: Seq<(int, int)>) -> int\n    decreases pairs.len()\n{\n\nspec fn max(a: int, b: int) -> int {\n\nspec fn valid_result(n: int, pairs: Seq<(int, int)>, result: int) -> bool {\n\n    decreases pairs.len()\n\n    decreases pairs.len()\n\n    requires valid_input(n as int, m as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)))\n\n    ensures valid_result(n as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)), result as int)"}}}, "all_snapshots": []}
{"id": "apps_test_889_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_input_lines(input: Seq<char>) -> Seq<Seq<char>>\n{\n    split_by_newline_simple(input, 0, seq![])\n}\n\nspec fn split_by_newline_simple(input: Seq<char>, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - pos\n{\n    if pos >= input.len() {\n        acc\n    } else {\n        let next_newline = find_next_newline(input, pos);\n        if next_newline == -1 {\n            if pos < input.len() {\n                acc.push(input.subrange(pos, input.len() as int))\n            } else {\n                acc\n            }\n        } else {\n            split_by_newline_simple(input, next_newline + 1, acc.push(input.subrange(pos, next_newline)))\n        }\n    }\n}\n\nspec fn find_next_newline(input: Seq<char>, start: int) -> int\n    decreases input.len() - start\n{\n    if start >= input.len() {\n        -1\n    } else if input[start] == '\\n' {\n        start\n    } else {\n        find_next_newline(input, start + 1)\n    }\n}\n\nspec fn count_black_in_square(lines: Seq<Seq<char>>, row: int, col: int) -> int\n{\n    (if lines[row][col] == '#' { 1int } else { 0int }) +\n    (if lines[row][col + 1] == '#' { 1int } else { 0int }) +\n    (if lines[row + 1][col] == '#' { 1int } else { 0int }) +\n    (if lines[row + 1][col + 1] == '#' { 1int } else { 0int })\n}\n\nspec fn valid_grid(lines: Seq<Seq<char>>) -> bool\n{\n    lines.len() == 4 && (forall|k: int| 0 <= k < 4 ==> lines[k].len() >= 4)\n}\n\nspec fn can_make_uniform_square(lines: Seq<Seq<char>>) -> bool\n{\n    exists|i: int, j: int| 0 <= i <= 2 && 0 <= j <= 2 && \n        i + 1 < lines.len() && j + 1 < lines[i].len() && j + 1 < lines[i + 1].len() &&\n        {\n            let black_count = count_black_in_square(lines, i, j);\n            black_count >= 3 || black_count <= 1\n        }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_input_lines(input: Seq<char>) -> Seq<Seq<char>>\n{\n    split_by_newline_simple(input, 0, seq![])\n}\n\nspec fn split_by_newline_simple(input: Seq<char>, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - pos\n{\n    if pos >= input.len() {\n        acc\n    } else {\n        let next_newline = find_next_newline(input, pos);\n        if next_newline == -1 {\n            if pos < input.len() {\n                acc.push(input.subrange(pos, input.len() as int))\n            } else {\n                acc\n            }\n        } else {\n            split_by_newline_simple(input, next_newline + 1, acc.push(input.subrange(pos, next_newline)))\n        }\n    }\n}\n\nspec fn find_next_newline(input: Seq<char>, start: int) -> int\n    decreases input.len() - start\n{\n    if start >= input.len() {\n        -1\n    } else if input[start] == '\\n' {\n        start\n    } else {\n        find_next_newline(input, start + 1)\n    }\n}\n\nspec fn count_black_in_square(lines: Seq<Seq<char>>, row: int, col: int) -> int\n{\n    (if lines[row][col] == '#' { 1int } else { 0int }) +\n    (if lines[row][col + 1] == '#' { 1int } else { 0int }) +\n    (if lines[row + 1][col] == '#' { 1int } else { 0int }) +\n    (if lines[row + 1][col + 1] == '#' { 1int } else { 0int })\n}\n\nspec fn valid_grid(lines: Seq<Seq<char>>) -> bool\n{\n    lines.len() == 4 && (forall|k: int| 0 <= k < 4 ==> lines[k].len() >= 4)\n}\n\nspec fn can_make_uniform_square(lines: Seq<Seq<char>>) -> bool\n{\n    exists|i: int, j: int| 0 <= i <= 2 && 0 <= j <= 2 && \n        i + 1 < lines.len() && j + 1 < lines[i].len() && j + 1 < lines[i + 1].len() &&\n        {\n            let black_count = count_black_in_square(lines, i, j);\n            black_count >= 3 || black_count <= 1\n        }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    String::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_889.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1100, "verus_errors": [{"error_type": "Other", "error_text": "`alloc::string::impl&%0::new` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "message": "VerusErrorType.Other: `alloc::string::impl&%0::new` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp6o4rr4bf", "lines": [77, 77], "label": null, "text": [{"text": "    String::new()", "highlight_start": 5, "highlight_end": 18}]}]}, {"error_type": "Other", "error_text": "`core::str::impl&%0::len` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "message": "VerusErrorType.Other: `core::str::impl&%0::len` is not supported (note: you may be able to add a Verus specification to this function with `assume_specification`) (note: the vstd library provides some specification for the Rust std library, but it is currently limited) ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp6o4rr4bf", "lines": [71, 71], "label": null, "text": [{"text": "    requires input.len() > 0", "highlight_start": 14, "highlight_end": 25}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 84, "minimized_LOC": 84, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn parse_input_lines(input: Seq<char>) -> Seq<Seq<char>>\n{\n\nspec fn split_by_newline_simple(input: Seq<char>, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - pos\n{\n\nspec fn find_next_newline(input: Seq<char>, start: int) -> int\n    decreases input.len() - start\n{\n\nspec fn count_black_in_square(lines: Seq<Seq<char>>, row: int, col: int) -> int\n{\n\nspec fn valid_grid(lines: Seq<Seq<char>>) -> bool\n{\n\nspec fn can_make_uniform_square(lines: Seq<Seq<char>>) -> bool\n{\n\n    decreases input.len() - pos\n\n    decreases input.len() - start\n\n    requires input.len() > 0\n\n    ensures result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']"}}}, "all_snapshots": []}
{"id": "apps_test_901_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn split_lines(s: &str) -> Seq<&str>\n{\n    if s.len() == 0 { seq![] } else { seq![s] }\n}\n\nspec fn split_ints(s: &str) -> Seq<int>\n{\n    seq![]\n}\n\nspec fn seq_to_set(s: Seq<int>) -> Set<int>\n{\n    s.to_set()\n}\n\nspec fn is_dangerous_group(group_data: Seq<int>) -> bool\n{\n    if group_data.len() <= 1 { \n        false \n    } else {\n        let group_members = group_data.subrange(1, group_data.len() as int);\n        let member_set = seq_to_set(group_members);\n        forall|member: int| member_set.contains(member) ==> !member_set.contains(-member)\n    }\n}\n\nspec fn exists_dangerous_group(stdin_input: &str) -> bool\n{\n    let lines = split_lines(stdin_input);\n    if lines.len() == 0 { \n        false \n    } else {\n        let first_line = split_ints(lines[0]);\n        if first_line.len() < 2 { \n            false \n        } else {\n            let n = first_line[0];\n            let m = first_line[1];\n            if m <= 0 || n <= 0 { \n                false \n            } else {\n                exists|i: int| 1 <= i <= m && i < lines.len() && \n                    is_dangerous_group(split_ints(lines[i]))\n            }\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0\n    ensures (result == \"YES\\n\") || (result == \"NO\\n\")\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn split_lines(s: &str) -> Seq<&str>\n{\n    if s.len() == 0 { seq![] } else { seq![s] }\n}\n\nspec fn split_ints(s: &str) -> Seq<int>\n{\n    seq![]\n}\n\nspec fn seq_to_set(s: Seq<int>) -> Set<int>\n{\n    s.to_set()\n}\n\nspec fn is_dangerous_group(group_data: Seq<int>) -> bool\n{\n    if group_data.len() <= 1 { \n        false \n    } else {\n        let group_members = group_data.subrange(1, group_data.len() as int);\n        let member_set = seq_to_set(group_members);\n        forall|member: int| member_set.contains(member) ==> !member_set.contains(-member)\n    }\n}\n\nspec fn exists_dangerous_group(stdin_input: &str) -> bool\n{\n    let lines = split_lines(stdin_input);\n    if lines.len() == 0 { \n        false \n    } else {\n        let first_line = split_ints(lines[0]);\n        if first_line.len() < 2 { \n            false \n        } else {\n            let n = first_line[0];\n            let m = first_line[1];\n            if m <= 0 || n <= 0 { \n                false \n            } else {\n                exists|i: int| 1 <= i <= m && i < lines.len() && \n                    is_dangerous_group(split_ints(lines[i]))\n            }\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0\n    ensures (result == \"YES\\n\") || (result == \"NO\\n\")\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\\n\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_901.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 831, "verus_errors": [{"error_type": "MismatchedType", "error_text": "mismatched types; types must be compatible to use == or != (this is `alloc::string::String`; this is `StrSlice`)", "message": "VerusErrorType.MismatchedType: mismatched types; types must be compatible to use == or != (this is `alloc::string::String`; this is `StrSlice`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpjd7236l_", "lines": [60, 60], "label": "this is `alloc::string::String`", "text": [{"text": "    ensures (result == \"YES\\n\") || (result == \"NO\\n\")", "highlight_start": 14, "highlight_end": 20}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpjd7236l_", "lines": [60, 60], "label": "this is `StrSlice`", "text": [{"text": "    ensures (result == \"YES\\n\") || (result == \"NO\\n\")", "highlight_start": 24, "highlight_end": 31}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpjd7236l_", "lines": [60, 60], "label": null, "text": [{"text": "    ensures (result == \"YES\\n\") || (result == \"NO\\n\")", "highlight_start": 13, "highlight_end": 32}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 72, "minimized_LOC": 72, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn main() {", "spec": "spec fn split_lines(s: &str) -> Seq<&str>\n{\n\nspec fn split_ints(s: &str) -> Seq<int>\n{\n\nspec fn seq_to_set(s: Seq<int>) -> Set<int>\n{\n\nspec fn is_dangerous_group(group_data: Seq<int>) -> bool\n{\n\nspec fn exists_dangerous_group(stdin_input: &str) -> bool\n{\n\n    requires stdin_input.len() > 0\n\n    ensures (result == \"YES\\n\") || (result == \"NO\\n\")"}}}, "all_snapshots": []}
{"id": "apps_test_911_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, c: int, p: Seq<int>, t: Seq<int>) -> bool {\n    n > 0 && c > 0 && p.len() == n && t.len() == n &&\n    (forall|i: int| 0 <= i < n ==> p[i] > 0) &&\n    (forall|i: int| 0 <= i < n ==> t[i] > 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> p[i] < p[i+1]) &&\n    (forall|i: int| 0 <= i < n-1 ==> t[i] < t[i+1])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { s[0] + sum_seq(s.drop_first()) }\n}\n\nspec fn calculate_limak_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int\n    requires n > 0 && p.len() == n && t.len() == n\n    decreases n\n{\n    if n == 0 { 0 }\n    else { \n        let cumulative_time = sum_seq(t.take(1));\n        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };\n        score + calculate_limak_score_helper(n-1, c, p.skip(1), t.skip(1), cumulative_time)\n    }\n}\n\nspec fn calculate_limak_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int\n    requires remaining >= 0 && p.len() == remaining && t.len() == remaining\n    decreases remaining\n{\n    if remaining == 0 { 0 }\n    else { \n        let cumulative_time = prev_time + t[0];\n        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };\n        score + calculate_limak_score_helper(remaining-1, c, p.skip(1), t.skip(1), cumulative_time)\n    }\n}\n\nspec fn calculate_radewoosh_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int\n    requires n > 0 && p.len() == n && t.len() == n\n{\n    calculate_radewoosh_score_helper(n, c, p, t, 0)\n}\n\nspec fn calculate_radewoosh_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int\n    requires remaining >= 0 && p.len() >= remaining && t.len() >= remaining\n    decreases remaining\n{\n    if remaining == 0 { 0 }\n    else { \n        let idx = remaining - 1;\n        let cumulative_time = prev_time + t[idx];\n        let score = if p[idx] - c * cumulative_time > 0 { p[idx] - c * cumulative_time } else { 0 };\n        score + calculate_radewoosh_score_helper(remaining-1, c, p, t, cumulative_time)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, c: int, p: Seq<int>, t: Seq<int>) -> (result: String)\n    requires valid_input(n, c, p, t)\n    ensures result == \"Limak\" || result == \"Radewoosh\" || result == \"Tie\"\n    ensures {\n            let limak_score = calculate_limak_score(n, c, p, t);\n            let radewoosh_score = calculate_radewoosh_score(n, c, p, t);\n            (result == \"Limak\") == (limak_score > radewoosh_score) &&\n            (result == \"Radewoosh\") == (limak_score < radewoosh_score) &&\n            (result == \"Tie\") == (limak_score == radewoosh_score)\n    }\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, c: int, p: Seq<int>, t: Seq<int>) -> bool {\n    n > 0 && c > 0 && p.len() == n && t.len() == n &&\n    (forall|i: int| 0 <= i < n ==> p[i] > 0) &&\n    (forall|i: int| 0 <= i < n ==> t[i] > 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> p[i] < p[i+1]) &&\n    (forall|i: int| 0 <= i < n-1 ==> t[i] < t[i+1])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { s[0] + sum_seq(s.drop_first()) }\n}\n\nspec fn calculate_limak_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int\n    requires n > 0 && p.len() == n && t.len() == n\n    decreases n\n{\n    if n == 0 { 0 }\n    else { \n        let cumulative_time = sum_seq(t.take(1));\n        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };\n        score + calculate_limak_score_helper(n-1, c, p.skip(1), t.skip(1), cumulative_time)\n    }\n}\n\nspec fn calculate_limak_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int\n    requires remaining >= 0 && p.len() == remaining && t.len() == remaining\n    decreases remaining\n{\n    if remaining == 0 { 0 }\n    else { \n        let cumulative_time = prev_time + t[0];\n        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };\n        score + calculate_limak_score_helper(remaining-1, c, p.skip(1), t.skip(1), cumulative_time)\n    }\n}\n\nspec fn calculate_radewoosh_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int\n    requires n > 0 && p.len() == n && t.len() == n\n{\n    calculate_radewoosh_score_helper(n, c, p, t, 0)\n}\n\nspec fn calculate_radewoosh_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int\n    requires remaining >= 0 && p.len() >= remaining && t.len() >= remaining\n    decreases remaining\n{\n    if remaining == 0 { 0 }\n    else { \n        let idx = remaining - 1;\n        let cumulative_time = prev_time + t[idx];\n        let score = if p[idx] - c * cumulative_time > 0 { p[idx] - c * cumulative_time } else { 0 };\n        score + calculate_radewoosh_score_helper(remaining-1, c, p, t, cumulative_time)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: int, c: int, p: Seq<int>, t: Seq<int>) -> (result: String)\n    requires valid_input(n, c, p, t)\n    ensures result == \"Limak\" || result == \"Radewoosh\" || result == \"Tie\"\n    ensures {\n            let limak_score = calculate_limak_score(n, c, p, t);\n            let radewoosh_score = calculate_radewoosh_score(n, c, p, t);\n            (result == \"Limak\") == (limak_score > radewoosh_score) &&\n            (result == \"Radewoosh\") == (limak_score < radewoosh_score) &&\n            (result == \"Tie\") == (limak_score == radewoosh_score)\n    }\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_911.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 322, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpmhto2ony", "lines": [72, 72], "label": null, "text": [{"text": "    ensures {", "highlight_start": 5, "highlight_end": 12}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 92, "minimized_LOC": 92, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, c: int, p: Seq<int>, t: Seq<int>) -> bool {\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n\nspec fn calculate_limak_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int\n    requires n > 0 && p.len() == n && t.len() == n\n    decreases n\n{\n\nspec fn calculate_limak_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int\n    requires remaining >= 0 && p.len() == remaining && t.len() == remaining\n    decreases remaining\n{\n\nspec fn calculate_radewoosh_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int\n    requires n > 0 && p.len() == n && t.len() == n\n{\n\nspec fn calculate_radewoosh_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int\n    requires remaining >= 0 && p.len() >= remaining && t.len() >= remaining\n    decreases remaining\n{\n\n    decreases s.len()\n\n    requires n > 0 && p.len() == n && t.len() == n\n\n    decreases n\n\n    requires remaining >= 0 && p.len() == remaining && t.len() == remaining\n\n    decreases remaining\n\n    requires n > 0 && p.len() == n && t.len() == n\n\n    requires remaining >= 0 && p.len() >= remaining && t.len() >= remaining\n\n    decreases remaining\n\n    requires valid_input(n, c, p, t)\n\n    ensures result == \"Limak\" || result == \"Radewoosh\" || result == \"Tie\"\n\n    ensures {"}}}, "all_snapshots": []}
{"id": "apps_test_93_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_newlines(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == '\\n' { 1int } else { 0int }) + count_newlines(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n') && count_newlines(input) >= 3\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    /* Implementation details for splitting lines */\n    seq![seq![]]\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char> {\n    s.reverse()\n}\n\nspec fn remove_first_x(s: Seq<char>) -> Seq<char> {\n    /* Implementation details for removing first X */\n    s\n}\n\nspec fn extract_and_normalize_puzzle1(input: Seq<char>) -> Seq<char> {\n    if valid_input(input) {\n        let lines = split_lines(input);\n        if lines.len() >= 2 {\n            let line1 = lines[0];\n            let line2 = reverse_seq(lines[1]);\n            let combined = line1.add(line2);\n            remove_first_x(combined)\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn extract_and_normalize_puzzle2(input: Seq<char>) -> Seq<char> {\n    if valid_input(input) {\n        let lines = split_lines(input);\n        if lines.len() >= 4 {\n            let line3 = lines[2];\n            let line4 = reverse_seq(lines[3]);\n            let combined = line3.add(line4);\n            remove_first_x(combined)\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn rotate_puzzle_left(puzzle: Seq<char>, rotation: int) -> Seq<char> {\n    /* Implementation details for rotating puzzle */\n    puzzle\n}\n\nspec fn can_reach_same_config(input: Seq<char>) -> bool {\n    if valid_input(input) {\n        exists|rotation: int| 0 <= rotation < 4 && \n            extract_and_normalize_puzzle1(input) == rotate_puzzle_left(extract_and_normalize_puzzle2(input), rotation)\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    ensures can_reach_same_config(input@) ==> result@ == seq!['Y', 'E', 'S']\n    ensures !can_reach_same_config(input@) ==> result@ == seq!['N', 'O']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_newlines(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == '\\n' { 1int } else { 0int }) + count_newlines(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n') && count_newlines(input) >= 3\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    /* Implementation details for splitting lines */\n    seq![seq![]]\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char> {\n    s.reverse()\n}\n\nspec fn remove_first_x(s: Seq<char>) -> Seq<char> {\n    /* Implementation details for removing first X */\n    s\n}\n\nspec fn extract_and_normalize_puzzle1(input: Seq<char>) -> Seq<char> {\n    if valid_input(input) {\n        let lines = split_lines(input);\n        if lines.len() >= 2 {\n            let line1 = lines[0];\n            let line2 = reverse_seq(lines[1]);\n            let combined = line1.add(line2);\n            remove_first_x(combined)\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn extract_and_normalize_puzzle2(input: Seq<char>) -> Seq<char> {\n    if valid_input(input) {\n        let lines = split_lines(input);\n        if lines.len() >= 4 {\n            let line3 = lines[2];\n            let line4 = reverse_seq(lines[3]);\n            let combined = line3.add(line4);\n            remove_first_x(combined)\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn rotate_puzzle_left(puzzle: Seq<char>, rotation: int) -> Seq<char> {\n    /* Implementation details for rotating puzzle */\n    puzzle\n}\n\nspec fn can_reach_same_config(input: Seq<char>) -> bool {\n    if valid_input(input) {\n        exists|rotation: int| 0 <= rotation < 4 && \n            extract_and_normalize_puzzle1(input) == rotate_puzzle_left(extract_and_normalize_puzzle2(input), rotation)\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    ensures can_reach_same_config(input@) ==> result@ == seq!['Y', 'E', 'S']\n    ensures !can_reach_same_config(input@) ==> result@ == seq!['N', 'O']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_93.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 318, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpsz00e8m_", "lines": [86, 86], "label": null, "text": [{"text": "    ensures !can_reach_same_config(input@) ==> result@ == seq!['N', 'O']", "highlight_start": 5, "highlight_end": 12}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 100, "minimized_LOC": 100, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn count_newlines(s: Seq<char>) -> int\n    decreases s.len()\n{\n\nspec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char> {\n\nspec fn remove_first_x(s: Seq<char>) -> Seq<char> {\n\nspec fn extract_and_normalize_puzzle1(input: Seq<char>) -> Seq<char> {\n\nspec fn extract_and_normalize_puzzle2(input: Seq<char>) -> Seq<char> {\n\nspec fn rotate_puzzle_left(puzzle: Seq<char>, rotation: int) -> Seq<char> {\n\nspec fn can_reach_same_config(input: Seq<char>) -> bool {\n\n    decreases s.len()\n\n    ensures can_reach_same_config(input@) ==> result@ == seq!['Y', 'E', 'S']\n\n    ensures !can_reach_same_config(input@) ==> result@ == seq!['N', 'O']"}}}, "all_snapshots": []}
{"id": "apps_test_95_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, arr: Seq<int>) -> bool {\n    n > 0 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn is_unimodal(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 { \n        true \n    } else {\n        let phases = compute_phases(arr);\n        phases.0 <= phases.1 && phases.1 <= phases.2 && phases.2 == arr.len() &&\n        (forall|i: int, j: int| 0 <= i < j < phases.0 ==> #[trigger] arr[i] < #[trigger] arr[j]) &&\n        (forall|i: int| phases.0 <= i < phases.1 ==> #[trigger] arr[i] == (if phases.0 > 0 { arr[phases.0] } else { arr[0] })) &&\n        (forall|i: int, j: int| phases.1 <= i < j < phases.2 ==> #[trigger] arr[i] > #[trigger] arr[j]) &&\n        (phases.0 > 0 && phases.1 < arr.len() ==> arr[phases.0-1] >= (if phases.1 > phases.0 { arr[phases.0] } else { arr[phases.1] }))\n    }\n}\n\nspec fn compute_phases(arr: Seq<int>) -> (int, int, int) {\n    let inc_end = compute_increasing_end(arr, 0, 0);\n    let const_end = compute_constant_end(arr, inc_end, if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    let dec_end = compute_decreasing_end(arr, const_end, if const_end > inc_end { arr[inc_end] } else if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    (inc_end, const_end, dec_end)\n}\n\nspec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    0\n}\n\nspec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {\n    start\n}\n\nspec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    arr.len() as int\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: nat, arr: Seq<int>) -> (result: String)\n    requires \n        valid_input(n, arr),\n    ensures \n        result@ == \"YES\"@ || result@ == \"NO\"@,\n        result@ == \"YES\"@ <==> is_unimodal(arr),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, arr: Seq<int>) -> bool {\n    n > 0 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn is_unimodal(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 { \n        true \n    } else {\n        let phases = compute_phases(arr);\n        phases.0 <= phases.1 && phases.1 <= phases.2 && phases.2 == arr.len() &&\n        (forall|i: int, j: int| 0 <= i < j < phases.0 ==> #[trigger] arr[i] < #[trigger] arr[j]) &&\n        (forall|i: int| phases.0 <= i < phases.1 ==> #[trigger] arr[i] == (if phases.0 > 0 { arr[phases.0] } else { arr[0] })) &&\n        (forall|i: int, j: int| phases.1 <= i < j < phases.2 ==> #[trigger] arr[i] > #[trigger] arr[j]) &&\n        (phases.0 > 0 && phases.1 < arr.len() ==> arr[phases.0-1] >= (if phases.1 > phases.0 { arr[phases.0] } else { arr[phases.1] }))\n    }\n}\n\nspec fn compute_phases(arr: Seq<int>) -> (int, int, int) {\n    let inc_end = compute_increasing_end(arr, 0, 0);\n    let const_end = compute_constant_end(arr, inc_end, if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    let dec_end = compute_decreasing_end(arr, const_end, if const_end > inc_end { arr[inc_end] } else if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    (inc_end, const_end, dec_end)\n}\n\nspec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    0\n}\n\nspec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {\n    start\n}\n\nspec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    arr.len() as int\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: nat, arr: Seq<int>) -> (result: String)\n    requires \n        valid_input(n, arr),\n    ensures \n        result@ == \"YES\"@ || result@ == \"NO\"@,\n        result@ == \"YES\"@ <==> is_unimodal(arr),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_95.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1247, "minimize_time_ms": 278826, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: nat, arr: Seq<int>) -> bool {\n\nspec fn is_unimodal(arr: Seq<int>) -> bool {\n\nspec fn compute_phases(arr: Seq<int>) -> (int, int, int) {\n\nspec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n\nspec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {\n\nspec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, arr: Seq<int>) -> bool {\n    n > 0 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn is_unimodal(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 { \n        true \n    } else {\n        let phases = compute_phases(arr);\n        phases.0 <= phases.1 && phases.1 <= phases.2 && phases.2 == arr.len() &&\n        (forall|i: int, j: int| 0 <= i < j < phases.0 ==> #[trigger] arr[i] < #[trigger] arr[j]) &&\n        (forall|i: int| phases.0 <= i < phases.1 ==> #[trigger] arr[i] == (if phases.0 > 0 { arr[phases.0] } else { arr[0] })) &&\n        (forall|i: int, j: int| phases.1 <= i < j < phases.2 ==> #[trigger] arr[i] > #[trigger] arr[j]) &&\n        (phases.0 > 0 && phases.1 < arr.len() ==> arr[phases.0-1] >= (if phases.1 > phases.0 { arr[phases.0] } else { arr[phases.1] }))\n    }\n}\n\nspec fn compute_phases(arr: Seq<int>) -> (int, int, int) {\n    let inc_end = compute_increasing_end(arr, 0, 0);\n    let const_end = compute_constant_end(arr, inc_end, if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    let dec_end = compute_decreasing_end(arr, const_end, if const_end > inc_end { arr[inc_end] } else if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    (inc_end, const_end, dec_end)\n}\n\nspec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    0\n}\n\nspec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {\n    start\n}\n\nspec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    arr.len() as int\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: nat, arr: Seq<int>) -> (result: String)\n    requires \n        valid_input(n, arr),\n    ensures \n        result@ == \"YES\"@ || result@ == \"NO\"@,\n        result@ == \"YES\"@ <==> is_unimodal(arr),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    \"NO\".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_966_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(y: int) -> bool {\n    1000 <= y <= 9000\n}\n\nspec fn has_distinct_digits(n: int) -> bool {\n    let digits = number_to_digits(n);\n    all_distinct(digits)\n}\n\nspec fn number_to_digits(n: int) -> Seq<int> {\n    if n == 0 { seq![0] }\n    else if n > 0 { number_to_digits_helper(n, seq![]) }\n    else { number_to_digits_helper(-n, seq![]) }\n}\n\nspec fn number_to_digits_helper(n: int, acc: Seq<int>) -> Seq<int>\n    decreases n when n >= 0\n{\n    if n == 0 { acc }\n    else { number_to_digits_helper(n / 10, seq![n % 10].add(acc)) }\n}\n\nspec fn all_distinct(digits: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < digits.len() ==> digits[i] != digits[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(y: i8) -> (result: i8)\n    requires valid_input(y as int)\n    ensures \n        result as int > y as int,\n        has_distinct_digits(result as int),\n        forall|n: int| y as int < n && n < result as int ==> !has_distinct_digits(n)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(y: int) -> bool {\n    1000 <= y <= 9000\n}\n\nspec fn has_distinct_digits(n: int) -> bool {\n    let digits = number_to_digits(n);\n    all_distinct(digits)\n}\n\nspec fn number_to_digits(n: int) -> Seq<int> {\n    if n == 0 { seq![0] }\n    else if n > 0 { number_to_digits_helper(n, seq![]) }\n    else { number_to_digits_helper(-n, seq![]) }\n}\n\nspec fn number_to_digits_helper(n: int, acc: Seq<int>) -> Seq<int>\n    decreases n when n >= 0\n{\n    if n == 0 { acc }\n    else { number_to_digits_helper(n / 10, seq![n % 10].add(acc)) }\n}\n\nspec fn all_distinct(digits: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < digits.len() ==> digits[i] != digits[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(y: i8) -> (result: i8)\n    requires valid_input(y as int)\n    ensures \n        result as int > y as int,\n        has_distinct_digits(result as int),\n        forall|n: int| y as int < n && n < result as int ==> !has_distinct_digits(n)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_966.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 455, "verus_errors": [{"error_type": "Other", "error_text": "expected `,` ()", "message": "VerusErrorType.Other: expected `,` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpl1jmybxy", "lines": [42, 42], "label": null, "text": [{"text": "        forall|n: int| y as int < n && n < result as int ==> !has_distinct_digits(n)", "highlight_start": 37, "highlight_end": 38}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(y: int) -> bool {\n\nspec fn has_distinct_digits(n: int) -> bool {\n\nspec fn number_to_digits(n: int) -> Seq<int> {\n\nspec fn number_to_digits_helper(n: int, acc: Seq<int>) -> Seq<int>\n    decreases n when n >= 0\n{\n\nspec fn all_distinct(digits: Seq<int>) -> bool {\n\n    decreases n when n >= 0\n\n    requires valid_input(y as int)\n\n    ensures "}}}, "all_snapshots": []}
{"id": "apps_test_98_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let board_parts = split_spaces_func(lines[0]);\n        let paint1_parts = split_spaces_func(lines[1]);\n        let paint2_parts = split_spaces_func(lines[2]);\n        board_parts.len() >= 2 && paint1_parts.len() >= 2 && paint2_parts.len() >= 2 &&\n        is_valid_int(board_parts[0]) && is_valid_int(board_parts[1]) &&\n        is_valid_int(paint1_parts[0]) && is_valid_int(paint1_parts[1]) &&\n        is_valid_int(paint2_parts[0]) && is_valid_int(paint2_parts[1])\n    }\n}\n\nspec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    (c+e <= a && max(d,f) <= b) ||\n    (c+e <= b && max(d,f) <= a) ||\n    (c+f <= a && max(d,e) <= b) ||\n    (c+f <= b && max(d,e) <= a) ||\n    (d+e <= a && max(c,f) <= b) ||\n    (d+e <= b && max(c,f) <= a) ||\n    (d+f <= a && max(c,e) <= b) ||\n    (d+f <= b && max(c,e) <= a)\n}\n\nspec fn max(x: int, y: int) -> int {\n    if x >= y { x } else { y }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']; 3]\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1']; 2]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let board_parts = split_spaces_func(lines[0]);\n        let paint1_parts = split_spaces_func(lines[1]);\n        let paint2_parts = split_spaces_func(lines[2]);\n        board_parts.len() >= 2 && paint1_parts.len() >= 2 && paint2_parts.len() >= 2 &&\n        is_valid_int(board_parts[0]) && is_valid_int(board_parts[1]) &&\n        is_valid_int(paint1_parts[0]) && is_valid_int(paint1_parts[1]) &&\n        is_valid_int(paint2_parts[0]) && is_valid_int(paint2_parts[1])\n    }\n}\n\nspec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    (c+e <= a && max(d,f) <= b) ||\n    (c+e <= b && max(d,f) <= a) ||\n    (c+f <= a && max(d,e) <= b) ||\n    (c+f <= b && max(d,e) <= a) ||\n    (d+e <= a && max(c,f) <= b) ||\n    (d+e <= b && max(c,f) <= a) ||\n    (d+f <= a && max(c,e) <= b) ||\n    (d+f <= b && max(c,e) <= a)\n}\n\nspec fn max(x: int, y: int) -> int {\n    if x >= y { x } else { y }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']; 3]\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1']; 2]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_98.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1853, "minimize_time_ms": 221255, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 71, "minimized_LOC": 71, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(input: Seq<char>) -> bool {\n\nspec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n\nspec fn max(x: int, y: int) -> int {\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n\n    requires input.len() > 0"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let board_parts = split_spaces_func(lines[0]);\n        let paint1_parts = split_spaces_func(lines[1]);\n        let paint2_parts = split_spaces_func(lines[2]);\n        board_parts.len() >= 2 && paint1_parts.len() >= 2 && paint2_parts.len() >= 2 &&\n        is_valid_int(board_parts[0]) && is_valid_int(board_parts[1]) &&\n        is_valid_int(paint1_parts[0]) && is_valid_int(paint1_parts[1]) &&\n        is_valid_int(paint2_parts[0]) && is_valid_int(paint2_parts[1])\n    }\n}\n\nspec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    (c+e <= a && max(d,f) <= b) ||\n    (c+e <= b && max(d,f) <= a) ||\n    (c+f <= a && max(d,e) <= b) ||\n    (c+f <= b && max(d,e) <= a) ||\n    (d+e <= a && max(c,f) <= b) ||\n    (d+e <= b && max(c,f) <= a) ||\n    (d+f <= a && max(c,e) <= b) ||\n    (d+f <= b && max(c,e) <= a)\n}\n\nspec fn max(x: int, y: int) -> int {\n    if x >= y { x } else { y }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']; 3]\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1']; 2]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        fn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "apps_test_992_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n    n >= 1 && n <= 3000 &&\n    s >= 1 && s <= 3000 &&\n    a.len() == n &&\n    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nspec fn compute_subset_sum_ways(n: int, s: int, a: Seq<int>) -> int {\n    let dp = compute_dp_table(n, s, a);\n    if dp.len() > n && dp[n].len() > s { dp[n][s] } else { 0 }\n}\n\nspec fn compute_dp_table(n: int, s: int, a: Seq<int>) -> Seq<Seq<int>>\n    decreases n\n{\n    if n == 1 {\n        let base = Seq::new(s+1, |j: int| if j == 0 { 1 } else { 0 });\n        let new_row = Seq::new(s+1, |j: int| {\n            let doubled = (base[j] * 2) % 998244353;\n            if j >= a[0] && j - a[0] >= 0 && j - a[0] < s+1 { \n                (doubled + base[j - a[0]]) % 998244353\n            } else { \n                doubled\n            }\n        });\n        seq![base, new_row]\n    } else {\n        let prev_dp = compute_dp_table(n-1, s, a.subrange(0, n-1));\n        let new_row = Seq::new(s+1, |j: int| {\n            let doubled = (prev_dp[n-1][j] * 2) % 998244353;\n            if j >= a[n-1] && j - a[n-1] >= 0 && j - a[n-1] < s+1 {\n                (doubled + prev_dp[n-1][j - a[n-1]]) % 998244353\n            } else {\n                doubled\n            }\n        });\n        prev_dp.push(new_row)\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![], seq![]]\n}\n\nspec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn valid_parsed_input(input: Seq<char>, n: int, s: int, a: Seq<int>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && {\n        let first_line = split_whitespace(lines[0]);\n        let second_line = split_whitespace(lines[1]);\n        first_line.len() >= 2 && second_line.len() == n &&\n        n == string_to_int(first_line[0]) &&\n        s == string_to_int(first_line[1]) &&\n        a.len() == n &&\n        (forall|i: int| 0 <= i < n ==> (a[i] == string_to_int(second_line[i]))) &&\n        valid_input(n, s, a)\n    }\n}\n\nspec fn valid_parsed_input_exists(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() < 2 {\n        false\n    } else {\n        let first_line = split_whitespace(lines[0]);\n        let second_line = split_whitespace(lines[1]);\n        if first_line.len() < 2 || second_line.len() == 0 {\n            false\n        } else {\n            let n = string_to_int(first_line[0]);\n            let s = string_to_int(first_line[1]);\n            n >= 1 && n <= 3000 && s >= 1 && s <= 3000 && second_line.len() == n &&\n            forall|i: int| 0 <= i < n ==> {\n                let ai = string_to_int(second_line[i]);\n                ai >= 1 && ai <= 3000\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input.len() > 0,\n    ensures\n        result.len() > 0,\n    ensures\n        result.as_bytes()[result.len()-1] == 10u8\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"0\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n    n >= 1 && n <= 3000 &&\n    s >= 1 && s <= 3000 &&\n    a.len() == n &&\n    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nspec fn compute_subset_sum_ways(n: int, s: int, a: Seq<int>) -> int {\n    let dp = compute_dp_table(n, s, a);\n    if dp.len() > n && dp[n].len() > s { dp[n][s] } else { 0 }\n}\n\nspec fn compute_dp_table(n: int, s: int, a: Seq<int>) -> Seq<Seq<int>>\n    decreases n\n{\n    if n == 1 {\n        let base = Seq::new(s+1, |j: int| if j == 0 { 1 } else { 0 });\n        let new_row = Seq::new(s+1, |j: int| {\n            let doubled = (base[j] * 2) % 998244353;\n            if j >= a[0] && j - a[0] >= 0 && j - a[0] < s+1 { \n                (doubled + base[j - a[0]]) % 998244353\n            } else { \n                doubled\n            }\n        });\n        seq![base, new_row]\n    } else {\n        let prev_dp = compute_dp_table(n-1, s, a.subrange(0, n-1));\n        let new_row = Seq::new(s+1, |j: int| {\n            let doubled = (prev_dp[n-1][j] * 2) % 998244353;\n            if j >= a[n-1] && j - a[n-1] >= 0 && j - a[n-1] < s+1 {\n                (doubled + prev_dp[n-1][j - a[n-1]]) % 998244353\n            } else {\n                doubled\n            }\n        });\n        prev_dp.push(new_row)\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![], seq![]]\n}\n\nspec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn valid_parsed_input(input: Seq<char>, n: int, s: int, a: Seq<int>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && {\n        let first_line = split_whitespace(lines[0]);\n        let second_line = split_whitespace(lines[1]);\n        first_line.len() >= 2 && second_line.len() == n &&\n        n == string_to_int(first_line[0]) &&\n        s == string_to_int(first_line[1]) &&\n        a.len() == n &&\n        (forall|i: int| 0 <= i < n ==> (a[i] == string_to_int(second_line[i]))) &&\n        valid_input(n, s, a)\n    }\n}\n\nspec fn valid_parsed_input_exists(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() < 2 {\n        false\n    } else {\n        let first_line = split_whitespace(lines[0]);\n        let second_line = split_whitespace(lines[1]);\n        if first_line.len() < 2 || second_line.len() == 0 {\n            false\n        } else {\n            let n = string_to_int(first_line[0]);\n            let s = string_to_int(first_line[1]);\n            n >= 1 && n <= 3000 && s >= 1 && s <= 3000 && second_line.len() == n &&\n            forall|i: int| 0 <= i < n ==> {\n                let ai = string_to_int(second_line[i]);\n                ai >= 1 && ai <= 3000\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input.len() > 0,\n    ensures\n        result.len() > 0,\n    ensures\n        result.as_bytes()[result.len()-1] == 10u8\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    \"0\\n\".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_992.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 380, "verus_errors": [{"error_type": "Other", "error_text": "expected curly braces ()", "message": "VerusErrorType.Other: expected curly braces ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmppr5iemc7", "lines": [107, 107], "label": null, "text": [{"text": "    ensures", "highlight_start": 5, "highlight_end": 12}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 122, "minimized_LOC": 122, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n\nspec fn compute_subset_sum_ways(n: int, s: int, a: Seq<int>) -> int {\n\nspec fn compute_dp_table(n: int, s: int, a: Seq<int>) -> Seq<Seq<int>>\n    decreases n\n{\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {\n\nspec fn string_to_int(s: Seq<char>) -> int {\n\nspec fn int_to_string(n: int) -> Seq<char> {\n\nspec fn valid_parsed_input(input: Seq<char>, n: int, s: int, a: Seq<int>) -> bool {\n\nspec fn valid_parsed_input_exists(input: Seq<char>) -> bool {\n\n    decreases n\n\n    requires\n\n    ensures\n\n    ensures"}}}, "all_snapshots": []}
{"id": "bignum_Add_NormalizeBitString_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn add(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(s1@) && valid_bit_string(s2@),\n  ensures \n    valid_bit_string(res@),\n    str2int(res@) == str2int(s1@) + str2int(s2@),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn add(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(s1@) && valid_bit_string(s2@),\n  ensures \n    valid_bit_string(res@),\n    str2int(res@) == str2int(s1@) + str2int(s2@),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_Add_NormalizeBitString.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 2545, "minimize_time_ms": 220234, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  ensures \n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn add(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(s1@) && valid_bit_string(s2@),\n  ensures \n    valid_bit_string(res@),\n    str2int(res@) == str2int(s1@) + str2int(s2@),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        fn main() {}\n", "use vstd::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_Compare_CompareUnequal_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + \n    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len()\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n    str2int(s1@) < str2int(s2@) ==> res == -1,\n    str2int(s1@) == str2int(s2@) ==> res == 0,\n    str2int(s1@) > str2int(s2@) ==> res == 1\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + \n    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len()\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n    str2int(s1@) < str2int(s2@) ==> res == -1,\n    str2int(s1@) == str2int(s2@) ==> res == 0,\n    str2int(s1@) > str2int(s2@) ==> res == 1\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_Compare_CompareUnequal.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 2289, "minimize_time_ms": 219050, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len()\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  requires \n\n  ensures \n\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n\n  ensures \n\n  decreases str2int(s1@) + str2int(s2@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + \n    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len()\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n    str2int(s1@) < str2int(s2@) ==> res == -1,\n    str2int(s1@) == str2int(s2@) ==> res == 0,\n    str2int(s1@) > str2int(s2@) ==> res == 1\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_Compare_CompareUnequal_NormalizeBitString_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1 as int)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures\n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires\n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len(),\n  ensures\n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1,\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures\n    str2int(s1@) < str2int(s2@) ==> res == -1,\n    str2int(s1@) == str2int(s2@) ==> res == 0,\n    str2int(s1@) > str2int(s2@) ==> res == 1,\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1 as int)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures\n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires\n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len(),\n  ensures\n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1,\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures\n    str2int(s1@) < str2int(s2@) ==> res == -1,\n    str2int(s1@) == str2int(s2@) ==> res == 0,\n    str2int(s1@) > str2int(s2@) ==> res == 1,\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_Compare_CompareUnequal_NormalizeBitString.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 2252, "minimize_time_ms": 184191, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 68, "minimized_LOC": 68, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 12, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures\n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires\n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len(),\n  ensures\n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1,\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\n  decreases s.len()\n\n  ensures\n\n  requires\n\n  ensures\n\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n\n  ensures\n\n  decreases str2int(s1@) + str2int(s2@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1 as int)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures\n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires\n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len(),\n  ensures\n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1,\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures\n    str2int(s1@) < str2int(s2@) ==> res == -1,\n    str2int(s1@) == str2int(s2@) ==> res == 0,\n    str2int(s1@) > str2int(s2@) ==> res == 1,\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_Compare_NormalizeBitString_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n      0nat\n  } else {\n      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n      valid_bit_string(t) &&\n      t.len() > 0 &&\n      (t.len() > 1 ==> t[0] != '0') &&\n      (valid_bit_string(s) ==> str2int(s) == str2int(t))\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i8)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n      (str2int(s1@) < str2int(s2@) ==> res as int == -1) &&\n      (str2int(s1@) == str2int(s2@) ==> res as int == 0) &&\n      (str2int(s1@) > str2int(s2@) ==> res as int == 1)\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n      0nat\n  } else {\n      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n      valid_bit_string(t) &&\n      t.len() > 0 &&\n      (t.len() > 1 ==> t[0] != '0') &&\n      (valid_bit_string(s) ==> str2int(s) == str2int(t))\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i8)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n      (str2int(s1@) < str2int(s2@) ==> res as int == -1) &&\n      (str2int(s1@) == str2int(s2@) ==> res as int == 0) &&\n      (str2int(s1@) > str2int(s2@) ==> res as int == 1)\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_Compare_NormalizeBitString.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1735, "minimize_time_ms": 185847, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"ensures_count": 1, "segments": {"exec": "\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n      valid_bit_string(t) &&\n      t.len() > 0 &&\n      (t.len() > 1 ==> t[0] != '0') &&\n      (valid_bit_string(s) ==> str2int(s) == str2int(t))\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  ensures \n\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n\n  ensures \n\n  decreases str2int(s1@) + str2int(s2@)"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n      0nat\n  } else {\n      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n      valid_bit_string(t) &&\n      t.len() > 0 &&\n      (t.len() > 1 ==> t[0] != '0') &&\n      (valid_bit_string(s) ==> str2int(s) == str2int(t))\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i8)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n      (str2int(s1@) < str2int(s2@) ==> res as int == -1) &&\n      (str2int(s1@) == str2int(s2@) ==> res as int == 0) &&\n      (str2int(s1@) > str2int(s2@) ==> res as int == 1)\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_DivMod_Compare_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n  decreases str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@),\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(res.0@) && valid_bit_string(res.1@),\n    str2int(res.0@) == str2int(dividend@) / str2int(divisor@),\n    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n  decreases str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@),\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(res.0@) && valid_bit_string(res.1@),\n    str2int(res.0@) == str2int(dividend@) / str2int(divisor@),\n    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_DivMod_Compare.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 942, "minimize_time_ms": 153715, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n  decreases str2int(s1) + str2int(s2)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\n  decreases s.len()\n\n  requires \n\n  ensures \n\n  decreases str2int(s1) + str2int(s2)\n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n  decreases str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@),\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(res.0@) && valid_bit_string(res.1@),\n    str2int(res.0@) == str2int(dividend@) / str2int(divisor@),\n    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_DivMod_Compare_Sub_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n        str2int(s1) >= str2int(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) - str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n    requires valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        str2int(s1) < str2int(s2) ==> res == -1,\n        str2int(s1) == str2int(s2) ==> res == 0,\n        str2int(s1) > str2int(s2) ==> res == 1,\n    decreases str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n    requires \n        valid_bit_string(dividend@) && valid_bit_string(divisor@),\n        str2int(divisor@) > 0,\n    ensures \n        valid_bit_string(res.0@) && valid_bit_string(res.1@),\n        str2int(res.0@) == str2int(dividend@) / str2int(divisor@),\n        str2int(res.1@) == str2int(dividend@) % str2int(divisor@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n        str2int(s1) >= str2int(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) - str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n    requires valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        str2int(s1) < str2int(s2) ==> res == -1,\n        str2int(s1) == str2int(s2) ==> res == 0,\n        str2int(s1) > str2int(s2) ==> res == 1,\n    decreases str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n    requires \n        valid_bit_string(dividend@) && valid_bit_string(divisor@),\n        str2int(divisor@) > 0,\n    ensures \n        valid_bit_string(res.0@) && valid_bit_string(res.1@),\n        str2int(res.0@) == str2int(dividend@) / str2int(divisor@),\n        str2int(res.1@) == str2int(dividend@) % str2int(divisor@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_DivMod_Compare_Sub.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1030, "minimize_time_ms": 153815, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 66, "minimized_LOC": 66, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n        str2int(s1) >= str2int(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) - str2int(s2),\n{\n\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n    requires valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        str2int(s1) < str2int(s2) ==> res == -1,\n        str2int(s1) == str2int(s2) ==> res == 0,\n        str2int(s1) > str2int(s2) ==> res == 1,\n    decreases str2int(s1) + str2int(s2),\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\n    decreases s.len()\n\n    requires \n\n    ensures \n\n    requires valid_bit_string(s1) && valid_bit_string(s2),\n\n    ensures \n\n    decreases str2int(s1) + str2int(s2),\n\n    requires \n\n    ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n        str2int(s1) >= str2int(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) - str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n    requires valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        str2int(s1) < str2int(s2) ==> res == -1,\n        str2int(s1) == str2int(s2) ==> res == 0,\n        str2int(s1) > str2int(s2) ==> res == 1,\n    decreases str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n    requires \n        valid_bit_string(dividend@) && valid_bit_string(divisor@),\n        str2int(divisor@) > 0,\n    ensures \n        valid_bit_string(res.0@) && valid_bit_string(res.1@),\n        str2int(res.0@) == str2int(dividend@) / str2int(divisor@),\n        str2int(res.1@) == str2int(dividend@) % str2int(divisor@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_DivMod_Sub_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    str2int(s1) >= str2int(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) - str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (result: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@),\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(result.0@) && valid_bit_string(result.1@),\n    str2int(result.0@) == str2int(dividend@) / str2int(divisor@),\n    str2int(result.1@) == str2int(dividend@) % str2int(divisor@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    str2int(s1) >= str2int(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) - str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (result: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@),\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(result.0@) && valid_bit_string(result.1@),\n    str2int(result.0@) == str2int(dividend@) / str2int(divisor@),\n    str2int(result.1@) == str2int(dividend@) % str2int(divisor@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_DivMod_Sub.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 935, "minimize_time_ms": 154594, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 53, "minimized_LOC": 53, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    str2int(s1) >= str2int(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) - str2int(s2)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\n  decreases s.len()\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    str2int(s1) >= str2int(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) - str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (result: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@),\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(result.0@) && valid_bit_string(result.1@),\n    str2int(result.0@) == str2int(dividend@) / str2int(divisor@),\n    str2int(result.1@) == str2int(dividend@) % str2int(divisor@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExpPow2_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy@.len() == n as int + 1,\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy@.len() == n as int + 1,\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 944, "minimize_time_ms": 187343, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 54, "minimized_LOC": 54, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 11, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {", "spec": "spec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\n    decreases y\n\n    decreases s.len()\n\n    requires \n\n    ensures \n\n    decreases n"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy@.len() == n as int + 1,\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExpPow2_Add_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Add.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 984, "minimize_time_ms": 153634, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 64, "minimized_LOC": 64, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn main() {", "spec": "spec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\n    decreases y\n\n    decreases s.len()\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases n"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExpPow2_Add_DivMod_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n    sy@.len() == n as int + 1 &&\n    str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n    sy@.len() == n as int + 1 &&\n    str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Add_DivMod.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1255, "minimize_time_ms": 153573, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 76, "minimized_LOC": 76, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn main() {", "spec": "spec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\n  decreases y\n\n  decreases s.len()\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases n"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n    sy@.len() == n as int + 1 &&\n    str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExpPow2_Add_DivMod_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Add_DivMod_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1062, "minimize_time_ms": 153722, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 91, "minimized_LOC": 91, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2),\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n\n\nfn main() {", "spec": "spec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n\n    decreases y\n\n    decreases s.len()\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases n,"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExpPow2_Add_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires\n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures\n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n as nat\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires\n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures\n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n as nat\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Add_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1202, "minimize_time_ms": 154260, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 74, "minimized_LOC": 74, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n\n\nfn main() {", "spec": "spec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\n    decreases y\n\n    decreases s.len()\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    decreases n as nat"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires\n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures\n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n as nat\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExpPow2_DivMod_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        if valid_bit_string(s) {\n            2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n        } else {\n            0nat\n        }\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n    ensures \n        valid_bit_string(result.0) && valid_bit_string(result.1),\n        str2int(result.0) == str2int(dividend) / str2int(divisor),\n        str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy.len() == n as int + 1,\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        if valid_bit_string(s) {\n            2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n        } else {\n            0nat\n        }\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n    ensures \n        valid_bit_string(result.0) && valid_bit_string(result.1),\n        str2int(result.0) == str2int(dividend) / str2int(divisor),\n        str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy.len() == n as int + 1,\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_DivMod.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 904, "minimize_time_ms": 183951, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n    ensures \n        valid_bit_string(result.0) && valid_bit_string(result.1),\n        str2int(result.0) == str2int(dividend) / str2int(divisor),\n        str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn main() {", "spec": "spec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\n    decreases y\n\n    decreases s.len()\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases n"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        if valid_bit_string(s) {\n            2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n        } else {\n            0nat\n        }\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n    ensures \n        valid_bit_string(result.0) && valid_bit_string(result.1),\n        str2int(result.0) == str2int(dividend) / str2int(divisor),\n        str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy.len() == n as int + 1,\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExpPow2_DivMod_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if !valid_bit_string(s) {\n        0nat\n    } else if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor),\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1),\n        str2int(res.0) == str2int(dividend) / str2int(divisor),\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy@.len() == n as int + 1,\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if !valid_bit_string(s) {\n        0nat\n    } else if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor),\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1),\n        str2int(res.0) == str2int(dividend) / str2int(divisor),\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy@.len() == n as int + 1,\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_DivMod_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1230, "minimize_time_ms": 183929, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 79, "minimized_LOC": 79, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor),\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1),\n        str2int(res.0) == str2int(dividend) / str2int(divisor),\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n\n\nfn main() {", "spec": "spec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\n    decreases y\n\n    decreases s.len()\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases n"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if !valid_bit_string(s) {\n        0nat\n    } else if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor),\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1),\n        str2int(res.0) == str2int(dividend) / str2int(divisor),\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy@.len() == n as int + 1,\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExpPow2_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1150, "minimize_time_ms": 183996, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n\n\nfn main() {", "spec": "spec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\n    decreases y\n\n    decreases s.len()\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases n"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s.index(s.len() - 1) == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s.index(i) == '0' || s.index(i) == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n  decreases sy@.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s.index(s.len() - 1) == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s.index(i) == '0' || s.index(i) == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n  decreases sy@.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1027, "minimize_time_ms": 184278, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy@.len(),"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s.index(s.len() - 1) == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s.index(i) == '0' || s.index(i) == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n  decreases sy@.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_DivMod_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2_int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2_int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 977, "minimize_time_ms": 184411, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 70, "minimized_LOC": 70, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),\n{\n\n\nfn main() {", "spec": "spec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy@.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2_int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(s1) && valid_bit_string(s2)\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires\n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures\n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n      sy.len() == n + 1 &&\n      str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      sy.len() > 0 && str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(s1) && valid_bit_string(s2)\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires\n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures\n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n      sy.len() == n + 1 &&\n      str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      sy.len() > 0 && str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_ModExpPow2.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 929, "minimize_time_ms": 184049, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 88, "minimized_LOC": 88, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(s1) && valid_bit_string(s2)\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires\n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures\n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n      sy.len() == n + 1 &&\n      str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires\n\n  ensures\n\n  requires\n\n  ensures\n\n  requires\n\n  ensures\n\n  decreases n\n\n  requires\n\n  ensures\n\n  decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(s1) && valid_bit_string(s2)\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires\n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures\n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n      sy.len() == n + 1 &&\n      str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      sy.len() > 0 && str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_ModExpPow2_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1401, "minimize_time_ms": 184490, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 103, "minimized_LOC": 103, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases n\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1667, "minimize_time_ms": 154460, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 106, "minimized_LOC": 106, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn all_zero(s: Seq<char>) -> bool {\n\n    decreases s.len()\n\n    decreases y\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases n\n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_DivMod_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&\n    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(ret.1) == str2int(dividend) % str2int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&\n    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(ret.1) == str2int(dividend) % str2int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1298, "minimize_time_ms": 154105, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 81, "minimized_LOC": 81, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&\n    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(ret.1) == str2int(dividend) % str2int(divisor),\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2),\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy@.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&\n    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(ret.1) == str2int(dividend) % str2int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_DivMod_Mul_Zeroes_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_Mul_Zeroes.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 739, "minimize_time_ms": 153757, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 97, "minimized_LOC": 97, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 19, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn all_zero(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_DivMod_Zeroes_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    if valid_bit_string(s) {\n      2 * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    } else {\n      0nat\n    }\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&\n    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2_int(s) == 0 &&\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2_int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),\n  decreases sy.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    if valid_bit_string(s) {\n      2 * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    } else {\n      0nat\n    }\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&\n    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2_int(s) == 0 &&\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2_int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),\n  decreases sy.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_Zeroes.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 771, "minimize_time_ms": 153202, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 95, "minimized_LOC": 95, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&\n    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),\n{\n\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2_int(s) == 0 &&\n    all_zero(s),\n{\n\n\nfn main() {", "spec": "spec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy.len(),"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    if valid_bit_string(s) {\n      2 * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    } else {\n      0nat\n    }\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&\n    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2_int(s) == 0 &&\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2_int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),\n  decreases sy.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_ModExpPow2_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<u8>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == 49u8 { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<u8>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)\n}\n\nfn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n    sy.len() == n + 1 &&\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<u8>, sy: Vec<u8>, sz: Vec<u8>) -> (res: Vec<u8>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<u8>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == 49u8 { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<u8>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)\n}\n\nfn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n    sy.len() == n + 1 &&\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<u8>, sy: Vec<u8>, sz: Vec<u8>) -> (res: Vec<u8>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_ModExpPow2.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 846, "minimize_time_ms": 185564, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 78, "minimized_LOC": 78, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 16, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n    sy.len() == n + 1 &&\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<u8>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<u8>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases n\n\n  requires \n\n  ensures \n\n  decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<u8>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == 49u8 { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<u8>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)\n}\n\nfn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n    sy.len() == n + 1 &&\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<u8>, sy: Vec<u8>, sz: Vec<u8>) -> (res: Vec<u8>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_ModExpPow2_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_ModExpPow2_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1104, "minimize_time_ms": 155112, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 88, "minimized_LOC": 88, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\n    decreases s.len()\n\n    decreases y\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases n\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_ModExpPow2_Mul_Zeroes_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0nat { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0nat { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 721, "minimize_time_ms": 183690, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 105, "minimized_LOC": 105, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn all_zero(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases n\n\n  requires \n\n  ensures \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0nat { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_ModExpPow2_Zeroes_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n      0nat \n  } else { \n      2nat * str2int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n      valid_bit_string(res),\n      str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n      sy.len() == n + 1,\n      str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n      s.len() == n,\n      valid_bit_string(s),\n      str2int(s) == 0,\n      all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      sy.len() > 0 && str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n      0nat \n  } else { \n      2nat * str2int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n      valid_bit_string(res),\n      str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n      sy.len() == n + 1,\n      str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n      s.len() == n,\n      valid_bit_string(s),\n      str2int(s) == 0,\n      all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      sy.len() > 0 && str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_ModExpPow2_Zeroes.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1045, "minimize_time_ms": 185087, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 95, "minimized_LOC": 95, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n      valid_bit_string(res),\n      str2int(res) == str2int(s1) + str2int(s2),\n{\n\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n      sy.len() == n + 1,\n      str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases n\n{\n\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n      s.len() == n,\n      valid_bit_string(s),\n      str2int(s) == 0,\n      all_zero(s),\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases n\n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n      0nat \n  } else { \n      2nat * str2int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n      valid_bit_string(res),\n      str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n      sy.len() == n + 1,\n      str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n      s.len() == n,\n      valid_bit_string(s),\n      str2int(s) == 0,\n      all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      sy.len() > 0 && str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) * str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2_int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),\n  decreases sy@.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) * str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2_int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),\n  decreases sy@.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 904, "minimize_time_ms": 153945, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 69, "minimized_LOC": 69, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) * str2_int(s2),\n{\n\n\nfn main() {", "spec": "spec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy@.len(),"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) * str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2_int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),\n  decreases sy@.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_Mul_Zeroes_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2int(s) == 0 &&\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2int(s) == 0 &&\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_Mul_Zeroes.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 763, "minimize_time_ms": 182917, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 83, "minimized_LOC": 83, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2int(s) == 0 &&\n    all_zero(s)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn all_zero(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2int(s) == 0 &&\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_Mul_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_ModExpPow2_Mul.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1971, "minimize_time_ms": 184686, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 103, "minimized_LOC": 103, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases n\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 942, "minimize_time_ms": 183545, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 106, "minimized_LOC": 106, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 20, "has_meaningful_spec": false, "readability_score": 0.7, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\nspec fn all_zero(s: Seq<char>) -> bool {\n\n    decreases s.len()\n\n    decreases y\n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases n\n\n    ensures \n\n    requires \n\n    ensures \n\n    decreases sy.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_Add_Zeroes_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@),\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@),\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_Zeroes.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1063, "minimize_time_ms": 184544, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 73, "minimized_LOC": 73, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s),\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  ensures \n\n  requires \n\n  ensures "}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@),\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
{"id": "bignum_ModExp_DivMod_91926749", "original_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, (s.len() - 1) as int)) + (if s[(s.len() - 1) as int] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures \n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n      valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n      sy@.len() > 0 && str2int(sz@) > 1\n  ensures \n      valid_bit_string(res@) &&\n      str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "minimized_code": "// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, (s.len() - 1) as int)) + (if s[(s.len() - 1) as int] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures \n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n      valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n      sy@.len() > 0 && str2int(sz@) > 1\n  ensures \n      valid_bit_string(res@) &&\n      str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "metadata": {"provenance": {"source_repo": "https://github.com/Beneficial-AI-Foundation/vericoding.git", "file_path": "/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_DivMod.rs", "commit_sha": "91926749b0a9a5b352aa8dfd080c3e105d585f0a"}, "verification": {"status": "verified", "verify_time_ms": 1231, "minimize_time_ms": 223057, "minimum_verifiable": true, "minimized_status": "succeeded"}, "quality": {"original_LOC": 59, "minimized_LOC": 59, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures \n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n\n\nfn main() {", "spec": "spec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n\n  decreases s.len()\n\n  decreases y\n\n  requires \n\n  ensures \n\n  requires \n\n  ensures \n\n  decreases sy@.len()"}}}, "all_snapshots": ["// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, (s.len() - 1) as int)) + (if s[(s.len() - 1) as int] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures \n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n      valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n      sy@.len() > 0 && str2int(sz@) > 1\n  ensures \n      valid_bit_string(res@) &&\n      str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}", "use vstd;\nfn main() {}\n", "use vstd::prelude::*;\n        fn main() {}\n", "use vstd::prelude::*;\nfn main() {}\n", "use vstd;\nfn main() {}\n"]}
