file_path,original_LOC,minimized_LOC,reduction_ratio,minimization_time,minimization_success,readability_score,self_contained,dependencies,verifiable,error_type,has_invariant,has_proof_block,requires_count,ensures_count,original_code,minimized_code,all_snapshots
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-assert/ex1.rs,76,76,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,True,,,"Failed assertion
```
Line 48-48:
                    assert(j < n);
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail
            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i,
                    n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                proof {
                    assert(j < n);
                }
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
","Failed assertion
```
Line 48-48:
                    assert(j < n);
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail
            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i,
                    n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                proof {
                    assert(j < n);
                }
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-assert/ex2.rs,70,70,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,True,,,"Failed assertion
```
Line 24-24:
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
","Failed assertion
```
Line 24-24:
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-assert/ex3.rs,101,101,1.0,,,0.9,True,['vstd::prelude::'],False,other,,True,,,"Failed assertion
```
Line 87-87:
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {

proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)
    requires
        0 <= i < a.len() as int,
    ensures
        sorted_between(a, i, i + 1),
{
    assert(sorted_between(a, i, i + 1));
    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);
}

proof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)
    requires
        sorted_between(a, i, k),
        i <= j,
        j <= k,
    ensures
        sorted_between(a, i, j),
        sorted_between(a, j, k),
{
    assert(sorted_between(a, i, k));
    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);
    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);
}

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]
}

spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
}

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
{
    let n = nums.len();
    if n == 0 {
        proof {
            let r = Seq::new(0, |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        return;
    }
    let ghost mut r = Seq::new(nums@.len(), |i: int| i);
    proof {
        assert(is_reorder_of(r, nums@, nums@));
    }
    for i in 1..n
    invariant
        sorted_between(nums@, 0, i as int),
        is_reorder_of(r, nums@, old(nums)@),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let mut j = i;
        while j > 0
        invariant
            0 <= j <= i < n,
            n == nums.len(),
            sorted_between(nums@, 0, j as int),
            sorted_between(nums@, j as int, i as int + 1),
            is_reorder_of(r, nums@, old(nums)@),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            if nums[j - 1] > nums[j] {
                let temp = nums[j - 1];
                nums.set(j - 1, nums[j]);
                nums.set(j, temp);
                proof {
                    lemma_sorted_between_single_element(nums@, j as int - 1);
                }
            }
            proof {
                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);
            }
            j -= 1;
            proof {
                assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
            }
        }
    }
}
}
```
","Failed assertion
```
Line 87-87:
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {

proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)
    requires
        0 <= i < a.len() as int,
    ensures
        sorted_between(a, i, i + 1),
{
    assert(sorted_between(a, i, i + 1));
    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);
}

proof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)
    requires
        sorted_between(a, i, k),
        i <= j,
        j <= k,
    ensures
        sorted_between(a, i, j),
        sorted_between(a, j, k),
{
    assert(sorted_between(a, i, k));
    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);
    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);
}

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]
}

spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
}

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
{
    let n = nums.len();
    if n == 0 {
        proof {
            let r = Seq::new(0, |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        return;
    }
    let ghost mut r = Seq::new(nums@.len(), |i: int| i);
    proof {
        assert(is_reorder_of(r, nums@, nums@));
    }
    for i in 1..n
    invariant
        sorted_between(nums@, 0, i as int),
        is_reorder_of(r, nums@, old(nums)@),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let mut j = i;
        while j > 0
        invariant
            0 <= j <= i < n,
            n == nums.len(),
            sorted_between(nums@, 0, j as int),
            sorted_between(nums@, j as int, i as int + 1),
            is_reorder_of(r, nums@, old(nums)@),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            if nums[j - 1] > nums[j] {
                let temp = nums[j - 1];
                nums.set(j - 1, nums[j]);
                nums.set(j, temp);
                proof {
                    lemma_sorted_between_single_element(nums@, j as int - 1);
                }
            }
            proof {
                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);
            }
            j -= 1;
            proof {
                assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
            }
        }
    }
}
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-default/ex1.rs,91,91,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,True,,,"no rules expected the token `;`
```
Line 50-50:
    let q = seq![0; n];
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {

proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)
    requires
        0 <= i < a.len() as int,
    ensures
        sorted_between(a, i, i + 1),
{
    assert(sorted_between(a, i, i + 1));
    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);
}

proof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)
    requires
        sorted_between(a, i, k),
        i <= j,
        j <= k,
    ensures
        sorted_between(a, i, j),
        sorted_between(a, j, k),
{
    assert(sorted_between(a, i, k));
    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);
    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);
}

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]
}

spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
}

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
{
    let n = nums.len();
    if n == 0 {
        return;
    }
    proof {
        let q = seq![0; n];
    }
    for i in 1..n
    invariant
        1 <= i <= n,
        sorted_between(nums@, 0, i as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@.take(i as int), old(nums)@),
    {
        let mut j = i;
        while j > 0
        invariant
            0 < j <= i,
            sorted_between(nums@, 0, j as int),
            sorted_between(nums@, j as int, i as int + 1),
            exists|r: Seq<int>| is_reorder_of(r, nums@.take(i as int), old(nums)@),
        {
            if nums[j - 1] > nums[j] {
                let temp = nums[j - 1];
                nums.set(j - 1, nums[j]);
                nums.set(j, temp);
                proof {
                    lemma_sorted_between_single_element(nums@, j as int - 1);
                }
            }
            proof {
                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);
            }
            j -= 1;
        }
    }
}
}
```
","no rules expected the token `;`
```
Line 50-50:
    let q = seq![0; n];
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {

proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)
    requires
        0 <= i < a.len() as int,
    ensures
        sorted_between(a, i, i + 1),
{
    assert(sorted_between(a, i, i + 1));
    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);
}

proof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)
    requires
        sorted_between(a, i, k),
        i <= j,
        j <= k,
    ensures
        sorted_between(a, i, j),
        sorted_between(a, j, k),
{
    assert(sorted_between(a, i, k));
    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);
    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);
}

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]
}

spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
}

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
{
    let n = nums.len();
    if n == 0 {
        return;
    }
    proof {
        let q = seq![0; n];
    }
    for i in 1..n
    invariant
        1 <= i <= n,
        sorted_between(nums@, 0, i as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@.take(i as int), old(nums)@),
    {
        let mut j = i;
        while j > 0
        invariant
            0 < j <= i,
            sorted_between(nums@, 0, j as int),
            sorted_between(nums@, j as int, i as int + 1),
            exists|r: Seq<int>| is_reorder_of(r, nums@.take(i as int), old(nums)@),
        {
            if nums[j - 1] > nums[j] {
                let temp = nums[j - 1];
                nums.set(j - 1, nums[j]);
                nums.set(j, temp);
                proof {
                    lemma_sorted_between_single_element(nums@, j as int - 1);
                }
            }
            proof {
                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);
            }
            j -= 1;
        }
    }
}
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-inv-end/ex1.rs,63,63,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,invariant,,True,,,"Failed invariant at end of the loop
```
Line 43-43:
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
            }
        }
    }
}
```
","Failed invariant at end of the loop
```
Line 43-43:
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
            }
        }
    }
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-inv-end/ex2.rs,117,117,1.0,,,0.9,True,"['vstd::multiset::Multiset', 'vstd::prelude::']",False,invariant,,True,,,"Failed invariant at end of the loop
```
Line 79-79:
                j > 0,
```

Code
```
use vstd::multiset::Multiset;
use vstd::prelude::*;
fn main() {}

verus! {

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {

    forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]

}

spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>

    decreases input.len()

{

    if input.len() == 0 {

        Multiset::empty()

    } else {

        multiset_from_seq(input.drop_last()).insert(input.last())

    }

}

proof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)
    requires
        0 <= i < s.len(),
    ensures
        multiset_from_seq(s).contains(s[i]),
        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),
    decreases
        s.len(),
{
    if i == s.len() - 1 {
        assert(s.update(i, v) =~= s.drop_last().push(v));
        assert(multiset_from_seq(s) == multiset_from_seq(s.drop_last()).insert(s.last()));
        assert(s.drop_last().push(v).drop_last() =~= s.drop_last());
    } else if s.len() != 0 {
        update_seq_multiset(s.drop_last(), i, v);
        assert(s.drop_last().update(i, v) =~= s.update(i, v).drop_last());
    }
}


#[verifier::loop_isolation(false)]

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
{

    let n = nums.len();

    if n == 0 {
        return;
    }

    for i in 1..n
        invariant
            n == nums.len(),
            sorted_between(nums@, 0, i as int),
            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
    {
        let mut j = i;

        while j != 0
            invariant
                j <= i,
                i < n,
                n == nums.len(),
                forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                j > 0,
                sorted_between(nums@, j as int, i + 1),
                multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
        {

            if nums[j - 1] > nums[j] {

                let temp = nums[j - 1];

                proof {
                    update_seq_multiset(nums@, j-1, nums[j as int])
                }
                nums.set(j - 1, nums[j]);

                assert(multiset_from_seq(old(nums)@) == multiset_from_seq(nums@).remove(nums[j as int]).insert(temp));

                proof{
                    update_seq_multiset(nums@, j as int, temp)
                }
                nums.set(j, temp);
            }

            j -= 1;

        }

    }

}
}
```
","Failed invariant at end of the loop
```
Line 79-79:
                j > 0,
```

Code
```
use vstd::multiset::Multiset;
use vstd::prelude::*;
fn main() {}

verus! {

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {

    forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]

}

spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>

    decreases input.len()

{

    if input.len() == 0 {

        Multiset::empty()

    } else {

        multiset_from_seq(input.drop_last()).insert(input.last())

    }

}

proof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)
    requires
        0 <= i < s.len(),
    ensures
        multiset_from_seq(s).contains(s[i]),
        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),
    decreases
        s.len(),
{
    if i == s.len() - 1 {
        assert(s.update(i, v) =~= s.drop_last().push(v));
        assert(multiset_from_seq(s) == multiset_from_seq(s.drop_last()).insert(s.last()));
        assert(s.drop_last().push(v).drop_last() =~= s.drop_last());
    } else if s.len() != 0 {
        update_seq_multiset(s.drop_last(), i, v);
        assert(s.drop_last().update(i, v) =~= s.update(i, v).drop_last());
    }
}


#[verifier::loop_isolation(false)]

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
{

    let n = nums.len();

    if n == 0 {
        return;
    }

    for i in 1..n
        invariant
            n == nums.len(),
            sorted_between(nums@, 0, i as int),
            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
    {
        let mut j = i;

        while j != 0
            invariant
                j <= i,
                i < n,
                n == nums.len(),
                forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                j > 0,
                sorted_between(nums@, j as int, i + 1),
                multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
        {

            if nums[j - 1] > nums[j] {

                let temp = nums[j - 1];

                proof {
                    update_seq_multiset(nums@, j-1, nums[j as int])
                }
                nums.set(j - 1, nums[j]);

                assert(multiset_from_seq(old(nums)@) == multiset_from_seq(nums@).remove(nums[j as int]).insert(temp));

                proof{
                    update_seq_multiset(nums@, j as int, temp)
                }
                nums.set(j, temp);
            }

            j -= 1;

        }

    }

}
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-inv-front/ex1.rs,67,67,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,invariant,,True,,,"Failed invariant before the loop
```
Line 31-31:
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
","Failed invariant before the loop
```
Line 31-31:
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-inv-front/ex2.rs,96,96,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,invariant,,True,,,"Failed invariant before the loop
```
Line 67-67:
n == nums.len(),
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {

proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)
    requires
        0 <= i < a.len() as int,
    ensures
        sorted_between(a, i, i + 1),
{
    assert(sorted_between(a, i, i + 1));
    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);
}

proof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)
    requires
        sorted_between(a, i, k),
        i <= j,
        j <= k,
    ensures
        sorted_between(a, i, j),
        sorted_between(a, j, k),
{
    assert(sorted_between(a, i, k));
    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);
    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);
}

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]
}

spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
}

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
{
    let n = nums.len();
    if n == 0 {
        proof {
            let r = Seq::new(0, |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        return;
    }
    proof {
        let r = Seq::new(nums@.len(), |i: int| i);
        assert(is_reorder_of(r, nums@, nums@));
    }
    for i in 1..n
    invariant
        sorted_between(nums@, 0, i as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let mut j = i;
        while j > 0
        invariant
            0 <= j <= i < n,
            n == nums.len(),
            sorted_between(nums@, 0, j as int),
            sorted_between(nums@, j as int, i as int + 1),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            if nums[j - 1] > nums[j] {
                let temp = nums[j - 1];
                nums.set(j - 1, nums[j]);
                nums.set(j, temp);
                proof {
                    lemma_sorted_between_single_element(nums@, j as int - 1);
                }
            }
            proof {
                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);
            }
            j -= 1;
        }
    }
}
}
```
","Failed invariant before the loop
```
Line 67-67:
n == nums.len(),
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {

proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)
    requires
        0 <= i < a.len() as int,
    ensures
        sorted_between(a, i, i + 1),
{
    assert(sorted_between(a, i, i + 1));
    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);
}

proof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)
    requires
        sorted_between(a, i, k),
        i <= j,
        j <= k,
    ensures
        sorted_between(a, i, j),
        sorted_between(a, j, k),
{
    assert(sorted_between(a, i, k));
    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);
    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);
}

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]
}

spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
}

fn test1(nums: &mut Vec<u32>)
    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
{
    let n = nums.len();
    if n == 0 {
        proof {
            let r = Seq::new(0, |i: int| i);
            assert(is_reorder_of(r, nums@, nums@));
        }
        return;
    }
    proof {
        let r = Seq::new(nums@.len(), |i: int| i);
        assert(is_reorder_of(r, nums@, nums@));
    }
    for i in 1..n
    invariant
        sorted_between(nums@, 0, i as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let mut j = i;
        while j > 0
        invariant
            0 <= j <= i < n,
            n == nums.len(),
            sorted_between(nums@, 0, j as int),
            sorted_between(nums@, j as int, i as int + 1),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            if nums[j - 1] > nums[j] {
                let temp = nums[j - 1];
                nums.set(j - 1, nums[j]);
                nums.set(j, temp);
                proof {
                    lemma_sorted_between_single_element(nums@, j as int - 1);
                }
            }
            proof {
                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);
            }
            j -= 1;
        }
    }
}
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-postcond/ex1.rs,72,72,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,True,,,"Failed post-condition
```
Line 21-21:
    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```
Failed location
```
Line 25-25:
    return;
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
","Failed post-condition
```
Line 21-21:
    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
```
Failed location
```
Line 25-25:
    return;
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-precond/ex1.rs,77,77,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,True,,,"Failed pre-condition
```
        i < vec.view().len(),
```
Failed location
```
Line 47-47:
            if nums[j - 1] > nums[j] {
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail
            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i,
                    n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
","Failed pre-condition
```
        i < vec.view().len(),
```
Failed location
```
Line 47-47:
            if nums[j - 1] > nums[j] {
```

Code
```
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }


    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        proof {
            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail
            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail
            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));
        }
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i,
                    n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    proof {
                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);
                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);
                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));
                    }
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
                proof{
                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));
                }
            }
        }
    }
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-proof/ex1.rs,51,51,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }

    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let ghost mut r = Seq::new(nums@.len(), |i: int| i);
        assert(is_reorder_of(r, nums@, nums@));
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
            }
        }
    }
}
","use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }


    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
    }

    fn test1(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
    {
        let ghost mut r = Seq::new(nums@.len(), |i: int| i);
        assert(is_reorder_of(r, nums@, nums@));
        let n = nums.len();
        if n == 0 {
            return;
        }
        for i in 1..n
            invariant
                n == nums.len(),
                sorted_between(nums@, 0, i as int),
                is_reorder_of(r, nums@, old(nums)@),
        {
            let mut j = i;
            while j != 0
                invariant
                    0 <= j <= i < n == nums.len(),
                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],
                    sorted_between(nums@, j as int, i + 1),
                    is_reorder_of(r, nums@, old(nums)@),
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
            }
        }
    }
}
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-proof/ex3.rs,111,111,1.0,,,0.9,True,['vstd::prelude::'],False,other,,True,,,"#[allow(unused_imports)]
use vstd::prelude::*;
fn main() {}

verus! {
spec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>
    decreases seq.len()
{
    if seq.len() == 0 {
        Set::empty()
    } else {
        seq_to_set_rec(seq.drop_last()).insert(seq.last())
    }
}

/// helper function showing that the resulting set contains all elements of the sequence
proof fn seq_to_set_rec_contains<A>(seq: Seq<A>)
    ensures forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a)
    decreases seq.len()
{
    if seq.len() > 0 {
        assert(forall |a| #[trigger] seq.drop_last().contains(a) <==> seq_to_set_rec(seq.drop_last()).contains(a)) by {
            seq_to_set_rec_contains(seq.drop_last());
        }

        assert(seq.ext_equal(seq.drop_last().push(seq.last())));
        assert forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a) by {
            if !seq.drop_last().contains(a) {
                if a == seq.last() {
                    assert(seq.contains(a));
                    assert(seq_to_set_rec(seq).contains(a));
                } else {
                    assert(!seq_to_set_rec(seq).contains(a));
                }
            }
        }
    }
}

/// helper function showing that the recursive definition matches the set comprehension one
proof fn seq_to_set_equal_rec<A>(seq: Seq<A>)
    ensures seq.to_set() == seq_to_set_rec(seq)
{
    assert(forall |n| #[trigger] seq.contains(n) <==> seq_to_set_rec(seq).contains(n)) by {
        seq_to_set_rec_contains(seq);
    }
    assert(forall |n| #[trigger] seq.contains(n) <==> seq.to_set().contains(n));
    assert(seq.to_set().ext_equal(seq_to_set_rec(seq)));
}

proof fn lemma_seq_push_to_set_insert<T>(s: Seq<T>, val: T)
ensures
    s.push(val).to_set() === s.to_set().insert(val),
{
    seq_to_set_equal_rec(s.push(val));
    assert(s.ext_equal(s.push(val).drop_last()));
    seq_to_set_equal_rec(s);
    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val)));
    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val).drop_last()).insert(val));
}

fn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)
ensures
    res@.no_duplicates(),
    nums@.to_set().ext_equal(res@.to_set())
{
    let mut res = Vec::new();
    let mut i = 0;
    while i < nums.len()
    invariant
        0 <= i <= nums@.len(),
        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
        res@.no_duplicates(),
    {
        let mut found = false;
        let mut j = 0;

        while j < res.len()
        invariant
            0 <= i < nums@.len(),
            0 <= j <= res@.len(),
            res@.no_duplicates(),
            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
            !found,
            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],
        ensures
            0<= i < nums@.len(),
            0 <= j <= res@.len(),
            res@.no_duplicates(),
            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),
            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],
            !found ==> j == res@.len(),
        {
            if nums[i] == res[j] {
                found = true;
                break;
            }
            j += 1;
        }
        if !found {
            res.push(nums[i]);
        }
        i += 1;
    }
    proof {
        assert(nums@.subrange(0, i  as int).ext_equal(nums@));
    }
    res
}
}
","#[allow(unused_imports)]
use vstd::prelude::*;
fn main() {}

verus! {
spec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>
    decreases seq.len()
{
    if seq.len() == 0 {
        Set::empty()
    } else {
        seq_to_set_rec(seq.drop_last()).insert(seq.last())
    }
}

/// helper function showing that the resulting set contains all elements of the sequence
proof fn seq_to_set_rec_contains<A>(seq: Seq<A>)
    ensures forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a)
    decreases seq.len()
{
    if seq.len() > 0 {
        assert(forall |a| #[trigger] seq.drop_last().contains(a) <==> seq_to_set_rec(seq.drop_last()).contains(a)) by {
            seq_to_set_rec_contains(seq.drop_last());
        }

        assert(seq.ext_equal(seq.drop_last().push(seq.last())));
        assert forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a) by {
            if !seq.drop_last().contains(a) {
                if a == seq.last() {
                    assert(seq.contains(a));
                    assert(seq_to_set_rec(seq).contains(a));
                } else {
                    assert(!seq_to_set_rec(seq).contains(a));
                }
            }
        }
    }
}

/// helper function showing that the recursive definition matches the set comprehension one
proof fn seq_to_set_equal_rec<A>(seq: Seq<A>)
    ensures seq.to_set() == seq_to_set_rec(seq)
{
    assert(forall |n| #[trigger] seq.contains(n) <==> seq_to_set_rec(seq).contains(n)) by {
        seq_to_set_rec_contains(seq);
    }
    assert(forall |n| #[trigger] seq.contains(n) <==> seq.to_set().contains(n));
    assert(seq.to_set().ext_equal(seq_to_set_rec(seq)));
}

proof fn lemma_seq_push_to_set_insert<T>(s: Seq<T>, val: T)
ensures
    s.push(val).to_set() === s.to_set().insert(val),
{
    seq_to_set_equal_rec(s.push(val));
    assert(s.ext_equal(s.push(val).drop_last()));
    seq_to_set_equal_rec(s);
    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val)));
    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val).drop_last()).insert(val));
}

fn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)
ensures
    res@.no_duplicates(),
    nums@.to_set().ext_equal(res@.to_set())
{
    let mut res = Vec::new();
    let mut i = 0;
    while i < nums.len()
    invariant
        0 <= i <= nums@.len(),
        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
        res@.no_duplicates(),
    {
        let mut found = false;
        let mut j = 0;

        while j < res.len()
        invariant
            0 <= i < nums@.len(),
            0 <= j <= res@.len(),
            res@.no_duplicates(),
            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
            !found,
            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],
        ensures
            0<= i < nums@.len(),
            0 <= j <= res@.len(),
            res@.no_duplicates(),
            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),
            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],
            !found ==> j == res@.len(),
        {
            if nums[i] == res[j] {
                found = true;
                break;
            }
            j += 1;
        }
        if !found {
            res.push(nums[i]);
        }
        i += 1;
    }
    proof {
        assert(nums@.subrange(0, i  as int).ext_equal(nums@));
    }
    res
}
}
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-proof-func-middle/ex2.rs,86,86,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,True,,,"Failed assertion
```
Line 58-58:
            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));
```

Code:
```
#[allow(unused_imports)]
use vstd::prelude::*;
fn main() {}

verus! {
spec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>
    decreases seq.len()
{
    if seq.len() == 0 {
        Set::empty()
    } else {
        seq_to_set_rec(seq.drop_last()).insert(seq.last())
    }
}

fn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)
ensures
    res@.no_duplicates(),
    nums@.to_set().ext_equal(res@.to_set())
{
    let mut res = Vec::new();
    let mut i = 0;
    while i < nums.len()
    invariant
        0 <= i <= nums@.len(),
        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
        res@.no_duplicates(),
    {
        let mut found = false;
        let mut j = 0;

        while j < res.len()
        invariant
            0 <= i < nums@.len(),
            0 <= j <= res@.len(),
            res@.no_duplicates(),
            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
            !found,
            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],
        ensures
            0<= i < nums@.len(),
            0 <= j <= res@.len(),
            res@.no_duplicates(),
            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),
            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],
            !found ==> j == res@.len(),
        {
            if nums[i] == res[j] {
                found = true;
                break;
            }
            j += 1;
        }
        proof {
            let val = nums@[i as int];
            assert(nums@.subrange(0, i as int + 1).ext_equal(nums@.subrange(0, i as int).push(val)));
            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));
            if found {
                assert(res@.contains(val));
                assert(res@.to_set().contains(val));
                assert(res@.to_set().ext_equal(res@.to_set().insert(val)));
                assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set()));
            }

        }
        if !found {
            res.push(nums[i]);
        }
        i += 1;
    }
    proof {
        assert(nums@.subrange(0, i  as int).ext_equal(nums@));
    }
    res
}
}
```
","Failed assertion
```
Line 58-58:
            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));
```

Code:
```
#[allow(unused_imports)]
use vstd::prelude::*;
fn main() {}

verus! {
spec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>
    decreases seq.len()
{
    if seq.len() == 0 {
        Set::empty()
    } else {
        seq_to_set_rec(seq.drop_last()).insert(seq.last())
    }
}

fn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)
ensures
    res@.no_duplicates(),
    nums@.to_set().ext_equal(res@.to_set())
{
    let mut res = Vec::new();
    let mut i = 0;
    while i < nums.len()
    invariant
        0 <= i <= nums@.len(),
        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
        res@.no_duplicates(),
    {
        let mut found = false;
        let mut j = 0;

        while j < res.len()
        invariant
            0 <= i < nums@.len(),
            0 <= j <= res@.len(),
            res@.no_duplicates(),
            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
            !found,
            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],
        ensures
            0<= i < nums@.len(),
            0 <= j <= res@.len(),
            res@.no_duplicates(),
            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),
            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),
            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],
            !found ==> j == res@.len(),
        {
            if nums[i] == res[j] {
                found = true;
                break;
            }
            j += 1;
        }
        proof {
            let val = nums@[i as int];
            assert(nums@.subrange(0, i as int + 1).ext_equal(nums@.subrange(0, i as int).push(val)));
            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));
            if found {
                assert(res@.contains(val));
                assert(res@.to_set().contains(val));
                assert(res@.to_set().ext_equal(res@.to_set().insert(val)));
                assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set()));
            }

        }
        if !found {
            res.push(nums[i]);
        }
        i += 1;
    }
    proof {
        assert(nums@.subrange(0, i  as int).ext_equal(nums@));
    }
    res
}
}
```
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-temp/ex4.rs,61,61,1.0,,,0.7999999999999999,True,"['vstd::multiset::Multiset', 'vstd::prelude::']",False,other,,,,,"use vstd::multiset::Multiset;
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {

        forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]

    }

    spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>

        decreases input.len()

    {

        if input.len() == 0 {

            Multiset::empty()

        } else {

            multiset_from_seq(input.drop_last()).insert(input.last())

        }

    }


    #[verifier::loop_isolation(false)]

    fn bubble_sort(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
    {

        let n = nums.len();

        if n == 0 {
            return;
        }

        for i in 1..n
        {
            let mut j = i;

            while j != 0
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
            }
        }

    }
}
","use vstd::multiset::Multiset;
use vstd::prelude::*;
fn main() {}

verus! {
    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {

        forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]

    }

    spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>

        decreases input.len()

    {

        if input.len() == 0 {

            Multiset::empty()

        } else {

            multiset_from_seq(input.drop_last()).insert(input.last())

        }

    }


    #[verifier::loop_isolation(false)]

    fn bubble_sort(nums: &mut Vec<u32>)
        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)
    {

        let n = nums.len();

        if n == 0 {
            return;
        }

        for i in 1..n
        {
            let mut j = i;

            while j != 0
            {
                if nums[j - 1] > nums[j] {
                    let temp = nums[j - 1];
                    nums.set(j - 1, nums[j]);
                    nums.set(j, temp);
                }
                j -= 1;
            }
        }

    }
}
",[]
/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/output/ex6.rs,57,57,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,True,,,"
use vstd::prelude::*;
fn main() {}

verus!{

    proof fn lemma_seq_subrange_ascend<T>(v: Seq<T>, i: int, j: int)
        requires
            0<= i < j <= v.len(),
        ensures
            v.subrange(i as int, j as int).drop_last() == v.subrange(i as int, j-1 ),
    {
        assert(v.subrange(i as int, j as int).drop_last() =~= v.subrange(i as int, j-1));
    }

    proof fn lemma_seq_subrange_all<T>(v: Seq<T>)
        ensures
            v == v.subrange(0, v.len() as int),
    {
        assert(v =~= v.subrange(0, v.len() as int));
    }

    #[verifier::loop_isolation(false)]

    pub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)
        requires
            old(y).len() == 0,
        ensures
            y@ == x@.filter(|k: u64| true),
    {
        proof {
            reveal(Seq::filter);
        }

        let mut i: usize = 0;

        assert(y@ == x@.subrange(0, (i) as int).filter(|k: u64| true));

        while (i < x.len())
            invariant
                i <= x.len(),
                y@ == x@.subrange(0, (i) as int).filter(|k: u64| true),
        {

            y.push(x[i]);
            i = i + 1;

            proof {
                lemma_seq_subrange_ascend(x@, 0, i as int);
            }
        }

        proof {
            lemma_seq_subrange_all(x@);
        }
    }
}
","
use vstd::prelude::*;
fn main() {}

verus!{

    proof fn lemma_seq_subrange_ascend<T>(v: Seq<T>, i: int, j: int)
        requires
            0<= i < j <= v.len(),
        ensures
            v.subrange(i as int, j as int).drop_last() == v.subrange(i as int, j-1 ),
    {
        assert(v.subrange(i as int, j as int).drop_last() =~= v.subrange(i as int, j-1));
    }

    proof fn lemma_seq_subrange_all<T>(v: Seq<T>)
        ensures
            v == v.subrange(0, v.len() as int),
    {
        assert(v =~= v.subrange(0, v.len() as int));
    }

    #[verifier::loop_isolation(false)]

    pub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)
        requires
            old(y).len() == 0,
        ensures
            y@ == x@.filter(|k: u64| true),
    {
        proof {
            reveal(Seq::filter);
        }

        let mut i: usize = 0;

        assert(y@ == x@.subrange(0, (i) as int).filter(|k: u64| true));

        while (i < x.len())
            invariant
                i <= x.len(),
                y@ == x@.subrange(0, (i) as int).filter(|k: u64| true),
        {

            y.push(x[i]);
            i = i + 1;

            proof {
                lemma_seq_subrange_ascend(x@, 0, i as int);
            }
        }

        proof {
            lemma_seq_subrange_all(x@);
        }
    }
}
",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1.rs,60,60,1.0,122.551,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn int_to_digits(x: int) -> Seq<int>
  recommends x >= 0
{
  if x == 0 { seq![0] }
  else { int_to_digits_helper(x) }
}

spec fn int_to_digits_helper(x: int) -> Seq<int>
  recommends x > 0
  decreases x
{
  if x < 10 { seq![x] }
  else { int_to_digits_helper(x / 10).add(seq![x % 10]) }
}

spec fn digit_sum(digits: Seq<int>) -> int
  decreases digits.len()
{
  if digits.len() == 0 { 0 }
  else { digits[0] + digit_sum(digits.subrange(1, digits.len() as int)) }
}

spec fn valid_input(x: int) -> bool
{
  x >= 1
}

spec fn valid_result(x: int, result: int) -> bool
  recommends valid_input(x)
{
  result > 0 &&
  result <= x &&
  (forall|y: int| 1 <= y <= x ==> digit_sum(int_to_digits(y)) <= digit_sum(int_to_digits(result))) &&
  (forall|y: int| 1 <= y <= x && digit_sum(int_to_digits(y)) == digit_sum(int_to_digits(result)) ==> y <= result)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x: i8) -> (result: i8)
  requires valid_input(x as int)
  ensures valid_result(x as int, result as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn int_to_digits(x: int) -> Seq<int>
  recommends x >= 0
{
  if x == 0 { seq![0] }
  else { int_to_digits_helper(x) }
}

spec fn int_to_digits_helper(x: int) -> Seq<int>
  recommends x > 0
  decreases x
{
  if x < 10 { seq![x] }
  else { int_to_digits_helper(x / 10).add(seq![x % 10]) }
}

spec fn digit_sum(digits: Seq<int>) -> int
  decreases digits.len()
{
  if digits.len() == 0 { 0 }
  else { digits[0] + digit_sum(digits.subrange(1, digits.len() as int)) }
}

spec fn valid_input(x: int) -> bool
{
  x >= 1
}

spec fn valid_result(x: int, result: int) -> bool
  recommends valid_input(x)
{
  result > 0 &&
  result <= x &&
  (forall|y: int| 1 <= y <= x ==> digit_sum(int_to_digits(y)) <= digit_sum(int_to_digits(result))) &&
  (forall|y: int| 1 <= y <= x && digit_sum(int_to_digits(y)) == digit_sum(int_to_digits(result)) ==> y <= result)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x: i8) -> (result: i8)
  requires valid_input(x as int)
  ensures valid_result(x as int, result as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_digits(x: int) -> Seq<int>\n  recommends x >= 0\n{\n  if x == 0 { seq![0] }\n  else { int_to_digits_helper(x) }\n}\n\nspec fn int_to_digits_helper(x: int) -> Seq<int>\n  recommends x > 0\n  decreases x\n{\n  if x < 10 { seq![x] }\n  else { int_to_digits_helper(x / 10).add(seq![x % 10]) }\n}\n\nspec fn digit_sum(digits: Seq<int>) -> int\n  decreases digits.len()\n{\n  if digits.len() == 0 { 0 }\n  else { digits[0] + digit_sum(digits.subrange(1, digits.len() as int)) }\n}\n\nspec fn valid_input(x: int) -> bool\n{\n  x >= 1\n}\n\nspec fn valid_result(x: int, result: int) -> bool\n  recommends valid_input(x)\n{\n  result > 0 &&\n  result <= x &&\n  (forall|y: int| 1 <= y <= x ==> digit_sum(int_to_digits(y)) <= digit_sum(int_to_digits(result))) &&\n  (forall|y: int| 1 <= y <= x && digit_sum(int_to_digits(y)) == digit_sum(int_to_digits(result)) ==> y <= result)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8) -> (result: i8)\n  requires valid_input(x as int)\n  ensures valid_result(x as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_10.rs,52,52,1.0,122.709,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn min_days_off(n: int) -> int {
  let complete_weeks = n / 7;
  let remaining_days = n % 7;
  let min_additional = if remaining_days > 5 { remaining_days - 5 } else { 0 };
  2 * complete_weeks + min_additional
}

spec fn max_days_off(n: int) -> int {
  let complete_weeks = n / 7;
  let remaining_days = n % 7;
  let max_additional = if remaining_days < 2 { remaining_days } else { 2 };
  2 * complete_weeks + max_additional
}

spec fn valid_output(result: Seq<int>, n: int) -> bool {
  result.len() == 2 &&
  result[0] >= 0 && result[1] >= 0 &&
  result[0] <= result[1] &&
  result[0] <= n && result[1] <= n &&
  result[0] == min_days_off(n) &&
  result[1] == max_days_off(n)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: Vec<i8>)
  requires valid_input(n as int)
  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn min_days_off(n: int) -> int {
  let complete_weeks = n / 7;
  let remaining_days = n % 7;
  let min_additional = if remaining_days > 5 { remaining_days - 5 } else { 0 };
  2 * complete_weeks + min_additional
}

spec fn max_days_off(n: int) -> int {
  let complete_weeks = n / 7;
  let remaining_days = n % 7;
  let max_additional = if remaining_days < 2 { remaining_days } else { 2 };
  2 * complete_weeks + max_additional
}

spec fn valid_output(result: Seq<int>, n: int) -> bool {
  result.len() == 2 &&
  result[0] >= 0 && result[1] >= 0 &&
  result[0] <= result[1] &&
  result[0] <= n && result[1] <= n &&
  result[0] == min_days_off(n) &&
  result[1] == max_days_off(n)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: Vec<i8>)
  requires valid_input(n as int)
  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  Vec::new()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn min_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let min_additional = if remaining_days > 5 { remaining_days - 5 } else { 0 };\n  2 * complete_weeks + min_additional\n}\n\nspec fn max_days_off(n: int) -> int {\n  let complete_weeks = n / 7;\n  let remaining_days = n % 7;\n  let max_additional = if remaining_days < 2 { remaining_days } else { 2 };\n  2 * complete_weeks + max_additional\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n  result.len() == 2 &&\n  result[0] >= 0 && result[1] >= 0 &&\n  result[0] <= result[1] &&\n  result[0] <= n && result[1] <= n &&\n  result[0] == min_days_off(n) &&\n  result[1] == max_days_off(n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1002.rs,54,54,1.0,122.666,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {
    1 <= n <= 100 && 1 <= d <= 10000 &&
    t.len() == n &&
    forall|i: int| 0 <= i < t.len() ==> #[trigger] t[i] >= 1 && #[trigger] t[i] <= 100
}

spec fn min_time_needed(n: int, t: Seq<int>) -> int {
    sum_seq(t) + 10 * (n - 1)
}

spec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {
    let song_sum = sum_seq(t);
    let min_time = min_time_needed(n, t);
    if min_time > d {
        result == -1
    } else {
        result == (d - song_sum) / 5 && result >= 0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, d: i8, t: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))
    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {
    1 <= n <= 100 && 1 <= d <= 10000 &&
    t.len() == n &&
    forall|i: int| 0 <= i < t.len() ==> #[trigger] t[i] >= 1 && #[trigger] t[i] <= 100
}

spec fn min_time_needed(n: int, t: Seq<int>) -> int {
    sum_seq(t) + 10 * (n - 1)
}

spec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {
    let song_sum = sum_seq(t);
    let min_time = min_time_needed(n, t);
    if min_time > d {
        result == -1
    } else {
        result == (d - song_sum) / 5 && result >= 0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, d: i8, t: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))
    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {\n    1 <= n <= 100 && 1 <= d <= 10000 &&\n    t.len() == n &&\n    forall|i: int| 0 <= i < t.len() ==> #[trigger] t[i] >= 1 && #[trigger] t[i] <= 100\n}\n\nspec fn min_time_needed(n: int, t: Seq<int>) -> int {\n    sum_seq(t) + 10 * (n - 1)\n}\n\nspec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {\n    let song_sum = sum_seq(t);\n    let min_time = min_time_needed(n, t);\n    if min_time > d {\n        result == -1\n    } else {\n        result == (d - song_sum) / 5 && result >= 0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, t: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))\n    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1007.rs,84,84,1.0,122.765,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn int_to_string(n: int) -> Seq<char>
    decreases n
{
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string(n / 10).add(seq![('0' as int + (n % 10)) as char])
    }
}

spec fn reverse_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]])
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else {
        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))
    }
}

spec fn sum_of_palindromes(k: int) -> int
    decreases k
{
    if k <= 0 {
        0
    } else if k == 1 {
        let s = int_to_string(1);
        let reversed = reverse_string(s);
        let palindrome = s.add(reversed);
        string_to_int(palindrome)
    } else {
        let s = int_to_string(k);
        let reversed = reverse_string(s);
        let palindrome = s.add(reversed);
        string_to_int(palindrome) + sum_of_palindromes(k - 1)
    }
}

spec fn valid_input(k: int, p: int) -> bool {
    k >= 1 && p >= 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i8, p: i8) -> (result: i8)
    requires
        valid_input(k as int, p as int),
    ensures
        0 <= result < p,
        result as int == (sum_of_palindromes(k as int) % (p as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}
fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn int_to_string(n: int) -> Seq<char>
    decreases n
{
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string(n / 10).add(seq![('0' as int + (n % 10)) as char])
    }
}

spec fn reverse_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]])
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else {
        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))
    }
}

spec fn sum_of_palindromes(k: int) -> int
    decreases k
{
    if k <= 0 {
        0
    } else if k == 1 {
        let s = int_to_string(1);
        let reversed = reverse_string(s);
        let palindrome = s.add(reversed);
        string_to_int(palindrome)
    } else {
        let s = int_to_string(k);
        let reversed = reverse_string(s);
        let palindrome = s.add(reversed);
        string_to_int(palindrome) + sum_of_palindromes(k - 1)
    }
}

spec fn valid_input(k: int, p: int) -> bool {
    k >= 1 && p >= 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i8, p: i8) -> (result: i8)
    requires
        valid_input(k as int, p as int),
    ensures
        0 <= result < p,
        result as int == (sum_of_palindromes(k as int) % (p as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}
fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]])\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn sum_of_palindromes(k: int) -> int\n    decreases k\n{\n    if k <= 0 {\n        0\n    } else if k == 1 {\n        let s = int_to_string(1);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome)\n    } else {\n        let s = int_to_string(k);\n        let reversed = reverse_string(s);\n        let palindrome = s.add(reversed);\n        string_to_int(palindrome) + sum_of_palindromes(k - 1)\n    }\n}\n\nspec fn valid_input(k: int, p: int) -> bool {\n    k >= 1 && p >= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, p: i8) -> (result: i8)\n    requires\n        valid_input(k as int, p as int),\n    ensures\n        0 <= result < p,\n        result as int == (sum_of_palindromes(k as int) % (p as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1009.rs,57,57,1.0,123.308,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {
    n >= 1 && k >= 1 && n <= 2*k &&
    l.len() == n &&
    forall|i: int, j: int| 0 <= i < l.len()-1 && j == i+1 ==> #[trigger] l[i] <= #[trigger] l[j] &&
    (forall|i: int| 0 <= i < l.len() ==> #[trigger] l[i] >= 0)
}

spec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {
    boxes.len() >= 1 &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] <= box_size) &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] >= 0)
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn max_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else if s.len() == 1 { 
        s[0] 
    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) { 
        s[0] 
    } else { 
        max_seq(s.subrange(1, s.len() as int)) 
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))
    ensures result >= 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {
    n >= 1 && k >= 1 && n <= 2*k &&
    l.len() == n &&
    forall|i: int, j: int| 0 <= i < l.len()-1 && j == i+1 ==> #[trigger] l[i] <= #[trigger] l[j] &&
    (forall|i: int| 0 <= i < l.len() ==> #[trigger] l[i] >= 0)
}

spec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {
    boxes.len() >= 1 &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] <= box_size) &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] >= 0)
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn max_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else if s.len() == 1 { 
        s[0] 
    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) { 
        s[0] 
    } else { 
        max_seq(s.subrange(1, s.len() as int)) 
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))
    ensures result >= 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && n <= 2*k &&\n    l.len() == n &&\n    forall|i: int, j: int| 0 <= i < l.len()-1 && j == i+1 ==> #[trigger] l[i] <= #[trigger] l[j] &&\n    (forall|i: int| 0 <= i < l.len() ==> #[trigger] l[i] >= 0)\n}\n\nspec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {\n    boxes.len() >= 1 &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] <= box_size) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] >= 0)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        s[0] \n    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) { \n        s[0] \n    } else { \n        max_seq(s.subrange(1, s.len() as int)) \n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1014.rs,53,53,1.0,122.192,True,0.7,True,"['vstd::prelude::', 'vstd::string::']",True,,,,,,"// <vc-preamble>
use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 2
}

spec fn is_win_for_white(n: int) -> bool {
    n % 2 == 0
}

spec fn is_win_for_black(n: int) -> bool {
    n % 2 == 1
}

spec fn optimal_white_move(n: int) -> (int, int)
    recommends valid_input(n) && is_win_for_white(n)
{
    (1, 2)
}

spec fn valid_result(n: int, result: String) -> bool
    recommends valid_input(n)
{
    if is_win_for_black(n) {
        result@ == ""black\n""@
    } else {
        result@ == ""white\n1 2\n""@
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: String)
    requires valid_input(n as int)
    ensures valid_result(n as int, result)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 2
}

spec fn is_win_for_white(n: int) -> bool {
    n % 2 == 0
}

spec fn is_win_for_black(n: int) -> bool {
    n % 2 == 1
}

spec fn optimal_white_move(n: int) -> (int, int)
    recommends valid_input(n) && is_win_for_white(n)
{
    (1, 2)
}

spec fn valid_result(n: int, result: String) -> bool
    recommends valid_input(n)
{
    if is_win_for_black(n) {
        result@ == ""black\n""@
    } else {
        result@ == ""white\n1 2\n""@
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: String)
    requires valid_input(n as int)
    ensures valid_result(n as int, result)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 2\n}\n\nspec fn is_win_for_white(n: int) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_win_for_black(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn optimal_white_move(n: int) -> (int, int)\n    recommends valid_input(n) && is_win_for_white(n)\n{\n    (1, 2)\n}\n\nspec fn valid_result(n: int, result: String) -> bool\n    recommends valid_input(n)\n{\n    if is_win_for_black(n) {\n        result@ == ""black\\n""@\n    } else {\n        result@ == ""white\\n1 2\\n""@\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: String)\n    requires valid_input(n as int)\n    ensures valid_result(n as int, result)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_102.rs,113,113,1.0,122.263,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    is_valid_integer_string(s) && 
    { let n = parse_integer(s); 0 <= n <= 99 }
}

spec fn correct_english_word(n: int) -> Seq<char> {
    if n == 0 { seq!['z', 'e', 'r', 'o'] }
    else if n == 1 { seq!['o', 'n', 'e'] }
    else if n == 2 { seq!['t', 'w', 'o'] }
    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }
    else if n == 4 { seq!['f', 'o', 'u', 'r'] }
    else if n == 5 { seq!['f', 'i', 'v', 'e'] }
    else if n == 6 { seq!['s', 'i', 'x'] }
    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }
    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }
    else if n == 9 { seq!['n', 'i', 'n', 'e'] }
    else if n == 10 { seq!['t', 'e', 'n'] }
    else if n == 11 { seq!['e', 'l', 'e', 'v', 'e', 'n'] }
    else if n == 12 { seq!['t', 'w', 'e', 'l', 'v', 'e'] }
    else if n == 13 { seq!['t', 'h', 'i', 'r', 't', 'e', 'e', 'n'] }
    else if n == 14 { seq!['f', 'o', 'u', 'r', 't', 'e', 'e', 'n'] }
    else if n == 15 { seq!['f', 'i', 'f', 't', 'e', 'e', 'n'] }
    else if n == 16 { seq!['s', 'i', 'x', 't', 'e', 'e', 'n'] }
    else if n == 17 { seq!['s', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n'] }
    else if n == 18 { seq!['e', 'i', 'g', 'h', 't', 'e', 'e', 'n'] }
    else if n == 19 { seq!['n', 'i', 'n', 'e', 't', 'e', 'e', 'n'] }
    else if n == 20 { seq!['t', 'w', 'e', 'n', 't', 'y'] }
    else if n == 30 { seq!['t', 'h', 'i', 'r', 't', 'y'] }
    else if n == 40 { seq!['f', 'o', 'r', 't', 'y'] }
    else if n == 50 { seq!['f', 'i', 'f', 't', 'y'] }
    else if n == 60 { seq!['s', 'i', 'x', 't', 'y'] }
    else if n == 70 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y'] }
    else if n == 80 { seq!['e', 'i', 'g', 'h', 't', 'y'] }
    else if n == 90 { seq!['n', 'i', 'n', 'e', 't', 'y'] }
    else if 21 <= n <= 29 { seq!['t', 'w', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }
    else if 31 <= n <= 39 { seq!['t', 'h', 'i', 'r', 't', 'y', '-'] + unit_word(n % 10) }
    else if 41 <= n <= 49 { seq!['f', 'o', 'r', 't', 'y', '-'] + unit_word(n % 10) }
    else if 51 <= n <= 59 { seq!['f', 'i', 'f', 't', 'y', '-'] + unit_word(n % 10) }
    else if 61 <= n <= 69 { seq!['s', 'i', 'x', 't', 'y', '-'] + unit_word(n % 10) }
    else if 71 <= n <= 79 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }
    else if 81 <= n <= 89 { seq!['e', 'i', 'g', 'h', 't', 'y', '-'] + unit_word(n % 10) }
    else { seq!['n', 'i', 'n', 'e', 't', 'y', '-'] + unit_word(n % 10) }
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    (s.len() >= 1 && s.len() <= 3 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9') ||
    (s.len() >= 2 && s.len() <= 4 && s[s.len() - 1] == '\n' && forall|i: int| 0 <= i < s.len() - 1 ==> '0' <= s[i] && s[i] <= '9')
}

spec fn parse_integer(s: Seq<char>) -> int {
    if s[s.len() - 1] == '\n' {
        parse_integer_helper(s.subrange(0, s.len() - 1))
    } else {
        parse_integer_helper(s)
    }
}

spec fn parse_integer_helper(s: Seq<char>) -> int {
    if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else if s.len() == 2 {
        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))
    } else {
        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))
    }
}

spec fn unit_word(n: int) -> Seq<char> {
    if n == 1 { seq!['o', 'n', 'e'] }
    else if n == 2 { seq!['t', 'w', 'o'] }
    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }
    else if n == 4 { seq!['f', 'o', 'u', 'r'] }
    else if n == 5 { seq!['f', 'i', 'v', 'e'] }
    else if n == 6 { seq!['s', 'i', 'x'] }
    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }
    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }
    else if n == 9 { seq!['n', 'i', 'n', 'e'] }
    else { seq![] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        stdin_input@.len() > 0,
        valid_input(stdin_input@),
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        ({
            let n = parse_integer(stdin_input@);
            result@ == correct_english_word(n) + seq!['\n']
        }),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    is_valid_integer_string(s) && 
    { let n = parse_integer(s); 0 <= n <= 99 }
}

spec fn correct_english_word(n: int) -> Seq<char> {
    if n == 0 { seq!['z', 'e', 'r', 'o'] }
    else if n == 1 { seq!['o', 'n', 'e'] }
    else if n == 2 { seq!['t', 'w', 'o'] }
    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }
    else if n == 4 { seq!['f', 'o', 'u', 'r'] }
    else if n == 5 { seq!['f', 'i', 'v', 'e'] }
    else if n == 6 { seq!['s', 'i', 'x'] }
    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }
    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }
    else if n == 9 { seq!['n', 'i', 'n', 'e'] }
    else if n == 10 { seq!['t', 'e', 'n'] }
    else if n == 11 { seq!['e', 'l', 'e', 'v', 'e', 'n'] }
    else if n == 12 { seq!['t', 'w', 'e', 'l', 'v', 'e'] }
    else if n == 13 { seq!['t', 'h', 'i', 'r', 't', 'e', 'e', 'n'] }
    else if n == 14 { seq!['f', 'o', 'u', 'r', 't', 'e', 'e', 'n'] }
    else if n == 15 { seq!['f', 'i', 'f', 't', 'e', 'e', 'n'] }
    else if n == 16 { seq!['s', 'i', 'x', 't', 'e', 'e', 'n'] }
    else if n == 17 { seq!['s', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n'] }
    else if n == 18 { seq!['e', 'i', 'g', 'h', 't', 'e', 'e', 'n'] }
    else if n == 19 { seq!['n', 'i', 'n', 'e', 't', 'e', 'e', 'n'] }
    else if n == 20 { seq!['t', 'w', 'e', 'n', 't', 'y'] }
    else if n == 30 { seq!['t', 'h', 'i', 'r', 't', 'y'] }
    else if n == 40 { seq!['f', 'o', 'r', 't', 'y'] }
    else if n == 50 { seq!['f', 'i', 'f', 't', 'y'] }
    else if n == 60 { seq!['s', 'i', 'x', 't', 'y'] }
    else if n == 70 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y'] }
    else if n == 80 { seq!['e', 'i', 'g', 'h', 't', 'y'] }
    else if n == 90 { seq!['n', 'i', 'n', 'e', 't', 'y'] }
    else if 21 <= n <= 29 { seq!['t', 'w', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }
    else if 31 <= n <= 39 { seq!['t', 'h', 'i', 'r', 't', 'y', '-'] + unit_word(n % 10) }
    else if 41 <= n <= 49 { seq!['f', 'o', 'r', 't', 'y', '-'] + unit_word(n % 10) }
    else if 51 <= n <= 59 { seq!['f', 'i', 'f', 't', 'y', '-'] + unit_word(n % 10) }
    else if 61 <= n <= 69 { seq!['s', 'i', 'x', 't', 'y', '-'] + unit_word(n % 10) }
    else if 71 <= n <= 79 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }
    else if 81 <= n <= 89 { seq!['e', 'i', 'g', 'h', 't', 'y', '-'] + unit_word(n % 10) }
    else { seq!['n', 'i', 'n', 'e', 't', 'y', '-'] + unit_word(n % 10) }
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    (s.len() >= 1 && s.len() <= 3 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9') ||
    (s.len() >= 2 && s.len() <= 4 && s[s.len() - 1] == '\n' && forall|i: int| 0 <= i < s.len() - 1 ==> '0' <= s[i] && s[i] <= '9')
}

spec fn parse_integer(s: Seq<char>) -> int {
    if s[s.len() - 1] == '\n' {
        parse_integer_helper(s.subrange(0, s.len() - 1))
    } else {
        parse_integer_helper(s)
    }
}

spec fn parse_integer_helper(s: Seq<char>) -> int {
    if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else if s.len() == 2 {
        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))
    } else {
        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))
    }
}

spec fn unit_word(n: int) -> Seq<char> {
    if n == 1 { seq!['o', 'n', 'e'] }
    else if n == 2 { seq!['t', 'w', 'o'] }
    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }
    else if n == 4 { seq!['f', 'o', 'u', 'r'] }
    else if n == 5 { seq!['f', 'i', 'v', 'e'] }
    else if n == 6 { seq!['s', 'i', 'x'] }
    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }
    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }
    else if n == 9 { seq!['n', 'i', 'n', 'e'] }
    else { seq![] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        stdin_input@.len() > 0,
        valid_input(stdin_input@),
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        ({
            let n = parse_integer(stdin_input@);
            result@ == correct_english_word(n) + seq!['\n']
        }),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    is_valid_integer_string(s) && \n    { let n = parse_integer(s); 0 <= n <= 99 }\n}\n\nspec fn correct_english_word(n: int) -> Seq<char> {\n    if n == 0 { seq!['z', 'e', 'r', 'o'] }\n    else if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else if n == 10 { seq!['t', 'e', 'n'] }\n    else if n == 11 { seq!['e', 'l', 'e', 'v', 'e', 'n'] }\n    else if n == 12 { seq!['t', 'w', 'e', 'l', 'v', 'e'] }\n    else if n == 13 { seq!['t', 'h', 'i', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 14 { seq!['f', 'o', 'u', 'r', 't', 'e', 'e', 'n'] }\n    else if n == 15 { seq!['f', 'i', 'f', 't', 'e', 'e', 'n'] }\n    else if n == 16 { seq!['s', 'i', 'x', 't', 'e', 'e', 'n'] }\n    else if n == 17 { seq!['s', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n'] }\n    else if n == 18 { seq!['e', 'i', 'g', 'h', 't', 'e', 'e', 'n'] }\n    else if n == 19 { seq!['n', 'i', 'n', 'e', 't', 'e', 'e', 'n'] }\n    else if n == 20 { seq!['t', 'w', 'e', 'n', 't', 'y'] }\n    else if n == 30 { seq!['t', 'h', 'i', 'r', 't', 'y'] }\n    else if n == 40 { seq!['f', 'o', 'r', 't', 'y'] }\n    else if n == 50 { seq!['f', 'i', 'f', 't', 'y'] }\n    else if n == 60 { seq!['s', 'i', 'x', 't', 'y'] }\n    else if n == 70 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y'] }\n    else if n == 80 { seq!['e', 'i', 'g', 'h', 't', 'y'] }\n    else if n == 90 { seq!['n', 'i', 'n', 'e', 't', 'y'] }\n    else if 21 <= n <= 29 { seq!['t', 'w', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 31 <= n <= 39 { seq!['t', 'h', 'i', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 41 <= n <= 49 { seq!['f', 'o', 'r', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 51 <= n <= 59 { seq!['f', 'i', 'f', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 61 <= n <= 69 { seq!['s', 'i', 'x', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 71 <= n <= 79 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }\n    else if 81 <= n <= 89 { seq!['e', 'i', 'g', 'h', 't', 'y', '-'] + unit_word(n % 10) }\n    else { seq!['n', 'i', 'n', 'e', 't', 'y', '-'] + unit_word(n % 10) }\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    (s.len() >= 1 && s.len() <= 3 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9') ||\n    (s.len() >= 2 && s.len() <= 4 && s[s.len() - 1] == '\\n' && forall|i: int| 0 <= i < s.len() - 1 ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    if s[s.len() - 1] == '\\n' {\n        parse_integer_helper(s.subrange(0, s.len() - 1))\n    } else {\n        parse_integer_helper(s)\n    }\n}\n\nspec fn parse_integer_helper(s: Seq<char>) -> int {\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() == 2 {\n        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))\n    } else {\n        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))\n    }\n}\n\nspec fn unit_word(n: int) -> Seq<char> {\n    if n == 1 { seq!['o', 'n', 'e'] }\n    else if n == 2 { seq!['t', 'w', 'o'] }\n    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['f', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['f', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['s', 'i', 'x'] }\n    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }\n    else if n == 9 { seq!['n', 'i', 'n', 'e'] }\n    else { seq![] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let n = parse_integer(stdin_input@);\n            result@ == correct_english_word(n) + seq!['\\n']\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1028.rs,57,57,1.0,122.851,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn comb2(n: int) -> int
  recommends n >= 0
{
  n * (n - 1) / 2
}

spec fn valid_input(n: int, m: int) -> bool
{
  1 <= m <= n
}

spec fn min_friendship_pairs(n: int, m: int) -> int
  recommends valid_input(n, m)
{
  let k = n / m;
  let p = n % m;
  p * comb2(k + 1) + (m - p) * comb2(k)
}

spec fn max_friendship_pairs(n: int, m: int) -> int
  recommends valid_input(n, m)
{
  comb2(n - m + 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8) -> (result: (i8, i8))
  requires valid_input(n as int, m as int)
  ensures 
      result.0 >= 0 &&
      result.1 >= 0 &&
      result.0 <= result.1 &&
      result.0 == min_friendship_pairs(n as int, m as int) &&
      result.1 == max_friendship_pairs(n as int, m as int)
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  (0, 0)
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn comb2(n: int) -> int
  recommends n >= 0
{
  n * (n - 1) / 2
}

spec fn valid_input(n: int, m: int) -> bool
{
  1 <= m <= n
}

spec fn min_friendship_pairs(n: int, m: int) -> int
  recommends valid_input(n, m)
{
  let k = n / m;
  let p = n % m;
  p * comb2(k + 1) + (m - p) * comb2(k)
}

spec fn max_friendship_pairs(n: int, m: int) -> int
  recommends valid_input(n, m)
{
  comb2(n - m + 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8) -> (result: (i8, i8))
  requires valid_input(n as int, m as int)
  ensures 
      result.0 >= 0 &&
      result.1 >= 0 &&
      result.0 <= result.1 &&
      result.0 == min_friendship_pairs(n as int, m as int) &&
      result.1 == max_friendship_pairs(n as int, m as int)
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  (0, 0)
  // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn comb2(n: int) -> int\n  recommends n >= 0\n{\n  n * (n - 1) / 2\n}\n\nspec fn valid_input(n: int, m: int) -> bool\n{\n  1 <= m <= n\n}\n\nspec fn min_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  let k = n / m;\n  let p = n % m;\n  p * comb2(k + 1) + (m - p) * comb2(k)\n}\n\nspec fn max_friendship_pairs(n: int, m: int) -> int\n  recommends valid_input(n, m)\n{\n  comb2(n - m + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: (i8, i8))\n  requires valid_input(n as int, m as int)\n  ensures \n      result.0 >= 0 &&\n      result.1 >= 0 &&\n      result.0 <= result.1 &&\n      result.0 == min_friendship_pairs(n as int, m as int) &&\n      result.1 == max_friendship_pairs(n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  (0, 0)\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1038.rs,61,61,1.0,122.762,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(a: int, b: int) -> bool {
        0 <= a <= b
    }
    
    spec fn xor_int(x: int, y: int) -> int
        decreases x + y
    {
        if x >= 0 && y >= 0 {
            if x == 0 && y == 0 { 0 }
            else if x == 0 { y }
            else if y == 0 { x }
            else {
                let bit_x = x % 2;
                let bit_y = y % 2;
                let xor_bit: int = if bit_x != bit_y { 1 } else { 0 };
                xor_bit + 2 * xor_int(x / 2, y / 2)
            }
        } else {
            0
        }
    }
    
    spec fn xor_range(a: int, b: int) -> int
        decreases b - a
    {
        if 0 <= a <= b {
            if a == b { a }
            else { xor_int(a, xor_range(a + 1, b)) }
        } else {
            0
        }
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i32, b: i32) -> (result: i32)
    requires 
        a >= 0,
        b >= 0,
        a <= b
    ensures 
        result >= 0,
        result as int == xor_range(a as int, b as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>

}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(a: int, b: int) -> bool {
        0 <= a <= b
    }
    
    spec fn xor_int(x: int, y: int) -> int
        decreases x + y
    {
        if x >= 0 && y >= 0 {
            if x == 0 && y == 0 { 0 }
            else if x == 0 { y }
            else if y == 0 { x }
            else {
                let bit_x = x % 2;
                let bit_y = y % 2;
                let xor_bit: int = if bit_x != bit_y { 1 } else { 0 };
                xor_bit + 2 * xor_int(x / 2, y / 2)
            }
        } else {
            0
        }
    }
    
    spec fn xor_range(a: int, b: int) -> int
        decreases b - a
    {
        if 0 <= a <= b {
            if a == b { a }
            else { xor_int(a, xor_range(a + 1, b)) }
        } else {
            0
        }
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i32, b: i32) -> (result: i32)
    requires 
        a >= 0,
        b >= 0,
        a <= b
    ensures 
        result >= 0,
        result as int == xor_range(a as int, b as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>

}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(a: int, b: int) -> bool {\n        0 <= a <= b\n    }\n    \n    spec fn xor_int(x: int, y: int) -> int\n        decreases x + y\n    {\n        if x >= 0 && y >= 0 {\n            if x == 0 && y == 0 { 0 }\n            else if x == 0 { y }\n            else if y == 0 { x }\n            else {\n                let bit_x = x % 2;\n                let bit_y = y % 2;\n                let xor_bit: int = if bit_x != bit_y { 1 } else { 0 };\n                xor_bit + 2 * xor_int(x / 2, y / 2)\n            }\n        } else {\n            0\n        }\n    }\n    \n    spec fn xor_range(a: int, b: int) -> int\n        decreases b - a\n    {\n        if 0 <= a <= b {\n            if a == b { a }\n            else { xor_int(a, xor_range(a + 1, b)) }\n        } else {\n            0\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i32, b: i32) -> (result: i32)\n    requires \n        a >= 0,\n        b >= 0,\n        a <= b\n    ensures \n        result >= 0,\n        result as int == xor_range(a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1045.rs,50,50,1.0,122.357,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn cubes_for_level(level: int) -> int
    recommends level >= 1
{
    level * (level + 1) / 2
}

spec fn total_cubes_for_height(h: int) -> int
    recommends h >= 1
{
    h * (h + 1) * (h + 2) / 6
}

spec fn valid_pyramid_height(n: int, h: int) -> bool {
    valid_input(n) && h >= 1 && 
    total_cubes_for_height(h) <= n &&
    total_cubes_for_height(h + 1) > n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures 
        result >= 1 &&
        valid_pyramid_height(n as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn cubes_for_level(level: int) -> int
    recommends level >= 1
{
    level * (level + 1) / 2
}

spec fn total_cubes_for_height(h: int) -> int
    recommends h >= 1
{
    h * (h + 1) * (h + 2) / 6
}

spec fn valid_pyramid_height(n: int, h: int) -> bool {
    valid_input(n) && h >= 1 && 
    total_cubes_for_height(h) <= n &&
    total_cubes_for_height(h + 1) > n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures 
        result >= 1 &&
        valid_pyramid_height(n as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn cubes_for_level(level: int) -> int\n    recommends level >= 1\n{\n    level * (level + 1) / 2\n}\n\nspec fn total_cubes_for_height(h: int) -> int\n    recommends h >= 1\n{\n    h * (h + 1) * (h + 2) / 6\n}\n\nspec fn valid_pyramid_height(n: int, h: int) -> bool {\n    valid_input(n) && h >= 1 && \n    total_cubes_for_height(h) <= n &&\n    total_cubes_for_height(h + 1) > n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures \n        result >= 1 &&\n        valid_pyramid_height(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1048.rs,50,50,1.0,122.424,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_commands(commands: Seq<char>) -> bool {
    forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize, commands: Vec<char>) -> (result: usize)
    requires 
        n >= 0,
        commands@.len() == n,
        valid_commands(commands@)
    ensures 
        result >= 0,
        result <= n,
        result % 2 == 0,
        result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + 
                         2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_commands(commands: Seq<char>) -> bool {
    forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize, commands: Vec<char>) -> (result: usize)
    requires 
        n >= 0,
        commands@.len() == n,
        valid_commands(commands@)
    ensures 
        result >= 0,
        result <= n,
        result % 2 == 0,
        result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + 
                         2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_commands(commands: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, commands: Vec<char>) -> (result: usize)\n    requires \n        n >= 0,\n        commands@.len() == n,\n        valid_commands(commands@)\n    ensures \n        result >= 0,\n        result <= n,\n        result % 2 == 0,\n        result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + \n                         2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1052.rs,56,56,1.0,122.722,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool {
    4 <= n <= 1000 && 1 <= k <= 4 && k < n
}

spec fn factorial(n: int) -> int
    decreases n
{
    if n <= 1 { 1 } else { n * factorial(n - 1) }
}

spec fn derangement(n: int) -> int
    decreases n
{
    if n <= 1 { 0 }
    else if n == 2 { 1 }
    else { (n - 1) * (derangement(n - 1) + derangement(n - 2)) }
}

spec fn binomial(n: int, k: int) -> int {
    if k > n { 0 }
    else if k == 0 || k == n { 1 }
    else { factorial(n) / (factorial(k) * factorial(n - k)) }
}

spec fn sum_binomial_derangement(n: int, k: int, i: int) -> int
    decreases n - k - i
{
    if i >= n - k { 0 }
    else { binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: i8)
    requires valid_input(n as int, k as int)
    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool {
    4 <= n <= 1000 && 1 <= k <= 4 && k < n
}

spec fn factorial(n: int) -> int
    decreases n
{
    if n <= 1 { 1 } else { n * factorial(n - 1) }
}

spec fn derangement(n: int) -> int
    decreases n
{
    if n <= 1 { 0 }
    else if n == 2 { 1 }
    else { (n - 1) * (derangement(n - 1) + derangement(n - 2)) }
}

spec fn binomial(n: int, k: int) -> int {
    if k > n { 0 }
    else if k == 0 || k == n { 1 }
    else { factorial(n) / (factorial(k) * factorial(n - k)) }
}

spec fn sum_binomial_derangement(n: int, k: int, i: int) -> int
    decreases n - k - i
{
    if i >= n - k { 0 }
    else { binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: i8)
    requires valid_input(n as int, k as int)
    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool {\n    4 <= n <= 1000 && 1 <= k <= 4 && k < n\n}\n\nspec fn factorial(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 1 } else { n * factorial(n - 1) }\n}\n\nspec fn derangement(n: int) -> int\n    decreases n\n{\n    if n <= 1 { 0 }\n    else if n == 2 { 1 }\n    else { (n - 1) * (derangement(n - 1) + derangement(n - 2)) }\n}\n\nspec fn binomial(n: int, k: int) -> int {\n    if k > n { 0 }\n    else if k == 0 || k == n { 1 }\n    else { factorial(n) / (factorial(k) * factorial(n - k)) }\n}\n\nspec fn sum_binomial_derangement(n: int, k: int, i: int) -> int\n    decreases n - k - i\n{\n    if i >= n - k { 0 }\n    else { binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires valid_input(n as int, k as int)\n    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1055.rs,52,52,1.0,122.801,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: Seq<int>) -> bool {
    a.len() > 0
}

spec fn is_sorted(x: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < x.len() ==> x[i] <= x[j]
}

spec fn thanos_sort(x: Seq<int>) -> int
    recommends x.len() > 0
    decreases x.len()
{
    let len = x.len() as int;
    if is_sorted(x) {
        len
    } else {
        let first_half = x.subrange(0, len / 2);
        let second_half = x.subrange(len / 2, len);
        let left_result = thanos_sort(first_half);
        let right_result = thanos_sort(second_half);
        if left_result > right_result { left_result } else { right_result }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Vec<i8>) -> (result: usize)
    requires 
        valid_input(a@.map(|i, x| x as int)),
    ensures 
        result as int == thanos_sort(a@.map(|i, x| x as int)),
        1 <= result <= a.len(),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: Seq<int>) -> bool {
    a.len() > 0
}

spec fn is_sorted(x: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < x.len() ==> x[i] <= x[j]
}

spec fn thanos_sort(x: Seq<int>) -> int
    recommends x.len() > 0
    decreases x.len()
{
    let len = x.len() as int;
    if is_sorted(x) {
        len
    } else {
        let first_half = x.subrange(0, len / 2);
        let second_half = x.subrange(len / 2, len);
        let left_result = thanos_sort(first_half);
        let right_result = thanos_sort(second_half);
        if left_result > right_result { left_result } else { right_result }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Vec<i8>) -> (result: usize)
    requires 
        valid_input(a@.map(|i, x| x as int)),
    ensures 
        result as int == thanos_sort(a@.map(|i, x| x as int)),
        1 <= result <= a.len(),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>) -> bool {\n    a.len() > 0\n}\n\nspec fn is_sorted(x: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < x.len() ==> x[i] <= x[j]\n}\n\nspec fn thanos_sort(x: Seq<int>) -> int\n    recommends x.len() > 0\n    decreases x.len()\n{\n    let len = x.len() as int;\n    if is_sorted(x) {\n        len\n    } else {\n        let first_half = x.subrange(0, len / 2);\n        let second_half = x.subrange(len / 2, len);\n        let left_result = thanos_sort(first_half);\n        let right_result = thanos_sort(second_half);\n        if left_result > right_result { left_result } else { right_result }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: usize)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result as int == thanos_sort(a@.map(|i, x| x as int)),\n        1 <= result <= a.len(),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_106.rs,57,57,1.0,122.386,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {
  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b
}

spec fn get_entrance(apt: int, m: int, k: int) -> int
  recommends apt >= 1, m > 0 && k > 0
{
  (apt - 1) / (m * k)
}

spec fn get_floor(apt: int, m: int, k: int) -> int
  recommends apt >= 1, m > 0 && k > 0
{
  ((apt - 1) - get_entrance(apt, m, k) * m * k) / k
}

spec fn min_travel_time(floors: int) -> int
  recommends floors >= 0
{
  let stair_time = 5 * floors;
  let elevator_time = 10 + floors;
  if stair_time < elevator_time { stair_time } else { elevator_time }
}

spec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int
  recommends n > 0
{
  let clockwise = (entrance_b - entrance_a + n) % n;
  let counterclockwise = (entrance_a - entrance_b + n) % n;
  if clockwise <= counterclockwise { clockwise } else { counterclockwise }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8, a: i8, b: i8) -> (result: i8)
  requires valid_input(n as int, m as int, k as int, a as int, b as int)
  ensures result as int >= 0
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {
  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b
}

spec fn get_entrance(apt: int, m: int, k: int) -> int
  recommends apt >= 1, m > 0 && k > 0
{
  (apt - 1) / (m * k)
}

spec fn get_floor(apt: int, m: int, k: int) -> int
  recommends apt >= 1, m > 0 && k > 0
{
  ((apt - 1) - get_entrance(apt, m, k) * m * k) / k
}

spec fn min_travel_time(floors: int) -> int
  recommends floors >= 0
{
  let stair_time = 5 * floors;
  let elevator_time = 10 + floors;
  if stair_time < elevator_time { stair_time } else { elevator_time }
}

spec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int
  recommends n > 0
{
  let clockwise = (entrance_b - entrance_a + n) % n;
  let counterclockwise = (entrance_a - entrance_b + n) % n;
  if clockwise <= counterclockwise { clockwise } else { counterclockwise }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8, a: i8, b: i8) -> (result: i8)
  requires valid_input(n as int, m as int, k as int, a as int, b as int)
  ensures result as int >= 0
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {\n  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b\n}\n\nspec fn get_entrance(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  (apt - 1) / (m * k)\n}\n\nspec fn get_floor(apt: int, m: int, k: int) -> int\n  recommends apt >= 1, m > 0 && k > 0\n{\n  ((apt - 1) - get_entrance(apt, m, k) * m * k) / k\n}\n\nspec fn min_travel_time(floors: int) -> int\n  recommends floors >= 0\n{\n  let stair_time = 5 * floors;\n  let elevator_time = 10 + floors;\n  if stair_time < elevator_time { stair_time } else { elevator_time }\n}\n\nspec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int\n  recommends n > 0\n{\n  let clockwise = (entrance_b - entrance_a + n) % n;\n  let counterclockwise = (entrance_a - entrance_b + n) % n;\n  if clockwise <= counterclockwise { clockwise } else { counterclockwise }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, a: i8, b: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int, a as int, b as int)\n  ensures result as int >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1071.rs,54,54,1.0,122.697,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {
    a.len() >= 0 && b.len() >= 0 &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 0) &&
    (forall|j: int| 0 <= j < b.len() ==> b[j] >= 0) &&
    n >= 1
}

spec fn sum_seq(s: Seq<int>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.drop_first()) }
}

spec fn shelves_needed(total: int, capacity: int) -> int
    recommends capacity > 0
{
    if total == 0 { 0 } else { (total - 1) / capacity + 1 }
}

spec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool
    recommends valid_input(a, b, n)
{
    let total_cups = sum_seq(a);
    let total_medals = sum_seq(b);
    let shelves_for_cups = shelves_needed(total_cups, 5);
    let shelves_for_medals = shelves_needed(total_medals, 10);
    shelves_for_cups + shelves_for_medals <= n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Vec<i8>, b: Vec<i8>, n: i8) -> (result: String)
    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)
    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { ""YES""@ } else { ""NO""@ })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {
    a.len() >= 0 && b.len() >= 0 &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 0) &&
    (forall|j: int| 0 <= j < b.len() ==> b[j] >= 0) &&
    n >= 1
}

spec fn sum_seq(s: Seq<int>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.drop_first()) }
}

spec fn shelves_needed(total: int, capacity: int) -> int
    recommends capacity > 0
{
    if total == 0 { 0 } else { (total - 1) / capacity + 1 }
}

spec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool
    recommends valid_input(a, b, n)
{
    let total_cups = sum_seq(a);
    let total_medals = sum_seq(b);
    let shelves_for_cups = shelves_needed(total_cups, 5);
    let shelves_for_medals = shelves_needed(total_medals, 10);
    shelves_for_cups + shelves_for_medals <= n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Vec<i8>, b: Vec<i8>, n: i8) -> (result: String)
    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)
    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { ""YES""@ } else { ""NO""@ })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {\n    a.len() >= 0 && b.len() >= 0 &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 0) &&\n    (forall|j: int| 0 <= j < b.len() ==> b[j] >= 0) &&\n    n >= 1\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.drop_first()) }\n}\n\nspec fn shelves_needed(total: int, capacity: int) -> int\n    recommends capacity > 0\n{\n    if total == 0 { 0 } else { (total - 1) / capacity + 1 }\n}\n\nspec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool\n    recommends valid_input(a, b, n)\n{\n    let total_cups = sum_seq(a);\n    let total_medals = sum_seq(b);\n    let shelves_for_cups = shelves_needed(total_cups, 5);\n    let shelves_for_medals = shelves_needed(total_medals, 10);\n    shelves_for_cups + shelves_for_medals <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>, b: Vec<i8>, n: i8) -> (result: String)\n    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)\n    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { ""YES""@ } else { ""NO""@ })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1081.rs,55,55,1.0,124.364,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 99
}

spec fn expected_result(n: int) -> bool
    recommends valid_input(n)
{
    if n < 12 {
        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 {
            false
        } else {
            true
        }
    } else if 12 < n < 30 {
        false
    } else if 69 < n < 80 {
        false
    } else if 89 < n {
        false
    } else {
        let last_digit = n % 10;
        if last_digit != 1 && last_digit != 7 && last_digit != 9 {
            true
        } else {
            false
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: bool)
requires 
    valid_input(n as int),
ensures 
    result == expected_result(n as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    false
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 99
}

spec fn expected_result(n: int) -> bool
    recommends valid_input(n)
{
    if n < 12 {
        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 {
            false
        } else {
            true
        }
    } else if 12 < n < 30 {
        false
    } else if 69 < n < 80 {
        false
    } else if 89 < n {
        false
    } else {
        let last_digit = n % 10;
        if last_digit != 1 && last_digit != 7 && last_digit != 9 {
            true
        } else {
            false
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: bool)
requires 
    valid_input(n as int),
ensures 
    result == expected_result(n as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    false
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 99\n}\n\nspec fn expected_result(n: int) -> bool\n    recommends valid_input(n)\n{\n    if n < 12 {\n        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 {\n            false\n        } else {\n            true\n        }\n    } else if 12 < n < 30 {\n        false\n    } else if 69 < n < 80 {\n        false\n    } else if 89 < n {\n        false\n    } else {\n        let last_digit = n % 10;\n        if last_digit != 1 && last_digit != 7 && last_digit != 9 {\n            true\n        } else {\n            false\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: bool)\nrequires \n    valid_input(n as int),\nensures \n    result == expected_result(n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1085.rs,69,69,1.0,122.518,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat) -> bool {
    n > 0
}

spec fn reduce_by_divisor(n: nat, d: nat) -> nat {
    if n > 0 && d > 1 && n % d == 0 && n >= d {
        n / d
    } else {
        n
    }
}

spec fn count_divisors(n: int) -> nat {
    if n > 0 {
        Set::new(|d: int| 1 <= d <= n && n % d == 0).len()
    } else {
        0
    }
}

spec fn count_special_divisors(n: nat) -> nat {
    if n > 0 {
        Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()
    } else {
        0
    }
}

spec fn count_valid_k_values(n: nat) -> int {
    if n > 0 {
        if n == 1 {
            -1
        } else {
            count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1
        }
    } else {
        -1
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8) -> (result: i8)
    requires 
        valid_input(n as nat)
    ensures 
        result as int == count_valid_k_values(n as nat),
        n == 1 ==> result as int == -1,
        n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,
        result as int >= -1
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat) -> bool {
    n > 0
}

spec fn reduce_by_divisor(n: nat, d: nat) -> nat {
    if n > 0 && d > 1 && n % d == 0 && n >= d {
        n / d
    } else {
        n
    }
}

spec fn count_divisors(n: int) -> nat {
    if n > 0 {
        Set::new(|d: int| 1 <= d <= n && n % d == 0).len()
    } else {
        0
    }
}

spec fn count_special_divisors(n: nat) -> nat {
    if n > 0 {
        Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()
    } else {
        0
    }
}

spec fn count_valid_k_values(n: nat) -> int {
    if n > 0 {
        if n == 1 {
            -1
        } else {
            count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1
        }
    } else {
        -1
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8) -> (result: i8)
    requires 
        valid_input(n as nat)
    ensures 
        result as int == count_valid_k_values(n as nat),
        n == 1 ==> result as int == -1,
        n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,
        result as int >= -1
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn reduce_by_divisor(n: nat, d: nat) -> nat {\n    if n > 0 && d > 1 && n % d == 0 && n >= d {\n        n / d\n    } else {\n        n\n    }\n}\n\nspec fn count_divisors(n: int) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 1 <= d <= n && n % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_special_divisors(n: nat) -> nat {\n    if n > 0 {\n        Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()\n    } else {\n        0\n    }\n}\n\nspec fn count_valid_k_values(n: nat) -> int {\n    if n > 0 {\n        if n == 1 {\n            -1\n        } else {\n            count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1\n        }\n    } else {\n        -1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8) -> (result: i8)\n    requires \n        valid_input(n as nat)\n    ensures \n        result as int == count_valid_k_values(n as nat),\n        n == 1 ==> result as int == -1,\n        n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,\n        result as int >= -1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1096.rs,65,65,1.0,122.697,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(position: Seq<char>) -> bool {
  position.len() == 2 && 
  'a' <= position[0] && position[0] <= 'h' && 
  '1' <= position[1] && position[1] <= '8'
}

spec fn is_corner(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  (position[0] == 'a' || position[0] == 'h') && 
  (position[1] == '1' || position[1] == '8')
}

spec fn is_edge(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  (position[0] == 'a' || position[0] == 'h' || 
   position[1] == '1' || position[1] == '8') && 
  !is_corner(position)
}

spec fn is_interior(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  !is_corner(position) && !is_edge(position)
}

spec fn valid_moves(position: Seq<char>) -> int
  recommends valid_input(position)
{
  if is_corner(position) { 3 }
  else if is_edge(position) { 5 }
  else { 8 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(position: Vec<char>) -> (moves: i8)
  requires 
    valid_input(position@),
  ensures 
    moves as int == valid_moves(position@),
    is_corner(position@) ==> moves == 3,
    is_edge(position@) ==> moves == 5,
    is_interior(position@) ==> moves == 8,
    moves == 3 || moves == 5 || moves == 8,
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(position: Seq<char>) -> bool {
  position.len() == 2 && 
  'a' <= position[0] && position[0] <= 'h' && 
  '1' <= position[1] && position[1] <= '8'
}

spec fn is_corner(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  (position[0] == 'a' || position[0] == 'h') && 
  (position[1] == '1' || position[1] == '8')
}

spec fn is_edge(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  (position[0] == 'a' || position[0] == 'h' || 
   position[1] == '1' || position[1] == '8') && 
  !is_corner(position)
}

spec fn is_interior(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  !is_corner(position) && !is_edge(position)
}

spec fn valid_moves(position: Seq<char>) -> int
  recommends valid_input(position)
{
  if is_corner(position) { 3 }
  else if is_edge(position) { 5 }
  else { 8 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(position: Vec<char>) -> (moves: i8)
  requires 
    valid_input(position@),
  ensures 
    moves as int == valid_moves(position@),
    is_corner(position@) ==> moves == 3,
    is_edge(position@) ==> moves == 5,
    is_interior(position@) ==> moves == 8,
    moves == 3 || moves == 5 || moves == 8,
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(position: Seq<char>) -> bool {\n  position.len() == 2 && \n  'a' <= position[0] && position[0] <= 'h' && \n  '1' <= position[1] && position[1] <= '8'\n}\n\nspec fn is_corner(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h') && \n  (position[1] == '1' || position[1] == '8')\n}\n\nspec fn is_edge(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  (position[0] == 'a' || position[0] == 'h' || \n   position[1] == '1' || position[1] == '8') && \n  !is_corner(position)\n}\n\nspec fn is_interior(position: Seq<char>) -> bool\n  recommends valid_input(position)\n{\n  !is_corner(position) && !is_edge(position)\n}\n\nspec fn valid_moves(position: Seq<char>) -> int\n  recommends valid_input(position)\n{\n  if is_corner(position) { 3 }\n  else if is_edge(position) { 5 }\n  else { 8 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(position: Vec<char>) -> (moves: i8)\n  requires \n    valid_input(position@),\n  ensures \n    moves as int == valid_moves(position@),\n    is_corner(position@) ==> moves == 3,\n    is_edge(position@) ==> moves == 5,\n    is_interior(position@) ==> moves == 8,\n    moves == 3 || moves == 5 || moves == 8,\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1102.rs,64,64,1.0,122.56,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {
    n > 0 && 1 <= a <= n && x.len() == n && 
    forall|i: int| 0 <= i < n ==> (x[i] == 0 || x[i] == 1)
}

spec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int
    decreases n + 1 - distance
{
    if distance > n { 
        0
    } else {
        let le = a_idx - distance;
        let rg = a_idx + distance;
        let le_valid = le >= 0 && le < n;
        let rg_valid = rg >= 0 && rg < n;
        let current_caught = if !le_valid && !rg_valid {
            0
        } else if le_valid && !rg_valid {
            x[le]
        } else if !le_valid && rg_valid {
            x[rg]
        } else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 {
            2
        } else {
            0
        };
        if !le_valid && !rg_valid {
            current_caught
        } else {
            current_caught + sum_criminals_caught(n, a_idx, x, distance + 1)
        }
    }
}

spec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {
    x[a-1] + sum_criminals_caught(n, a-1, x, 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, x: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))
    ensures 
        result >= 0 &&
        result as int == total_criminals_caught(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {
    n > 0 && 1 <= a <= n && x.len() == n && 
    forall|i: int| 0 <= i < n ==> (x[i] == 0 || x[i] == 1)
}

spec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int
    decreases n + 1 - distance
{
    if distance > n { 
        0
    } else {
        let le = a_idx - distance;
        let rg = a_idx + distance;
        let le_valid = le >= 0 && le < n;
        let rg_valid = rg >= 0 && rg < n;
        let current_caught = if !le_valid && !rg_valid {
            0
        } else if le_valid && !rg_valid {
            x[le]
        } else if !le_valid && rg_valid {
            x[rg]
        } else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 {
            2
        } else {
            0
        };
        if !le_valid && !rg_valid {
            current_caught
        } else {
            current_caught + sum_criminals_caught(n, a_idx, x, distance + 1)
        }
    }
}

spec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {
    x[a-1] + sum_criminals_caught(n, a-1, x, 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, x: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))
    ensures 
        result >= 0 &&
        result as int == total_criminals_caught(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {\n    n > 0 && 1 <= a <= n && x.len() == n && \n    forall|i: int| 0 <= i < n ==> (x[i] == 0 || x[i] == 1)\n}\n\nspec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int\n    decreases n + 1 - distance\n{\n    if distance > n { \n        0\n    } else {\n        let le = a_idx - distance;\n        let rg = a_idx + distance;\n        let le_valid = le >= 0 && le < n;\n        let rg_valid = rg >= 0 && rg < n;\n        let current_caught = if !le_valid && !rg_valid {\n            0\n        } else if le_valid && !rg_valid {\n            x[le]\n        } else if !le_valid && rg_valid {\n            x[rg]\n        } else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 {\n            2\n        } else {\n            0\n        };\n        if !le_valid && !rg_valid {\n            current_caught\n        } else {\n            current_caught + sum_criminals_caught(n, a_idx, x, distance + 1)\n        }\n    }\n}\n\nspec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {\n    x[a-1] + sum_criminals_caught(n, a-1, x, 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, x: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n    ensures \n        result >= 0 &&\n        result as int == total_criminals_caught(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1109.rs,63,63,1.0,122.724,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {
    1 <= k <= n <= 100 &&
    n % k == 0 &&
    a.len() == n &&
    forall|i: int| 0 <= i < a.len() ==> a[i] == 1 || a[i] == 2
}

spec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 1).len() as int
}

spec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 2).len() as int
}

spec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    let count1 = count_ones_in_column(a, n, k, col);
    let count2 = count_twos_in_column(a, n, k, col);
    if count1 < count2 { count1 } else { count2 }
}

spec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int
    decreases k - col when col <= k
{
    if col >= k {
        0
    } else {
        min_changes_for_column(a, n, k, col) + sum_min_changes_helper(a, n, k, col + 1)
    }
}

spec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {
    sum_min_changes_helper(a, n, k, 0)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, a@.map(|i, v| v as int))
    ensures 
        0 <= result as int <= n as int,
        result as int == sum_min_changes_for_all_columns(a@.map(|i, v| v as int), n as int, k as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {
    1 <= k <= n <= 100 &&
    n % k == 0 &&
    a.len() == n &&
    forall|i: int| 0 <= i < a.len() ==> a[i] == 1 || a[i] == 2
}

spec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 1).len() as int
}

spec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 2).len() as int
}

spec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    let count1 = count_ones_in_column(a, n, k, col);
    let count2 = count_twos_in_column(a, n, k, col);
    if count1 < count2 { count1 } else { count2 }
}

spec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int
    decreases k - col when col <= k
{
    if col >= k {
        0
    } else {
        min_changes_for_column(a, n, k, col) + sum_min_changes_helper(a, n, k, col + 1)
    }
}

spec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {
    sum_min_changes_helper(a, n, k, 0)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, a@.map(|i, v| v as int))
    ensures 
        0 <= result as int <= n as int,
        result as int == sum_min_changes_for_all_columns(a@.map(|i, v| v as int), n as int, k as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    1 <= k <= n <= 100 &&\n    n % k == 0 &&\n    a.len() == n &&\n    forall|i: int| 0 <= i < a.len() ==> a[i] == 1 || a[i] == 2\n}\n\nspec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 1).len() as int\n}\n\nspec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 2).len() as int\n}\n\nspec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {\n    let count1 = count_ones_in_column(a, n, k, col);\n    let count2 = count_twos_in_column(a, n, k, col);\n    if count1 < count2 { count1 } else { count2 }\n}\n\nspec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int\n    decreases k - col when col <= k\n{\n    if col >= k {\n        0\n    } else {\n        min_changes_for_column(a, n, k, col) + sum_min_changes_helper(a, n, k, col + 1)\n    }\n}\n\nspec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {\n    sum_min_changes_helper(a, n, k, 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, a@.map(|i, v| v as int))\n    ensures \n        0 <= result as int <= n as int,\n        result as int == sum_min_changes_for_all_columns(a@.map(|i, v| v as int), n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1117.rs,69,69,1.0,122.517,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {
    if rectangles.len() <= 1 {
        true
    } else {
        can_form_non_ascending_sequence_helper(rectangles, 1, max_spec(rectangles[0].0, rectangles[0].1))
    }
}

spec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool
    recommends 0 <= index <= rectangles.len()
    decreases rectangles.len() - index
{
    if index >= rectangles.len() {
        true
    } else {
        let a = rectangles[index].0;
        let b = rectangles[index].1;
        let min_dim = min_spec(a, b);
        let max_dim = max_spec(a, b);

        if min_dim > prev_height {
            false
        } else if min_dim <= prev_height < max_dim {
            can_form_non_ascending_sequence_helper(rectangles, index + 1, min_dim)
        } else {
            can_form_non_ascending_sequence_helper(rectangles, index + 1, max_dim)
        }
    }
}

spec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {
    /* Placeholder for parsing logic */
    seq![]
}

spec fn min_spec(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn max_spec(a: int, b: int) -> int {
    if a >= b { a } else { b }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures result@ == ""YES""@ || result@ == ""NO""@
    /* ensures result@ == ""YES""@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {
    if rectangles.len() <= 1 {
        true
    } else {
        can_form_non_ascending_sequence_helper(rectangles, 1, max_spec(rectangles[0].0, rectangles[0].1))
    }
}

spec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool
    recommends 0 <= index <= rectangles.len()
    decreases rectangles.len() - index
{
    if index >= rectangles.len() {
        true
    } else {
        let a = rectangles[index].0;
        let b = rectangles[index].1;
        let min_dim = min_spec(a, b);
        let max_dim = max_spec(a, b);

        if min_dim > prev_height {
            false
        } else if min_dim <= prev_height < max_dim {
            can_form_non_ascending_sequence_helper(rectangles, index + 1, min_dim)
        } else {
            can_form_non_ascending_sequence_helper(rectangles, index + 1, max_dim)
        }
    }
}

spec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {
    /* Placeholder for parsing logic */
    seq![]
}

spec fn min_spec(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn max_spec(a: int, b: int) -> int {
    if a >= b { a } else { b }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures result@ == ""YES""@ || result@ == ""NO""@
    /* ensures result@ == ""YES""@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {\n    if rectangles.len() <= 1 {\n        true\n    } else {\n        can_form_non_ascending_sequence_helper(rectangles, 1, max_spec(rectangles[0].0, rectangles[0].1))\n    }\n}\n\nspec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool\n    recommends 0 <= index <= rectangles.len()\n    decreases rectangles.len() - index\n{\n    if index >= rectangles.len() {\n        true\n    } else {\n        let a = rectangles[index].0;\n        let b = rectangles[index].1;\n        let min_dim = min_spec(a, b);\n        let max_dim = max_spec(a, b);\n\n        if min_dim > prev_height {\n            false\n        } else if min_dim <= prev_height < max_dim {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, min_dim)\n        } else {\n            can_form_non_ascending_sequence_helper(rectangles, index + 1, max_dim)\n        }\n    }\n}\n\nspec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {\n    /* Placeholder for parsing logic */\n    seq![]\n}\n\nspec fn min_spec(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn max_spec(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures result@ == ""YES""@ || result@ == ""NO""@\n    /* ensures result@ == ""YES""@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1124.rs,74,74,1.0,122.627,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(values: Seq<int>) -> bool {
    values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0
}

spec fn gcd(a: int, b: int) -> int
    decreases (if a >= b { a } else { b }) when a > 0 && b > 0
{
    if a > 0 && b > 0 {
        if a == b {
            a
        } else if a > b {
            gcd(a - b, b)
        } else {
            gcd(a, b - a)
        }
    } else {
        1
    }
}

spec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int
    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0
{
    if 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {
        if index == values.len() {
            current
        } else {
            gcd_seq(values, index + 1, gcd(current, values[index as int]))
        }
    } else {
        1
    }
}

spec fn gcd_of_all(values: Seq<int>) -> int {
    if values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {
        gcd_seq(values, 1, values[0])
    } else {
        1
    }
}
// </vc-preamble>

// <vc-helpers>
spec fn values_as_int(values: Seq<i8>) -> Seq<int> {
    values.map(|i, x| x as int)
}
// </vc-helpers>

// <vc-spec>
fn solve(values: Vec<i8>) -> (result: i8)
    requires valid_input(values_as_int(values@)) && values.len() <= 127
    ensures 
        result > 0 &&
        result as int == gcd_of_all(values_as_int(values@)) &&
        forall|i: int| 0 <= i < values@.len() ==> (values@[i] as int) % (result as int) == 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(values: Seq<int>) -> bool {
    values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0
}

spec fn gcd(a: int, b: int) -> int
    decreases (if a >= b { a } else { b }) when a > 0 && b > 0
{
    if a > 0 && b > 0 {
        if a == b {
            a
        } else if a > b {
            gcd(a - b, b)
        } else {
            gcd(a, b - a)
        }
    } else {
        1
    }
}

spec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int
    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0
{
    if 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {
        if index == values.len() {
            current
        } else {
            gcd_seq(values, index + 1, gcd(current, values[index as int]))
        }
    } else {
        1
    }
}

spec fn gcd_of_all(values: Seq<int>) -> int {
    if values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {
        gcd_seq(values, 1, values[0])
    } else {
        1
    }
}
// </vc-preamble>

// <vc-helpers>
spec fn values_as_int(values: Seq<i8>) -> Seq<int> {
    values.map(|i, x| x as int)
}
// </vc-helpers>

// <vc-spec>
fn solve(values: Vec<i8>) -> (result: i8)
    requires valid_input(values_as_int(values@)) && values.len() <= 127
    ensures 
        result > 0 &&
        result as int == gcd_of_all(values_as_int(values@)) &&
        forall|i: int| 0 <= i < values@.len() ==> (values@[i] as int) % (result as int) == 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(values: Seq<int>) -> bool {\n    values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if a >= b { a } else { b }) when a > 0 && b > 0\n{\n    if a > 0 && b > 0 {\n        if a == b {\n            a\n        } else if a > b {\n            gcd(a - b, b)\n        } else {\n            gcd(a, b - a)\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int\n    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0\n{\n    if 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        if index == values.len() {\n            current\n        } else {\n            gcd_seq(values, index + 1, gcd(current, values[index as int]))\n        }\n    } else {\n        1\n    }\n}\n\nspec fn gcd_of_all(values: Seq<int>) -> int {\n    if values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {\n        gcd_seq(values, 1, values[0])\n    } else {\n        1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn values_as_int(values: Seq<i8>) -> Seq<int> {\n    values.map(|i, x| x as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(values: Vec<i8>) -> (result: i8)\n    requires valid_input(values_as_int(values@)) && values.len() <= 127\n    ensures \n        result > 0 &&\n        result as int == gcd_of_all(values_as_int(values@)) &&\n        forall|i: int| 0 <= i < values@.len() ==> (values@[i] as int) % (result as int) == 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1138.rs,69,69,1.0,122.802,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    count_char_helper(s, c, 0, 0)
}

spec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        count
    } else if s.index(index) == c {
        count_char_helper(s, c, index + 1, count + 1)
    } else {
        count_char_helper(s, c, index + 1, count)
    }
}

spec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        0
    } else if s.index(index) == c {
        1 + count_char_from_index(s, c, index + 1)
    } else {
        count_char_from_index(s, c, index + 1)
    }
}

spec fn correct_result(s: Seq<char>, result: int) -> bool {
    (s.len() % 2 != 0 ==> result == -1) &&
    (s.len() % 2 == 0 ==> result >= 0) &&
    (s.len() % 2 == 0 ==> result <= s.len() / 2) &&
    (s.len() % 2 == 0 ==> result == (abs(count_char(s, 'L') - count_char(s, 'R')) + abs(count_char(s, 'U') - count_char(s, 'D'))) / 2)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures correct_result(s@, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    count_char_helper(s, c, 0, 0)
}

spec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        count
    } else if s.index(index) == c {
        count_char_helper(s, c, index + 1, count + 1)
    } else {
        count_char_helper(s, c, index + 1, count)
    }
}

spec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        0
    } else if s.index(index) == c {
        1 + count_char_from_index(s, c, index + 1)
    } else {
        count_char_from_index(s, c, index + 1)
    }
}

spec fn correct_result(s: Seq<char>, result: int) -> bool {
    (s.len() % 2 != 0 ==> result == -1) &&
    (s.len() % 2 == 0 ==> result >= 0) &&
    (s.len() % 2 == 0 ==> result <= s.len() / 2) &&
    (s.len() % 2 == 0 ==> result == (abs(count_char(s, 'L') - count_char(s, 'R')) + abs(count_char(s, 'U') - count_char(s, 'D'))) / 2)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures correct_result(s@, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s.index(index) == c {\n        count_char_helper(s, c, index + 1, count + 1)\n    } else {\n        count_char_helper(s, c, index + 1, count)\n    }\n}\n\nspec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        0\n    } else if s.index(index) == c {\n        1 + count_char_from_index(s, c, index + 1)\n    } else {\n        count_char_from_index(s, c, index + 1)\n    }\n}\n\nspec fn correct_result(s: Seq<char>, result: int) -> bool {\n    (s.len() % 2 != 0 ==> result == -1) &&\n    (s.len() % 2 == 0 ==> result >= 0) &&\n    (s.len() % 2 == 0 ==> result <= s.len() / 2) &&\n    (s.len() % 2 == 0 ==> result == (abs(count_char(s, 'L') - count_char(s, 'R')) + abs(count_char(s, 'U') - count_char(s, 'D'))) / 2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures correct_result(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1142.rs,111,111,1.0,153.516,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
#[derive(PartialEq, Eq)]
struct Wave {
    start_time: nat,
    end_time: nat,
    monsters: nat,
}

spec fn valid_waves(waves: Seq<Wave>) -> bool {
    forall|i: int| 0 <= i < waves.len() ==> 
        #[trigger] waves[i].start_time <= waves[i].end_time &&
        waves[i].monsters > 0 &&
        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)
}

spec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {
    k > 0 && 
    forall|i: int| 0 <= i < waves.len() ==> 
        #[trigger] can_solve_wave(waves, i as nat, k)
}

spec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {
    &&& wave_index < waves.len()
    &&& k > 0
    &&& {
        let wave = waves[wave_index as int];
        let time_available = wave.end_time - wave.start_time + 1;
        let max_possible_shots = time_available * k;
        wave.monsters <= max_possible_shots &&
        (wave_index == 0 || can_reach_wave_in_time(waves, wave_index, k))
    }
}

spec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {
    &&& wave_index > 0 && wave_index < waves.len()
    &&& k > 0
    &&& {
        let prev_wave = waves[wave_index as int - 1];
        let curr_wave = waves[wave_index as int];
        let time_gap = curr_wave.start_time - prev_wave.end_time;
        let reloads_needed = calculate_reloads_needed(prev_wave.monsters, k);
        reloads_needed <= time_gap
    }
}

spec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {
    if k > 0 {
        if monsters <= k { 
            0 
        } else { 
            ((monsters - 1) as int / k as int) as nat
        }
    } else {
        0
    }
}

spec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {
    if k > 0 && valid_waves(waves) && can_solve_all_waves(waves, k) {
        calculate_minimum_bullets_helper(waves, k, 0, k)
    } else {
        0
    }
}

spec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat
    decreases waves.len() - wave_index
{
    if wave_index >= waves.len() {
        0
    } else {
        let wave = waves[wave_index as int];
        if current_bullets >= wave.monsters {
            wave.monsters + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)
        } else {
            let reloads_needed = (((wave.monsters - 1) as int / k as int) + 1) as nat;
            reloads_needed * k + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve_monster_waves(waves: Vec<Wave>, k: u8) -> (result: i32)
    requires 
        valid_waves(waves@),
        k > 0,
    ensures 
        result == -1 <==> !can_solve_all_waves(waves@, k as nat),
        result >= 0 <==> can_solve_all_waves(waves@, k as nat),
        can_solve_all_waves(waves@, k as nat) ==> result == calculate_minimum_bullets(waves@, k as nat) as i32,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    -1
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
#[derive(PartialEq, Eq)]
struct Wave {
    start_time: nat,
    end_time: nat,
    monsters: nat,
}

spec fn valid_waves(waves: Seq<Wave>) -> bool {
    forall|i: int| 0 <= i < waves.len() ==> 
        #[trigger] waves[i].start_time <= waves[i].end_time &&
        waves[i].monsters > 0 &&
        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)
}

spec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {
    k > 0 && 
    forall|i: int| 0 <= i < waves.len() ==> 
        #[trigger] can_solve_wave(waves, i as nat, k)
}

spec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {
    &&& wave_index < waves.len()
    &&& k > 0
    &&& {
        let wave = waves[wave_index as int];
        let time_available = wave.end_time - wave.start_time + 1;
        let max_possible_shots = time_available * k;
        wave.monsters <= max_possible_shots &&
        (wave_index == 0 || can_reach_wave_in_time(waves, wave_index, k))
    }
}

spec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {
    &&& wave_index > 0 && wave_index < waves.len()
    &&& k > 0
    &&& {
        let prev_wave = waves[wave_index as int - 1];
        let curr_wave = waves[wave_index as int];
        let time_gap = curr_wave.start_time - prev_wave.end_time;
        let reloads_needed = calculate_reloads_needed(prev_wave.monsters, k);
        reloads_needed <= time_gap
    }
}

spec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {
    if k > 0 {
        if monsters <= k { 
            0 
        } else { 
            ((monsters - 1) as int / k as int) as nat
        }
    } else {
        0
    }
}

spec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {
    if k > 0 && valid_waves(waves) && can_solve_all_waves(waves, k) {
        calculate_minimum_bullets_helper(waves, k, 0, k)
    } else {
        0
    }
}

spec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat
    decreases waves.len() - wave_index
{
    if wave_index >= waves.len() {
        0
    } else {
        let wave = waves[wave_index as int];
        if current_bullets >= wave.monsters {
            wave.monsters + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)
        } else {
            let reloads_needed = (((wave.monsters - 1) as int / k as int) + 1) as nat;
            reloads_needed * k + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve_monster_waves(waves: Vec<Wave>, k: u8) -> (result: i32)
    requires 
        valid_waves(waves@),
        k > 0,
    ensures 
        result == -1 <==> !can_solve_all_waves(waves@, k as nat),
        result >= 0 <==> can_solve_all_waves(waves@, k as nat),
        can_solve_all_waves(waves@, k as nat) ==> result == calculate_minimum_bullets(waves@, k as nat) as i32,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    -1
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n#[derive(PartialEq, Eq)]\nstruct Wave {\n    start_time: nat,\n    end_time: nat,\n    monsters: nat,\n}\n\nspec fn valid_waves(waves: Seq<Wave>) -> bool {\n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] waves[i].start_time <= waves[i].end_time &&\n        waves[i].monsters > 0 &&\n        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)\n}\n\nspec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {\n    k > 0 && \n    forall|i: int| 0 <= i < waves.len() ==> \n        #[trigger] can_solve_wave(waves, i as nat, k)\n}\n\nspec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let wave = waves[wave_index as int];\n        let time_available = wave.end_time - wave.start_time + 1;\n        let max_possible_shots = time_available * k;\n        wave.monsters <= max_possible_shots &&\n        (wave_index == 0 || can_reach_wave_in_time(waves, wave_index, k))\n    }\n}\n\nspec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {\n    &&& wave_index > 0 && wave_index < waves.len()\n    &&& k > 0\n    &&& {\n        let prev_wave = waves[wave_index as int - 1];\n        let curr_wave = waves[wave_index as int];\n        let time_gap = curr_wave.start_time - prev_wave.end_time;\n        let reloads_needed = calculate_reloads_needed(prev_wave.monsters, k);\n        reloads_needed <= time_gap\n    }\n}\n\nspec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {\n    if k > 0 {\n        if monsters <= k { \n            0 \n        } else { \n            ((monsters - 1) as int / k as int) as nat\n        }\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {\n    if k > 0 && valid_waves(waves) && can_solve_all_waves(waves, k) {\n        calculate_minimum_bullets_helper(waves, k, 0, k)\n    } else {\n        0\n    }\n}\n\nspec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat\n    decreases waves.len() - wave_index\n{\n    if wave_index >= waves.len() {\n        0\n    } else {\n        let wave = waves[wave_index as int];\n        if current_bullets >= wave.monsters {\n            wave.monsters + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        } else {\n            let reloads_needed = (((wave.monsters - 1) as int / k as int) + 1) as nat;\n            reloads_needed * k + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_monster_waves(waves: Vec<Wave>, k: u8) -> (result: i32)\n    requires \n        valid_waves(waves@),\n        k > 0,\n    ensures \n        result == -1 <==> !can_solve_all_waves(waves@, k as nat),\n        result >= 0 <==> can_solve_all_waves(waves@, k as nat),\n        can_solve_all_waves(waves@, k as nat) ==> result == calculate_minimum_bullets(waves@, k as nat) as i32,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1149.rs,159,159,1.0,184.157,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    lines.len() >= 3 && {
        let n = parse_int(lines[0]);
        let x_line = parse_int_list(lines[1]);
        let y_line = parse_int_list(lines[2]);
        n >= 1 && x_line.len() > 0 && y_line.len() > 0 &&
        x_line[0] >= 0 && y_line[0] >= 0 &&
        x_line.len() >= (1 + x_line[0]) as nat && y_line.len() >= (1 + y_line[0]) as nat
    }
}

spec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>
    recommends valid_input(stdin_input)
{
    let lines = split_lines(stdin_input);
    let n = parse_int(lines[0]);
    let x_line = parse_int_list(lines[1]);
    let y_line = parse_int_list(lines[2]);
    let x_levels = set_from_seq(x_line.subrange(1, 1 + x_line[0] as int));
    let y_levels = set_from_seq(y_line.subrange(1, 1 + y_line[0] as int));
    let all_levels = x_levels.union(y_levels);
    let required_levels = Set::new(|i: int| 1 <= i <= n);
    if required_levels.subset_of(all_levels) { 
        Seq::new(17, |i: int| if i == 0 { 'I' } else if i == 1 { ' ' } else if i == 2 { 'b' } else if i == 3 { 'e' } else if i == 4 { 'c' } else if i == 5 { 'o' } else if i == 6 { 'm' } else if i == 7 { 'e' } else if i == 8 { ' ' } else if i == 9 { 't' } else if i == 10 { 'h' } else if i == 11 { 'e' } else if i == 12 { ' ' } else if i == 13 { 'g' } else if i == 14 { 'u' } else if i == 15 { 'y' } else { '.' })
    } else { 
        Seq::new(16, |i: int| if i == 0 { 'O' } else if i == 1 { 'h' } else if i == 2 { ',' } else if i == 3 { ' ' } else if i == 4 { 'm' } else if i == 5 { 'y' } else if i == 6 { ' ' } else if i == 7 { 'k' } else if i == 8 { 'e' } else if i == 9 { 'y' } else if i == 10 { 'b' } else if i == 11 { 'o' } else if i == 12 { 'a' } else if i == 13 { 'r' } else if i == 14 { 'd' } else { '!' })
    }
}

spec fn set_from_seq(s: Seq<int>) -> Set<int> {
    Set::new(|x: int| s.contains(x))
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))
    } else {
        let newline_pos = find_char(s, '\n');
        if newline_pos == -1 {
            Seq::new(1 as nat, |j: int| trim(s))
        } else if 0 <= newline_pos < s.len() {
            Seq::new(1 as nat, |j: int| trim(s.subrange(0, newline_pos))).add(split_lines(s.subrange(newline_pos+1, s.len() as int)))
        } else {
            Seq::new(1 as nat, |j: int| trim(s))
        }
    }
}

spec fn trim(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[s.len() as int - 1] == '\r' {
        s.subrange(0, s.len() as int - 1)
    } else {
        s
    }
}

spec fn find_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        -1
    } else if s[0] == c {
        0
    } else {
        let rest = find_char(s.subrange(1, s.len() as int), c);
        if rest == -1 { -1 } else { rest + 1 }
    }
}

spec fn parse_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        if is_valid_digits(s.subrange(1, s.len() as int)) { 
            -parse_int_helper(s.subrange(1, s.len() as int)) 
        } else { 
            0 
        }
    } else if is_valid_digits(s) { 
        parse_int_helper(s) 
    } else { 
        0 
    }
}

spec fn is_valid_digits(s: Seq<char>) -> bool {
    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> ('0' <= s[i] <= '9')
}

spec fn parse_int_helper(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        char_to_digit(s[0])
    } else {
        parse_int_helper(s.subrange(0, s.len() as int - 1)) * 10 + char_to_digit(s[s.len() as int - 1])
    }
}

spec fn char_to_digit(c: char) -> int {
    (c as u32 as int) - ('0' as u32 as int)
}

spec fn parse_int_list(s: Seq<char>) -> Seq<int> {
    let parts = split_by_char(s, ' ');
    Seq::new(parts.len(), |i: int| parse_int(parts[i]))
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))
    } else {
        let delim_pos = find_char(s, delimiter);
        if delim_pos == -1 {
            Seq::new(1 as nat, |j: int| s)
        } else if delim_pos == 0 {
            split_by_char(s.subrange(1, s.len() as int), delimiter)
        } else if 0 < delim_pos < s.len() {
            Seq::new(1 as nat, |j: int| s.subrange(0, delim_pos)).add(split_by_char(s.subrange(delim_pos+1, s.len() as int), delimiter))
        } else {
            Seq::new(1 as nat, |j: int| s)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(stdin_input@.map(|i, c| c as char))
    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    lines.len() >= 3 && {
        let n = parse_int(lines[0]);
        let x_line = parse_int_list(lines[1]);
        let y_line = parse_int_list(lines[2]);
        n >= 1 && x_line.len() > 0 && y_line.len() > 0 &&
        x_line[0] >= 0 && y_line[0] >= 0 &&
        x_line.len() >= (1 + x_line[0]) as nat && y_line.len() >= (1 + y_line[0]) as nat
    }
}

spec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>
    recommends valid_input(stdin_input)
{
    let lines = split_lines(stdin_input);
    let n = parse_int(lines[0]);
    let x_line = parse_int_list(lines[1]);
    let y_line = parse_int_list(lines[2]);
    let x_levels = set_from_seq(x_line.subrange(1, 1 + x_line[0] as int));
    let y_levels = set_from_seq(y_line.subrange(1, 1 + y_line[0] as int));
    let all_levels = x_levels.union(y_levels);
    let required_levels = Set::new(|i: int| 1 <= i <= n);
    if required_levels.subset_of(all_levels) { 
        Seq::new(17, |i: int| if i == 0 { 'I' } else if i == 1 { ' ' } else if i == 2 { 'b' } else if i == 3 { 'e' } else if i == 4 { 'c' } else if i == 5 { 'o' } else if i == 6 { 'm' } else if i == 7 { 'e' } else if i == 8 { ' ' } else if i == 9 { 't' } else if i == 10 { 'h' } else if i == 11 { 'e' } else if i == 12 { ' ' } else if i == 13 { 'g' } else if i == 14 { 'u' } else if i == 15 { 'y' } else { '.' })
    } else { 
        Seq::new(16, |i: int| if i == 0 { 'O' } else if i == 1 { 'h' } else if i == 2 { ',' } else if i == 3 { ' ' } else if i == 4 { 'm' } else if i == 5 { 'y' } else if i == 6 { ' ' } else if i == 7 { 'k' } else if i == 8 { 'e' } else if i == 9 { 'y' } else if i == 10 { 'b' } else if i == 11 { 'o' } else if i == 12 { 'a' } else if i == 13 { 'r' } else if i == 14 { 'd' } else { '!' })
    }
}

spec fn set_from_seq(s: Seq<int>) -> Set<int> {
    Set::new(|x: int| s.contains(x))
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))
    } else {
        let newline_pos = find_char(s, '\n');
        if newline_pos == -1 {
            Seq::new(1 as nat, |j: int| trim(s))
        } else if 0 <= newline_pos < s.len() {
            Seq::new(1 as nat, |j: int| trim(s.subrange(0, newline_pos))).add(split_lines(s.subrange(newline_pos+1, s.len() as int)))
        } else {
            Seq::new(1 as nat, |j: int| trim(s))
        }
    }
}

spec fn trim(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[s.len() as int - 1] == '\r' {
        s.subrange(0, s.len() as int - 1)
    } else {
        s
    }
}

spec fn find_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        -1
    } else if s[0] == c {
        0
    } else {
        let rest = find_char(s.subrange(1, s.len() as int), c);
        if rest == -1 { -1 } else { rest + 1 }
    }
}

spec fn parse_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        if is_valid_digits(s.subrange(1, s.len() as int)) { 
            -parse_int_helper(s.subrange(1, s.len() as int)) 
        } else { 
            0 
        }
    } else if is_valid_digits(s) { 
        parse_int_helper(s) 
    } else { 
        0 
    }
}

spec fn is_valid_digits(s: Seq<char>) -> bool {
    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> ('0' <= s[i] <= '9')
}

spec fn parse_int_helper(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        char_to_digit(s[0])
    } else {
        parse_int_helper(s.subrange(0, s.len() as int - 1)) * 10 + char_to_digit(s[s.len() as int - 1])
    }
}

spec fn char_to_digit(c: char) -> int {
    (c as u32 as int) - ('0' as u32 as int)
}

spec fn parse_int_list(s: Seq<char>) -> Seq<int> {
    let parts = split_by_char(s, ' ');
    Seq::new(parts.len(), |i: int| parse_int(parts[i]))
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))
    } else {
        let delim_pos = find_char(s, delimiter);
        if delim_pos == -1 {
            Seq::new(1 as nat, |j: int| s)
        } else if delim_pos == 0 {
            split_by_char(s.subrange(1, s.len() as int), delimiter)
        } else if 0 < delim_pos < s.len() {
            Seq::new(1 as nat, |j: int| s.subrange(0, delim_pos)).add(split_by_char(s.subrange(delim_pos+1, s.len() as int), delimiter))
        } else {
            Seq::new(1 as nat, |j: int| s)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(stdin_input@.map(|i, c| c as char))
    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    lines.len() >= 3 && {\n        let n = parse_int(lines[0]);\n        let x_line = parse_int_list(lines[1]);\n        let y_line = parse_int_list(lines[2]);\n        n >= 1 && x_line.len() > 0 && y_line.len() > 0 &&\n        x_line[0] >= 0 && y_line[0] >= 0 &&\n        x_line.len() >= (1 + x_line[0]) as nat && y_line.len() >= (1 + y_line[0]) as nat\n    }\n}\n\nspec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    let x_line = parse_int_list(lines[1]);\n    let y_line = parse_int_list(lines[2]);\n    let x_levels = set_from_seq(x_line.subrange(1, 1 + x_line[0] as int));\n    let y_levels = set_from_seq(y_line.subrange(1, 1 + y_line[0] as int));\n    let all_levels = x_levels.union(y_levels);\n    let required_levels = Set::new(|i: int| 1 <= i <= n);\n    if required_levels.subset_of(all_levels) { \n        Seq::new(17, |i: int| if i == 0 { 'I' } else if i == 1 { ' ' } else if i == 2 { 'b' } else if i == 3 { 'e' } else if i == 4 { 'c' } else if i == 5 { 'o' } else if i == 6 { 'm' } else if i == 7 { 'e' } else if i == 8 { ' ' } else if i == 9 { 't' } else if i == 10 { 'h' } else if i == 11 { 'e' } else if i == 12 { ' ' } else if i == 13 { 'g' } else if i == 14 { 'u' } else if i == 15 { 'y' } else { '.' })\n    } else { \n        Seq::new(16, |i: int| if i == 0 { 'O' } else if i == 1 { 'h' } else if i == 2 { ',' } else if i == 3 { ' ' } else if i == 4 { 'm' } else if i == 5 { 'y' } else if i == 6 { ' ' } else if i == 7 { 'k' } else if i == 8 { 'e' } else if i == 9 { 'y' } else if i == 10 { 'b' } else if i == 11 { 'o' } else if i == 12 { 'a' } else if i == 13 { 'r' } else if i == 14 { 'd' } else { '!' })\n    }\n}\n\nspec fn set_from_seq(s: Seq<int>) -> Set<int> {\n    Set::new(|x: int| s.contains(x))\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let newline_pos = find_char(s, '\\n');\n        if newline_pos == -1 {\n            Seq::new(1 as nat, |j: int| trim(s))\n        } else if 0 <= newline_pos < s.len() {\n            Seq::new(1 as nat, |j: int| trim(s.subrange(0, newline_pos))).add(split_lines(s.subrange(newline_pos+1, s.len() as int)))\n        } else {\n            Seq::new(1 as nat, |j: int| trim(s))\n        }\n    }\n}\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[s.len() as int - 1] == '\\r' {\n        s.subrange(0, s.len() as int - 1)\n    } else {\n        s\n    }\n}\n\nspec fn find_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == c {\n        0\n    } else {\n        let rest = find_char(s.subrange(1, s.len() as int), c);\n        if rest == -1 { -1 } else { rest + 1 }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        if is_valid_digits(s.subrange(1, s.len() as int)) { \n            -parse_int_helper(s.subrange(1, s.len() as int)) \n        } else { \n            0 \n        }\n    } else if is_valid_digits(s) { \n        parse_int_helper(s) \n    } else { \n        0 \n    }\n}\n\nspec fn is_valid_digits(s: Seq<char>) -> bool {\n    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> ('0' <= s[i] <= '9')\n}\n\nspec fn parse_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        char_to_digit(s[0])\n    } else {\n        parse_int_helper(s.subrange(0, s.len() as int - 1)) * 10 + char_to_digit(s[s.len() as int - 1])\n    }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as u32 as int) - ('0' as u32 as int)\n}\n\nspec fn parse_int_list(s: Seq<char>) -> Seq<int> {\n    let parts = split_by_char(s, ' ');\n    Seq::new(parts.len(), |i: int| parse_int(parts[i]))\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))\n    } else {\n        let delim_pos = find_char(s, delimiter);\n        if delim_pos == -1 {\n            Seq::new(1 as nat, |j: int| s)\n        } else if delim_pos == 0 {\n            split_by_char(s.subrange(1, s.len() as int), delimiter)\n        } else if 0 < delim_pos < s.len() {\n            Seq::new(1 as nat, |j: int| s.subrange(0, delim_pos)).add(split_by_char(s.subrange(delim_pos+1, s.len() as int), delimiter))\n        } else {\n            Seq::new(1 as nat, |j: int| s)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(stdin_input@.map(|i, c| c as char))\n    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1150.rs,156,156,1.0,123.549,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() - 1] == '\n'
}

spec fn valid_mole(mole: (int, int, int, int)) -> bool {
    let (x, y, a, b) = mole;
    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&
    -10000 <= a <= 10000 && -10000 <= b <= 10000
}

spec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {
    moles.len() == 4 && forall|i: int| 0 <= i < 4 ==> #[trigger] valid_mole(moles[i])
}

spec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {
    let dx = x - center_x;
    let dy = y - center_y;
    let rotations = times % 4;
    if rotations == 0 {
        (x, y)
    } else if rotations == 1 {
        (center_x - dy, center_y + dx)
    } else if rotations == 2 {
        (center_x - dx, center_y - dy)
    } else {
        (center_x + dy, center_y - dx)
    }
}

spec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {
    let (x1, y1) = p1;
    let (x2, y2) = p2;
    let dx = x1 - x2;
    let dy = y1 - y2;
    let dx_abs: nat = if dx >= 0 { dx as nat } else { (-dx) as nat };
    let dy_abs: nat = if dy >= 0 { dy as nat } else { (-dy) as nat };
    dx_abs * dx_abs + dy_abs * dy_abs
}

spec fn is_square(points: Seq<(int, int)>) -> bool
    recommends points.len() == 4
{
    if points.len() != 4 {
        false
    } else {
        let p0 = points[0];
        let p1 = points[1];
        let p2 = points[2];
        let p3 = points[3];
        let d01 = distance_squared(p0, p1);
        let d02 = distance_squared(p0, p2);
        let d03 = distance_squared(p0, p3);
        let d12 = distance_squared(p1, p2);
        let d13 = distance_squared(p1, p3);
        let d23 = distance_squared(p2, p3);
        
        d01 > 0 && (
            (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||
            (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||
            (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||
            (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||
            (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)
        )
    }
}

spec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool
    recommends valid_regiment(moles)
{
    total_moves <= 12
}

spec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>
    recommends moles.len() == 4
{
    if moles.len() != 4 {
        seq![]
    } else {
        let (x0, y0, a0, b0) = moles[0];
        let (x1, y1, a1, b1) = moles[1];
        let (x2, y2, a2, b2) = moles[2];
        let (x3, y3, a3, b3) = moles[3];
        seq![
            rotate_point(x0, y0, a0, b0, moves0),
            rotate_point(x1, y1, a1, b1, moves1),
            rotate_point(x2, y2, a2, b2, moves2),
            rotate_point(x3, y3, a3, b3, moves3)
        ]
    }
}

spec fn is_all_digits(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn string_to_nat(s: Seq<char>) -> nat
    recommends is_all_digits(s) && s.len() > 0
    decreases s.len()
{
    if s.len() == 0 || !is_all_digits(s) {
        0
    } else if s.len() == 1 {
        ((s[0] as int) - ('0' as int)) as nat
    } else {
        string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (((s[s.len() - 1] as int) - ('0' as int)) as nat)
    }
}

spec fn nat_to_string(n: nat) -> Seq<char>
    recommends n <= 12
{
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else if n == 4 { seq!['4'] }
    else if n == 5 { seq!['5'] }
    else if n == 6 { seq!['6'] }
    else if n == 7 { seq!['7'] }
    else if n == 8 { seq!['8'] }
    else if n == 9 { seq!['9'] }
    else if n == 10 { seq!['1', '0'] }
    else if n == 11 { seq!['1', '1'] }
    else { seq!['1', '2'] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
    requires valid_input(stdin_input@)
    ensures valid_output(output@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() - 1] == '\n'
}

spec fn valid_mole(mole: (int, int, int, int)) -> bool {
    let (x, y, a, b) = mole;
    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&
    -10000 <= a <= 10000 && -10000 <= b <= 10000
}

spec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {
    moles.len() == 4 && forall|i: int| 0 <= i < 4 ==> #[trigger] valid_mole(moles[i])
}

spec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {
    let dx = x - center_x;
    let dy = y - center_y;
    let rotations = times % 4;
    if rotations == 0 {
        (x, y)
    } else if rotations == 1 {
        (center_x - dy, center_y + dx)
    } else if rotations == 2 {
        (center_x - dx, center_y - dy)
    } else {
        (center_x + dy, center_y - dx)
    }
}

spec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {
    let (x1, y1) = p1;
    let (x2, y2) = p2;
    let dx = x1 - x2;
    let dy = y1 - y2;
    let dx_abs: nat = if dx >= 0 { dx as nat } else { (-dx) as nat };
    let dy_abs: nat = if dy >= 0 { dy as nat } else { (-dy) as nat };
    dx_abs * dx_abs + dy_abs * dy_abs
}

spec fn is_square(points: Seq<(int, int)>) -> bool
    recommends points.len() == 4
{
    if points.len() != 4 {
        false
    } else {
        let p0 = points[0];
        let p1 = points[1];
        let p2 = points[2];
        let p3 = points[3];
        let d01 = distance_squared(p0, p1);
        let d02 = distance_squared(p0, p2);
        let d03 = distance_squared(p0, p3);
        let d12 = distance_squared(p1, p2);
        let d13 = distance_squared(p1, p3);
        let d23 = distance_squared(p2, p3);
        
        d01 > 0 && (
            (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||
            (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||
            (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||
            (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||
            (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)
        )
    }
}

spec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool
    recommends valid_regiment(moles)
{
    total_moves <= 12
}

spec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>
    recommends moles.len() == 4
{
    if moles.len() != 4 {
        seq![]
    } else {
        let (x0, y0, a0, b0) = moles[0];
        let (x1, y1, a1, b1) = moles[1];
        let (x2, y2, a2, b2) = moles[2];
        let (x3, y3, a3, b3) = moles[3];
        seq![
            rotate_point(x0, y0, a0, b0, moves0),
            rotate_point(x1, y1, a1, b1, moves1),
            rotate_point(x2, y2, a2, b2, moves2),
            rotate_point(x3, y3, a3, b3, moves3)
        ]
    }
}

spec fn is_all_digits(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn string_to_nat(s: Seq<char>) -> nat
    recommends is_all_digits(s) && s.len() > 0
    decreases s.len()
{
    if s.len() == 0 || !is_all_digits(s) {
        0
    } else if s.len() == 1 {
        ((s[0] as int) - ('0' as int)) as nat
    } else {
        string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (((s[s.len() - 1] as int) - ('0' as int)) as nat)
    }
}

spec fn nat_to_string(n: nat) -> Seq<char>
    recommends n <= 12
{
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else if n == 4 { seq!['4'] }
    else if n == 5 { seq!['5'] }
    else if n == 6 { seq!['6'] }
    else if n == 7 { seq!['7'] }
    else if n == 8 { seq!['8'] }
    else if n == 9 { seq!['9'] }
    else if n == 10 { seq!['1', '0'] }
    else if n == 11 { seq!['1', '1'] }
    else { seq!['1', '2'] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
    requires valid_input(stdin_input@)
    ensures valid_output(output@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn valid_mole(mole: (int, int, int, int)) -> bool {\n    let (x, y, a, b) = mole;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&\n    -10000 <= a <= 10000 && -10000 <= b <= 10000\n}\n\nspec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {\n    moles.len() == 4 && forall|i: int| 0 <= i < 4 ==> #[trigger] valid_mole(moles[i])\n}\n\nspec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {\n    let dx = x - center_x;\n    let dy = y - center_y;\n    let rotations = times % 4;\n    if rotations == 0 {\n        (x, y)\n    } else if rotations == 1 {\n        (center_x - dy, center_y + dx)\n    } else if rotations == 2 {\n        (center_x - dx, center_y - dy)\n    } else {\n        (center_x + dy, center_y - dx)\n    }\n}\n\nspec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {\n    let (x1, y1) = p1;\n    let (x2, y2) = p2;\n    let dx = x1 - x2;\n    let dy = y1 - y2;\n    let dx_abs: nat = if dx >= 0 { dx as nat } else { (-dx) as nat };\n    let dy_abs: nat = if dy >= 0 { dy as nat } else { (-dy) as nat };\n    dx_abs * dx_abs + dy_abs * dy_abs\n}\n\nspec fn is_square(points: Seq<(int, int)>) -> bool\n    recommends points.len() == 4\n{\n    if points.len() != 4 {\n        false\n    } else {\n        let p0 = points[0];\n        let p1 = points[1];\n        let p2 = points[2];\n        let p3 = points[3];\n        let d01 = distance_squared(p0, p1);\n        let d02 = distance_squared(p0, p2);\n        let d03 = distance_squared(p0, p3);\n        let d12 = distance_squared(p1, p2);\n        let d13 = distance_squared(p1, p3);\n        let d23 = distance_squared(p2, p3);\n        \n        d01 > 0 && (\n            (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||\n            (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||\n            (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)\n        )\n    }\n}\n\nspec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool\n    recommends valid_regiment(moles)\n{\n    total_moves <= 12\n}\n\nspec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>\n    recommends moles.len() == 4\n{\n    if moles.len() != 4 {\n        seq![]\n    } else {\n        let (x0, y0, a0, b0) = moles[0];\n        let (x1, y1, a1, b1) = moles[1];\n        let (x2, y2, a2, b2) = moles[2];\n        let (x3, y3, a3, b3) = moles[3];\n        seq![\n            rotate_point(x0, y0, a0, b0, moves0),\n            rotate_point(x1, y1, a1, b1, moves1),\n            rotate_point(x2, y2, a2, b2, moves2),\n            rotate_point(x3, y3, a3, b3, moves3)\n        ]\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    recommends is_all_digits(s) && s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 0 || !is_all_digits(s) {\n        0\n    } else if s.len() == 1 {\n        ((s[0] as int) - ('0' as int)) as nat\n    } else {\n        string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (((s[s.len() - 1] as int) - ('0' as int)) as nat)\n    }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char>\n    recommends n <= 12\n{\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else { seq!['1', '2'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(output@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n              fn main() {\n    }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_116.rs,61,61,1.0,122.435,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {
    l1 <= r1 && l2 <= r2
}

spec fn intersection_left(l1: int, l2: int) -> int {
    if l1 > l2 { l1 } else { l2 }
}

spec fn intersection_right(r1: int, r2: int) -> int {
    if r1 < r2 { r1 } else { r2 }
}

spec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {
    let left = intersection_left(l1, l2);
    let right = intersection_right(r1, r2);
    if right - left + 1 > 0 { right - left + 1 } else { 0 }
}

spec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {
    let left = intersection_left(l1, l2);
    let right = intersection_right(r1, r2);
    left <= k <= right
}

spec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {
    let intersection_size_val = intersection_size(l1, r1, l2, r2);
    if k_in_intersection(l1, r1, l2, r2, k) {
        if intersection_size_val - 1 > 0 { intersection_size_val - 1 } else { 0 }
    } else {
        intersection_size_val
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(l1: i8, r1: i8, l2: i8, r2: i8, k: i8) -> (result: i8)
    requires 
        valid_input(l1 as int, r1 as int, l2 as int, r2 as int, k as int)
    ensures 
        result as int == expected_result(l1 as int, r1 as int, l2 as int, r2 as int, k as int),
        result >= 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {
    l1 <= r1 && l2 <= r2
}

spec fn intersection_left(l1: int, l2: int) -> int {
    if l1 > l2 { l1 } else { l2 }
}

spec fn intersection_right(r1: int, r2: int) -> int {
    if r1 < r2 { r1 } else { r2 }
}

spec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {
    let left = intersection_left(l1, l2);
    let right = intersection_right(r1, r2);
    if right - left + 1 > 0 { right - left + 1 } else { 0 }
}

spec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {
    let left = intersection_left(l1, l2);
    let right = intersection_right(r1, r2);
    left <= k <= right
}

spec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {
    let intersection_size_val = intersection_size(l1, r1, l2, r2);
    if k_in_intersection(l1, r1, l2, r2, k) {
        if intersection_size_val - 1 > 0 { intersection_size_val - 1 } else { 0 }
    } else {
        intersection_size_val
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(l1: i8, r1: i8, l2: i8, r2: i8, k: i8) -> (result: i8)
    requires 
        valid_input(l1 as int, r1 as int, l2 as int, r2 as int, k as int)
    ensures 
        result as int == expected_result(l1 as int, r1 as int, l2 as int, r2 as int, k as int),
        result >= 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    l1 <= r1 && l2 <= r2\n}\n\nspec fn intersection_left(l1: int, l2: int) -> int {\n    if l1 > l2 { l1 } else { l2 }\n}\n\nspec fn intersection_right(r1: int, r2: int) -> int {\n    if r1 < r2 { r1 } else { r2 }\n}\n\nspec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    if right - left + 1 > 0 { right - left + 1 } else { 0 }\n}\n\nspec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {\n    let left = intersection_left(l1, l2);\n    let right = intersection_right(r1, r2);\n    left <= k <= right\n}\n\nspec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {\n    let intersection_size_val = intersection_size(l1, r1, l2, r2);\n    if k_in_intersection(l1, r1, l2, r2, k) {\n        if intersection_size_val - 1 > 0 { intersection_size_val - 1 } else { 0 }\n    } else {\n        intersection_size_val\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(l1: i8, r1: i8, l2: i8, r2: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(l1 as int, r1 as int, l2 as int, r2 as int, k as int)\n    ensures \n        result as int == expected_result(l1 as int, r1 as int, l2 as int, r2 as int, k as int),\n        result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1176.rs,50,50,1.0,122.458,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn min_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0
    } else if s.len() == 1 { 
        s[0] 
    } else { 
        let rest_min = min_seq(s.subrange(1, s.len() as int));
        if s[0] <= rest_min { s[0] } else { rest_min }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Vec<i8>) -> (result: i8)
    requires a@.len() >= 2
    ensures ({
        let count_neg = Set::new(|i: int| 0 <= i < a@.len() && a@[i] < 0).len();
        let sum_abs = sum_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));
        let min_abs = min_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));
        result as int == if count_neg % 2 == 0 { sum_abs } else { sum_abs - 2 * min_abs }
    })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn min_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0
    } else if s.len() == 1 { 
        s[0] 
    } else { 
        let rest_min = min_seq(s.subrange(1, s.len() as int));
        if s[0] <= rest_min { s[0] } else { rest_min }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Vec<i8>) -> (result: i8)
    requires a@.len() >= 2
    ensures ({
        let count_neg = Set::new(|i: int| 0 <= i < a@.len() && a@[i] < 0).len();
        let sum_abs = sum_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));
        let min_abs = min_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));
        result as int == if count_neg % 2 == 0 { sum_abs } else { sum_abs - 2 * min_abs }
    })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn min_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 { \n        s[0] \n    } else { \n        let rest_min = min_seq(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: i8)\n    requires a@.len() >= 2\n    ensures ({\n        let count_neg = Set::new(|i: int| 0 <= i < a@.len() && a@[i] < 0).len();\n        let sum_abs = sum_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        let min_abs = min_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));\n        result as int == if count_neg % 2 == 0 { sum_abs } else { sum_abs - 2 * min_abs }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1177.rs,53,53,1.0,122.689,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {
    n >= 1 && s >= 1 && a.len() == n && n <= 3000 && s <= 3000 &&
    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000
}

spec fn valid_result(result: int) -> bool {
    result >= 0 && result < 998244353
}

spec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] > s
}

spec fn single_element_case(n: int, s: int, a: Seq<int>) -> int
    decreases n
{
    if n == 1 && a.len() == 1 {
        if s == a[0] { 1 } else { 0 }
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, s: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        valid_result(result as int),
        (result as int) % 998244353 == (result as int),
        (n as int == 1 && s as int == a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
        (n as int == 1 && s as int != a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
        all_elements_greater_than_s(a@.map(|i: int, x: i8| x as int), s as int) ==> (result as int) == 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {
    n >= 1 && s >= 1 && a.len() == n && n <= 3000 && s <= 3000 &&
    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000
}

spec fn valid_result(result: int) -> bool {
    result >= 0 && result < 998244353
}

spec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] > s
}

spec fn single_element_case(n: int, s: int, a: Seq<int>) -> int
    decreases n
{
    if n == 1 && a.len() == 1 {
        if s == a[0] { 1 } else { 0 }
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, s: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        valid_result(result as int),
        (result as int) % 998244353 == (result as int),
        (n as int == 1 && s as int == a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
        (n as int == 1 && s as int != a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
        all_elements_greater_than_s(a@.map(|i: int, x: i8| x as int), s as int) ==> (result as int) == 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n    n >= 1 && s >= 1 && a.len() == n && n <= 3000 && s <= 3000 &&\n    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nspec fn valid_result(result: int) -> bool {\n    result >= 0 && result < 998244353\n}\n\nspec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > s\n}\n\nspec fn single_element_case(n: int, s: int, a: Seq<int>) -> int\n    decreases n\n{\n    if n == 1 && a.len() == 1 {\n        if s == a[0] { 1 } else { 0 }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        valid_result(result as int),\n        (result as int) % 998244353 == (result as int),\n        (n as int == 1 && s as int == a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        (n as int == 1 && s as int != a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),\n        all_elements_greater_than_s(a@.map(|i: int, x: i8| x as int), s as int) ==> (result as int) == 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1195.rs,52,52,1.0,123.118,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(lst: Seq<int>) -> bool {
    5 <= lst.len() <= 10 &&
    forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32
}

spec fn int_xor(a: int, b: int) -> int {
    let a_bv = a as u32;
    let b_bv = b as u32;
    (a_bv ^ b_bv) as int
}

spec fn min_of_sequence(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_min = min_of_sequence(s.skip(1));
        if s[0] <= tail_min {
            s[0]
        } else {
            tail_min
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(lst: Vec<i8>) -> (result: i8)
    requires valid_input(lst@.map(|i: int, x: i8| x as int))
    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(lst: Seq<int>) -> bool {
    5 <= lst.len() <= 10 &&
    forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32
}

spec fn int_xor(a: int, b: int) -> int {
    let a_bv = a as u32;
    let b_bv = b as u32;
    (a_bv ^ b_bv) as int
}

spec fn min_of_sequence(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_min = min_of_sequence(s.skip(1));
        if s[0] <= tail_min {
            s[0]
        } else {
            tail_min
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(lst: Vec<i8>) -> (result: i8)
    requires valid_input(lst@.map(|i: int, x: i8| x as int))
    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(lst: Seq<int>) -> bool {\n    5 <= lst.len() <= 10 &&\n    forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32\n}\n\nspec fn int_xor(a: int, b: int) -> int {\n    let a_bv = a as u32;\n    let b_bv = b as u32;\n    (a_bv ^ b_bv) as int\n}\n\nspec fn min_of_sequence(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = min_of_sequence(s.skip(1));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(lst: Vec<i8>) -> (result: i8)\n    requires valid_input(lst@.map(|i: int, x: i8| x as int))\n    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1212.rs,50,50,1.0,123.493,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum_window(heights: Seq<int>, start: int, k: int) -> int
  decreases k
{
  if 0 <= start && start + k <= heights.len() && k > 0 {
    if k == 1 { heights[start] }
    else { heights[start] + sum_window(heights, start + 1, k - 1) }
  } else {
    0
  }
}

spec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool
{
  1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> (1 <= #[trigger] heights[i] <= 100)
}

spec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool
{
  &&& valid_input(n, k, heights)
  &&& 1 <= result <= n-k+1
  &&& (forall|start: int| 0 <= start <= n-k ==> 
        sum_window(heights, result-1, k) <= #[trigger] sum_window(heights, start, k))
  &&& (forall|start: int| 0 <= start < result-1 ==>
        #[trigger] sum_window(heights, start, k) > sum_window(heights, result-1, k))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, heights: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))
  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum_window(heights: Seq<int>, start: int, k: int) -> int
  decreases k
{
  if 0 <= start && start + k <= heights.len() && k > 0 {
    if k == 1 { heights[start] }
    else { heights[start] + sum_window(heights, start + 1, k - 1) }
  } else {
    0
  }
}

spec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool
{
  1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> (1 <= #[trigger] heights[i] <= 100)
}

spec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool
{
  &&& valid_input(n, k, heights)
  &&& 1 <= result <= n-k+1
  &&& (forall|start: int| 0 <= start <= n-k ==> 
        sum_window(heights, result-1, k) <= #[trigger] sum_window(heights, start, k))
  &&& (forall|start: int| 0 <= start < result-1 ==>
        #[trigger] sum_window(heights, start, k) > sum_window(heights, result-1, k))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, heights: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))
  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_window(heights: Seq<int>, start: int, k: int) -> int\n  decreases k\n{\n  if 0 <= start && start + k <= heights.len() && k > 0 {\n    if k == 1 { heights[start] }\n    else { heights[start] + sum_window(heights, start + 1, k - 1) }\n  } else {\n    0\n  }\n}\n\nspec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool\n{\n  1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> (1 <= #[trigger] heights[i] <= 100)\n}\n\nspec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool\n{\n  &&& valid_input(n, k, heights)\n  &&& 1 <= result <= n-k+1\n  &&& (forall|start: int| 0 <= start <= n-k ==> \n        sum_window(heights, result-1, k) <= #[trigger] sum_window(heights, start, k))\n  &&& (forall|start: int| 0 <= start < result-1 ==>\n        #[trigger] sum_window(heights, start, k) > sum_window(heights, result-1, k))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, heights: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n               fn main() {\n     }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1218.rs,61,61,1.0,122.483,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 2
}

spec fn impossibility_condition(n: int, k: int) -> bool
    recommends valid_input(n, k)
{
    2 * (n - 1) - k * (k - 1) > 0
}

spec fn quadratic_condition(x: int, n: int, k: int) -> bool {
    x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0
}

spec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {
    (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0
}

spec fn valid_solution(n: int, k: int, result: int) -> bool
    recommends valid_input(n, k)
{
    if impossibility_condition(n, k) {
        result == -1
    } else {
        result >= 0 && result <= k &&
        exists|x: int| #[trigger] quadratic_condition(x, n, k) &&
            x >= 0 && 
            quadratic_condition(x, n, k) && 
            (x == 0 || next_quadratic_condition(x, n, k)) &&
            result == k - x
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result >= -1,
        (result == -1) <==> impossibility_condition(n as int, k as int),
        valid_solution(n as int, k as int, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 2
}

spec fn impossibility_condition(n: int, k: int) -> bool
    recommends valid_input(n, k)
{
    2 * (n - 1) - k * (k - 1) > 0
}

spec fn quadratic_condition(x: int, n: int, k: int) -> bool {
    x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0
}

spec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {
    (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0
}

spec fn valid_solution(n: int, k: int, result: int) -> bool
    recommends valid_input(n, k)
{
    if impossibility_condition(n, k) {
        result == -1
    } else {
        result >= 0 && result <= k &&
        exists|x: int| #[trigger] quadratic_condition(x, n, k) &&
            x >= 0 && 
            quadratic_condition(x, n, k) && 
            (x == 0 || next_quadratic_condition(x, n, k)) &&
            result == k - x
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result >= -1,
        (result == -1) <==> impossibility_condition(n as int, k as int),
        valid_solution(n as int, k as int, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 2\n}\n\nspec fn impossibility_condition(n: int, k: int) -> bool\n    recommends valid_input(n, k)\n{\n    2 * (n - 1) - k * (k - 1) > 0\n}\n\nspec fn quadratic_condition(x: int, n: int, k: int) -> bool {\n    x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0\n}\n\nspec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {\n    (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0\n}\n\nspec fn valid_solution(n: int, k: int, result: int) -> bool\n    recommends valid_input(n, k)\n{\n    if impossibility_condition(n, k) {\n        result == -1\n    } else {\n        result >= 0 && result <= k &&\n        exists|x: int| #[trigger] quadratic_condition(x, n, k) &&\n            x >= 0 && \n            quadratic_condition(x, n, k) && \n            (x == 0 || next_quadratic_condition(x, n, k)) &&\n            result == k - x\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= -1,\n        (result == -1) <==> impossibility_condition(n as int, k as int),\n        valid_solution(n as int, k as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1225.rs,90,90,1.0,122.749,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(h: int) -> bool {
    h >= 1
}

spec fn compute_attacks(h: int) -> int
    recommends h >= 0
{
    if h == 0 { 0 }
    else { compute_attacks_iterative(h, 0) }
}

spec fn compute_attacks_iterative(h: int, n: int) -> int
    recommends h >= 0 && n >= 0
    decreases h when h > 0
{
    if h == 0 { 0 }
    else { pow2(n) + compute_attacks_iterative(h / 2, n + 1) }
}

spec fn pow2(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n <= 0 { 1 }
    else { 2 * pow2(n - 1) }
}

spec fn parse_int_func(s: Seq<char>) -> int
    recommends s.len() > 0
{
    parse_int_helper(s, 0, 0)
}

spec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int
    recommends 0 <= i <= s.len() && acc >= 0
    decreases s.len() - i
{
    if i >= s.len() || s[i] == '\n' || s[i] == ' ' {
        acc
    } else if '0' <= s[i] <= '9' {
        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        parse_int_helper(s, i + 1, acc)
    }
}

spec fn int_to_string_func(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n, seq![]) }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>
    recommends n >= 0
    decreases n when n > 0
{
    if n == 0 { acc }
    else {
        let digit = n % 10;
        let digit_char = ('0' as int + digit) as char;
        int_to_string_helper(n / 10, seq![digit_char].add(acc))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)
    requires stdin_input@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(h: int) -> bool {
    h >= 1
}

spec fn compute_attacks(h: int) -> int
    recommends h >= 0
{
    if h == 0 { 0 }
    else { compute_attacks_iterative(h, 0) }
}

spec fn compute_attacks_iterative(h: int, n: int) -> int
    recommends h >= 0 && n >= 0
    decreases h when h > 0
{
    if h == 0 { 0 }
    else { pow2(n) + compute_attacks_iterative(h / 2, n + 1) }
}

spec fn pow2(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n <= 0 { 1 }
    else { 2 * pow2(n - 1) }
}

spec fn parse_int_func(s: Seq<char>) -> int
    recommends s.len() > 0
{
    parse_int_helper(s, 0, 0)
}

spec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int
    recommends 0 <= i <= s.len() && acc >= 0
    decreases s.len() - i
{
    if i >= s.len() || s[i] == '\n' || s[i] == ' ' {
        acc
    } else if '0' <= s[i] <= '9' {
        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        parse_int_helper(s, i + 1, acc)
    }
}

spec fn int_to_string_func(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n, seq![]) }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>
    recommends n >= 0
    decreases n when n > 0
{
    if n == 0 { acc }
    else {
        let digit = n % 10;
        let digit_char = ('0' as int + digit) as char;
        int_to_string_helper(n / 10, seq![digit_char].add(acc))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)
    requires stdin_input@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(h: int) -> bool {\n    h >= 1\n}\n\nspec fn compute_attacks(h: int) -> int\n    recommends h >= 0\n{\n    if h == 0 { 0 }\n    else { compute_attacks_iterative(h, 0) }\n}\n\nspec fn compute_attacks_iterative(h: int, n: int) -> int\n    recommends h >= 0 && n >= 0\n    decreases h when h > 0\n{\n    if h == 0 { 0 }\n    else { pow2(n) + compute_attacks_iterative(h / 2, n + 1) }\n}\n\nspec fn pow2(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 { 1 }\n    else { 2 * pow2(n - 1) }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    parse_int_helper(s, 0, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    recommends 0 <= i <= s.len() && acc >= 0\n    decreases s.len() - i\n{\n    if i >= s.len() || s[i] == '\\n' || s[i] == ' ' {\n        acc\n    } else if '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        parse_int_helper(s, i + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n, seq![]) }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n when n > 0\n{\n    if n == 0 { acc }\n    else {\n        let digit = n % 10;\n        let digit_char = ('0' as int + digit) as char;\n        int_to_string_helper(n / 10, seq![digit_char].add(acc))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires stdin_input@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1227.rs,58,58,1.0,122.469,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_non_zero_digits(n: int) -> int
    decreases n when n >= 0
{
    if n == 0 { 0 }
    else if n % 10 == 0 { count_non_zero_digits(n / 10) }
    else { 1 + count_non_zero_digits(n / 10) }
}

spec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int
{
    count_range(n, k, 1, n)
}

spec fn count_range(n: int, k: int, start: int, end: int) -> int
    decreases if end < start { 0int } else { end - start + 1 }
{
    if start > end { 0 }
    else if count_non_zero_digits(start) == k { 
        1 + count_range(n, k, start + 1, end)
    } else { 
        count_range(n, k, start + 1, end)
    }
}

spec fn valid_input(n: int, k: int) -> bool
{
    n >= 1 && k >= 1 && k <= 3
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn count_numbers_with_exactly_k_non_zero_digits(n: i8, k: i8) -> (count: i8)
requires
    valid_input(n as int, k as int)
ensures
    count as int == count_numbers_with_k_non_zero_digits(n as int, k as int),
    count as int >= 0,
    count as int <= n as int
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_non_zero_digits(n: int) -> int
    decreases n when n >= 0
{
    if n == 0 { 0 }
    else if n % 10 == 0 { count_non_zero_digits(n / 10) }
    else { 1 + count_non_zero_digits(n / 10) }
}

spec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int
{
    count_range(n, k, 1, n)
}

spec fn count_range(n: int, k: int, start: int, end: int) -> int
    decreases if end < start { 0int } else { end - start + 1 }
{
    if start > end { 0 }
    else if count_non_zero_digits(start) == k { 
        1 + count_range(n, k, start + 1, end)
    } else { 
        count_range(n, k, start + 1, end)
    }
}

spec fn valid_input(n: int, k: int) -> bool
{
    n >= 1 && k >= 1 && k <= 3
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn count_numbers_with_exactly_k_non_zero_digits(n: i8, k: i8) -> (count: i8)
requires
    valid_input(n as int, k as int)
ensures
    count as int == count_numbers_with_k_non_zero_digits(n as int, k as int),
    count as int >= 0,
    count as int <= n as int
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_non_zero_digits(n: int) -> int\n    decreases n when n >= 0\n{\n    if n == 0 { 0 }\n    else if n % 10 == 0 { count_non_zero_digits(n / 10) }\n    else { 1 + count_non_zero_digits(n / 10) }\n}\n\nspec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int\n{\n    count_range(n, k, 1, n)\n}\n\nspec fn count_range(n: int, k: int, start: int, end: int) -> int\n    decreases if end < start { 0int } else { end - start + 1 }\n{\n    if start > end { 0 }\n    else if count_non_zero_digits(start) == k { \n        1 + count_range(n, k, start + 1, end)\n    } else { \n        count_range(n, k, start + 1, end)\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 1 && k <= 3\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_numbers_with_exactly_k_non_zero_digits(n: i8, k: i8) -> (count: i8)\nrequires\n    valid_input(n as int, k as int)\nensures\n    count as int == count_numbers_with_k_non_zero_digits(n as int, k as int),\n    count as int >= 0,\n    count as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1228.rs,56,56,1.0,122.478,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn get_category(hp: int) -> char {
        let remainder = hp % 4;
        if remainder == 1 {
            'A'
        } else if remainder == 3 {
            'B'
        } else if remainder == 2 {
            'C'
        } else {
            'D'
        }
    }
    
    spec fn valid_input(n: int) -> bool {
        30 <= n <= 100
    }
    
    spec fn valid_output(a: int, b: char) -> bool {
        0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')
    }
    
    spec fn optimal_choice(n: int, a: int, b: char) -> bool {
        b == get_category(n + a) &&
        ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&
        ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&
        ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&
        ((n % 4 == 0) ==> (a == 1 && b == 'A'))
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: (i8, char))
    requires 
        30 <= n <= 100
    ensures 
        0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),
        optimal_choice(n as int, result.0 as int, result.1),
        result.1 == 'A' || result.1 == 'B'
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 'A')
}
// </vc-code>

}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn get_category(hp: int) -> char {
        let remainder = hp % 4;
        if remainder == 1 {
            'A'
        } else if remainder == 3 {
            'B'
        } else if remainder == 2 {
            'C'
        } else {
            'D'
        }
    }
    
    spec fn valid_input(n: int) -> bool {
        30 <= n <= 100
    }
    
    spec fn valid_output(a: int, b: char) -> bool {
        0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')
    }
    
    spec fn optimal_choice(n: int, a: int, b: char) -> bool {
        b == get_category(n + a) &&
        ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&
        ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&
        ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&
        ((n % 4 == 0) ==> (a == 1 && b == 'A'))
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: (i8, char))
    requires 
        30 <= n <= 100
    ensures 
        0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),
        optimal_choice(n as int, result.0 as int, result.1),
        result.1 == 'A' || result.1 == 'B'
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 'A')
}
// </vc-code>

}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn get_category(hp: int) -> char {\n        let remainder = hp % 4;\n        if remainder == 1 {\n            'A'\n        } else if remainder == 3 {\n            'B'\n        } else if remainder == 2 {\n            'C'\n        } else {\n            'D'\n        }\n    }\n    \n    spec fn valid_input(n: int) -> bool {\n        30 <= n <= 100\n    }\n    \n    spec fn valid_output(a: int, b: char) -> bool {\n        0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')\n    }\n    \n    spec fn optimal_choice(n: int, a: int, b: char) -> bool {\n        b == get_category(n + a) &&\n        ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&\n        ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&\n        ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&\n        ((n % 4 == 0) ==> (a == 1 && b == 'A'))\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: (i8, char))\n    requires \n        30 <= n <= 100\n    ensures \n        0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),\n        optimal_choice(n as int, result.0 as int, result.1),\n        result.1 == 'A' || result.1 == 'B'\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 'A')\n}\n// </vc-code>\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1240.rs,52,52,1.0,122.505,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(columns: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < columns.len() ==> columns[i].0 > 0 && columns[i].1 > 0
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn sum_left(columns: Seq<(int, int)>) -> int
    decreases columns.len()
{
    if columns.len() == 0 {
        0
    } else {
        columns[0].0 + sum_left(columns.drop_first())
    }
}

spec fn sum_right(columns: Seq<(int, int)>) -> int
    decreases columns.len()
{
    if columns.len() == 0 {
        0
    } else {
        columns[0].1 + sum_right(columns.drop_first())
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(columns: Vec<(i8, i8)>) -> (result: i8)
    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))
    ensures 0 <= result as int <= columns@.len()
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(columns: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < columns.len() ==> columns[i].0 > 0 && columns[i].1 > 0
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn sum_left(columns: Seq<(int, int)>) -> int
    decreases columns.len()
{
    if columns.len() == 0 {
        0
    } else {
        columns[0].0 + sum_left(columns.drop_first())
    }
}

spec fn sum_right(columns: Seq<(int, int)>) -> int
    decreases columns.len()
{
    if columns.len() == 0 {
        0
    } else {
        columns[0].1 + sum_right(columns.drop_first())
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(columns: Vec<(i8, i8)>) -> (result: i8)
    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))
    ensures 0 <= result as int <= columns@.len()
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(columns: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < columns.len() ==> columns[i].0 > 0 && columns[i].1 > 0\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn sum_left(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].0 + sum_left(columns.drop_first())\n    }\n}\n\nspec fn sum_right(columns: Seq<(int, int)>) -> int\n    decreases columns.len()\n{\n    if columns.len() == 0 {\n        0\n    } else {\n        columns[0].1 + sum_right(columns.drop_first())\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(columns: Vec<(i8, i8)>) -> (result: i8)\n    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))\n    ensures 0 <= result as int <= columns@.len()\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_125.rs,97,22,0.2268041237113402,185.885,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_newlines(s: Seq<char>, idx: int) -> int
    decreases s.len() - idx
{
    if idx >= s.len() {
        0
    } else if s[idx] == '\n' {
        1 + count_newlines(s, idx + 1)
    } else {
        count_newlines(s, idx + 1)
    }
}

spec fn valid_input_string(s: Seq<char>) -> bool {
    s.len() >= 7 &&
    contains_four_lines(s) &&
    all_lines_have_four_valid_integers(s)
}

spec fn contains_four_lines(s: Seq<char>) -> bool {
    count_newlines(s, 0) >= 3
}

spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1' || s[i] == ' ' || s[i] == '\n')
}

spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {
    input_lines.len() == 4 &&
    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&
    (forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> 
        (#[trigger] input_lines[i][j] >= 0 && #[trigger] input_lines[i][j] <= 1)) &&
    string_contains_four_lines_of_four_integers(s, input_lines)
}

spec fn string_contains_four_lines_of_four_integers(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {
    input_lines.len() == 4 &&
    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&
    valid_input_string(s)
}

spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool
    recommends 
        lanes.len() == 4,
        forall|i: int| 0 <= i < 4 ==> #[trigger] lanes[i].len() == 4,
        forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> 
            (#[trigger] lanes[i][j] == 0 || #[trigger] lanes[i][j] == 1)
{
    exists|i: int| 0 <= i < 4 && accident_at_lane(i, lanes)
}

spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool
    recommends 
        0 <= i < 4,
        lanes.len() == 4,
        forall|j: int| 0 <= j < 4 ==> #[trigger] lanes[j].len() == 4
{
    (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||
    (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||
    (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||
    (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        s.len() > 0,
        forall|i: int| 0 <= i < s.len() ==> (#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),
        valid_input_string(s@)
    ensures 
        result@ == ""YES\n""@ || result@ == ""NO\n""@,
        exists|input_lines: Seq<Seq<int>>| 
            parse_input(s@, input_lines) && 
            (result@ == ""YES\n""@ <==> accident_possible(input_lines)),
        result.len() >= 3
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn count_newlines(s: Seq<char>, idx: int) -> int     decreases s.len() - idx ;
       spec fn valid_input_string(s: Seq<char>) -> bool ;
       spec fn contains_four_lines(s: Seq<char>) -> bool ;
       spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool ;
       spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;
       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        
#[trigger] lanes[i].len() == 4,
;
       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        
#[trigger] lanes[j].len() == 4
{
          (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||     (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||     (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||     (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1) }
       fn solve(s: Vec<char>) -> (result: Vec<char>)     requires          s.len() > 0,         forall|i: int| 0 <= i < s.len() ==> (       
#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),
        valid_input_string(s@)     ensures          result@ == ""YES\n""@ || result@ == ""NO\n""@,         exists|input_lines: Seq<Seq<int>>|              parse_input(s@, input_lines) &&              (result@ == ""YES\n""@ <==> accident_possible(input_lines)),         result.len() >= 3 {
          assume(false);
          unreached() }
       }
        fn main() {
      }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_newlines(s: Seq<char>, idx: int) -> int\n    decreases s.len() - idx\n{\n    if idx >= s.len() {\n        0\n    } else if s[idx] == \'\\n\' {\n        1 + count_newlines(s, idx + 1)\n    } else {\n        count_newlines(s, idx + 1)\n    }\n}\n\nspec fn valid_input_string(s: Seq<char>) -> bool {\n    s.len() >= 7 &&\n    contains_four_lines(s) &&\n    all_lines_have_four_valid_integers(s)\n}\n\nspec fn contains_four_lines(s: Seq<char>) -> bool {\n    count_newlines(s, 0) >= 3\n}\n\nspec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == \'0\' || s[i] == \'1\' || s[i] == \' \' || s[i] == \'\\n\')\n}\n\nspec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {\n    input_lines.len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&\n    (forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> \n        (#[trigger] input_lines[i][j] >= 0 && #[trigger] input_lines[i][j] <= 1)) &&\n    string_contains_four_lines_of_four_integers(s, input_lines)\n}\n\nspec fn string_contains_four_lines_of_four_integers(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {\n    input_lines.len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&\n    valid_input_string(s)\n}\n\nspec fn accident_possible(lanes: Seq<Seq<int>>) -> bool\n    recommends \n        lanes.len() == 4,\n        forall|i: int| 0 <= i < 4 ==> #[trigger] lanes[i].len() == 4,\n        forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> \n            (#[trigger] lanes[i][j] == 0 || #[trigger] lanes[i][j] == 1)\n{\n    exists|i: int| 0 <= i < 4 && accident_at_lane(i, lanes)\n}\n\nspec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool\n    recommends \n        0 <= i < 4,\n        lanes.len() == 4,\n        forall|j: int| 0 <= j < 4 ==> #[trigger] lanes[j].len() == 4\n{\n    (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||\n    (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||\n    (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||\n    (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> (#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),\n        valid_input_string(s@)\n    ensures \n        result@ == ""YES\\n""@ || result@ == ""NO\\n""@,\n        exists|input_lines: Seq<Seq<int>>| \n            parse_input(s@, input_lines) && \n            (result@ == ""YES\\n""@ <==> accident_possible(input_lines)),\n        result.len() >= 3\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn count_newlines(s: Seq<char>, idx: int) -> int     decreases s.len() - idx ;\n       spec fn valid_input_string(s: Seq<char>) -> bool ;\n       spec fn contains_four_lines(s: Seq<char>) -> bool ;\n       spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool ;\n       spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool ;\n       spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool     recommends          lanes.len() == 4,         forall|i: int| 0 <= i < 4 ==>        \n#[trigger] lanes[i].len() == 4,\n;\n       spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool     recommends          0 <= i < 4,         lanes.len() == 4,         forall|j: int| 0 <= j < 4 ==>        \n#[trigger] lanes[j].len() == 4\n{\n          (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||     (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||     (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||     (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1) }\n       fn solve(s: Vec<char>) -> (result: Vec<char>)     requires          s.len() > 0,         forall|i: int| 0 <= i < s.len() ==> (       \n#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),\n        valid_input_string(s@)     ensures          result@ == ""YES\\n""@ || result@ == ""NO\\n""@,         exists|input_lines: Seq<Seq<int>>|              parse_input(s@, input_lines) &&              (result@ == ""YES\\n""@ <==> accident_possible(input_lines)),         result.len() >= 3 {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1255.rs,106,106,1.0,122.434,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {
    let lines = split_lines_function(input);
    if lines.len() == 0 { 0 } else { max_frequency_in_all_lines(lines) }
}

spec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(s, 0, 0, seq![])
}

spec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i
{
    if i >= s.len() {
        if start < s.len() { acc.push(s.subrange(start, s.len() as int)) } else { acc }
    } else if s[i] == '\n' {
        let new_acc = if start < i { acc.push(s.subrange(start, i)) } else { acc };
        split_lines_helper(s, i + 1, i + 1, new_acc)
    } else {
        split_lines_helper(s, start, i + 1, acc)
    }
}

spec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {
    if lines.len() == 0 { 0 } else { max_frequency_helper(lines, 0, 0) }
}

spec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int
    decreases lines.len() - index
{
    if index >= lines.len() { current_max }
    else {
        let count = count_occurrences(lines, lines[index]);
        let new_max = if count > current_max { count } else { current_max };
        max_frequency_helper(lines, index + 1, new_max)
    }
}

spec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {
    count_occurrences_helper(lines, target, 0, 0)
}

spec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int
    decreases lines.len() - index
{
    if index >= lines.len() { count }
    else {
        let new_count = if lines[index] == target { count + 1 } else { count };
        count_occurrences_helper(lines, target, index + 1, new_count)
    }
}

spec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int
    decreases lines.len() - index
{
    if index + 1 >= lines.len() { lines.len() as int }
    else if lines[index + 1] == lines[index] { skip_identical(lines, index + 1) }
    else { index + 1 }
}

spec fn int_to_string_function(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n > 0 { int_to_string_helper(n, seq![]) }
    else { seq!['0'] }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>
    decreases n
{
    let digit = n % 10;
    let digit_char = ('0' as u32 + digit as u32) as char;
    if n / 10 == 0 { seq![digit_char].add(acc) }
    else if n / 10 > 0 && n / 10 < n { int_to_string_helper(n / 10, seq![digit_char].add(acc)) }
    else { seq![digit_char].add(acc) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {
    let lines = split_lines_function(input);
    if lines.len() == 0 { 0 } else { max_frequency_in_all_lines(lines) }
}

spec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(s, 0, 0, seq![])
}

spec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i
{
    if i >= s.len() {
        if start < s.len() { acc.push(s.subrange(start, s.len() as int)) } else { acc }
    } else if s[i] == '\n' {
        let new_acc = if start < i { acc.push(s.subrange(start, i)) } else { acc };
        split_lines_helper(s, i + 1, i + 1, new_acc)
    } else {
        split_lines_helper(s, start, i + 1, acc)
    }
}

spec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {
    if lines.len() == 0 { 0 } else { max_frequency_helper(lines, 0, 0) }
}

spec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int
    decreases lines.len() - index
{
    if index >= lines.len() { current_max }
    else {
        let count = count_occurrences(lines, lines[index]);
        let new_max = if count > current_max { count } else { current_max };
        max_frequency_helper(lines, index + 1, new_max)
    }
}

spec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {
    count_occurrences_helper(lines, target, 0, 0)
}

spec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int
    decreases lines.len() - index
{
    if index >= lines.len() { count }
    else {
        let new_count = if lines[index] == target { count + 1 } else { count };
        count_occurrences_helper(lines, target, index + 1, new_count)
    }
}

spec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int
    decreases lines.len() - index
{
    if index + 1 >= lines.len() { lines.len() as int }
    else if lines[index + 1] == lines[index] { skip_identical(lines, index + 1) }
    else { index + 1 }
}

spec fn int_to_string_function(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n > 0 { int_to_string_helper(n, seq![]) }
    else { seq!['0'] }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>
    decreases n
{
    let digit = n % 10;
    let digit_char = ('0' as u32 + digit as u32) as char;
    if n / 10 == 0 { seq![digit_char].add(acc) }
    else if n / 10 > 0 && n / 10 < n { int_to_string_helper(n / 10, seq![digit_char].add(acc)) }
    else { seq![digit_char].add(acc) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {\n    let lines = split_lines_function(input);\n    if lines.len() == 0 { 0 } else { max_frequency_in_all_lines(lines) }\n}\n\nspec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(s, 0, 0, seq![])\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if start < s.len() { acc.push(s.subrange(start, s.len() as int)) } else { acc }\n    } else if s[i] == '\\n' {\n        let new_acc = if start < i { acc.push(s.subrange(start, i)) } else { acc };\n        split_lines_helper(s, i + 1, i + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, i + 1, acc)\n    }\n}\n\nspec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {\n    if lines.len() == 0 { 0 } else { max_frequency_helper(lines, 0, 0) }\n}\n\nspec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { current_max }\n    else {\n        let count = count_occurrences(lines, lines[index]);\n        let new_max = if count > current_max { count } else { current_max };\n        max_frequency_helper(lines, index + 1, new_max)\n    }\n}\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {\n    count_occurrences_helper(lines, target, 0, 0)\n}\n\nspec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int\n    decreases lines.len() - index\n{\n    if index >= lines.len() { count }\n    else {\n        let new_count = if lines[index] == target { count + 1 } else { count };\n        count_occurrences_helper(lines, target, index + 1, new_count)\n    }\n}\n\nspec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int\n    decreases lines.len() - index\n{\n    if index + 1 >= lines.len() { lines.len() as int }\n    else if lines[index + 1] == lines[index] { skip_identical(lines, index + 1) }\n    else { index + 1 }\n}\n\nspec fn int_to_string_function(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n > 0 { int_to_string_helper(n, seq![]) }\n    else { seq!['0'] }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    let digit = n % 10;\n    let digit_char = ('0' as u32 + digit as u32) as char;\n    if n / 10 == 0 { seq![digit_char].add(acc) }\n    else if n / 10 > 0 && n / 10 < n { int_to_string_helper(n / 10, seq![digit_char].add(acc)) }\n    else { seq![digit_char].add(acc) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_126.rs,80,80,1.0,122.434,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn string_to_digits(s: Seq<char>) -> Set<int> {
    Set::new(|i: int| 
        0 <= i < s.len() && 
        '0' <= s[i] && 
        s[i] <= '9' && 
        (s[i] as int) - ('0' as int) >= 0
    ).map(|i: int| (s[i] as int) - ('0' as int))
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.contains('\n')
}

spec fn has_unique_movement_sequence(digits: Set<int>) -> bool {
    (digits.contains(1) || digits.contains(4) || digits.contains(7) || digits.contains(0)) &&
    (digits.contains(1) || digits.contains(2) || digits.contains(3)) &&
    (digits.contains(3) || digits.contains(6) || digits.contains(9) || digits.contains(0)) &&
    (digits.contains(7) || digits.contains(0) || digits.contains(9))
}

spec fn find_char_index(s: Seq<char>, c: char) -> int {
    if exists|i: int| 0 <= i < s.len() && s[i] == c {
        choose|i: int| 0 <= i < s.len() && s[i] == c
    } else {
        -1
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if !s.contains('\n') {
        seq![s]
    } else {
        let idx = find_char_index(s, '\n');
        if idx == -1 {
            seq![s]
        } else if idx < s.len() {
            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx + 1, s.len() as int)))
        } else {
            seq![s]
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() == 3 || result@.len() == 4,
        result@.len() > 0,
        ({
            let lines = split_lines(input@);
            lines.len() >= 2 ==> {
                let digits_str = lines[1];
                let digits = string_to_digits(digits_str);
                has_unique_movement_sequence(digits) ==> result@.len() == 4
            }
        })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn string_to_digits(s: Seq<char>) -> Set<int> {
    Set::new(|i: int| 
        0 <= i < s.len() && 
        '0' <= s[i] && 
        s[i] <= '9' && 
        (s[i] as int) - ('0' as int) >= 0
    ).map(|i: int| (s[i] as int) - ('0' as int))
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.contains('\n')
}

spec fn has_unique_movement_sequence(digits: Set<int>) -> bool {
    (digits.contains(1) || digits.contains(4) || digits.contains(7) || digits.contains(0)) &&
    (digits.contains(1) || digits.contains(2) || digits.contains(3)) &&
    (digits.contains(3) || digits.contains(6) || digits.contains(9) || digits.contains(0)) &&
    (digits.contains(7) || digits.contains(0) || digits.contains(9))
}

spec fn find_char_index(s: Seq<char>, c: char) -> int {
    if exists|i: int| 0 <= i < s.len() && s[i] == c {
        choose|i: int| 0 <= i < s.len() && s[i] == c
    } else {
        -1
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if !s.contains('\n') {
        seq![s]
    } else {
        let idx = find_char_index(s, '\n');
        if idx == -1 {
            seq![s]
        } else if idx < s.len() {
            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx + 1, s.len() as int)))
        } else {
            seq![s]
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() == 3 || result@.len() == 4,
        result@.len() > 0,
        ({
            let lines = split_lines(input@);
            lines.len() >= 2 ==> {
                let digits_str = lines[1];
                let digits = string_to_digits(digits_str);
                has_unique_movement_sequence(digits) ==> result@.len() == 4
            }
        })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn string_to_digits(s: Seq<char>) -> Set<int> {\n    Set::new(|i: int| \n        0 <= i < s.len() && \n        '0' <= s[i] && \n        s[i] <= '9' && \n        (s[i] as int) - ('0' as int) >= 0\n    ).map(|i: int| (s[i] as int) - ('0' as int))\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n')\n}\n\nspec fn has_unique_movement_sequence(digits: Set<int>) -> bool {\n    (digits.contains(1) || digits.contains(4) || digits.contains(7) || digits.contains(0)) &&\n    (digits.contains(1) || digits.contains(2) || digits.contains(3)) &&\n    (digits.contains(3) || digits.contains(6) || digits.contains(9) || digits.contains(0)) &&\n    (digits.contains(7) || digits.contains(0) || digits.contains(9))\n}\n\nspec fn find_char_index(s: Seq<char>, c: char) -> int {\n    if exists|i: int| 0 <= i < s.len() && s[i] == c {\n        choose|i: int| 0 <= i < s.len() && s[i] == c\n    } else {\n        -1\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if !s.contains('\\n') {\n        seq![s]\n    } else {\n        let idx = find_char_index(s, '\\n');\n        if idx == -1 {\n            seq![s]\n        } else if idx < s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx + 1, s.len() as int)))\n        } else {\n            seq![s]\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() == 3 || result@.len() == 4,\n        result@.len() > 0,\n        ({\n            let lines = split_lines(input@);\n            lines.len() >= 2 ==> {\n                let digits_str = lines[1];\n                let digits = string_to_digits(digits_str);\n                has_unique_movement_sequence(digits) ==> result@.len() == 4\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1282.rs,112,112,1.0,122.811,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'M' || input[i] == 'F'
}

spec fn compute_swap_time(input: Seq<char>) -> nat
    recommends valid_input(input)
{
    let rev_input = input.reverse();
    let first_f = find_char(rev_input, 'F', 0);

    if first_f == -1 { 0nat }
    else {
        let first_m_after_f = find_char(rev_input, 'M', first_f + 1);
        if first_m_after_f == -1 { 0nat }
        else {
            let last_m = rfind_char(rev_input, 'M');
            if last_m < first_m_after_f { 0nat }
            else {
                let substring = rev_input.subrange(first_m_after_f, last_m + 1);
                let balance = calculate_balance(substring);
                let f_count = count_char(substring, 'F');
                (balance + f_count + first_m_after_f - first_f - 1) as nat
            }
        }
    }
}
spec fn find_char(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start] == c { start }
    else { find_char(s, c, start + 1) }
}

spec fn rfind_char(s: Seq<char>, c: char) -> int {
    rfind_char_helper(s, c, s.len() as int - 1)
}

spec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int
    decreases pos + 1
{
    if pos < 0 { -1 }
    else if s[pos] == c { pos }
    else { rfind_char_helper(s, c, pos - 1) }
}

spec fn calculate_balance(s: Seq<char>) -> nat {
    calculate_balance_helper(s, 0, 0)
}

spec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat
    decreases s.len() - pos
{
    if pos >= s.len() { balance as nat }
    else if s[pos] == 'M' { calculate_balance_helper(s, pos + 1, balance + 1) }
    else { calculate_balance_helper(s, pos + 1, if balance > 0 { balance - 1 } else { 0 }) }
}

spec fn count_char(s: Seq<char>, c: char) -> nat {
    count_char_helper(s, c, 0, 0)
}

spec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat
    decreases s.len() - pos
{
    if pos >= s.len() { count }
    else if s[pos] == c { count_char_helper(s, c, pos + 1, count + 1) }
    else { count_char_helper(s, c, pos + 1, count) }
}

spec fn nat_to_string(n: nat) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { nat_to_string_helper(n, seq![]) }
}

spec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>
    decreases n
{
    if n == 0 { acc }
    else { nat_to_string_helper(n / 10, seq![('0' as u8 + (n % 10) as u8) as char] + acc) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() >= 1,
        result@[result@.len() - 1] == '\n',
        exists|val: nat| val >= 0 && result@ == nat_to_string(val) + seq!['\n'],
        result@ == nat_to_string(compute_swap_time(input@)) + seq!['\n']
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'M' || input[i] == 'F'
}

spec fn compute_swap_time(input: Seq<char>) -> nat
    recommends valid_input(input)
{
    let rev_input = input.reverse();
    let first_f = find_char(rev_input, 'F', 0);

    if first_f == -1 { 0nat }
    else {
        let first_m_after_f = find_char(rev_input, 'M', first_f + 1);
        if first_m_after_f == -1 { 0nat }
        else {
            let last_m = rfind_char(rev_input, 'M');
            if last_m < first_m_after_f { 0nat }
            else {
                let substring = rev_input.subrange(first_m_after_f, last_m + 1);
                let balance = calculate_balance(substring);
                let f_count = count_char(substring, 'F');
                (balance + f_count + first_m_after_f - first_f - 1) as nat
            }
        }
    }
}
spec fn find_char(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start] == c { start }
    else { find_char(s, c, start + 1) }
}

spec fn rfind_char(s: Seq<char>, c: char) -> int {
    rfind_char_helper(s, c, s.len() as int - 1)
}

spec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int
    decreases pos + 1
{
    if pos < 0 { -1 }
    else if s[pos] == c { pos }
    else { rfind_char_helper(s, c, pos - 1) }
}

spec fn calculate_balance(s: Seq<char>) -> nat {
    calculate_balance_helper(s, 0, 0)
}

spec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat
    decreases s.len() - pos
{
    if pos >= s.len() { balance as nat }
    else if s[pos] == 'M' { calculate_balance_helper(s, pos + 1, balance + 1) }
    else { calculate_balance_helper(s, pos + 1, if balance > 0 { balance - 1 } else { 0 }) }
}

spec fn count_char(s: Seq<char>, c: char) -> nat {
    count_char_helper(s, c, 0, 0)
}

spec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat
    decreases s.len() - pos
{
    if pos >= s.len() { count }
    else if s[pos] == c { count_char_helper(s, c, pos + 1, count + 1) }
    else { count_char_helper(s, c, pos + 1, count) }
}

spec fn nat_to_string(n: nat) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { nat_to_string_helper(n, seq![]) }
}

spec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>
    decreases n
{
    if n == 0 { acc }
    else { nat_to_string_helper(n / 10, seq![('0' as u8 + (n % 10) as u8) as char] + acc) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() >= 1,
        result@[result@.len() - 1] == '\n',
        exists|val: nat| val >= 0 && result@ == nat_to_string(val) + seq!['\n'],
        result@ == nat_to_string(compute_swap_time(input@)) + seq!['\n']
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'M' || input[i] == 'F'\n}\n\nspec fn compute_swap_time(input: Seq<char>) -> nat\n    recommends valid_input(input)\n{\n    let rev_input = input.reverse();\n    let first_f = find_char(rev_input, 'F', 0);\n\n    if first_f == -1 { 0nat }\n    else {\n        let first_m_after_f = find_char(rev_input, 'M', first_f + 1);\n        if first_m_after_f == -1 { 0nat }\n        else {\n            let last_m = rfind_char(rev_input, 'M');\n            if last_m < first_m_after_f { 0nat }\n            else {\n                let substring = rev_input.subrange(first_m_after_f, last_m + 1);\n                let balance = calculate_balance(substring);\n                let f_count = count_char(substring, 'F');\n                (balance + f_count + first_m_after_f - first_f - 1) as nat\n            }\n        }\n    }\n}\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start] == c { start }\n    else { find_char(s, c, start + 1) }\n}\n\nspec fn rfind_char(s: Seq<char>, c: char) -> int {\n    rfind_char_helper(s, c, s.len() as int - 1)\n}\n\nspec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int\n    decreases pos + 1\n{\n    if pos < 0 { -1 }\n    else if s[pos] == c { pos }\n    else { rfind_char_helper(s, c, pos - 1) }\n}\n\nspec fn calculate_balance(s: Seq<char>) -> nat {\n    calculate_balance_helper(s, 0, 0)\n}\n\nspec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { balance as nat }\n    else if s[pos] == 'M' { calculate_balance_helper(s, pos + 1, balance + 1) }\n    else { calculate_balance_helper(s, pos + 1, if balance > 0 { balance - 1 } else { 0 }) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> nat {\n    count_char_helper(s, c, 0, 0)\n}\n\nspec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat\n    decreases s.len() - pos\n{\n    if pos >= s.len() { count }\n    else if s[pos] == c { count_char_helper(s, c, pos + 1, count + 1) }\n    else { count_char_helper(s, c, pos + 1, count) }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { nat_to_string_helper(n, seq![]) }\n}\n\nspec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>\n    decreases n\n{\n    if n == 0 { acc }\n    else { nat_to_string_helper(n / 10, seq![('0' as u8 + (n % 10) as u8) as char] + acc) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|val: nat| val >= 0 && result@ == nat_to_string(val) + seq!['\\n'],\n        result@ == nat_to_string(compute_swap_time(input@)) + seq!['\\n']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1289.rs,108,22,0.2037037037037037,215.058,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

spec fn all_distances_equal(positions: Seq<int>) -> bool {
    if positions.len() <= 2 {
        true
    } else {
        let first_dist = positions[1] - positions[0];
        true /* simplified to avoid trigger issues */
    }
}

spec fn count_visits(visits: Seq<int>, stop: int) -> int {
    0 /* placeholder implementation */
}

spec fn max_val(s: Seq<int>) -> int {
    0 /* placeholder implementation */
}

spec fn sum(s: Seq<int>) -> int {
    0 /* placeholder implementation */
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> {
    let base_counts = Seq::new(n as nat, |i: int| count_visits(visits, i + 1));
    Seq::new(n as nat, |i: int| 
        if i == 0 || i == n - 1 { 
            base_counts[i] * 2 
        } else { 
            base_counts[i] 
        }
    )
}

spec fn compute_max_rounds(counts: Seq<int>) -> int {
    max_val(Seq::new(counts.len(), |i: int| counts[i] / 2))
}

spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool {
    let counts = compute_counts(n, visits);
    let max_rounds = compute_max_rounds(counts);
    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);
    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;

    all_zero && n > 2 && !all_distances_equal(positions)
}

spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int {
    let counts = compute_counts(n, visits);
    let max_rounds = compute_max_rounds(counts);
    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);
    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;

    if all_zero {
        if n == 2 {
            max_rounds * (positions[1] - positions[0]) * 2 - (positions[1] - positions[0])
        } else {
            let first_dist = positions[1] - positions[0];
            max_rounds * first_dist * 2 * (n - 1) - first_dist
        }
    } else {
        let edge_distance = sum(Seq::new((n-1) as nat, |i: int| min(remaining_counts[i], remaining_counts[i+1]) * (positions[i+1] - positions[i])));
        let total_edge_length = sum(Seq::new((n-1) as nat, |i: int| positions[i+1] - positions[i]));
        edge_distance + max_rounds * 2 * total_edge_length
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)
    requires
        n >= 1,
        positions.len() == n as nat,
        is_sorted(positions@.map(|i, x: i8| x as int)),
        m >= 1,
        visits.len() == m as nat
    ensures
        result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {
            -1
        } else {
            calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))
        }
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn is_sorted(s: Seq<int>) -> bool ;
       spec fn all_distances_equal(positions: Seq<int>) -> bool ;
       spec fn count_visits(visits: Seq<int>, stop: int) -> int ;
       spec fn max_val(s: Seq<int>) -> int ;
       spec fn sum(s: Seq<int>) -> int ;
       spec fn min(a: int, b: int) -> int ;
       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;
       spec fn compute_max_rounds(counts: Seq<int>) -> int ;
       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;
       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;
       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {
                  -1         }
       else {
                  calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))         }
       {
          assume(false);
          unreached() }
       }
        fn main() {
      }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn all_distances_equal(positions: Seq<int>) -> bool {\n    if positions.len() <= 2 {\n        true\n    } else {\n        let first_dist = positions[1] - positions[0];\n        true /* simplified to avoid trigger issues */\n    }\n}\n\nspec fn count_visits(visits: Seq<int>, stop: int) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn max_val(s: Seq<int>) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn sum(s: Seq<int>) -> int {\n    0 /* placeholder implementation */\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> {\n    let base_counts = Seq::new(n as nat, |i: int| count_visits(visits, i + 1));\n    Seq::new(n as nat, |i: int| \n        if i == 0 || i == n - 1 { \n            base_counts[i] * 2 \n        } else { \n            base_counts[i] \n        }\n    )\n}\n\nspec fn compute_max_rounds(counts: Seq<int>) -> int {\n    max_val(Seq::new(counts.len(), |i: int| counts[i] / 2))\n}\n\nspec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool {\n    let counts = compute_counts(n, visits);\n    let max_rounds = compute_max_rounds(counts);\n    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);\n    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;\n\n    all_zero && n > 2 && !all_distances_equal(positions)\n}\n\nspec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int {\n    let counts = compute_counts(n, visits);\n    let max_rounds = compute_max_rounds(counts);\n    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);\n    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;\n\n    if all_zero {\n        if n == 2 {\n            max_rounds * (positions[1] - positions[0]) * 2 - (positions[1] - positions[0])\n        } else {\n            let first_dist = positions[1] - positions[0];\n            max_rounds * first_dist * 2 * (n - 1) - first_dist\n        }\n    } else {\n        let edge_distance = sum(Seq::new((n-1) as nat, |i: int| min(remaining_counts[i], remaining_counts[i+1]) * (positions[i+1] - positions[i])));\n        let total_edge_length = sum(Seq::new((n-1) as nat, |i: int| positions[i+1] - positions[i]));\n        edge_distance + max_rounds * 2 * total_edge_length\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)\n    requires\n        n >= 1,\n        positions.len() == n as nat,\n        is_sorted(positions@.map(|i, x: i8| x as int)),\n        m >= 1,\n        visits.len() == m as nat\n    ensures\n        result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n            -1\n        } else {\n            calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn all_distances_equal(positions: Seq<int>) -> bool ;\n       spec fn count_visits(visits: Seq<int>, stop: int) -> int ;\n       spec fn max_val(s: Seq<int>) -> int ;\n       spec fn sum(s: Seq<int>) -> int ;\n       spec fn min(a: int, b: int) -> int ;\n       spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> ;\n       spec fn compute_max_rounds(counts: Seq<int>) -> int ;\n       spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool ;\n       spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int ;\n       fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)     requires         n >= 1,         positions.len() == n as nat,         is_sorted(positions@.map(|i, x: i8| x as int)),         m >= 1,         visits.len() == m as nat     ensures         result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {\n                  -1         }\n       else {\n                  calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))         }\n       {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1291.rs,140,140,1.0,122.597,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input.index(i) == '\n') &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    input.len() >= 3
}

spec fn valid_output(output: Seq<char>) -> bool {
    output == ""YES\n""@ || output == ""NO\n""@
}

spec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)
    recommends valid_input(input)
{
    let lines = split_lines(input);
    if lines.len() >= 1 {
        let first_line = lines[0];
        let nm_parts = split_whitespace(first_line);
        if nm_parts.len() >= 2 {
            let n = string_to_int(nm_parts[0]);
            let m = string_to_int(nm_parts[1]);
            let a_lines = if lines.len() > n { lines.subrange(1, n+1) } else { Seq::empty() };
            let b_lines = if lines.len() > n + m { lines.subrange(n+1, n+m+1) } else { Seq::empty() };
            (n, m, first_line, a_lines, b_lines)
        } else {
            let a_seq = Seq::new(1, |i: int| Seq::empty());
            let b_seq = Seq::new(1, |i: int| Seq::empty());
            (1, 1, first_line, a_seq, b_seq)
        }
    } else {
        let a_seq = Seq::new(1, |i: int| Seq::empty());
        let b_seq = Seq::new(1, |i: int| Seq::empty());
        (1, 1, Seq::empty(), a_seq, b_seq)
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty() /* placeholder for line splitting */
}

spec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty() /* placeholder for whitespace splitting */
}

spec fn string_to_int(s: Seq<char>) -> int {
    0 /* placeholder for string to int conversion */
}

spec fn solve_circle_separation(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let parsed = parse_input(input);
    let n = parsed.0;
    let m = parsed.1;
    let nm_string = parsed.2;
    let a = parsed.3;
    let b = parsed.4;

    if (
        (n == 2 && m == 2 && a.len() > 0 && a[0] == ""-1 0""@) ||
        (n == 2 && m == 3 && a.len() > 0 && a[0] == ""-1 0""@) ||
        (n == 3 && m == 3 && a.len() > 0 && a[0] == ""-3 -4""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""15 70""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""28 9""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""917 -4476""@) ||
        (n == 3 && m == 2 && a.len() > 0 && a[0] == ""9599 -9999""@) ||
        (n == 145 && m == 143 && a.len() > 0 && a[0] == ""-5915 6910""@) ||
        (n == 2 && m == 10 && a.len() >= 2 && ((a[0] == ""-1 0""@ && a[1] == ""0 -1""@) || (a[0] == ""1 0""@ && a[1] == ""0 1""@))) ||
        (n == 2 && m == 3 && a.len() > 0 && a[0] == ""0 -1""@) ||
        (n == 100 && m == 100 && a.len() > 0 && a[0] == ""-10000 6429""@)
    ) { 
        ""NO\n""@
    }
    else if (
        (n == 4 && m == 4 && a.len() > 0 && a[0] == ""1 0""@) ||
        (n == 3 && m == 4 && a.len() > 0 && a[0] == ""-9998 -10000""@) ||
        (n == 1) ||
        (m == 1) ||
        (n == 2 && m == 2 && a.len() > 0 && a[0] == ""3782 2631""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-4729 -6837""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""6558 -2280""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-5051 5846""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-4547 4547""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""7010 10000""@) ||
        (n == 1948 && m == 1091 && a.len() > 0 && a[0] == ""-1873 -10000""@) ||
        (n == 1477 && m == 1211 && a.len() > 0 && a[0] == ""2770 -10000""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""5245 6141""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""-4957 8783""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""-1729 2513""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""8781 -5556""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""5715 5323""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""-1323 290""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""6828 3257""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""1592 -154""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""-1535 5405""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && (a[0] == ""-3041 8307""@ || a[0] == ""-2797 3837""@ || a[0] == ""8393 -5715""@))
    ) { 
        ""YES\n""@
    }
    else if (n >= 1000) { 
        ""NO\n""@
    }
    else { 
        ""YES\n""@
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures 
        valid_output(result@) &&
        result@ == solve_circle_separation(stdin_input@) &&
        result@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input.index(i) == '\n') &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    input.len() >= 3
}

spec fn valid_output(output: Seq<char>) -> bool {
    output == ""YES\n""@ || output == ""NO\n""@
}

spec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)
    recommends valid_input(input)
{
    let lines = split_lines(input);
    if lines.len() >= 1 {
        let first_line = lines[0];
        let nm_parts = split_whitespace(first_line);
        if nm_parts.len() >= 2 {
            let n = string_to_int(nm_parts[0]);
            let m = string_to_int(nm_parts[1]);
            let a_lines = if lines.len() > n { lines.subrange(1, n+1) } else { Seq::empty() };
            let b_lines = if lines.len() > n + m { lines.subrange(n+1, n+m+1) } else { Seq::empty() };
            (n, m, first_line, a_lines, b_lines)
        } else {
            let a_seq = Seq::new(1, |i: int| Seq::empty());
            let b_seq = Seq::new(1, |i: int| Seq::empty());
            (1, 1, first_line, a_seq, b_seq)
        }
    } else {
        let a_seq = Seq::new(1, |i: int| Seq::empty());
        let b_seq = Seq::new(1, |i: int| Seq::empty());
        (1, 1, Seq::empty(), a_seq, b_seq)
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty() /* placeholder for line splitting */
}

spec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty() /* placeholder for whitespace splitting */
}

spec fn string_to_int(s: Seq<char>) -> int {
    0 /* placeholder for string to int conversion */
}

spec fn solve_circle_separation(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let parsed = parse_input(input);
    let n = parsed.0;
    let m = parsed.1;
    let nm_string = parsed.2;
    let a = parsed.3;
    let b = parsed.4;

    if (
        (n == 2 && m == 2 && a.len() > 0 && a[0] == ""-1 0""@) ||
        (n == 2 && m == 3 && a.len() > 0 && a[0] == ""-1 0""@) ||
        (n == 3 && m == 3 && a.len() > 0 && a[0] == ""-3 -4""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""15 70""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""28 9""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""917 -4476""@) ||
        (n == 3 && m == 2 && a.len() > 0 && a[0] == ""9599 -9999""@) ||
        (n == 145 && m == 143 && a.len() > 0 && a[0] == ""-5915 6910""@) ||
        (n == 2 && m == 10 && a.len() >= 2 && ((a[0] == ""-1 0""@ && a[1] == ""0 -1""@) || (a[0] == ""1 0""@ && a[1] == ""0 1""@))) ||
        (n == 2 && m == 3 && a.len() > 0 && a[0] == ""0 -1""@) ||
        (n == 100 && m == 100 && a.len() > 0 && a[0] == ""-10000 6429""@)
    ) { 
        ""NO\n""@
    }
    else if (
        (n == 4 && m == 4 && a.len() > 0 && a[0] == ""1 0""@) ||
        (n == 3 && m == 4 && a.len() > 0 && a[0] == ""-9998 -10000""@) ||
        (n == 1) ||
        (m == 1) ||
        (n == 2 && m == 2 && a.len() > 0 && a[0] == ""3782 2631""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-4729 -6837""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""6558 -2280""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-5051 5846""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-4547 4547""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""7010 10000""@) ||
        (n == 1948 && m == 1091 && a.len() > 0 && a[0] == ""-1873 -10000""@) ||
        (n == 1477 && m == 1211 && a.len() > 0 && a[0] == ""2770 -10000""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""5245 6141""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""-4957 8783""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""-1729 2513""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""8781 -5556""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""5715 5323""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""-1323 290""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""6828 3257""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""1592 -154""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""-1535 5405""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && (a[0] == ""-3041 8307""@ || a[0] == ""-2797 3837""@ || a[0] == ""8393 -5715""@))
    ) { 
        ""YES\n""@
    }
    else if (n >= 1000) { 
        ""NO\n""@
    }
    else { 
        ""YES\n""@
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures 
        valid_output(result@) &&
        result@ == solve_circle_separation(stdin_input@) &&
        result@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input.index(i) == \'\\n\') &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() >= 3\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output == ""YES\\n""@ || output == ""NO\\n""@\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    if lines.len() >= 1 {\n        let first_line = lines[0];\n        let nm_parts = split_whitespace(first_line);\n        if nm_parts.len() >= 2 {\n            let n = string_to_int(nm_parts[0]);\n            let m = string_to_int(nm_parts[1]);\n            let a_lines = if lines.len() > n { lines.subrange(1, n+1) } else { Seq::empty() };\n            let b_lines = if lines.len() > n + m { lines.subrange(n+1, n+m+1) } else { Seq::empty() };\n            (n, m, first_line, a_lines, b_lines)\n        } else {\n            let a_seq = Seq::new(1, |i: int| Seq::empty());\n            let b_seq = Seq::new(1, |i: int| Seq::empty());\n            (1, 1, first_line, a_seq, b_seq)\n        }\n    } else {\n        let a_seq = Seq::new(1, |i: int| Seq::empty());\n        let b_seq = Seq::new(1, |i: int| Seq::empty());\n        (1, 1, Seq::empty(), a_seq, b_seq)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for line splitting */\n}\n\nspec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty() /* placeholder for whitespace splitting */\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0 /* placeholder for string to int conversion */\n}\n\nspec fn solve_circle_separation(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let parsed = parse_input(input);\n    let n = parsed.0;\n    let m = parsed.1;\n    let nm_string = parsed.2;\n    let a = parsed.3;\n    let b = parsed.4;\n\n    if (\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == ""-1 0""@) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == ""-1 0""@) ||\n        (n == 3 && m == 3 && a.len() > 0 && a[0] == ""-3 -4""@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""15 70""@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""28 9""@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""917 -4476""@) ||\n        (n == 3 && m == 2 && a.len() > 0 && a[0] == ""9599 -9999""@) ||\n        (n == 145 && m == 143 && a.len() > 0 && a[0] == ""-5915 6910""@) ||\n        (n == 2 && m == 10 && a.len() >= 2 && ((a[0] == ""-1 0""@ && a[1] == ""0 -1""@) || (a[0] == ""1 0""@ && a[1] == ""0 1""@))) ||\n        (n == 2 && m == 3 && a.len() > 0 && a[0] == ""0 -1""@) ||\n        (n == 100 && m == 100 && a.len() > 0 && a[0] == ""-10000 6429""@)\n    ) { \n        ""NO\\n""@\n    }\n    else if (\n        (n == 4 && m == 4 && a.len() > 0 && a[0] == ""1 0""@) ||\n        (n == 3 && m == 4 && a.len() > 0 && a[0] == ""-9998 -10000""@) ||\n        (n == 1) ||\n        (m == 1) ||\n        (n == 2 && m == 2 && a.len() > 0 && a[0] == ""3782 2631""@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-4729 -6837""@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""6558 -2280""@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-5051 5846""@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-4547 4547""@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""7010 10000""@) ||\n        (n == 1948 && m == 1091 && a.len() > 0 && a[0] == ""-1873 -10000""@) ||\n        (n == 1477 && m == 1211 && a.len() > 0 && a[0] == ""2770 -10000""@) ||\n        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""5245 6141""@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""-4957 8783""@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""-1729 2513""@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""8781 -5556""@) ||\n        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""5715 5323""@) ||\n        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""-1323 290""@) ||\n        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""6828 3257""@) ||\n        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""1592 -154""@) ||\n        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""-1535 5405""@) ||\n        (nm_string == ""10000 10000""@ && a.len() > 0 && (a[0] == ""-3041 8307""@ || a[0] == ""-2797 3837""@ || a[0] == ""8393 -5715""@))\n    ) { \n        ""YES\\n""@\n    }\n    else if (n >= 1000) { \n        ""NO\\n""@\n    }\n    else { \n        ""YES\\n""@\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        valid_output(result@) &&\n        result@ == solve_circle_separation(stdin_input@) &&\n        result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1298.rs,107,107,1.0,154.468,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] == '0' || #[trigger] s[i] == '1')
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (s[0] != '0' || s.len() == 1) && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }
}

spec fn abs_diff_count(s: Seq<char>) -> int
    recommends is_binary_string(s)
{
    let count0 = count_char(s, '0');
    let count1 = count_char(s, '1');
    if count1 >= count0 { count1 - count0 } else { count0 - count1 }
}

spec fn int_to_string(n: int) -> Seq<char>
    recommends n >= 0
    decreases n
{
    if n == 0 { seq!['0'] }
    else if n < 10 { seq![char_of_digit(n)] }
    else { int_to_string(n / 10).add(seq![char_of_digit(n % 10)]) }
}

spec fn char_of_digit(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0int { '0' }
    else if d == 1int { '1' }
    else if d == 2int { '2' }
    else if d == 3int { '3' }
    else if d == 4int { '4' }
    else if d == 5int { '5' }
    else if d == 6int { '6' }
    else if d == 7int { '7' }
    else if d == 8int { '8' }
    else if d == 9int { '9' }
    else { '0' }
}

spec fn string_to_int(s: Seq<char>) -> int
    recommends is_valid_integer(s)
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else if s.len() == 1 { (s[0] as int) - ('0' as int) }
    else { string_to_int(s.subrange(0, s.len() - 1)) * 10int + ((s[s.len() - 1] as int) - ('0' as int)) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires 
        stdin_input@.len() > 0,
        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n',
        exists|newline_pos: int| {
            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\n' &&
            newline_pos + 1 < stdin_input@.len() &&
            exists|binary_end: int| {
                newline_pos + 1 <= binary_end <= stdin_input@.len() &&
                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\n') &&
                is_valid_integer(stdin_input@.subrange(0, newline_pos)) &&
                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end))
            }
        },
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        exists|newline_pos: int| {
            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\n' &&
            newline_pos + 1 < stdin_input@.len() &&
            exists|binary_end: int| {
                newline_pos + 1 <= binary_end <= stdin_input@.len() &&
                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\n') &&
                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end)) &&
                result@ == int_to_string(abs_diff_count(stdin_input@.subrange(newline_pos + 1, binary_end))).add(seq!['\n'])
            }
        },
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}
fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] == '0' || #[trigger] s[i] == '1')
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (s[0] != '0' || s.len() == 1) && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }
}

spec fn abs_diff_count(s: Seq<char>) -> int
    recommends is_binary_string(s)
{
    let count0 = count_char(s, '0');
    let count1 = count_char(s, '1');
    if count1 >= count0 { count1 - count0 } else { count0 - count1 }
}

spec fn int_to_string(n: int) -> Seq<char>
    recommends n >= 0
    decreases n
{
    if n == 0 { seq!['0'] }
    else if n < 10 { seq![char_of_digit(n)] }
    else { int_to_string(n / 10).add(seq![char_of_digit(n % 10)]) }
}

spec fn char_of_digit(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0int { '0' }
    else if d == 1int { '1' }
    else if d == 2int { '2' }
    else if d == 3int { '3' }
    else if d == 4int { '4' }
    else if d == 5int { '5' }
    else if d == 6int { '6' }
    else if d == 7int { '7' }
    else if d == 8int { '8' }
    else if d == 9int { '9' }
    else { '0' }
}

spec fn string_to_int(s: Seq<char>) -> int
    recommends is_valid_integer(s)
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else if s.len() == 1 { (s[0] as int) - ('0' as int) }
    else { string_to_int(s.subrange(0, s.len() - 1)) * 10int + ((s[s.len() - 1] as int) - ('0' as int)) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires 
        stdin_input@.len() > 0,
        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n',
        exists|newline_pos: int| {
            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\n' &&
            newline_pos + 1 < stdin_input@.len() &&
            exists|binary_end: int| {
                newline_pos + 1 <= binary_end <= stdin_input@.len() &&
                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\n') &&
                is_valid_integer(stdin_input@.subrange(0, newline_pos)) &&
                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end))
            }
        },
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        exists|newline_pos: int| {
            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\n' &&
            newline_pos + 1 < stdin_input@.len() &&
            exists|binary_end: int| {
                newline_pos + 1 <= binary_end <= stdin_input@.len() &&
                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\n') &&
                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end)) &&
                result@ == int_to_string(abs_diff_count(stdin_input@.subrange(newline_pos + 1, binary_end))).add(seq!['\n'])
            }
        },
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}
fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] == '0' || #[trigger] s[i] == '1')\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (s[0] != '0' || s.len() == 1) && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn abs_diff_count(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    let count0 = count_char(s, '0');\n    let count1 = count_char(s, '1');\n    if count1 >= count0 { count1 - count0 } else { count0 - count1 }\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { seq!['0'] }\n    else if n < 10 { seq![char_of_digit(n)] }\n    else { int_to_string(n / 10).add(seq![char_of_digit(n % 10)]) }\n}\n\nspec fn char_of_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0int { '0' }\n    else if d == 1int { '1' }\n    else if d == 2int { '2' }\n    else if d == 3int { '3' }\n    else if d == 4int { '4' }\n    else if d == 5int { '5' }\n    else if d == 6int { '6' }\n    else if d == 7int { '7' }\n    else if d == 8int { '8' }\n    else if d == 9int { '9' }\n    else { '0' }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else if s.len() == 1 { (s[0] as int) - ('0' as int) }\n    else { string_to_int(s.subrange(0, s.len() - 1)) * 10int + ((s[s.len() - 1] as int) - ('0' as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_valid_integer(stdin_input@.subrange(0, newline_pos)) &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end))\n            }\n        },\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        exists|newline_pos: int| {\n            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\\n' &&\n            newline_pos + 1 < stdin_input@.len() &&\n            exists|binary_end: int| {\n                newline_pos + 1 <= binary_end <= stdin_input@.len() &&\n                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\\n') &&\n                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end)) &&\n                result@ == int_to_string(abs_diff_count(stdin_input@.subrange(newline_pos + 1, binary_end))).add(seq!['\\n'])\n            }\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1301.rs,75,75,1.0,122.516,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_pokemon_name(name: Seq<char>) -> bool {
    name == seq!['v','a','p','o','r','e','o','n'] || 
    name == seq!['j','o','l','t','e','o','n'] || 
    name == seq!['f','l','a','r','e','o','n'] || 
    name == seq!['e','s','p','e','o','n'] ||
    name == seq!['u','m','b','r','e','o','n'] || 
    name == seq!['l','e','a','f','e','o','n'] || 
    name == seq!['g','l','a','c','e','o','n'] || 
    name == seq!['s','y','l','v','e','o','n']
}

spec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool
    recommends pokemon_name.len() == pattern.len()
{
    pokemon_name.len() == pattern.len() &&
    forall|i: int| 0 <= i < pattern.len() ==> (pattern[i] == '.' || pattern[i] == pokemon_name[i])
}

spec fn get_pokemon_list() -> Seq<Seq<char>> {
    seq![
        seq!['v','a','p','o','r','e','o','n'],
        seq!['j','o','l','t','e','o','n'],
        seq!['f','l','a','r','e','o','n'],
        seq!['e','s','p','e','o','n'],
        seq!['u','m','b','r','e','o','n'],
        seq!['l','e','a','f','e','o','n'],
        seq!['g','l','a','c','e','o','n'],
        seq!['s','y','l','v','e','o','n']
    ]
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
    /* Additional validation logic would be implemented here */
}

spec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {
    exists|i: int| 0 <= i < pokemon_list.len() && 
        pokemon_list[i] == result &&
        result.len() == pattern.len() &&
        matches_pattern(result, pattern) &&
        forall|j: int| 0 <= j < i ==> (pokemon_list[j].len() != pattern.len() || !matches_pattern(pokemon_list[j], pattern))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        valid_input(input@),
    ensures
        valid_pokemon_name(result@),
        is_first_match(result@, input@, get_pokemon_list()),
        exists|i: int| 0 <= i < get_pokemon_list().len() && 
            get_pokemon_list()[i] == result@ &&
            matches_pattern(result@, input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_pokemon_name(name: Seq<char>) -> bool {
    name == seq!['v','a','p','o','r','e','o','n'] || 
    name == seq!['j','o','l','t','e','o','n'] || 
    name == seq!['f','l','a','r','e','o','n'] || 
    name == seq!['e','s','p','e','o','n'] ||
    name == seq!['u','m','b','r','e','o','n'] || 
    name == seq!['l','e','a','f','e','o','n'] || 
    name == seq!['g','l','a','c','e','o','n'] || 
    name == seq!['s','y','l','v','e','o','n']
}

spec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool
    recommends pokemon_name.len() == pattern.len()
{
    pokemon_name.len() == pattern.len() &&
    forall|i: int| 0 <= i < pattern.len() ==> (pattern[i] == '.' || pattern[i] == pokemon_name[i])
}

spec fn get_pokemon_list() -> Seq<Seq<char>> {
    seq![
        seq!['v','a','p','o','r','e','o','n'],
        seq!['j','o','l','t','e','o','n'],
        seq!['f','l','a','r','e','o','n'],
        seq!['e','s','p','e','o','n'],
        seq!['u','m','b','r','e','o','n'],
        seq!['l','e','a','f','e','o','n'],
        seq!['g','l','a','c','e','o','n'],
        seq!['s','y','l','v','e','o','n']
    ]
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
    /* Additional validation logic would be implemented here */
}

spec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {
    exists|i: int| 0 <= i < pokemon_list.len() && 
        pokemon_list[i] == result &&
        result.len() == pattern.len() &&
        matches_pattern(result, pattern) &&
        forall|j: int| 0 <= j < i ==> (pokemon_list[j].len() != pattern.len() || !matches_pattern(pokemon_list[j], pattern))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        valid_input(input@),
    ensures
        valid_pokemon_name(result@),
        is_first_match(result@, input@, get_pokemon_list()),
        exists|i: int| 0 <= i < get_pokemon_list().len() && 
            get_pokemon_list()[i] == result@ &&
            matches_pattern(result@, input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_pokemon_name(name: Seq<char>) -> bool {\n    name == seq!['v','a','p','o','r','e','o','n'] || \n    name == seq!['j','o','l','t','e','o','n'] || \n    name == seq!['f','l','a','r','e','o','n'] || \n    name == seq!['e','s','p','e','o','n'] ||\n    name == seq!['u','m','b','r','e','o','n'] || \n    name == seq!['l','e','a','f','e','o','n'] || \n    name == seq!['g','l','a','c','e','o','n'] || \n    name == seq!['s','y','l','v','e','o','n']\n}\n\nspec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool\n    recommends pokemon_name.len() == pattern.len()\n{\n    pokemon_name.len() == pattern.len() &&\n    forall|i: int| 0 <= i < pattern.len() ==> (pattern[i] == '.' || pattern[i] == pokemon_name[i])\n}\n\nspec fn get_pokemon_list() -> Seq<Seq<char>> {\n    seq![\n        seq!['v','a','p','o','r','e','o','n'],\n        seq!['j','o','l','t','e','o','n'],\n        seq!['f','l','a','r','e','o','n'],\n        seq!['e','s','p','e','o','n'],\n        seq!['u','m','b','r','e','o','n'],\n        seq!['l','e','a','f','e','o','n'],\n        seq!['g','l','a','c','e','o','n'],\n        seq!['s','y','l','v','e','o','n']\n    ]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* Additional validation logic would be implemented here */\n}\n\nspec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < pokemon_list.len() && \n        pokemon_list[i] == result &&\n        result.len() == pattern.len() &&\n        matches_pattern(result, pattern) &&\n        forall|j: int| 0 <= j < i ==> (pokemon_list[j].len() != pattern.len() || !matches_pattern(pokemon_list[j], pattern))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_pokemon_name(result@),\n        is_first_match(result@, input@, get_pokemon_list()),\n        exists|i: int| 0 <= i < get_pokemon_list().len() && \n            get_pokemon_list()[i] == result@ &&\n            matches_pattern(result@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1312.rs,58,58,1.0,122.504,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
  n >= m > 0
}

spec fn sum(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 
    0int 
  } else { 
    s[0] + sum(s.subrange(1, s.len() as int)) 
  }
}

spec fn count(s: Seq<int>, val: int) -> int
  decreases s.len()
{
  if s.len() == 0 { 
    0int 
  } else { 
    (if s[0] == val { 1int } else { 0int }) + count(s.subrange(1, s.len() as int), val) 
  }
}

spec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {
  &&& m > 0
  &&& result.len() == m
  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] > 0)
  &&& sum(result) == n
  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == n / m || result[i] == n / m + 1)
  &&& count(result, n / m) == m - (n % m)
  &&& count(result, n / m + 1) == n % m
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8) -> (result: Vec<i8>)
  requires valid_input(n as int, m as int)
  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
  n >= m > 0
}

spec fn sum(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 
    0int 
  } else { 
    s[0] + sum(s.subrange(1, s.len() as int)) 
  }
}

spec fn count(s: Seq<int>, val: int) -> int
  decreases s.len()
{
  if s.len() == 0 { 
    0int 
  } else { 
    (if s[0] == val { 1int } else { 0int }) + count(s.subrange(1, s.len() as int), val) 
  }
}

spec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {
  &&& m > 0
  &&& result.len() == m
  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] > 0)
  &&& sum(result) == n
  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == n / m || result[i] == n / m + 1)
  &&& count(result, n / m) == m - (n % m)
  &&& count(result, n / m + 1) == n % m
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8) -> (result: Vec<i8>)
  requires valid_input(n as int, m as int)
  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n  n >= m > 0\n}\n\nspec fn sum(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    s[0] + sum(s.subrange(1, s.len() as int)) \n  }\n}\n\nspec fn count(s: Seq<int>, val: int) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0int \n  } else { \n    (if s[0] == val { 1int } else { 0int }) + count(s.subrange(1, s.len() as int), val) \n  }\n}\n\nspec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {\n  &&& m > 0\n  &&& result.len() == m\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] > 0)\n  &&& sum(result) == n\n  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == n / m || result[i] == n / m + 1)\n  &&& count(result, n / m) == m - (n % m)\n  &&& count(result, n / m + 1) == n % m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int, m as int)\n  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1332.rs,54,54,1.0,123.468,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(coins: Seq<int>) -> bool {
    coins.len() == 5 && forall|i: int| 0 <= i < coins.len() ==> #[trigger] coins[i] >= 0 && #[trigger] coins[i] <= 100
}

spec fn total_coins(coins: Seq<int>) -> int {
    if coins.len() == 5 { coins[0] + coins[1] + coins[2] + coins[3] + coins[4] } else { 0 }
}

spec fn has_valid_solution(coins: Seq<int>) -> bool {
    if valid_input(coins) {
        let total = total_coins(coins);
        total > 0 && total % 5 == 0
    } else {
        false
    }
}

spec fn compute_result(coins: Seq<int>) -> int {
    if valid_input(coins) {
        let total = total_coins(coins);
        if total > 0 && total % 5 == 0 { total / 5 } else { -1 }
    } else {
        -1
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(coins: Vec<i8>) -> (result: i8)
    requires
        valid_input(coins@.map(|i, x| x as int)),
    ensures
        result as int == compute_result(coins@.map(|i, x| x as int)),
        has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == total_coins(coins@.map(|i, x| x as int)) / 5,
        !has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == -1,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(coins: Seq<int>) -> bool {
    coins.len() == 5 && forall|i: int| 0 <= i < coins.len() ==> #[trigger] coins[i] >= 0 && #[trigger] coins[i] <= 100
}

spec fn total_coins(coins: Seq<int>) -> int {
    if coins.len() == 5 { coins[0] + coins[1] + coins[2] + coins[3] + coins[4] } else { 0 }
}

spec fn has_valid_solution(coins: Seq<int>) -> bool {
    if valid_input(coins) {
        let total = total_coins(coins);
        total > 0 && total % 5 == 0
    } else {
        false
    }
}

spec fn compute_result(coins: Seq<int>) -> int {
    if valid_input(coins) {
        let total = total_coins(coins);
        if total > 0 && total % 5 == 0 { total / 5 } else { -1 }
    } else {
        -1
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(coins: Vec<i8>) -> (result: i8)
    requires
        valid_input(coins@.map(|i, x| x as int)),
    ensures
        result as int == compute_result(coins@.map(|i, x| x as int)),
        has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == total_coins(coins@.map(|i, x| x as int)) / 5,
        !has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == -1,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(coins: Seq<int>) -> bool {\n    coins.len() == 5 && forall|i: int| 0 <= i < coins.len() ==> #[trigger] coins[i] >= 0 && #[trigger] coins[i] <= 100\n}\n\nspec fn total_coins(coins: Seq<int>) -> int {\n    if coins.len() == 5 { coins[0] + coins[1] + coins[2] + coins[3] + coins[4] } else { 0 }\n}\n\nspec fn has_valid_solution(coins: Seq<int>) -> bool {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        total > 0 && total % 5 == 0\n    } else {\n        false\n    }\n}\n\nspec fn compute_result(coins: Seq<int>) -> int {\n    if valid_input(coins) {\n        let total = total_coins(coins);\n        if total > 0 && total % 5 == 0 { total / 5 } else { -1 }\n    } else {\n        -1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(coins: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(coins@.map(|i, x| x as int)),\n    ensures\n        result as int == compute_result(coins@.map(|i, x| x as int)),\n        has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == total_coins(coins@.map(|i, x| x as int)) / 5,\n        !has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == -1,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1353.rs,52,52,1.0,122.466,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: int, b: int) -> bool {
    n >= 1 && n <= 1000 &&
    m >= 1 && m <= 1000 &&
    a >= 1 && a <= 1000 &&
    b >= 1 && b <= 1000
}

spec fn optimal_cost(n: int, m: int, a: int, b: int) -> int
    recommends valid_input(n, m, a, b)
{
    if n * a <= ((n + m - 1) / m) * b {
        if n * a <= (n / m) * b + (n % m) * a {
            n * a
        } else {
            (n / m) * b + (n % m) * a
        }
    } else {
        if ((n + m - 1) / m) * b <= (n / m) * b + (n % m) * a {
            ((n + m - 1) / m) * b
        } else {
            (n / m) * b + (n % m) * a
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int, a as int, b as int),
    ensures 
        result >= 0,
        result as int == optimal_cost(n as int, m as int, a as int, b as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: int, b: int) -> bool {
    n >= 1 && n <= 1000 &&
    m >= 1 && m <= 1000 &&
    a >= 1 && a <= 1000 &&
    b >= 1 && b <= 1000
}

spec fn optimal_cost(n: int, m: int, a: int, b: int) -> int
    recommends valid_input(n, m, a, b)
{
    if n * a <= ((n + m - 1) / m) * b {
        if n * a <= (n / m) * b + (n % m) * a {
            n * a
        } else {
            (n / m) * b + (n % m) * a
        }
    } else {
        if ((n + m - 1) / m) * b <= (n / m) * b + (n % m) * a {
            ((n + m - 1) / m) * b
        } else {
            (n / m) * b + (n % m) * a
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int, a as int, b as int),
    ensures 
        result >= 0,
        result as int == optimal_cost(n as int, m as int, a as int, b as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: int, b: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    m >= 1 && m <= 1000 &&\n    a >= 1 && a <= 1000 &&\n    b >= 1 && b <= 1000\n}\n\nspec fn optimal_cost(n: int, m: int, a: int, b: int) -> int\n    recommends valid_input(n, m, a, b)\n{\n    if n * a <= ((n + m - 1) / m) * b {\n        if n * a <= (n / m) * b + (n % m) * a {\n            n * a\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    } else {\n        if ((n + m - 1) / m) * b <= (n / m) * b + (n % m) * a {\n            ((n + m - 1) / m) * b\n        } else {\n            (n / m) * b + (n % m) * a\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a as int, b as int),\n    ensures \n        result >= 0,\n        result as int == optimal_cost(n as int, m as int, a as int, b as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1356.rs,50,50,1.0,122.486,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_a(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0 as int
    } else {
        (if s[0] == 'a' { 1 as int } else { 0 as int }) + count_a(s.subrange(1, s.len() as int))
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && exists|i: int| 0 <= i < s.len() && s[i] == 'a'
}

spec fn is_good_string(s: Seq<char>) -> bool {
    s.len() > 0 && count_a(s) > s.len() as int / 2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: usize)
    requires 
        valid_input(s@),
    ensures 
        result >= 1,
        result <= s.len(),
        result == min(2 * count_a(s@) - 1, s.len() as int) as usize,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_a(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0 as int
    } else {
        (if s[0] == 'a' { 1 as int } else { 0 as int }) + count_a(s.subrange(1, s.len() as int))
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && exists|i: int| 0 <= i < s.len() && s[i] == 'a'
}

spec fn is_good_string(s: Seq<char>) -> bool {
    s.len() > 0 && count_a(s) > s.len() as int / 2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: usize)
    requires 
        valid_input(s@),
    ensures 
        result >= 1,
        result <= s.len(),
        result == min(2 * count_a(s@) - 1, s.len() as int) as usize,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_a(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == 'a' { 1 as int } else { 0 as int }) + count_a(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && exists|i: int| 0 <= i < s.len() && s[i] == 'a'\n}\n\nspec fn is_good_string(s: Seq<char>) -> bool {\n    s.len() > 0 && count_a(s) > s.len() as int / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        result >= 1,\n        result <= s.len(),\n        result == min(2 * count_a(s@) - 1, s.len() as int) as usize,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1381.rs,58,58,1.0,122.72,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(k: int, n: int, s: int, p: int) -> bool {
  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&
  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000
}

spec fn sheets_per_person(n: int, s: int) -> int
  recommends s >= 1
{
  (n + s - 1) / s
}

spec fn total_sheets_needed(k: int, n: int, s: int) -> int
  recommends s >= 1
{
  k * sheets_per_person(n, s)
}

spec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int
  recommends s >= 1 && p >= 1
{
  (total_sheets_needed(k, n, s) + p - 1) / p
}

spec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool
  recommends s >= 1 && p >= 1
{
  result == min_packs_needed(k, n, s, p) &&
  result * p >= total_sheets_needed(k, n, s) &&
  (result - 1) * p < total_sheets_needed(k, n, s)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i32, n: i32, s: i32, p: i32) -> (result: i32)
  requires
    valid_input(k as int, n as int, s as int, p as int),
  ensures
    result >= 1,
    correct_result(result as int, k as int, n as int, s as int, p as int),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(k: int, n: int, s: int, p: int) -> bool {
  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&
  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000
}

spec fn sheets_per_person(n: int, s: int) -> int
  recommends s >= 1
{
  (n + s - 1) / s
}

spec fn total_sheets_needed(k: int, n: int, s: int) -> int
  recommends s >= 1
{
  k * sheets_per_person(n, s)
}

spec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int
  recommends s >= 1 && p >= 1
{
  (total_sheets_needed(k, n, s) + p - 1) / p
}

spec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool
  recommends s >= 1 && p >= 1
{
  result == min_packs_needed(k, n, s, p) &&
  result * p >= total_sheets_needed(k, n, s) &&
  (result - 1) * p < total_sheets_needed(k, n, s)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i32, n: i32, s: i32, p: i32) -> (result: i32)
  requires
    valid_input(k as int, n as int, s as int, p as int),
  ensures
    result >= 1,
    correct_result(result as int, k as int, n as int, s as int, p as int),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(k: int, n: int, s: int, p: int) -> bool {\n  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&\n  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000\n}\n\nspec fn sheets_per_person(n: int, s: int) -> int\n  recommends s >= 1\n{\n  (n + s - 1) / s\n}\n\nspec fn total_sheets_needed(k: int, n: int, s: int) -> int\n  recommends s >= 1\n{\n  k * sheets_per_person(n, s)\n}\n\nspec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int\n  recommends s >= 1 && p >= 1\n{\n  (total_sheets_needed(k, n, s) + p - 1) / p\n}\n\nspec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool\n  recommends s >= 1 && p >= 1\n{\n  result == min_packs_needed(k, n, s, p) &&\n  result * p >= total_sheets_needed(k, n, s) &&\n  (result - 1) * p < total_sheets_needed(k, n, s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i32, n: i32, s: i32, p: i32) -> (result: i32)\n  requires\n    valid_input(k as int, n as int, s as int, p as int),\n  ensures\n    result >= 1,\n    correct_result(result as int, k as int, n as int, s as int, p as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1395.rs,77,77,1.0,123.429,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 && exists|pos: int| 0 <= pos < stdin_input.len() && stdin_input[pos] == '\n'
}

spec fn valid_digit_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn valid_number_string(s: Seq<char>) -> bool {
    valid_digit_string(s) && s[0] != '0'
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 && forall|i: int| 0 <= i < result.len() ==> ('0' <= #[trigger] result[i] <= '9')
}

spec fn is_good_shift(s: Seq<char>, shift: int) -> bool 
    recommends 0 <= shift < s.len(), s.len() > 0
{
    s[shift] != '0'
}

spec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int
    recommends 
        0 <= shift < s.len(),
        s.len() > 0,
        m >= 2,
        valid_digit_string(s)
{
    cyclic_shift_remainder_helper(s, shift, m, 0, 0)
}

spec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int
    recommends 
        0 <= shift < s.len(),
        s.len() > 0,
        m >= 2,
        0 <= pos <= s.len(),
        0 <= acc < m,
        valid_digit_string(s)
    decreases (s.len() - pos) when 0 <= pos <= s.len()
{
    if pos == s.len() { 
        acc 
    } else {
        let idx = (shift + pos) % (s.len() as int);
        let digit = (s[idx] as int) - ('0' as int);
        let new_acc = (acc * 10 + digit) % m;
        cyclic_shift_remainder_helper(s, shift, m, pos + 1, new_acc)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 && exists|pos: int| 0 <= pos < stdin_input.len() && stdin_input[pos] == '\n'
}

spec fn valid_digit_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn valid_number_string(s: Seq<char>) -> bool {
    valid_digit_string(s) && s[0] != '0'
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 && forall|i: int| 0 <= i < result.len() ==> ('0' <= #[trigger] result[i] <= '9')
}

spec fn is_good_shift(s: Seq<char>, shift: int) -> bool 
    recommends 0 <= shift < s.len(), s.len() > 0
{
    s[shift] != '0'
}

spec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int
    recommends 
        0 <= shift < s.len(),
        s.len() > 0,
        m >= 2,
        valid_digit_string(s)
{
    cyclic_shift_remainder_helper(s, shift, m, 0, 0)
}

spec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int
    recommends 
        0 <= shift < s.len(),
        s.len() > 0,
        m >= 2,
        0 <= pos <= s.len(),
        0 <= acc < m,
        valid_digit_string(s)
    decreases (s.len() - pos) when 0 <= pos <= s.len()
{
    if pos == s.len() { 
        acc 
    } else {
        let idx = (shift + pos) % (s.len() as int);
        let digit = (s[idx] as int) - ('0' as int);
        let new_acc = (acc * 10 + digit) % m;
        cyclic_shift_remainder_helper(s, shift, m, pos + 1, new_acc)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 && exists|pos: int| 0 <= pos < stdin_input.len() && stdin_input[pos] == '\\n'\n}\n\nspec fn valid_digit_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn valid_number_string(s: Seq<char>) -> bool {\n    valid_digit_string(s) && s[0] != '0'\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 && forall|i: int| 0 <= i < result.len() ==> ('0' <= #[trigger] result[i] <= '9')\n}\n\nspec fn is_good_shift(s: Seq<char>, shift: int) -> bool \n    recommends 0 <= shift < s.len(), s.len() > 0\n{\n    s[shift] != '0'\n}\n\nspec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        valid_digit_string(s)\n{\n    cyclic_shift_remainder_helper(s, shift, m, 0, 0)\n}\n\nspec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int\n    recommends \n        0 <= shift < s.len(),\n        s.len() > 0,\n        m >= 2,\n        0 <= pos <= s.len(),\n        0 <= acc < m,\n        valid_digit_string(s)\n    decreases (s.len() - pos) when 0 <= pos <= s.len()\n{\n    if pos == s.len() { \n        acc \n    } else {\n        let idx = (shift + pos) % (s.len() as int);\n        let digit = (s[idx] as int) - ('0' as int);\n        let new_acc = (acc * 10 + digit) % m;\n        cyclic_shift_remainder_helper(s, shift, m, pos + 1, new_acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n                fn main() {\n      }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1419.rs,66,66,1.0,122.429,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool
    recommends k >= 1 && s.len() >= 1 && max_width >= 1
{
    check_formatting(s, k, max_width, 0, 1, 0)
}

spec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool
    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0
    decreases s.len() - pos when 0 <= pos <= s.len()
{
    if pos == s.len() {
        lines <= k && current_line <= max_width
    } else {
        if s[pos] == ' ' || s[pos] == '-' {
            /* Potential break point */
            if current_line + 1 > max_width {
                /* Must break line */
                if lines + 1 > k {
                    false
                } else {
                    check_formatting(s, k, max_width, pos + 1, lines + 1, 1)
                }
            } else {
                /* Can continue on current line or break */
                (check_formatting(s, k, max_width, pos + 1, lines, current_line + 1) ||
                 (lines < k && check_formatting(s, k, max_width, pos + 1, lines + 1, 1)))
            }
        } else {
            /* Regular character - must continue on current line */
            if current_line + 1 > max_width {
                false
            } else {
                check_formatting(s, k, max_width, pos + 1, lines, current_line + 1)
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i8, s: Vec<char>) -> (result: i8)
    requires k >= 1,
            s.len() >= 1,
    ensures result >= 1,
            result <= s@.len(),
            can_format_text(s@, k as int, result as int),
            result > 1 ==> !can_format_text(s@, k as int, (result - 1) as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool
    recommends k >= 1 && s.len() >= 1 && max_width >= 1
{
    check_formatting(s, k, max_width, 0, 1, 0)
}

spec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool
    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0
    decreases s.len() - pos when 0 <= pos <= s.len()
{
    if pos == s.len() {
        lines <= k && current_line <= max_width
    } else {
        if s[pos] == ' ' || s[pos] == '-' {
            /* Potential break point */
            if current_line + 1 > max_width {
                /* Must break line */
                if lines + 1 > k {
                    false
                } else {
                    check_formatting(s, k, max_width, pos + 1, lines + 1, 1)
                }
            } else {
                /* Can continue on current line or break */
                (check_formatting(s, k, max_width, pos + 1, lines, current_line + 1) ||
                 (lines < k && check_formatting(s, k, max_width, pos + 1, lines + 1, 1)))
            }
        } else {
            /* Regular character - must continue on current line */
            if current_line + 1 > max_width {
                false
            } else {
                check_formatting(s, k, max_width, pos + 1, lines, current_line + 1)
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i8, s: Vec<char>) -> (result: i8)
    requires k >= 1,
            s.len() >= 1,
    ensures result >= 1,
            result <= s@.len(),
            can_format_text(s@, k as int, result as int),
            result > 1 ==> !can_format_text(s@, k as int, (result - 1) as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1\n{\n    check_formatting(s, k, max_width, 0, 1, 0)\n}\n\nspec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool\n    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() {\n        lines <= k && current_line <= max_width\n    } else {\n        if s[pos] == ' ' || s[pos] == '-' {\n            /* Potential break point */\n            if current_line + 1 > max_width {\n                /* Must break line */\n                if lines + 1 > k {\n                    false\n                } else {\n                    check_formatting(s, k, max_width, pos + 1, lines + 1, 1)\n                }\n            } else {\n                /* Can continue on current line or break */\n                (check_formatting(s, k, max_width, pos + 1, lines, current_line + 1) ||\n                 (lines < k && check_formatting(s, k, max_width, pos + 1, lines + 1, 1)))\n            }\n        } else {\n            /* Regular character - must continue on current line */\n            if current_line + 1 > max_width {\n                false\n            } else {\n                check_formatting(s, k, max_width, pos + 1, lines, current_line + 1)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, s: Vec<char>) -> (result: i8)\n    requires k >= 1,\n            s.len() >= 1,\n    ensures result >= 1,\n            result <= s@.len(),\n            can_format_text(s@, k as int, result as int),\n            result > 1 ==> !can_format_text(s@, k as int, (result - 1) as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1451.rs,52,52,1.0,122.438,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {
    n >= 1 && k >= 0 && numbers.len() == n && forall|i: int| 0 <= i < numbers.len() ==> numbers[i] > 0
}

spec fn count_lucky_digits(num: int) -> int
    decreases num when num >= 0
{
    if num <= 0 { 0 }
    else {
        let digit = num % 10;
        let rest = num / 10;
        let digit_count: int = if digit == 4 || digit == 7 { 1 } else { 0 };
        digit_count + count_lucky_digits(rest)
    }
}

spec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int
    decreases up_to when up_to >= 0
{
    if up_to <= 0 { 0 }
    else {
        let prev_count = count_valid_numbers(numbers, k, up_to - 1);
        if count_lucky_digits(numbers[up_to - 1]) <= k { prev_count + 1 } else { prev_count }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, numbers: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))
    ensures 0 <= result as int <= n as int
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {
    n >= 1 && k >= 0 && numbers.len() == n && forall|i: int| 0 <= i < numbers.len() ==> numbers[i] > 0
}

spec fn count_lucky_digits(num: int) -> int
    decreases num when num >= 0
{
    if num <= 0 { 0 }
    else {
        let digit = num % 10;
        let rest = num / 10;
        let digit_count: int = if digit == 4 || digit == 7 { 1 } else { 0 };
        digit_count + count_lucky_digits(rest)
    }
}

spec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int
    decreases up_to when up_to >= 0
{
    if up_to <= 0 { 0 }
    else {
        let prev_count = count_valid_numbers(numbers, k, up_to - 1);
        if count_lucky_digits(numbers[up_to - 1]) <= k { prev_count + 1 } else { prev_count }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, numbers: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))
    ensures 0 <= result as int <= n as int
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {\n    n >= 1 && k >= 0 && numbers.len() == n && forall|i: int| 0 <= i < numbers.len() ==> numbers[i] > 0\n}\n\nspec fn count_lucky_digits(num: int) -> int\n    decreases num when num >= 0\n{\n    if num <= 0 { 0 }\n    else {\n        let digit = num % 10;\n        let rest = num / 10;\n        let digit_count: int = if digit == 4 || digit == 7 { 1 } else { 0 };\n        digit_count + count_lucky_digits(rest)\n    }\n}\n\nspec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int\n    decreases up_to when up_to >= 0\n{\n    if up_to <= 0 { 0 }\n    else {\n        let prev_count = count_valid_numbers(numbers, k, up_to - 1);\n        if count_lucky_digits(numbers[up_to - 1]) <= k { prev_count + 1 } else { prev_count }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, numbers: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures 0 <= result as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1461.rs,55,55,1.0,123.029,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {
  n > 0 && f.len() == n && w.len() == n &&
  (forall|i: int| #![trigger f[i]] 0 <= i < n ==> 0 <= f[i] < n) &&
  (forall|i: int| #![trigger w[i]] 0 <= i < n ==> w[i] >= 0)
}

spec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {
  sums.len() == n && mins.len() == n &&
  forall|i: int| #![trigger sums[i], mins[i]] 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0
}

spec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int
  decreases k
{
  if k <= 0 { 0 }
  else { w[start] + path_sum(f[start], k - 1, f, w) }
}

spec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int
  decreases k
{
  if k <= 1 { w[start] }
  else {
    let next_min = path_min(f[start], k - 1, f, w);
    if w[start] <= next_min { w[start] } else { next_min }
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve_graph(n: i8, k: i8, f: Vec<i8>, w: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))
  requires 
    valid_graph(n as int, f@.map_values(|x: i8| x as int), w@.map_values(|x: i8| x as int)),
    k > 0
  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {
  n > 0 && f.len() == n && w.len() == n &&
  (forall|i: int| #![trigger f[i]] 0 <= i < n ==> 0 <= f[i] < n) &&
  (forall|i: int| #![trigger w[i]] 0 <= i < n ==> w[i] >= 0)
}

spec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {
  sums.len() == n && mins.len() == n &&
  forall|i: int| #![trigger sums[i], mins[i]] 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0
}

spec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int
  decreases k
{
  if k <= 0 { 0 }
  else { w[start] + path_sum(f[start], k - 1, f, w) }
}

spec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int
  decreases k
{
  if k <= 1 { w[start] }
  else {
    let next_min = path_min(f[start], k - 1, f, w);
    if w[start] <= next_min { w[start] } else { next_min }
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve_graph(n: i8, k: i8, f: Vec<i8>, w: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))
  requires 
    valid_graph(n as int, f@.map_values(|x: i8| x as int), w@.map_values(|x: i8| x as int)),
    k > 0
  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {\n  n > 0 && f.len() == n && w.len() == n &&\n  (forall|i: int| #![trigger f[i]] 0 <= i < n ==> 0 <= f[i] < n) &&\n  (forall|i: int| #![trigger w[i]] 0 <= i < n ==> w[i] >= 0)\n}\n\nspec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {\n  sums.len() == n && mins.len() == n &&\n  forall|i: int| #![trigger sums[i], mins[i]] 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0\n}\n\nspec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 0 { 0 }\n  else { w[start] + path_sum(f[start], k - 1, f, w) }\n}\n\nspec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int\n  decreases k\n{\n  if k <= 1 { w[start] }\n  else {\n    let next_min = path_min(f[start], k - 1, f, w);\n    if w[start] <= next_min { w[start] } else { next_min }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_graph(n: i8, k: i8, f: Vec<i8>, w: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires \n    valid_graph(n as int, f@.map_values(|x: i8| x as int), w@.map_values(|x: i8| x as int)),\n    k > 0\n  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_148.rs,89,89,1.0,122.477,True,0.7999999999999999,True,"['vstd::prelude::', 'vstd::string::']",True,,,,,,"// <vc-preamble>
use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == '\n') &&
    {
        let parts = parse_input(input);
        parts.len() == 5 &&
        parts[0] >= 4 && parts[0] <= 100 &&
        parts[1] >= 1 && parts[1] <= parts[0] &&
        parts[2] >= 1 && parts[2] <= parts[0] &&
        parts[3] >= 1 && parts[3] <= parts[0] &&
        parts[4] >= 1 && parts[4] <= parts[0] &&
        parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&
        parts[2] != parts[3] && parts[2] != parts[4] &&
        parts[3] != parts[4]
    }
}

spec fn trains_will_meet(input: Seq<char>) -> bool 
    recommends
        input.len() > 0,
        exists|i: int| 0 <= i < input.len() && input[i] == '\n',
        valid_input(input),
{
    let parts = parse_input(input);
    let n = parts[0];
    let a = parts[1];
    let x = parts[2];
    let b = parts[3];
    let y = parts[4];

    if a == b { true }
    else { simulate_trains(n, a, x, b, y) }
}

spec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool
    recommends
        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,
        a != x && a != b && a != y && x != b && x != y && b != y,
{
    simulate_trains_helper(n, a, x, b, y, 2 * n)
}

spec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {
    if fuel <= 0 {
        false
    } else {
        /* Placeholder simulation logic - returns false for now */
        false
    }
}

spec fn parse_input(input: Seq<char>) -> Seq<int> {
    /* Placeholder parsing logic - returns empty sequence for now */
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: String)
    requires 
        stdin_input.len() > 0,
        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n' as u8,
        valid_input(stdin_input@.map(|i, x: u8| x as char)),
    ensures
        result@ =~= seq!['Y', 'E', 'S', '\n'] || result@ =~= seq!['N', 'O', '\n'],
        result@ =~= seq!['Y', 'E', 'S', '\n'] <==> trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),
        result@ =~= seq!['N', 'O', '\n'] <==> !trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""NO\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == '\n') &&
    {
        let parts = parse_input(input);
        parts.len() == 5 &&
        parts[0] >= 4 && parts[0] <= 100 &&
        parts[1] >= 1 && parts[1] <= parts[0] &&
        parts[2] >= 1 && parts[2] <= parts[0] &&
        parts[3] >= 1 && parts[3] <= parts[0] &&
        parts[4] >= 1 && parts[4] <= parts[0] &&
        parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&
        parts[2] != parts[3] && parts[2] != parts[4] &&
        parts[3] != parts[4]
    }
}

spec fn trains_will_meet(input: Seq<char>) -> bool 
    recommends
        input.len() > 0,
        exists|i: int| 0 <= i < input.len() && input[i] == '\n',
        valid_input(input),
{
    let parts = parse_input(input);
    let n = parts[0];
    let a = parts[1];
    let x = parts[2];
    let b = parts[3];
    let y = parts[4];

    if a == b { true }
    else { simulate_trains(n, a, x, b, y) }
}

spec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool
    recommends
        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,
        a != x && a != b && a != y && x != b && x != y && b != y,
{
    simulate_trains_helper(n, a, x, b, y, 2 * n)
}

spec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {
    if fuel <= 0 {
        false
    } else {
        /* Placeholder simulation logic - returns false for now */
        false
    }
}

spec fn parse_input(input: Seq<char>) -> Seq<int> {
    /* Placeholder parsing logic - returns empty sequence for now */
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: String)
    requires 
        stdin_input.len() > 0,
        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n' as u8,
        valid_input(stdin_input@.map(|i, x: u8| x as char)),
    ensures
        result@ =~= seq!['Y', 'E', 'S', '\n'] || result@ =~= seq!['N', 'O', '\n'],
        result@ =~= seq!['Y', 'E', 'S', '\n'] <==> trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),
        result@ =~= seq!['N', 'O', '\n'] <==> !trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""NO\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == \'\\n\') &&\n    {\n        let parts = parse_input(input);\n        parts.len() == 5 &&\n        parts[0] >= 4 && parts[0] <= 100 &&\n        parts[1] >= 1 && parts[1] <= parts[0] &&\n        parts[2] >= 1 && parts[2] <= parts[0] &&\n        parts[3] >= 1 && parts[3] <= parts[0] &&\n        parts[4] >= 1 && parts[4] <= parts[0] &&\n        parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&\n        parts[2] != parts[3] && parts[2] != parts[4] &&\n        parts[3] != parts[4]\n    }\n}\n\nspec fn trains_will_meet(input: Seq<char>) -> bool \n    recommends\n        input.len() > 0,\n        exists|i: int| 0 <= i < input.len() && input[i] == \'\\n\',\n        valid_input(input),\n{\n    let parts = parse_input(input);\n    let n = parts[0];\n    let a = parts[1];\n    let x = parts[2];\n    let b = parts[3];\n    let y = parts[4];\n\n    if a == b { true }\n    else { simulate_trains(n, a, x, b, y) }\n}\n\nspec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool\n    recommends\n        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,\n        a != x && a != b && a != y && x != b && x != y && b != y,\n{\n    simulate_trains_helper(n, a, x, b, y, 2 * n)\n}\n\nspec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {\n    if fuel <= 0 {\n        false\n    } else {\n        /* Placeholder simulation logic - returns false for now */\n        false\n    }\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<int> {\n    /* Placeholder parsing logic - returns empty sequence for now */\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: String)\n    requires \n        stdin_input.len() > 0,\n        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == \'\\n\' as u8,\n        valid_input(stdin_input@.map(|i, x: u8| x as char)),\n    ensures\n        result@ =~= seq![\'Y\', \'E\', \'S\', \'\\n\'] || result@ =~= seq![\'N\', \'O\', \'\\n\'],\n        result@ =~= seq![\'Y\', \'E\', \'S\', \'\\n\'] <==> trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n        result@ =~= seq![\'N\', \'O\', \'\\n\'] <==> !trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    ""NO\\n"".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1486.rs,74,74,1.0,122.428,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(cities: Seq<int>) -> bool {
  cities.len() >= 2 &&
  forall|i: int, j: int| 0 <= i < j < cities.len() ==> cities[i] < cities[j]
}

spec fn min_distance(cities: Seq<int>, i: int) -> int 
  recommends
    valid_input(cities),
    0 <= i < cities.len()
{
  if i == 0 {
    cities[1] - cities[0]
  } else if i == cities.len() - 1 {
    cities[i] - cities[i-1]
  } else {
    let left_dist = cities[i] - cities[i-1];
    let right_dist = cities[i+1] - cities[i];
    if left_dist <= right_dist { left_dist } else { right_dist }
  }
}

spec fn max_distance(cities: Seq<int>, i: int) -> int 
  recommends
    valid_input(cities),
    0 <= i < cities.len()
{
  if i == 0 {
    cities[cities.len()-1] - cities[0]
  } else if i == cities.len() - 1 {
    cities[i] - cities[0]
  } else {
    let dist_to_first = cities[i] - cities[0];
    let dist_to_last = cities[cities.len()-1] - cities[i];
    if dist_to_first >= dist_to_last { dist_to_first } else { dist_to_last }
  }
}

spec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {
  valid_input(cities) &&
  min_distances.len() == cities.len() &&
  max_distances.len() == cities.len() &&
  forall|i: int| 0 <= i < cities.len() ==> 
    min_distances[i] == min_distance(cities, i) &&
    max_distances[i] == max_distance(cities, i) &&
    min_distances[i] > 0 &&
    max_distances[i] > 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn calculate_distances(cities: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))
  requires valid_input(cities@.map(|i, v: i8| v as int))
  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(cities: Seq<int>) -> bool {
  cities.len() >= 2 &&
  forall|i: int, j: int| 0 <= i < j < cities.len() ==> cities[i] < cities[j]
}

spec fn min_distance(cities: Seq<int>, i: int) -> int 
  recommends
    valid_input(cities),
    0 <= i < cities.len()
{
  if i == 0 {
    cities[1] - cities[0]
  } else if i == cities.len() - 1 {
    cities[i] - cities[i-1]
  } else {
    let left_dist = cities[i] - cities[i-1];
    let right_dist = cities[i+1] - cities[i];
    if left_dist <= right_dist { left_dist } else { right_dist }
  }
}

spec fn max_distance(cities: Seq<int>, i: int) -> int 
  recommends
    valid_input(cities),
    0 <= i < cities.len()
{
  if i == 0 {
    cities[cities.len()-1] - cities[0]
  } else if i == cities.len() - 1 {
    cities[i] - cities[0]
  } else {
    let dist_to_first = cities[i] - cities[0];
    let dist_to_last = cities[cities.len()-1] - cities[i];
    if dist_to_first >= dist_to_last { dist_to_first } else { dist_to_last }
  }
}

spec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {
  valid_input(cities) &&
  min_distances.len() == cities.len() &&
  max_distances.len() == cities.len() &&
  forall|i: int| 0 <= i < cities.len() ==> 
    min_distances[i] == min_distance(cities, i) &&
    max_distances[i] == max_distance(cities, i) &&
    min_distances[i] > 0 &&
    max_distances[i] > 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn calculate_distances(cities: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))
  requires valid_input(cities@.map(|i, v: i8| v as int))
  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cities: Seq<int>) -> bool {\n  cities.len() >= 2 &&\n  forall|i: int, j: int| 0 <= i < j < cities.len() ==> cities[i] < cities[j]\n}\n\nspec fn min_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[i-1]\n  } else {\n    let left_dist = cities[i] - cities[i-1];\n    let right_dist = cities[i+1] - cities[i];\n    if left_dist <= right_dist { left_dist } else { right_dist }\n  }\n}\n\nspec fn max_distance(cities: Seq<int>, i: int) -> int \n  recommends\n    valid_input(cities),\n    0 <= i < cities.len()\n{\n  if i == 0 {\n    cities[cities.len()-1] - cities[0]\n  } else if i == cities.len() - 1 {\n    cities[i] - cities[0]\n  } else {\n    let dist_to_first = cities[i] - cities[0];\n    let dist_to_last = cities[cities.len()-1] - cities[i];\n    if dist_to_first >= dist_to_last { dist_to_first } else { dist_to_last }\n  }\n}\n\nspec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {\n  valid_input(cities) &&\n  min_distances.len() == cities.len() &&\n  max_distances.len() == cities.len() &&\n  forall|i: int| 0 <= i < cities.len() ==> \n    min_distances[i] == min_distance(cities, i) &&\n    max_distances[i] == max_distance(cities, i) &&\n    min_distances[i] > 0 &&\n    max_distances[i] > 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn calculate_distances(cities: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n  requires valid_input(cities@.map(|i, v: i8| v as int))\n  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1526.rs,65,65,1.0,122.637,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    0 <= a <= 50 && 0 <= b <= 50 && 0 <= c <= 50
}

spec fn max_of_3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c { a }
    else if b >= c { b }
    else { c }
}

spec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {
    if a >= b && a >= c {
        if b >= c { (a, b, c) } else { (a, c, b) }
    } else if b >= a && b >= c {
        if a >= c { (b, a, c) } else { (b, c, a) }
    } else {
        if a >= b { (c, a, b) } else { (c, b, a) }
    }
}

spec fn min_operations(a: int, b: int, c: int) -> int
    recommends valid_input(a, b, c)
{
    let (a0, a1, a2) = sort_descending(a, b, c);
    let gap1 = a0 - a1;
    let updated_smallest = a2 + gap1;
    let remaining_gap = a0 - updated_smallest;
    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2
}

spec fn all_equal(a: int, b: int, c: int) -> bool {
    a == b && b == c
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires
        valid_input(a as int, b as int, c as int),
    ensures
        result >= 0,
        all_equal(a as int, b as int, c as int) ==> result == 0,
        result as int == min_operations(a as int, b as int, c as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    0 <= a <= 50 && 0 <= b <= 50 && 0 <= c <= 50
}

spec fn max_of_3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c { a }
    else if b >= c { b }
    else { c }
}

spec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {
    if a >= b && a >= c {
        if b >= c { (a, b, c) } else { (a, c, b) }
    } else if b >= a && b >= c {
        if a >= c { (b, a, c) } else { (b, c, a) }
    } else {
        if a >= b { (c, a, b) } else { (c, b, a) }
    }
}

spec fn min_operations(a: int, b: int, c: int) -> int
    recommends valid_input(a, b, c)
{
    let (a0, a1, a2) = sort_descending(a, b, c);
    let gap1 = a0 - a1;
    let updated_smallest = a2 + gap1;
    let remaining_gap = a0 - updated_smallest;
    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2
}

spec fn all_equal(a: int, b: int, c: int) -> bool {
    a == b && b == c
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires
        valid_input(a as int, b as int, c as int),
    ensures
        result >= 0,
        all_equal(a as int, b as int, c as int) ==> result == 0,
        result as int == min_operations(a as int, b as int, c as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    0 <= a <= 50 && 0 <= b <= 50 && 0 <= c <= 50\n}\n\nspec fn max_of_3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a }\n    else if b >= c { b }\n    else { c }\n}\n\nspec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {\n    if a >= b && a >= c {\n        if b >= c { (a, b, c) } else { (a, c, b) }\n    } else if b >= a && b >= c {\n        if a >= c { (b, a, c) } else { (b, c, a) }\n    } else {\n        if a >= b { (c, a, b) } else { (c, b, a) }\n    }\n}\n\nspec fn min_operations(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let (a0, a1, a2) = sort_descending(a, b, c);\n    let gap1 = a0 - a1;\n    let updated_smallest = a2 + gap1;\n    let remaining_gap = a0 - updated_smallest;\n    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2\n}\n\nspec fn all_equal(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires\n        valid_input(a as int, b as int, c as int),\n    ensures\n        result >= 0,\n        all_equal(a as int, b as int, c as int) ==> result == 0,\n        result as int == min_operations(a as int, b as int, c as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1529.rs,109,109,1.0,122.893,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    if input.len() == 0 {
        seq![]
    } else {
        split_lines_helper(input, 0, seq![], seq![])
    }
}

spec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - i when 0 <= i <= input.len()
{
    if i == input.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else if i < input.len() && input[i] == '\n' {
        split_lines_helper(input, i + 1, seq![], acc.push(current))
    } else if i < input.len() {
        split_lines_helper(input, i + 1, current.push(input[i]), acc)
    } else {
        acc
    }
}

spec fn parse_int_func(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else {
        parse_int_helper(s, 0, 0)
    }
}

spec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i == s.len() {
        acc
    } else if i < s.len() && '0' <= s[i] <= '9' {
        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        acc
    }
}

spec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>
    decreases n when n >= 0
{
    if n == 0 {
        seq![]
    } else if n == 1 && 1 < lines.len() {
        classify_sentence_func(lines[1])
    } else if n > 1 && n < lines.len() {
        build_output_func(lines, n-1) + seq!['\n'] + classify_sentence_func(lines[n])
    } else {
        seq![]
    }
}

spec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {
    if ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) && !starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) {
        seq!['F', 'r', 'e', 'd', 'a', '\'', 's']
    } else if starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) && !ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) {
        seq!['R', 'a', 'i', 'n', 'b', 'o', 'w', '\'', 's']
    } else {
        seq!['O', 'M', 'G', '>', '.', '<', ' ', 'I', ' ', 'd', 'o', 'n', '\'', 't', ' ', 'k', 'n', 'o', 'w', '!']
    }
}

spec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {
    prefix.len() <= s.len() && (forall|i: int| 0 <= i < prefix.len() ==> s[i] == prefix[i])
}

spec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {
    suffix.len() <= s.len() && (forall|i: int| 0 <= i < suffix.len() ==> s[s.len() - suffix.len() + i] == suffix[i])
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@.len() >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    if input.len() == 0 {
        seq![]
    } else {
        split_lines_helper(input, 0, seq![], seq![])
    }
}

spec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - i when 0 <= i <= input.len()
{
    if i == input.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else if i < input.len() && input[i] == '\n' {
        split_lines_helper(input, i + 1, seq![], acc.push(current))
    } else if i < input.len() {
        split_lines_helper(input, i + 1, current.push(input[i]), acc)
    } else {
        acc
    }
}

spec fn parse_int_func(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else {
        parse_int_helper(s, 0, 0)
    }
}

spec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i == s.len() {
        acc
    } else if i < s.len() && '0' <= s[i] <= '9' {
        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        acc
    }
}

spec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>
    decreases n when n >= 0
{
    if n == 0 {
        seq![]
    } else if n == 1 && 1 < lines.len() {
        classify_sentence_func(lines[1])
    } else if n > 1 && n < lines.len() {
        build_output_func(lines, n-1) + seq!['\n'] + classify_sentence_func(lines[n])
    } else {
        seq![]
    }
}

spec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {
    if ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) && !starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) {
        seq!['F', 'r', 'e', 'd', 'a', '\'', 's']
    } else if starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) && !ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) {
        seq!['R', 'a', 'i', 'n', 'b', 'o', 'w', '\'', 's']
    } else {
        seq!['O', 'M', 'G', '>', '.', '<', ' ', 'I', ' ', 'd', 'o', 'n', '\'', 't', ' ', 'k', 'n', 'o', 'w', '!']
    }
}

spec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {
    prefix.len() <= s.len() && (forall|i: int| 0 <= i < prefix.len() ==> s[i] == prefix[i])
}

spec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {
    suffix.len() <= s.len() && (forall|i: int| 0 <= i < suffix.len() ==> s[s.len() - suffix.len() + i] == suffix[i])
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@.len() >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(input, 0, seq![], seq![])\n    }\n}\n\nspec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i when 0 <= i <= input.len()\n{\n    if i == input.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if i < input.len() && input[i] == '\\n' {\n        split_lines_helper(input, i + 1, seq![], acc.push(current))\n    } else if i < input.len() {\n        split_lines_helper(input, i + 1, current.push(input[i]), acc)\n    } else {\n        acc\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        acc\n    } else if i < s.len() && '0' <= s[i] <= '9' {\n        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n == 0 {\n        seq![]\n    } else if n == 1 && 1 < lines.len() {\n        classify_sentence_func(lines[1])\n    } else if n > 1 && n < lines.len() {\n        build_output_func(lines, n-1) + seq!['\\n'] + classify_sentence_func(lines[n])\n    } else {\n        seq![]\n    }\n}\n\nspec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {\n    if ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) && !starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) {\n        seq!['F', 'r', 'e', 'd', 'a', '\\'', 's']\n    } else if starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) && !ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) {\n        seq!['R', 'a', 'i', 'n', 'b', 'o', 'w', '\\'', 's']\n    } else {\n        seq!['O', 'M', 'G', '>', '.', '<', ' ', 'I', ' ', 'd', 'o', 'n', '\\'', 't', ' ', 'k', 'n', 'o', 'w', '!']\n    }\n}\n\nspec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {\n    prefix.len() <= s.len() && (forall|i: int| 0 <= i < prefix.len() ==> s[i] == prefix[i])\n}\n\nspec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {\n    suffix.len() <= s.len() && (forall|i: int| 0 <= i < suffix.len() ==> s[s.len() - suffix.len() + i] == suffix[i])\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1541.rs,71,71,1.0,122.663,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_lever_input(s: Seq<char>) -> bool {
        s.len() >= 3 &&
        (exists|i: int| 0 <= i < s.len() && s[i] == '^') &&
        (forall|i: int| 0 <= i < s.len() ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&
        (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == '^' ==> s[j] != '^') &&
        (forall|i: int| 0 <= i < s.len() && s[i] == '^' ==> (i != 0 && i != s.len() - 1))
    }
    
    spec fn find_pivot(s: Seq<char>) -> int {
        find_pivot_helper(s, 0)
    }
    
    spec fn find_pivot_helper(s: Seq<char>, index: int) -> int
        decreases s.len() - index
    {
        if index >= s.len() {
            0
        } else if s[index] == '^' {
            index
        } else {
            find_pivot_helper(s, index + 1)
        }
    }
    
    spec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {
        calculate_torque_helper(s, pivot_pos, 0)
    }
    
    spec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int
        decreases s.len() - index
    {
        if index >= s.len() {
            0
        } else if '1' <= s[index] <= '9' {
            let weight = (s[index] as int) - ('0' as int);
            (pivot_pos - index) * weight + calculate_torque_helper(s, pivot_pos, index + 1)
        } else {
            calculate_torque_helper(s, pivot_pos, index + 1)
        }
    }
    
    spec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {
        calculate_torque_helper(s, pivot_pos, 0) - calculate_torque_helper(s, pivot_pos, up_to)
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_lever_input(s@)
    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_lever_input(s: Seq<char>) -> bool {
        s.len() >= 3 &&
        (exists|i: int| 0 <= i < s.len() && s[i] == '^') &&
        (forall|i: int| 0 <= i < s.len() ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&
        (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == '^' ==> s[j] != '^') &&
        (forall|i: int| 0 <= i < s.len() && s[i] == '^' ==> (i != 0 && i != s.len() - 1))
    }
    
    spec fn find_pivot(s: Seq<char>) -> int {
        find_pivot_helper(s, 0)
    }
    
    spec fn find_pivot_helper(s: Seq<char>, index: int) -> int
        decreases s.len() - index
    {
        if index >= s.len() {
            0
        } else if s[index] == '^' {
            index
        } else {
            find_pivot_helper(s, index + 1)
        }
    }
    
    spec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {
        calculate_torque_helper(s, pivot_pos, 0)
    }
    
    spec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int
        decreases s.len() - index
    {
        if index >= s.len() {
            0
        } else if '1' <= s[index] <= '9' {
            let weight = (s[index] as int) - ('0' as int);
            (pivot_pos - index) * weight + calculate_torque_helper(s, pivot_pos, index + 1)
        } else {
            calculate_torque_helper(s, pivot_pos, index + 1)
        }
    }
    
    spec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {
        calculate_torque_helper(s, pivot_pos, 0) - calculate_torque_helper(s, pivot_pos, up_to)
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_lever_input(s@)
    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_lever_input(s: Seq<char>) -> bool {\n        s.len() >= 3 &&\n        (exists|i: int| 0 <= i < s.len() && s[i] == '^') &&\n        (forall|i: int| 0 <= i < s.len() ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&\n        (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == '^' ==> s[j] != '^') &&\n        (forall|i: int| 0 <= i < s.len() && s[i] == '^' ==> (i != 0 && i != s.len() - 1))\n    }\n    \n    spec fn find_pivot(s: Seq<char>) -> int {\n        find_pivot_helper(s, 0)\n    }\n    \n    spec fn find_pivot_helper(s: Seq<char>, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if s[index] == '^' {\n            index\n        } else {\n            find_pivot_helper(s, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0)\n    }\n    \n    spec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int\n        decreases s.len() - index\n    {\n        if index >= s.len() {\n            0\n        } else if '1' <= s[index] <= '9' {\n            let weight = (s[index] as int) - ('0' as int);\n            (pivot_pos - index) * weight + calculate_torque_helper(s, pivot_pos, index + 1)\n        } else {\n            calculate_torque_helper(s, pivot_pos, index + 1)\n        }\n    }\n    \n    spec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {\n        calculate_torque_helper(s, pivot_pos, 0) - calculate_torque_helper(s, pivot_pos, up_to)\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_lever_input(s@)\n    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1550.rs,134,134,1.0,215.246,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, digits: Seq<char>) -> bool {
    n > 0 && digits.len() == n && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= '0' && #[trigger] digits[i] <= '9'
}

spec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {
    let key = if s[index] == '0' { 0 } else { 10 - (s[index] as int - '0' as int) };
    let transformed = transform_digits(s, key);
    rotate_string(transformed, index)
}

spec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let digit = (s[0] as int - '0' as int + key) % 10;
        seq![('0' as int + digit) as char].add(transform_digits(s.skip(1), key))
    }
}

spec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {
    if s.len() == 0 {
        seq![]
    } else {
        s.skip(index).add(s.take(index))
    }
}

spec fn is_all_digits(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>
    decreases input.len()
{
    parse_input_helper(input, 0, seq![], seq![])
}

spec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - i
{
    if i >= input.len() {
        if current_line.len() > 0 { lines.push(current_line) } else { lines }
    } else if input[i] == '\n' {
        parse_input_helper(input, i + 1, seq![], lines.push(current_line))
    } else {
        parse_input_helper(input, i + 1, current_line.push(input[i]), lines)
    }
}

spec fn parse_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if !('0' <= s[0] <= '9') {
        0
    } else {
        (s[0] as int - '0' as int) + 10 * parse_int(s.skip(1))
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if !('0' <= s[0] <= '9') {
        string_to_int(s.skip(1))
    } else {
        (s[0] as int - '0' as int) * pow(10, (s.len() - 1) as nat) + string_to_int(s.skip(1))
    }
}

spec fn pow(base: int, exp: nat) -> int
    decreases exp
{
    if exp == 0 {
        1
    } else {
        base * pow(base, (exp - 1) as nat)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: String) -> (result: String)
    requires
        stdin_input@.len() > 0,
        (exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n'),
    ensures
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        ({
            let lines = parse_input(stdin_input@);
            if lines.len() >= 2 {
                let n = parse_int(lines[0]);
                let digits = lines[1];
                if valid_input(n, digits) {
                    let min_result = result@.take(result@.len() - 1);
                    min_result.len() == n &&
                    (forall|i: int| 0 <= i < min_result.len() ==> #[trigger] min_result[i] >= '0' && #[trigger] min_result[i] <= '9') &&
                    (exists|index: int| 0 <= index < n && min_result == modify_string(digits, index)) &&
                    (forall|index: int| 0 <= index < n ==> string_to_int(min_result) <= string_to_int(modify_string(digits, index)))
                } else {
                    result@ == seq!['\n']
                }
            } else {
                result@ == seq!['\n']
            }
        })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, digits: Seq<char>) -> bool {
    n > 0 && digits.len() == n && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= '0' && #[trigger] digits[i] <= '9'
}

spec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {
    let key = if s[index] == '0' { 0 } else { 10 - (s[index] as int - '0' as int) };
    let transformed = transform_digits(s, key);
    rotate_string(transformed, index)
}

spec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let digit = (s[0] as int - '0' as int + key) % 10;
        seq![('0' as int + digit) as char].add(transform_digits(s.skip(1), key))
    }
}

spec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {
    if s.len() == 0 {
        seq![]
    } else {
        s.skip(index).add(s.take(index))
    }
}

spec fn is_all_digits(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>
    decreases input.len()
{
    parse_input_helper(input, 0, seq![], seq![])
}

spec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - i
{
    if i >= input.len() {
        if current_line.len() > 0 { lines.push(current_line) } else { lines }
    } else if input[i] == '\n' {
        parse_input_helper(input, i + 1, seq![], lines.push(current_line))
    } else {
        parse_input_helper(input, i + 1, current_line.push(input[i]), lines)
    }
}

spec fn parse_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if !('0' <= s[0] <= '9') {
        0
    } else {
        (s[0] as int - '0' as int) + 10 * parse_int(s.skip(1))
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if !('0' <= s[0] <= '9') {
        string_to_int(s.skip(1))
    } else {
        (s[0] as int - '0' as int) * pow(10, (s.len() - 1) as nat) + string_to_int(s.skip(1))
    }
}

spec fn pow(base: int, exp: nat) -> int
    decreases exp
{
    if exp == 0 {
        1
    } else {
        base * pow(base, (exp - 1) as nat)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: String) -> (result: String)
    requires
        stdin_input@.len() > 0,
        (exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n'),
    ensures
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        ({
            let lines = parse_input(stdin_input@);
            if lines.len() >= 2 {
                let n = parse_int(lines[0]);
                let digits = lines[1];
                if valid_input(n, digits) {
                    let min_result = result@.take(result@.len() - 1);
                    min_result.len() == n &&
                    (forall|i: int| 0 <= i < min_result.len() ==> #[trigger] min_result[i] >= '0' && #[trigger] min_result[i] <= '9') &&
                    (exists|index: int| 0 <= index < n && min_result == modify_string(digits, index)) &&
                    (forall|index: int| 0 <= index < n ==> string_to_int(min_result) <= string_to_int(modify_string(digits, index)))
                } else {
                    result@ == seq!['\n']
                }
            } else {
                result@ == seq!['\n']
            }
        })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, digits: Seq<char>) -> bool {\n    n > 0 && digits.len() == n && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= '0' && #[trigger] digits[i] <= '9'\n}\n\nspec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {\n    let key = if s[index] == '0' { 0 } else { 10 - (s[index] as int - '0' as int) };\n    let transformed = transform_digits(s, key);\n    rotate_string(transformed, index)\n}\n\nspec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let digit = (s[0] as int - '0' as int + key) % 10;\n        seq![('0' as int + digit) as char].add(transform_digits(s.skip(1), key))\n    }\n}\n\nspec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        s.skip(index).add(s.take(index))\n    }\n}\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n    decreases input.len()\n{\n    parse_input_helper(input, 0, seq![], seq![])\n}\n\nspec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - i\n{\n    if i >= input.len() {\n        if current_line.len() > 0 { lines.push(current_line) } else { lines }\n    } else if input[i] == '\\n' {\n        parse_input_helper(input, i + 1, seq![], lines.push(current_line))\n    } else {\n        parse_input_helper(input, i + 1, current_line.push(input[i]), lines)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        0\n    } else {\n        (s[0] as int - '0' as int) + 10 * parse_int(s.skip(1))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if !('0' <= s[0] <= '9') {\n        string_to_int(s.skip(1))\n    } else {\n        (s[0] as int - '0' as int) * pow(10, (s.len() - 1) as nat) + string_to_int(s.skip(1))\n    }\n}\n\nspec fn pow(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        (exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\\n'),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let lines = parse_input(stdin_input@);\n            if lines.len() >= 2 {\n                let n = parse_int(lines[0]);\n                let digits = lines[1];\n                if valid_input(n, digits) {\n                    let min_result = result@.take(result@.len() - 1);\n                    min_result.len() == n &&\n                    (forall|i: int| 0 <= i < min_result.len() ==> #[trigger] min_result[i] >= '0' && #[trigger] min_result[i] <= '9') &&\n                    (exists|index: int| 0 <= index < n && min_result == modify_string(digits, index)) &&\n                    (forall|index: int| 0 <= index < n ==> string_to_int(min_result) <= string_to_int(modify_string(digits, index)))\n                } else {\n                    result@ == seq!['\\n']\n                }\n            } else {\n                result@ == seq!['\\n']\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n                fn main() {\n      }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1568.rs,52,52,1.0,122.406,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {
    1 <= n <= 1000 &&
    1 <= a <= 1000 &&
    1 <= b <= 1000 &&
    1 <= c <= 1000 &&
    1 <= t <= 1000 &&
    arrivals.len() == n &&
    forall|i: int| 0 <= i < arrivals.len() ==> #[trigger] arrivals[i] >= 1 && #[trigger] arrivals[i] <= t
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {
    if b > c {
        n * a
    } else {
        n * a + (c - b) * (n * t - sum_seq(arrivals))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, c: i8, t: i8, arrivals: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))
    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {
    1 <= n <= 1000 &&
    1 <= a <= 1000 &&
    1 <= b <= 1000 &&
    1 <= c <= 1000 &&
    1 <= t <= 1000 &&
    arrivals.len() == n &&
    forall|i: int| 0 <= i < arrivals.len() ==> #[trigger] arrivals[i] >= 1 && #[trigger] arrivals[i] <= t
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {
    if b > c {
        n * a
    } else {
        n * a + (c - b) * (n * t - sum_seq(arrivals))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, c: i8, t: i8, arrivals: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))
    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    1 <= a <= 1000 &&\n    1 <= b <= 1000 &&\n    1 <= c <= 1000 &&\n    1 <= t <= 1000 &&\n    arrivals.len() == n &&\n    forall|i: int| 0 <= i < arrivals.len() ==> #[trigger] arrivals[i] >= 1 && #[trigger] arrivals[i] <= t\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {\n    if b > c {\n        n * a\n    } else {\n        n * a + (c - b) * (n * t - sum_seq(arrivals))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, c: i8, t: i8, arrivals: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1577.rs,81,81,1.0,92.05,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && exists|newline_pos: int| 0 <= newline_pos < input.len() && input[newline_pos] == '\n'
}

spec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_game_string(lines[1]) &&
    {
        let n = string_to_int(lines[0]);
        let s = lines[1];
        s.len() == n && n >= 1
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9'
}

spec fn is_valid_game_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'D'
}

spec fn count_char(s: Seq<char>, c: char) -> int 
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)
    }
}

spec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {
    if count_a > count_d {
        seq!['A', 'n', 't', 'o', 'n']
    } else if count_d > count_a {
        seq!['D', 'a', 'n', 'i', 'k']
    } else {
        seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p']
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;

spec fn string_to_int(s: Seq<char>) -> int;
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@) &&
        valid_parsed_input(split_lines(input@))
    ensures 
        result@ == seq!['A', 'n', 't', 'o', 'n'] || 
        result@ == seq!['D', 'a', 'n', 'i', 'k'] || 
        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&
        result@ == {
            let lines = split_lines(input@);
            let s = lines[1];
            let count_a = count_char(s, 'A');
            let count_d = count_char(s, 'D');
            determine_winner(count_a, count_d)
        }
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && exists|newline_pos: int| 0 <= newline_pos < input.len() && input[newline_pos] == '\n'
}

spec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_game_string(lines[1]) &&
    {
        let n = string_to_int(lines[0]);
        let s = lines[1];
        s.len() == n && n >= 1
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9'
}

spec fn is_valid_game_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'D'
}

spec fn count_char(s: Seq<char>, c: char) -> int 
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)
    }
}

spec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {
    if count_a > count_d {
        seq!['A', 'n', 't', 'o', 'n']
    } else if count_d > count_a {
        seq!['D', 'a', 'n', 'i', 'k']
    } else {
        seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p']
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;

spec fn string_to_int(s: Seq<char>) -> int;
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@) &&
        valid_parsed_input(split_lines(input@))
    ensures 
        result@ == seq!['A', 'n', 't', 'o', 'n'] || 
        result@ == seq!['D', 'a', 'n', 'i', 'k'] || 
        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&
        result@ == {
            let lines = split_lines(input@);
            let s = lines[1];
            let count_a = count_char(s, 'A');
            let count_d = count_char(s, 'D');
            determine_winner(count_a, count_d)
        }
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|newline_pos: int| 0 <= newline_pos < input.len() && input[newline_pos] == '\\n'\n}\n\nspec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_game_string(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let s = lines[1];\n        s.len() == n && n >= 1\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_game_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'D'\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {\n    if count_a > count_d {\n        seq!['A', 'n', 't', 'o', 'n']\n    } else if count_d > count_a {\n        seq!['D', 'a', 'n', 'i', 'k']\n    } else {\n        seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p']\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn string_to_int(s: Seq<char>) -> int;\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@) &&\n        valid_parsed_input(split_lines(input@))\n    ensures \n        result@ == seq!['A', 'n', 't', 'o', 'n'] || \n        result@ == seq!['D', 'a', 'n', 'i', 'k'] || \n        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&\n        result@ == {\n            let lines = split_lines(input@);\n            let s = lines[1];\n            let count_a = count_char(s, 'A');\n            let count_d = count_char(s, 'D');\n            determine_winner(count_a, count_d)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1594.rs,66,66,1.0,122.568,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int
  recommends 
    n >= 0,
    songs.len() >= n,
    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0
  decreases n
  when n >= 0 && songs.len() >= n
{
  if n == 0 { 
    0 
  } else { 
    songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1) 
  }
}

spec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int
  recommends 
    song_idx >= -1,
    songs.len() > song_idx,
    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0
  decreases song_idx + 1
  when song_idx >= -1 && songs.len() > song_idx
{
  if song_idx == -1 { 
    0 
  } else { 
    songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1) 
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, songs: Vec<(i8, i8)>, queries: Vec<i8>) -> (result: Vec<i8>)
  requires 
    n >= 0,
    m >= 0,
    songs.len() == n as nat,
    queries.len() == m as nat,
    forall|i: int| #![trigger songs[i]] 0 <= i < n as int ==> songs[i].0 > 0 && songs[i].1 > 0,
    forall|i: int| #![trigger queries[i]] 0 <= i < m as int - 1 ==> queries[i] < queries[i + 1],
    forall|i: int| #![trigger queries[i]] 0 <= i < m as int ==> queries[i] >= 1,
    m == 0 || queries[(m-1) as int] as int <= sum_playlist_duration(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), n as int)
  ensures 
    result.len() == m as nat,
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> 1 <= result[i] as int <= n as int,
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> queries[i] as int <= cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 1),
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> result[i] as int == 1 || queries[i] as int > cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 2)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int
  recommends 
    n >= 0,
    songs.len() >= n,
    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0
  decreases n
  when n >= 0 && songs.len() >= n
{
  if n == 0 { 
    0 
  } else { 
    songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1) 
  }
}

spec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int
  recommends 
    song_idx >= -1,
    songs.len() > song_idx,
    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0
  decreases song_idx + 1
  when song_idx >= -1 && songs.len() > song_idx
{
  if song_idx == -1 { 
    0 
  } else { 
    songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1) 
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, songs: Vec<(i8, i8)>, queries: Vec<i8>) -> (result: Vec<i8>)
  requires 
    n >= 0,
    m >= 0,
    songs.len() == n as nat,
    queries.len() == m as nat,
    forall|i: int| #![trigger songs[i]] 0 <= i < n as int ==> songs[i].0 > 0 && songs[i].1 > 0,
    forall|i: int| #![trigger queries[i]] 0 <= i < m as int - 1 ==> queries[i] < queries[i + 1],
    forall|i: int| #![trigger queries[i]] 0 <= i < m as int ==> queries[i] >= 1,
    m == 0 || queries[(m-1) as int] as int <= sum_playlist_duration(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), n as int)
  ensures 
    result.len() == m as nat,
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> 1 <= result[i] as int <= n as int,
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> queries[i] as int <= cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 1),
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> result[i] as int == 1 || queries[i] as int > cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 2)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int\n  recommends \n    n >= 0,\n    songs.len() >= n,\n    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases n\n  when n >= 0 && songs.len() >= n\n{\n  if n == 0 { \n    0 \n  } else { \n    songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1) \n  }\n}\n\nspec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int\n  recommends \n    song_idx >= -1,\n    songs.len() > song_idx,\n    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0\n  decreases song_idx + 1\n  when song_idx >= -1 && songs.len() > song_idx\n{\n  if song_idx == -1 { \n    0 \n  } else { \n    songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1) \n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, songs: Vec<(i8, i8)>, queries: Vec<i8>) -> (result: Vec<i8>)\n  requires \n    n >= 0,\n    m >= 0,\n    songs.len() == n as nat,\n    queries.len() == m as nat,\n    forall|i: int| #![trigger songs[i]] 0 <= i < n as int ==> songs[i].0 > 0 && songs[i].1 > 0,\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int - 1 ==> queries[i] < queries[i + 1],\n    forall|i: int| #![trigger queries[i]] 0 <= i < m as int ==> queries[i] >= 1,\n    m == 0 || queries[(m-1) as int] as int <= sum_playlist_duration(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), n as int)\n  ensures \n    result.len() == m as nat,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> 1 <= result[i] as int <= n as int,\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> queries[i] as int <= cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 1),\n    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> result[i] as int == 1 || queries[i] as int > cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 2)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1598.rs,76,76,1.0,122.405,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {
    if str.len() == 0 {
        0
    } else if str.len() == 1 {
        1
    } else {
        longest_non_decreasing_subseq_helper(str, 1, 1, 1)
    }
}

spec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat
    decreases str.len() - i
{
    if i >= str.len() {
        max_len
    } else {
        let new_current_len = if str[i] >= str[i-1] { current_len + 1 } else { 1 };
        let new_max_len = if new_current_len > max_len { new_current_len } else { max_len };
        longest_non_decreasing_subseq_helper(str, i + 1, new_current_len, new_max_len)
    }
}

spec fn count_zeros(str: Seq<char>) -> nat
    decreases str.len()
{
    if str.len() == 0 {
        0
    } else if str[0] == '0' {
        1 + count_zeros(str.subrange(1, str.len() as int))
    } else {
        count_zeros(str.subrange(1, str.len() as int))
    }
}

spec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {
    forall|l: int, r: int| 0 <= l <= r <= s.len() ==> 
        longest_non_decreasing_subseq(s.subrange(l, r)) == longest_non_decreasing_subseq(t.subrange(l, r))
}

spec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {
    s.len() == t.len() && same_subsequence_lengths(s, t)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires
        valid_binary_string(s@),
    ensures
        valid_solution(s@, result@),
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {
    if str.len() == 0 {
        0
    } else if str.len() == 1 {
        1
    } else {
        longest_non_decreasing_subseq_helper(str, 1, 1, 1)
    }
}

spec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat
    decreases str.len() - i
{
    if i >= str.len() {
        max_len
    } else {
        let new_current_len = if str[i] >= str[i-1] { current_len + 1 } else { 1 };
        let new_max_len = if new_current_len > max_len { new_current_len } else { max_len };
        longest_non_decreasing_subseq_helper(str, i + 1, new_current_len, new_max_len)
    }
}

spec fn count_zeros(str: Seq<char>) -> nat
    decreases str.len()
{
    if str.len() == 0 {
        0
    } else if str[0] == '0' {
        1 + count_zeros(str.subrange(1, str.len() as int))
    } else {
        count_zeros(str.subrange(1, str.len() as int))
    }
}

spec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {
    forall|l: int, r: int| 0 <= l <= r <= s.len() ==> 
        longest_non_decreasing_subseq(s.subrange(l, r)) == longest_non_decreasing_subseq(t.subrange(l, r))
}

spec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {
    s.len() == t.len() && same_subsequence_lengths(s, t)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires
        valid_binary_string(s@),
    ensures
        valid_solution(s@, result@),
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {\n    if str.len() == 0 {\n        0\n    } else if str.len() == 1 {\n        1\n    } else {\n        longest_non_decreasing_subseq_helper(str, 1, 1, 1)\n    }\n}\n\nspec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat\n    decreases str.len() - i\n{\n    if i >= str.len() {\n        max_len\n    } else {\n        let new_current_len = if str[i] >= str[i-1] { current_len + 1 } else { 1 };\n        let new_max_len = if new_current_len > max_len { new_current_len } else { max_len };\n        longest_non_decreasing_subseq_helper(str, i + 1, new_current_len, new_max_len)\n    }\n}\n\nspec fn count_zeros(str: Seq<char>) -> nat\n    decreases str.len()\n{\n    if str.len() == 0 {\n        0\n    } else if str[0] == '0' {\n        1 + count_zeros(str.subrange(1, str.len() as int))\n    } else {\n        count_zeros(str.subrange(1, str.len() as int))\n    }\n}\n\nspec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {\n    forall|l: int, r: int| 0 <= l <= r <= s.len() ==> \n        longest_non_decreasing_subseq(s.subrange(l, r)) == longest_non_decreasing_subseq(t.subrange(l, r))\n}\n\nspec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && same_subsequence_lengths(s, t)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_binary_string(s@),\n    ensures\n        valid_solution(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1605.rs,71,71,1.0,92.281,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'a' || s[i] == 'b'
}

spec fn merge_consecutive(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        s
    } else if s.len() == 1 {
        s
    } else if s[0] == s[1] {
        merge_consecutive(s.subrange(1, s.len() as int))
    } else {
        seq![s[0]].add(merge_consecutive(s.subrange(1, s.len() as int)))
    }
}

spec fn is_palindrome(s: Seq<char>) -> bool
    decreases s.len()
{
    if s.len() <= 1 {
        true
    } else {
        s[0] == s[s.len() - 1] && is_palindrome(s.subrange(1, s.len() - 1))
    }
}

spec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {
    &&& valid_input(s)
    &&& 0 <= i <= j < s.len()
    &&& {
        let sub = s.subrange(i, j + 1);
        is_palindrome(merge_consecutive(sub))
    }
}

spec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {
    &&& valid_input(s)
    &&& even_count >= 0
    &&& odd_count >= 0
    &&& even_count + odd_count >= s.len()
    &&& odd_count >= s.len()
    &&& (s.len() == 1 ==> even_count == 0 && odd_count == 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: (u32, u32))
    requires valid_input(s@)
    ensures valid_output(s@, result.0 as int, result.1 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 0)
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'a' || s[i] == 'b'
}

spec fn merge_consecutive(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        s
    } else if s.len() == 1 {
        s
    } else if s[0] == s[1] {
        merge_consecutive(s.subrange(1, s.len() as int))
    } else {
        seq![s[0]].add(merge_consecutive(s.subrange(1, s.len() as int)))
    }
}

spec fn is_palindrome(s: Seq<char>) -> bool
    decreases s.len()
{
    if s.len() <= 1 {
        true
    } else {
        s[0] == s[s.len() - 1] && is_palindrome(s.subrange(1, s.len() - 1))
    }
}

spec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {
    &&& valid_input(s)
    &&& 0 <= i <= j < s.len()
    &&& {
        let sub = s.subrange(i, j + 1);
        is_palindrome(merge_consecutive(sub))
    }
}

spec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {
    &&& valid_input(s)
    &&& even_count >= 0
    &&& odd_count >= 0
    &&& even_count + odd_count >= s.len()
    &&& odd_count >= s.len()
    &&& (s.len() == 1 ==> even_count == 0 && odd_count == 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: (u32, u32))
    requires valid_input(s@)
    ensures valid_output(s@, result.0 as int, result.1 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 0)
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'a' || s[i] == 'b'\n}\n\nspec fn merge_consecutive(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s.len() == 1 {\n        s\n    } else if s[0] == s[1] {\n        merge_consecutive(s.subrange(1, s.len() as int))\n    } else {\n        seq![s[0]].add(merge_consecutive(s.subrange(1, s.len() as int)))\n    }\n}\n\nspec fn is_palindrome(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        true\n    } else {\n        s[0] == s[s.len() - 1] && is_palindrome(s.subrange(1, s.len() - 1))\n    }\n}\n\nspec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {\n    &&& valid_input(s)\n    &&& 0 <= i <= j < s.len()\n    &&& {\n        let sub = s.subrange(i, j + 1);\n        is_palindrome(merge_consecutive(sub))\n    }\n}\n\nspec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {\n    &&& valid_input(s)\n    &&& even_count >= 0\n    &&& odd_count >= 0\n    &&& even_count + odd_count >= s.len()\n    &&& odd_count >= s.len()\n    &&& (s.len() == 1 ==> even_count == 0 && odd_count == 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: (u32, u32))\n    requires valid_input(s@)\n    ensures valid_output(s@, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1618.rs,58,58,1.0,153.504,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn max(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn valid_stairs(stair_heights: Seq<int>) -> bool {
    stair_heights.len() >= 1 &&
    (forall|i: int| 0 <= i < stair_heights.len() - 1 ==> #[trigger] stair_heights[i] <= stair_heights[add(i, 1)]) &&
    (forall|i: int| 0 <= i < stair_heights.len() ==> #[trigger] stair_heights[i] >= 0)
}

spec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {
    forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1
}

spec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool
    recommends 
        stair_heights.len() >= 1,
        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()
{
    result.len() == boxes.len() &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] result[i] >= 0) &&
    (forall|i: int| 0 <= i < boxes.len() ==> 
        result[i] >= stair_heights[0] && result[i] >= stair_heights[sub(boxes[i].0, 1)]) &&
    (forall|i: int| 0 <= i < boxes.len() ==> 
        result[i] == max(if i == 0 { stair_heights[0] } else { result[sub(i, 1)] + boxes[sub(i, 1)].1 }, 
                        stair_heights[sub(boxes[i].0, 1)]))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stairs_amount: i8, stair_heights: Vec<i8>, boxes_amount: i8, boxes: Vec<(i8, i8)>) -> (result: Vec<i8>)
    requires 
        stairs_amount >= 1,
        stair_heights.len() == stairs_amount as int,
        boxes_amount >= 0,
        boxes.len() == boxes_amount as int,
        valid_stairs(stair_heights@.map(|i: int, x: i8| x as int)),
        valid_boxes(boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stairs_amount as int),
    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn max(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn valid_stairs(stair_heights: Seq<int>) -> bool {
    stair_heights.len() >= 1 &&
    (forall|i: int| 0 <= i < stair_heights.len() - 1 ==> #[trigger] stair_heights[i] <= stair_heights[add(i, 1)]) &&
    (forall|i: int| 0 <= i < stair_heights.len() ==> #[trigger] stair_heights[i] >= 0)
}

spec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {
    forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1
}

spec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool
    recommends 
        stair_heights.len() >= 1,
        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()
{
    result.len() == boxes.len() &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] result[i] >= 0) &&
    (forall|i: int| 0 <= i < boxes.len() ==> 
        result[i] >= stair_heights[0] && result[i] >= stair_heights[sub(boxes[i].0, 1)]) &&
    (forall|i: int| 0 <= i < boxes.len() ==> 
        result[i] == max(if i == 0 { stair_heights[0] } else { result[sub(i, 1)] + boxes[sub(i, 1)].1 }, 
                        stair_heights[sub(boxes[i].0, 1)]))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stairs_amount: i8, stair_heights: Vec<i8>, boxes_amount: i8, boxes: Vec<(i8, i8)>) -> (result: Vec<i8>)
    requires 
        stairs_amount >= 1,
        stair_heights.len() == stairs_amount as int,
        boxes_amount >= 0,
        boxes.len() == boxes_amount as int,
        valid_stairs(stair_heights@.map(|i: int, x: i8| x as int)),
        valid_boxes(boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stairs_amount as int),
    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn valid_stairs(stair_heights: Seq<int>) -> bool {\n    stair_heights.len() >= 1 &&\n    (forall|i: int| 0 <= i < stair_heights.len() - 1 ==> #[trigger] stair_heights[i] <= stair_heights[add(i, 1)]) &&\n    (forall|i: int| 0 <= i < stair_heights.len() ==> #[trigger] stair_heights[i] >= 0)\n}\n\nspec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {\n    forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1\n}\n\nspec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool\n    recommends \n        stair_heights.len() >= 1,\n        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()\n{\n    result.len() == boxes.len() &&\n    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] >= stair_heights[0] && result[i] >= stair_heights[sub(boxes[i].0, 1)]) &&\n    (forall|i: int| 0 <= i < boxes.len() ==> \n        result[i] == max(if i == 0 { stair_heights[0] } else { result[sub(i, 1)] + boxes[sub(i, 1)].1 }, \n                        stair_heights[sub(boxes[i].0, 1)]))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stairs_amount: i8, stair_heights: Vec<i8>, boxes_amount: i8, boxes: Vec<(i8, i8)>) -> (result: Vec<i8>)\n    requires \n        stairs_amount >= 1,\n        stair_heights.len() == stairs_amount as int,\n        boxes_amount >= 0,\n        boxes.len() == boxes_amount as int,\n        valid_stairs(stair_heights@.map(|i: int, x: i8| x as int)),\n        valid_boxes(boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stairs_amount as int),\n    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1621.rs,60,60,1.0,122.385,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn string_value(s: Seq<char>, w: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0 }
  else {
    let char_index = (s.last() as int) - ('a' as int);
    string_value(s.drop_last(), w) + s.len() * w[char_index]
  }
}

spec fn append_value(start_pos: int, count: int, max_val: int) -> int
  decreases count
{
  if count <= 0 { 0 }
  else { (start_pos + count) * max_val + append_value(start_pos, count - 1, max_val) }
}

spec fn max_value(w: Seq<int>) -> int
  decreases w.len()
{
  if w.len() <= 1 { w[0] }
  else if w[0] >= max_value(w.subrange(1, w.len() as int)) { w[0] }
  else { max_value(w.subrange(1, w.len() as int)) }
}

spec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool
{
  w.len() == 26 && 
  k >= 0 && 
  s.len() <= 1000 && 
  k <= 1000 && 
  (forall|i: int| 0 <= i < w.len() ==> #[trigger] w[i] >= 0 && #[trigger] w[i] <= 1000) &&
  (forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] && #[trigger] s[i] <= 'z')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>, k: i8, w: Vec<i8>) -> (result: i8)
  requires valid_input(s@, k as int, w@.map(|i, x| x as int))
  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn string_value(s: Seq<char>, w: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0 }
  else {
    let char_index = (s.last() as int) - ('a' as int);
    string_value(s.drop_last(), w) + s.len() * w[char_index]
  }
}

spec fn append_value(start_pos: int, count: int, max_val: int) -> int
  decreases count
{
  if count <= 0 { 0 }
  else { (start_pos + count) * max_val + append_value(start_pos, count - 1, max_val) }
}

spec fn max_value(w: Seq<int>) -> int
  decreases w.len()
{
  if w.len() <= 1 { w[0] }
  else if w[0] >= max_value(w.subrange(1, w.len() as int)) { w[0] }
  else { max_value(w.subrange(1, w.len() as int)) }
}

spec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool
{
  w.len() == 26 && 
  k >= 0 && 
  s.len() <= 1000 && 
  k <= 1000 && 
  (forall|i: int| 0 <= i < w.len() ==> #[trigger] w[i] >= 0 && #[trigger] w[i] <= 1000) &&
  (forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] && #[trigger] s[i] <= 'z')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>, k: i8, w: Vec<i8>) -> (result: i8)
  requires valid_input(s@, k as int, w@.map(|i, x| x as int))
  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn string_value(s: Seq<char>, w: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 }\n  else {\n    let char_index = (s.last() as int) - ('a' as int);\n    string_value(s.drop_last(), w) + s.len() * w[char_index]\n  }\n}\n\nspec fn append_value(start_pos: int, count: int, max_val: int) -> int\n  decreases count\n{\n  if count <= 0 { 0 }\n  else { (start_pos + count) * max_val + append_value(start_pos, count - 1, max_val) }\n}\n\nspec fn max_value(w: Seq<int>) -> int\n  decreases w.len()\n{\n  if w.len() <= 1 { w[0] }\n  else if w[0] >= max_value(w.subrange(1, w.len() as int)) { w[0] }\n  else { max_value(w.subrange(1, w.len() as int)) }\n}\n\nspec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool\n{\n  w.len() == 26 && \n  k >= 0 && \n  s.len() <= 1000 && \n  k <= 1000 && \n  (forall|i: int| 0 <= i < w.len() ==> #[trigger] w[i] >= 0 && #[trigger] w[i] <= 1000) &&\n  (forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] && #[trigger] s[i] <= 'z')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, k: i8, w: Vec<i8>) -> (result: i8)\n  requires valid_input(s@, k as int, w@.map(|i, x| x as int))\n  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1623.rs,76,76,1.0,92.135,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, l: int, r: int) -> bool {
    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20
}

spec fn power(base: int, exp: int) -> int
    decreases exp
{
    if exp <= 0 { 1 } else { base * power(base, exp - 1) }
}

spec fn sum_with_decreasing_powers(n: int, start_power: int) -> int
    decreases n
{
    if n <= 0 { 0 } 
    else if start_power <= 1 { n }
    else { start_power + sum_with_decreasing_powers(n - 1, start_power / 2) }
}

spec fn sum_with_increasing_powers(n: int, max_power: int) -> int
    decreases n
{
    if n <= 0 { 0 }
    else if n == 1 { max_power }
    else { max_power + sum_with_increasing_powers(n - 1, max_power * 2) }
}

spec fn min_sum_calculation(n: int, l: int) -> int {
    if n >= 1 && l >= 1 {
        let start_power = power(2, l - 1);
        sum_with_decreasing_powers(n, start_power)
    } else {
        0
    }
}

spec fn max_sum_calculation(n: int, r: int) -> int {
    if n >= 1 && r >= 1 {
        let max_power = power(2, r - 1);
        sum_with_increasing_powers(n, max_power)
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, l: i8, r: i8) -> (result: (i8, i8))
    requires valid_input(n as int, l as int, r as int)
    ensures ({
        let (min_sum, max_sum) = result;
        min_sum > 0 &&
        max_sum > 0 &&
        min_sum <= max_sum &&
        min_sum as int == min_sum_calculation(n as int, l as int) &&
        max_sum as int == max_sum_calculation(n as int, r as int)
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 0)
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, l: int, r: int) -> bool {
    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20
}

spec fn power(base: int, exp: int) -> int
    decreases exp
{
    if exp <= 0 { 1 } else { base * power(base, exp - 1) }
}

spec fn sum_with_decreasing_powers(n: int, start_power: int) -> int
    decreases n
{
    if n <= 0 { 0 } 
    else if start_power <= 1 { n }
    else { start_power + sum_with_decreasing_powers(n - 1, start_power / 2) }
}

spec fn sum_with_increasing_powers(n: int, max_power: int) -> int
    decreases n
{
    if n <= 0 { 0 }
    else if n == 1 { max_power }
    else { max_power + sum_with_increasing_powers(n - 1, max_power * 2) }
}

spec fn min_sum_calculation(n: int, l: int) -> int {
    if n >= 1 && l >= 1 {
        let start_power = power(2, l - 1);
        sum_with_decreasing_powers(n, start_power)
    } else {
        0
    }
}

spec fn max_sum_calculation(n: int, r: int) -> int {
    if n >= 1 && r >= 1 {
        let max_power = power(2, r - 1);
        sum_with_increasing_powers(n, max_power)
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, l: i8, r: i8) -> (result: (i8, i8))
    requires valid_input(n as int, l as int, r as int)
    ensures ({
        let (min_sum, max_sum) = result;
        min_sum > 0 &&
        max_sum > 0 &&
        min_sum <= max_sum &&
        min_sum as int == min_sum_calculation(n as int, l as int) &&
        max_sum as int == max_sum_calculation(n as int, r as int)
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 0)
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, l: int, r: int) -> bool {\n    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 } else { base * power(base, exp - 1) }\n}\n\nspec fn sum_with_decreasing_powers(n: int, start_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 } \n    else if start_power <= 1 { n }\n    else { start_power + sum_with_decreasing_powers(n - 1, start_power / 2) }\n}\n\nspec fn sum_with_increasing_powers(n: int, max_power: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 }\n    else if n == 1 { max_power }\n    else { max_power + sum_with_increasing_powers(n - 1, max_power * 2) }\n}\n\nspec fn min_sum_calculation(n: int, l: int) -> int {\n    if n >= 1 && l >= 1 {\n        let start_power = power(2, l - 1);\n        sum_with_decreasing_powers(n, start_power)\n    } else {\n        0\n    }\n}\n\nspec fn max_sum_calculation(n: int, r: int) -> int {\n    if n >= 1 && r >= 1 {\n        let max_power = power(2, r - 1);\n        sum_with_increasing_powers(n, max_power)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, l: i8, r: i8) -> (result: (i8, i8))\n    requires valid_input(n as int, l as int, r as int)\n    ensures ({\n        let (min_sum, max_sum) = result;\n        min_sum > 0 &&\n        max_sum > 0 &&\n        min_sum <= max_sum &&\n        min_sum as int == min_sum_calculation(n as int, l as int) &&\n        max_sum as int == max_sum_calculation(n as int, r as int)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1627.rs,87,87,1.0,92.102,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, arr: Seq<int>) -> bool {
    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1
}

spec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {
    forall|op: (int, int)| operations.contains(op) ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1
}

spec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool 
    decreases arr.len() - i
{
    if i >= arr.len() - 1 {
        true
    } else {
        arr[i] <= arr[i + 1] && is_sorted_helper(arr, i + 1)
    }
}

spec fn is_sorted(arr: Seq<int>) -> bool {
    if arr.len() <= 1 {
        true
    } else {
        is_sorted_helper(arr, 0)
    }
}

spec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {
    if i >= 0 && j >= 0 && i < arr.len() && j < arr.len() && j == i + 1 {
        arr.update(i, arr[j]).update(j, arr[i])
    } else {
        arr
    }
}

spec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>
    decreases operations.len()
{
    if operations.len() == 0 {
        arr
    } else {
        let op = operations[0];
        if 1 <= op.0 <= arr.len() && 1 <= op.1 <= arr.len() && op.1 == op.0 + 1 {
            let new_arr = swap_adjacent(arr, (op.0 - 1) as int, (op.1 - 1) as int);
            apply_operations(new_arr, operations.drop_first())
        } else {
            apply_operations(arr, operations.drop_first())
        }
    }
}

spec fn count_inversions(arr: Seq<int>) -> nat {
    /* Count of pairs (i, j) where i < j and arr[i] > arr[j] */
    0nat /* Placeholder implementation */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, arr: Vec<i8>) -> (operations: Vec<(i8, i8)>)
  requires 
      valid_input(n as int, arr@.map_values(|x: i8| x as int)),
  ensures 
      valid_operations(operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)), n as int) &&
      (is_sorted(apply_operations(arr@.map_values(|x: i8| x as int), operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)))) || operations.len() == 20000) &&
      operations.len() <= 20000 &&
      (is_sorted(arr@.map_values(|x: i8| x as int)) ==> operations.len() == 0)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, arr: Seq<int>) -> bool {
    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1
}

spec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {
    forall|op: (int, int)| operations.contains(op) ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1
}

spec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool 
    decreases arr.len() - i
{
    if i >= arr.len() - 1 {
        true
    } else {
        arr[i] <= arr[i + 1] && is_sorted_helper(arr, i + 1)
    }
}

spec fn is_sorted(arr: Seq<int>) -> bool {
    if arr.len() <= 1 {
        true
    } else {
        is_sorted_helper(arr, 0)
    }
}

spec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {
    if i >= 0 && j >= 0 && i < arr.len() && j < arr.len() && j == i + 1 {
        arr.update(i, arr[j]).update(j, arr[i])
    } else {
        arr
    }
}

spec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>
    decreases operations.len()
{
    if operations.len() == 0 {
        arr
    } else {
        let op = operations[0];
        if 1 <= op.0 <= arr.len() && 1 <= op.1 <= arr.len() && op.1 == op.0 + 1 {
            let new_arr = swap_adjacent(arr, (op.0 - 1) as int, (op.1 - 1) as int);
            apply_operations(new_arr, operations.drop_first())
        } else {
            apply_operations(arr, operations.drop_first())
        }
    }
}

spec fn count_inversions(arr: Seq<int>) -> nat {
    /* Count of pairs (i, j) where i < j and arr[i] > arr[j] */
    0nat /* Placeholder implementation */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, arr: Vec<i8>) -> (operations: Vec<(i8, i8)>)
  requires 
      valid_input(n as int, arr@.map_values(|x: i8| x as int)),
  ensures 
      valid_operations(operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)), n as int) &&
      (is_sorted(apply_operations(arr@.map_values(|x: i8| x as int), operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)))) || operations.len() == 20000) &&
      operations.len() <= 20000 &&
      (is_sorted(arr@.map_values(|x: i8| x as int)) ==> operations.len() == 0)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {\n    forall|op: (int, int)| operations.contains(op) ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1\n}\n\nspec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool \n    decreases arr.len() - i\n{\n    if i >= arr.len() - 1 {\n        true\n    } else {\n        arr[i] <= arr[i + 1] && is_sorted_helper(arr, i + 1)\n    }\n}\n\nspec fn is_sorted(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 {\n        true\n    } else {\n        is_sorted_helper(arr, 0)\n    }\n}\n\nspec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {\n    if i >= 0 && j >= 0 && i < arr.len() && j < arr.len() && j == i + 1 {\n        arr.update(i, arr[j]).update(j, arr[i])\n    } else {\n        arr\n    }\n}\n\nspec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>\n    decreases operations.len()\n{\n    if operations.len() == 0 {\n        arr\n    } else {\n        let op = operations[0];\n        if 1 <= op.0 <= arr.len() && 1 <= op.1 <= arr.len() && op.1 == op.0 + 1 {\n            let new_arr = swap_adjacent(arr, (op.0 - 1) as int, (op.1 - 1) as int);\n            apply_operations(new_arr, operations.drop_first())\n        } else {\n            apply_operations(arr, operations.drop_first())\n        }\n    }\n}\n\nspec fn count_inversions(arr: Seq<int>) -> nat {\n    /* Count of pairs (i, j) where i < j and arr[i] > arr[j] */\n    0nat /* Placeholder implementation */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, arr: Vec<i8>) -> (operations: Vec<(i8, i8)>)\n  requires \n      valid_input(n as int, arr@.map_values(|x: i8| x as int)),\n  ensures \n      valid_operations(operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)), n as int) &&\n      (is_sorted(apply_operations(arr@.map_values(|x: i8| x as int), operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)))) || operations.len() == 20000) &&\n      operations.len() <= 20000 &&\n      (is_sorted(arr@.map_values(|x: i8| x as int)) ==> operations.len() == 0)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_164.rs,79,79,1.0,122.539,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {
    y1 < y2 < y_w &&
    y_b + r < y_w &&
    2 * r < y2 - y1 &&
    x_b > 0 && y_b > 0 && r > 0 &&
    2 * (y_w - r) - y1 - y_b - r != 0
}

spec fn compute_w(y_w: int, r: int) -> int {
    y_w - r
}

spec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {
    2 * (y_w - r) - y1 - y_b - r
}

spec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {
    2 * (y_w - r) - y2 - y_b
}

spec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {
    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)
}

spec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {
    (new_y1 * new_y1 + x_b * x_b) * r * r
}

spec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool
    recommends valid_input(y1, y2, y_w, x_b, y_b, r)
{
    let w = compute_w(y_w, r);
    let new_y1 = compute_new_y1(y_w, r, y1, y_b);
    let new_y2 = compute_new_y2(y_w, r, y2, y_b);
    let left_side = compute_left_side(x_b, new_y1, new_y2);
    let right_side = compute_right_side(x_b, new_y1, r);
    left_side <= right_side
}

spec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int
    recommends 
        valid_input(y1, y2, y_w, x_b, y_b, r) &&
        !is_impossible(y1, y2, y_w, x_b, y_b, r)
{
    let w = compute_w(y_w, r);
    let new_y1 = compute_new_y1(y_w, r, y1, y_b);
    x_b * (new_y1 + y_b - w) / new_y1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(y1: i8, y2: i8, y_w: i8, x_b: i8, y_b: i8, r: i8) -> (result: i8)
    requires 
        valid_input(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)
    ensures 
        is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result == -1,
        !is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result as int == compute_solution(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {
    y1 < y2 < y_w &&
    y_b + r < y_w &&
    2 * r < y2 - y1 &&
    x_b > 0 && y_b > 0 && r > 0 &&
    2 * (y_w - r) - y1 - y_b - r != 0
}

spec fn compute_w(y_w: int, r: int) -> int {
    y_w - r
}

spec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {
    2 * (y_w - r) - y1 - y_b - r
}

spec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {
    2 * (y_w - r) - y2 - y_b
}

spec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {
    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)
}

spec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {
    (new_y1 * new_y1 + x_b * x_b) * r * r
}

spec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool
    recommends valid_input(y1, y2, y_w, x_b, y_b, r)
{
    let w = compute_w(y_w, r);
    let new_y1 = compute_new_y1(y_w, r, y1, y_b);
    let new_y2 = compute_new_y2(y_w, r, y2, y_b);
    let left_side = compute_left_side(x_b, new_y1, new_y2);
    let right_side = compute_right_side(x_b, new_y1, r);
    left_side <= right_side
}

spec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int
    recommends 
        valid_input(y1, y2, y_w, x_b, y_b, r) &&
        !is_impossible(y1, y2, y_w, x_b, y_b, r)
{
    let w = compute_w(y_w, r);
    let new_y1 = compute_new_y1(y_w, r, y1, y_b);
    x_b * (new_y1 + y_b - w) / new_y1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(y1: i8, y2: i8, y_w: i8, x_b: i8, y_b: i8, r: i8) -> (result: i8)
    requires 
        valid_input(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)
    ensures 
        is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result == -1,
        !is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result as int == compute_solution(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {\n    y1 < y2 < y_w &&\n    y_b + r < y_w &&\n    2 * r < y2 - y1 &&\n    x_b > 0 && y_b > 0 && r > 0 &&\n    2 * (y_w - r) - y1 - y_b - r != 0\n}\n\nspec fn compute_w(y_w: int, r: int) -> int {\n    y_w - r\n}\n\nspec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {\n    2 * (y_w - r) - y1 - y_b - r\n}\n\nspec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {\n    2 * (y_w - r) - y2 - y_b\n}\n\nspec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {\n    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)\n}\n\nspec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {\n    (new_y1 * new_y1 + x_b * x_b) * r * r\n}\n\nspec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool\n    recommends valid_input(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    let new_y2 = compute_new_y2(y_w, r, y2, y_b);\n    let left_side = compute_left_side(x_b, new_y1, new_y2);\n    let right_side = compute_right_side(x_b, new_y1, r);\n    left_side <= right_side\n}\n\nspec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int\n    recommends \n        valid_input(y1, y2, y_w, x_b, y_b, r) &&\n        !is_impossible(y1, y2, y_w, x_b, y_b, r)\n{\n    let w = compute_w(y_w, r);\n    let new_y1 = compute_new_y1(y_w, r, y1, y_b);\n    x_b * (new_y1 + y_b - w) / new_y1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(y1: i8, y2: i8, y_w: i8, x_b: i8, y_b: i8, r: i8) -> (result: i8)\n    requires \n        valid_input(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n    ensures \n        is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result == -1,\n        !is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result as int == compute_solution(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1643.rs,87,87,1.0,92.165,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn count_zeros(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '0' {
        1 + count_zeros(s.subrange(1, s.len() as int))
    } else {
        count_zeros(s.subrange(1, s.len() as int))
    }
}

spec fn count_ones(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '1' {
        1 + count_ones(s.subrange(1, s.len() as int))
    } else {
        count_ones(s.subrange(1, s.len() as int))
    }
}

spec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        1
    } else {
        let count_ones = count_ones(s);
        let count_zeros = s.len() - count_ones;
        if count_zeros == 0 {
            count_ones
        } else if count_ones == 0 {
            1
        } else {
            count_zeros + count_ones
        }
    }
}

spec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int
    recommends 0 <= l <= r < s.len()
{
    let sub = s.subrange(l, r + 1);
    longest_non_decreasing_subseq_length_complete(sub)
}

spec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {
    &&& s.len() == t.len()
    &&& valid_binary_string(s)
    &&& valid_binary_string(t)
    &&& (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' ==> t[i] == '0')
    &&& (forall|i: int| 0 <= i < s.len() ==> t[i] == '1' ==> s[i] == '1')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_binary_string(s@)
    ensures basic_valid_solution(s@, result@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn count_zeros(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '0' {
        1 + count_zeros(s.subrange(1, s.len() as int))
    } else {
        count_zeros(s.subrange(1, s.len() as int))
    }
}

spec fn count_ones(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '1' {
        1 + count_ones(s.subrange(1, s.len() as int))
    } else {
        count_ones(s.subrange(1, s.len() as int))
    }
}

spec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        1
    } else {
        let count_ones = count_ones(s);
        let count_zeros = s.len() - count_ones;
        if count_zeros == 0 {
            count_ones
        } else if count_ones == 0 {
            1
        } else {
            count_zeros + count_ones
        }
    }
}

spec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int
    recommends 0 <= l <= r < s.len()
{
    let sub = s.subrange(l, r + 1);
    longest_non_decreasing_subseq_length_complete(sub)
}

spec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {
    &&& s.len() == t.len()
    &&& valid_binary_string(s)
    &&& valid_binary_string(t)
    &&& (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' ==> t[i] == '0')
    &&& (forall|i: int| 0 <= i < s.len() ==> t[i] == '1' ==> s[i] == '1')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_binary_string(s@)
    ensures basic_valid_solution(s@, result@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '0' {\n        1 + count_zeros(s.subrange(1, s.len() as int))\n    } else {\n        count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_ones(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        1 + count_ones(s.subrange(1, s.len() as int))\n    } else {\n        count_ones(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        1\n    } else {\n        let count_ones = count_ones(s);\n        let count_zeros = s.len() - count_ones;\n        if count_zeros == 0 {\n            count_ones\n        } else if count_ones == 0 {\n            1\n        } else {\n            count_zeros + count_ones\n        }\n    }\n}\n\nspec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int\n    recommends 0 <= l <= r < s.len()\n{\n    let sub = s.subrange(l, r + 1);\n    longest_non_decreasing_subseq_length_complete(sub)\n}\n\nspec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {\n    &&& s.len() == t.len()\n    &&& valid_binary_string(s)\n    &&& valid_binary_string(t)\n    &&& (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' ==> t[i] == '0')\n    &&& (forall|i: int| 0 <= i < s.len() ==> t[i] == '1' ==> s[i] == '1')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_binary_string(s@)\n    ensures basic_valid_solution(s@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1646.rs,57,57,1.0,92.023,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_binary_string(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1') &&
    (s == seq!['0'] || s[0] == '1')
}

spec fn count_zeros(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0int
    } else { 
        (if s[0] == '0' { 1int } else { 0int }) + count_zeros(s.subrange(1, s.len() as int))
    }
}

spec fn create_zero_seq(n: nat) -> Seq<char> {
    Seq::new(n, |i: int| '0')
}

spec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {
    (s == seq!['0'] ==> result == seq!['0'])
    &&
    (s != seq!['0'] ==> result == seq!['1'] + create_zero_seq(count_zeros(s) as nat))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, s: Vec<char>) -> (result: Vec<char>)
    requires 
        n >= 1 && n <= 100,
        s.len() == n as usize,
        valid_binary_string(s@),
    ensures 
        valid_binary_string(result@),
        is_minimal_form(s@, result@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_binary_string(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1') &&
    (s == seq!['0'] || s[0] == '1')
}

spec fn count_zeros(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0int
    } else { 
        (if s[0] == '0' { 1int } else { 0int }) + count_zeros(s.subrange(1, s.len() as int))
    }
}

spec fn create_zero_seq(n: nat) -> Seq<char> {
    Seq::new(n, |i: int| '0')
}

spec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {
    (s == seq!['0'] ==> result == seq!['0'])
    &&
    (s != seq!['0'] ==> result == seq!['1'] + create_zero_seq(count_zeros(s) as nat))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, s: Vec<char>) -> (result: Vec<char>)
    requires 
        n >= 1 && n <= 100,
        s.len() == n as usize,
        valid_binary_string(s@),
    ensures 
        valid_binary_string(result@),
        is_minimal_form(s@, result@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1') &&\n    (s == seq!['0'] || s[0] == '1')\n}\n\nspec fn count_zeros(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0int\n    } else { \n        (if s[0] == '0' { 1int } else { 0int }) + count_zeros(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn create_zero_seq(n: nat) -> Seq<char> {\n    Seq::new(n, |i: int| '0')\n}\n\nspec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {\n    (s == seq!['0'] ==> result == seq!['0'])\n    &&\n    (s != seq!['0'] ==> result == seq!['1'] + create_zero_seq(count_zeros(s) as nat))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 1 && n <= 100,\n        s.len() == n as usize,\n        valid_binary_string(s@),\n    ensures \n        valid_binary_string(result@),\n        is_minimal_form(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1656.rs,64,64,1.0,92.036,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn wow_factor(s: Seq<char>) -> int {
    if s.len() < 4 { 0 }
    else {
        wow_factor_sum(s, 0)
    }
}

spec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos <= 1 { 0 }
    else {
        let prev = count_vv_pairs_before(s, pos - 1);
        if s[pos-1] == 'v' && s[pos-2] == 'v' { prev + 1 } else { prev }
    }
}

spec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() - 1 { 0 }
    else {
        let rest = count_vv_pairs_after(s, pos + 1);
        if pos + 1 < s.len() && s[pos] == 'v' && s[pos+1] == 'v' { rest + 1 } else { rest }
    }
}

spec fn wow_factor_sum(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() { 0 }
    else {
        let current = if s[pos] == 'o' { 
            count_vv_pairs_before(s, pos) * count_vv_pairs_after(s, pos + 1)
        } else { 0 };
        current + wow_factor_sum(s, pos + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    ensures
        result as int == wow_factor(s@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn wow_factor(s: Seq<char>) -> int {
    if s.len() < 4 { 0 }
    else {
        wow_factor_sum(s, 0)
    }
}

spec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos <= 1 { 0 }
    else {
        let prev = count_vv_pairs_before(s, pos - 1);
        if s[pos-1] == 'v' && s[pos-2] == 'v' { prev + 1 } else { prev }
    }
}

spec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() - 1 { 0 }
    else {
        let rest = count_vv_pairs_after(s, pos + 1);
        if pos + 1 < s.len() && s[pos] == 'v' && s[pos+1] == 'v' { rest + 1 } else { rest }
    }
}

spec fn wow_factor_sum(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() { 0 }
    else {
        let current = if s[pos] == 'o' { 
            count_vv_pairs_before(s, pos) * count_vv_pairs_after(s, pos + 1)
        } else { 0 };
        current + wow_factor_sum(s, pos + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    ensures
        result as int == wow_factor(s@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn wow_factor(s: Seq<char>) -> int {\n    if s.len() < 4 { 0 }\n    else {\n        wow_factor_sum(s, 0)\n    }\n}\n\nspec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos <= 1 { 0 }\n    else {\n        let prev = count_vv_pairs_before(s, pos - 1);\n        if s[pos-1] == 'v' && s[pos-2] == 'v' { prev + 1 } else { prev }\n    }\n}\n\nspec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() - 1 { 0 }\n    else {\n        let rest = count_vv_pairs_after(s, pos + 1);\n        if pos + 1 < s.len() && s[pos] == 'v' && s[pos+1] == 'v' { rest + 1 } else { rest }\n    }\n}\n\nspec fn wow_factor_sum(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() { 0 }\n    else {\n        let current = if s[pos] == 'o' { \n            count_vv_pairs_before(s, pos) * count_vv_pairs_after(s, pos + 1)\n        } else { 0 };\n        current + wow_factor_sum(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    ensures\n        result as int == wow_factor(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1689.rs,52,52,1.0,92.171,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {
    n >= 0 && rows.len() == n && forall|i: int| 0 <= i < rows.len() ==> rows[i].len() == 5
}

spec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {
    exists|i: int| 0 <= i < rows.len() && 
        ((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||
         (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))
}

spec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {
    forall|i: int| 0 <= i < rows.len() ==> 
        !((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||
          (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))
}

spec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {
    result.len() != 2 || result[0] != 'N' || result[1] != 'O' ==> result.len() >= 4
}
// </vc-preamble>

// <vc-helpers>
spec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {
    v@.map(|i, row: Vec<char>| row@)
}
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, rows: Vec<Vec<char>>) -> (result: Vec<char>)
    requires 
        valid_input(n as int, vec_to_seq_seq(rows))
    ensures 
        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') || result@.len() >= 4,
        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> no_adjacent_empty_seats(vec_to_seq_seq(rows)),
        !(result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> has_adjacent_empty_seats(vec_to_seq_seq(rows)),
        valid_solution(result@, vec_to_seq_seq(rows))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {
    n >= 0 && rows.len() == n && forall|i: int| 0 <= i < rows.len() ==> rows[i].len() == 5
}

spec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {
    exists|i: int| 0 <= i < rows.len() && 
        ((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||
         (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))
}

spec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {
    forall|i: int| 0 <= i < rows.len() ==> 
        !((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||
          (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))
}

spec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {
    result.len() != 2 || result[0] != 'N' || result[1] != 'O' ==> result.len() >= 4
}
// </vc-preamble>

// <vc-helpers>
spec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {
    v@.map(|i, row: Vec<char>| row@)
}
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, rows: Vec<Vec<char>>) -> (result: Vec<char>)
    requires 
        valid_input(n as int, vec_to_seq_seq(rows))
    ensures 
        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') || result@.len() >= 4,
        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> no_adjacent_empty_seats(vec_to_seq_seq(rows)),
        !(result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> has_adjacent_empty_seats(vec_to_seq_seq(rows)),
        valid_solution(result@, vec_to_seq_seq(rows))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {\n    n >= 0 && rows.len() == n && forall|i: int| 0 <= i < rows.len() ==> rows[i].len() == 5\n}\n\nspec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    exists|i: int| 0 <= i < rows.len() && \n        ((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n         (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < rows.len() ==> \n        !((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n          (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\nspec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {\n    result.len() != 2 || result[0] != 'N' || result[1] != 'O' ==> result.len() >= 4\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {\n    v@.map(|i, row: Vec<char>| row@)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, rows: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        valid_input(n as int, vec_to_seq_seq(rows))\n    ensures \n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') || result@.len() >= 4,\n        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> no_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        !(result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> has_adjacent_empty_seats(vec_to_seq_seq(rows)),\n        valid_solution(result@, vec_to_seq_seq(rows))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_171.rs,70,70,1.0,92.152,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn contains_lowercase(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && 'a' <= s[i] && s[i] <= 'z'
}

spec fn contains_uppercase(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && 'A' <= s[i] && s[i] <= 'Z'
}

spec fn contains_digit(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'
}

spec fn is_valid_password(s: Seq<char>) -> bool {
    s.len() >= 5 && contains_lowercase(s) && contains_uppercase(s) && contains_digit(s)
}

spec fn trim_newline(s: Seq<char>) -> Seq<char> {
    if s.len() > 0 && s[s.len() as int - 1] == '\n' { 
        s.subrange(0, s.len() as int - 1) 
    } else { 
        s 
    }
}

spec fn strip_whitespace(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 { 
        s
    } else if s[0] == ' ' || s[0] == '\t' || s[0] == '\n' || s[0] == '\r' {
        strip_whitespace(s.subrange(1, s.len() as int))
    } else if s[s.len() as int - 1] == ' ' || s[s.len() as int - 1] == '\t' || s[s.len() as int - 1] == '\n' || s[s.len() as int - 1] == '\r' {
        strip_whitespace(s.subrange(0, s.len() as int - 1))
    } else { 
        s 
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires input@.len() > 0
    ensures ({
        let processed_input = trim_newline(input@);
        let stripped = strip_whitespace(processed_input);
        if is_valid_password(stripped) {
            output@ == seq!['C', 'o', 'r', 'r', 'e', 'c', 't', '\n']
        } else {
            output@ == seq!['T', 'o', 'o', ' ', 'w', 'e', 'a', 'k', '\n']
        }
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn contains_lowercase(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && 'a' <= s[i] && s[i] <= 'z'
}

spec fn contains_uppercase(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && 'A' <= s[i] && s[i] <= 'Z'
}

spec fn contains_digit(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'
}

spec fn is_valid_password(s: Seq<char>) -> bool {
    s.len() >= 5 && contains_lowercase(s) && contains_uppercase(s) && contains_digit(s)
}

spec fn trim_newline(s: Seq<char>) -> Seq<char> {
    if s.len() > 0 && s[s.len() as int - 1] == '\n' { 
        s.subrange(0, s.len() as int - 1) 
    } else { 
        s 
    }
}

spec fn strip_whitespace(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 { 
        s
    } else if s[0] == ' ' || s[0] == '\t' || s[0] == '\n' || s[0] == '\r' {
        strip_whitespace(s.subrange(1, s.len() as int))
    } else if s[s.len() as int - 1] == ' ' || s[s.len() as int - 1] == '\t' || s[s.len() as int - 1] == '\n' || s[s.len() as int - 1] == '\r' {
        strip_whitespace(s.subrange(0, s.len() as int - 1))
    } else { 
        s 
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires input@.len() > 0
    ensures ({
        let processed_input = trim_newline(input@);
        let stripped = strip_whitespace(processed_input);
        if is_valid_password(stripped) {
            output@ == seq!['C', 'o', 'r', 'r', 'e', 'c', 't', '\n']
        } else {
            output@ == seq!['T', 'o', 'o', ' ', 'w', 'e', 'a', 'k', '\n']
        }
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn contains_lowercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'a' <= s[i] && s[i] <= 'z'\n}\n\nspec fn contains_uppercase(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && 'A' <= s[i] && s[i] <= 'Z'\n}\n\nspec fn contains_digit(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_password(s: Seq<char>) -> bool {\n    s.len() >= 5 && contains_lowercase(s) && contains_uppercase(s) && contains_digit(s)\n}\n\nspec fn trim_newline(s: Seq<char>) -> Seq<char> {\n    if s.len() > 0 && s[s.len() as int - 1] == '\\n' { \n        s.subrange(0, s.len() as int - 1) \n    } else { \n        s \n    }\n}\n\nspec fn strip_whitespace(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        s\n    } else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' {\n        strip_whitespace(s.subrange(1, s.len() as int))\n    } else if s[s.len() as int - 1] == ' ' || s[s.len() as int - 1] == '\\t' || s[s.len() as int - 1] == '\\n' || s[s.len() as int - 1] == '\\r' {\n        strip_whitespace(s.subrange(0, s.len() as int - 1))\n    } else { \n        s \n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires input@.len() > 0\n    ensures ({\n        let processed_input = trim_newline(input@);\n        let stripped = strip_whitespace(processed_input);\n        if is_valid_password(stripped) {\n            output@ == seq!['C', 'o', 'r', 'r', 'e', 'c', 't', '\\n']\n        } else {\n            output@ == seq!['T', 'o', 'o', ' ', 'w', 'e', 'a', 'k', '\\n']\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1711.rs,52,52,1.0,92.168,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int) -> bool {
    n >= 2 && m >= 1 && n <= m && m <= 200000
}

spec fn combination(n: int, k: int, modulus: int) -> int {
    0  /* placeholder - actual combinatorial calculation */
}

spec fn power(base: int, exp: int, modulus: int) -> int {
    0  /* placeholder - actual modular exponentiation */
}

spec fn expected_result(n: int, m: int) -> int {
    if n == 2 {
        0
    } else {
        (((combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * power(2, n - 3, 998244353)) % 998244353
    }
}

spec fn valid_output(result: int) -> bool {
    0 <= result < 998244353
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int)
    ensures 
        valid_output(result as int),
        result as int == expected_result(n as int, m as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int) -> bool {
    n >= 2 && m >= 1 && n <= m && m <= 200000
}

spec fn combination(n: int, k: int, modulus: int) -> int {
    0  /* placeholder - actual combinatorial calculation */
}

spec fn power(base: int, exp: int, modulus: int) -> int {
    0  /* placeholder - actual modular exponentiation */
}

spec fn expected_result(n: int, m: int) -> int {
    if n == 2 {
        0
    } else {
        (((combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * power(2, n - 3, 998244353)) % 998244353
    }
}

spec fn valid_output(result: int) -> bool {
    0 <= result < 998244353
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int)
    ensures 
        valid_output(result as int),
        result as int == expected_result(n as int, m as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    n >= 2 && m >= 1 && n <= m && m <= 200000\n}\n\nspec fn combination(n: int, k: int, modulus: int) -> int {\n    0  /* placeholder - actual combinatorial calculation */\n}\n\nspec fn power(base: int, exp: int, modulus: int) -> int {\n    0  /* placeholder - actual modular exponentiation */\n}\n\nspec fn expected_result(n: int, m: int) -> int {\n    if n == 2 {\n        0\n    } else {\n        (((combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * power(2, n - 3, 998244353)) % 998244353\n    }\n}\n\nspec fn valid_output(result: int) -> bool {\n    0 <= result < 998244353\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        valid_output(result as int),\n        result as int == expected_result(n as int, m as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1712.rs,54,54,1.0,123.34,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {
    n >= 0 && a > 0 && b > 0 && mobs.len() == n &&
    forall|i: int| 0 <= i < n ==> #[trigger] mobs[i] >= 0
}

spec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {
    result.len() == n &&
    forall|i: int| 0 <= i < n ==> 
        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a']) || 
        (result[i]@ =~= seq!['V', 'o', 'v', 'a']) || 
        (result[i]@ =~= seq!['B', 'o', 't', 'h'])
}

spec fn determine_winner(k: int, a: int, b: int) -> int {
    if k <= a { 0 } else { 1 }
}

spec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool
    recommends a > 0 && b > 0 && mobs.len() == n
{
    valid_output(result, n) &&
    forall|i: int| 0 <= i < n ==> {
        let total = a + b;
        let k = if mobs[i] == 0 { 0 } else { mobs[i] % total };
        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a'] <==> determine_winner(k, a, b) == 0) &&
        (result[i]@ =~= seq!['V', 'o', 'v', 'a'] <==> determine_winner(k, a, b) == 1) &&
        (result[i]@ =~= seq!['B', 'o', 't', 'h'] <==> determine_winner(k, a, b) == 2)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, mobs: Vec<i8>) -> (result: Vec<Vec<char>>)
    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))
    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {
    n >= 0 && a > 0 && b > 0 && mobs.len() == n &&
    forall|i: int| 0 <= i < n ==> #[trigger] mobs[i] >= 0
}

spec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {
    result.len() == n &&
    forall|i: int| 0 <= i < n ==> 
        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a']) || 
        (result[i]@ =~= seq!['V', 'o', 'v', 'a']) || 
        (result[i]@ =~= seq!['B', 'o', 't', 'h'])
}

spec fn determine_winner(k: int, a: int, b: int) -> int {
    if k <= a { 0 } else { 1 }
}

spec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool
    recommends a > 0 && b > 0 && mobs.len() == n
{
    valid_output(result, n) &&
    forall|i: int| 0 <= i < n ==> {
        let total = a + b;
        let k = if mobs[i] == 0 { 0 } else { mobs[i] % total };
        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a'] <==> determine_winner(k, a, b) == 0) &&
        (result[i]@ =~= seq!['V', 'o', 'v', 'a'] <==> determine_winner(k, a, b) == 1) &&
        (result[i]@ =~= seq!['B', 'o', 't', 'h'] <==> determine_winner(k, a, b) == 2)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, mobs: Vec<i8>) -> (result: Vec<Vec<char>>)
    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))
    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {\n    n >= 0 && a > 0 && b > 0 && mobs.len() == n &&\n    forall|i: int| 0 <= i < n ==> #[trigger] mobs[i] >= 0\n}\n\nspec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < n ==> \n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a']) || \n        (result[i]@ =~= seq!['V', 'o', 'v', 'a']) || \n        (result[i]@ =~= seq!['B', 'o', 't', 'h'])\n}\n\nspec fn determine_winner(k: int, a: int, b: int) -> int {\n    if k <= a { 0 } else { 1 }\n}\n\nspec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool\n    recommends a > 0 && b > 0 && mobs.len() == n\n{\n    valid_output(result, n) &&\n    forall|i: int| 0 <= i < n ==> {\n        let total = a + b;\n        let k = if mobs[i] == 0 { 0 } else { mobs[i] % total };\n        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a'] <==> determine_winner(k, a, b) == 0) &&\n        (result[i]@ =~= seq!['V', 'o', 'v', 'a'] <==> determine_winner(k, a, b) == 1) &&\n        (result[i]@ =~= seq!['B', 'o', 't', 'h'] <==> determine_winner(k, a, b) == 2)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, mobs: Vec<i8>) -> (result: Vec<Vec<char>>)\n    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n              fn main() {\n    }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1723.rs,61,61,1.0,123.366,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_output(n: int, result: Seq<String>) -> bool
    recommends n >= 2
{
    if n < 6 {
        result.len() == 1 + (n - 1) &&
        result[0]@ == seq!['-', '1'] &&
        (forall|i: int| #![auto] 1 <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 1))
    } else {
        result.len() == (5 + (n - 6)) + (n - 1) &&
        result[0]@ == seq!['1', ' ', '2'] && 
        result[1]@ == seq!['1', ' ', '3'] && 
        result[2]@ == seq!['1', ' ', '4'] && 
        result[3]@ == seq!['2', ' ', '5'] && 
        result[4]@ == seq!['2', ' ', '6'] &&
        (forall|i: int| #![auto] 5 <= i < 5 + (n - 6) ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 2)) &&
        (forall|i: int| #![auto] 5 + (n - 6) <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i - (5 + (n - 6)) + 2))
    }
}

spec fn int_to_string_pos(n: nat) -> Seq<char>
    decreases n
{
    if n < 10 {
        seq![(n + ('0' as nat)) as char]
    } else {
        int_to_string_pos(n / 10) + int_to_string_pos(n % 10)
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n < 0 {
        seq!['-'] + int_to_string_pos((-n) as nat)
    } else {
        int_to_string_pos(n as nat)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: Vec<String>)
    requires n as int >= 2
    ensures valid_output(n as int, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_output(n: int, result: Seq<String>) -> bool
    recommends n >= 2
{
    if n < 6 {
        result.len() == 1 + (n - 1) &&
        result[0]@ == seq!['-', '1'] &&
        (forall|i: int| #![auto] 1 <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 1))
    } else {
        result.len() == (5 + (n - 6)) + (n - 1) &&
        result[0]@ == seq!['1', ' ', '2'] && 
        result[1]@ == seq!['1', ' ', '3'] && 
        result[2]@ == seq!['1', ' ', '4'] && 
        result[3]@ == seq!['2', ' ', '5'] && 
        result[4]@ == seq!['2', ' ', '6'] &&
        (forall|i: int| #![auto] 5 <= i < 5 + (n - 6) ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 2)) &&
        (forall|i: int| #![auto] 5 + (n - 6) <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i - (5 + (n - 6)) + 2))
    }
}

spec fn int_to_string_pos(n: nat) -> Seq<char>
    decreases n
{
    if n < 10 {
        seq![(n + ('0' as nat)) as char]
    } else {
        int_to_string_pos(n / 10) + int_to_string_pos(n % 10)
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n < 0 {
        seq!['-'] + int_to_string_pos((-n) as nat)
    } else {
        int_to_string_pos(n as nat)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: Vec<String>)
    requires n as int >= 2
    ensures valid_output(n as int, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_output(n: int, result: Seq<String>) -> bool\n    recommends n >= 2\n{\n    if n < 6 {\n        result.len() == 1 + (n - 1) &&\n        result[0]@ == seq!['-', '1'] &&\n        (forall|i: int| #![auto] 1 <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 1))\n    } else {\n        result.len() == (5 + (n - 6)) + (n - 1) &&\n        result[0]@ == seq!['1', ' ', '2'] && \n        result[1]@ == seq!['1', ' ', '3'] && \n        result[2]@ == seq!['1', ' ', '4'] && \n        result[3]@ == seq!['2', ' ', '5'] && \n        result[4]@ == seq!['2', ' ', '6'] &&\n        (forall|i: int| #![auto] 5 <= i < 5 + (n - 6) ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 2)) &&\n        (forall|i: int| #![auto] 5 + (n - 6) <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i - (5 + (n - 6)) + 2))\n    }\n}\n\nspec fn int_to_string_pos(n: nat) -> Seq<char>\n    decreases n\n{\n    if n < 10 {\n        seq![(n + ('0' as nat)) as char]\n    } else {\n        int_to_string_pos(n / 10) + int_to_string_pos(n % 10)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n < 0 {\n        seq!['-'] + int_to_string_pos((-n) as nat)\n    } else {\n        int_to_string_pos(n as nat)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<String>)\n    requires n as int >= 2\n    ensures valid_output(n as int, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n                fn main() {\n      }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1725.rs,137,25,0.18248175182481752,184.568,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool {
    n > 0 && m > 0 && d > 0 &&
    matrix.len() == n &&
    (forall|i: int| #![auto] 0 <= i < n ==> matrix[i].len() == m) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> matrix[i][j] > 0)
}

spec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool
    recommends valid_input(matrix.len() as int, if matrix.len() > 0 { matrix[0].len() as int } else { 0 }, d, matrix)
{
    forall|i: int, j: int, k: int, l: int| 
        0 <= i < matrix.len() && 0 <= j < matrix[0].len() && 
        0 <= k < matrix.len() && 0 <= l < matrix[0].len() ==>
        matrix[i][j] % d == matrix[k][l] % d
}

spec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>
    decreases matrix.len()
{
    if matrix.len() == 0 {
        seq![]
    } else {
        matrix[0].add(flatten(matrix.subrange(1, matrix.len() as int)))
    }
}

spec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>
    recommends d > 0
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        seq![s[0] / d].add(divide_sequence_by_d(s.subrange(1, s.len() as int), d))
    }
}

spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        (if s[0] >= target { s[0] - target } else { target - s[0] }) + 
        sum_abs_differences_from_target(s.subrange(1, s.len() as int), target)
    }
}

spec fn seq_min(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
{
    if s.len() == 1 {
        s[0]
    } else if s.len() == 0 {
        0
    } else {
        let rest_min = seq_min(s.subrange(1, s.len() as int));
        if s[0] <= rest_min { s[0] } else { rest_min }
    }
}

spec fn seq_max(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
{
    if s.len() == 1 {
        s[0]
    } else if s.len() == 0 {
        0
    } else {
        let rest_max = seq_max(s.subrange(1, s.len() as int));
        if s[0] >= rest_max { s[0] } else { rest_max }
    }
}

spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int
    recommends simplified.len() > 0
    decreases max_val - min_val
{
    if min_val >= max_val {
        sum_abs_differences_from_target(simplified, min_val)
    } else {
        let mid = (min_val + max_val) / 2;
        let mid_ops = sum_abs_differences_from_target(simplified, mid);
        let left_ops = if mid > min_val { min_ops_in_range(simplified, min_val, mid - 1) } else { mid_ops };
        let right_ops = if mid < max_val { min_ops_in_range(simplified, mid + 1, max_val) } else { mid_ops };
        if mid_ops <= left_ops && mid_ops <= right_ops {
            mid_ops
        } else if left_ops <= right_ops {
            left_ops
        } else {
            right_ops
        }
    }
}

spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int
    recommends simplified.len() > 0
{
    let min_val = seq_min(simplified);
    let max_val = seq_max(simplified);
    min_ops_in_range(simplified, min_val, max_val)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)
    requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))
    ensures 
        result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),
        result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),
        result >= 0 ==> {
            let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));
            let simplified = divide_sequence_by_d(flat, d as int);
            result as int == minimum_operations_to_make_equal(simplified)
        }
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool ;
       spec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool     recommends valid_input(matrix.len() as int, if matrix.len() > 0 {
      matrix[0].len() as int }
       else {
      0 }
      , d, matrix) ;
       spec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>     decreases matrix.len() ;
       spec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>     recommends d > 0     decreases s.len() ;
       spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int     decreases s.len() ;
       spec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;
       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;
       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;
       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;
       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {
                  let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));
                  let simplified = divide_sequence_by_d(flat, d as int);
                  result as int == minimum_operations_to_make_equal(simplified)         }
       {
          assume(false);
          unreached() }
       }
        fn main() {
      }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool {\n    n > 0 && m > 0 && d > 0 &&\n    matrix.len() == n &&\n    (forall|i: int| #![auto] 0 <= i < n ==> matrix[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> matrix[i][j] > 0)\n}\n\nspec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool\n    recommends valid_input(matrix.len() as int, if matrix.len() > 0 { matrix[0].len() as int } else { 0 }, d, matrix)\n{\n    forall|i: int, j: int, k: int, l: int| \n        0 <= i < matrix.len() && 0 <= j < matrix[0].len() && \n        0 <= k < matrix.len() && 0 <= l < matrix[0].len() ==>\n        matrix[i][j] % d == matrix[k][l] % d\n}\n\nspec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>\n    decreases matrix.len()\n{\n    if matrix.len() == 0 {\n        seq![]\n    } else {\n        matrix[0].add(flatten(matrix.subrange(1, matrix.len() as int)))\n    }\n}\n\nspec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>\n    recommends d > 0\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![s[0] / d].add(divide_sequence_by_d(s.subrange(1, s.len() as int), d))\n    }\n}\n\nspec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if s[0] >= target { s[0] - target } else { target - s[0] }) + \n        sum_abs_differences_from_target(s.subrange(1, s.len() as int), target)\n    }\n}\n\nspec fn seq_min(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() == 0 {\n        0\n    } else {\n        let rest_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= rest_min { s[0] } else { rest_min }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() == 0 {\n        0\n    } else {\n        let rest_max = seq_max(s.subrange(1, s.len() as int));\n        if s[0] >= rest_max { s[0] } else { rest_max }\n    }\n}\n\nspec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int\n    recommends simplified.len() > 0\n    decreases max_val - min_val\n{\n    if min_val >= max_val {\n        sum_abs_differences_from_target(simplified, min_val)\n    } else {\n        let mid = (min_val + max_val) / 2;\n        let mid_ops = sum_abs_differences_from_target(simplified, mid);\n        let left_ops = if mid > min_val { min_ops_in_range(simplified, min_val, mid - 1) } else { mid_ops };\n        let right_ops = if mid < max_val { min_ops_in_range(simplified, mid + 1, max_val) } else { mid_ops };\n        if mid_ops <= left_ops && mid_ops <= right_ops {\n            mid_ops\n        } else if left_ops <= right_ops {\n            left_ops\n        } else {\n            right_ops\n        }\n    }\n}\n\nspec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int\n    recommends simplified.len() > 0\n{\n    let min_val = seq_min(simplified);\n    let max_val = seq_max(simplified);\n    min_ops_in_range(simplified, min_val, max_val)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures \n        result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),\n        result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),\n        result >= 0 ==> {\n            let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));\n            let simplified = divide_sequence_by_d(flat, d as int);\n            result as int == minimum_operations_to_make_equal(simplified)\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool ;\n       spec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool     recommends valid_input(matrix.len() as int, if matrix.len() > 0 {\n      matrix[0].len() as int }\n       else {\n      0 }\n      , d, matrix) ;\n       spec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>     decreases matrix.len() ;\n       spec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>     recommends d > 0     decreases s.len() ;\n       spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int     decreases s.len() ;\n       spec fn seq_min(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn seq_max(s: Seq<int>) -> int     recommends s.len() > 0     decreases s.len() ;\n       spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int     recommends simplified.len() > 0     decreases max_val - min_val ;\n       spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int     recommends simplified.len() > 0 ;\n       fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)     requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))     ensures          result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),         result >= 0 ==> {\n                  let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));\n                  let simplified = divide_sequence_by_d(flat, d as int);\n                  result as int == minimum_operations_to_make_equal(simplified)         }\n       {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n         verus! {}\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1735.rs,56,56,1.0,122.331,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_max_moves(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        let stack: Seq<char> = seq![];
        let moves: nat = 0;
        count_max_moves_helper(s, 0, stack, moves)
    }
}

spec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat
    decreases s.len() - i
{
    if i <= s.len() {
        if i == s.len() {
            moves
        } else if stack.len() > 0 && s[i as int] == stack[stack.len() as int - 1] {
            count_max_moves_helper(s, i + 1, stack.subrange(0, stack.len() as int - 1), moves + 1)
        } else {
            count_max_moves_helper(s, i + 1, stack.push(s[i as int]), moves)
        }
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: &'static str)
    requires s.len() >= 1
    ensures
        result == ""Yes"" || result == ""No"",
        result == ""Yes"" <==> count_max_moves(s@) % 2 == 1,
        result == ""No"" <==> count_max_moves(s@) % 2 == 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No""
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_max_moves(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        let stack: Seq<char> = seq![];
        let moves: nat = 0;
        count_max_moves_helper(s, 0, stack, moves)
    }
}

spec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat
    decreases s.len() - i
{
    if i <= s.len() {
        if i == s.len() {
            moves
        } else if stack.len() > 0 && s[i as int] == stack[stack.len() as int - 1] {
            count_max_moves_helper(s, i + 1, stack.subrange(0, stack.len() as int - 1), moves + 1)
        } else {
            count_max_moves_helper(s, i + 1, stack.push(s[i as int]), moves)
        }
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: &'static str)
    requires s.len() >= 1
    ensures
        result == ""Yes"" || result == ""No"",
        result == ""Yes"" <==> count_max_moves(s@) % 2 == 1,
        result == ""No"" <==> count_max_moves(s@) % 2 == 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No""
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_max_moves(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let stack: Seq<char> = seq![];\n        let moves: nat = 0;\n        count_max_moves_helper(s, 0, stack, moves)\n    }\n}\n\nspec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat\n    decreases s.len() - i\n{\n    if i <= s.len() {\n        if i == s.len() {\n            moves\n        } else if stack.len() > 0 && s[i as int] == stack[stack.len() as int - 1] {\n            count_max_moves_helper(s, i + 1, stack.subrange(0, stack.len() as int - 1), moves + 1)\n        } else {\n            count_max_moves_helper(s, i + 1, stack.push(s[i as int]), moves)\n        }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: &\'static str)\n    requires s.len() >= 1\n    ensures\n        result == ""Yes"" || result == ""No"",\n        result == ""Yes"" <==> count_max_moves(s@) % 2 == 1,\n        result == ""No"" <==> count_max_moves(s@) % 2 == 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""No""\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1746.rs,52,52,1.0,122.441,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn has_children(node: int, parents: Seq<int>, n: int) -> bool
    recommends 0 <= node < n, n >= 3, parents.len() == n - 1
{
    exists|i: int| 0 <= i < n - 1 && parents[i] - 1 == node
}

spec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int
    recommends 0 <= node < n, n >= 3, parents.len() == n - 1
{
    (Set::new(|i: int| 0 <= i < n - 1 && parents[i] - 1 == node && !has_children(i + 1, parents, n))).len() as int
}

spec fn valid_input(n: int, parents: Seq<int>) -> bool
{
    n >= 3 && parents.len() == n - 1 && 
    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] parents[i] >= 1 && parents[i] <= i + 1)
}

spec fn is_spruce(n: int, parents: Seq<int>) -> bool
    recommends valid_input(n, parents)
{
    forall|node: int| 0 <= node < n && has_children(node, parents, n) ==> 
        count_leaf_children(node, parents, n) >= 3
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, parents: Vec<i8>) -> (result: String)
    requires 
        valid_input(n as int, parents@.map_values(|x: i8| x as int)),
    ensures 
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],
        result@ == seq!['Y', 'e', 's'] <==> is_spruce(n as int, parents@.map_values(|x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn has_children(node: int, parents: Seq<int>, n: int) -> bool
    recommends 0 <= node < n, n >= 3, parents.len() == n - 1
{
    exists|i: int| 0 <= i < n - 1 && parents[i] - 1 == node
}

spec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int
    recommends 0 <= node < n, n >= 3, parents.len() == n - 1
{
    (Set::new(|i: int| 0 <= i < n - 1 && parents[i] - 1 == node && !has_children(i + 1, parents, n))).len() as int
}

spec fn valid_input(n: int, parents: Seq<int>) -> bool
{
    n >= 3 && parents.len() == n - 1 && 
    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] parents[i] >= 1 && parents[i] <= i + 1)
}

spec fn is_spruce(n: int, parents: Seq<int>) -> bool
    recommends valid_input(n, parents)
{
    forall|node: int| 0 <= node < n && has_children(node, parents, n) ==> 
        count_leaf_children(node, parents, n) >= 3
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, parents: Vec<i8>) -> (result: String)
    requires 
        valid_input(n as int, parents@.map_values(|x: i8| x as int)),
    ensures 
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],
        result@ == seq!['Y', 'e', 's'] <==> is_spruce(n as int, parents@.map_values(|x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn has_children(node: int, parents: Seq<int>, n: int) -> bool\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    exists|i: int| 0 <= i < n - 1 && parents[i] - 1 == node\n}\n\nspec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int\n    recommends 0 <= node < n, n >= 3, parents.len() == n - 1\n{\n    (Set::new(|i: int| 0 <= i < n - 1 && parents[i] - 1 == node && !has_children(i + 1, parents, n))).len() as int\n}\n\nspec fn valid_input(n: int, parents: Seq<int>) -> bool\n{\n    n >= 3 && parents.len() == n - 1 && \n    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] parents[i] >= 1 && parents[i] <= i + 1)\n}\n\nspec fn is_spruce(n: int, parents: Seq<int>) -> bool\n    recommends valid_input(n, parents)\n{\n    forall|node: int| 0 <= node < n && has_children(node, parents, n) ==> \n        count_leaf_children(node, parents, n) >= 3\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, parents: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, parents@.map_values(|x: i8| x as int)),\n    ensures \n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        result@ == seq!['Y', 'e', 's'] <==> is_spruce(n as int, parents@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1761.rs,80,80,1.0,122.432,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {
    0  /* placeholder for uninterpreted function */
}

spec fn valid_input(input: Seq<Seq<char>>) -> bool {
    input.len() >= 2 &&
    {
        let n = parse_int_helper(input[0], 0, 0);
        n >= 1 && n + 1 < input.len()
    }
}

spec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>
    decreases words.len()
{
    if words.len() == 0 {
        seq!['<', '3']
    } else {
        seq!['<', '3'] + words[0] + build_expected_pattern(words.subrange(1, words.len() as int))
    }
}

spec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {
    is_subsequence_helper(pattern, text, 0, 0)
}

spec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool
    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()
{
    if pattern_index <= pattern.len() && text_index <= text.len() {
        if pattern_index == pattern.len() {
            true
        } else if text_index == text.len() {
            false
        } else if pattern[pattern_index as int] == text[text_index as int] {
            is_subsequence_helper(pattern, text, (pattern_index + 1) as nat, (text_index + 1) as nat)
        } else {
            is_subsequence_helper(pattern, text, pattern_index, (text_index + 1) as nat)
        }
    } else {
        false
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)
    requires 
        input.len() >= 2,
        valid_input(input@.map(|i, v: Vec<char>| v@))
    ensures 
        result@ == seq!['y', 'e', 's'] || result@ == seq!['n', 'o'],
        result@ == seq!['y', 'e', 's'] <==> {
            valid_input(input@.map(|i, v: Vec<char>| v@)) && {
                let n = parse_int_helper(input@.map(|i, v: Vec<char>| v@)[0], 0, 0);
                let expected = build_expected_pattern(input@.map(|i, v: Vec<char>| v@).subrange(1, n + 1));
                let message = input@.map(|i, v: Vec<char>| v@)[n + 1];
                is_subsequence(expected, message)
            }
        }
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {
    0  /* placeholder for uninterpreted function */
}

spec fn valid_input(input: Seq<Seq<char>>) -> bool {
    input.len() >= 2 &&
    {
        let n = parse_int_helper(input[0], 0, 0);
        n >= 1 && n + 1 < input.len()
    }
}

spec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>
    decreases words.len()
{
    if words.len() == 0 {
        seq!['<', '3']
    } else {
        seq!['<', '3'] + words[0] + build_expected_pattern(words.subrange(1, words.len() as int))
    }
}

spec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {
    is_subsequence_helper(pattern, text, 0, 0)
}

spec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool
    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()
{
    if pattern_index <= pattern.len() && text_index <= text.len() {
        if pattern_index == pattern.len() {
            true
        } else if text_index == text.len() {
            false
        } else if pattern[pattern_index as int] == text[text_index as int] {
            is_subsequence_helper(pattern, text, (pattern_index + 1) as nat, (text_index + 1) as nat)
        } else {
            is_subsequence_helper(pattern, text, pattern_index, (text_index + 1) as nat)
        }
    } else {
        false
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)
    requires 
        input.len() >= 2,
        valid_input(input@.map(|i, v: Vec<char>| v@))
    ensures 
        result@ == seq!['y', 'e', 's'] || result@ == seq!['n', 'o'],
        result@ == seq!['y', 'e', 's'] <==> {
            valid_input(input@.map(|i, v: Vec<char>| v@)) && {
                let n = parse_int_helper(input@.map(|i, v: Vec<char>| v@)[0], 0, 0);
                let expected = build_expected_pattern(input@.map(|i, v: Vec<char>| v@).subrange(1, n + 1));
                let message = input@.map(|i, v: Vec<char>| v@)[n + 1];
                is_subsequence(expected, message)
            }
        }
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {\n    0  /* placeholder for uninterpreted function */\n}\n\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 2 &&\n    {\n        let n = parse_int_helper(input[0], 0, 0);\n        n >= 1 && n + 1 < input.len()\n    }\n}\n\nspec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>\n    decreases words.len()\n{\n    if words.len() == 0 {\n        seq!['<', '3']\n    } else {\n        seq!['<', '3'] + words[0] + build_expected_pattern(words.subrange(1, words.len() as int))\n    }\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool\n    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()\n{\n    if pattern_index <= pattern.len() && text_index <= text.len() {\n        if pattern_index == pattern.len() {\n            true\n        } else if text_index == text.len() {\n            false\n        } else if pattern[pattern_index as int] == text[text_index as int] {\n            is_subsequence_helper(pattern, text, (pattern_index + 1) as nat, (text_index + 1) as nat)\n        } else {\n            is_subsequence_helper(pattern, text, pattern_index, (text_index + 1) as nat)\n        }\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires \n        input.len() >= 2,\n        valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures \n        result@ == seq!['y', 'e', 's'] || result@ == seq!['n', 'o'],\n        result@ == seq!['y', 'e', 's'] <==> {\n            valid_input(input@.map(|i, v: Vec<char>| v@)) && {\n                let n = parse_int_helper(input@.map(|i, v: Vec<char>| v@)[0], 0, 0);\n                let expected = build_expected_pattern(input@.map(|i, v: Vec<char>| v@).subrange(1, n + 1));\n                let message = input@.map(|i, v: Vec<char>| v@)[n + 1];\n                is_subsequence(expected, message)\n            }\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1766.rs,64,64,1.0,122.701,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(cards: Seq<int>) -> bool {
    cards.len() >= 1 &&
    (forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0) &&
    (forall|i: int, j: int| 0 <= i < j < cards.len() ==> cards[i] != cards[j])
}

spec fn sum(cards: Seq<int>) -> int 
    decreases cards.len()
{
    if cards.len() == 0 { 
        0 
    } else { 
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int
    decreases right - left + 1
    when 0 <= left <= right < cards.len()
{
    if left == right {
        if sereja_turn { cards[left] } else { 0 }
    } else if cards[left] > cards[right] {
        (if sereja_turn { cards[left] } else { 0 }) + sereja_optimal_score(cards, left+1, right, !sereja_turn)
    } else {
        (if sereja_turn { cards[right] } else { 0 }) + sereja_optimal_score(cards, left, right-1, !sereja_turn)
    }
}

spec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {
    valid_input(cards) ==>
    scores.len() == 2 &&
    scores[0] >= 0 && scores[1] >= 0 &&
    scores[0] + scores[1] == sum(cards) &&
    scores[0] == sereja_optimal_score(cards, 0, cards.len()-1, true) &&
    scores[1] == sum(cards) - sereja_optimal_score(cards, 0, cards.len()-1, true)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(cards: Vec<i8>) -> (scores: Vec<i8>)
    requires valid_input(cards@.map(|i, x| x as int))
    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(cards: Seq<int>) -> bool {
    cards.len() >= 1 &&
    (forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0) &&
    (forall|i: int, j: int| 0 <= i < j < cards.len() ==> cards[i] != cards[j])
}

spec fn sum(cards: Seq<int>) -> int 
    decreases cards.len()
{
    if cards.len() == 0 { 
        0 
    } else { 
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int
    decreases right - left + 1
    when 0 <= left <= right < cards.len()
{
    if left == right {
        if sereja_turn { cards[left] } else { 0 }
    } else if cards[left] > cards[right] {
        (if sereja_turn { cards[left] } else { 0 }) + sereja_optimal_score(cards, left+1, right, !sereja_turn)
    } else {
        (if sereja_turn { cards[right] } else { 0 }) + sereja_optimal_score(cards, left, right-1, !sereja_turn)
    }
}

spec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {
    valid_input(cards) ==>
    scores.len() == 2 &&
    scores[0] >= 0 && scores[1] >= 0 &&
    scores[0] + scores[1] == sum(cards) &&
    scores[0] == sereja_optimal_score(cards, 0, cards.len()-1, true) &&
    scores[1] == sum(cards) - sereja_optimal_score(cards, 0, cards.len()-1, true)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(cards: Vec<i8>) -> (scores: Vec<i8>)
    requires valid_input(cards@.map(|i, x| x as int))
    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() >= 1 &&\n    (forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0) &&\n    (forall|i: int, j: int| 0 <= i < j < cards.len() ==> cards[i] != cards[j])\n}\n\nspec fn sum(cards: Seq<int>) -> int \n    decreases cards.len()\n{\n    if cards.len() == 0 { \n        0 \n    } else { \n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int\n    decreases right - left + 1\n    when 0 <= left <= right < cards.len()\n{\n    if left == right {\n        if sereja_turn { cards[left] } else { 0 }\n    } else if cards[left] > cards[right] {\n        (if sereja_turn { cards[left] } else { 0 }) + sereja_optimal_score(cards, left+1, right, !sereja_turn)\n    } else {\n        (if sereja_turn { cards[right] } else { 0 }) + sereja_optimal_score(cards, left, right-1, !sereja_turn)\n    }\n}\n\nspec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {\n    valid_input(cards) ==>\n    scores.len() == 2 &&\n    scores[0] >= 0 && scores[1] >= 0 &&\n    scores[0] + scores[1] == sum(cards) &&\n    scores[0] == sereja_optimal_score(cards, 0, cards.len()-1, true) &&\n    scores[1] == sum(cards) - sereja_optimal_score(cards, 0, cards.len()-1, true)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>) -> (scores: Vec<i8>)\n    requires valid_input(cards@.map(|i, x| x as int))\n    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1795.rs,57,57,1.0,122.575,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, f: Seq<int>) -> bool {
    n >= 2 && n <= 5000 &&
    f.len() == n &&
    forall|i: int| 0 <= i < f.len() ==> 1 <= f[i] <= n && f[i] != i + 1
}

spec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>
    recommends valid_input(n, f)
{
    Seq::new(n as nat, |j: int| f[j] - 1)
}

spec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool
    recommends 
        a.len() == n &&
        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n
{
    exists|i: int| 0 <= i < n && 
        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i
}

spec fn has_love_triangle(n: int, f: Seq<int>) -> bool
    recommends valid_input(n, f)
{
    let a = zero_indexed_array(n, f);
    has_love_triangle_with(n, a)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, f: Vec<i8>) -> (result: String)
    requires 
        valid_input(n as int, f@.map(|i: int, x: i8| x as int)),
    ensures 
        result@.len() == 2 || result@.len() == 3,
        (result@.len() == 3) <==> has_love_triangle(n as int, f@.map(|i: int, x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, f: Seq<int>) -> bool {
    n >= 2 && n <= 5000 &&
    f.len() == n &&
    forall|i: int| 0 <= i < f.len() ==> 1 <= f[i] <= n && f[i] != i + 1
}

spec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>
    recommends valid_input(n, f)
{
    Seq::new(n as nat, |j: int| f[j] - 1)
}

spec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool
    recommends 
        a.len() == n &&
        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n
{
    exists|i: int| 0 <= i < n && 
        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i
}

spec fn has_love_triangle(n: int, f: Seq<int>) -> bool
    recommends valid_input(n, f)
{
    let a = zero_indexed_array(n, f);
    has_love_triangle_with(n, a)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, f: Vec<i8>) -> (result: String)
    requires 
        valid_input(n as int, f@.map(|i: int, x: i8| x as int)),
    ensures 
        result@.len() == 2 || result@.len() == 3,
        (result@.len() == 3) <==> has_love_triangle(n as int, f@.map(|i: int, x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, f: Seq<int>) -> bool {\n    n >= 2 && n <= 5000 &&\n    f.len() == n &&\n    forall|i: int| 0 <= i < f.len() ==> 1 <= f[i] <= n && f[i] != i + 1\n}\n\nspec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>\n    recommends valid_input(n, f)\n{\n    Seq::new(n as nat, |j: int| f[j] - 1)\n}\n\nspec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool\n    recommends \n        a.len() == n &&\n        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n\n{\n    exists|i: int| 0 <= i < n && \n        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i\n}\n\nspec fn has_love_triangle(n: int, f: Seq<int>) -> bool\n    recommends valid_input(n, f)\n{\n    let a = zero_indexed_array(n, f);\n    has_love_triangle_with(n, a)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, f: Vec<i8>) -> (result: String)\n    requires \n        valid_input(n as int, f@.map(|i: int, x: i8| x as int)),\n    ensures \n        result@.len() == 2 || result@.len() == 3,\n        (result@.len() == 3) <==> has_love_triangle(n as int, f@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1797.rs,81,81,1.0,122.654,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, p: Seq<int>) -> bool {
  n > 0 && p.len() == n &&
  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&
  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn count_true(visited: Seq<bool>) -> int
  decreases visited.len()
{
  if visited.len() == 0 { 0int }
  else { (if visited[0] { 1int } else { 0int }) + count_true(visited.subrange(1, visited.len() as int)) }
}

spec fn sum_of_squares(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0int } else { s[0] * s[0] + sum_of_squares(s.subrange(1, s.len() as int)) }
}

spec fn find_unvisited(visited: Seq<bool>) -> int {
  0int  /* placeholder */
}

spec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {
  1int  /* placeholder */
}

spec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {
  visited  /* placeholder */
}

spec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {
  get_cycles_helper(n, p, Seq::new(n as nat, |i: int| false), Seq::empty())
}

spec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>
  decreases n - count_true(visited)
{
  if count_true(visited) >= n { cycles }
  else {
    let unvisited = find_unvisited(visited);
    if unvisited == -1int { cycles }
    else if 0 <= unvisited < n {
      let cycle_length = get_cycle_length(p, visited, unvisited);
      let new_visited = mark_cycle_visited(p, visited, unvisited);
      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n {
        get_cycles_helper(n, p, new_visited, cycles.push(cycle_length))
      } else {
        cycles.push(cycle_length)
      }
    } else {
      cycles
    }
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))
  ensures result > 0
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, p: Seq<int>) -> bool {
  n > 0 && p.len() == n &&
  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&
  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn count_true(visited: Seq<bool>) -> int
  decreases visited.len()
{
  if visited.len() == 0 { 0int }
  else { (if visited[0] { 1int } else { 0int }) + count_true(visited.subrange(1, visited.len() as int)) }
}

spec fn sum_of_squares(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0int } else { s[0] * s[0] + sum_of_squares(s.subrange(1, s.len() as int)) }
}

spec fn find_unvisited(visited: Seq<bool>) -> int {
  0int  /* placeholder */
}

spec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {
  1int  /* placeholder */
}

spec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {
  visited  /* placeholder */
}

spec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {
  get_cycles_helper(n, p, Seq::new(n as nat, |i: int| false), Seq::empty())
}

spec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>
  decreases n - count_true(visited)
{
  if count_true(visited) >= n { cycles }
  else {
    let unvisited = find_unvisited(visited);
    if unvisited == -1int { cycles }
    else if 0 <= unvisited < n {
      let cycle_length = get_cycle_length(p, visited, unvisited);
      let new_visited = mark_cycle_visited(p, visited, unvisited);
      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n {
        get_cycles_helper(n, p, new_visited, cycles.push(cycle_length))
      } else {
        cycles.push(cycle_length)
      }
    } else {
      cycles
    }
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))
  ensures result > 0
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, p: Seq<int>) -> bool {\n  n > 0 && p.len() == n &&\n  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&\n  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn count_true(visited: Seq<bool>) -> int\n  decreases visited.len()\n{\n  if visited.len() == 0 { 0int }\n  else { (if visited[0] { 1int } else { 0int }) + count_true(visited.subrange(1, visited.len() as int)) }\n}\n\nspec fn sum_of_squares(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0int } else { s[0] * s[0] + sum_of_squares(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_unvisited(visited: Seq<bool>) -> int {\n  0int  /* placeholder */\n}\n\nspec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {\n  1int  /* placeholder */\n}\n\nspec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {\n  visited  /* placeholder */\n}\n\nspec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {\n  get_cycles_helper(n, p, Seq::new(n as nat, |i: int| false), Seq::empty())\n}\n\nspec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>\n  decreases n - count_true(visited)\n{\n  if count_true(visited) >= n { cycles }\n  else {\n    let unvisited = find_unvisited(visited);\n    if unvisited == -1int { cycles }\n    else if 0 <= unvisited < n {\n      let cycle_length = get_cycle_length(p, visited, unvisited);\n      let new_visited = mark_cycle_visited(p, visited, unvisited);\n      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n {\n        get_cycles_helper(n, p, new_visited, cycles.push(cycle_length))\n      } else {\n        cycles.push(cycle_length)\n      }\n    } else {\n      cycles\n    }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))\n  ensures result > 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_181.rs,57,57,1.0,123.17,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn normalize_angle(angle: int) -> int {
    let n = angle % 360;
    if n < 0 { n + 360 } else { n }
}

spec fn deviation_from_vertical(angle: int) -> int
    recommends 0 <= angle < 360
{
    if angle <= 180 { angle } else { 360 - angle }
}

spec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int
    recommends 0 <= rotations <= 3
{
    normalize_angle(-camera_angle + 90 * rotations)
}

spec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int
    recommends 0 <= rotations <= 3
{
    deviation_from_vertical(image_angle_after_rotations(camera_angle, rotations))
}

spec fn is_optimal_rotations(camera_angle: int, result: int) -> bool
    recommends 0 <= result <= 3
{
    forall|k: int| 0 <= k <= 3 ==> #[trigger] image_deviation_after_rotations(camera_angle, k) >= image_deviation_after_rotations(camera_angle, result) && (image_deviation_after_rotations(camera_angle, k) > image_deviation_after_rotations(camera_angle, result) || result <= k)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x: i8) -> (result: u8)
    ensures 
        0 <= result <= 3,
        is_optimal_rotations(x as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn normalize_angle(angle: int) -> int {
    let n = angle % 360;
    if n < 0 { n + 360 } else { n }
}

spec fn deviation_from_vertical(angle: int) -> int
    recommends 0 <= angle < 360
{
    if angle <= 180 { angle } else { 360 - angle }
}

spec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int
    recommends 0 <= rotations <= 3
{
    normalize_angle(-camera_angle + 90 * rotations)
}

spec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int
    recommends 0 <= rotations <= 3
{
    deviation_from_vertical(image_angle_after_rotations(camera_angle, rotations))
}

spec fn is_optimal_rotations(camera_angle: int, result: int) -> bool
    recommends 0 <= result <= 3
{
    forall|k: int| 0 <= k <= 3 ==> #[trigger] image_deviation_after_rotations(camera_angle, k) >= image_deviation_after_rotations(camera_angle, result) && (image_deviation_after_rotations(camera_angle, k) > image_deviation_after_rotations(camera_angle, result) || result <= k)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x: i8) -> (result: u8)
    ensures 
        0 <= result <= 3,
        is_optimal_rotations(x as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn normalize_angle(angle: int) -> int {\n    let n = angle % 360;\n    if n < 0 { n + 360 } else { n }\n}\n\nspec fn deviation_from_vertical(angle: int) -> int\n    recommends 0 <= angle < 360\n{\n    if angle <= 180 { angle } else { 360 - angle }\n}\n\nspec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    normalize_angle(-camera_angle + 90 * rotations)\n}\n\nspec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int\n    recommends 0 <= rotations <= 3\n{\n    deviation_from_vertical(image_angle_after_rotations(camera_angle, rotations))\n}\n\nspec fn is_optimal_rotations(camera_angle: int, result: int) -> bool\n    recommends 0 <= result <= 3\n{\n    forall|k: int| 0 <= k <= 3 ==> #[trigger] image_deviation_after_rotations(camera_angle, k) >= image_deviation_after_rotations(camera_angle, result) && (image_deviation_after_rotations(camera_angle, k) > image_deviation_after_rotations(camera_angle, result) || result <= k)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8) -> (result: u8)\n    ensures \n        0 <= result <= 3,\n        is_optimal_rotations(x as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\n fn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1826.rs,62,62,1.0,92.098,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && exists|pos: int| 0 <= pos < input.len() && input[pos] == '\n'
}

spec fn valid_move_sequence(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'U' || s[i] == 'R'
}

spec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {
    if length <= 1 {
        0
    } else {
        count_replacements_helper(s, start, length, 1, 0)
    }
}

spec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int
    decreases length - i
{
    if i >= length {
        count
    } else if start + i < s.len() && s[start + i - 1] != s[start + i] {
        if i + 2 <= length {
            count_replacements_helper(s, start, length, i + 2, count + 1)
        } else {
            count + 1
        }
    } else {
        count_replacements_helper(s, start, length, i + 1, count)
    }
}

spec fn minimized_length(original_length: int, replacements: int) -> int {
    original_length - replacements
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires valid_input(input@)
    ensures result@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && exists|pos: int| 0 <= pos < input.len() && input[pos] == '\n'
}

spec fn valid_move_sequence(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'U' || s[i] == 'R'
}

spec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {
    if length <= 1 {
        0
    } else {
        count_replacements_helper(s, start, length, 1, 0)
    }
}

spec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int
    decreases length - i
{
    if i >= length {
        count
    } else if start + i < s.len() && s[start + i - 1] != s[start + i] {
        if i + 2 <= length {
            count_replacements_helper(s, start, length, i + 2, count + 1)
        } else {
            count + 1
        }
    } else {
        count_replacements_helper(s, start, length, i + 1, count)
    }
}

spec fn minimized_length(original_length: int, replacements: int) -> int {
    original_length - replacements
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires valid_input(input@)
    ensures result@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && exists|pos: int| 0 <= pos < input.len() && input[pos] == '\\n'\n}\n\nspec fn valid_move_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == 'U' || s[i] == 'R'\n}\n\nspec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {\n    if length <= 1 {\n        0\n    } else {\n        count_replacements_helper(s, start, length, 1, 0)\n    }\n}\n\nspec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int\n    decreases length - i\n{\n    if i >= length {\n        count\n    } else if start + i < s.len() && s[start + i - 1] != s[start + i] {\n        if i + 2 <= length {\n            count_replacements_helper(s, start, length, i + 2, count + 1)\n        } else {\n            count + 1\n        }\n    } else {\n        count_replacements_helper(s, start, length, i + 1, count)\n    }\n}\n\nspec fn minimized_length(original_length: int, replacements: int) -> int {\n    original_length - replacements\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1837.rs,52,52,1.0,122.345,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    (forall|i: int| #![trigger a[i]] 0 <= i < n ==> 0 <= a[i] < n) &&
    (forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < n ==> a[i] != a[j]) &&
    (forall|k: int| #![trigger a[k]] 0 <= k < n ==> exists|i: int| 0 <= i < n && a[i] == k)
}

spec fn current_fixed_points(a: Seq<int>) -> int {
    a.len() as int
}

spec fn max_possible_fixed_points(a: Seq<int>) -> int 
    recommends valid_input(a.len() as int, a)
{
    let current = current_fixed_points(a);
    if current == a.len() {
        a.len() as int
    } else if exists|i: int| 0 <= i < a.len() && a[i] != i && a[a[i] as int] == i {
        current + 2
    } else {
        current + 1
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map(|i, x| x as int)),
    ensures 
        result as int == max_possible_fixed_points(a@.map(|i, x| x as int)),
        result >= 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    (forall|i: int| #![trigger a[i]] 0 <= i < n ==> 0 <= a[i] < n) &&
    (forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < n ==> a[i] != a[j]) &&
    (forall|k: int| #![trigger a[k]] 0 <= k < n ==> exists|i: int| 0 <= i < n && a[i] == k)
}

spec fn current_fixed_points(a: Seq<int>) -> int {
    a.len() as int
}

spec fn max_possible_fixed_points(a: Seq<int>) -> int 
    recommends valid_input(a.len() as int, a)
{
    let current = current_fixed_points(a);
    if current == a.len() {
        a.len() as int
    } else if exists|i: int| 0 <= i < a.len() && a[i] != i && a[a[i] as int] == i {
        current + 2
    } else {
        current + 1
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map(|i, x| x as int)),
    ensures 
        result as int == max_possible_fixed_points(a@.map(|i, x| x as int)),
        result >= 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| #![trigger a[i]] 0 <= i < n ==> 0 <= a[i] < n) &&\n    (forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < n ==> a[i] != a[j]) &&\n    (forall|k: int| #![trigger a[k]] 0 <= k < n ==> exists|i: int| 0 <= i < n && a[i] == k)\n}\n\nspec fn current_fixed_points(a: Seq<int>) -> int {\n    a.len() as int\n}\n\nspec fn max_possible_fixed_points(a: Seq<int>) -> int \n    recommends valid_input(a.len() as int, a)\n{\n    let current = current_fixed_points(a);\n    if current == a.len() {\n        a.len() as int\n    } else if exists|i: int| 0 <= i < a.len() && a[i] != i && a[a[i] as int] == i {\n        current + 2\n    } else {\n        current + 1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i, x| x as int)),\n    ensures \n        result as int == max_possible_fixed_points(a@.map(|i, x| x as int)),\n        result >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1849.rs,58,58,1.0,123.012,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec const MOD: int = 998244353int;

spec fn valid_input(n: int) -> bool
{
  n >= 1
}

spec fn pow(base: int, exp: int, modulus: int) -> int
  decreases exp
{
  if exp <= 0 { 1int }
  else { (base * pow(base, exp - 1, modulus)) % modulus }
}

spec fn block_count_formula(n: int, i: int) -> int
  recommends n >= 1 && 1 <= i <= n
{
  if i == n { 10int }
  else { 
    ((2int * 9int * pow(10int, n - i - 1, MOD) * 10int) + 
     (if i < n - 1 { ((n - 1 - i) * 9int * 9int * pow(10int, n - i - 2, MOD) * 10int) } else { 0int })) % MOD
  }
}

spec fn valid_result(result: Seq<int>, n: int) -> bool
  recommends n >= 1
{
  result.len() == n &&
  (forall|k: int| 0 <= k < n ==> #[trigger] result[k] >= 0 && #[trigger] result[k] < MOD) &&
  (n >= 1 ==> result[n-1] == 10int) &&
  (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] == block_count_formula(n, i+1))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: Vec<i8>)
  requires valid_input(n as int)
  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec const MOD: int = 998244353int;

spec fn valid_input(n: int) -> bool
{
  n >= 1
}

spec fn pow(base: int, exp: int, modulus: int) -> int
  decreases exp
{
  if exp <= 0 { 1int }
  else { (base * pow(base, exp - 1, modulus)) % modulus }
}

spec fn block_count_formula(n: int, i: int) -> int
  recommends n >= 1 && 1 <= i <= n
{
  if i == n { 10int }
  else { 
    ((2int * 9int * pow(10int, n - i - 1, MOD) * 10int) + 
     (if i < n - 1 { ((n - 1 - i) * 9int * 9int * pow(10int, n - i - 2, MOD) * 10int) } else { 0int })) % MOD
  }
}

spec fn valid_result(result: Seq<int>, n: int) -> bool
  recommends n >= 1
{
  result.len() == n &&
  (forall|k: int| 0 <= k < n ==> #[trigger] result[k] >= 0 && #[trigger] result[k] < MOD) &&
  (n >= 1 ==> result[n-1] == 10int) &&
  (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] == block_count_formula(n, i+1))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: Vec<i8>)
  requires valid_input(n as int)
  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec const MOD: int = 998244353int;\n\nspec fn valid_input(n: int) -> bool\n{\n  n >= 1\n}\n\nspec fn pow(base: int, exp: int, modulus: int) -> int\n  decreases exp\n{\n  if exp <= 0 { 1int }\n  else { (base * pow(base, exp - 1, modulus)) % modulus }\n}\n\nspec fn block_count_formula(n: int, i: int) -> int\n  recommends n >= 1 && 1 <= i <= n\n{\n  if i == n { 10int }\n  else { \n    ((2int * 9int * pow(10int, n - i - 1, MOD) * 10int) + \n     (if i < n - 1 { ((n - 1 - i) * 9int * 9int * pow(10int, n - i - 2, MOD) * 10int) } else { 0int })) % MOD\n  }\n}\n\nspec fn valid_result(result: Seq<int>, n: int) -> bool\n  recommends n >= 1\n{\n  result.len() == n &&\n  (forall|k: int| 0 <= k < n ==> #[trigger] result[k] >= 0 && #[trigger] result[k] < MOD) &&\n  (n >= 1 ==> result[n-1] == 10int) &&\n  (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] == block_count_formula(n, i+1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<i8>)\n  requires valid_input(n as int)\n  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n                fn main() {\n      }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1850.rs,73,73,1.0,153.652,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {
        n >= 1 && n <= 200000 &&
        d >= 1 && d <= n &&
        current_points.len() == n &&
        awards.len() == n &&
        d-1 < current_points.len() &&
        (forall|i: int| 0 <= i < current_points.len()-1 ==> 
            #[trigger] current_points.index(i) >= current_points.index((i+1) as int)) &&
        (forall|i: int| 0 <= i < awards.len()-1 ==> 
            #[trigger] awards.index(i) >= awards.index((i+1) as int))
    }
    
    spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int
        recommends 
            current_points.len() == awards.len(),
            d >= 1 && d <= current_points.len(),
            d-1 < current_points.len(),
            forall|i: int| 0 <= i < awards.len()-1 ==> 
                #[trigger] awards.index(i) >= awards.index((i+1) as int)
    {
        count_overtaken_helper(current_points, awards, d, 0, 0)
    }
    
    spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int
        recommends 
            current_points.len() == awards.len(),
            d >= 1 && d <= current_points.len(),
            d-1 < current_points.len(),
            forall|i: int| 0 <= i < awards.len()-1 ==> 
                #[trigger] awards.index(i) >= awards.index((i+1) as int),
            0 <= pos <= d-1,
            0 <= used_awards <= awards.len()
        decreases d-1-pos
    {
        if pos >= d-1 {
            0
        } else {
            let target_score = current_points.index(d-1) + awards.index(0);
            let remaining_awards = awards.len() - used_awards;
            if remaining_awards > 0 && used_awards < awards.len() && current_points.index(pos) + awards.index(awards.len()-1-used_awards) <= target_score {
                1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)
            } else {
                count_overtaken_helper(current_points, awards, d, pos+1, used_awards)
            }
        }
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, d: i8, current_points: Vec<i8>, awards: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, d as int, current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int))
    ensures 
        1 <= result as int <= d as int,
        result as int == d as int - count_overtaken(current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int), d as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>

}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {
        n >= 1 && n <= 200000 &&
        d >= 1 && d <= n &&
        current_points.len() == n &&
        awards.len() == n &&
        d-1 < current_points.len() &&
        (forall|i: int| 0 <= i < current_points.len()-1 ==> 
            #[trigger] current_points.index(i) >= current_points.index((i+1) as int)) &&
        (forall|i: int| 0 <= i < awards.len()-1 ==> 
            #[trigger] awards.index(i) >= awards.index((i+1) as int))
    }
    
    spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int
        recommends 
            current_points.len() == awards.len(),
            d >= 1 && d <= current_points.len(),
            d-1 < current_points.len(),
            forall|i: int| 0 <= i < awards.len()-1 ==> 
                #[trigger] awards.index(i) >= awards.index((i+1) as int)
    {
        count_overtaken_helper(current_points, awards, d, 0, 0)
    }
    
    spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int
        recommends 
            current_points.len() == awards.len(),
            d >= 1 && d <= current_points.len(),
            d-1 < current_points.len(),
            forall|i: int| 0 <= i < awards.len()-1 ==> 
                #[trigger] awards.index(i) >= awards.index((i+1) as int),
            0 <= pos <= d-1,
            0 <= used_awards <= awards.len()
        decreases d-1-pos
    {
        if pos >= d-1 {
            0
        } else {
            let target_score = current_points.index(d-1) + awards.index(0);
            let remaining_awards = awards.len() - used_awards;
            if remaining_awards > 0 && used_awards < awards.len() && current_points.index(pos) + awards.index(awards.len()-1-used_awards) <= target_score {
                1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)
            } else {
                count_overtaken_helper(current_points, awards, d, pos+1, used_awards)
            }
        }
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, d: i8, current_points: Vec<i8>, awards: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, d as int, current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int))
    ensures 
        1 <= result as int <= d as int,
        result as int == d as int - count_overtaken(current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int), d as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>

}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {\n        n >= 1 && n <= 200000 &&\n        d >= 1 && d <= n &&\n        current_points.len() == n &&\n        awards.len() == n &&\n        d-1 < current_points.len() &&\n        (forall|i: int| 0 <= i < current_points.len()-1 ==> \n            #[trigger] current_points.index(i) >= current_points.index((i+1) as int)) &&\n        (forall|i: int| 0 <= i < awards.len()-1 ==> \n            #[trigger] awards.index(i) >= awards.index((i+1) as int))\n    }\n    \n    spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int)\n    {\n        count_overtaken_helper(current_points, awards, d, 0, 0)\n    }\n    \n    spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int\n        recommends \n            current_points.len() == awards.len(),\n            d >= 1 && d <= current_points.len(),\n            d-1 < current_points.len(),\n            forall|i: int| 0 <= i < awards.len()-1 ==> \n                #[trigger] awards.index(i) >= awards.index((i+1) as int),\n            0 <= pos <= d-1,\n            0 <= used_awards <= awards.len()\n        decreases d-1-pos\n    {\n        if pos >= d-1 {\n            0\n        } else {\n            let target_score = current_points.index(d-1) + awards.index(0);\n            let remaining_awards = awards.len() - used_awards;\n            if remaining_awards > 0 && used_awards < awards.len() && current_points.index(pos) + awards.index(awards.len()-1-used_awards) <= target_score {\n                1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)\n            } else {\n                count_overtaken_helper(current_points, awards, d, pos+1, used_awards)\n            }\n        }\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, current_points: Vec<i8>, awards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, d as int, current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int))\n    ensures \n        1 <= result as int <= d as int,\n        result as int == d as int - count_overtaken(current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int), d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1877.rs,58,58,1.0,122.382,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: Seq<char>) -> bool {
    n >= 0 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> (s[i] == 'U' || s[i] == 'R')
}

spec fn count_kingdom_transitions(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else { count_transitions_helper(s, 0, 0, 0, -1) }
}

spec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int
    decreases s.len() - pos when 0 <= pos <= s.len()
{
    if pos == s.len() { 0 }
    else {
        let new_x = if s[pos] == 'U' { x } else { x + 1 };
        let new_y = if s[pos] == 'U' { y + 1 } else { y };

        if new_x == new_y {
            count_transitions_helper(s, pos + 1, new_x, new_y, pred)
        } else {
            let cur = if new_x > new_y { 0 } else { 1 };
            let transition: int = if cur != pred && pred != -1 { 1 } else { 0 };
            transition + count_transitions_helper(s, pos + 1, new_x, new_y, cur)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, s: Vec<char>) -> (result: i8)
    requires 
        valid_input(n as int, s@),
        n >= 0
    ensures 
        result >= 0 &&
        result <= n &&
        (n == 0 ==> result == 0) &&
        result as int == count_kingdom_transitions(s@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: Seq<char>) -> bool {
    n >= 0 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> (s[i] == 'U' || s[i] == 'R')
}

spec fn count_kingdom_transitions(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else { count_transitions_helper(s, 0, 0, 0, -1) }
}

spec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int
    decreases s.len() - pos when 0 <= pos <= s.len()
{
    if pos == s.len() { 0 }
    else {
        let new_x = if s[pos] == 'U' { x } else { x + 1 };
        let new_y = if s[pos] == 'U' { y + 1 } else { y };

        if new_x == new_y {
            count_transitions_helper(s, pos + 1, new_x, new_y, pred)
        } else {
            let cur = if new_x > new_y { 0 } else { 1 };
            let transition: int = if cur != pred && pred != -1 { 1 } else { 0 };
            transition + count_transitions_helper(s, pos + 1, new_x, new_y, cur)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, s: Vec<char>) -> (result: i8)
    requires 
        valid_input(n as int, s@),
        n >= 0
    ensures 
        result >= 0 &&
        result <= n &&
        (n == 0 ==> result == 0) &&
        result as int == count_kingdom_transitions(s@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n >= 0 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> (s[i] == 'U' || s[i] == 'R')\n}\n\nspec fn count_kingdom_transitions(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else { count_transitions_helper(s, 0, 0, 0, -1) }\n}\n\nspec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos == s.len() { 0 }\n    else {\n        let new_x = if s[pos] == 'U' { x } else { x + 1 };\n        let new_y = if s[pos] == 'U' { y + 1 } else { y };\n\n        if new_x == new_y {\n            count_transitions_helper(s, pos + 1, new_x, new_y, pred)\n        } else {\n            let cur = if new_x > new_y { 0 } else { 1 };\n            let transition: int = if cur != pred && pred != -1 { 1 } else { 0 };\n            transition + count_transitions_helper(s, pos + 1, new_x, new_y, cur)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(n as int, s@),\n        n >= 0\n    ensures \n        result >= 0 &&\n        result <= n &&\n        (n == 0 ==> result == 0) &&\n        result as int == count_kingdom_transitions(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1878.rs,188,188,1.0,92.118,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        split_lines_helper(s, 0, 0, seq![])
    }
}

spec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - pos when pos >= 0 && pos <= s.len()
{
    if pos >= s.len() {
        if start < pos {
            acc.push(s.subrange(start, pos))
        } else {
            acc
        }
    } else if s[pos] == '\n' {
        let new_acc = if start < pos {
            acc.push(s.subrange(start, pos))
        } else {
            acc
        };
        split_lines_helper(s, pos + 1, pos + 1, new_acc)
    } else {
        split_lines_helper(s, start, pos + 1, acc)
    }
}

spec fn parse_int_func(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        -parse_int_pos_func(s.subrange(1, s.len() as int))
    } else {
        parse_int_pos_func(s)
    }
}

spec fn parse_int_pos_func(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if '0' <= s[0] && s[0] <= '9' {
        (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))
    } else {
        0
    }
}

spec fn parse_ints_func(s: Seq<char>) -> Seq<int> {
    if s.len() == 0 {
        seq![]
    } else {
        parse_ints_helper(s, 0, 0, seq![])
    }
}

spec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>
    decreases s.len() - pos when pos >= 0 && pos <= s.len()
{
    if pos >= s.len() {
        if start < pos {
            acc.push(parse_int_func(s.subrange(start, pos)))
        } else {
            acc
        }
    } else if s[pos] == ' ' {
        let new_acc = if start < pos {
            acc.push(parse_int_func(s.subrange(start, pos)))
        } else {
            acc
        };
        parse_ints_helper(s, pos + 1, pos + 1, new_acc)
    } else {
        parse_ints_helper(s, start, pos + 1, acc)
    }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_pos(n)
    } else {
        seq!['-'] + int_to_string_pos(-n)
    }
}

spec fn int_to_string_pos(n: int) -> Seq<char>
    decreases n when n > 0
{
    if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char]
    }
}

spec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int
    decreases rectangle_lines.len()
{
    if rectangle_lines.len() == 0 {
        0
    } else {
        let coords = parse_ints_func(rectangle_lines[0]);
        let area = if coords.len() >= 4 {
            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);
            if computed >= 0 { computed } else { 0 }
        } else {
            0
        };
        area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))
    }
}

spec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int
    decreases n when n >= 0
{
    if n <= 0 || rectangle_lines.len() == 0 {
        0
    } else {
        let coords = parse_ints_func(rectangle_lines[0]);
        let area = if coords.len() >= 4 {
            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);
            if computed >= 0 { computed } else { 0 }
        } else {
            0
        };
        area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@),
    ensures 
        result@.len() >= 1,
        result@[result@.len() - 1] == '\n',
        exists|total_area: int| {
            &&& total_area >= 0
            &&& result@ == int_to_string_func(total_area) + seq!['\n']
            &&& {
                let processed_input = if input@.len() > 0 && input@[input@.len() - 1] == '\n' {
                    input@
                } else {
                    input@ + seq!['\n']
                };
                let lines = split_lines_func(processed_input);
                if lines.len() == 0 {
                    total_area == 0
                } else {
                    let n = parse_int_func(lines[0]);
                    if n >= 0 && n + 1 <= lines.len() {
                        total_area == compute_total_area(lines.subrange(1, n + 1))
                    } else {
                        total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)
                    }
                }
            }
        }
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        split_lines_helper(s, 0, 0, seq![])
    }
}

spec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - pos when pos >= 0 && pos <= s.len()
{
    if pos >= s.len() {
        if start < pos {
            acc.push(s.subrange(start, pos))
        } else {
            acc
        }
    } else if s[pos] == '\n' {
        let new_acc = if start < pos {
            acc.push(s.subrange(start, pos))
        } else {
            acc
        };
        split_lines_helper(s, pos + 1, pos + 1, new_acc)
    } else {
        split_lines_helper(s, start, pos + 1, acc)
    }
}

spec fn parse_int_func(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        -parse_int_pos_func(s.subrange(1, s.len() as int))
    } else {
        parse_int_pos_func(s)
    }
}

spec fn parse_int_pos_func(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if '0' <= s[0] && s[0] <= '9' {
        (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))
    } else {
        0
    }
}

spec fn parse_ints_func(s: Seq<char>) -> Seq<int> {
    if s.len() == 0 {
        seq![]
    } else {
        parse_ints_helper(s, 0, 0, seq![])
    }
}

spec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>
    decreases s.len() - pos when pos >= 0 && pos <= s.len()
{
    if pos >= s.len() {
        if start < pos {
            acc.push(parse_int_func(s.subrange(start, pos)))
        } else {
            acc
        }
    } else if s[pos] == ' ' {
        let new_acc = if start < pos {
            acc.push(parse_int_func(s.subrange(start, pos)))
        } else {
            acc
        };
        parse_ints_helper(s, pos + 1, pos + 1, new_acc)
    } else {
        parse_ints_helper(s, start, pos + 1, acc)
    }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_pos(n)
    } else {
        seq!['-'] + int_to_string_pos(-n)
    }
}

spec fn int_to_string_pos(n: int) -> Seq<char>
    decreases n when n > 0
{
    if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char]
    }
}

spec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int
    decreases rectangle_lines.len()
{
    if rectangle_lines.len() == 0 {
        0
    } else {
        let coords = parse_ints_func(rectangle_lines[0]);
        let area = if coords.len() >= 4 {
            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);
            if computed >= 0 { computed } else { 0 }
        } else {
            0
        };
        area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))
    }
}

spec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int
    decreases n when n >= 0
{
    if n <= 0 || rectangle_lines.len() == 0 {
        0
    } else {
        let coords = parse_ints_func(rectangle_lines[0]);
        let area = if coords.len() >= 4 {
            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);
            if computed >= 0 { computed } else { 0 }
        } else {
            0
        };
        area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@),
    ensures 
        result@.len() >= 1,
        result@[result@.len() - 1] == '\n',
        exists|total_area: int| {
            &&& total_area >= 0
            &&& result@ == int_to_string_func(total_area) + seq!['\n']
            &&& {
                let processed_input = if input@.len() > 0 && input@[input@.len() - 1] == '\n' {
                    input@
                } else {
                    input@ + seq!['\n']
                };
                let lines = split_lines_func(processed_input);
                if lines.len() == 0 {
                    total_area == 0
                } else {
                    let n = parse_int_func(lines[0]);
                    if n >= 0 && n + 1 <= lines.len() {
                        total_area == compute_total_area(lines.subrange(1, n + 1))
                    } else {
                        total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)
                    }
                }
            }
        }
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_lines_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        }\n    } else if s[pos] == '\\n' {\n        let new_acc = if start < pos {\n            acc.push(s.subrange(start, pos))\n        } else {\n            acc\n        };\n        split_lines_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        split_lines_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        parse_int_pos_func(s)\n    }\n}\n\nspec fn parse_int_pos_func(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if '0' <= s[0] && s[0] <= '9' {\n        (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn parse_ints_func(s: Seq<char>) -> Seq<int> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        parse_ints_helper(s, 0, 0, seq![])\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>\n    decreases s.len() - pos when pos >= 0 && pos <= s.len()\n{\n    if pos >= s.len() {\n        if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        }\n    } else if s[pos] == ' ' {\n        let new_acc = if start < pos {\n            acc.push(parse_int_func(s.subrange(start, pos)))\n        } else {\n            acc\n        };\n        parse_ints_helper(s, pos + 1, pos + 1, new_acc)\n    } else {\n        parse_ints_helper(s, start, pos + 1, acc)\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'] + int_to_string_pos(-n)\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char]\n    }\n}\n\nspec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int\n    decreases rectangle_lines.len()\n{\n    if rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))\n    }\n}\n\nspec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 || rectangle_lines.len() == 0 {\n        0\n    } else {\n        let coords = parse_ints_func(rectangle_lines[0]);\n        let area = if coords.len() >= 4 {\n            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 { computed } else { 0 }\n        } else {\n            0\n        };\n        area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@),\n    ensures \n        result@.len() >= 1,\n        result@[result@.len() - 1] == '\\n',\n        exists|total_area: int| {\n            &&& total_area >= 0\n            &&& result@ == int_to_string_func(total_area) + seq!['\\n']\n            &&& {\n                let processed_input = if input@.len() > 0 && input@[input@.len() - 1] == '\\n' {\n                    input@\n                } else {\n                    input@ + seq!['\\n']\n                };\n                let lines = split_lines_func(processed_input);\n                if lines.len() == 0 {\n                    total_area == 0\n                } else {\n                    let n = parse_int_func(lines[0]);\n                    if n >= 0 && n + 1 <= lines.len() {\n                        total_area == compute_total_area(lines.subrange(1, n + 1))\n                    } else {\n                        total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)\n                    }\n                }\n            }\n        }\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1887.rs,78,78,1.0,184.431,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {
    n >= 1 && h1.len() >= n && h2.len() >= n &&
    (forall|i: int| 0 <= i < n ==> h1[i] >= 0) &&
    (forall|i: int| 0 <= i < n ==> h2[i] >= 0)
}

spec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
{
    let dp1 = max_height_ending_in_row1(n, h1, h2);
    let dp2 = max_height_ending_in_row2(n, h1, h2);
    if dp1 > dp2 { dp1 } else { dp2 }
}

spec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
    decreases n via max_height_ending_in_row1_decreases
{
    if n == 1 { h1[0] }
    else {
        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);
        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);
        let take_from_row2 = prev_row2 + h1[n-1];
        if take_from_row2 > prev_row1 { take_from_row2 } else { prev_row1 }
    }
}

spec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
    decreases n via max_height_ending_in_row2_decreases
{
    if n == 1 { h2[0] }
    else {
        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);
        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);
        let take_from_row1 = prev_row1 + h2[n-1];
        if take_from_row1 > prev_row2 { take_from_row1 } else { prev_row2 }
    }
}

#[via_fn]
proof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {
    assume(false);
}

#[via_fn]
proof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {
    assume(false);
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, h1: Vec<i8>, h2: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))
    ensures 
        result >= 0,
        result as int == max_team_height(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {
    n >= 1 && h1.len() >= n && h2.len() >= n &&
    (forall|i: int| 0 <= i < n ==> h1[i] >= 0) &&
    (forall|i: int| 0 <= i < n ==> h2[i] >= 0)
}

spec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
{
    let dp1 = max_height_ending_in_row1(n, h1, h2);
    let dp2 = max_height_ending_in_row2(n, h1, h2);
    if dp1 > dp2 { dp1 } else { dp2 }
}

spec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
    decreases n via max_height_ending_in_row1_decreases
{
    if n == 1 { h1[0] }
    else {
        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);
        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);
        let take_from_row2 = prev_row2 + h1[n-1];
        if take_from_row2 > prev_row1 { take_from_row2 } else { prev_row1 }
    }
}

spec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
    decreases n via max_height_ending_in_row2_decreases
{
    if n == 1 { h2[0] }
    else {
        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);
        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);
        let take_from_row1 = prev_row1 + h2[n-1];
        if take_from_row1 > prev_row2 { take_from_row1 } else { prev_row2 }
    }
}

#[via_fn]
proof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {
    assume(false);
}

#[via_fn]
proof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {
    assume(false);
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, h1: Vec<i8>, h2: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))
    ensures 
        result >= 0,
        result as int == max_team_height(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {\n    n >= 1 && h1.len() >= n && h2.len() >= n &&\n    (forall|i: int| 0 <= i < n ==> h1[i] >= 0) &&\n    (forall|i: int| 0 <= i < n ==> h2[i] >= 0)\n}\n\nspec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n{\n    let dp1 = max_height_ending_in_row1(n, h1, h2);\n    let dp2 = max_height_ending_in_row2(n, h1, h2);\n    if dp1 > dp2 { dp1 } else { dp2 }\n}\n\nspec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row1_decreases\n{\n    if n == 1 { h1[0] }\n    else {\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let take_from_row2 = prev_row2 + h1[n-1];\n        if take_from_row2 > prev_row1 { take_from_row2 } else { prev_row1 }\n    }\n}\n\nspec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int\n    recommends valid_input(n, h1, h2)\n    decreases n via max_height_ending_in_row2_decreases\n{\n    if n == 1 { h2[0] }\n    else {\n        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);\n        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);\n        let take_from_row1 = prev_row1 + h2[n-1];\n        if take_from_row1 > prev_row2 { take_from_row1 } else { prev_row2 }\n    }\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n\n#[via_fn]\nproof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {\n    assume(false);\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, h1: Vec<i8>, h2: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n    ensures \n        result >= 0,\n        result as int == max_team_height(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1889.rs,80,80,1.0,154.47,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {
    grid.len() == n && n > 0 && m > 0 &&
    (forall|i: int| 0 <= i < n ==> grid[i].len() == m) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {
    queries.len() == q && q >= 0 &&
    (forall|k: int| 0 <= k < q ==> #[trigger] queries[k].0 >= 1 && queries[k].0 <= n && queries[k].1 >= 1 && queries[k].1 <= m)
}

spec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int
    decreases l.len() - index
{
    if index >= l.len() {
        max_so_far
    } else if l[index] == 1 {
        let new_current = current + 1;
        let new_max = if new_current > max_so_far { new_current } else { max_so_far };
        cons_helper(l, index + 1, new_current, new_max)
    } else {
        cons_helper(l, index + 1, 0, max_so_far)
    }
}

spec fn cons(l: Seq<int>) -> int {
    cons_helper(l, 0, 0, 0)
}

spec fn max_in_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let rest = max_in_seq(s.subrange(1, s.len() as int));
        if s[0] > rest { s[0] } else { rest }
    }
}

spec fn compute_score(grid: Seq<Seq<int>>) -> int {
    if grid.len() == 0 {
        0
    } else {
        let row_scores = Seq::new(grid.len(), |i: int| cons(grid[i]));
        max_in_seq(row_scores)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, q: i8, grid: Vec<Vec<i8>>, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)
    requires 
        valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), n as int, m as int),
        valid_queries(queries@.map(|k: int, query: (i8, i8)| (query.0 as int, query.1 as int)), q as int, n as int, m as int),
    ensures 
        results.len() == q,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {
    grid.len() == n && n > 0 && m > 0 &&
    (forall|i: int| 0 <= i < n ==> grid[i].len() == m) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {
    queries.len() == q && q >= 0 &&
    (forall|k: int| 0 <= k < q ==> #[trigger] queries[k].0 >= 1 && queries[k].0 <= n && queries[k].1 >= 1 && queries[k].1 <= m)
}

spec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int
    decreases l.len() - index
{
    if index >= l.len() {
        max_so_far
    } else if l[index] == 1 {
        let new_current = current + 1;
        let new_max = if new_current > max_so_far { new_current } else { max_so_far };
        cons_helper(l, index + 1, new_current, new_max)
    } else {
        cons_helper(l, index + 1, 0, max_so_far)
    }
}

spec fn cons(l: Seq<int>) -> int {
    cons_helper(l, 0, 0, 0)
}

spec fn max_in_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let rest = max_in_seq(s.subrange(1, s.len() as int));
        if s[0] > rest { s[0] } else { rest }
    }
}

spec fn compute_score(grid: Seq<Seq<int>>) -> int {
    if grid.len() == 0 {
        0
    } else {
        let row_scores = Seq::new(grid.len(), |i: int| cons(grid[i]));
        max_in_seq(row_scores)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, q: i8, grid: Vec<Vec<i8>>, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)
    requires 
        valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), n as int, m as int),
        valid_queries(queries@.map(|k: int, query: (i8, i8)| (query.0 as int, query.1 as int)), q as int, n as int, m as int),
    ensures 
        results.len() == q,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {\n    grid.len() == n && n > 0 && m > 0 &&\n    (forall|i: int| 0 <= i < n ==> grid[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {\n    queries.len() == q && q >= 0 &&\n    (forall|k: int| 0 <= k < q ==> #[trigger] queries[k].0 >= 1 && queries[k].0 <= n && queries[k].1 >= 1 && queries[k].1 <= m)\n}\n\nspec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int\n    decreases l.len() - index\n{\n    if index >= l.len() {\n        max_so_far\n    } else if l[index] == 1 {\n        let new_current = current + 1;\n        let new_max = if new_current > max_so_far { new_current } else { max_so_far };\n        cons_helper(l, index + 1, new_current, new_max)\n    } else {\n        cons_helper(l, index + 1, 0, max_so_far)\n    }\n}\n\nspec fn cons(l: Seq<int>) -> int {\n    cons_helper(l, 0, 0, 0)\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let rest = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] > rest { s[0] } else { rest }\n    }\n}\n\nspec fn compute_score(grid: Seq<Seq<int>>) -> int {\n    if grid.len() == 0 {\n        0\n    } else {\n        let row_scores = Seq::new(grid.len(), |i: int| cons(grid[i]));\n        max_in_seq(row_scores)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, q: i8, grid: Vec<Vec<i8>>, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires \n        valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), n as int, m as int),\n        valid_queries(queries@.map(|k: int, query: (i8, i8)| (query.0 as int, query.1 as int)), q as int, n as int, m as int),\n    ensures \n        results.len() == q,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n           fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_189.rs,66,20,0.30303030303030304,155.92,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, sticks: Seq<int>) -> bool {
    1 <= n <= 1000 &&
    sticks.len() == n &&
    (forall|i: int| 0 <= i < sticks.len() ==> #[trigger] sticks[i] >= 1 && #[trigger] sticks[i] <= 100)
}

spec fn cost_for_t(sticks: Seq<int>, t: int) -> int {
    sum_costs(sticks, t, 0)
}

spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int
    decreases sticks.len() - index when 0 <= index <= sticks.len()
{
    if index < 0 || index >= sticks.len() {
        0
    } else if index == sticks.len() {
        0
    } else {
        max_int(0, abs_int(t - sticks[index as int]) - 1) + sum_costs(sticks, t, index + 1)
    }
}

spec fn abs_int(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn max_int(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {
    forall|other_t: int| 1 <= other_t <= 99 ==> 
        #[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))
    requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))
    ensures ({
        let (t, min_cost) = result;
        1 <= t as int <= 99 &&
        min_cost as int >= 0 &&
        min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&
        is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input(n: int, sticks: Seq<int>) -> bool ;
       spec fn cost_for_t(sticks: Seq<int>, t: int) -> int ;
       spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int     decreases sticks.len() - index when 0 <= index <= sticks.len() ;
       spec fn abs_int(x: int) -> int ;
       spec fn max_int(a: int, b: int) -> int ;
       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {
          forall|other_t: int| 1 <= other_t <= 99 ==>                 
#[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)
}
       fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))     requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))     ensures ({
              let (t, min_cost) = result;
              1 <= t as int <= 99 &&         min_cost as int >= 0 &&         min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&         is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)     }
      ) {
          assume(false);
          unreached() }
       }
        fn main() {
      }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, sticks: Seq<int>) -> bool {\n    1 <= n <= 1000 &&\n    sticks.len() == n &&\n    (forall|i: int| 0 <= i < sticks.len() ==> #[trigger] sticks[i] >= 1 && #[trigger] sticks[i] <= 100)\n}\n\nspec fn cost_for_t(sticks: Seq<int>, t: int) -> int {\n    sum_costs(sticks, t, 0)\n}\n\nspec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int\n    decreases sticks.len() - index when 0 <= index <= sticks.len()\n{\n    if index < 0 || index >= sticks.len() {\n        0\n    } else if index == sticks.len() {\n        0\n    } else {\n        max_int(0, abs_int(t - sticks[index as int]) - 1) + sum_costs(sticks, t, index + 1)\n    }\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn max_int(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n    forall|other_t: int| 1 <= other_t <= 99 ==> \n        #[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))\n    requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))\n    ensures ({\n        let (t, min_cost) = result;\n        1 <= t as int <= 99 &&\n        min_cost as int >= 0 &&\n        min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&\n        is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(n: int, sticks: Seq<int>) -> bool ;\n       spec fn cost_for_t(sticks: Seq<int>, t: int) -> int ;\n       spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int     decreases sticks.len() - index when 0 <= index <= sticks.len() ;\n       spec fn abs_int(x: int) -> int ;\n       spec fn max_int(a: int, b: int) -> int ;\n       spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {\n          forall|other_t: int| 1 <= other_t <= 99 ==>                 \n#[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)\n}\n       fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))     requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))     ensures ({\n              let (t, min_cost) = result;\n              1 <= t as int <= 99 &&         min_cost as int >= 0 &&         min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&         is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)     }\n      ) {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n              fn main() {\n    }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1925.rs,100,100,1.0,123.064,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    parse_three_ints_func(input).1 > 0
}

spec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) 
    recommends s.len() > 0
{
    let nums = parse_numbers(s, 0, seq![], 0, false);
    if nums.len() >= 3 { 
        (nums[0], if nums[1] > 0 { nums[1] } else { 1 }, nums[2])
    } else { 
        (0, 1, 0) 
    }
}

spec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>
    recommends 0 <= i <= s.len()
    decreases s.len() - i
{
    if i >= s.len() {
        if in_number && nums.len() < 3 { nums.push(current) } else { nums }
    } else if nums.len() >= 3 {
        nums
    } else {
        let c = s[i];
        if c >= '0' && c <= '9' {
            let digit = c as int - '0' as int;
            if !in_number {
                parse_numbers(s, i + 1, nums, digit, true)
            } else {
                parse_numbers(s, i + 1, nums, current * 10 + digit, true)
            }
        } else if in_number {
            parse_numbers(s, i + 1, nums.push(current), 0, false)
        } else {
            parse_numbers(s, i + 1, nums, current, false)
        }
    }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'].add(int_to_string_helper_func(-n)) }
    else { int_to_string_helper_func(n) }
}

spec fn int_to_string_helper_func(n: int) -> Seq<char> 
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_helper_func(n / 10).add(seq![('0' as int + (n % 10)) as char])
    }
}

spec fn compute_max_value(a: int, b: int, n: int) -> int 
    recommends b > 0
{
    let min_val = if b - 1 < n { b - 1 } else { n };
    (a * min_val) / b
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures ({
        let parts = parse_three_ints_func(input@);
        let a = parts.0;
        let b = parts.1;  
        let n = parts.2;
        b > 0 &&
        result@ == int_to_string_func(compute_max_value(a, b, n)).add(seq!['\n'])
    })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    parse_three_ints_func(input).1 > 0
}

spec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) 
    recommends s.len() > 0
{
    let nums = parse_numbers(s, 0, seq![], 0, false);
    if nums.len() >= 3 { 
        (nums[0], if nums[1] > 0 { nums[1] } else { 1 }, nums[2])
    } else { 
        (0, 1, 0) 
    }
}

spec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>
    recommends 0 <= i <= s.len()
    decreases s.len() - i
{
    if i >= s.len() {
        if in_number && nums.len() < 3 { nums.push(current) } else { nums }
    } else if nums.len() >= 3 {
        nums
    } else {
        let c = s[i];
        if c >= '0' && c <= '9' {
            let digit = c as int - '0' as int;
            if !in_number {
                parse_numbers(s, i + 1, nums, digit, true)
            } else {
                parse_numbers(s, i + 1, nums, current * 10 + digit, true)
            }
        } else if in_number {
            parse_numbers(s, i + 1, nums.push(current), 0, false)
        } else {
            parse_numbers(s, i + 1, nums, current, false)
        }
    }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'].add(int_to_string_helper_func(-n)) }
    else { int_to_string_helper_func(n) }
}

spec fn int_to_string_helper_func(n: int) -> Seq<char> 
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_helper_func(n / 10).add(seq![('0' as int + (n % 10)) as char])
    }
}

spec fn compute_max_value(a: int, b: int, n: int) -> int 
    recommends b > 0
{
    let min_val = if b - 1 < n { b - 1 } else { n };
    (a * min_val) / b
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures ({
        let parts = parse_three_ints_func(input@);
        let a = parts.0;
        let b = parts.1;  
        let n = parts.2;
        b > 0 &&
        result@ == int_to_string_func(compute_max_value(a, b, n)).add(seq!['\n'])
    })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    parse_three_ints_func(input).1 > 0\n}\n\nspec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) \n    recommends s.len() > 0\n{\n    let nums = parse_numbers(s, 0, seq![], 0, false);\n    if nums.len() >= 3 { \n        (nums[0], if nums[1] > 0 { nums[1] } else { 1 }, nums[2])\n    } else { \n        (0, 1, 0) \n    }\n}\n\nspec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if in_number && nums.len() < 3 { nums.push(current) } else { nums }\n    } else if nums.len() >= 3 {\n        nums\n    } else {\n        let c = s[i];\n        if c >= '0' && c <= '9' {\n            let digit = c as int - '0' as int;\n            if !in_number {\n                parse_numbers(s, i + 1, nums, digit, true)\n            } else {\n                parse_numbers(s, i + 1, nums, current * 10 + digit, true)\n            }\n        } else if in_number {\n            parse_numbers(s, i + 1, nums.push(current), 0, false)\n        } else {\n            parse_numbers(s, i + 1, nums, current, false)\n        }\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'].add(int_to_string_helper_func(-n)) }\n    else { int_to_string_helper_func(n) }\n}\n\nspec fn int_to_string_helper_func(n: int) -> Seq<char> \n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_helper_func(n / 10).add(seq![('0' as int + (n % 10)) as char])\n    }\n}\n\nspec fn compute_max_value(a: int, b: int, n: int) -> int \n    recommends b > 0\n{\n    let min_val = if b - 1 < n { b - 1 } else { n };\n    (a * min_val) / b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures ({\n        let parts = parse_three_ints_func(input@);\n        let a = parts.0;\n        let b = parts.1;  \n        let n = parts.2;\n        b > 0 &&\n        result@ == int_to_string_func(compute_max_value(a, b, n)).add(seq!['\\n'])\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_194.rs,64,64,1.0,122.786,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {
    n >= 1 && a >= 1 && b >= 1 && groups.len() == n &&
    forall|i: int| 0 <= i < groups.len() ==> groups[i] == 1 || groups[i] == 2
}

spec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {
    count_denied_people_with_half(groups, a, b, 0)
}

spec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int
    decreases groups.len()
{
    if groups.len() == 0 {
        0
    } else {
        let group = groups[0];
        let rest = groups.subrange(1, groups.len() as int);
        if group == 2 {
            if b > 0 {
                count_denied_people_with_half(rest, a, b - 1, half_occupied)
            } else {
                2 + count_denied_people_with_half(rest, a, b, half_occupied)
            }
        } else {
            if a > 0 {
                count_denied_people_with_half(rest, a - 1, b, half_occupied)
            } else if b > 0 {
                count_denied_people_with_half(rest, a, b - 1, half_occupied + 1)
            } else if half_occupied > 0 {
                count_denied_people_with_half(rest, a, b, half_occupied - 1)
            } else {
                1 + count_denied_people_with_half(rest, a, b, half_occupied)
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, groups: Vec<i8>) -> (denied: i8)
    requires 
        valid_input(n as int, a as int, b as int, groups@.map_values(|x: i8| x as int))
    ensures 
        denied >= 0,
        denied as int == count_denied_people(groups@.map_values(|x: i8| x as int), a as int, b as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {
    n >= 1 && a >= 1 && b >= 1 && groups.len() == n &&
    forall|i: int| 0 <= i < groups.len() ==> groups[i] == 1 || groups[i] == 2
}

spec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {
    count_denied_people_with_half(groups, a, b, 0)
}

spec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int
    decreases groups.len()
{
    if groups.len() == 0 {
        0
    } else {
        let group = groups[0];
        let rest = groups.subrange(1, groups.len() as int);
        if group == 2 {
            if b > 0 {
                count_denied_people_with_half(rest, a, b - 1, half_occupied)
            } else {
                2 + count_denied_people_with_half(rest, a, b, half_occupied)
            }
        } else {
            if a > 0 {
                count_denied_people_with_half(rest, a - 1, b, half_occupied)
            } else if b > 0 {
                count_denied_people_with_half(rest, a, b - 1, half_occupied + 1)
            } else if half_occupied > 0 {
                count_denied_people_with_half(rest, a, b, half_occupied - 1)
            } else {
                1 + count_denied_people_with_half(rest, a, b, half_occupied)
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, groups: Vec<i8>) -> (denied: i8)
    requires 
        valid_input(n as int, a as int, b as int, groups@.map_values(|x: i8| x as int))
    ensures 
        denied >= 0,
        denied as int == count_denied_people(groups@.map_values(|x: i8| x as int), a as int, b as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && groups.len() == n &&\n    forall|i: int| 0 <= i < groups.len() ==> groups[i] == 1 || groups[i] == 2\n}\n\nspec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {\n    count_denied_people_with_half(groups, a, b, 0)\n}\n\nspec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int\n    decreases groups.len()\n{\n    if groups.len() == 0 {\n        0\n    } else {\n        let group = groups[0];\n        let rest = groups.subrange(1, groups.len() as int);\n        if group == 2 {\n            if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied)\n            } else {\n                2 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        } else {\n            if a > 0 {\n                count_denied_people_with_half(rest, a - 1, b, half_occupied)\n            } else if b > 0 {\n                count_denied_people_with_half(rest, a, b - 1, half_occupied + 1)\n            } else if half_occupied > 0 {\n                count_denied_people_with_half(rest, a, b, half_occupied - 1)\n            } else {\n                1 + count_denied_people_with_half(rest, a, b, half_occupied)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, groups: Vec<i8>) -> (denied: i8)\n    requires \n        valid_input(n as int, a as int, b as int, groups@.map_values(|x: i8| x as int))\n    ensures \n        denied >= 0,\n        denied as int == count_denied_people(groups@.map_values(|x: i8| x as int), a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1958.rs,68,68,1.0,122.495,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {
    1 <= n <= 40 &&
    2 <= p <= 1000 &&
    p % 2 == 0 &&
    buyers.len() == n &&
    forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
}

spec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int
    recommends p >= 0,
                p % 2 == 0,
                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
{
    compute_payment_backward(buyers, p, buyers.len() - 1, 0)
}

spec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int
    recommends p >= 0,
                p % 2 == 0,
                -1 <= current_index < buyers.len(),
                current_apples >= 0,
                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
    decreases current_index + 1
{
    if current_index < 0 {
        0
    } else {
        let new_apples = if buyers[current_index] == ""halfplus"" { 
                            current_apples * 2 + 1
                         } else { 
                            current_apples * 2
                         };
        let payment = if buyers[current_index] == ""halfplus"" { 
                          (new_apples / 2) * p
                       } else { 
                          current_apples * p
                       };
        payment + compute_payment_backward(buyers, p, current_index - 1, new_apples)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: i8, buyers: Vec<&str>) -> (result: i8)
    requires valid_input(n as int, p as int, buyers@)
    ensures result >= 0,
            result as int == compute_total_payment(buyers@, p as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {
    1 <= n <= 40 &&
    2 <= p <= 1000 &&
    p % 2 == 0 &&
    buyers.len() == n &&
    forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
}

spec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int
    recommends p >= 0,
                p % 2 == 0,
                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
{
    compute_payment_backward(buyers, p, buyers.len() - 1, 0)
}

spec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int
    recommends p >= 0,
                p % 2 == 0,
                -1 <= current_index < buyers.len(),
                current_apples >= 0,
                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
    decreases current_index + 1
{
    if current_index < 0 {
        0
    } else {
        let new_apples = if buyers[current_index] == ""halfplus"" { 
                            current_apples * 2 + 1
                         } else { 
                            current_apples * 2
                         };
        let payment = if buyers[current_index] == ""halfplus"" { 
                          (new_apples / 2) * p
                       } else { 
                          current_apples * p
                       };
        payment + compute_payment_backward(buyers, p, current_index - 1, new_apples)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: i8, buyers: Vec<&str>) -> (result: i8)
    requires valid_input(n as int, p as int, buyers@)
    ensures result >= 0,
            result as int == compute_total_payment(buyers@, p as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {\n    1 <= n <= 40 &&\n    2 <= p <= 1000 &&\n    p % 2 == 0 &&\n    buyers.len() == n &&\n    forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""\n}\n\nspec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""\n{\n    compute_payment_backward(buyers, p, buyers.len() - 1, 0)\n}\n\nspec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int\n    recommends p >= 0,\n                p % 2 == 0,\n                -1 <= current_index < buyers.len(),\n                current_apples >= 0,\n                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""\n    decreases current_index + 1\n{\n    if current_index < 0 {\n        0\n    } else {\n        let new_apples = if buyers[current_index] == ""halfplus"" { \n                            current_apples * 2 + 1\n                         } else { \n                            current_apples * 2\n                         };\n        let payment = if buyers[current_index] == ""halfplus"" { \n                          (new_apples / 2) * p\n                       } else { \n                          current_apples * p\n                       };\n        payment + compute_payment_backward(buyers, p, current_index - 1, new_apples)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, buyers: Vec<&str>) -> (result: i8)\n    requires valid_input(n as int, p as int, buyers@)\n    ensures result >= 0,\n            result as int == compute_total_payment(buyers@, p as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1965.rs,68,68,1.0,122.356,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_occurrences(s: Seq<int>, x: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == x {
        1 + count_occurrences(s.drop_first(), x)
    } else {
        count_occurrences(s.drop_first(), x)
    }
}

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum(s.drop_first())
    }
}

spec fn valid_input(n: int, ratings: Seq<int>) -> bool {
    n >= 2 && ratings.len() == n
}

spec fn all_infected(k: int, ratings: Seq<int>) -> bool {
    ratings.contains(k) && count_occurrences(ratings, k) == ratings.len()
}

spec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {
    (ratings.contains(k) && count_occurrences(ratings, k) != ratings.len()) ||
    (!ratings.contains(k) && k * ratings.len() == sum(ratings))
}

spec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {
    !ratings.contains(k) && k * ratings.len() != sum(ratings)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve_case(n: i8, k: i8, ratings: Vec<i8>) -> (answer: i8)
    requires 
        valid_input(n as int, ratings@.map(|i: int, x: i8| x as int))
    ensures 
        answer >= 0 && answer <= 2,
        all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 0,
        can_infect_in_one_contest(k as int, ratings@.map(|i: int, x: i8| x as int)) && !all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 1,
        requires_two_contests(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 2
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_occurrences(s: Seq<int>, x: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == x {
        1 + count_occurrences(s.drop_first(), x)
    } else {
        count_occurrences(s.drop_first(), x)
    }
}

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum(s.drop_first())
    }
}

spec fn valid_input(n: int, ratings: Seq<int>) -> bool {
    n >= 2 && ratings.len() == n
}

spec fn all_infected(k: int, ratings: Seq<int>) -> bool {
    ratings.contains(k) && count_occurrences(ratings, k) == ratings.len()
}

spec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {
    (ratings.contains(k) && count_occurrences(ratings, k) != ratings.len()) ||
    (!ratings.contains(k) && k * ratings.len() == sum(ratings))
}

spec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {
    !ratings.contains(k) && k * ratings.len() != sum(ratings)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve_case(n: i8, k: i8, ratings: Vec<i8>) -> (answer: i8)
    requires 
        valid_input(n as int, ratings@.map(|i: int, x: i8| x as int))
    ensures 
        answer >= 0 && answer <= 2,
        all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 0,
        can_infect_in_one_contest(k as int, ratings@.map(|i: int, x: i8| x as int)) && !all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 1,
        requires_two_contests(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 2
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == x {\n        1 + count_occurrences(s.drop_first(), x)\n    } else {\n        count_occurrences(s.drop_first(), x)\n    }\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.drop_first())\n    }\n}\n\nspec fn valid_input(n: int, ratings: Seq<int>) -> bool {\n    n >= 2 && ratings.len() == n\n}\n\nspec fn all_infected(k: int, ratings: Seq<int>) -> bool {\n    ratings.contains(k) && count_occurrences(ratings, k) == ratings.len()\n}\n\nspec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {\n    (ratings.contains(k) && count_occurrences(ratings, k) != ratings.len()) ||\n    (!ratings.contains(k) && k * ratings.len() == sum(ratings))\n}\n\nspec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {\n    !ratings.contains(k) && k * ratings.len() != sum(ratings)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_case(n: i8, k: i8, ratings: Vec<i8>) -> (answer: i8)\n    requires \n        valid_input(n as int, ratings@.map(|i: int, x: i8| x as int))\n    ensures \n        answer >= 0 && answer <= 2,\n        all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 0,\n        can_infect_in_one_contest(k as int, ratings@.map(|i: int, x: i8| x as int)) && !all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 1,\n        requires_two_contests(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 2\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1985.rs,99,18,0.18181818181818182,154.431,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }
}

spec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int
    recommends 0 <= pos < a.len(), b.len() > 0
{
    b[0] - sum(a.subrange(0, pos + 1))
}

spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>
    recommends 0 <= pos < a.len()
    decreases pos
    when pos >= 0
{
    if pos == 0 { 
        set![score_at_pos] 
    } else { 
        set![score_at_pos].union(compute_backward_scores(pos - 1, score_at_pos - a[pos], a))
    }
}

spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>
    recommends 0 <= pos < a.len()
    decreases a.len() - pos
    when pos < a.len()
{
    if pos == a.len() - 1 { 
        Set::empty() 
    } else { 
        compute_forward_scores(pos + 1, score_at_pos + a[pos + 1], a).insert(score_at_pos + a[pos + 1])
    }
}

spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>
    recommends 0 <= pos < a.len()
{
    let backwards = compute_backward_scores(pos, score_at_pos, a);
    let forwards = compute_forward_scores(pos, score_at_pos, a);
    backwards.union(forwards)
}

spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool
    recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0
{
    let scores = compute_scores(pos, b[0], a);
    forall|j: int| 0 <= j < b.len() ==> #[trigger] scores.contains(b[j])
}

spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>
    recommends 
        k > 0,
        a.len() == k,
        b.len() > 0,
        forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000,
        forall|i: int| 0 <= i < b.len() ==> -4000000 <= #[trigger] b[i] <= 4000000
{
    Set::new(|x: int| exists|i: int| #[trigger] is_valid_initial_score(i, k, a, b) && 0 <= i < k && x == compute_initial_score(i, a, b))
}

spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool
{
    k > 0 && n > 0 && a.len() == k && b.len() == n && n <= k &&
    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] b[i] != #[trigger] b[j]) &&
    (forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000) &&
    (forall|i: int| 0 <= i < n ==> -4000000 <= #[trigger] b[i] <= 4000000)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i8, n: i8, a: Vec<i8>, b: Vec<i8>) -> (result: i8)
    requires
        valid_input(k as int, n as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))
    ensures
        result >= 0,
        result <= k,
        result as int == valid_initial_scores(k as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)).len(),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;
       spec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int     recommends 0 <= pos < a.len(), b.len() > 0 ;
       spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases pos     when pos >= 0 ;
       spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;
       spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;
       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;
       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        
#[trigger] a[i] <= 2000,
;
       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {
         (forall|i: int| 0 <= i < n ==> -4000000 <=        
#[trigger] b[i] <= 4000000)
}
       }
        fn main() {
      }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }\n}\n\nspec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int\n    recommends 0 <= pos < a.len(), b.len() > 0\n{\n    b[0] - sum(a.subrange(0, pos + 1))\n}\n\nspec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n    decreases pos\n    when pos >= 0\n{\n    if pos == 0 { \n        set![score_at_pos] \n    } else { \n        set![score_at_pos].union(compute_backward_scores(pos - 1, score_at_pos - a[pos], a))\n    }\n}\n\nspec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n    decreases a.len() - pos\n    when pos < a.len()\n{\n    if pos == a.len() - 1 { \n        Set::empty() \n    } else { \n        compute_forward_scores(pos + 1, score_at_pos + a[pos + 1], a).insert(score_at_pos + a[pos + 1])\n    }\n}\n\nspec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>\n    recommends 0 <= pos < a.len()\n{\n    let backwards = compute_backward_scores(pos, score_at_pos, a);\n    let forwards = compute_forward_scores(pos, score_at_pos, a);\n    backwards.union(forwards)\n}\n\nspec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool\n    recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0\n{\n    let scores = compute_scores(pos, b[0], a);\n    forall|j: int| 0 <= j < b.len() ==> #[trigger] scores.contains(b[j])\n}\n\nspec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>\n    recommends \n        k > 0,\n        a.len() == k,\n        b.len() > 0,\n        forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000,\n        forall|i: int| 0 <= i < b.len() ==> -4000000 <= #[trigger] b[i] <= 4000000\n{\n    Set::new(|x: int| exists|i: int| #[trigger] is_valid_initial_score(i, k, a, b) && 0 <= i < k && x == compute_initial_score(i, a, b))\n}\n\nspec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool\n{\n    k > 0 && n > 0 && a.len() == k && b.len() == n && n <= k &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] b[i] != #[trigger] b[j]) &&\n    (forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000) &&\n    (forall|i: int| 0 <= i < n ==> -4000000 <= #[trigger] b[i] <= 4000000)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, n: i8, a: Vec<i8>, b: Vec<i8>) -> (result: i8)\n    requires\n        valid_input(k as int, n as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))\n    ensures\n        result >= 0,\n        result <= k,\n        result as int == valid_initial_scores(k as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)).len(),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n       spec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int     recommends 0 <= pos < a.len(), b.len() > 0 ;\n       spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases pos     when pos >= 0 ;\n       spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len()     decreases a.len() - pos     when pos < a.len() ;\n       spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>     recommends 0 <= pos < a.len() ;\n       spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool     recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0 ;\n       spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>     recommends          k > 0,         a.len() == k,         b.len() > 0,         forall|i: int| 0 <= i < k ==> -2000 <=        \n#[trigger] a[i] <= 2000,\n;\n       spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool {\n         (forall|i: int| 0 <= i < n ==> -4000000 <=        \n#[trigger] b[i] <= 4000000)\n}\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n             fn main() {\n   }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_1988.rs,73,73,1.0,92.204,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 2 &&
    (s.last() == '\n' || (s.len() >= 2 && s.subrange(s.len() - 2, s.len() as int) == seq!['\n']))
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() >= 0 &&
    (result.len() == 0 || result.last() == '\n')
}

spec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>
    recommends 1 <= k <= n && input_str.len() == n
{
    let i = k - 1;
    if (n - i) % 2 == 0 {
        input_str.subrange(i, n as int) + input_str.subrange(0, i)
    } else {
        input_str.subrange(i, n as int) + reverse_string(input_str.subrange(0, i))
    }
}

spec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool
    recommends input_str.len() == n
{
    1 <= k <= n &&
    result_str == transform_string(input_str, n, k) &&
    true /* Simplified to avoid trigger issues */
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![] /* TODO: Define line splitting logic */
}

spec fn parse_int(line: Seq<char>) -> int {
    0 /* TODO: Define integer parsing logic */
}

spec fn is_lowercase_letter(c: char) -> bool {
    'a' <= c && c <= 'z'
}

spec fn reverse_string(s: Seq<char>) -> Seq<char> {
    s /* TODO: Define string reversal logic */
}

spec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {
    true /* TODO: Define lexicographic comparison */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: &str) -> (result: String)
  requires valid_input(s@)
  ensures valid_output(result@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 2 &&
    (s.last() == '\n' || (s.len() >= 2 && s.subrange(s.len() - 2, s.len() as int) == seq!['\n']))
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() >= 0 &&
    (result.len() == 0 || result.last() == '\n')
}

spec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>
    recommends 1 <= k <= n && input_str.len() == n
{
    let i = k - 1;
    if (n - i) % 2 == 0 {
        input_str.subrange(i, n as int) + input_str.subrange(0, i)
    } else {
        input_str.subrange(i, n as int) + reverse_string(input_str.subrange(0, i))
    }
}

spec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool
    recommends input_str.len() == n
{
    1 <= k <= n &&
    result_str == transform_string(input_str, n, k) &&
    true /* Simplified to avoid trigger issues */
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![] /* TODO: Define line splitting logic */
}

spec fn parse_int(line: Seq<char>) -> int {
    0 /* TODO: Define integer parsing logic */
}

spec fn is_lowercase_letter(c: char) -> bool {
    'a' <= c && c <= 'z'
}

spec fn reverse_string(s: Seq<char>) -> Seq<char> {
    s /* TODO: Define string reversal logic */
}

spec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {
    true /* TODO: Define lexicographic comparison */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: &str) -> (result: String)
  requires valid_input(s@)
  ensures valid_output(result@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 2 &&\n    (s.last() == '\\n' || (s.len() >= 2 && s.subrange(s.len() - 2, s.len() as int) == seq!['\\n']))\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 0 &&\n    (result.len() == 0 || result.last() == '\\n')\n}\n\nspec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>\n    recommends 1 <= k <= n && input_str.len() == n\n{\n    let i = k - 1;\n    if (n - i) % 2 == 0 {\n        input_str.subrange(i, n as int) + input_str.subrange(0, i)\n    } else {\n        input_str.subrange(i, n as int) + reverse_string(input_str.subrange(0, i))\n    }\n}\n\nspec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool\n    recommends input_str.len() == n\n{\n    1 <= k <= n &&\n    result_str == transform_string(input_str, n, k) &&\n    true /* Simplified to avoid trigger issues */\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![] /* TODO: Define line splitting logic */\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0 /* TODO: Define integer parsing logic */\n}\n\nspec fn is_lowercase_letter(c: char) -> bool {\n    'a' <= c && c <= 'z'\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char> {\n    s /* TODO: Define string reversal logic */\n}\n\nspec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {\n    true /* TODO: Define lexicographic comparison */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n  requires valid_input(s@)\n  ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_199.rs,63,63,1.0,122.551,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {
    n > 0 && v.len() == n && s >= 0 && forall|i: int| 0 <= i < v.len() ==> v[i] >= 0
}

spec fn sum(v: Seq<int>) -> int
    decreases v.len()
{
    if v.len() == 0 {
        0
    } else {
        v[0] + sum(v.subrange(1, v.len() as int))
    }
}

spec fn min_seq(v: Seq<int>) -> int
    recommends v.len() > 0
    decreases v.len()
{
    if v.len() == 1 {
        v[0]
    } else if v.len() > 1 && v[0] <= min_seq(v.subrange(1, v.len() as int)) {
        v[0]
    } else if v.len() > 1 {
        min_seq(v.subrange(1, v.len() as int))
    } else {
        0
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, s: i8, v: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, s as int, v@.map(|i, x| x as int))
    ensures 
        sum(v@.map(|i, x| x as int)) < s as int ==> result == -1,
        sum(v@.map(|i, x| x as int)) >= s as int ==> result == min((sum(v@.map(|i, x| x as int)) - s as int) / n as int, min_seq(v@.map(|i, x| x as int))) as i8,
        result == -1 || result >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {
    n > 0 && v.len() == n && s >= 0 && forall|i: int| 0 <= i < v.len() ==> v[i] >= 0
}

spec fn sum(v: Seq<int>) -> int
    decreases v.len()
{
    if v.len() == 0 {
        0
    } else {
        v[0] + sum(v.subrange(1, v.len() as int))
    }
}

spec fn min_seq(v: Seq<int>) -> int
    recommends v.len() > 0
    decreases v.len()
{
    if v.len() == 1 {
        v[0]
    } else if v.len() > 1 && v[0] <= min_seq(v.subrange(1, v.len() as int)) {
        v[0]
    } else if v.len() > 1 {
        min_seq(v.subrange(1, v.len() as int))
    } else {
        0
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, s: i8, v: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, s as int, v@.map(|i, x| x as int))
    ensures 
        sum(v@.map(|i, x| x as int)) < s as int ==> result == -1,
        sum(v@.map(|i, x| x as int)) >= s as int ==> result == min((sum(v@.map(|i, x| x as int)) - s as int) / n as int, min_seq(v@.map(|i, x| x as int))) as i8,
        result == -1 || result >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {\n    n > 0 && v.len() == n && s >= 0 && forall|i: int| 0 <= i < v.len() ==> v[i] >= 0\n}\n\nspec fn sum(v: Seq<int>) -> int\n    decreases v.len()\n{\n    if v.len() == 0 {\n        0\n    } else {\n        v[0] + sum(v.subrange(1, v.len() as int))\n    }\n}\n\nspec fn min_seq(v: Seq<int>) -> int\n    recommends v.len() > 0\n    decreases v.len()\n{\n    if v.len() == 1 {\n        v[0]\n    } else if v.len() > 1 && v[0] <= min_seq(v.subrange(1, v.len() as int)) {\n        v[0]\n    } else if v.len() > 1 {\n        min_seq(v.subrange(1, v.len() as int))\n    } else {\n        0\n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: i8, v: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, s as int, v@.map(|i, x| x as int))\n    ensures \n        sum(v@.map(|i, x| x as int)) < s as int ==> result == -1,\n        sum(v@.map(|i, x| x as int)) >= s as int ==> result == min((sum(v@.map(|i, x| x as int)) - s as int) / n as int, min_seq(v@.map(|i, x| x as int))) as i8,\n        result == -1 || result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2025.rs,52,52,1.0,122.3,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_composite(x: int) -> bool {
    x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0
}

spec fn valid_input(queries: Seq<int>) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1
}

spec fn max_composite_summands(n: int) -> int {
    if n % 4 == 0 {
        n / 4
    } else if n % 4 == 1 && n / 4 >= 2 {
        n / 4 - 1
    } else if n % 4 == 2 && n / 4 >= 1 {
        n / 4
    } else if n % 4 == 3 && n / 4 >= 3 {
        n / 4 - 1
    } else {
        -1
    }
}

spec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<i8>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i, x: i8| x as int))
    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_composite(x: int) -> bool {
    x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0
}

spec fn valid_input(queries: Seq<int>) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1
}

spec fn max_composite_summands(n: int) -> int {
    if n % 4 == 0 {
        n / 4
    } else if n % 4 == 1 && n / 4 >= 2 {
        n / 4 - 1
    } else if n % 4 == 2 && n / 4 >= 1 {
        n / 4
    } else if n % 4 == 3 && n / 4 >= 3 {
        n / 4 - 1
    } else {
        -1
    }
}

spec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<i8>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i, x: i8| x as int))
    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_composite(x: int) -> bool {\n    x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0\n}\n\nspec fn valid_input(queries: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1\n}\n\nspec fn max_composite_summands(n: int) -> int {\n    if n % 4 == 0 {\n        n / 4\n    } else if n % 4 == 1 && n / 4 >= 2 {\n        n / 4 - 1\n    } else if n % 4 == 2 && n / 4 >= 1 {\n        n / 4\n    } else if n % 4 == 3 && n / 4 >= 3 {\n        n / 4 - 1\n    } else {\n        -1\n    }\n}\n\nspec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i, x: i8| x as int))\n    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_203.rs,53,53,1.0,92.399,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: Seq<char>) -> bool {
    1 <= n <= 200000 && s.len() == n &&
    forall|i: int| 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'
}

spec fn count_d(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == 'D' { 1int } else { 0int }) + count_d(s.subrange(1, s.len() as int)) }
}

spec fn count_r(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == 'R' { 1int } else { 0int }) + count_r(s.subrange(1, s.len() as int)) }
}

spec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {
    if count_d(s) == 0 { seq!['R'] }
    else if count_r(s) == 0 { seq!['D'] }
    else if count_d(s) >= count_r(s) { seq!['D'] }
    else { seq!['R'] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(n as int, s@)
    ensures result@ == optimal_elimination_game_winner(s@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: Seq<char>) -> bool {
    1 <= n <= 200000 && s.len() == n &&
    forall|i: int| 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'
}

spec fn count_d(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == 'D' { 1int } else { 0int }) + count_d(s.subrange(1, s.len() as int)) }
}

spec fn count_r(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == 'R' { 1int } else { 0int }) + count_r(s.subrange(1, s.len() as int)) }
}

spec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {
    if count_d(s) == 0 { seq!['R'] }
    else if count_r(s) == 0 { seq!['D'] }
    else if count_d(s) >= count_r(s) { seq!['D'] }
    else { seq!['R'] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(n as int, s@)
    ensures result@ == optimal_elimination_game_winner(s@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    1 <= n <= 200000 && s.len() == n &&\n    forall|i: int| 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'\n}\n\nspec fn count_d(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'D' { 1int } else { 0int }) + count_d(s.subrange(1, s.len() as int)) }\n}\n\nspec fn count_r(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0int }\n    else { (if s[0] == 'R' { 1int } else { 0int }) + count_r(s.subrange(1, s.len() as int)) }\n}\n\nspec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {\n    if count_d(s) == 0 { seq!['R'] }\n    else if count_r(s) == 0 { seq!['D'] }\n    else if count_d(s) >= count_r(s) { seq!['D'] }\n    else { seq!['R'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(n as int, s@)\n    ensures result@ == optimal_elimination_game_winner(s@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_204.rs,52,52,1.0,92.052,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, x: int, y: int) -> bool {
  a > 0 && b > 0 && x > 0 && y > 0
}

spec fn gcd(a: int, b: int) -> int
  recommends a >= 0 && b >= 0
  decreases b when b >= 0
{
  if b == 0 { a } else { gcd(b, a % b) }
}

spec fn min(a: int, b: int) -> int {
  if a <= b { a } else { b }
}

spec fn expected_result(a: int, b: int, x: int, y: int) -> int
  recommends valid_input(a, b, x, y)
{
  let g = gcd(x, y);
  let x_reduced = x / g;
  let y_reduced = y / g;
  min(a / x_reduced, b / y_reduced)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, x: i8, y: i8) -> (result: i8)
requires 
  valid_input(a as int, b as int, x as int, y as int)
ensures 
  result as int >= 0,
  result as int == expected_result(a as int, b as int, x as int, y as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, x: int, y: int) -> bool {
  a > 0 && b > 0 && x > 0 && y > 0
}

spec fn gcd(a: int, b: int) -> int
  recommends a >= 0 && b >= 0
  decreases b when b >= 0
{
  if b == 0 { a } else { gcd(b, a % b) }
}

spec fn min(a: int, b: int) -> int {
  if a <= b { a } else { b }
}

spec fn expected_result(a: int, b: int, x: int, y: int) -> int
  recommends valid_input(a, b, x, y)
{
  let g = gcd(x, y);
  let x_reduced = x / g;
  let y_reduced = y / g;
  min(a / x_reduced, b / y_reduced)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, x: i8, y: i8) -> (result: i8)
requires 
  valid_input(a as int, b as int, x as int, y as int)
ensures 
  result as int >= 0,
  result as int == expected_result(a as int, b as int, x as int, y as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, x: int, y: int) -> bool {\n  a > 0 && b > 0 && x > 0 && y > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a >= 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn min(a: int, b: int) -> int {\n  if a <= b { a } else { b }\n}\n\nspec fn expected_result(a: int, b: int, x: int, y: int) -> int\n  recommends valid_input(a, b, x, y)\n{\n  let g = gcd(x, y);\n  let x_reduced = x / g;\n  let y_reduced = y / g;\n  min(a / x_reduced, b / y_reduced)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, x: i8, y: i8) -> (result: i8)\nrequires \n  valid_input(a as int, b as int, x as int, y as int)\nensures \n  result as int >= 0,\n  result as int == expected_result(a as int, b as int, x as int, y as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2044.rs,73,73,1.0,123.544,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {
    n >= 1 && m >= 1 && a.len() == n && 
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1)
}

spec fn valid_output(result: Seq<int>, n: int) -> bool {
    result.len() == n && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)
}

spec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int
    recommends m >= 1, i >= 0, s >= 0
{
    if i >= a.len() { 0 }
    else { (s + a[i]) / m }
}

spec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int
    recommends m >= 1, i >= 0, s >= 0
{
    if i >= a.len() { s }
    else { (s + a[i]) % m }
}

spec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool
    recommends m >= 1
{
    result.len() == a.len() &&
    (forall|i: int| 0 <= i < a.len() ==> {
        let s = compute_state_at(a, m, i);
        #[trigger] result[i] == (s + a[i]) / m
    })
}

spec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int
    recommends m >= 1, day >= 0
    decreases day
{
    if day <= 0 { 0 }
    else if day > a.len() { compute_state_at(a, m, a.len() as int) }
    else if day > 0 && day <= a.len() { (compute_state_at(a, m, day - 1) + a[day - 1]) % m }
    else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: Vec<i8>)
requires
    valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int))
ensures
    valid_output(result@.map(|i: int, x: i8| x as int), n as int),
    correct_page_turns(result@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), m as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {
    n >= 1 && m >= 1 && a.len() == n && 
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1)
}

spec fn valid_output(result: Seq<int>, n: int) -> bool {
    result.len() == n && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)
}

spec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int
    recommends m >= 1, i >= 0, s >= 0
{
    if i >= a.len() { 0 }
    else { (s + a[i]) / m }
}

spec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int
    recommends m >= 1, i >= 0, s >= 0
{
    if i >= a.len() { s }
    else { (s + a[i]) % m }
}

spec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool
    recommends m >= 1
{
    result.len() == a.len() &&
    (forall|i: int| 0 <= i < a.len() ==> {
        let s = compute_state_at(a, m, i);
        #[trigger] result[i] == (s + a[i]) / m
    })
}

spec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int
    recommends m >= 1, day >= 0
    decreases day
{
    if day <= 0 { 0 }
    else if day > a.len() { compute_state_at(a, m, a.len() as int) }
    else if day > 0 && day <= a.len() { (compute_state_at(a, m, day - 1) + a[day - 1]) % m }
    else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: Vec<i8>)
requires
    valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int))
ensures
    valid_output(result@.map(|i: int, x: i8| x as int), n as int),
    correct_page_turns(result@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), m as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && a.len() == n && \n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1)\n}\n\nspec fn valid_output(result: Seq<int>, n: int) -> bool {\n    result.len() == n && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)\n}\n\nspec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { 0 }\n    else { (s + a[i]) / m }\n}\n\nspec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int\n    recommends m >= 1, i >= 0, s >= 0\n{\n    if i >= a.len() { s }\n    else { (s + a[i]) % m }\n}\n\nspec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool\n    recommends m >= 1\n{\n    result.len() == a.len() &&\n    (forall|i: int| 0 <= i < a.len() ==> {\n        let s = compute_state_at(a, m, i);\n        #[trigger] result[i] == (s + a[i]) / m\n    })\n}\n\nspec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int\n    recommends m >= 1, day >= 0\n    decreases day\n{\n    if day <= 0 { 0 }\n    else if day > a.len() { compute_state_at(a, m, a.len() as int) }\n    else if day > 0 && day <= a.len() { (compute_state_at(a, m, day - 1) + a[day - 1]) % m }\n    else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: Vec<i8>) -> (result: Vec<i8>)\nrequires\n    valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int))\nensures\n    valid_output(result@.map(|i: int, x: i8| x as int), n as int),\n    correct_page_turns(result@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), m as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n               fn main() {\n     }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2049.rs,54,54,1.0,153.58,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {
  &&& 0 <= l <= r < arr.len()
  &&& if l == r {
    true
  } else {
    exists|k: int| l <= k <= r && 
      is_non_decreasing(arr, l, k) && 
      is_non_increasing(arr, k, r)
  }
}

spec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {
  &&& 0 <= start <= end < arr.len()
  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] <= arr[i+1]
}

spec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {
  &&& 0 <= start <= end < arr.len()
  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] >= arr[i+1]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, arr: Vec<i8>, queries: Vec<(i8, i8)>) -> (results: Vec<Vec<char>>)
  requires 
    n >= 1 && m >= 1,
    arr@.len() == n as int,
    queries@.len() == m as int,
    forall|i: int| 0 <= i < m as int ==> 1 <= #[trigger] queries@[i].0 as int <= queries@[i].1 as int <= n as int,
  ensures 
    results@.len() == m as int,
    forall|i: int| 0 <= i < m as int ==> #[trigger] results@[i]@ == seq!['Y', 'e', 's'] || results@[i]@ == seq!['N', 'o'],
    forall|i: int| 0 <= i < m as int ==> 
      (#[trigger] results@[i]@ == seq!['Y', 'e', 's'] <==> is_ladder(arr@.map(|_i, v| v as int), queries@[i].0 as int - 1, queries@[i].1 as int - 1)),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {
  &&& 0 <= l <= r < arr.len()
  &&& if l == r {
    true
  } else {
    exists|k: int| l <= k <= r && 
      is_non_decreasing(arr, l, k) && 
      is_non_increasing(arr, k, r)
  }
}

spec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {
  &&& 0 <= start <= end < arr.len()
  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] <= arr[i+1]
}

spec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {
  &&& 0 <= start <= end < arr.len()
  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] >= arr[i+1]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, arr: Vec<i8>, queries: Vec<(i8, i8)>) -> (results: Vec<Vec<char>>)
  requires 
    n >= 1 && m >= 1,
    arr@.len() == n as int,
    queries@.len() == m as int,
    forall|i: int| 0 <= i < m as int ==> 1 <= #[trigger] queries@[i].0 as int <= queries@[i].1 as int <= n as int,
  ensures 
    results@.len() == m as int,
    forall|i: int| 0 <= i < m as int ==> #[trigger] results@[i]@ == seq!['Y', 'e', 's'] || results@[i]@ == seq!['N', 'o'],
    forall|i: int| 0 <= i < m as int ==> 
      (#[trigger] results@[i]@ == seq!['Y', 'e', 's'] <==> is_ladder(arr@.map(|_i, v| v as int), queries@[i].0 as int - 1, queries@[i].1 as int - 1)),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {\n  &&& 0 <= l <= r < arr.len()\n  &&& if l == r {\n    true\n  } else {\n    exists|k: int| l <= k <= r && \n      is_non_decreasing(arr, l, k) && \n      is_non_increasing(arr, k, r)\n  }\n}\n\nspec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] <= arr[i+1]\n}\n\nspec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {\n  &&& 0 <= start <= end < arr.len()\n  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] >= arr[i+1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, arr: Vec<i8>, queries: Vec<(i8, i8)>) -> (results: Vec<Vec<char>>)\n  requires \n    n >= 1 && m >= 1,\n    arr@.len() == n as int,\n    queries@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> 1 <= #[trigger] queries@[i].0 as int <= queries@[i].1 as int <= n as int,\n  ensures \n    results@.len() == m as int,\n    forall|i: int| 0 <= i < m as int ==> #[trigger] results@[i]@ == seq!['Y', 'e', 's'] || results@[i]@ == seq!['N', 'o'],\n    forall|i: int| 0 <= i < m as int ==> \n      (#[trigger] results@[i]@ == seq!['Y', 'e', 's'] <==> is_ladder(arr@.map(|_i, v| v as int), queries@[i].0 as int - 1, queries@[i].1 as int - 1)),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n             fn main() {\n   }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2074.rs,69,69,1.0,122.639,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0
}

spec fn seq_min(s: Seq<int>) -> int 
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { 
        s[0]
    } else {
        let tail_min = seq_min(s.drop_first());
        if s[0] <= tail_min { 
            s[0]
        } else { 
            tail_min
        }
    }
}

spec fn seq_max(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { 
        s[0]
    } else {
        let tail_max = seq_max(s.drop_first());
        if s[0] >= tail_max { 
            s[0]
        } else { 
            tail_max
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(grid: Vec<Vec<i8>>) -> (result: i8)
    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))
    ensures ({
        let grid_spec = grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int));
        let row_mins = Seq::new(grid_spec.len(), |i: int| seq_min(grid_spec[i]));
        result as int == seq_max(row_mins)
    })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0
}

spec fn seq_min(s: Seq<int>) -> int 
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { 
        s[0]
    } else {
        let tail_min = seq_min(s.drop_first());
        if s[0] <= tail_min { 
            s[0]
        } else { 
            tail_min
        }
    }
}

spec fn seq_max(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { 
        s[0]
    } else {
        let tail_max = seq_max(s.drop_first());
        if s[0] >= tail_max { 
            s[0]
        } else { 
            tail_max
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(grid: Vec<Vec<i8>>) -> (result: i8)
    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))
    ensures ({
        let grid_spec = grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int));
        let row_mins = Seq::new(grid_spec.len(), |i: int| seq_min(grid_spec[i]));
        result as int == seq_max(row_mins)
    })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0\n}\n\nspec fn seq_min(s: Seq<int>) -> int \n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_min = seq_min(s.drop_first());\n        if s[0] <= tail_min { \n            s[0]\n        } else { \n            tail_min\n        }\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { \n        s[0]\n    } else {\n        let tail_max = seq_max(s.drop_first());\n        if s[0] >= tail_max { \n            s[0]\n        } else { \n            tail_max\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(grid: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures ({\n        let grid_spec = grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int));\n        let row_mins = Seq::new(grid_spec.len(), |i: int| seq_min(grid_spec[i]));\n        result as int == seq_max(row_mins)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_208.rs,73,73,1.0,185.246,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {
    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100
}

spec fn int_abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 != y2 && int_abs(x1 - x2) != int_abs(y1 - y2)
}

spec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 != y2 && int_abs(x1 - x2) == int_abs(y1 - y2)
}

spec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 == x2
}

spec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 == y2
}

spec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1, y2, x2, y1]
}

spec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1 + int_abs(y2 - y1), y1, x1 + int_abs(y2 - y1), y2]
}

spec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1, y1 + int_abs(x2 - x1), x2, y1 + int_abs(x2 - x1)]
}

spec fn valid_output(result: Seq<int>) -> bool {
    (result.len() == 1 && result[0] == -1) ||
    (result.len() == 4 && (forall|i: int| #![trigger result[i]] 0 <= i < 4 ==> -1000 <= result[i] <= 1000))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)
    requires 
        valid_input(x1 as int, y1 as int, x2 as int, y2 as int)
    ensures 
        valid_output(result@.map(|i, v| v as int)),
        is_invalid_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == seq![-1],
        is_diagonal_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_diagonal_result(x1 as int, y1 as int, x2 as int, y2 as int),
        is_vertical_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_vertical_result(x1 as int, y1 as int, x2 as int, y2 as int),
        is_horizontal_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_horizontal_result(x1 as int, y1 as int, x2 as int, y2 as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {
    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100
}

spec fn int_abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 != y2 && int_abs(x1 - x2) != int_abs(y1 - y2)
}

spec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 != y2 && int_abs(x1 - x2) == int_abs(y1 - y2)
}

spec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 == x2
}

spec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 == y2
}

spec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1, y2, x2, y1]
}

spec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1 + int_abs(y2 - y1), y1, x1 + int_abs(y2 - y1), y2]
}

spec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1, y1 + int_abs(x2 - x1), x2, y1 + int_abs(x2 - x1)]
}

spec fn valid_output(result: Seq<int>) -> bool {
    (result.len() == 1 && result[0] == -1) ||
    (result.len() == 4 && (forall|i: int| #![trigger result[i]] 0 <= i < 4 ==> -1000 <= result[i] <= 1000))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)
    requires 
        valid_input(x1 as int, y1 as int, x2 as int, y2 as int)
    ensures 
        valid_output(result@.map(|i, v| v as int)),
        is_invalid_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == seq![-1],
        is_diagonal_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_diagonal_result(x1 as int, y1 as int, x2 as int, y2 as int),
        is_vertical_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_vertical_result(x1 as int, y1 as int, x2 as int, y2 as int),
        is_horizontal_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_horizontal_result(x1 as int, y1 as int, x2 as int, y2 as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {\n    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100\n}\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) != int_abs(y1 - y2)\n}\n\nspec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 != y2 && int_abs(x1 - x2) == int_abs(y1 - y2)\n}\n\nspec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 == x2\n}\n\nspec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {\n    x1 != x2 && y1 == y2\n}\n\nspec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y2, x2, y1]\n}\n\nspec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1 + int_abs(y2 - y1), y1, x1 + int_abs(y2 - y1), y2]\n}\n\nspec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {\n    seq![x1, y1 + int_abs(x2 - x1), x2, y1 + int_abs(x2 - x1)]\n}\n\nspec fn valid_output(result: Seq<int>) -> bool {\n    (result.len() == 1 && result[0] == -1) ||\n    (result.len() == 4 && (forall|i: int| #![trigger result[i]] 0 <= i < 4 ==> -1000 <= result[i] <= 1000))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(x1 as int, y1 as int, x2 as int, y2 as int)\n    ensures \n        valid_output(result@.map(|i, v| v as int)),\n        is_invalid_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == seq![-1],\n        is_diagonal_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_diagonal_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_vertical_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_vertical_result(x1 as int, y1 as int, x2 as int, y2 as int),\n        is_horizontal_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_horizontal_result(x1 as int, y1 as int, x2 as int, y2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2080.rs,74,74,1.0,122.212,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    1 <= n <= 2000000000
}

spec fn valid_output(n: int, result: int) -> bool {
    result >= 0 &&
    result >= n - 1 &&
    result <= n * (n - 1) / 2
}

spec fn compute_expected_result(n: int) -> int {
    let quad_solv_numerator = isqrt(8*n + 1) - 1;
    let x = quad_solv_numerator / 2;
    let y = x + 1;
    let xed = x * (x - 1) / 2 + n - x;
    let ybr = n - y;
    let yed = 2 * ybr;
    if xed > yed { xed } else { yed }
}

spec fn isqrt(n: int) -> int {
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else if n <= 3 { 1 }
    else {
        let guess = n / 2;
        let low = 0;
        let high = guess + 1;
        isqrt_helper(n, low, high)
    }
}

spec fn isqrt_helper(n: int, low: int, high: int) -> int
    decreases high - low
{
    if high - low <= 1 { low }
    else {
        let mid = (low + high) / 2;
        if mid * mid <= n {
            isqrt_helper(n, mid, high)
        } else {
            isqrt_helper(n, low, mid)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int),
    ensures
        valid_output(n as int, result as int),
        result as int == compute_expected_result(n as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    1 <= n <= 2000000000
}

spec fn valid_output(n: int, result: int) -> bool {
    result >= 0 &&
    result >= n - 1 &&
    result <= n * (n - 1) / 2
}

spec fn compute_expected_result(n: int) -> int {
    let quad_solv_numerator = isqrt(8*n + 1) - 1;
    let x = quad_solv_numerator / 2;
    let y = x + 1;
    let xed = x * (x - 1) / 2 + n - x;
    let ybr = n - y;
    let yed = 2 * ybr;
    if xed > yed { xed } else { yed }
}

spec fn isqrt(n: int) -> int {
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else if n <= 3 { 1 }
    else {
        let guess = n / 2;
        let low = 0;
        let high = guess + 1;
        isqrt_helper(n, low, high)
    }
}

spec fn isqrt_helper(n: int, low: int, high: int) -> int
    decreases high - low
{
    if high - low <= 1 { low }
    else {
        let mid = (low + high) / 2;
        if mid * mid <= n {
            isqrt_helper(n, mid, high)
        } else {
            isqrt_helper(n, low, mid)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int),
    ensures
        valid_output(n as int, result as int),
        result as int == compute_expected_result(n as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 2000000000\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    result >= 0 &&\n    result >= n - 1 &&\n    result <= n * (n - 1) / 2\n}\n\nspec fn compute_expected_result(n: int) -> int {\n    let quad_solv_numerator = isqrt(8*n + 1) - 1;\n    let x = quad_solv_numerator / 2;\n    let y = x + 1;\n    let xed = x * (x - 1) / 2 + n - x;\n    let ybr = n - y;\n    let yed = 2 * ybr;\n    if xed > yed { xed } else { yed }\n}\n\nspec fn isqrt(n: int) -> int {\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n <= 3 { 1 }\n    else {\n        let guess = n / 2;\n        let low = 0;\n        let high = guess + 1;\n        isqrt_helper(n, low, high)\n    }\n}\n\nspec fn isqrt_helper(n: int, low: int, high: int) -> int\n    decreases high - low\n{\n    if high - low <= 1 { low }\n    else {\n        let mid = (low + high) / 2;\n        if mid * mid <= n {\n            isqrt_helper(n, mid, high)\n        } else {\n            isqrt_helper(n, low, mid)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int),\n    ensures\n        valid_output(n as int, result as int),\n        result as int == compute_expected_result(n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2104.rs,94,94,1.0,184.315,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(l: int, r: int) -> bool {
    l < r && (r - l) % 2 == 1
}

spec fn gcd(a: int, b: int) -> int
    recommends a != 0 || b != 0
    decreases (if a >= 0 { a } else { -a })
{
    if a == 0 {
        if b >= 0 { b } else { -b }
    } else {
        gcd(b % a, a)
    }
}

spec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {
    exists|i: int, j: int| l <= i <= r && l <= j <= r && i != j &&
        pair == int_to_string(i).add(seq![' ']).add(int_to_string(j)) &&
        (i != 0 || j != 0) && gcd(i, j) == 1
}

spec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {
    result.len() >= 1 &&
    result[0] == seq!['Y', 'E', 'S'] &&
    result.len() == 1 + (r - l + 1) / 2 &&
    (forall|i: int| 1 <= i < result.len() ==> pair_has_gcd_one(result[i], l, r))
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_pos(n)
    } else {
        seq!['-'].add(int_to_string_pos(-n))
    }
}

spec fn int_to_string_pos(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![char_from_digit(n)]
    } else {
        int_to_string_pos(n / 10).push(char_from_digit(n % 10))
    }
}

spec fn char_from_digit(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else if d == 9 { '9' }
    else { '0' }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(l: i8, r: i8) -> (result: Vec<Vec<char>>)
    requires valid_input(l as int, r as int)
    ensures
        result.len() >= 1,
        result[0]@ == seq!['Y', 'E', 'S'],
        result.len() == 1 + (r as int - l as int + 1) / 2,
        forall|i: int| 1 <= i < result.len() ==> 
            #[trigger] result[i]@ == int_to_string(l as int + 2 * (i - 1)).add(seq![' ']).add(int_to_string(l as int + 2 * (i - 1) + 1))
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(l: int, r: int) -> bool {
    l < r && (r - l) % 2 == 1
}

spec fn gcd(a: int, b: int) -> int
    recommends a != 0 || b != 0
    decreases (if a >= 0 { a } else { -a })
{
    if a == 0 {
        if b >= 0 { b } else { -b }
    } else {
        gcd(b % a, a)
    }
}

spec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {
    exists|i: int, j: int| l <= i <= r && l <= j <= r && i != j &&
        pair == int_to_string(i).add(seq![' ']).add(int_to_string(j)) &&
        (i != 0 || j != 0) && gcd(i, j) == 1
}

spec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {
    result.len() >= 1 &&
    result[0] == seq!['Y', 'E', 'S'] &&
    result.len() == 1 + (r - l + 1) / 2 &&
    (forall|i: int| 1 <= i < result.len() ==> pair_has_gcd_one(result[i], l, r))
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_pos(n)
    } else {
        seq!['-'].add(int_to_string_pos(-n))
    }
}

spec fn int_to_string_pos(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![char_from_digit(n)]
    } else {
        int_to_string_pos(n / 10).push(char_from_digit(n % 10))
    }
}

spec fn char_from_digit(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else if d == 9 { '9' }
    else { '0' }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(l: i8, r: i8) -> (result: Vec<Vec<char>>)
    requires valid_input(l as int, r as int)
    ensures
        result.len() >= 1,
        result[0]@ == seq!['Y', 'E', 'S'],
        result.len() == 1 + (r as int - l as int + 1) / 2,
        forall|i: int| 1 <= i < result.len() ==> 
            #[trigger] result[i]@ == int_to_string(l as int + 2 * (i - 1)).add(seq![' ']).add(int_to_string(l as int + 2 * (i - 1) + 1))
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(l: int, r: int) -> bool {\n    l < r && (r - l) % 2 == 1\n}\n\nspec fn gcd(a: int, b: int) -> int\n    recommends a != 0 || b != 0\n    decreases (if a >= 0 { a } else { -a })\n{\n    if a == 0 {\n        if b >= 0 { b } else { -b }\n    } else {\n        gcd(b % a, a)\n    }\n}\n\nspec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {\n    exists|i: int, j: int| l <= i <= r && l <= j <= r && i != j &&\n        pair == int_to_string(i).add(seq![' ']).add(int_to_string(j)) &&\n        (i != 0 || j != 0) && gcd(i, j) == 1\n}\n\nspec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {\n    result.len() >= 1 &&\n    result[0] == seq!['Y', 'E', 'S'] &&\n    result.len() == 1 + (r - l + 1) / 2 &&\n    (forall|i: int| 1 <= i < result.len() ==> pair_has_gcd_one(result[i], l, r))\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_pos(n)\n    } else {\n        seq!['-'].add(int_to_string_pos(-n))\n    }\n}\n\nspec fn int_to_string_pos(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![char_from_digit(n)]\n    } else {\n        int_to_string_pos(n / 10).push(char_from_digit(n % 10))\n    }\n}\n\nspec fn char_from_digit(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else if d == 9 { '9' }\n    else { '0' }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(l: i8, r: i8) -> (result: Vec<Vec<char>>)\n    requires valid_input(l as int, r as int)\n    ensures\n        result.len() >= 1,\n        result[0]@ == seq!['Y', 'E', 'S'],\n        result.len() == 1 + (r as int - l as int + 1) / 2,\n        forall|i: int| 1 <= i < result.len() ==> \n            #[trigger] result[i]@ == int_to_string(l as int + 2 * (i - 1)).add(seq![' ']).add(int_to_string(l as int + 2 * (i - 1) + 1))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2123.rs,56,56,1.0,154.362,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n > 0 && heights.len() == n
}

spec fn max_in_seq(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    via max_in_seq_decreases
{
    if s.len() == 1 {
        s[0]
    } else {
        let tail = s.subrange(1, s.len() as int);
        let tail_max = max_in_seq(tail);
        if s[0] >= tail_max { s[0] } else { tail_max }
    }
}

#[via_fn]
proof fn max_in_seq_decreases(s: Seq<int>) {
    assume(false);
}

spec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool
    recommends valid_input(n, heights)
{
    result == max_in_seq(heights) &&
    forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&
    exists|i: int| 0 <= i < heights.len() && heights[i] == result
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, heights: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))
    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n > 0 && heights.len() == n
}

spec fn max_in_seq(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    via max_in_seq_decreases
{
    if s.len() == 1 {
        s[0]
    } else {
        let tail = s.subrange(1, s.len() as int);
        let tail_max = max_in_seq(tail);
        if s[0] >= tail_max { s[0] } else { tail_max }
    }
}

#[via_fn]
proof fn max_in_seq_decreases(s: Seq<int>) {
    assume(false);
}

spec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool
    recommends valid_input(n, heights)
{
    result == max_in_seq(heights) &&
    forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&
    exists|i: int| 0 <= i < heights.len() && heights[i] == result
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, heights: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))
    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    via max_in_seq_decreases\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        let tail = s.subrange(1, s.len() as int);\n        let tail_max = max_in_seq(tail);\n        if s[0] >= tail_max { s[0] } else { tail_max }\n    }\n}\n\n#[via_fn]\nproof fn max_in_seq_decreases(s: Seq<int>) {\n    assume(false);\n}\n\nspec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool\n    recommends valid_input(n, heights)\n{\n    result == max_in_seq(heights) &&\n    forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&\n    exists|i: int| 0 <= i < heights.len() && heights[i] == result\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))\n    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_217.rs,62,62,1.0,122.52,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, f: int, k: int) -> bool {
  a > 0 && b > 0 && f > 0 && k > 0 && f < a
}

spec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {
  b < f ||                                    
  b < a - f ||                               
  (k > 1 && b < 2 * a - f) ||               
  (k == 1 && b < a && b < f)                
}

spec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {
  b >= f &&                                  
  b >= a - f &&                             
  (k <= 1 || b >= 2 * a - f) &&            
  (k == 1 ==> (b >= a || b >= f))          
}

spec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {
  k == 1 && result >= 0 ==> (
    (b >= a && result == 0) ||                
    (b < a && b >= f && result == 1)          
  )
}

spec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {
  k > 1 && result >= 0 ==> (
    b >= f && b >= a - f && b >= 2 * a - f    
  )
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, f: i8, k: i8) -> (result: i8)
  requires
    valid_input(a as int, b as int, f as int, k as int)
  ensures
    result as int >= -1 &&
    ((result as int == -1) <==> impossible_conditions(a as int, b as int, f as int, k as int)) &&
    (result as int >= 0 ==> result as int <= k as int) &&
    (result as int >= 0 ==> feasibility_conditions(a as int, b as int, f as int, k as int)) &&
    single_journey_result(a as int, b as int, f as int, k as int, result as int) &&
    multi_journey_feasibility(a as int, b as int, f as int, k as int, result as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, f: int, k: int) -> bool {
  a > 0 && b > 0 && f > 0 && k > 0 && f < a
}

spec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {
  b < f ||                                    
  b < a - f ||                               
  (k > 1 && b < 2 * a - f) ||               
  (k == 1 && b < a && b < f)                
}

spec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {
  b >= f &&                                  
  b >= a - f &&                             
  (k <= 1 || b >= 2 * a - f) &&            
  (k == 1 ==> (b >= a || b >= f))          
}

spec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {
  k == 1 && result >= 0 ==> (
    (b >= a && result == 0) ||                
    (b < a && b >= f && result == 1)          
  )
}

spec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {
  k > 1 && result >= 0 ==> (
    b >= f && b >= a - f && b >= 2 * a - f    
  )
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, f: i8, k: i8) -> (result: i8)
  requires
    valid_input(a as int, b as int, f as int, k as int)
  ensures
    result as int >= -1 &&
    ((result as int == -1) <==> impossible_conditions(a as int, b as int, f as int, k as int)) &&
    (result as int >= 0 ==> result as int <= k as int) &&
    (result as int >= 0 ==> feasibility_conditions(a as int, b as int, f as int, k as int)) &&
    single_journey_result(a as int, b as int, f as int, k as int, result as int) &&
    multi_journey_feasibility(a as int, b as int, f as int, k as int, result as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, f: int, k: int) -> bool {\n  a > 0 && b > 0 && f > 0 && k > 0 && f < a\n}\n\nspec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b < f ||                                    \n  b < a - f ||                               \n  (k > 1 && b < 2 * a - f) ||               \n  (k == 1 && b < a && b < f)                \n}\n\nspec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {\n  b >= f &&                                  \n  b >= a - f &&                             \n  (k <= 1 || b >= 2 * a - f) &&            \n  (k == 1 ==> (b >= a || b >= f))          \n}\n\nspec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k == 1 && result >= 0 ==> (\n    (b >= a && result == 0) ||                \n    (b < a && b >= f && result == 1)          \n  )\n}\n\nspec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {\n  k > 1 && result >= 0 ==> (\n    b >= f && b >= a - f && b >= 2 * a - f    \n  )\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, f: i8, k: i8) -> (result: i8)\n  requires\n    valid_input(a as int, b as int, f as int, k as int)\n  ensures\n    result as int >= -1 &&\n    ((result as int == -1) <==> impossible_conditions(a as int, b as int, f as int, k as int)) &&\n    (result as int >= 0 ==> result as int <= k as int) &&\n    (result as int >= 0 ==> feasibility_conditions(a as int, b as int, f as int, k as int)) &&\n    single_journey_result(a as int, b as int, f as int, k as int, result as int) &&\n    multi_journey_feasibility(a as int, b as int, f as int, k as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2209.rs,91,91,1.0,123.209,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<Seq<char>>) -> bool {
    input.len() >= 1 &&
    (forall|i: int| 0 <= i < input[0].len() ==> #[trigger] input[0][i] == input[0][i] && '0' <= input[0][i] <= '9') &&
    {
        let n = string_to_int(input[0]);
        n >= 1 && input.len() >= n + 1 &&
        forall|i: int| 1 <= i <= n ==> #[trigger] input[i] == input[i] && (input[i].len() > 0 &&
            forall|j: int| 0 <= j < input[i].len() ==> #[trigger] input[i][j] == input[i][j] && (input[i][j] == 's' || input[i][j] == 'h'))
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { string_to_int(s.subrange(0, s.len() as int - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) }
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }
}

spec fn count_sh_subsequences(s: Seq<char>) -> int {
    count_sh_subsequences_helper(s, 0, 0)
}

spec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int
    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0
{
    if index == s.len() { 0 }
    else if index < s.len() && s[index] == 's' {
        count_sh_subsequences_helper(s, index + 1, s_count + 1)
    } else if index < s.len() && s[index] == 'h' {
        s_count + count_sh_subsequences_helper(s, index + 1, s_count)
    } else {
        count_sh_subsequences_helper(s, index + 1, s_count)
    }
}

spec fn string_ratio(s: Seq<char>) -> int {
    if s.len() == 0 { 0 } else { count_char(s, 's') * 1000 / s.len() as int }
}

spec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>
    decreases strings.len()
{
    if strings.len() == 0 { Seq::empty() }
    else { strings[0] + concatenate_strings(strings.subrange(1, strings.len() as int)) }
}

spec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {
    forall|i: int, j: int| 0 <= i < j < strings.len() ==> 
        #[trigger] strings[i] == strings[i] && #[trigger] strings[j] == strings[j] &&
        strings[i].len() > 0 && strings[j].len() > 0 ==> 
        string_ratio(strings[i]) <= string_ratio(strings[j])
}

spec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {
    arranged.len() == original.len() &&
    forall|s: Seq<char>| #[trigger] original.contains(s) <==> arranged.contains(s)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<Vec<char>>) -> (result: i32)
    requires valid_input(input@.map(|i, v: Vec<char>| v@))
    ensures result >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    0
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<Seq<char>>) -> bool {
    input.len() >= 1 &&
    (forall|i: int| 0 <= i < input[0].len() ==> #[trigger] input[0][i] == input[0][i] && '0' <= input[0][i] <= '9') &&
    {
        let n = string_to_int(input[0]);
        n >= 1 && input.len() >= n + 1 &&
        forall|i: int| 1 <= i <= n ==> #[trigger] input[i] == input[i] && (input[i].len() > 0 &&
            forall|j: int| 0 <= j < input[i].len() ==> #[trigger] input[i][j] == input[i][j] && (input[i][j] == 's' || input[i][j] == 'h'))
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { string_to_int(s.subrange(0, s.len() as int - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) }
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }
}

spec fn count_sh_subsequences(s: Seq<char>) -> int {
    count_sh_subsequences_helper(s, 0, 0)
}

spec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int
    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0
{
    if index == s.len() { 0 }
    else if index < s.len() && s[index] == 's' {
        count_sh_subsequences_helper(s, index + 1, s_count + 1)
    } else if index < s.len() && s[index] == 'h' {
        s_count + count_sh_subsequences_helper(s, index + 1, s_count)
    } else {
        count_sh_subsequences_helper(s, index + 1, s_count)
    }
}

spec fn string_ratio(s: Seq<char>) -> int {
    if s.len() == 0 { 0 } else { count_char(s, 's') * 1000 / s.len() as int }
}

spec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>
    decreases strings.len()
{
    if strings.len() == 0 { Seq::empty() }
    else { strings[0] + concatenate_strings(strings.subrange(1, strings.len() as int)) }
}

spec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {
    forall|i: int, j: int| 0 <= i < j < strings.len() ==> 
        #[trigger] strings[i] == strings[i] && #[trigger] strings[j] == strings[j] &&
        strings[i].len() > 0 && strings[j].len() > 0 ==> 
        string_ratio(strings[i]) <= string_ratio(strings[j])
}

spec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {
    arranged.len() == original.len() &&
    forall|s: Seq<char>| #[trigger] original.contains(s) <==> arranged.contains(s)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<Vec<char>>) -> (result: i32)
    requires valid_input(input@.map(|i, v: Vec<char>| v@))
    ensures result >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    0
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<Seq<char>>) -> bool {\n    input.len() >= 1 &&\n    (forall|i: int| 0 <= i < input[0].len() ==> #[trigger] input[0][i] == input[0][i] && '0' <= input[0][i] <= '9') &&\n    {\n        let n = string_to_int(input[0]);\n        n >= 1 && input.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n ==> #[trigger] input[i] == input[i] && (input[i].len() > 0 &&\n            forall|j: int| 0 <= j < input[i].len() ==> #[trigger] input[i][j] == input[i][j] && (input[i][j] == 's' || input[i][j] == 'h'))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { string_to_int(s.subrange(0, s.len() as int - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }\n}\n\nspec fn count_sh_subsequences(s: Seq<char>) -> int {\n    count_sh_subsequences_helper(s, 0, 0)\n}\n\nspec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int\n    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0\n{\n    if index == s.len() { 0 }\n    else if index < s.len() && s[index] == 's' {\n        count_sh_subsequences_helper(s, index + 1, s_count + 1)\n    } else if index < s.len() && s[index] == 'h' {\n        s_count + count_sh_subsequences_helper(s, index + 1, s_count)\n    } else {\n        count_sh_subsequences_helper(s, index + 1, s_count)\n    }\n}\n\nspec fn string_ratio(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 } else { count_char(s, 's') * 1000 / s.len() as int }\n}\n\nspec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>\n    decreases strings.len()\n{\n    if strings.len() == 0 { Seq::empty() }\n    else { strings[0] + concatenate_strings(strings.subrange(1, strings.len() as int)) }\n}\n\nspec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < strings.len() ==> \n        #[trigger] strings[i] == strings[i] && #[trigger] strings[j] == strings[j] &&\n        strings[i].len() > 0 && strings[j].len() > 0 ==> \n        string_ratio(strings[i]) <= string_ratio(strings[j])\n}\n\nspec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {\n    arranged.len() == original.len() &&\n    forall|s: Seq<char>| #[trigger] original.contains(s) <==> arranged.contains(s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<Vec<char>>) -> (result: i32)\n    requires valid_input(input@.map(|i, v: Vec<char>| v@))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_222.rs,71,71,1.0,122.691,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn generate_squares() -> Seq<int> {
    generate_squares_helper(1, 44721)
}

spec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {
    is_subsequence_helper(pattern, text, 0, 0)
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n) }
}

spec fn generate_squares_helper(start: int, end: int) -> Seq<int>
    decreases end + 1 - start when start <= end
{
    if start > end { Seq::empty() }
    else { seq![start * start].add(generate_squares_helper(start + 1, end)) }
}

spec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool
    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()
{
    if pi >= pattern.len() { true }
    else if ti >= text.len() { false }
    else if pattern[pi] == text[ti] { 
        is_subsequence_helper(pattern, text, pi + 1, ti + 1)
    } else {
        is_subsequence_helper(pattern, text, pi, ti + 1)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n when n > 0
{
    if n < 10 { seq![('0' as u8 + (n % 10) as u8) as char] }
    else { int_to_string_helper(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char]) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i32)
    requires 
        s.len() > 0,
        forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s@[i] <= '9',
        s@[0] != '0' || s.len() == 1,
    ensures 
        result == -1 || result >= 0,
        result == -1 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) ==> !is_subsequence(int_to_string(sq), s@),
        result >= 0 ==> exists|sq: int| #![auto] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) && result == s.len() as i32 - int_to_string(sq).len() as i32,
        result >= 0 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) ==> s.len() as i32 - int_to_string(sq).len() as i32 >= result,
// </vc-spec>
// <vc-code>
{
    assume(false);
    -1
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn generate_squares() -> Seq<int> {
    generate_squares_helper(1, 44721)
}

spec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {
    is_subsequence_helper(pattern, text, 0, 0)
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n) }
}

spec fn generate_squares_helper(start: int, end: int) -> Seq<int>
    decreases end + 1 - start when start <= end
{
    if start > end { Seq::empty() }
    else { seq![start * start].add(generate_squares_helper(start + 1, end)) }
}

spec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool
    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()
{
    if pi >= pattern.len() { true }
    else if ti >= text.len() { false }
    else if pattern[pi] == text[ti] { 
        is_subsequence_helper(pattern, text, pi + 1, ti + 1)
    } else {
        is_subsequence_helper(pattern, text, pi, ti + 1)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n when n > 0
{
    if n < 10 { seq![('0' as u8 + (n % 10) as u8) as char] }
    else { int_to_string_helper(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char]) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i32)
    requires 
        s.len() > 0,
        forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s@[i] <= '9',
        s@[0] != '0' || s.len() == 1,
    ensures 
        result == -1 || result >= 0,
        result == -1 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) ==> !is_subsequence(int_to_string(sq), s@),
        result >= 0 ==> exists|sq: int| #![auto] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) && result == s.len() as i32 - int_to_string(sq).len() as i32,
        result >= 0 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) ==> s.len() as i32 - int_to_string(sq).len() as i32 >= result,
// </vc-spec>
// <vc-code>
{
    assume(false);
    -1
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn generate_squares() -> Seq<int> {\n    generate_squares_helper(1, 44721)\n}\n\nspec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {\n    is_subsequence_helper(pattern, text, 0, 0)\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n) }\n}\n\nspec fn generate_squares_helper(start: int, end: int) -> Seq<int>\n    decreases end + 1 - start when start <= end\n{\n    if start > end { Seq::empty() }\n    else { seq![start * start].add(generate_squares_helper(start + 1, end)) }\n}\n\nspec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool\n    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()\n{\n    if pi >= pattern.len() { true }\n    else if ti >= text.len() { false }\n    else if pattern[pi] == text[ti] { \n        is_subsequence_helper(pattern, text, pi + 1, ti + 1)\n    } else {\n        is_subsequence_helper(pattern, text, pi, ti + 1)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n > 0\n{\n    if n < 10 { seq![('0' as u8 + (n % 10) as u8) as char] }\n    else { int_to_string_helper(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char]) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i32)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s@[i] <= '9',\n        s@[0] != '0' || s.len() == 1,\n    ensures \n        result == -1 || result >= 0,\n        result == -1 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) ==> !is_subsequence(int_to_string(sq), s@),\n        result >= 0 ==> exists|sq: int| #![auto] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) && result == s.len() as i32 - int_to_string(sq).len() as i32,\n        result >= 0 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) ==> s.len() as i32 - int_to_string(sq).len() as i32 >= result,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2220.rs,79,79,1.0,122.73,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {
    n >= 2 && k >= 1 && m >= 1 && emotes.len() == n &&
    forall|i: int| 0 <= i < emotes.len() ==> emotes[i] >= 1
}

spec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {
    let k_plus_1 = k + 1;
    let total = m / k_plus_1;
    let remainder = m % k_plus_1;

    let max_val = max_value(emotes);
    let second_max_val = second_max_value(emotes);
    remainder * max_val + max_val * (total * k) + second_max_val * total
}

spec fn max_value(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 1 {
        s[0]
    } else if s.len() > 1 && s[0] >= max_value(s.skip(1)) {
        s[0]
    } else if s.len() > 1 {
        max_value(s.skip(1))
    } else {
        s[0]
    }
}

spec fn second_max_value(s: Seq<int>) -> int {
    let max_val = max_value(s);
    let filtered = filter_out(s, max_val, 1);
    if filtered.len() > 0 {
        max_value(filtered)
    } else {
        1
    }
}

spec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>
    decreases s.len(), count
{
    if s.len() == 0 || count == 0 {
        s
    } else if s[0] == val {
        filter_out(s.skip(1), val, count - 1)
    } else {
        seq![s[0]].add(filter_out(s.skip(1), val, count))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8, emotes: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, k as int, 
            seq![].add(emotes@.map(|i: int, x: i8| x as int)))
    ensures result >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {
    n >= 2 && k >= 1 && m >= 1 && emotes.len() == n &&
    forall|i: int| 0 <= i < emotes.len() ==> emotes[i] >= 1
}

spec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {
    let k_plus_1 = k + 1;
    let total = m / k_plus_1;
    let remainder = m % k_plus_1;

    let max_val = max_value(emotes);
    let second_max_val = second_max_value(emotes);
    remainder * max_val + max_val * (total * k) + second_max_val * total
}

spec fn max_value(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 1 {
        s[0]
    } else if s.len() > 1 && s[0] >= max_value(s.skip(1)) {
        s[0]
    } else if s.len() > 1 {
        max_value(s.skip(1))
    } else {
        s[0]
    }
}

spec fn second_max_value(s: Seq<int>) -> int {
    let max_val = max_value(s);
    let filtered = filter_out(s, max_val, 1);
    if filtered.len() > 0 {
        max_value(filtered)
    } else {
        1
    }
}

spec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>
    decreases s.len(), count
{
    if s.len() == 0 || count == 0 {
        s
    } else if s[0] == val {
        filter_out(s.skip(1), val, count - 1)
    } else {
        seq![s[0]].add(filter_out(s.skip(1), val, count))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8, emotes: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, k as int, 
            seq![].add(emotes@.map(|i: int, x: i8| x as int)))
    ensures result >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {\n    n >= 2 && k >= 1 && m >= 1 && emotes.len() == n &&\n    forall|i: int| 0 <= i < emotes.len() ==> emotes[i] >= 1\n}\n\nspec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {\n    let k_plus_1 = k + 1;\n    let total = m / k_plus_1;\n    let remainder = m % k_plus_1;\n\n    let max_val = max_value(emotes);\n    let second_max_val = second_max_value(emotes);\n    remainder * max_val + max_val * (total * k) + second_max_val * total\n}\n\nspec fn max_value(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] >= max_value(s.skip(1)) {\n        s[0]\n    } else if s.len() > 1 {\n        max_value(s.skip(1))\n    } else {\n        s[0]\n    }\n}\n\nspec fn second_max_value(s: Seq<int>) -> int {\n    let max_val = max_value(s);\n    let filtered = filter_out(s, max_val, 1);\n    if filtered.len() > 0 {\n        max_value(filtered)\n    } else {\n        1\n    }\n}\n\nspec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>\n    decreases s.len(), count\n{\n    if s.len() == 0 || count == 0 {\n        s\n    } else if s[0] == val {\n        filter_out(s.skip(1), val, count - 1)\n    } else {\n        seq![s[0]].add(filter_out(s.skip(1), val, count))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, emotes: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, k as int, \n            seq![].add(emotes@.map(|i: int, x: i8| x as int)))\n    ensures result >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2238.rs,64,64,1.0,154.073,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 3 && n <= 101 && n % 2 == 1
}

spec fn valid_result(result: Seq<String>, n: int) -> bool {
    result.len() == n &&
    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() == n
}

spec fn repeat_char(c: char, count: int) -> Seq<char>
    decreases count
{
    if count <= 0 { Seq::empty() }
    else { repeat_char(c, count - 1).push(c) }
}

spec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {
    result.len() == n ==> {
        let magic = (n - 1) / 2;
        
        (forall|i: int| 0 <= i <= magic && i < result.len() ==> {
            let stars = magic - i;
            let diamonds = n - 2 * stars;
            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)
        }) &&
        
        (forall|i: int| magic + 1 <= i < n && i < result.len() ==> {
            let u = i - magic;
            let stars = u;
            let diamonds = n - 2 * stars;
            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)
        })
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize) -> (result: Vec<String>)
    requires 
        valid_input(n as int)
    ensures 
        valid_result(result@, n as int),
        correct_diamond_pattern(result@, n as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 3 && n <= 101 && n % 2 == 1
}

spec fn valid_result(result: Seq<String>, n: int) -> bool {
    result.len() == n &&
    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() == n
}

spec fn repeat_char(c: char, count: int) -> Seq<char>
    decreases count
{
    if count <= 0 { Seq::empty() }
    else { repeat_char(c, count - 1).push(c) }
}

spec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {
    result.len() == n ==> {
        let magic = (n - 1) / 2;
        
        (forall|i: int| 0 <= i <= magic && i < result.len() ==> {
            let stars = magic - i;
            let diamonds = n - 2 * stars;
            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)
        }) &&
        
        (forall|i: int| magic + 1 <= i < n && i < result.len() ==> {
            let u = i - magic;
            let stars = u;
            let diamonds = n - 2 * stars;
            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)
        })
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize) -> (result: Vec<String>)
    requires 
        valid_input(n as int)
    ensures 
        valid_result(result@, n as int),
        correct_diamond_pattern(result@, n as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 3 && n <= 101 && n % 2 == 1\n}\n\nspec fn valid_result(result: Seq<String>, n: int) -> bool {\n    result.len() == n &&\n    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() == n\n}\n\nspec fn repeat_char(c: char, count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 { Seq::empty() }\n    else { repeat_char(c, count - 1).push(c) }\n}\n\nspec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {\n    result.len() == n ==> {\n        let magic = (n - 1) / 2;\n        \n        (forall|i: int| 0 <= i <= magic && i < result.len() ==> {\n            let stars = magic - i;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        }) &&\n        \n        (forall|i: int| magic + 1 <= i < n && i < result.len() ==> {\n            let u = i - magic;\n            let stars = u;\n            let diamonds = n - 2 * stars;\n            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)\n        })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize) -> (result: Vec<String>)\n    requires \n        valid_input(n as int)\n    ensures \n        valid_result(result@, n as int),\n        correct_diamond_pattern(result@, n as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_228.rs,53,53,1.0,153.908,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn minimum(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else if s.len() > 1 && s[0] <= minimum(s.subrange(1, s.len() as int)) {
        s[0]
    } else {
        minimum(s.subrange(1, s.len() as int))
    }
}

spec fn count_occurrences(s: Seq<int>, val: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == val { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), val)
    }
}

spec fn valid_input(n: int, piles: Seq<int>) -> bool {
    n >= 2 && n % 2 == 0 && piles.len() == n && forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, piles: Vec<i8>) -> (result: &'static str)
    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))
    ensures result == ""Alice"" || result == ""Bob""
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""Alice""
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn minimum(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else if s.len() > 1 && s[0] <= minimum(s.subrange(1, s.len() as int)) {
        s[0]
    } else {
        minimum(s.subrange(1, s.len() as int))
    }
}

spec fn count_occurrences(s: Seq<int>, val: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == val { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), val)
    }
}

spec fn valid_input(n: int, piles: Seq<int>) -> bool {
    n >= 2 && n % 2 == 0 && piles.len() == n && forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, piles: Vec<i8>) -> (result: &'static str)
    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))
    ensures result == ""Alice"" || result == ""Bob""
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""Alice""
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn minimum(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s.len() > 1 && s[0] <= minimum(s.subrange(1, s.len() as int)) {\n        s[0]\n    } else {\n        minimum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn count_occurrences(s: Seq<int>, val: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == val { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), val)\n    }\n}\n\nspec fn valid_input(n: int, piles: Seq<int>) -> bool {\n    n >= 2 && n % 2 == 0 && piles.len() == n && forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, piles: Vec<i8>) -> (result: &\'static str)\n    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))\n    ensures result == ""Alice"" || result == ""Bob""\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""Alice""\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n      fn main() {\n    }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2293.rs,60,60,1.0,122.888,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: &str) -> bool {
    input@.len() > 0
    /* Additional validation logic would go here in a real implementation */
}

spec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>
    recommends
        input@.len() > 0,
        day_index >= 0,
        n >= 1,
{
    Set::empty() /* Placeholder - actual implementation would parse input */
}

spec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>
    recommends
        input@.len() > 0,
        day_index >= 0,
        n >= 1,
{
    let all_stores: Set<int> = Set::new(|i: int| 1 <= i <= n);
    let dora_set = extract_dora_set(input, day_index, n);
    all_stores.difference(dora_set)
}

spec fn solution_exists(input: &str) -> bool
    recommends valid_input(input)
{
    /* Logic to check if a valid assignment exists */
    true /* Placeholder */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        valid_input(input),
    ensures
        result@ =~= ""possible""@ || result@ =~= ""impossible""@,
        (result@ =~= ""possible""@) <==> solution_exists(input),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""impossible"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: &str) -> bool {
    input@.len() > 0
    /* Additional validation logic would go here in a real implementation */
}

spec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>
    recommends
        input@.len() > 0,
        day_index >= 0,
        n >= 1,
{
    Set::empty() /* Placeholder - actual implementation would parse input */
}

spec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>
    recommends
        input@.len() > 0,
        day_index >= 0,
        n >= 1,
{
    let all_stores: Set<int> = Set::new(|i: int| 1 <= i <= n);
    let dora_set = extract_dora_set(input, day_index, n);
    all_stores.difference(dora_set)
}

spec fn solution_exists(input: &str) -> bool
    recommends valid_input(input)
{
    /* Logic to check if a valid assignment exists */
    true /* Placeholder */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        valid_input(input),
    ensures
        result@ =~= ""possible""@ || result@ =~= ""impossible""@,
        (result@ =~= ""possible""@) <==> solution_exists(input),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""impossible"".to_string()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    input@.len() > 0\n    /* Additional validation logic would go here in a real implementation */\n}\n\nspec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    Set::empty() /* Placeholder - actual implementation would parse input */\n}\n\nspec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>\n    recommends\n        input@.len() > 0,\n        day_index >= 0,\n        n >= 1,\n{\n    let all_stores: Set<int> = Set::new(|i: int| 1 <= i <= n);\n    let dora_set = extract_dora_set(input, day_index, n);\n    all_stores.difference(dora_set)\n}\n\nspec fn solution_exists(input: &str) -> bool\n    recommends valid_input(input)\n{\n    /* Logic to check if a valid assignment exists */\n    true /* Placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        valid_input(input),\n    ensures\n        result@ =~= ""possible""@ || result@ =~= ""impossible""@,\n        (result@ =~= ""possible""@) <==> solution_exists(input),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""impossible"".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2297.rs,56,56,1.0,122.765,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_query(query: (int, int)) -> bool {
    query.0 >= 1 && query.0 <= query.1
}

spec fn valid_input(queries: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])
}

spec fn array_element(i: int) -> int
    recommends i >= 1
{
    i * (if i % 2 == 1 { -1 } else { 1 })
}

spec fn range_sum(l: int, r: int) -> int
    recommends l >= 1
    decreases r - l + 1
{
    if l > r { 0 } else { array_element(l) + range_sum(l + 1, r) }
}

spec fn prefix_sum(k: int) -> int {
    if k % 2 == 0 { k / 2 } else { -(k + 1) / 2 }
}

spec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool
    recommends valid_input(queries)
{
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] == prefix_sum(queries[i].1) - prefix_sum(queries[i].0 - 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<(i8, i8)>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))
    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_query(query: (int, int)) -> bool {
    query.0 >= 1 && query.0 <= query.1
}

spec fn valid_input(queries: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])
}

spec fn array_element(i: int) -> int
    recommends i >= 1
{
    i * (if i % 2 == 1 { -1 } else { 1 })
}

spec fn range_sum(l: int, r: int) -> int
    recommends l >= 1
    decreases r - l + 1
{
    if l > r { 0 } else { array_element(l) + range_sum(l + 1, r) }
}

spec fn prefix_sum(k: int) -> int {
    if k % 2 == 0 { k / 2 } else { -(k + 1) / 2 }
}

spec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool
    recommends valid_input(queries)
{
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] == prefix_sum(queries[i].1) - prefix_sum(queries[i].0 - 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<(i8, i8)>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))
    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_query(query: (int, int)) -> bool {\n    query.0 >= 1 && query.0 <= query.1\n}\n\nspec fn valid_input(queries: Seq<(int, int)>) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn array_element(i: int) -> int\n    recommends i >= 1\n{\n    i * (if i % 2 == 1 { -1 } else { 1 })\n}\n\nspec fn range_sum(l: int, r: int) -> int\n    recommends l >= 1\n    decreases r - l + 1\n{\n    if l > r { 0 } else { array_element(l) + range_sum(l + 1, r) }\n}\n\nspec fn prefix_sum(k: int) -> int {\n    if k % 2 == 0 { k / 2 } else { -(k + 1) / 2 }\n}\n\nspec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool\n    recommends valid_input(queries)\n{\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> results[i] == prefix_sum(queries[i].1) - prefix_sum(queries[i].0 - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(i8, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))\n    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2308.rs,105,105,1.0,185.361,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 && 
    is_valid_number(lines[0]) &&
    {
        let t = string_to_int(lines[0]);
        t >= 0 && lines.len() >= 2 * t + 1 &&
        forall|i: int| 1 <= i < 2 * t + 1 ==> #[trigger] lines.len() > i && is_binary_string(lines[i]) && contains_one(lines[i])
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 ==> {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t ==> #[trigger] is_valid_number(output_lines[i])
    }
}

spec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 ==> {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t && 1 + 2*i < lines.len() && 2 + 2*i < lines.len() ==> {
            let x = lines[1 + 2*i];
            let y = lines[2 + 2*i];
            let rev_x = reverse(x);
            let rev_y = reverse(y);
            let start = index_of(rev_y, '1');
            start >= 0 &&
            {
                let offset = index_of_from(rev_x, '1', start);
                #[trigger] string_to_int(output_lines[i]) == offset
            }
        }
    }
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == '0' || s.index(i) == '1'
}

spec fn contains_one(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && #[trigger] s.index(i) == '1'
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '0' && s.index(i) <= '9'
}

/* Helper functions */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    arbitrary()
}

spec fn string_to_int(s: Seq<char>) -> int {
    arbitrary()
}

spec fn reverse(s: Seq<char>) -> Seq<char> {
    arbitrary()
}

spec fn index_of(s: Seq<char>, c: char) -> int {
    arbitrary()
}

spec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {
    arbitrary()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (output: String)
    requires
        input@.len() > 0,
        input@.index(input@.len() as int - 1) == '\n',
        valid_input(input@),
    ensures
        valid_output(output@, input@),
        output@.len() > 0 ==> output@.index(output@.len() as int - 1) != '\n',
        correct_computation(output@, input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 && 
    is_valid_number(lines[0]) &&
    {
        let t = string_to_int(lines[0]);
        t >= 0 && lines.len() >= 2 * t + 1 &&
        forall|i: int| 1 <= i < 2 * t + 1 ==> #[trigger] lines.len() > i && is_binary_string(lines[i]) && contains_one(lines[i])
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 ==> {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t ==> #[trigger] is_valid_number(output_lines[i])
    }
}

spec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 ==> {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t && 1 + 2*i < lines.len() && 2 + 2*i < lines.len() ==> {
            let x = lines[1 + 2*i];
            let y = lines[2 + 2*i];
            let rev_x = reverse(x);
            let rev_y = reverse(y);
            let start = index_of(rev_y, '1');
            start >= 0 &&
            {
                let offset = index_of_from(rev_x, '1', start);
                #[trigger] string_to_int(output_lines[i]) == offset
            }
        }
    }
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == '0' || s.index(i) == '1'
}

spec fn contains_one(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && #[trigger] s.index(i) == '1'
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '0' && s.index(i) <= '9'
}

/* Helper functions */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    arbitrary()
}

spec fn string_to_int(s: Seq<char>) -> int {
    arbitrary()
}

spec fn reverse(s: Seq<char>) -> Seq<char> {
    arbitrary()
}

spec fn index_of(s: Seq<char>, c: char) -> int {
    arbitrary()
}

spec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {
    arbitrary()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (output: String)
    requires
        input@.len() > 0,
        input@.index(input@.len() as int - 1) == '\n',
        valid_input(input@),
    ensures
        valid_output(output@, input@),
        output@.len() > 0 ==> output@.index(output@.len() as int - 1) != '\n',
        correct_computation(output@, input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 && \n    is_valid_number(lines[0]) &&\n    {\n        let t = string_to_int(lines[0]);\n        t >= 0 && lines.len() >= 2 * t + 1 &&\n        forall|i: int| 1 <= i < 2 * t + 1 ==> #[trigger] lines.len() > i && is_binary_string(lines[i]) && contains_one(lines[i])\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] is_valid_number(output_lines[i])\n    }\n}\n\nspec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 ==> {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && 1 + 2*i < lines.len() && 2 + 2*i < lines.len() ==> {\n            let x = lines[1 + 2*i];\n            let y = lines[2 + 2*i];\n            let rev_x = reverse(x);\n            let rev_y = reverse(y);\n            let start = index_of(rev_y, '1');\n            start >= 0 &&\n            {\n                let offset = index_of_from(rev_x, '1', start);\n                #[trigger] string_to_int(output_lines[i]) == offset\n            }\n        }\n    }\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == '0' || s.index(i) == '1'\n}\n\nspec fn contains_one(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && #[trigger] s.index(i) == '1'\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '0' && s.index(i) <= '9'\n}\n\n/* Helper functions */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    arbitrary()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    arbitrary()\n}\n\nspec fn reverse(s: Seq<char>) -> Seq<char> {\n    arbitrary()\n}\n\nspec fn index_of(s: Seq<char>, c: char) -> int {\n    arbitrary()\n}\n\nspec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {\n    arbitrary()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (output: String)\n    requires\n        input@.len() > 0,\n        input@.index(input@.len() as int - 1) == '\\n',\n        valid_input(input@),\n    ensures\n        valid_output(output@, input@),\n        output@.len() > 0 ==> output@.index(output@.len() as int - 1) != '\\n',\n        correct_computation(output@, input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2320.rs,105,105,1.0,122.637,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_character(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0 as int
    } else {
        (if s[0] == c { 1 as int } else { 0 as int }) + count_character(s.skip(1), c)
    }
}

spec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {
    s.len() == t.len() && 
    (forall|c: char| count_character(s, c) == count_character(t, c))
}

spec fn find_next_match(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        s.len() as int
    } else if s[start] == c {
        start
    } else {
        find_next_match(s, c, start + 1)
    }
}

spec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool
    decreases j - i + 1, s.len() - k
{
    if i > j {
        true
    } else if k >= s.len() {
        false
    } else {
        let next_k = find_next_match(s, t[j], k);
        if next_k >= s.len() {
            false
        } else if i == j {
            true
        } else {
            can_match_substring(s, t, i, j-1, next_k+1)
        }
    }
}

spec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int
    decreases t.len() - i, t.len() - j
{
    if i >= t.len() {
        max_so_far
    } else if j >= t.len() {
        max_preservable_length(s, t, i+1, i+1, max_so_far)
    } else {
        let current_len = j - i + 1;
        let can_match = can_match_substring(s, t, i, j, 0);
        let new_max = if can_match && current_len > max_so_far { current_len } else { max_so_far };
        max_preservable_length(s, t, i, j+1, new_max)
    }
}

spec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int
{
    if s.len() == 0 {
        0 as int
    } else {
        max_preservable_length(s, t, 0, 0, 0)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>, t: Vec<char>) -> (result: i32)
    requires 
        s.len() == t.len(),
        s.len() >= 0,
    ensures 
        result == -1 <==> !has_same_character_counts(s@, t@),
        result >= -1,
        result != -1 ==> 0 <= result <= s.len() as i32,
        result != -1 ==> has_same_character_counts(s@, t@),
        result != -1 ==> result == s.len() as i32 - max_longest_subsequence(s@, t@) as i32,
        s.len() == 0 ==> result == 0,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    -1
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_character(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0 as int
    } else {
        (if s[0] == c { 1 as int } else { 0 as int }) + count_character(s.skip(1), c)
    }
}

spec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {
    s.len() == t.len() && 
    (forall|c: char| count_character(s, c) == count_character(t, c))
}

spec fn find_next_match(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        s.len() as int
    } else if s[start] == c {
        start
    } else {
        find_next_match(s, c, start + 1)
    }
}

spec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool
    decreases j - i + 1, s.len() - k
{
    if i > j {
        true
    } else if k >= s.len() {
        false
    } else {
        let next_k = find_next_match(s, t[j], k);
        if next_k >= s.len() {
            false
        } else if i == j {
            true
        } else {
            can_match_substring(s, t, i, j-1, next_k+1)
        }
    }
}

spec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int
    decreases t.len() - i, t.len() - j
{
    if i >= t.len() {
        max_so_far
    } else if j >= t.len() {
        max_preservable_length(s, t, i+1, i+1, max_so_far)
    } else {
        let current_len = j - i + 1;
        let can_match = can_match_substring(s, t, i, j, 0);
        let new_max = if can_match && current_len > max_so_far { current_len } else { max_so_far };
        max_preservable_length(s, t, i, j+1, new_max)
    }
}

spec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int
{
    if s.len() == 0 {
        0 as int
    } else {
        max_preservable_length(s, t, 0, 0, 0)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>, t: Vec<char>) -> (result: i32)
    requires 
        s.len() == t.len(),
        s.len() >= 0,
    ensures 
        result == -1 <==> !has_same_character_counts(s@, t@),
        result >= -1,
        result != -1 ==> 0 <= result <= s.len() as i32,
        result != -1 ==> has_same_character_counts(s@, t@),
        result != -1 ==> result == s.len() as i32 - max_longest_subsequence(s@, t@) as i32,
        s.len() == 0 ==> result == 0,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    -1
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_character(s: Seq<char>, c: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[0] == c { 1 as int } else { 0 as int }) + count_character(s.skip(1), c)\n    }\n}\n\nspec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {\n    s.len() == t.len() && \n    (forall|c: char| count_character(s, c) == count_character(t, c))\n}\n\nspec fn find_next_match(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        s.len() as int\n    } else if s[start] == c {\n        start\n    } else {\n        find_next_match(s, c, start + 1)\n    }\n}\n\nspec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool\n    decreases j - i + 1, s.len() - k\n{\n    if i > j {\n        true\n    } else if k >= s.len() {\n        false\n    } else {\n        let next_k = find_next_match(s, t[j], k);\n        if next_k >= s.len() {\n            false\n        } else if i == j {\n            true\n        } else {\n            can_match_substring(s, t, i, j-1, next_k+1)\n        }\n    }\n}\n\nspec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int\n    decreases t.len() - i, t.len() - j\n{\n    if i >= t.len() {\n        max_so_far\n    } else if j >= t.len() {\n        max_preservable_length(s, t, i+1, i+1, max_so_far)\n    } else {\n        let current_len = j - i + 1;\n        let can_match = can_match_substring(s, t, i, j, 0);\n        let new_max = if can_match && current_len > max_so_far { current_len } else { max_so_far };\n        max_preservable_length(s, t, i, j+1, new_max)\n    }\n}\n\nspec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        max_preservable_length(s, t, 0, 0, 0)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, t: Vec<char>) -> (result: i32)\n    requires \n        s.len() == t.len(),\n        s.len() >= 0,\n    ensures \n        result == -1 <==> !has_same_character_counts(s@, t@),\n        result >= -1,\n        result != -1 ==> 0 <= result <= s.len() as i32,\n        result != -1 ==> has_same_character_counts(s@, t@),\n        result != -1 ==> result == s.len() as i32 - max_longest_subsequence(s@, t@) as i32,\n        s.len() == 0 ==> result == 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2330.rs,102,102,1.0,123.543,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

pub enum Result {
    Impossible,
    Possible { cost: int, edges: Seq<(int, int)> }
}

spec fn seq_sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + seq_sum(s.skip(1))
    }
}

spec fn seq_sum_first(s: Seq<int>, n: int) -> int
    decreases n
{
    if n == 0 {
        0
    } else if n > 0 && n - 1 < s.len() {
        s[n-1] + seq_sum_first(s, n-1)
    } else {
        0
    }
}

spec fn min_index(weights: Seq<int>) -> int {
    if weights.len() > 0 {
        min_index_helper(weights, 0, 1)
    } else {
        0
    }
}

spec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int
    decreases weights.len() - next
{
    if next >= weights.len() {
        current_min
    } else if weights[next] < weights[current_min] {
        min_index_helper(weights, next, next + 1)
    } else {
        min_index_helper(weights, current_min, next + 1)
    }
}

spec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {
    if weights.len() > 1 && 0 <= exclude < weights.len() {
        let first_valid = if exclude == 0 { 1 } else { 0 };
        min_index_excluding_helper(weights, exclude, first_valid, 0)
    } else {
        0
    }
}

spec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int
    decreases weights.len() - next
{
    if next >= weights.len() {
        current_min
    } else if next == exclude {
        min_index_excluding_helper(weights, exclude, current_min, next + 1)
    } else if weights[next] < weights[current_min] {
        min_index_excluding_helper(weights, exclude, next, next + 1)
    } else {
        min_index_excluding_helper(weights, exclude, current_min, next + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(t: i8, cases: Vec<(i8, i8, Vec<i8>)>) -> (results: Vec<Result>)
    requires 
        t >= 0,
        cases.len() == t as nat,
        forall|i: int| #![auto] 0 <= i < t as int ==> 
            cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2@.len() == cases[i].0 as nat
    ensures 
        results@.len() == t as nat
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

pub enum Result {
    Impossible,
    Possible { cost: int, edges: Seq<(int, int)> }
}

spec fn seq_sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + seq_sum(s.skip(1))
    }
}

spec fn seq_sum_first(s: Seq<int>, n: int) -> int
    decreases n
{
    if n == 0 {
        0
    } else if n > 0 && n - 1 < s.len() {
        s[n-1] + seq_sum_first(s, n-1)
    } else {
        0
    }
}

spec fn min_index(weights: Seq<int>) -> int {
    if weights.len() > 0 {
        min_index_helper(weights, 0, 1)
    } else {
        0
    }
}

spec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int
    decreases weights.len() - next
{
    if next >= weights.len() {
        current_min
    } else if weights[next] < weights[current_min] {
        min_index_helper(weights, next, next + 1)
    } else {
        min_index_helper(weights, current_min, next + 1)
    }
}

spec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {
    if weights.len() > 1 && 0 <= exclude < weights.len() {
        let first_valid = if exclude == 0 { 1 } else { 0 };
        min_index_excluding_helper(weights, exclude, first_valid, 0)
    } else {
        0
    }
}

spec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int
    decreases weights.len() - next
{
    if next >= weights.len() {
        current_min
    } else if next == exclude {
        min_index_excluding_helper(weights, exclude, current_min, next + 1)
    } else if weights[next] < weights[current_min] {
        min_index_excluding_helper(weights, exclude, next, next + 1)
    } else {
        min_index_excluding_helper(weights, exclude, current_min, next + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(t: i8, cases: Vec<(i8, i8, Vec<i8>)>) -> (results: Vec<Result>)
    requires 
        t >= 0,
        cases.len() == t as nat,
        forall|i: int| #![auto] 0 <= i < t as int ==> 
            cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2@.len() == cases[i].0 as nat
    ensures 
        results@.len() == t as nat
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\npub enum Result {\n    Impossible,\n    Possible { cost: int, edges: Seq<(int, int)> }\n}\n\nspec fn seq_sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + seq_sum(s.skip(1))\n    }\n}\n\nspec fn seq_sum_first(s: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n > 0 && n - 1 < s.len() {\n        s[n-1] + seq_sum_first(s, n-1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index(weights: Seq<int>) -> int {\n    if weights.len() > 0 {\n        min_index_helper(weights, 0, 1)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if weights[next] < weights[current_min] {\n        min_index_helper(weights, next, next + 1)\n    } else {\n        min_index_helper(weights, current_min, next + 1)\n    }\n}\n\nspec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {\n    if weights.len() > 1 && 0 <= exclude < weights.len() {\n        let first_valid = if exclude == 0 { 1 } else { 0 };\n        min_index_excluding_helper(weights, exclude, first_valid, 0)\n    } else {\n        0\n    }\n}\n\nspec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int\n    decreases weights.len() - next\n{\n    if next >= weights.len() {\n        current_min\n    } else if next == exclude {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    } else if weights[next] < weights[current_min] {\n        min_index_excluding_helper(weights, exclude, next, next + 1)\n    } else {\n        min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: i8, cases: Vec<(i8, i8, Vec<i8>)>) -> (results: Vec<Result>)\n    requires \n        t >= 0,\n        cases.len() == t as nat,\n        forall|i: int| #![auto] 0 <= i < t as int ==> \n            cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2@.len() == cases[i].0 as nat\n    ensures \n        results@.len() == t as nat\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2340.rs,88,88,1.0,123.099,True,0.7999999999999999,True,"['vstd::prelude::', 'vstd::string::']",True,,,,,,"// <vc-preamble>
use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {
    h >= 1 && n >= 1 && platforms.len() >= n && n > 0 && platforms.len() > 0 && platforms[0] == h
}

spec fn valid_crystal_count(crystals: int, n: int) -> bool {
    crystals >= 0 && crystals <= n - 1
}

spec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {
    if platforms.len() >= 1 && platforms[0] == h && h >= 1 {
        if platforms.len() == 1 {
            0
        } else {
            count_crystals_needed_up_to(h, platforms.push(0), (platforms.len() - 1) as int)
        }
    } else {
        0
    }
}

spec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {
        if up_to == 0 {
            0
        } else {
            let cur_pos = simulate_position_up_to(h, arr, up_to - 1);
            let prev_crystals = count_crystals_needed_up_to(h, arr, up_to - 1);
            if cur_pos == arr[up_to as int] {
                prev_crystals
            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {
                prev_crystals
            } else {
                prev_crystals + 1
            }
        }
    } else {
        0
    }
}

spec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {
        if up_to == 0 {
            h
        } else {
            let prev_pos = simulate_position_up_to(h, arr, up_to - 1);
            if prev_pos == arr[up_to as int] {
                prev_pos
            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {
                arr[up_to as int] - 1
            } else {
                prev_pos
            }
        }
    } else {
        h
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires input@.len() > 0
    ensures result@.len() >= 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {
    h >= 1 && n >= 1 && platforms.len() >= n && n > 0 && platforms.len() > 0 && platforms[0] == h
}

spec fn valid_crystal_count(crystals: int, n: int) -> bool {
    crystals >= 0 && crystals <= n - 1
}

spec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {
    if platforms.len() >= 1 && platforms[0] == h && h >= 1 {
        if platforms.len() == 1 {
            0
        } else {
            count_crystals_needed_up_to(h, platforms.push(0), (platforms.len() - 1) as int)
        }
    } else {
        0
    }
}

spec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {
        if up_to == 0 {
            0
        } else {
            let cur_pos = simulate_position_up_to(h, arr, up_to - 1);
            let prev_crystals = count_crystals_needed_up_to(h, arr, up_to - 1);
            if cur_pos == arr[up_to as int] {
                prev_crystals
            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {
                prev_crystals
            } else {
                prev_crystals + 1
            }
        }
    } else {
        0
    }
}

spec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {
        if up_to == 0 {
            h
        } else {
            let prev_pos = simulate_position_up_to(h, arr, up_to - 1);
            if prev_pos == arr[up_to as int] {
                prev_pos
            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {
                arr[up_to as int] - 1
            } else {
                prev_pos
            }
        }
    } else {
        h
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires input@.len() > 0
    ensures result@.len() >= 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {\n    h >= 1 && n >= 1 && platforms.len() >= n && n > 0 && platforms.len() > 0 && platforms[0] == h\n}\n\nspec fn valid_crystal_count(crystals: int, n: int) -> bool {\n    crystals >= 0 && crystals <= n - 1\n}\n\nspec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {\n    if platforms.len() >= 1 && platforms[0] == h && h >= 1 {\n        if platforms.len() == 1 {\n            0\n        } else {\n            count_crystals_needed_up_to(h, platforms.push(0), (platforms.len() - 1) as int)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            0\n        } else {\n            let cur_pos = simulate_position_up_to(h, arr, up_to - 1);\n            let prev_crystals = count_crystals_needed_up_to(h, arr, up_to - 1);\n            if cur_pos == arr[up_to as int] {\n                prev_crystals\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                prev_crystals\n            } else {\n                prev_crystals + 1\n            }\n        }\n    } else {\n        0\n    }\n}\n\nspec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {\n        if up_to == 0 {\n            h\n        } else {\n            let prev_pos = simulate_position_up_to(h, arr, up_to - 1);\n            if prev_pos == arr[up_to as int] {\n                prev_pos\n            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {\n                arr[up_to as int] - 1\n            } else {\n                prev_pos\n            }\n        }\n    } else {\n        h\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires input@.len() > 0\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_235.rs,51,51,1.0,122.435,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn vasya_eats_with_strategy(n: int, k: int) -> int
    decreases n
{
    if n <= 0 || k < 1 { 
        0 
    } else {
        let cur = if n < k { n } else { k };
        let remaining_after_vasya = n - cur;
        let remaining_after_petya = remaining_after_vasya - remaining_after_vasya / 10;
        cur + vasya_eats_with_strategy(remaining_after_petya, k)
    }
}

spec fn is_minimal_solution(n: int, k: int) -> bool {
    valid_input(n) && k >= 1 && 
    vasya_eats_with_strategy(n, k) * 2 >= n &&
    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures
        1 <= result as int <= n as int,
        is_minimal_solution(n as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn vasya_eats_with_strategy(n: int, k: int) -> int
    decreases n
{
    if n <= 0 || k < 1 { 
        0 
    } else {
        let cur = if n < k { n } else { k };
        let remaining_after_vasya = n - cur;
        let remaining_after_petya = remaining_after_vasya - remaining_after_vasya / 10;
        cur + vasya_eats_with_strategy(remaining_after_petya, k)
    }
}

spec fn is_minimal_solution(n: int, k: int) -> bool {
    valid_input(n) && k >= 1 && 
    vasya_eats_with_strategy(n, k) * 2 >= n &&
    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures
        1 <= result as int <= n as int,
        is_minimal_solution(n as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn vasya_eats_with_strategy(n: int, k: int) -> int\n    decreases n\n{\n    if n <= 0 || k < 1 { \n        0 \n    } else {\n        let cur = if n < k { n } else { k };\n        let remaining_after_vasya = n - cur;\n        let remaining_after_petya = remaining_after_vasya - remaining_after_vasya / 10;\n        cur + vasya_eats_with_strategy(remaining_after_petya, k)\n    }\n}\n\nspec fn is_minimal_solution(n: int, k: int) -> bool {\n    valid_input(n) && k >= 1 && \n    vasya_eats_with_strategy(n, k) * 2 >= n &&\n    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures\n        1 <= result as int <= n as int,\n        is_minimal_solution(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2353.rs,50,50,1.0,123.485,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    a >= 0 && b >= 0 && c >= 0 && d >= 0
}

spec fn first_alarm_sufficient(a: int, b: int) -> bool {
    a <= b
}

spec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {
    a > b && c <= d
}

spec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {
    a > b && c > d
}

spec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {
    let remaining = a - b;
    let cycles = (remaining - 1) / (c - d) + 1;
    b + c * cycles
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int, d as int)
    ensures 
        first_alarm_sufficient(a as int, b as int) ==> result as int == b as int,
        never_wakes(a as int, b as int, c as int, d as int) ==> result == -1,
        eventually_wakes(a as int, b as int, c as int, d as int) ==> result as int == calculate_wake_time(a as int, b as int, c as int, d as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    a >= 0 && b >= 0 && c >= 0 && d >= 0
}

spec fn first_alarm_sufficient(a: int, b: int) -> bool {
    a <= b
}

spec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {
    a > b && c <= d
}

spec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {
    a > b && c > d
}

spec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {
    let remaining = a - b;
    let cycles = (remaining - 1) / (c - d) + 1;
    b + c * cycles
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int, d as int)
    ensures 
        first_alarm_sufficient(a as int, b as int) ==> result as int == b as int,
        never_wakes(a as int, b as int, c as int, d as int) ==> result == -1,
        eventually_wakes(a as int, b as int, c as int, d as int) ==> result as int == calculate_wake_time(a as int, b as int, c as int, d as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && d >= 0\n}\n\nspec fn first_alarm_sufficient(a: int, b: int) -> bool {\n    a <= b\n}\n\nspec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c <= d\n}\n\nspec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {\n    a > b && c > d\n}\n\nspec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {\n    let remaining = a - b;\n    let cycles = (remaining - 1) / (c - d) + 1;\n    b + c * cycles\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int, d as int)\n    ensures \n        first_alarm_sufficient(a as int, b as int) ==> result as int == b as int,\n        never_wakes(a as int, b as int, c as int, d as int) ==> result == -1,\n        eventually_wakes(a as int, b as int, c as int, d as int) ==> result as int == calculate_wake_time(a as int, b as int, c as int, d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2386.rs,66,66,1.0,122.417,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1
}

spec fn transform(a: Seq<int>) -> Seq<int> {
    Seq::new(a.len(), |i: int| a[i] - (i + 1))
}

spec fn sum_abs_diffs(a: Seq<int>, target: int) -> int
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        abs_int(a[0] - target) + sum_abs_diffs(a.subrange(1, a.len() as int), target)
    }
}

spec fn median_of(a: Seq<int>) -> int {
    let sorted = sorted_seq(a);
    if sorted.len() == 0 {
        0
    } else if sorted.len() % 2 == 1 {
        sorted[sorted.len() as int / 2]
    } else if sorted.len() == 2 {
        (sorted[0] + sorted[1]) / 2
    } else {
        (sorted[sorted.len() as int / 2 - 1] + sorted[sorted.len() as int / 2]) / 2
    }
}

spec fn sorted_seq(a: Seq<int>) -> Seq<int> {
    a
}

spec fn abs_int(x: int) -> int {
    if x >= 0 { x } else { -x }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        result >= 0,
        result as int == sum_abs_diffs(transform(a@.map(|i: int, x: i8| x as int)), median_of(transform(a@.map(|i: int, x: i8| x as int)))),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1
}

spec fn transform(a: Seq<int>) -> Seq<int> {
    Seq::new(a.len(), |i: int| a[i] - (i + 1))
}

spec fn sum_abs_diffs(a: Seq<int>, target: int) -> int
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        abs_int(a[0] - target) + sum_abs_diffs(a.subrange(1, a.len() as int), target)
    }
}

spec fn median_of(a: Seq<int>) -> int {
    let sorted = sorted_seq(a);
    if sorted.len() == 0 {
        0
    } else if sorted.len() % 2 == 1 {
        sorted[sorted.len() as int / 2]
    } else if sorted.len() == 2 {
        (sorted[0] + sorted[1]) / 2
    } else {
        (sorted[sorted.len() as int / 2 - 1] + sorted[sorted.len() as int / 2]) / 2
    }
}

spec fn sorted_seq(a: Seq<int>) -> Seq<int> {
    a
}

spec fn abs_int(x: int) -> int {
    if x >= 0 { x } else { -x }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        result >= 0,
        result as int == sum_abs_diffs(transform(a@.map(|i: int, x: i8| x as int)), median_of(transform(a@.map(|i: int, x: i8| x as int)))),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1\n}\n\nspec fn transform(a: Seq<int>) -> Seq<int> {\n    Seq::new(a.len(), |i: int| a[i] - (i + 1))\n}\n\nspec fn sum_abs_diffs(a: Seq<int>, target: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        abs_int(a[0] - target) + sum_abs_diffs(a.subrange(1, a.len() as int), target)\n    }\n}\n\nspec fn median_of(a: Seq<int>) -> int {\n    let sorted = sorted_seq(a);\n    if sorted.len() == 0 {\n        0\n    } else if sorted.len() % 2 == 1 {\n        sorted[sorted.len() as int / 2]\n    } else if sorted.len() == 2 {\n        (sorted[0] + sorted[1]) / 2\n    } else {\n        (sorted[sorted.len() as int / 2 - 1] + sorted[sorted.len() as int / 2]) / 2\n    }\n}\n\nspec fn sorted_seq(a: Seq<int>) -> Seq<int> {\n    a\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int == sum_abs_diffs(transform(a@.map(|i: int, x: i8| x as int)), median_of(transform(a@.map(|i: int, x: i8| x as int)))),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2406.rs,51,51,1.0,122.513,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n > 0 && heights.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])
}

spec fn valid_output(n: int, result: Seq<int>) -> bool {
    result.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)
}

spec fn is_stable(result: Seq<int>) -> bool {
    forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, heights: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, heights@.map(|i, v| v as int))
    ensures 
        valid_output(n as int, result@.map(|i, v| v as int)) &&
        sum_seq(result@.map(|i, v| v as int)) == sum_seq(heights@.map(|i, v| v as int)) &&
        is_stable(result@.map(|i, v| v as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n > 0 && heights.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])
}

spec fn valid_output(n: int, result: Seq<int>) -> bool {
    result.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)
}

spec fn is_stable(result: Seq<int>) -> bool {
    forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, heights: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, heights@.map(|i, v| v as int))
    ensures 
        valid_output(n as int, result@.map(|i, v| v as int)) &&
        sum_seq(result@.map(|i, v| v as int)) == sum_seq(heights@.map(|i, v| v as int)) &&
        is_stable(result@.map(|i, v| v as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n > 0 && heights.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])\n}\n\nspec fn valid_output(n: int, result: Seq<int>) -> bool {\n    result.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)\n}\n\nspec fn is_stable(result: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, heights@.map(|i, v| v as int))\n    ensures \n        valid_output(n as int, result@.map(|i, v| v as int)) &&\n        sum_seq(result@.map(|i, v| v as int)) == sum_seq(heights@.map(|i, v| v as int)) &&\n        is_stable(result@.map(|i, v| v as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2425.rs,81,81,1.0,123.227,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn power2(k: nat) -> int
    decreases k
{
    if k == 0 { 1 } else { 2 * power2((k - 1) as nat) }
}

spec fn valid_query(a: int) -> bool
{
    2 <= a <= power2(25) - 1
}

spec fn valid_queries(queries: Seq<int>) -> bool
{
    forall|i: int| #![auto] 0 <= i < queries.len() ==> valid_query(queries[i])
}

spec fn largest_proper_divisor(n: int) -> int
    recommends n > 1
{
    if n <= 1 { 
        1 
    } else { 
        largest_proper_divisor_helper(n, 2) 
    }
}

spec fn largest_proper_divisor_helper(n: int, d: int) -> int
    recommends n > 1 && d >= 2
    decreases if n >= d { n - d } else { 0 }
{
    if d * d > n { 
        1 
    } else if n % d == 0 { 
        let quotient = n / d;
        if quotient == d { 
            quotient 
        } else if n > d {
            let remainder_check = largest_proper_divisor_helper(n, d + 1);
            if quotient > remainder_check { quotient } else { remainder_check }
        } else {
            quotient
        }
    } else if n > d { 
        largest_proper_divisor_helper(n, d + 1) 
    } else {
        1
    }
}

spec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool
{
    results.len() == queries.len() &&
    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&
    true
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<i8>) -> (results: Vec<i8>)
    requires valid_queries(queries@.map(|_i, x: i8| x as int))
    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn power2(k: nat) -> int
    decreases k
{
    if k == 0 { 1 } else { 2 * power2((k - 1) as nat) }
}

spec fn valid_query(a: int) -> bool
{
    2 <= a <= power2(25) - 1
}

spec fn valid_queries(queries: Seq<int>) -> bool
{
    forall|i: int| #![auto] 0 <= i < queries.len() ==> valid_query(queries[i])
}

spec fn largest_proper_divisor(n: int) -> int
    recommends n > 1
{
    if n <= 1 { 
        1 
    } else { 
        largest_proper_divisor_helper(n, 2) 
    }
}

spec fn largest_proper_divisor_helper(n: int, d: int) -> int
    recommends n > 1 && d >= 2
    decreases if n >= d { n - d } else { 0 }
{
    if d * d > n { 
        1 
    } else if n % d == 0 { 
        let quotient = n / d;
        if quotient == d { 
            quotient 
        } else if n > d {
            let remainder_check = largest_proper_divisor_helper(n, d + 1);
            if quotient > remainder_check { quotient } else { remainder_check }
        } else {
            quotient
        }
    } else if n > d { 
        largest_proper_divisor_helper(n, d + 1) 
    } else {
        1
    }
}

spec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool
{
    results.len() == queries.len() &&
    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&
    true
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<i8>) -> (results: Vec<i8>)
    requires valid_queries(queries@.map(|_i, x: i8| x as int))
    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn power2(k: nat) -> int\n    decreases k\n{\n    if k == 0 { 1 } else { 2 * power2((k - 1) as nat) }\n}\n\nspec fn valid_query(a: int) -> bool\n{\n    2 <= a <= power2(25) - 1\n}\n\nspec fn valid_queries(queries: Seq<int>) -> bool\n{\n    forall|i: int| #![auto] 0 <= i < queries.len() ==> valid_query(queries[i])\n}\n\nspec fn largest_proper_divisor(n: int) -> int\n    recommends n > 1\n{\n    if n <= 1 { \n        1 \n    } else { \n        largest_proper_divisor_helper(n, 2) \n    }\n}\n\nspec fn largest_proper_divisor_helper(n: int, d: int) -> int\n    recommends n > 1 && d >= 2\n    decreases if n >= d { n - d } else { 0 }\n{\n    if d * d > n { \n        1 \n    } else if n % d == 0 { \n        let quotient = n / d;\n        if quotient == d { \n            quotient \n        } else if n > d {\n            let remainder_check = largest_proper_divisor_helper(n, d + 1);\n            if quotient > remainder_check { quotient } else { remainder_check }\n        } else {\n            quotient\n        }\n    } else if n > d { \n        largest_proper_divisor_helper(n, d + 1) \n    } else {\n        1\n    }\n}\n\nspec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool\n{\n    results.len() == queries.len() &&\n    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<i8>) -> (results: Vec<i8>)\n    requires valid_queries(queries@.map(|_i, x: i8| x as int))\n    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2434.rs,152,15,0.09868421052631579,184.452,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn yes_string() -> Seq<char> {
    seq!['Y', 'E', 'S']
}

spec fn no_string() -> Seq<char> {
    seq!['N', 'O']
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = split_by_newline(input);
    lines.len() >= 1 && 
    is_valid_int(lines[0]) &&
    {
        let t = parse_int(lines[0]);
        t >= 0 && t + 1 <= lines.len() &&
        forall|i: int| 1 <= i <= t ==> #[trigger] is_valid_two_int_line(lines[i])
    }
}

spec fn is_valid_int(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn is_valid_two_int_line(s: Seq<char>) -> bool {
    let parts = split_by_space(s);
    parts.len() >= 2 && is_valid_int(parts[0]) && is_valid_int(parts[1])
}

spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {
    let input_lines = split_by_newline(input);
    if input_lines.len() == 0 { 
        output.len() == 0
    } else {
        let t = parse_int(input_lines[0]);
        let output_lines = split_by_newline(output);
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t ==> #[trigger] seq_equals(output_lines[i], yes_string()) || #[trigger] seq_equals(output_lines[i], no_string())
    }
}

spec fn correct_divisibility_results(input: Seq<char>, output: Seq<char>) -> bool {
    let input_lines = split_by_newline(input);
    if input_lines.len() == 0 { 
        output.len() == 0
    } else {
        let t = parse_int(input_lines[0]);
        let output_lines = split_by_newline(output);
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t && i + 1 < input_lines.len() ==> {
            let parts = split_by_space(input_lines[i + 1]);
            parts.len() >= 2 ==> {
                let x = parse_int(parts[0]);
                let y = parse_int(parts[1]);
                y != 0 ==> (#[trigger] seq_equals(output_lines[i], yes_string()) <==> x % y == 0)
            }
        }
    }
}

spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {
    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == #[trigger] s2[i]
}

spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { 
        seq![]
    } else if s[0] == '\n' { 
        seq![seq![]].add(split_by_newline(s.subrange(1, s.len() as int)))
    } else {
        let rest = split_by_newline(s.subrange(1, s.len() as int));
        if rest.len() == 0 { 
            seq![s]
        } else { 
            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))
        }
    }
}

spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { 
        seq![]
    } else if s[0] == ' ' { 
        seq![seq![]].add(split_by_space(s.subrange(1, s.len() as int)))
    } else {
        let rest = split_by_space(s.subrange(1, s.len() as int));
        if rest.len() == 0 { 
            seq![s]
        } else { 
            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))
        }
    }
}

spec fn parse_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0
    } else if s.len() == 1 {
        if '0' <= s[0] <= '9' { 
            s[0] as int - '0' as int 
        } else { 
            0 
        }
    } else {
        if '0' <= s[0] <= '9' {
            (s[0] as int - '0' as int) * pow10(s.len() - 1) + parse_int(s.subrange(1, s.len() as int))
        } else { 
            0 
        }
    }
}

spec fn pow10(n: int) -> int 
    decreases n
{
    if n <= 0 { 1 } else { 10 * pow10(n - 1) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires 
        input.len() > 0,
        valid_input_format(input@),
    ensures 
        forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\n',
        valid_output_format(output@, input@),
        correct_divisibility_results(input@, output@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn yes_string() -> Seq<char> ;
       spec fn valid_input_format(input: Seq<char>) -> bool ;
       spec fn is_valid_int(s: Seq<char>) -> bool ;
       spec fn is_valid_two_int_line(s: Seq<char>) -> bool ;
       spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;
       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;
       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;
       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;
       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;
       spec fn pow10(n: int) -> int      decreases n ;
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn yes_string() -> Seq<char> {\n    seq!['Y', 'E', 'S']\n}\n\nspec fn no_string() -> Seq<char> {\n    seq!['N', 'O']\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_by_newline(input);\n    lines.len() >= 1 && \n    is_valid_int(lines[0]) &&\n    {\n        let t = parse_int(lines[0]);\n        t >= 0 && t + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= t ==> #[trigger] is_valid_two_int_line(lines[i])\n    }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nspec fn is_valid_two_int_line(s: Seq<char>) -> bool {\n    let parts = split_by_space(s);\n    parts.len() >= 2 && is_valid_int(parts[0]) && is_valid_int(parts[1])\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    let input_lines = split_by_newline(input);\n    if input_lines.len() == 0 { \n        output.len() == 0\n    } else {\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_by_newline(output);\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t ==> #[trigger] seq_equals(output_lines[i], yes_string()) || #[trigger] seq_equals(output_lines[i], no_string())\n    }\n}\n\nspec fn correct_divisibility_results(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_by_newline(input);\n    if input_lines.len() == 0 { \n        output.len() == 0\n    } else {\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_by_newline(output);\n        output_lines.len() == t &&\n        forall|i: int| 0 <= i < t && i + 1 < input_lines.len() ==> {\n            let parts = split_by_space(input_lines[i + 1]);\n            parts.len() >= 2 ==> {\n                let x = parse_int(parts[0]);\n                let y = parse_int(parts[1]);\n                y != 0 ==> (#[trigger] seq_equals(output_lines[i], yes_string()) <==> x % y == 0)\n            }\n        }\n    }\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == #[trigger] s2[i]\n}\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![]\n    } else if s[0] == '\\n' { \n        seq![seq![]].add(split_by_newline(s.subrange(1, s.len() as int)))\n    } else {\n        let rest = split_by_newline(s.subrange(1, s.len() as int));\n        if rest.len() == 0 { \n            seq![s]\n        } else { \n            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![]\n    } else if s[0] == ' ' { \n        seq![seq![]].add(split_by_space(s.subrange(1, s.len() as int)))\n    } else {\n        let rest = split_by_space(s.subrange(1, s.len() as int));\n        if rest.len() == 0 { \n            seq![s]\n        } else { \n            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 {\n        if '0' <= s[0] <= '9' { \n            s[0] as int - '0' as int \n        } else { \n            0 \n        }\n    } else {\n        if '0' <= s[0] <= '9' {\n            (s[0] as int - '0' as int) * pow10(s.len() - 1) + parse_int(s.subrange(1, s.len() as int))\n        } else { \n            0 \n        }\n    }\n}\n\nspec fn pow10(n: int) -> int \n    decreases n\n{\n    if n <= 0 { 1 } else { 10 * pow10(n - 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires \n        input.len() > 0,\n        valid_input_format(input@),\n    ensures \n        forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n',\n        valid_output_format(output@, input@),\n        correct_divisibility_results(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn yes_string() -> Seq<char> ;\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn is_valid_int(s: Seq<char>) -> bool ;\n       spec fn is_valid_two_int_line(s: Seq<char>) -> bool ;\n       spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool ;\n       spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool ;\n       spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>     decreases s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn pow10(n: int) -> int      decreases n ;\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n                fn main() {\n      }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2435.rs,73,11,0.1506849315068493,154.169,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool {
    test_cases.len() >= 0 &&
    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {
        let (n, x, operations) = test_cases[i];
        n >= 1 && 1 <= x <= n && operations.len() >= 0 &&
        forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 >= 1 && {
            let (l, r) = operations[j];
            1 <= l <= r <= n
        }
    }
}

spec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)
    recommends forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 <= operations[j].1
{
    compute_final_bounds_helper(x, x, operations, 0)
}

spec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool
    recommends valid_input(test_cases)
{
    results.len() == test_cases.len() &&
    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {
        let (n, x, operations) = test_cases[i];
        let final_bounds = compute_final_bounds(x, operations);
        results[i] == final_bounds.1 - final_bounds.0 + 1 &&
        final_bounds.0 <= x <= final_bounds.1 &&
        results[i] >= 1 &&
        1 <= final_bounds.0 <= final_bounds.1 <= n
    }
}

spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)
    decreases operations.len() - index
{
    if index >= operations.len() {
        (min_pos, max_pos)
    } else {
        let (l, r) = operations[index];
        let new_min = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {
            if l < min_pos { l } else { min_pos }
        } else { min_pos };
        let new_max = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {
            if r > max_pos { r } else { max_pos }
        } else { max_pos };
        compute_final_bounds_helper(new_min, new_max, operations, index + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(test_cases: Vec<(i8, i8, Vec<(i8, i8)>)>) -> (results: Vec<i8>)
    requires valid_input(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))))
    ensures valid_results(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))), results@.map(|i: int, r: i8| r as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool ;
        spec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)     recommends forall|j: int| 0 <= j < operations.len() ==>        
#[trigger] operations[j].0 <= operations[j].1
;
        spec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool     recommends valid_input(test_cases) ;
        spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;
        }
        fn main() {
       }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool {\n    test_cases.len() >= 0 &&\n    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {\n        let (n, x, operations) = test_cases[i];\n        n >= 1 && 1 <= x <= n && operations.len() >= 0 &&\n        forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 >= 1 && {\n            let (l, r) = operations[j];\n            1 <= l <= r <= n\n        }\n    }\n}\n\nspec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)\n    recommends forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 <= operations[j].1\n{\n    compute_final_bounds_helper(x, x, operations, 0)\n}\n\nspec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool\n    recommends valid_input(test_cases)\n{\n    results.len() == test_cases.len() &&\n    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {\n        let (n, x, operations) = test_cases[i];\n        let final_bounds = compute_final_bounds(x, operations);\n        results[i] == final_bounds.1 - final_bounds.0 + 1 &&\n        final_bounds.0 <= x <= final_bounds.1 &&\n        results[i] >= 1 &&\n        1 <= final_bounds.0 <= final_bounds.1 <= n\n    }\n}\n\nspec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)\n    decreases operations.len() - index\n{\n    if index >= operations.len() {\n        (min_pos, max_pos)\n    } else {\n        let (l, r) = operations[index];\n        let new_min = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {\n            if l < min_pos { l } else { min_pos }\n        } else { min_pos };\n        let new_max = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {\n            if r > max_pos { r } else { max_pos }\n        } else { max_pos };\n        compute_final_bounds_helper(new_min, new_max, operations, index + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(test_cases: Vec<(i8, i8, Vec<(i8, i8)>)>) -> (results: Vec<i8>)\n    requires valid_input(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))))\n    ensures valid_results(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))), results@.map(|i: int, r: i8| r as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool ;\n        spec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)     recommends forall|j: int| 0 <= j < operations.len() ==>        \n#[trigger] operations[j].0 <= operations[j].1\n;\n        spec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool     recommends valid_input(test_cases) ;\n        spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)     decreases operations.len() - index ;\n        }\n        fn main() {\n       }\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_244.rs,56,56,1.0,122.566,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_position(pos: int) -> bool {
    0 <= pos <= 2
}

spec fn swap_move(pos: int, move_num: int) -> int {
    if move_num % 2 == 1 {
        if pos == 0 { 1 }
        else if pos == 1 { 0 }
        else { 2 }
    } else {
        if pos == 1 { 2 }
        else if pos == 2 { 1 }
        else { 0 }
    }
}

spec fn reverse_move(pos: int, move_num: int) -> int {
    if move_num % 2 == 1 {
        if pos == 0 { 1 }
        else if pos == 1 { 0 }
        else { 2 }
    } else {
        if pos == 1 { 2 }
        else if pos == 2 { 1 }
        else { 0 }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn shell_game(n: i32, x: i8) -> (result: i8)
    requires 
        n >= 1 && n <= 2000000000,
        valid_position(x as int),
    ensures valid_position(result as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_position(pos: int) -> bool {
    0 <= pos <= 2
}

spec fn swap_move(pos: int, move_num: int) -> int {
    if move_num % 2 == 1 {
        if pos == 0 { 1 }
        else if pos == 1 { 0 }
        else { 2 }
    } else {
        if pos == 1 { 2 }
        else if pos == 2 { 1 }
        else { 0 }
    }
}

spec fn reverse_move(pos: int, move_num: int) -> int {
    if move_num % 2 == 1 {
        if pos == 0 { 1 }
        else if pos == 1 { 0 }
        else { 2 }
    } else {
        if pos == 1 { 2 }
        else if pos == 2 { 1 }
        else { 0 }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn shell_game(n: i32, x: i8) -> (result: i8)
    requires 
        n >= 1 && n <= 2000000000,
        valid_position(x as int),
    ensures valid_position(result as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_position(pos: int) -> bool {\n    0 <= pos <= 2\n}\n\nspec fn swap_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n\nspec fn reverse_move(pos: int, move_num: int) -> int {\n    if move_num % 2 == 1 {\n        if pos == 0 { 1 }\n        else if pos == 1 { 0 }\n        else { 2 }\n    } else {\n        if pos == 1 { 2 }\n        else if pos == 2 { 1 }\n        else { 0 }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn shell_game(n: i32, x: i8) -> (result: i8)\n    requires \n        n >= 1 && n <= 2000000000,\n        valid_position(x as int),\n    ensures valid_position(result as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2443.rs,72,72,1.0,153.62,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat
  recommends modulus > 0, i <= s.len()
  decreases i
{
    if i == 0 { 1 }
    else { (s[i as int - 1] * prefix_product(s, (i - 1) as nat, modulus)) % modulus }
}

spec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>
  recommends modulus > 0
{
    Seq::new(s.len(), |i: int| prefix_product(s, (i + 1) as nat, modulus))
}

spec fn all_distinct<T>(s: Seq<T>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]
}

spec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool
  recommends modulus > 0
{
    let products = prefix_products(s, modulus);
    forall|i: int| 0 <= i < products.len() ==> !forbidden.contains(products[i])
}

spec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {
    m >= 1 &&
    n >= 0 &&
    forbidden.len() == n &&
    (forall|i: int| 0 <= i < forbidden.len() ==> #[trigger] forbidden[i] >= 0 && forbidden[i] < m) &&
    (forall|i: int, j: int| 0 <= i < j < forbidden.len() ==> #[trigger] forbidden[i] != #[trigger] forbidden[j])
}

spec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool
  recommends m > 0
{
    (forall|i: int| 0 <= i < sequence.len() ==> #[trigger] sequence[i] >= 0 && sequence[i] < m) &&
    all_distinct(Seq::new(1, |x: int| 1).add(prefix_products(sequence, m))) &&
    no_forbidden_products(sequence, forbidden, m)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, m: u8, forbidden: Vec<u8>) -> (result: (u8, Vec<u8>))
  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))
  ensures ({
      let (length, sequence) = result;
      length == sequence.len() as u8 &&
      length >= 0 &&
      (m == 1 ==> length == 0 && sequence@ == Seq::<u8>::empty()) &&
      (m > 1 ==> valid_sequence(sequence@.map(|i, x: u8| x as nat), m as nat, forbidden@.map(|i, x: u8| x as nat))) &&
      (n == 0 && m > 1 ==> length > 0)
  })
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, Vec::new())
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat
  recommends modulus > 0, i <= s.len()
  decreases i
{
    if i == 0 { 1 }
    else { (s[i as int - 1] * prefix_product(s, (i - 1) as nat, modulus)) % modulus }
}

spec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>
  recommends modulus > 0
{
    Seq::new(s.len(), |i: int| prefix_product(s, (i + 1) as nat, modulus))
}

spec fn all_distinct<T>(s: Seq<T>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]
}

spec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool
  recommends modulus > 0
{
    let products = prefix_products(s, modulus);
    forall|i: int| 0 <= i < products.len() ==> !forbidden.contains(products[i])
}

spec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {
    m >= 1 &&
    n >= 0 &&
    forbidden.len() == n &&
    (forall|i: int| 0 <= i < forbidden.len() ==> #[trigger] forbidden[i] >= 0 && forbidden[i] < m) &&
    (forall|i: int, j: int| 0 <= i < j < forbidden.len() ==> #[trigger] forbidden[i] != #[trigger] forbidden[j])
}

spec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool
  recommends m > 0
{
    (forall|i: int| 0 <= i < sequence.len() ==> #[trigger] sequence[i] >= 0 && sequence[i] < m) &&
    all_distinct(Seq::new(1, |x: int| 1).add(prefix_products(sequence, m))) &&
    no_forbidden_products(sequence, forbidden, m)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, m: u8, forbidden: Vec<u8>) -> (result: (u8, Vec<u8>))
  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))
  ensures ({
      let (length, sequence) = result;
      length == sequence.len() as u8 &&
      length >= 0 &&
      (m == 1 ==> length == 0 && sequence@ == Seq::<u8>::empty()) &&
      (m > 1 ==> valid_sequence(sequence@.map(|i, x: u8| x as nat), m as nat, forbidden@.map(|i, x: u8| x as nat))) &&
      (n == 0 && m > 1 ==> length > 0)
  })
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, Vec::new())
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat\n  recommends modulus > 0, i <= s.len()\n  decreases i\n{\n    if i == 0 { 1 }\n    else { (s[i as int - 1] * prefix_product(s, (i - 1) as nat, modulus)) % modulus }\n}\n\nspec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>\n  recommends modulus > 0\n{\n    Seq::new(s.len(), |i: int| prefix_product(s, (i + 1) as nat, modulus))\n}\n\nspec fn all_distinct<T>(s: Seq<T>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]\n}\n\nspec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool\n  recommends modulus > 0\n{\n    let products = prefix_products(s, modulus);\n    forall|i: int| 0 <= i < products.len() ==> !forbidden.contains(products[i])\n}\n\nspec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {\n    m >= 1 &&\n    n >= 0 &&\n    forbidden.len() == n &&\n    (forall|i: int| 0 <= i < forbidden.len() ==> #[trigger] forbidden[i] >= 0 && forbidden[i] < m) &&\n    (forall|i: int, j: int| 0 <= i < j < forbidden.len() ==> #[trigger] forbidden[i] != #[trigger] forbidden[j])\n}\n\nspec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool\n  recommends m > 0\n{\n    (forall|i: int| 0 <= i < sequence.len() ==> #[trigger] sequence[i] >= 0 && sequence[i] < m) &&\n    all_distinct(Seq::new(1, |x: int| 1).add(prefix_products(sequence, m))) &&\n    no_forbidden_products(sequence, forbidden, m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, m: u8, forbidden: Vec<u8>) -> (result: (u8, Vec<u8>))\n  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))\n  ensures ({\n      let (length, sequence) = result;\n      length == sequence.len() as u8 &&\n      length >= 0 &&\n      (m == 1 ==> length == 0 && sequence@ == Seq::<u8>::empty()) &&\n      (m > 1 ==> valid_sequence(sequence@.map(|i, x: u8| x as nat), m as nat, forbidden@.map(|i, x: u8| x as nat))) &&\n      (n == 0 && m > 1 ==> length > 0)\n  })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, Vec::new())\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2451.rs,60,60,1.0,124.006,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {
    n >= 1 && h >= 1 && 1 <= a <= b <= h
}

spec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {
    1 <= query.0 <= n && 1 <= query.1 <= h &&
    1 <= query.2 <= n && 1 <= query.3 <= h
}

spec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> #[trigger] valid_query(queries[i], n, h)
}

spec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {
    if t1 == t2 {
        if f1 >= f2 { f1 - f2 } else { f2 - f1 }
    } else if f1 >= a && f1 <= b {
        (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= f1 { f2 - f1 } else { f1 - f2 })
    } else if f1 < a {
        (a - f1) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= a { f2 - a } else { a - f2 })
    } else {
        (f1 - b) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= b { f2 - b } else { b - f2 })
    }
}

spec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> {
        let (t1, f1, t2, f2) = queries[i];
        #[trigger] results[i] == min_travel_time(t1, f1, t2, f2, a, b)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, h: i8, a: i8, b: i8, queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)
    requires
        valid_building_params(n as int, h as int, a as int, b as int),
        valid_queries(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), n as int, h as int),
    ensures
        correct_results(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), results@.map_values(|x: i8| x as int), a as int, b as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {
    n >= 1 && h >= 1 && 1 <= a <= b <= h
}

spec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {
    1 <= query.0 <= n && 1 <= query.1 <= h &&
    1 <= query.2 <= n && 1 <= query.3 <= h
}

spec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> #[trigger] valid_query(queries[i], n, h)
}

spec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {
    if t1 == t2 {
        if f1 >= f2 { f1 - f2 } else { f2 - f1 }
    } else if f1 >= a && f1 <= b {
        (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= f1 { f2 - f1 } else { f1 - f2 })
    } else if f1 < a {
        (a - f1) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= a { f2 - a } else { a - f2 })
    } else {
        (f1 - b) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= b { f2 - b } else { b - f2 })
    }
}

spec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> {
        let (t1, f1, t2, f2) = queries[i];
        #[trigger] results[i] == min_travel_time(t1, f1, t2, f2, a, b)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, h: i8, a: i8, b: i8, queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)
    requires
        valid_building_params(n as int, h as int, a as int, b as int),
        valid_queries(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), n as int, h as int),
    ensures
        correct_results(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), results@.map_values(|x: i8| x as int), a as int, b as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {\n    n >= 1 && h >= 1 && 1 <= a <= b <= h\n}\n\nspec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {\n    1 <= query.0 <= n && 1 <= query.1 <= h &&\n    1 <= query.2 <= n && 1 <= query.3 <= h\n}\n\nspec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {\n    forall|i: int| 0 <= i < queries.len() ==> #[trigger] valid_query(queries[i], n, h)\n}\n\nspec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {\n    if t1 == t2 {\n        if f1 >= f2 { f1 - f2 } else { f2 - f1 }\n    } else if f1 >= a && f1 <= b {\n        (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= f1 { f2 - f1 } else { f1 - f2 })\n    } else if f1 < a {\n        (a - f1) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= a { f2 - a } else { a - f2 })\n    } else {\n        (f1 - b) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= b { f2 - b } else { b - f2 })\n    }\n}\n\nspec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {\n    results.len() == queries.len() &&\n    forall|i: int| 0 <= i < queries.len() ==> {\n        let (t1, f1, t2, f2) = queries[i];\n        #[trigger] results[i] == min_travel_time(t1, f1, t2, f2, a, b)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, h: i8, a: i8, b: i8, queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)\n    requires\n        valid_building_params(n as int, h as int, a as int, b as int),\n        valid_queries(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), n as int, h as int),\n    ensures\n        correct_results(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), results@.map_values(|x: i8| x as int), a as int, b as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n         verus! {}\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2467.rs,72,21,0.2916666666666667,185.191,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum(s.subrange(1, s.len() as int))
    }
}

spec fn is_distinct(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j]
}

spec fn is_sorted(s: Seq<int>) -> bool {
    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i + 1]
}

spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool {
    combo.len() == k &&
    sum(combo) == n &&
    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&
    is_distinct(combo) &&
    is_sorted(combo)
}

spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {
    combo.len() == k &&
    sum(combo) == n &&
    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&
    is_distinct(combo) &&
    is_sorted(combo) &&
    combo.len() >= temp.len() &&
    (forall|i: int| 0 <= i < temp.len() ==> #[trigger] temp[i] == #[trigger] combo[i]) &&
    (forall|i: int| temp.len() <= i < combo.len() ==> #[trigger] combo[i] >= start)
}
// </vc-preamble>

// <vc-helpers>
spec fn to_int_seq(v: Vec<i8>) -> Seq<int> {
    v@.map(|i: int, x: i8| x as int)
}
// </vc-helpers>

// <vc-spec>
fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)
    requires k > 0 && n > 0 && k <= 9
    ensures 
        (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == k as int) &&
        (forall|i: int| 0 <= i < result.len() ==> sum(to_int_seq(#[trigger] result[i])) == n as int) &&
        (forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < #[trigger] result[i].len() ==> 1 <= #[trigger] result[i][j] as int <= 9) &&
        (forall|i: int| 0 <= i < result.len() ==> is_distinct(to_int_seq(#[trigger] result[i]))) &&
        (forall|i: int| 0 <= i < result.len() ==> is_sorted(to_int_seq(#[trigger] result[i]))) &&
        (forall|i: int, j: int| 0 <= i < j < result.len() ==> to_int_seq(#[trigger] result[i]) != to_int_seq(#[trigger] result[j])) &&
        (forall|combo: Seq<int>| is_valid_combination(combo, k as int, n as int) ==> exists|i: int| 0 <= i < result.len() && to_int_seq(#[trigger] result[i]) == combo) &&
        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(#[trigger] result[i]), k as int, n as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;
       spec fn is_distinct(s: Seq<int>) -> bool ;
       spec fn is_sorted(s: Seq<int>) -> bool ;
       spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool ;
       spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {
        (forall|i: int| temp.len() <= i < combo.len() ==>        
#[trigger] combo[i] >= start)
}
       spec fn to_int_seq(v: Vec<i8>) -> Seq<int> {
          v@.map(|i: int, x: i8| x as int) }
       fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)     requires k > 0 && n > 0 && k <= 9     ensures          (forall|i: int| 0 <= i < result.len() ==>        
#[trigger] result[i].len() == k as int) &&
        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(       
#[trigger] result[i]), k as int, n as int))
{
          Vec::new() }
       }
        fn main() {
      }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn is_distinct(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j]\n}\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i + 1]\n}\n\nspec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool {\n    combo.len() == k &&\n    sum(combo) == n &&\n    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&\n    is_distinct(combo) &&\n    is_sorted(combo)\n}\n\nspec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n    combo.len() == k &&\n    sum(combo) == n &&\n    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&\n    is_distinct(combo) &&\n    is_sorted(combo) &&\n    combo.len() >= temp.len() &&\n    (forall|i: int| 0 <= i < temp.len() ==> #[trigger] temp[i] == #[trigger] combo[i]) &&\n    (forall|i: int| temp.len() <= i < combo.len() ==> #[trigger] combo[i] >= start)\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn to_int_seq(v: Vec<i8>) -> Seq<int> {\n    v@.map(|i: int, x: i8| x as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)\n    requires k > 0 && n > 0 && k <= 9\n    ensures \n        (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == k as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> sum(to_int_seq(#[trigger] result[i])) == n as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < #[trigger] result[i].len() ==> 1 <= #[trigger] result[i][j] as int <= 9) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_distinct(to_int_seq(#[trigger] result[i]))) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_sorted(to_int_seq(#[trigger] result[i]))) &&\n        (forall|i: int, j: int| 0 <= i < j < result.len() ==> to_int_seq(#[trigger] result[i]) != to_int_seq(#[trigger] result[j])) &&\n        (forall|combo: Seq<int>| is_valid_combination(combo, k as int, n as int) ==> exists|i: int| 0 <= i < result.len() && to_int_seq(#[trigger] result[i]) == combo) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(#[trigger] result[i]), k as int, n as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn sum(s: Seq<int>) -> int     decreases s.len() ;\n       spec fn is_distinct(s: Seq<int>) -> bool ;\n       spec fn is_sorted(s: Seq<int>) -> bool ;\n       spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool ;\n       spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {\n        (forall|i: int| temp.len() <= i < combo.len() ==>        \n#[trigger] combo[i] >= start)\n}\n       spec fn to_int_seq(v: Vec<i8>) -> Seq<int> {\n          v@.map(|i: int, x: i8| x as int) }\n       fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)     requires k > 0 && n > 0 && k <= 9     ensures          (forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i].len() == k as int) &&\n        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(       \n#[trigger] result[i]), k as int, n as int))\n{\n          Vec::new() }\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2486.rs,71,71,1.0,122.469,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int
  recommends
    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],
    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,
    k >= 1
{
  if sorted.len() == 0 {
    0
  } else {
    unnecessary_cards_count_helper(sorted, k, 0, 0, 0)
  }
}

spec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int
  recommends
    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],
    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,
    k >= 1,
    0 <= i <= sorted.len(),
    temp >= 0,
    ans >= 0
  decreases sorted.len() - i
{
  if i >= sorted.len() {
    ans
  } else {
    let x = sorted[i];
    if temp + x < k {
      unnecessary_cards_count_helper(sorted, k, temp + x, ans + 1, i + 1)
    } else {
      unnecessary_cards_count_helper(sorted, k, 0, 0, i + 1)
    }
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
  requires
    n >= 1,
    k >= 1,
    a.len() == n as usize,
    forall|i: int| 0 <= i < a.len() ==> a[i] as int >= 1
  ensures
    result >= 0,
    result as int <= n as int,
    exists|sorted: Seq<int>|
      sorted.len() == a@.len() &&
      sorted.to_multiset() == a@.map(|i: int, x: i8| x as int).to_multiset() &&
      (forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j]) &&
      (forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1) &&
      result as int == unnecessary_cards_count(sorted, k as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int
  recommends
    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],
    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,
    k >= 1
{
  if sorted.len() == 0 {
    0
  } else {
    unnecessary_cards_count_helper(sorted, k, 0, 0, 0)
  }
}

spec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int
  recommends
    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],
    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,
    k >= 1,
    0 <= i <= sorted.len(),
    temp >= 0,
    ans >= 0
  decreases sorted.len() - i
{
  if i >= sorted.len() {
    ans
  } else {
    let x = sorted[i];
    if temp + x < k {
      unnecessary_cards_count_helper(sorted, k, temp + x, ans + 1, i + 1)
    } else {
      unnecessary_cards_count_helper(sorted, k, 0, 0, i + 1)
    }
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
  requires
    n >= 1,
    k >= 1,
    a.len() == n as usize,
    forall|i: int| 0 <= i < a.len() ==> a[i] as int >= 1
  ensures
    result >= 0,
    result as int <= n as int,
    exists|sorted: Seq<int>|
      sorted.len() == a@.len() &&
      sorted.to_multiset() == a@.map(|i: int, x: i8| x as int).to_multiset() &&
      (forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j]) &&
      (forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1) &&
      result as int == unnecessary_cards_count(sorted, k as int)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int\n  recommends\n    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],\n    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,\n    k >= 1\n{\n  if sorted.len() == 0 {\n    0\n  } else {\n    unnecessary_cards_count_helper(sorted, k, 0, 0, 0)\n  }\n}\n\nspec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int\n  recommends\n    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],\n    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,\n    k >= 1,\n    0 <= i <= sorted.len(),\n    temp >= 0,\n    ans >= 0\n  decreases sorted.len() - i\n{\n  if i >= sorted.len() {\n    ans\n  } else {\n    let x = sorted[i];\n    if temp + x < k {\n      unnecessary_cards_count_helper(sorted, k, temp + x, ans + 1, i + 1)\n    } else {\n      unnecessary_cards_count_helper(sorted, k, 0, 0, i + 1)\n    }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    n >= 1,\n    k >= 1,\n    a.len() == n as usize,\n    forall|i: int| 0 <= i < a.len() ==> a[i] as int >= 1\n  ensures\n    result >= 0,\n    result as int <= n as int,\n    exists|sorted: Seq<int>|\n      sorted.len() == a@.len() &&\n      sorted.to_multiset() == a@.map(|i: int, x: i8| x as int).to_multiset() &&\n      (forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j]) &&\n      (forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1) &&\n      result as int == unnecessary_cards_count(sorted, k as int)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2516.rs,52,52,1.0,122.331,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_prime(p: int) -> bool {
    p >= 2 && forall|k: int| 2 <= k < p ==> #[trigger] (p % k) != 0
}

spec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {
    n >= 1 &&
    p >= 2 &&
    is_prime(p) &&
    s.len() == n &&
    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn substring_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else {
        substring_to_int(s.subrange(0, s.len() as int - 1)) * 10 + ((s[s.len() as int - 1] as int) - ('0' as int))
    }
}

spec fn valid_result(result: int, n: int) -> bool {
    result >= 0 && result <= n * (n + 1) / 2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: i8, s: Vec<char>) -> (result: i8)
    requires valid_input(n as int, p as int, s@)
    ensures valid_result(result as int, n as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_prime(p: int) -> bool {
    p >= 2 && forall|k: int| 2 <= k < p ==> #[trigger] (p % k) != 0
}

spec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {
    n >= 1 &&
    p >= 2 &&
    is_prime(p) &&
    s.len() == n &&
    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn substring_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else {
        substring_to_int(s.subrange(0, s.len() as int - 1)) * 10 + ((s[s.len() as int - 1] as int) - ('0' as int))
    }
}

spec fn valid_result(result: int, n: int) -> bool {
    result >= 0 && result <= n * (n + 1) / 2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: i8, s: Vec<char>) -> (result: i8)
    requires valid_input(n as int, p as int, s@)
    ensures valid_result(result as int, n as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_prime(p: int) -> bool {\n    p >= 2 && forall|k: int| 2 <= k < p ==> #[trigger] (p % k) != 0\n}\n\nspec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {\n    n >= 1 &&\n    p >= 2 &&\n    is_prime(p) &&\n    s.len() == n &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn substring_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else {\n        substring_to_int(s.subrange(0, s.len() as int - 1)) * 10 + ((s[s.len() as int - 1] as int) - ('0' as int))\n    }\n}\n\nspec fn valid_result(result: int, n: int) -> bool {\n    result >= 0 && result <= n * (n + 1) / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, s: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, p as int, s@)\n    ensures valid_result(result as int, n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_253.rs,75,75,1.0,122.521,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(nums: Seq<int>) -> bool {
    nums.len() == 3 &&
    forall|i: int| 0 <= i < nums.len() ==> nums[i] > 0 &&
    forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1500
}

spec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {
    if x <= y && x <= z {
        if y <= z { (x, y, z) } else { (x, z, y) }
    } else if y <= x && y <= z {
        if x <= z { (y, x, z) } else { (y, z, x) }
    } else {
        if x <= y { (z, x, y) } else { (z, y, x) }
    }
}

spec fn compute_result(x: int, y: int, z: int) -> Seq<char> {
    let sorted = sort_three(x, y, z);
    let a = sorted.0;
    let b = sorted.1;
    let c = sorted.2;

    if a > 3 {
        seq!['N', 'O']
    } else if a == 3 {
        if b > 3 {
            seq!['N', 'O']
        } else if b == 3 {
            if c > 3 { seq!['N', 'O'] } else { seq!['Y', 'E', 'S'] }
        } else {
            seq!['N', 'O']
        }
    } else if a == 1 {
        seq!['Y', 'E', 'S']
    } else {
        if b == 2 {
            seq!['Y', 'E', 'S']
        } else if b > 4 {
            seq!['N', 'O']
        } else if b == 4 {
            if c == 4 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }
        } else {
            seq!['N', 'O']
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(nums: Vec<i8>) -> (result: Vec<char>)
    requires
        valid_input(nums@.map(|i, x| x as int)),
    ensures
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        result@ == compute_result(nums@[0] as int, nums@[1] as int, nums@[2] as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(nums: Seq<int>) -> bool {
    nums.len() == 3 &&
    forall|i: int| 0 <= i < nums.len() ==> nums[i] > 0 &&
    forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1500
}

spec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {
    if x <= y && x <= z {
        if y <= z { (x, y, z) } else { (x, z, y) }
    } else if y <= x && y <= z {
        if x <= z { (y, x, z) } else { (y, z, x) }
    } else {
        if x <= y { (z, x, y) } else { (z, y, x) }
    }
}

spec fn compute_result(x: int, y: int, z: int) -> Seq<char> {
    let sorted = sort_three(x, y, z);
    let a = sorted.0;
    let b = sorted.1;
    let c = sorted.2;

    if a > 3 {
        seq!['N', 'O']
    } else if a == 3 {
        if b > 3 {
            seq!['N', 'O']
        } else if b == 3 {
            if c > 3 { seq!['N', 'O'] } else { seq!['Y', 'E', 'S'] }
        } else {
            seq!['N', 'O']
        }
    } else if a == 1 {
        seq!['Y', 'E', 'S']
    } else {
        if b == 2 {
            seq!['Y', 'E', 'S']
        } else if b > 4 {
            seq!['N', 'O']
        } else if b == 4 {
            if c == 4 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }
        } else {
            seq!['N', 'O']
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(nums: Vec<i8>) -> (result: Vec<char>)
    requires
        valid_input(nums@.map(|i, x| x as int)),
    ensures
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        result@ == compute_result(nums@[0] as int, nums@[1] as int, nums@[2] as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(nums: Seq<int>) -> bool {\n    nums.len() == 3 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] > 0 &&\n    forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1500\n}\n\nspec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {\n    if x <= y && x <= z {\n        if y <= z { (x, y, z) } else { (x, z, y) }\n    } else if y <= x && y <= z {\n        if x <= z { (y, x, z) } else { (y, z, x) }\n    } else {\n        if x <= y { (z, x, y) } else { (z, y, x) }\n    }\n}\n\nspec fn compute_result(x: int, y: int, z: int) -> Seq<char> {\n    let sorted = sort_three(x, y, z);\n    let a = sorted.0;\n    let b = sorted.1;\n    let c = sorted.2;\n\n    if a > 3 {\n        seq!['N', 'O']\n    } else if a == 3 {\n        if b > 3 {\n            seq!['N', 'O']\n        } else if b == 3 {\n            if c > 3 { seq!['N', 'O'] } else { seq!['Y', 'E', 'S'] }\n        } else {\n            seq!['N', 'O']\n        }\n    } else if a == 1 {\n        seq!['Y', 'E', 'S']\n    } else {\n        if b == 2 {\n            seq!['Y', 'E', 'S']\n        } else if b > 4 {\n            seq!['N', 'O']\n        } else if b == 4 {\n            if c == 4 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }\n        } else {\n            seq!['N', 'O']\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(nums: Vec<i8>) -> (result: Vec<char>)\n    requires\n        valid_input(nums@.map(|i, x| x as int)),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        result@ == compute_result(nums@[0] as int, nums@[1] as int, nums@[2] as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2548.rs,74,74,1.0,153.709,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(digits: Seq<int>) -> bool {
    digits.len() >= 1 && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= 0 && #[trigger] digits[i] <= 9
}

spec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool
    recommends 0 <= start <= end < digits.len()
{
    let subarray_sum = sum(digits.subrange(start, end + 1));
    let subarray_length = end - start + 1;
    subarray_sum == subarray_length
}

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.drop_first()) }
}

spec fn count_good_subarrays(digits: Seq<int>) -> int
    recommends valid_input(digits)
{
    count_good_subarrays_helper(digits, 0, map![0 => 1], 0, 0)
}

spec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, 
                                  current_sum: int, current_count: int) -> int
    recommends 
        0 <= pos <= digits.len() &&
        valid_input(digits) &&
        current_count == pos &&
        current_sum >= 0 &&
        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&
        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)
    decreases digits.len() - pos
{
    if pos >= digits.len() { 0 }
    else {
        let new_sum = current_sum + digits[pos];
        let new_count = current_count + 1;
        let diff = new_count - new_sum;
        let contribution = if freq_map.dom().contains(diff) { freq_map[diff] } else { 0 };
        let new_freq_map = freq_map.insert(diff, if freq_map.dom().contains(diff) { freq_map[diff] + 1 } else { 1 });
        contribution + count_good_subarrays_helper(digits, pos + 1, new_freq_map, new_sum, new_count)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn count_good_subarrays_in_array(digits: Vec<i8>) -> (count: i8)
    requires 
        valid_input(digits@.map(|i, x| x as int)),
    ensures 
        count >= 0,
        count as int == count_good_subarrays(digits@.map(|i, x| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(digits: Seq<int>) -> bool {
    digits.len() >= 1 && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= 0 && #[trigger] digits[i] <= 9
}

spec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool
    recommends 0 <= start <= end < digits.len()
{
    let subarray_sum = sum(digits.subrange(start, end + 1));
    let subarray_length = end - start + 1;
    subarray_sum == subarray_length
}

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.drop_first()) }
}

spec fn count_good_subarrays(digits: Seq<int>) -> int
    recommends valid_input(digits)
{
    count_good_subarrays_helper(digits, 0, map![0 => 1], 0, 0)
}

spec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, 
                                  current_sum: int, current_count: int) -> int
    recommends 
        0 <= pos <= digits.len() &&
        valid_input(digits) &&
        current_count == pos &&
        current_sum >= 0 &&
        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&
        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)
    decreases digits.len() - pos
{
    if pos >= digits.len() { 0 }
    else {
        let new_sum = current_sum + digits[pos];
        let new_count = current_count + 1;
        let diff = new_count - new_sum;
        let contribution = if freq_map.dom().contains(diff) { freq_map[diff] } else { 0 };
        let new_freq_map = freq_map.insert(diff, if freq_map.dom().contains(diff) { freq_map[diff] + 1 } else { 1 });
        contribution + count_good_subarrays_helper(digits, pos + 1, new_freq_map, new_sum, new_count)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn count_good_subarrays_in_array(digits: Vec<i8>) -> (count: i8)
    requires 
        valid_input(digits@.map(|i, x| x as int)),
    ensures 
        count >= 0,
        count as int == count_good_subarrays(digits@.map(|i, x| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(digits: Seq<int>) -> bool {\n    digits.len() >= 1 && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= 0 && #[trigger] digits[i] <= 9\n}\n\nspec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool\n    recommends 0 <= start <= end < digits.len()\n{\n    let subarray_sum = sum(digits.subrange(start, end + 1));\n    let subarray_length = end - start + 1;\n    subarray_sum == subarray_length\n}\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.drop_first()) }\n}\n\nspec fn count_good_subarrays(digits: Seq<int>) -> int\n    recommends valid_input(digits)\n{\n    count_good_subarrays_helper(digits, 0, map![0 => 1], 0, 0)\n}\n\nspec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, \n                                  current_sum: int, current_count: int) -> int\n    recommends \n        0 <= pos <= digits.len() &&\n        valid_input(digits) &&\n        current_count == pos &&\n        current_sum >= 0 &&\n        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&\n        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)\n    decreases digits.len() - pos\n{\n    if pos >= digits.len() { 0 }\n    else {\n        let new_sum = current_sum + digits[pos];\n        let new_count = current_count + 1;\n        let diff = new_count - new_sum;\n        let contribution = if freq_map.dom().contains(diff) { freq_map[diff] } else { 0 };\n        let new_freq_map = freq_map.insert(diff, if freq_map.dom().contains(diff) { freq_map[diff] + 1 } else { 1 });\n        contribution + count_good_subarrays_helper(digits, pos + 1, new_freq_map, new_sum, new_count)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_good_subarrays_in_array(digits: Vec<i8>) -> (count: i8)\n    requires \n        valid_input(digits@.map(|i, x| x as int)),\n    ensures \n        count >= 0,\n        count as int == count_good_subarrays(digits@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n           fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2550.rs,58,58,1.0,122.531,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {
    n >= 1 && m >= 1 && scores.len() == n &&
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 0 && #[trigger] scores[i] <= m
}

spec fn sum(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() == 0 { 
        0 
    } else { 
        nums[0] + sum(nums.subrange(1, nums.len() as int)) 
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {
    redistributed.len() == original.len() &&
    sum(redistributed) == sum(original) &&
    forall|i: int| 0 <= i < redistributed.len() ==> #[trigger] redistributed[i] >= 0 && #[trigger] redistributed[i] <= m
}

spec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {
    min(sum(scores), m)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, scores: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),
    ensures 
        result as int == max_possible_first_score(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),
        result as int == min(sum(scores@.map(|_i: int, x: i8| x as int)), m as int),
        exists|redistributed: Seq<int>| (valid_redistribution(scores@.map(|_i: int, x: i8| x as int), redistributed, m as int) && 
            redistributed[0] == result as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {
    n >= 1 && m >= 1 && scores.len() == n &&
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 0 && #[trigger] scores[i] <= m
}

spec fn sum(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() == 0 { 
        0 
    } else { 
        nums[0] + sum(nums.subrange(1, nums.len() as int)) 
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {
    redistributed.len() == original.len() &&
    sum(redistributed) == sum(original) &&
    forall|i: int| 0 <= i < redistributed.len() ==> #[trigger] redistributed[i] >= 0 && #[trigger] redistributed[i] <= m
}

spec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {
    min(sum(scores), m)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, scores: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),
    ensures 
        result as int == max_possible_first_score(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),
        result as int == min(sum(scores@.map(|_i: int, x: i8| x as int)), m as int),
        exists|redistributed: Seq<int>| (valid_redistribution(scores@.map(|_i: int, x: i8| x as int), redistributed, m as int) && 
            redistributed[0] == result as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {\n    n >= 1 && m >= 1 && scores.len() == n &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 0 && #[trigger] scores[i] <= m\n}\n\nspec fn sum(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 { \n        0 \n    } else { \n        nums[0] + sum(nums.subrange(1, nums.len() as int)) \n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {\n    redistributed.len() == original.len() &&\n    sum(redistributed) == sum(original) &&\n    forall|i: int| 0 <= i < redistributed.len() ==> #[trigger] redistributed[i] >= 0 && #[trigger] redistributed[i] <= m\n}\n\nspec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {\n    min(sum(scores), m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, scores: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n    ensures \n        result as int == max_possible_first_score(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),\n        result as int == min(sum(scores@.map(|_i: int, x: i8| x as int)), m as int),\n        exists|redistributed: Seq<int>| (valid_redistribution(scores@.map(|_i: int, x: i8| x as int), redistributed, m as int) && \n            redistributed[0] == result as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2568.rs,53,53,1.0,92.498,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'
}

spec fn compute_result(s: Seq<char>) -> int {
    compute_result_helper(s, 0, 0, 0, s.len() as int)
}

spec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i == s.len() {
        ans
    } else if s[i] == '+' {
        compute_result_helper(s, i + 1, cur + 1, pm, ans)
    } else {
        let new_cur = cur - 1;
        if new_cur < pm {
            compute_result_helper(s, i + 1, new_cur, new_cur, ans + i + 1)
        } else {
            compute_result_helper(s, i + 1, new_cur, pm, ans)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    requires 
        valid_input(s@),
        s.len() <= 127
    ensures 
        result as int >= s@.len(),
        result as int == compute_result(s@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'
}

spec fn compute_result(s: Seq<char>) -> int {
    compute_result_helper(s, 0, 0, 0, s.len() as int)
}

spec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i == s.len() {
        ans
    } else if s[i] == '+' {
        compute_result_helper(s, i + 1, cur + 1, pm, ans)
    } else {
        let new_cur = cur - 1;
        if new_cur < pm {
            compute_result_helper(s, i + 1, new_cur, new_cur, ans + i + 1)
        } else {
            compute_result_helper(s, i + 1, new_cur, pm, ans)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    requires 
        valid_input(s@),
        s.len() <= 127
    ensures 
        result as int >= s@.len(),
        result as int == compute_result(s@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'\n}\n\nspec fn compute_result(s: Seq<char>) -> int {\n    compute_result_helper(s, 0, 0, 0, s.len() as int)\n}\n\nspec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        ans\n    } else if s[i] == '+' {\n        compute_result_helper(s, i + 1, cur + 1, pm, ans)\n    } else {\n        let new_cur = cur - 1;\n        if new_cur < pm {\n            compute_result_helper(s, i + 1, new_cur, new_cur, ans + i + 1)\n        } else {\n            compute_result_helper(s, i + 1, new_cur, pm, ans)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires \n        valid_input(s@),\n        s.len() <= 127\n    ensures \n        result as int >= s@.len(),\n        result as int == compute_result(s@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2583.rs,62,62,1.0,123.209,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn determine_winner(n: int) -> &'static str
    recommends n >= 1
{
    if n == 1 { ""FastestFinger"" }
    else if n == 2 { ""Ashishgup"" }
    else if is_power_of_two(n) { ""FastestFinger"" }
    else if n % 4 != 2 { ""Ashishgup"" }
    else if is_limited_prime(n / 2) { ""FastestFinger"" }
    else { ""Ashishgup"" }
}

spec fn is_power_of_two(n: int) -> bool
    recommends n >= 1
    decreases n
{
    if n <= 0 { false }
    else { n == 1 || (n % 2 == 0 && is_power_of_two(n / 2)) }
}

spec fn is_limited_prime(p: int) -> bool
    recommends p >= 1
{
    if p <= 1 { false }
    else if p == 2 { true }
    else if p % 2 == 0 { false }
    else { true /* simplified primality check */ }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<i8>) -> (result: Vec<&'static str>)
    requires
        input.len() >= 1,
        input[0] as int >= 1,
        input.len() == input[0] as int + 1,
        forall|i: int| #![auto] 1 <= i < input.len() ==> input[i as int] as int >= 1
    ensures
        result.len() == input[0] as int,
        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int] == ""FastestFinger"" || result[i as int] == ""Ashishgup"",
        forall|i: int| #![auto] 1 <= i < input.len() ==> result[(i-1) as int] == determine_winner(input[i as int] as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn determine_winner(n: int) -> &'static str
    recommends n >= 1
{
    if n == 1 { ""FastestFinger"" }
    else if n == 2 { ""Ashishgup"" }
    else if is_power_of_two(n) { ""FastestFinger"" }
    else if n % 4 != 2 { ""Ashishgup"" }
    else if is_limited_prime(n / 2) { ""FastestFinger"" }
    else { ""Ashishgup"" }
}

spec fn is_power_of_two(n: int) -> bool
    recommends n >= 1
    decreases n
{
    if n <= 0 { false }
    else { n == 1 || (n % 2 == 0 && is_power_of_two(n / 2)) }
}

spec fn is_limited_prime(p: int) -> bool
    recommends p >= 1
{
    if p <= 1 { false }
    else if p == 2 { true }
    else if p % 2 == 0 { false }
    else { true /* simplified primality check */ }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<i8>) -> (result: Vec<&'static str>)
    requires
        input.len() >= 1,
        input[0] as int >= 1,
        input.len() == input[0] as int + 1,
        forall|i: int| #![auto] 1 <= i < input.len() ==> input[i as int] as int >= 1
    ensures
        result.len() == input[0] as int,
        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int] == ""FastestFinger"" || result[i as int] == ""Ashishgup"",
        forall|i: int| #![auto] 1 <= i < input.len() ==> result[(i-1) as int] == determine_winner(input[i as int] as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn determine_winner(n: int) -> &\'static str\n    recommends n >= 1\n{\n    if n == 1 { ""FastestFinger"" }\n    else if n == 2 { ""Ashishgup"" }\n    else if is_power_of_two(n) { ""FastestFinger"" }\n    else if n % 4 != 2 { ""Ashishgup"" }\n    else if is_limited_prime(n / 2) { ""FastestFinger"" }\n    else { ""Ashishgup"" }\n}\n\nspec fn is_power_of_two(n: int) -> bool\n    recommends n >= 1\n    decreases n\n{\n    if n <= 0 { false }\n    else { n == 1 || (n % 2 == 0 && is_power_of_two(n / 2)) }\n}\n\nspec fn is_limited_prime(p: int) -> bool\n    recommends p >= 1\n{\n    if p <= 1 { false }\n    else if p == 2 { true }\n    else if p % 2 == 0 { false }\n    else { true /* simplified primality check */ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<i8>) -> (result: Vec<&\'static str>)\n    requires\n        input.len() >= 1,\n        input[0] as int >= 1,\n        input.len() == input[0] as int + 1,\n        forall|i: int| #![auto] 1 <= i < input.len() ==> input[i as int] as int >= 1\n    ensures\n        result.len() == input[0] as int,\n        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int] == ""FastestFinger"" || result[i as int] == ""Ashishgup"",\n        forall|i: int| #![auto] 1 <= i < input.len() ==> result[(i-1) as int] == determine_winner(input[i as int] as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n      fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2622.rs,194,10,0.05154639175257732,153.772,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = parse_lines_func(input);
    lines.len() >= 3 &&
    {
        let first_line = parse_ints_func(lines[0]);
        first_line.len() >= 2 &&
        {
            let n = first_line[0];
            let m = first_line[1];
            n >= 1 && m >= 1 && m <= n &&
            lines.len() >= 1 + n + m &&
            (forall|k: int| 1 <= k <= n ==> k < lines.len() && lines[k].len() >= m) &&
            (forall|k: int| 1 + n <= k < 1 + n + m ==> k < lines.len() && lines[k].len() >= n)
        }
    }
}

spec fn valid_solution(input: Seq<char>, result: Seq<char>) -> bool {
    let lines = parse_lines_func(input);
    if lines.len() < 3 { 
        true 
    } else {
        let first_line = parse_ints_func(lines[0]);
        if first_line.len() < 2 { 
            true 
        } else {
            let n = first_line[0];
            let m = first_line[1];
            if n <= 0 || m <= 0 || m > n { 
                true 
            } else {
                let result_parts = parse_ints_func(result);
                if result_parts.len() < 2 { 
                    false 
                } else {
                    let i = result_parts[0];
                    let j = result_parts[1];
                    1 <= i <= n - m + 1 && 1 <= j <= n - m + 1 &&
                    if lines.len() >= 1 + n + m { 
                        correct_sub_matrices_match(lines, n, m, i - 1, j - 1) 
                    } else { 
                        false 
                    }
                }
            }
        }
    }
}

spec fn solution_exists(input: Seq<char>) -> bool {
    if !valid_input_format(input) { 
        false 
    } else {
        let lines = parse_lines_func(input);
        let first_line = parse_ints_func(lines[0]);
        let n = first_line[0];
        let m = first_line[1];
        exists|i: int, j: int| 0 <= i <= n - m && 0 <= j <= n - m &&
            correct_sub_matrices_match(lines, n, m, i, j)
    }
}

spec fn solution_found(input: Seq<char>, result: Seq<char>) -> bool {
    valid_solution(input, result) &&
    if !valid_input_format(input) { 
        false 
    } else {
        let lines = parse_lines_func(input);
        let first_line = parse_ints_func(lines[0]);
        let n = first_line[0];
        let m = first_line[1];
        let result_parts = parse_ints_func(result);
        if result_parts.len() >= 2 {
            let i = result_parts[0] - 1;
            let j = result_parts[1] - 1;
            correct_sub_matrices_match(lines, n, m, i, j)
        } else { 
            false 
        }
    }
}

spec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool {
    if !valid_input_format(input) { 
        true 
    } else {
        let lines = parse_lines_func(input);
        let first_line = parse_ints_func(lines[0]);
        let n = first_line[0];
        let m = first_line[1];
        let result_parts = parse_ints_func(result);
        if result_parts.len() >= 2 {
            let i = result_parts[0] - 1;
            let j = result_parts[1] - 1;
            0 <= i <= n - m && 0 <= j <= n - m &&
            (forall|r: int, c: int| 
                #![trigger r + c]
                (0 <= r < m && 0 <= c < m) ==> true)
        } else { 
            false 
        }
    }
}

spec fn always_returns_first_match(input: Seq<char>, result: Seq<char>) -> bool {
    if !valid_input_format(input) { 
        true 
    } else {
        let lines = parse_lines_func(input);
        let first_line = parse_ints_func(lines[0]);
        let n = first_line[0];
        let m = first_line[1];
        let result_parts = parse_ints_func(result);
        if result_parts.len() >= 2 {
            let result_i = result_parts[0] - 1;
            let result_j = result_parts[1] - 1;
            forall|i: int, j: int| 
                #![trigger correct_sub_matrices_match(lines, n, m, i, j)]
                (0 <= i <= n - m && 0 <= j <= n - m &&
                (i < result_i || (i == result_i && j < result_j))) ==>
                !correct_sub_matrices_match(lines, n, m, i, j)
        } else { 
            false 
        }
    }
}

spec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool
    recommends 
        lines.len() >= 1 + n + m,
        0 <= i <= n - m && 0 <= j <= n - m
{
    forall|r: int, c: int| 
        #![trigger r + c]
        (0 <= r < m && 0 <= c < m) ==> true
}

spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['a']]
}

spec fn parse_ints_func(line: Seq<char>) -> Seq<int> {
    seq![1, 1]
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else if n == 4 { seq!['4'] }
    else if n == 5 { seq!['5'] }
    else if n == 6 { seq!['6'] }
    else if n == 7 { seq!['7'] }
    else if n == 8 { seq!['8'] }
    else if n == 9 { seq!['9'] }
    else { seq!['1', '0'] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires 
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures 
        result@.len() > 0,
        exists|i: int, j: int| i >= 1 && j >= 1 && result@ == int_to_string_func(i) + seq![' '] + int_to_string_func(j),
        valid_solution(stdin_input@, result@),
        solution_exists(stdin_input@) ==> solution_found(stdin_input@, result@),
        correct_matrix_matching(stdin_input@, result@),
        always_returns_first_match(stdin_input@, result@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input_format(input: Seq<char>) -> bool ;
       spec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool ;
       spec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool     recommends          lines.len() >= 1 + n + m,         0 <= i <= n - m && 0 <= j <= n - m ;
       spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> ;
       spec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = parse_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let first_line = parse_ints_func(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 1 && m <= n &&\n            lines.len() >= 1 + n + m &&\n            (forall|k: int| 1 <= k <= n ==> k < lines.len() && lines[k].len() >= m) &&\n            (forall|k: int| 1 + n <= k < 1 + n + m ==> k < lines.len() && lines[k].len() >= n)\n        }\n    }\n}\n\nspec fn valid_solution(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = parse_lines_func(input);\n    if lines.len() < 3 { \n        true \n    } else {\n        let first_line = parse_ints_func(lines[0]);\n        if first_line.len() < 2 { \n            true \n        } else {\n            let n = first_line[0];\n            let m = first_line[1];\n            if n <= 0 || m <= 0 || m > n { \n                true \n            } else {\n                let result_parts = parse_ints_func(result);\n                if result_parts.len() < 2 { \n                    false \n                } else {\n                    let i = result_parts[0];\n                    let j = result_parts[1];\n                    1 <= i <= n - m + 1 && 1 <= j <= n - m + 1 &&\n                    if lines.len() >= 1 + n + m { \n                        correct_sub_matrices_match(lines, n, m, i - 1, j - 1) \n                    } else { \n                        false \n                    }\n                }\n            }\n        }\n    }\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        false \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        exists|i: int, j: int| 0 <= i <= n - m && 0 <= j <= n - m &&\n            correct_sub_matrices_match(lines, n, m, i, j)\n    }\n}\n\nspec fn solution_found(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_solution(input, result) &&\n    if !valid_input_format(input) { \n        false \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let i = result_parts[0] - 1;\n            let j = result_parts[1] - 1;\n            correct_sub_matrices_match(lines, n, m, i, j)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        true \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let i = result_parts[0] - 1;\n            let j = result_parts[1] - 1;\n            0 <= i <= n - m && 0 <= j <= n - m &&\n            (forall|r: int, c: int| \n                #![trigger r + c]\n                (0 <= r < m && 0 <= c < m) ==> true)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn always_returns_first_match(input: Seq<char>, result: Seq<char>) -> bool {\n    if !valid_input_format(input) { \n        true \n    } else {\n        let lines = parse_lines_func(input);\n        let first_line = parse_ints_func(lines[0]);\n        let n = first_line[0];\n        let m = first_line[1];\n        let result_parts = parse_ints_func(result);\n        if result_parts.len() >= 2 {\n            let result_i = result_parts[0] - 1;\n            let result_j = result_parts[1] - 1;\n            forall|i: int, j: int| \n                #![trigger correct_sub_matrices_match(lines, n, m, i, j)]\n                (0 <= i <= n - m && 0 <= j <= n - m &&\n                (i < result_i || (i == result_i && j < result_j))) ==>\n                !correct_sub_matrices_match(lines, n, m, i, j)\n        } else { \n            false \n        }\n    }\n}\n\nspec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool\n    recommends \n        lines.len() >= 1 + n + m,\n        0 <= i <= n - m && 0 <= j <= n - m\n{\n    forall|r: int, c: int| \n        #![trigger r + c]\n        (0 <= r < m && 0 <= c < m) ==> true\n}\n\nspec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]\n}\n\nspec fn parse_ints_func(line: Seq<char>) -> Seq<int> {\n    seq![1, 1]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else { seq!['1', '0'] }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        result@.len() > 0,\n        exists|i: int, j: int| i >= 1 && j >= 1 && result@ == int_to_string_func(i) + seq![' '] + int_to_string_func(j),\n        valid_solution(stdin_input@, result@),\n        solution_exists(stdin_input@) ==> solution_found(stdin_input@, result@),\n        correct_matrix_matching(stdin_input@, result@),\n        always_returns_first_match(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       spec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool     recommends          lines.len() >= 1 + n + m,         0 <= i <= n - m && 0 <= j <= n - m ;\n       spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_ints_func(line: Seq<char>) -> Seq<int> ;\n       }\n        fn main() {\n      }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2629.rs,64,64,1.0,153.436,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn spiral_order(row: int, col: int, n: int) -> int
    recommends 0 <= row < n && 0 <= col < n && n >= 1
    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1
{
    let layer = min(min(row, col), min(n-1-row, n-1-col));
    let layer_start = 4 * layer * (n - layer - 1) + layer;

    if row == layer {
        /* Top row of current layer */
        layer_start + (col - layer)
    } else if col == n - 1 - layer {
        /* Right column of current layer */
        layer_start + (n - 2 * layer - 1) + (row - layer)
    } else if row == n - 1 - layer {
        /* Bottom row of current layer */
        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)
    } else {
        /* Left column of current layer */
        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)
    }
}

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {
    matrix.len() == n &&
    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)
    requires 
        valid_input(n as int)
    ensures 
        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&
        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&
        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn spiral_order(row: int, col: int, n: int) -> int
    recommends 0 <= row < n && 0 <= col < n && n >= 1
    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1
{
    let layer = min(min(row, col), min(n-1-row, n-1-col));
    let layer_start = 4 * layer * (n - layer - 1) + layer;

    if row == layer {
        /* Top row of current layer */
        layer_start + (col - layer)
    } else if col == n - 1 - layer {
        /* Right column of current layer */
        layer_start + (n - 2 * layer - 1) + (row - layer)
    } else if row == n - 1 - layer {
        /* Bottom row of current layer */
        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)
    } else {
        /* Left column of current layer */
        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)
    }
}

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {
    matrix.len() == n &&
    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)
    requires 
        valid_input(n as int)
    ensures 
        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&
        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&
        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn spiral_order(row: int, col: int, n: int) -> int\n    recommends 0 <= row < n && 0 <= col < n && n >= 1\n    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1\n{\n    let layer = min(min(row, col), min(n-1-row, n-1-col));\n    let layer_start = 4 * layer * (n - layer - 1) + layer;\n\n    if row == layer {\n        /* Top row of current layer */\n        layer_start + (col - layer)\n    } else if col == n - 1 - layer {\n        /* Right column of current layer */\n        layer_start + (n - 2 * layer - 1) + (row - layer)\n    } else if row == n - 1 - layer {\n        /* Bottom row of current layer */\n        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)\n    } else {\n        /* Left column of current layer */\n        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {\n    matrix.len() == n &&\n    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&\n    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)\n    requires \n        valid_input(n as int)\n    ensures \n        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&\n        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2630.rs,81,81,1.0,183.714,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && grid[0].len() > 0 &&
    (forall|i: int| #![trigger grid[i].len(), grid[0].len()] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()) &&
    (forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> 
        grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn binomial(n: int, k: int) -> int
    decreases n, k
{
    if k > n || n < 0 || k < 0 {
        0int
    } else if k == 0 || k == n {
        1int
    } else if k == 1 {
        n
    } else {
        binomial(n-1, k-1) + binomial(n-1, k)
    }
}

spec fn dp_path_count(grid: Seq<Seq<int>>) -> int
    recommends valid_grid(grid)
{
    let m = grid.len();
    let n = grid[0].len();
    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {
        0int
    } else if m == 1 && n == 1 {
        1int
    } else if m == 1 {
        if forall|j: int| #![trigger grid[0][j]] 0 <= j < n ==> grid[0][j] == 0 { 1int } else { 0int }
    } else if n == 1 {
        if forall|i: int| #![trigger grid[i][0]] 0 <= i < m ==> grid[i][0] == 0 { 1int } else { 0int }
    } else if forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 {
        binomial(m + n - 2, m - 1)
    } else {
        0int  /* placeholder for complex case */
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
exec fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i8>>) -> (result: i8)
    requires 
        valid_grid(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),
    ensures 
        result >= 0,
        obstacle_grid@[0][0] == 1 ==> result == 0,
        obstacle_grid@[obstacle_grid@.len()-1][obstacle_grid@[0].len()-1] == 1 ==> result == 0,
        obstacle_grid@.len() == 1 && obstacle_grid@[0].len() == 1 ==> 
            result == (if obstacle_grid@[0][0] == 0 { 1i8 } else { 0i8 }),
        result as int == dp_path_count(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),
        (forall|i: int, j: int| #![trigger obstacle_grid@[i][j]] 0 <= i < obstacle_grid@.len() && 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[i][j] == 0) ==> 
            result as int == binomial(obstacle_grid@.len() + obstacle_grid@[0].len() - 2, obstacle_grid@.len() - 1),
        obstacle_grid@.len() == 1 ==> 
            (result > 0 <==> (forall|j: int| #![trigger obstacle_grid@[0][j]] 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[0][j] == 0)),
        obstacle_grid@[0].len() == 1 ==> 
            (result > 0 <==> (forall|i: int| #![trigger obstacle_grid@[i][0]] 0 <= i < obstacle_grid@.len() ==> obstacle_grid@[i][0] == 0))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && grid[0].len() > 0 &&
    (forall|i: int| #![trigger grid[i].len(), grid[0].len()] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()) &&
    (forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> 
        grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn binomial(n: int, k: int) -> int
    decreases n, k
{
    if k > n || n < 0 || k < 0 {
        0int
    } else if k == 0 || k == n {
        1int
    } else if k == 1 {
        n
    } else {
        binomial(n-1, k-1) + binomial(n-1, k)
    }
}

spec fn dp_path_count(grid: Seq<Seq<int>>) -> int
    recommends valid_grid(grid)
{
    let m = grid.len();
    let n = grid[0].len();
    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {
        0int
    } else if m == 1 && n == 1 {
        1int
    } else if m == 1 {
        if forall|j: int| #![trigger grid[0][j]] 0 <= j < n ==> grid[0][j] == 0 { 1int } else { 0int }
    } else if n == 1 {
        if forall|i: int| #![trigger grid[i][0]] 0 <= i < m ==> grid[i][0] == 0 { 1int } else { 0int }
    } else if forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 {
        binomial(m + n - 2, m - 1)
    } else {
        0int  /* placeholder for complex case */
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
exec fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i8>>) -> (result: i8)
    requires 
        valid_grid(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),
    ensures 
        result >= 0,
        obstacle_grid@[0][0] == 1 ==> result == 0,
        obstacle_grid@[obstacle_grid@.len()-1][obstacle_grid@[0].len()-1] == 1 ==> result == 0,
        obstacle_grid@.len() == 1 && obstacle_grid@[0].len() == 1 ==> 
            result == (if obstacle_grid@[0][0] == 0 { 1i8 } else { 0i8 }),
        result as int == dp_path_count(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),
        (forall|i: int, j: int| #![trigger obstacle_grid@[i][j]] 0 <= i < obstacle_grid@.len() && 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[i][j] == 0) ==> 
            result as int == binomial(obstacle_grid@.len() + obstacle_grid@[0].len() - 2, obstacle_grid@.len() - 1),
        obstacle_grid@.len() == 1 ==> 
            (result > 0 <==> (forall|j: int| #![trigger obstacle_grid@[0][j]] 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[0][j] == 0)),
        obstacle_grid@[0].len() == 1 ==> 
            (result > 0 <==> (forall|i: int| #![trigger obstacle_grid@[i][0]] 0 <= i < obstacle_grid@.len() ==> obstacle_grid@[i][0] == 0))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && grid[0].len() > 0 &&\n    (forall|i: int| #![trigger grid[i].len(), grid[0].len()] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()) &&\n    (forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn binomial(n: int, k: int) -> int\n    decreases n, k\n{\n    if k > n || n < 0 || k < 0 {\n        0int\n    } else if k == 0 || k == n {\n        1int\n    } else if k == 1 {\n        n\n    } else {\n        binomial(n-1, k-1) + binomial(n-1, k)\n    }\n}\n\nspec fn dp_path_count(grid: Seq<Seq<int>>) -> int\n    recommends valid_grid(grid)\n{\n    let m = grid.len();\n    let n = grid[0].len();\n    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {\n        0int\n    } else if m == 1 && n == 1 {\n        1int\n    } else if m == 1 {\n        if forall|j: int| #![trigger grid[0][j]] 0 <= j < n ==> grid[0][j] == 0 { 1int } else { 0int }\n    } else if n == 1 {\n        if forall|i: int| #![trigger grid[i][0]] 0 <= i < m ==> grid[i][0] == 0 { 1int } else { 0int }\n    } else if forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 {\n        binomial(m + n - 2, m - 1)\n    } else {\n        0int  /* placeholder for complex case */\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nexec fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i8>>) -> (result: i8)\n    requires \n        valid_grid(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n    ensures \n        result >= 0,\n        obstacle_grid@[0][0] == 1 ==> result == 0,\n        obstacle_grid@[obstacle_grid@.len()-1][obstacle_grid@[0].len()-1] == 1 ==> result == 0,\n        obstacle_grid@.len() == 1 && obstacle_grid@[0].len() == 1 ==> \n            result == (if obstacle_grid@[0][0] == 0 { 1i8 } else { 0i8 }),\n        result as int == dp_path_count(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),\n        (forall|i: int, j: int| #![trigger obstacle_grid@[i][j]] 0 <= i < obstacle_grid@.len() && 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[i][j] == 0) ==> \n            result as int == binomial(obstacle_grid@.len() + obstacle_grid@[0].len() - 2, obstacle_grid@.len() - 1),\n        obstacle_grid@.len() == 1 ==> \n            (result > 0 <==> (forall|j: int| #![trigger obstacle_grid@[0][j]] 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[0][j] == 0)),\n        obstacle_grid@[0].len() == 1 ==> \n            (result > 0 <==> (forall|i: int| #![trigger obstacle_grid@[i][0]] 0 <= i < obstacle_grid@.len() ==> obstacle_grid@[i][0] == 0))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2632.rs,56,56,1.0,123.505,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {
    path.len() >= 1 &&
    path[0] == (0int, 0int) &&
    path[path.len() - 1] == (m - 1, n - 1) &&
    (forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&
    forall|i: int| #![trigger path[i]] 0 <= i < path.len() - 1 ==> 
        (path[i + 1].0 == path[i].0 && path[i + 1].1 == path[i].1 + 1) ||
        (path[i + 1].0 == path[i].0 + 1 && path[i + 1].1 == path[i].1)
}

spec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int
    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()
    decreases path.len()
{
    if path.len() == 0 { 
        0 
    } else { 
        grid[path[0].0][path[0].1] as int + path_sum(path.subrange(1, path.len() as int), grid)
    }
}

spec fn valid_input(grid: Seq<Vec<i32>>) -> bool {
    grid.len() > 0 && 
    (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() > 0) &&
    (grid.len() > 0 ==> (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len())) &&
    forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] >= 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn min_path_sum(grid: Vec<Vec<i32>>) -> (result: i32)
    requires 
        valid_input(grid@),
    ensures 
        result >= 0,
        grid.len() == 1 && grid[0].len() == 1 ==> result == grid[0][0],
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {
    path.len() >= 1 &&
    path[0] == (0int, 0int) &&
    path[path.len() - 1] == (m - 1, n - 1) &&
    (forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&
    forall|i: int| #![trigger path[i]] 0 <= i < path.len() - 1 ==> 
        (path[i + 1].0 == path[i].0 && path[i + 1].1 == path[i].1 + 1) ||
        (path[i + 1].0 == path[i].0 + 1 && path[i + 1].1 == path[i].1)
}

spec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int
    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()
    decreases path.len()
{
    if path.len() == 0 { 
        0 
    } else { 
        grid[path[0].0][path[0].1] as int + path_sum(path.subrange(1, path.len() as int), grid)
    }
}

spec fn valid_input(grid: Seq<Vec<i32>>) -> bool {
    grid.len() > 0 && 
    (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() > 0) &&
    (grid.len() > 0 ==> (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len())) &&
    forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] >= 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn min_path_sum(grid: Vec<Vec<i32>>) -> (result: i32)
    requires 
        valid_input(grid@),
    ensures 
        result >= 0,
        grid.len() == 1 && grid[0].len() == 1 ==> result == grid[0][0],
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {\n    path.len() >= 1 &&\n    path[0] == (0int, 0int) &&\n    path[path.len() - 1] == (m - 1, n - 1) &&\n    (forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&\n    forall|i: int| #![trigger path[i]] 0 <= i < path.len() - 1 ==> \n        (path[i + 1].0 == path[i].0 && path[i + 1].1 == path[i].1 + 1) ||\n        (path[i + 1].0 == path[i].0 + 1 && path[i + 1].1 == path[i].1)\n}\n\nspec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int\n    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()\n    decreases path.len()\n{\n    if path.len() == 0 { \n        0 \n    } else { \n        grid[path[0].0][path[0].1] as int + path_sum(path.subrange(1, path.len() as int), grid)\n    }\n}\n\nspec fn valid_input(grid: Seq<Vec<i32>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (grid.len() > 0 ==> (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len())) &&\n    forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn min_path_sum(grid: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        valid_input(grid@),\n    ensures \n        result >= 0,\n        grid.len() == 1 && grid[0].len() == 1 ==> result == grid[0][0],\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n           fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_2633.rs,71,71,1.0,123.378,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {
    dungeon.len() > 0 &&
    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() > 0) &&
    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() == dungeon[0].len())
}

spec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool
    recommends valid_dungeon(dungeon)
{
    path.len() > 0 &&
    path[0] == (0int, 0int) &&
    path[path.len()-1] == (dungeon.len()-1, dungeon[0].len()-1) &&
    (forall|i: int| 0 <= i < path.len() ==> {
        let (r, c) = #[trigger] path[i];
        0 <= r < dungeon.len() && 0 <= c < dungeon[0].len()
    }) &&
    forall|i: int| 0 <= i < path.len()-1 ==> {
        (#[trigger] path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||
        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)
    }
}

spec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int
    recommends 
        valid_dungeon(dungeon),
        is_valid_path(dungeon, path),
        0 <= step < path.len()
    decreases step when step >= 0
{
    if step == 0 {
        let (r, c) = path[0];
        initial_health + dungeon[r][c]
    } else {
        let (r, c) = path[step];
        health_at_step(dungeon, path, (step-1) as int, initial_health) + dungeon[r][c]
    }
}

spec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool
    recommends
        valid_dungeon(dungeon),
        is_valid_path(dungeon, path)
{
    forall|i: int| 0 <= i < path.len() ==> 
        #[trigger] health_at_step(dungeon, path, i, initial_health) > 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn calculate_minimum_hp(dungeon: Vec<Vec<i8>>) -> (result: i8)
    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))
    ensures result >= 1
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {
    dungeon.len() > 0 &&
    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() > 0) &&
    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() == dungeon[0].len())
}

spec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool
    recommends valid_dungeon(dungeon)
{
    path.len() > 0 &&
    path[0] == (0int, 0int) &&
    path[path.len()-1] == (dungeon.len()-1, dungeon[0].len()-1) &&
    (forall|i: int| 0 <= i < path.len() ==> {
        let (r, c) = #[trigger] path[i];
        0 <= r < dungeon.len() && 0 <= c < dungeon[0].len()
    }) &&
    forall|i: int| 0 <= i < path.len()-1 ==> {
        (#[trigger] path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||
        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)
    }
}

spec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int
    recommends 
        valid_dungeon(dungeon),
        is_valid_path(dungeon, path),
        0 <= step < path.len()
    decreases step when step >= 0
{
    if step == 0 {
        let (r, c) = path[0];
        initial_health + dungeon[r][c]
    } else {
        let (r, c) = path[step];
        health_at_step(dungeon, path, (step-1) as int, initial_health) + dungeon[r][c]
    }
}

spec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool
    recommends
        valid_dungeon(dungeon),
        is_valid_path(dungeon, path)
{
    forall|i: int| 0 <= i < path.len() ==> 
        #[trigger] health_at_step(dungeon, path, i, initial_health) > 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn calculate_minimum_hp(dungeon: Vec<Vec<i8>>) -> (result: i8)
    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))
    ensures result >= 1
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {\n    dungeon.len() > 0 &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() > 0) &&\n    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() == dungeon[0].len())\n}\n\nspec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool\n    recommends valid_dungeon(dungeon)\n{\n    path.len() > 0 &&\n    path[0] == (0int, 0int) &&\n    path[path.len()-1] == (dungeon.len()-1, dungeon[0].len()-1) &&\n    (forall|i: int| 0 <= i < path.len() ==> {\n        let (r, c) = #[trigger] path[i];\n        0 <= r < dungeon.len() && 0 <= c < dungeon[0].len()\n    }) &&\n    forall|i: int| 0 <= i < path.len()-1 ==> {\n        (#[trigger] path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||\n        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)\n    }\n}\n\nspec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int\n    recommends \n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path),\n        0 <= step < path.len()\n    decreases step when step >= 0\n{\n    if step == 0 {\n        let (r, c) = path[0];\n        initial_health + dungeon[r][c]\n    } else {\n        let (r, c) = path[step];\n        health_at_step(dungeon, path, (step-1) as int, initial_health) + dungeon[r][c]\n    }\n}\n\nspec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool\n    recommends\n        valid_dungeon(dungeon),\n        is_valid_path(dungeon, path)\n{\n    forall|i: int| 0 <= i < path.len() ==> \n        #[trigger] health_at_step(dungeon, path, i, initial_health) > 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn calculate_minimum_hp(dungeon: Vec<Vec<i8>>) -> (result: i8)\n    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))\n    ensures result >= 1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_27.rs,56,56,1.0,92.832,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, s: Seq<char>) -> bool {
    s.len() == n
}

spec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {
    max_copy_savings_up_to(s, n, n / 2)
}

spec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat
    decreases limit
{
    if limit == 0 { 0 }
    else {
        let i = (limit - 1) as nat;
        let current = if can_copy_at(s, n, i) { i } else { 0 };
        let prev = max_copy_savings_up_to(s, n, i);
        if current > prev { current } else { prev }
    }
}

spec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {
    let prefix_len = i + 1;
    let end_pos = i + 1 + prefix_len;
    end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i+1) as int, end_pos as int)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, s: Vec<char>) -> (result: u8)
    requires 
        valid_input(n as nat, s@)
    ensures 
        result as nat <= n as nat,
        n == 0 ==> result == 0,
        n > 0 ==> result >= 1,
        result as nat == n as nat - max_copy_savings(s@, n as nat)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, s: Seq<char>) -> bool {
    s.len() == n
}

spec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {
    max_copy_savings_up_to(s, n, n / 2)
}

spec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat
    decreases limit
{
    if limit == 0 { 0 }
    else {
        let i = (limit - 1) as nat;
        let current = if can_copy_at(s, n, i) { i } else { 0 };
        let prev = max_copy_savings_up_to(s, n, i);
        if current > prev { current } else { prev }
    }
}

spec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {
    let prefix_len = i + 1;
    let end_pos = i + 1 + prefix_len;
    end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i+1) as int, end_pos as int)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, s: Vec<char>) -> (result: u8)
    requires 
        valid_input(n as nat, s@)
    ensures 
        result as nat <= n as nat,
        n == 0 ==> result == 0,
        n > 0 ==> result >= 1,
        result as nat == n as nat - max_copy_savings(s@, n as nat)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, s: Seq<char>) -> bool {\n    s.len() == n\n}\n\nspec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {\n    max_copy_savings_up_to(s, n, n / 2)\n}\n\nspec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat\n    decreases limit\n{\n    if limit == 0 { 0 }\n    else {\n        let i = (limit - 1) as nat;\n        let current = if can_copy_at(s, n, i) { i } else { 0 };\n        let prev = max_copy_savings_up_to(s, n, i);\n        if current > prev { current } else { prev }\n    }\n}\n\nspec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {\n    let prefix_len = i + 1;\n    let end_pos = i + 1 + prefix_len;\n    end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i+1) as int, end_pos as int)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, s: Vec<char>) -> (result: u8)\n    requires \n        valid_input(n as nat, s@)\n    ensures \n        result as nat <= n as nat,\n        n == 0 ==> result == 0,\n        n > 0 ==> result >= 1,\n        result as nat == n as nat - max_copy_savings(s@, n as nat)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_287.rs,56,56,1.0,92.411,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool
{
    n >= 1 && k >= 0 && k <= n
}

spec fn valid_output(result: Seq<int>, n: int, k: int) -> bool
{
    result.len() == 2 && 
    result[0] >= 0 && 
    result[1] >= 0 && 
    result[0] <= result[1] &&
    result[0] <= n - k &&
    result[1] <= n - k
}

spec fn min_good_apartments(n: int, k: int) -> int
{
    if k == 0 || k == n { 0 } else { 1 }
}

spec fn max_good_apartments(n: int, k: int) -> int
{
    if k == 0 || k == n { 0 }
    else if n - k < k * 2 { n - k }
    else { k * 2 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: Vec<i8>)
    requires valid_input(n as int, k as int)
    ensures 
        result.len() == 2 &&
        valid_output(result@.map(|i: int, x: i8| x as int), n as int, k as int) &&
        result[0] as int == min_good_apartments(n as int, k as int) &&
        result[1] as int == max_good_apartments(n as int, k as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool
{
    n >= 1 && k >= 0 && k <= n
}

spec fn valid_output(result: Seq<int>, n: int, k: int) -> bool
{
    result.len() == 2 && 
    result[0] >= 0 && 
    result[1] >= 0 && 
    result[0] <= result[1] &&
    result[0] <= n - k &&
    result[1] <= n - k
}

spec fn min_good_apartments(n: int, k: int) -> int
{
    if k == 0 || k == n { 0 } else { 1 }
}

spec fn max_good_apartments(n: int, k: int) -> int
{
    if k == 0 || k == n { 0 }
    else if n - k < k * 2 { n - k }
    else { k * 2 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: Vec<i8>)
    requires valid_input(n as int, k as int)
    ensures 
        result.len() == 2 &&
        valid_output(result@.map(|i: int, x: i8| x as int), n as int, k as int) &&
        result[0] as int == min_good_apartments(n as int, k as int) &&
        result[1] as int == max_good_apartments(n as int, k as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n >= 1 && k >= 0 && k <= n\n}\n\nspec fn valid_output(result: Seq<int>, n: int, k: int) -> bool\n{\n    result.len() == 2 && \n    result[0] >= 0 && \n    result[1] >= 0 && \n    result[0] <= result[1] &&\n    result[0] <= n - k &&\n    result[1] <= n - k\n}\n\nspec fn min_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 } else { 1 }\n}\n\nspec fn max_good_apartments(n: int, k: int) -> int\n{\n    if k == 0 || k == n { 0 }\n    else if n - k < k * 2 { n - k }\n    else { k * 2 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires valid_input(n as int, k as int)\n    ensures \n        result.len() == 2 &&\n        valid_output(result@.map(|i: int, x: i8| x as int), n as int, k as int) &&\n        result[0] as int == min_good_apartments(n as int, k as int) &&\n        result[1] as int == max_good_apartments(n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_299.rs,110,110,1.0,122.58,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn chest_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 0 { reps[0int] } else { 0int };
        first + chest_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn chest_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 0 { reps[0int] } else { 0int };
        first + chest_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn biceps_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 1 { reps[0int] } else { 0int };
        first + biceps_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn biceps_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 1 { reps[0int] } else { 0int };
        first + biceps_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn back_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 2 { reps[0int] } else { 0int };
        first + back_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn back_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 2 { reps[0int] } else { 0int };
        first + back_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn valid_input(reps: Seq<int>) -> bool {
    reps.len() > 0 && forall|i: int| 0 <= i < reps.len() ==> reps[i] > 0
}

spec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {
    let chest_total_val = chest_total(reps);
    let biceps_total_val = biceps_total(reps);
    let back_total_val = back_total(reps);

    match muscle {
        ""chest"" => chest_total_val >= biceps_total_val && chest_total_val >= back_total_val,
        ""biceps"" => biceps_total_val > chest_total_val && biceps_total_val >= back_total_val,
        ""back"" => back_total_val > chest_total_val && back_total_val > biceps_total_val,
        _ => false,
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn find_strongest_muscle_group(reps: Vec<i8>) -> (result: &'static str)
    requires 
        valid_input(reps@.map(|i: int, x: i8| x as int))
    ensures 
        result == ""chest"" || result == ""biceps"" || result == ""back"",
        is_winner(result, reps@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""chest""
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn chest_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 0 { reps[0int] } else { 0int };
        first + chest_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn chest_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 0 { reps[0int] } else { 0int };
        first + chest_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn biceps_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 1 { reps[0int] } else { 0int };
        first + biceps_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn biceps_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 1 { reps[0int] } else { 0int };
        first + biceps_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn back_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 2 { reps[0int] } else { 0int };
        first + back_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn back_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 2 { reps[0int] } else { 0int };
        first + back_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn valid_input(reps: Seq<int>) -> bool {
    reps.len() > 0 && forall|i: int| 0 <= i < reps.len() ==> reps[i] > 0
}

spec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {
    let chest_total_val = chest_total(reps);
    let biceps_total_val = biceps_total(reps);
    let back_total_val = back_total(reps);

    match muscle {
        ""chest"" => chest_total_val >= biceps_total_val && chest_total_val >= back_total_val,
        ""biceps"" => biceps_total_val > chest_total_val && biceps_total_val >= back_total_val,
        ""back"" => back_total_val > chest_total_val && back_total_val > biceps_total_val,
        _ => false,
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn find_strongest_muscle_group(reps: Vec<i8>) -> (result: &'static str)
    requires 
        valid_input(reps@.map(|i: int, x: i8| x as int))
    ensures 
        result == ""chest"" || result == ""biceps"" || result == ""back"",
        is_winner(result, reps@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""chest""
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn chest_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn chest_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 0 { reps[0int] } else { 0int };\n        first + chest_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn biceps_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn biceps_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 1 { reps[0int] } else { 0int };\n        first + biceps_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn back_total(reps: Seq<int>) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if 0int % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), 1int)\n    }\n}\n\nspec fn back_total_helper(reps: Seq<int>, index: int) -> int \ndecreases reps.len()\n{\n    if reps.len() == 0 {\n        0int\n    } else {\n        let first = if index % 3 == 2 { reps[0int] } else { 0int };\n        first + back_total_helper(reps.subrange(1, reps.len() as int), index + 1)\n    }\n}\n\nspec fn valid_input(reps: Seq<int>) -> bool {\n    reps.len() > 0 && forall|i: int| 0 <= i < reps.len() ==> reps[i] > 0\n}\n\nspec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {\n    let chest_total_val = chest_total(reps);\n    let biceps_total_val = biceps_total(reps);\n    let back_total_val = back_total(reps);\n\n    match muscle {\n        ""chest"" => chest_total_val >= biceps_total_val && chest_total_val >= back_total_val,\n        ""biceps"" => biceps_total_val > chest_total_val && biceps_total_val >= back_total_val,\n        ""back"" => back_total_val > chest_total_val && back_total_val > biceps_total_val,\n        _ => false,\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_strongest_muscle_group(reps: Vec<i8>) -> (result: &\'static str)\n    requires \n        valid_input(reps@.map(|i: int, x: i8| x as int))\n    ensures \n        result == ""chest"" || result == ""biceps"" || result == ""back"",\n        is_winner(result, reps@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""chest""\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_302.rs,53,53,1.0,92.034,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn pow(base: nat, exp: nat) -> nat
    decreases exp
{
    if exp == 0 { 1 } else { base * pow(base, (exp - 1) as nat) }
}

spec fn repunit(n: nat) -> nat
{
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else if n == 2 { 11 }
    else if n == 3 { 111 }
    else if n == 4 { 1111 }
    else if n == 5 { 11111 }
    else { n }
}

spec fn valid_input(n: nat) -> bool
{
    true
}

spec fn valid_output(n: nat, result: nat) -> bool
{
    (n == 0 ==> result == 0) &&
    (n > 0 ==> result > 0)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn min_repunit_sum(n: u8) -> (result: u8)
    requires valid_input(n as nat)
    ensures valid_output(n as nat, result as nat)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn pow(base: nat, exp: nat) -> nat
    decreases exp
{
    if exp == 0 { 1 } else { base * pow(base, (exp - 1) as nat) }
}

spec fn repunit(n: nat) -> nat
{
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else if n == 2 { 11 }
    else if n == 3 { 111 }
    else if n == 4 { 1111 }
    else if n == 5 { 11111 }
    else { n }
}

spec fn valid_input(n: nat) -> bool
{
    true
}

spec fn valid_output(n: nat, result: nat) -> bool
{
    (n == 0 ==> result == 0) &&
    (n > 0 ==> result > 0)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn min_repunit_sum(n: u8) -> (result: u8)
    requires valid_input(n as nat)
    ensures valid_output(n as nat, result as nat)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 } else { base * pow(base, (exp - 1) as nat) }\n}\n\nspec fn repunit(n: nat) -> nat\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else if n == 2 { 11 }\n    else if n == 3 { 111 }\n    else if n == 4 { 1111 }\n    else if n == 5 { 11111 }\n    else { n }\n}\n\nspec fn valid_input(n: nat) -> bool\n{\n    true\n}\n\nspec fn valid_output(n: nat, result: nat) -> bool\n{\n    (n == 0 ==> result == 0) &&\n    (n > 0 ==> result > 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn min_repunit_sum(n: u8) -> (result: u8)\n    requires valid_input(n as nat)\n    ensures valid_output(n as nat, result as nat)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_3805.rs,59,59,1.0,92.144,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn extract_first_line(input: Seq<char>) -> Seq<char>
    decreases input.len()
{
    if input.len() == 0 {
        Seq::empty()
    } else if input[0] == '\n' {
        Seq::empty()
    } else {
        seq![input[0]] + extract_first_line(input.subrange(1, input.len() as int))
    }
}

spec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>
    decreases input.len()
{
    if input.len() == 0 {
        stack
    } else {
        let c = input[0];
        let new_stack = if stack.len() > 0 && stack[stack.len() - 1] == c {
            stack.subrange(0, stack.len() - 1)
        } else {
            stack.push(c)
        };
        process_string(input.subrange(1, input.len() as int), new_stack)
    }
}

spec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool
{
    let stack = process_string(input, Seq::empty());
    stack.len() == 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    ensures result@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn extract_first_line(input: Seq<char>) -> Seq<char>
    decreases input.len()
{
    if input.len() == 0 {
        Seq::empty()
    } else if input[0] == '\n' {
        Seq::empty()
    } else {
        seq![input[0]] + extract_first_line(input.subrange(1, input.len() as int))
    }
}

spec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>
    decreases input.len()
{
    if input.len() == 0 {
        stack
    } else {
        let c = input[0];
        let new_stack = if stack.len() > 0 && stack[stack.len() - 1] == c {
            stack.subrange(0, stack.len() - 1)
        } else {
            stack.push(c)
        };
        process_string(input.subrange(1, input.len() as int), new_stack)
    }
}

spec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool
{
    let stack = process_string(input, Seq::empty());
    stack.len() == 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    ensures result@.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn extract_first_line(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        Seq::empty()\n    } else if input[0] == '\\n' {\n        Seq::empty()\n    } else {\n        seq![input[0]] + extract_first_line(input.subrange(1, input.len() as int))\n    }\n}\n\nspec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        stack\n    } else {\n        let c = input[0];\n        let new_stack = if stack.len() > 0 && stack[stack.len() - 1] == c {\n            stack.subrange(0, stack.len() - 1)\n        } else {\n            stack.push(c)\n        };\n        process_string(input.subrange(1, input.len() as int), new_stack)\n    }\n}\n\nspec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool\n{\n    let stack = process_string(input, Seq::empty());\n    stack.len() == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4088.rs,85,85,1.0,122.165,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0
    /* TODO: Implement full validation logic for:
     * - Lines parsing and validation
     * - Test case count validation  
     * - String and integer array parsing
     * - Character and bounds validation
     */
}

spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> output.len() > 0
    /* TODO: Implement validation for:
     * - Output lines matching test cases
     * - Correct string lengths
     * - Valid lowercase characters
     */
}

spec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> true
    /* TODO: Implement constraint validation for:
     * - Distance sum calculations
     * - Character ordering requirements
     */
}

spec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> true
    /* TODO: Implement character count preservation:
     * - Character frequency validation
     * - Subset usage validation
     */
}

spec fn contains_newline_terminated_results(output: Seq<char>) -> bool {
    output.len() > 0 ==> output[output.len() - 1] == '\n'
}

spec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {
    0
    /* TODO: Implement distance sum calculation:
     * - Compare characters lexicographically
     * - Calculate absolute differences
     * - Sum all applicable distances
     */
}

spec fn abs_diff(i: int, j: int) -> int {
    if i >= j { i - j } else { j - i }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: String) -> (result: String)
    requires 
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures 
        valid_output_format(result@, stdin_input@),
        output_satisfies_constraints(result@, stdin_input@),
        preserves_character_usage(result@, stdin_input@),
        result@.len() > 0 ==> contains_newline_terminated_results(result@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0
    /* TODO: Implement full validation logic for:
     * - Lines parsing and validation
     * - Test case count validation  
     * - String and integer array parsing
     * - Character and bounds validation
     */
}

spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> output.len() > 0
    /* TODO: Implement validation for:
     * - Output lines matching test cases
     * - Correct string lengths
     * - Valid lowercase characters
     */
}

spec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> true
    /* TODO: Implement constraint validation for:
     * - Distance sum calculations
     * - Character ordering requirements
     */
}

spec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> true
    /* TODO: Implement character count preservation:
     * - Character frequency validation
     * - Subset usage validation
     */
}

spec fn contains_newline_terminated_results(output: Seq<char>) -> bool {
    output.len() > 0 ==> output[output.len() - 1] == '\n'
}

spec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {
    0
    /* TODO: Implement distance sum calculation:
     * - Compare characters lexicographically
     * - Calculate absolute differences
     * - Sum all applicable distances
     */
}

spec fn abs_diff(i: int, j: int) -> int {
    if i >= j { i - j } else { j - i }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: String) -> (result: String)
    requires 
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures 
        valid_output_format(result@, stdin_input@),
        output_satisfies_constraints(result@, stdin_input@),
        preserves_character_usage(result@, stdin_input@),
        result@.len() > 0 ==> contains_newline_terminated_results(result@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0\n    /* TODO: Implement full validation logic for:\n     * - Lines parsing and validation\n     * - Test case count validation  \n     * - String and integer array parsing\n     * - Character and bounds validation\n     */\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> output.len() > 0\n    /* TODO: Implement validation for:\n     * - Output lines matching test cases\n     * - Correct string lengths\n     * - Valid lowercase characters\n     */\n}\n\nspec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement constraint validation for:\n     * - Distance sum calculations\n     * - Character ordering requirements\n     */\n}\n\nspec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {\n    valid_input_format(input) ==> true\n    /* TODO: Implement character count preservation:\n     * - Character frequency validation\n     * - Subset usage validation\n     */\n}\n\nspec fn contains_newline_terminated_results(output: Seq<char>) -> bool {\n    output.len() > 0 ==> output[output.len() - 1] == '\\n'\n}\n\nspec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {\n    0\n    /* TODO: Implement distance sum calculation:\n     * - Compare characters lexicographically\n     * - Calculate absolute differences\n     * - Sum all applicable distances\n     */\n}\n\nspec fn abs_diff(i: int, j: int) -> int {\n    if i >= j { i - j } else { j - i }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        valid_output_format(result@, stdin_input@),\n        output_satisfies_constraints(result@, stdin_input@),\n        preserves_character_usage(result@, stdin_input@),\n        result@.len() > 0 ==> contains_newline_terminated_results(result@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_409.rs,70,70,1.0,92.513,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat 
    decreases s.len()
{
    if pattern.len() == 0 || s.len() < pattern.len() {
        0
    } else if s.subrange(0, pattern.len() as int) =~= pattern {
        1 + count_substring(s.subrange(1, s.len() as int), pattern)
    } else {
        count_substring(s.subrange(1, s.len() as int), pattern)
    }
}

spec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int 
    decreases s.len()
{
    if pattern.len() == 0 || s.len() < pattern.len() {
        -1
    } else if s.subrange(0, pattern.len() as int) =~= pattern {
        0
    } else {
        let rest = find_index(s.subrange(1, s.len() as int), pattern);
        if rest == -1 { -1 } else { 1 + rest }
    }
}

spec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {
    let ab_pattern = seq!['A', 'B'];
    let ba_pattern = seq!['B', 'A'];
    let ab_index = find_index(s, ab_pattern);
    let ba_index = find_index(s, ba_pattern);

    (ab_index >= 0 && ba_index >= 0) &&
    (
        (ab_index >= 0 && ab_index + 2 < s.len() && count_substring(s.subrange(ab_index + 2, s.len() as int), ba_pattern) > 0) ||
        (ba_index >= 0 && ba_index + 2 < s.len() && count_substring(s.subrange(ba_index + 2, s.len() as int), ab_pattern) > 0)
    )
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures 
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        has_non_overlapping_ab_and_ba(input@) <==> result@ == seq!['Y', 'E', 'S']
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    vec!['N', 'O']
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat 
    decreases s.len()
{
    if pattern.len() == 0 || s.len() < pattern.len() {
        0
    } else if s.subrange(0, pattern.len() as int) =~= pattern {
        1 + count_substring(s.subrange(1, s.len() as int), pattern)
    } else {
        count_substring(s.subrange(1, s.len() as int), pattern)
    }
}

spec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int 
    decreases s.len()
{
    if pattern.len() == 0 || s.len() < pattern.len() {
        -1
    } else if s.subrange(0, pattern.len() as int) =~= pattern {
        0
    } else {
        let rest = find_index(s.subrange(1, s.len() as int), pattern);
        if rest == -1 { -1 } else { 1 + rest }
    }
}

spec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {
    let ab_pattern = seq!['A', 'B'];
    let ba_pattern = seq!['B', 'A'];
    let ab_index = find_index(s, ab_pattern);
    let ba_index = find_index(s, ba_pattern);

    (ab_index >= 0 && ba_index >= 0) &&
    (
        (ab_index >= 0 && ab_index + 2 < s.len() && count_substring(s.subrange(ab_index + 2, s.len() as int), ba_pattern) > 0) ||
        (ba_index >= 0 && ba_index + 2 < s.len() && count_substring(s.subrange(ba_index + 2, s.len() as int), ab_pattern) > 0)
    )
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures 
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        has_non_overlapping_ab_and_ba(input@) <==> result@ == seq!['Y', 'E', 'S']
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    vec!['N', 'O']
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        0\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        1 + count_substring(s.subrange(1, s.len() as int), pattern)\n    } else {\n        count_substring(s.subrange(1, s.len() as int), pattern)\n    }\n}\n\nspec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int \n    decreases s.len()\n{\n    if pattern.len() == 0 || s.len() < pattern.len() {\n        -1\n    } else if s.subrange(0, pattern.len() as int) =~= pattern {\n        0\n    } else {\n        let rest = find_index(s.subrange(1, s.len() as int), pattern);\n        if rest == -1 { -1 } else { 1 + rest }\n    }\n}\n\nspec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {\n    let ab_pattern = seq!['A', 'B'];\n    let ba_pattern = seq!['B', 'A'];\n    let ab_index = find_index(s, ab_pattern);\n    let ba_index = find_index(s, ba_pattern);\n\n    (ab_index >= 0 && ba_index >= 0) &&\n    (\n        (ab_index >= 0 && ab_index + 2 < s.len() && count_substring(s.subrange(ab_index + 2, s.len() as int), ba_pattern) > 0) ||\n        (ba_index >= 0 && ba_index + 2 < s.len() && count_substring(s.subrange(ba_index + 2, s.len() as int), ab_pattern) > 0)\n    )\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        has_non_overlapping_ab_and_ba(input@) <==> result@ == seq!['Y', 'E', 'S']\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    vec!['N', 'O']\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4111.rs,84,84,1.0,92.4,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, arr: Seq<int>) -> bool {
    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < n ==> arr[i] >= 1
}

spec fn sum_even_indices(arr: Seq<int>, start: int) -> int
    decreases arr.len() - start when 0 <= start <= arr.len()
{
    if start == arr.len() {
        0
    } else {
        let contribution = if start % 2 == 0 { arr[start] } else { 0 };
        contribution + sum_even_indices(arr, start + 1)
    }
}

spec fn sum_odd_indices(arr: Seq<int>, start: int) -> int
    decreases arr.len() - start when 0 <= start <= arr.len()
{
    if start == arr.len() {
        0
    } else {
        let contribution = if start % 2 == 1 { arr[start] } else { 0 };
        contribution + sum_odd_indices(arr, start + 1)
    }
}

spec fn count_balanced_removals(arr: Seq<int>) -> int {
    let n = arr.len();
    if n == 0 {
        0
    } else {
        count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)
    }
}

spec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int
    decreases arr.len() - i when 0 <= i <= arr.len()
{
    if i == arr.len() {
        0
    } else {
        let contribution: int = 
            if i % 2 == 0 {
                let val1 = temp1 + count2 - temp2;
                let val2 = temp2 + count1 - temp1 - arr[i];
                if val1 == val2 { 1 } else { 0 }
            } else {
                let val1 = temp1 + count2 - temp2 - arr[i];
                let val2 = temp2 + count1 - temp1;
                if val1 == val2 { 1 } else { 0 }
            };
        let new_temp1 = if i % 2 == 0 { temp1 + arr[i] } else { temp1 };
        let new_temp2 = if i % 2 == 1 { temp2 + arr[i] } else { temp2 };
        contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, arr: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, arr@.map(|i: int, x: i8| x as int)),
    ensures 
        0 <= result as int <= n as int,
        result as int == count_balanced_removals(arr@.map(|i: int, x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, arr: Seq<int>) -> bool {
    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < n ==> arr[i] >= 1
}

spec fn sum_even_indices(arr: Seq<int>, start: int) -> int
    decreases arr.len() - start when 0 <= start <= arr.len()
{
    if start == arr.len() {
        0
    } else {
        let contribution = if start % 2 == 0 { arr[start] } else { 0 };
        contribution + sum_even_indices(arr, start + 1)
    }
}

spec fn sum_odd_indices(arr: Seq<int>, start: int) -> int
    decreases arr.len() - start when 0 <= start <= arr.len()
{
    if start == arr.len() {
        0
    } else {
        let contribution = if start % 2 == 1 { arr[start] } else { 0 };
        contribution + sum_odd_indices(arr, start + 1)
    }
}

spec fn count_balanced_removals(arr: Seq<int>) -> int {
    let n = arr.len();
    if n == 0 {
        0
    } else {
        count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)
    }
}

spec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int
    decreases arr.len() - i when 0 <= i <= arr.len()
{
    if i == arr.len() {
        0
    } else {
        let contribution: int = 
            if i % 2 == 0 {
                let val1 = temp1 + count2 - temp2;
                let val2 = temp2 + count1 - temp1 - arr[i];
                if val1 == val2 { 1 } else { 0 }
            } else {
                let val1 = temp1 + count2 - temp2 - arr[i];
                let val2 = temp2 + count1 - temp1;
                if val1 == val2 { 1 } else { 0 }
            };
        let new_temp1 = if i % 2 == 0 { temp1 + arr[i] } else { temp1 };
        let new_temp2 = if i % 2 == 1 { temp2 + arr[i] } else { temp2 };
        contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, arr: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, arr@.map(|i: int, x: i8| x as int)),
    ensures 
        0 <= result as int <= n as int,
        result as int == count_balanced_removals(arr@.map(|i: int, x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, arr: Seq<int>) -> bool {\n    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < n ==> arr[i] >= 1\n}\n\nspec fn sum_even_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 0 { arr[start] } else { 0 };\n        contribution + sum_even_indices(arr, start + 1)\n    }\n}\n\nspec fn sum_odd_indices(arr: Seq<int>, start: int) -> int\n    decreases arr.len() - start when 0 <= start <= arr.len()\n{\n    if start == arr.len() {\n        0\n    } else {\n        let contribution = if start % 2 == 1 { arr[start] } else { 0 };\n        contribution + sum_odd_indices(arr, start + 1)\n    }\n}\n\nspec fn count_balanced_removals(arr: Seq<int>) -> int {\n    let n = arr.len();\n    if n == 0 {\n        0\n    } else {\n        count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)\n    }\n}\n\nspec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int\n    decreases arr.len() - i when 0 <= i <= arr.len()\n{\n    if i == arr.len() {\n        0\n    } else {\n        let contribution: int = \n            if i % 2 == 0 {\n                let val1 = temp1 + count2 - temp2;\n                let val2 = temp2 + count1 - temp1 - arr[i];\n                if val1 == val2 { 1 } else { 0 }\n            } else {\n                let val1 = temp1 + count2 - temp2 - arr[i];\n                let val2 = temp2 + count1 - temp1;\n                if val1 == val2 { 1 } else { 0 }\n            };\n        let new_temp1 = if i % 2 == 0 { temp1 + arr[i] } else { temp1 };\n        let new_temp2 = if i % 2 == 1 { temp2 + arr[i] } else { temp2 };\n        contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, arr: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, arr@.map(|i: int, x: i8| x as int)),\n    ensures \n        0 <= result as int <= n as int,\n        result as int == count_balanced_removals(arr@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4115.rs,58,58,1.0,122.473,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1
}

spec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int
    decreases limit
{
    if limit <= 0 || s.len() < 1 { 
        0 
    } else {
        let n = s.len() as int - 1;
        let mismatch: int = if limit > 0 && limit <= s.len() && s[limit-1] != s[n - (limit-1)] { 1 } else { 0 };
        count_mismatches_up_to(s, limit-1) + mismatch
    }
}

spec fn count_mismatches(s: Seq<char>) -> int {
    if s.len() >= 1 {
        count_mismatches_up_to(s, s.len() as int)
    } else {
        0
    }
}

spec fn valid_result(s: Seq<char>, result: int) -> bool {
    if valid_input(s) {
        result >= 0 && result <= s.len() / 2 && result == (count_mismatches(s) / 2)
    } else {
        false
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures valid_result(s@, result as int)
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1
}

spec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int
    decreases limit
{
    if limit <= 0 || s.len() < 1 { 
        0 
    } else {
        let n = s.len() as int - 1;
        let mismatch: int = if limit > 0 && limit <= s.len() && s[limit-1] != s[n - (limit-1)] { 1 } else { 0 };
        count_mismatches_up_to(s, limit-1) + mismatch
    }
}

spec fn count_mismatches(s: Seq<char>) -> int {
    if s.len() >= 1 {
        count_mismatches_up_to(s, s.len() as int)
    } else {
        0
    }
}

spec fn valid_result(s: Seq<char>, result: int) -> bool {
    if valid_input(s) {
        result >= 0 && result <= s.len() / 2 && result == (count_mismatches(s) / 2)
    } else {
        false
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures valid_result(s@, result as int)
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1\n}\n\nspec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int\n    decreases limit\n{\n    if limit <= 0 || s.len() < 1 { \n        0 \n    } else {\n        let n = s.len() as int - 1;\n        let mismatch: int = if limit > 0 && limit <= s.len() && s[limit-1] != s[n - (limit-1)] { 1 } else { 0 };\n        count_mismatches_up_to(s, limit-1) + mismatch\n    }\n}\n\nspec fn count_mismatches(s: Seq<char>) -> int {\n    if s.len() >= 1 {\n        count_mismatches_up_to(s, s.len() as int)\n    } else {\n        0\n    }\n}\n\nspec fn valid_result(s: Seq<char>, result: int) -> bool {\n    if valid_input(s) {\n        result >= 0 && result <= s.len() / 2 && result == (count_mismatches(s) / 2)\n    } else {\n        false\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures valid_result(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4143.rs,55,55,1.0,122.286,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {
    n >= 1 && a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1
}

spec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int
    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1
{
    let temp1 = if a <= b { a } else { b };
    let temp2 = if temp1 <= c { temp1 } else { c };
    let temp3 = if temp2 <= d { temp2 } else { d };
    if temp3 <= e { temp3 } else { e }
}

spec fn ceil_div(a: int, b: int) -> int
    recommends a >= 0 && b >= 1
{
    (a + b - 1) / b
}

spec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool
    recommends valid_input(n, a, b, c, d, e)
{
    let min_cap = min_capacity(a, b, c, d, e);
    let groups = ceil_div(n, min_cap);
    result == 4 + groups
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, c: i8, d: i8, e: i8) -> (result: i8)
    requires 
        valid_input(n as int, a as int, b as int, c as int, d as int, e as int)
    ensures 
        correct_result(n as int, a as int, b as int, c as int, d as int, e as int, result as int) &&
        result >= 5
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {
    n >= 1 && a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1
}

spec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int
    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1
{
    let temp1 = if a <= b { a } else { b };
    let temp2 = if temp1 <= c { temp1 } else { c };
    let temp3 = if temp2 <= d { temp2 } else { d };
    if temp3 <= e { temp3 } else { e }
}

spec fn ceil_div(a: int, b: int) -> int
    recommends a >= 0 && b >= 1
{
    (a + b - 1) / b
}

spec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool
    recommends valid_input(n, a, b, c, d, e)
{
    let min_cap = min_capacity(a, b, c, d, e);
    let groups = ceil_div(n, min_cap);
    result == 4 + groups
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, c: i8, d: i8, e: i8) -> (result: i8)
    requires 
        valid_input(n as int, a as int, b as int, c as int, d as int, e as int)
    ensures 
        correct_result(n as int, a as int, b as int, c as int, d as int, e as int, result as int) &&
        result >= 5
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {\n    n >= 1 && a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n}\n\nspec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int\n    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1\n{\n    let temp1 = if a <= b { a } else { b };\n    let temp2 = if temp1 <= c { temp1 } else { c };\n    let temp3 = if temp2 <= d { temp2 } else { d };\n    if temp3 <= e { temp3 } else { e }\n}\n\nspec fn ceil_div(a: int, b: int) -> int\n    recommends a >= 0 && b >= 1\n{\n    (a + b - 1) / b\n}\n\nspec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool\n    recommends valid_input(n, a, b, c, d, e)\n{\n    let min_cap = min_capacity(a, b, c, d, e);\n    let groups = ceil_div(n, min_cap);\n    result == 4 + groups\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, c: i8, d: i8, e: i8) -> (result: i8)\n    requires \n        valid_input(n as int, a as int, b as int, c as int, d as int, e as int)\n    ensures \n        correct_result(n as int, a as int, b as int, c as int, d as int, e as int, result as int) &&\n        result >= 5\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4159.rs,51,51,1.0,122.472,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, k: int) -> bool {
    a >= 0 && b >= 0 && k >= 0
}

spec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int
    recommends valid_input(a, b, k)
{
    if a >= k { a - k }
    else { 0 }
}

spec fn expected_aoki_cookies(a: int, b: int, k: int) -> int
    recommends valid_input(a, b, k)
{
    if a >= k { b }
    else if k - a < b { b - (k - a) }
    else { 0 }
}

spec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool
    recommends valid_input(a, b, k)
{
    takahashi == expected_takahashi_cookies(a, b, k) &&
    aoki == expected_aoki_cookies(a, b, k) &&
    takahashi >= 0 && aoki >= 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, k: i8) -> (result: (i8, i8))
    requires valid_input(a as int, b as int, k as int)
    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, k: int) -> bool {
    a >= 0 && b >= 0 && k >= 0
}

spec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int
    recommends valid_input(a, b, k)
{
    if a >= k { a - k }
    else { 0 }
}

spec fn expected_aoki_cookies(a: int, b: int, k: int) -> int
    recommends valid_input(a, b, k)
{
    if a >= k { b }
    else if k - a < b { b - (k - a) }
    else { 0 }
}

spec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool
    recommends valid_input(a, b, k)
{
    takahashi == expected_takahashi_cookies(a, b, k) &&
    aoki == expected_aoki_cookies(a, b, k) &&
    takahashi >= 0 && aoki >= 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, k: i8) -> (result: (i8, i8))
    requires valid_input(a as int, b as int, k as int)
    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int, k: int) -> bool {\n    a >= 0 && b >= 0 && k >= 0\n}\n\nspec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { a - k }\n    else { 0 }\n}\n\nspec fn expected_aoki_cookies(a: int, b: int, k: int) -> int\n    recommends valid_input(a, b, k)\n{\n    if a >= k { b }\n    else if k - a < b { b - (k - a) }\n    else { 0 }\n}\n\nspec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool\n    recommends valid_input(a, b, k)\n{\n    takahashi == expected_takahashi_cookies(a, b, k) &&\n    aoki == expected_aoki_cookies(a, b, k) &&\n    takahashi >= 0 && aoki >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, k: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, k as int)\n    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4167.rs,63,63,1.0,92.483,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool
    recommends k >= 1
{
    1 <= a <= n && 1 <= b <= n && 1 <= c <= n &&
    (a + b) % k == 0 && (b + c) % k == 0 && (c + a) % k == 0
}

spec fn count_valid_triples(n: int, k: int) -> int
    recommends n >= 1 && k >= 1
{
    if k % 2 == 1 {
        let cnt1 = n / k;
        cnt1 * cnt1 * cnt1
    } else {
        let cnt1 = n / k;
        let cnt2 = n / k + (if n % k >= k / 2 { 1int } else { 0int });
        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2
    }
}

spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 1
}

spec fn count_divisible_by_k(n: int, k: int) -> int
    recommends k >= 1
{
    if n <= 0 { 0int } else { n / k }
}

spec fn count_with_remainder_half_k(n: int, k: int) -> int
    recommends k >= 1
{
    if n <= 0 { 0int } else { n / k + (if n % k >= k / 2 { 1int } else { 0int }) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result >= 0,
        result as int == count_valid_triples(n as int, k as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool
    recommends k >= 1
{
    1 <= a <= n && 1 <= b <= n && 1 <= c <= n &&
    (a + b) % k == 0 && (b + c) % k == 0 && (c + a) % k == 0
}

spec fn count_valid_triples(n: int, k: int) -> int
    recommends n >= 1 && k >= 1
{
    if k % 2 == 1 {
        let cnt1 = n / k;
        cnt1 * cnt1 * cnt1
    } else {
        let cnt1 = n / k;
        let cnt2 = n / k + (if n % k >= k / 2 { 1int } else { 0int });
        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2
    }
}

spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 1
}

spec fn count_divisible_by_k(n: int, k: int) -> int
    recommends k >= 1
{
    if n <= 0 { 0int } else { n / k }
}

spec fn count_with_remainder_half_k(n: int, k: int) -> int
    recommends k >= 1
{
    if n <= 0 { 0int } else { n / k + (if n % k >= k / 2 { 1int } else { 0int }) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result >= 0,
        result as int == count_valid_triples(n as int, k as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool\n    recommends k >= 1\n{\n    1 <= a <= n && 1 <= b <= n && 1 <= c <= n &&\n    (a + b) % k == 0 && (b + c) % k == 0 && (c + a) % k == 0\n}\n\nspec fn count_valid_triples(n: int, k: int) -> int\n    recommends n >= 1 && k >= 1\n{\n    if k % 2 == 1 {\n        let cnt1 = n / k;\n        cnt1 * cnt1 * cnt1\n    } else {\n        let cnt1 = n / k;\n        let cnt2 = n / k + (if n % k >= k / 2 { 1int } else { 0int });\n        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2\n    }\n}\n\nspec fn valid_input(n: int, k: int) -> bool {\n    n >= 1 && k >= 1\n}\n\nspec fn count_divisible_by_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k }\n}\n\nspec fn count_with_remainder_half_k(n: int, k: int) -> int\n    recommends k >= 1\n{\n    if n <= 0 { 0int } else { n / k + (if n % k >= k / 2 { 1int } else { 0int }) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: i8)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        result >= 0,\n        result as int == count_valid_triples(n as int, k as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4173.rs,53,53,1.0,123.304,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_query(query: (int, int, int)) -> bool {
    query.0 > 0 && query.1 > 0 && query.2 > 0
}

spec fn min_cost_for_query(n: int, a: int, b: int) -> int
    recommends n > 0 && a > 0 && b > 0
{
    if n % 2 == 0 {
        if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }
    } else {
        if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<(i8, i8, i8)>) -> (results: Vec<i8>)
    requires 
        forall|i: int| 0 <= i < queries@.len() ==> #[trigger] valid_query((queries@[i].0 as int, queries@[i].1 as int, queries@[i].2 as int))
    ensures 
        results@.len() == queries@.len() &&
        forall|i: int| 0 <= i < queries@.len() ==> {
            let n = queries@[i].0 as int;
            let a = queries@[i].1 as int;
            let b = queries@[i].2 as int;
            #[trigger] results@[i] as int == (if n % 2 == 0 {
                if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }
            } else {
                if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }
            })
        }
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_query(query: (int, int, int)) -> bool {
    query.0 > 0 && query.1 > 0 && query.2 > 0
}

spec fn min_cost_for_query(n: int, a: int, b: int) -> int
    recommends n > 0 && a > 0 && b > 0
{
    if n % 2 == 0 {
        if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }
    } else {
        if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<(i8, i8, i8)>) -> (results: Vec<i8>)
    requires 
        forall|i: int| 0 <= i < queries@.len() ==> #[trigger] valid_query((queries@[i].0 as int, queries@[i].1 as int, queries@[i].2 as int))
    ensures 
        results@.len() == queries@.len() &&
        forall|i: int| 0 <= i < queries@.len() ==> {
            let n = queries@[i].0 as int;
            let a = queries@[i].1 as int;
            let b = queries@[i].2 as int;
            #[trigger] results@[i] as int == (if n % 2 == 0 {
                if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }
            } else {
                if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }
            })
        }
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_query(query: (int, int, int)) -> bool {\n    query.0 > 0 && query.1 > 0 && query.2 > 0\n}\n\nspec fn min_cost_for_query(n: int, a: int, b: int) -> int\n    recommends n > 0 && a > 0 && b > 0\n{\n    if n % 2 == 0 {\n        if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n    } else {\n        if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(i8, i8, i8)>) -> (results: Vec<i8>)\n    requires \n        forall|i: int| 0 <= i < queries@.len() ==> #[trigger] valid_query((queries@[i].0 as int, queries@[i].1 as int, queries@[i].2 as int))\n    ensures \n        results@.len() == queries@.len() &&\n        forall|i: int| 0 <= i < queries@.len() ==> {\n            let n = queries@[i].0 as int;\n            let a = queries@[i].1 as int;\n            let b = queries@[i].2 as int;\n            #[trigger] results@[i] as int == (if n % 2 == 0 {\n                if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }\n            } else {\n                if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }\n            })\n        }\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n           fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4176.rs,59,59,1.0,123.406,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|space_index: int| 0 <= space_index < input.len() && 
        input[space_index] == ' ' &&
    forall|i: int| 0 <= i < input.len() ==> 
        (input[i] == ' ' || ('0' <= input[i] <= '9'))
}

spec fn parse_two_ints(s: Seq<char>) -> (int, int) {
    if valid_input(s) { (1, 1) } else { (1, 1) }
}

spec fn lcm(a: int, b: int) -> int {
    if a > 0 && b > 0 { (a * b) / spec_gcd(a, b) } else { 1 }
}

spec fn spec_gcd(a: int, b: int) -> int
    decreases b
{
    if a > 0 && b > 0 {
        if b == 0 { a } else { spec_gcd(b, a % b) }
    } else { 1 }
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    forall|i: int| 0 <= i < output.len() ==> #[trigger] output[i] >= '0' && #[trigger] output[i] <= '9'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures ({
        let nums = parse_two_ints(input@);
        let a = nums.0;
        let b = nums.1;
        a > 0 && b > 0
    }) && valid_output(result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|space_index: int| 0 <= space_index < input.len() && 
        input[space_index] == ' ' &&
    forall|i: int| 0 <= i < input.len() ==> 
        (input[i] == ' ' || ('0' <= input[i] <= '9'))
}

spec fn parse_two_ints(s: Seq<char>) -> (int, int) {
    if valid_input(s) { (1, 1) } else { (1, 1) }
}

spec fn lcm(a: int, b: int) -> int {
    if a > 0 && b > 0 { (a * b) / spec_gcd(a, b) } else { 1 }
}

spec fn spec_gcd(a: int, b: int) -> int
    decreases b
{
    if a > 0 && b > 0 {
        if b == 0 { a } else { spec_gcd(b, a % b) }
    } else { 1 }
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    forall|i: int| 0 <= i < output.len() ==> #[trigger] output[i] >= '0' && #[trigger] output[i] <= '9'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures ({
        let nums = parse_two_ints(input@);
        let a = nums.0;
        let b = nums.1;
        a > 0 && b > 0
    }) && valid_output(result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|space_index: int| 0 <= space_index < input.len() && \n        input[space_index] == ' ' &&\n    forall|i: int| 0 <= i < input.len() ==> \n        (input[i] == ' ' || ('0' <= input[i] <= '9'))\n}\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n    if valid_input(s) { (1, 1) } else { (1, 1) }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 { (a * b) / spec_gcd(a, b) } else { 1 }\n}\n\nspec fn spec_gcd(a: int, b: int) -> int\n    decreases b\n{\n    if a > 0 && b > 0 {\n        if b == 0 { a } else { spec_gcd(b, a % b) }\n    } else { 1 }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    forall|i: int| 0 <= i < output.len() ==> #[trigger] output[i] >= '0' && #[trigger] output[i] <= '9'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures ({\n        let nums = parse_two_ints(input@);\n        let a = nums.0;\n        let b = nums.1;\n        a > 0 && b > 0\n    }) && valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4178.rs,54,54,1.0,92.069,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn max_height_up_to(heights: Seq<int>, index: int) -> int
    decreases index + 1
{
    if heights.len() > 0 && -1 <= index < heights.len() {
        if index < 0 {
            0
        } else if index == 0 {
            heights[0]
        } else if heights[index] > max_height_up_to(heights, index - 1) {
            heights[index]
        } else {
            max_height_up_to(heights, index - 1)
        }
    } else {
        0
    }
}

spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n >= 1 && heights.len() == n && (forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1)
}

spec fn can_make_non_decreasing(heights: Seq<int>) -> bool {
    if heights.len() > 0 {
        forall|i: int| 0 <= i < heights.len() ==> heights[i] >= max_height_up_to(heights, i) - 1
    } else {
        true
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, heights: Vec<i8>) -> (result: String)
    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))
    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn max_height_up_to(heights: Seq<int>, index: int) -> int
    decreases index + 1
{
    if heights.len() > 0 && -1 <= index < heights.len() {
        if index < 0 {
            0
        } else if index == 0 {
            heights[0]
        } else if heights[index] > max_height_up_to(heights, index - 1) {
            heights[index]
        } else {
            max_height_up_to(heights, index - 1)
        }
    } else {
        0
    }
}

spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n >= 1 && heights.len() == n && (forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1)
}

spec fn can_make_non_decreasing(heights: Seq<int>) -> bool {
    if heights.len() > 0 {
        forall|i: int| 0 <= i < heights.len() ==> heights[i] >= max_height_up_to(heights, i) - 1
    } else {
        true
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, heights: Vec<i8>) -> (result: String)
    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))
    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_height_up_to(heights: Seq<int>, index: int) -> int\n    decreases index + 1\n{\n    if heights.len() > 0 && -1 <= index < heights.len() {\n        if index < 0 {\n            0\n        } else if index == 0 {\n            heights[0]\n        } else if heights[index] > max_height_up_to(heights, index - 1) {\n            heights[index]\n        } else {\n            max_height_up_to(heights, index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn valid_input(n: int, heights: Seq<int>) -> bool {\n    n >= 1 && heights.len() == n && (forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1)\n}\n\nspec fn can_make_non_decreasing(heights: Seq<int>) -> bool {\n    if heights.len() > 0 {\n        forall|i: int| 0 <= i < heights.len() ==> heights[i] >= max_height_up_to(heights, i) - 1\n    } else {\n        true\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, heights: Vec<i8>) -> (result: String)\n    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))\n    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4183.rs,65,65,1.0,122.189,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn gcd(a: int, b: int) -> int
    decreases b when b >= 0
{
    if a > 0 && b >= 0 {
        if b == 0 { a } else { gcd(b, a % b) }
    } else {
        1  /* default for invalid input */
    }
}

spec fn lcm(a: int, b: int) -> int {
    if a > 0 && b > 0 {
        (a * b) / gcd(a, b)
    } else {
        1  /* default for invalid input */
    }
}

spec fn lcm_seq(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() > 0 {
        if nums.len() == 1 { 
            nums[0] 
        } else { 
            lcm(nums[0], lcm_seq(nums.skip(1)))
        }
    } else {
        1  /* default for empty sequence */
    }
}

spec fn valid_input(periods: Seq<int>) -> bool {
    periods.len() > 0 && periods.len() <= 100 &&
    forall|i: int| 0 <= i < periods.len() ==> periods[i] > 0
}

spec fn correct_result(periods: Seq<int>, result: int) -> bool {
    valid_input(periods) ==> result == lcm_seq(periods)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn find_minimum_time(periods: Vec<i8>) -> (result: i8)
    requires valid_input(periods@.map(|i: int, v: i8| v as int))
    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn gcd(a: int, b: int) -> int
    decreases b when b >= 0
{
    if a > 0 && b >= 0 {
        if b == 0 { a } else { gcd(b, a % b) }
    } else {
        1  /* default for invalid input */
    }
}

spec fn lcm(a: int, b: int) -> int {
    if a > 0 && b > 0 {
        (a * b) / gcd(a, b)
    } else {
        1  /* default for invalid input */
    }
}

spec fn lcm_seq(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() > 0 {
        if nums.len() == 1 { 
            nums[0] 
        } else { 
            lcm(nums[0], lcm_seq(nums.skip(1)))
        }
    } else {
        1  /* default for empty sequence */
    }
}

spec fn valid_input(periods: Seq<int>) -> bool {
    periods.len() > 0 && periods.len() <= 100 &&
    forall|i: int| 0 <= i < periods.len() ==> periods[i] > 0
}

spec fn correct_result(periods: Seq<int>, result: int) -> bool {
    valid_input(periods) ==> result == lcm_seq(periods)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn find_minimum_time(periods: Vec<i8>) -> (result: i8)
    requires valid_input(periods@.map(|i: int, v: i8| v as int))
    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn gcd(a: int, b: int) -> int\n    decreases b when b >= 0\n{\n    if a > 0 && b >= 0 {\n        if b == 0 { a } else { gcd(b, a % b) }\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm(a: int, b: int) -> int {\n    if a > 0 && b > 0 {\n        (a * b) / gcd(a, b)\n    } else {\n        1  /* default for invalid input */\n    }\n}\n\nspec fn lcm_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() > 0 {\n        if nums.len() == 1 { \n            nums[0] \n        } else { \n            lcm(nums[0], lcm_seq(nums.skip(1)))\n        }\n    } else {\n        1  /* default for empty sequence */\n    }\n}\n\nspec fn valid_input(periods: Seq<int>) -> bool {\n    periods.len() > 0 && periods.len() <= 100 &&\n    forall|i: int| 0 <= i < periods.len() ==> periods[i] > 0\n}\n\nspec fn correct_result(periods: Seq<int>, result: int) -> bool {\n    valid_input(periods) ==> result == lcm_seq(periods)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn find_minimum_time(periods: Vec<i8>) -> (result: i8)\n    requires valid_input(periods@.map(|i: int, v: i8| v as int))\n    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4194.rs,53,53,1.0,92.411,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {
    n >= 0 && m >= 0 && m == a.len()
}

spec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {
    sum_seq(a) <= n
}

spec fn total_assignment_days(a: Seq<int>) -> int {
    sum_seq(a)
}

spec fn sum_seq(s: Seq<int>) -> int 
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else { 
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, a@.map(|i, x: i8| x as int))
    ensures 
        m as int == 0 ==> result as int == n as int,
        m as int > 0 && can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == n as int - total_assignment_days(a@.map(|i, x: i8| x as int)),
        m as int > 0 && !can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == -1,
        result as int >= -1
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {
    n >= 0 && m >= 0 && m == a.len()
}

spec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {
    sum_seq(a) <= n
}

spec fn total_assignment_days(a: Seq<int>) -> int {
    sum_seq(a)
}

spec fn sum_seq(s: Seq<int>) -> int 
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else { 
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, a@.map(|i, x: i8| x as int))
    ensures 
        m as int == 0 ==> result as int == n as int,
        m as int > 0 && can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == n as int - total_assignment_days(a@.map(|i, x: i8| x as int)),
        m as int > 0 && !can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == -1,
        result as int >= -1
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {\n    n >= 0 && m >= 0 && m == a.len()\n}\n\nspec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {\n    sum_seq(a) <= n\n}\n\nspec fn total_assignment_days(a: Seq<int>) -> int {\n    sum_seq(a)\n}\n\nspec fn sum_seq(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else { \n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, a@.map(|i, x: i8| x as int))\n    ensures \n        m as int == 0 ==> result as int == n as int,\n        m as int > 0 && can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == n as int - total_assignment_days(a@.map(|i, x: i8| x as int)),\n        m as int > 0 && !can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == -1,\n        result as int >= -1\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4216.rs,51,51,1.0,92.231,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn num_digits(n: int) -> int
  recommends n >= 1
  decreases n
{
  if n < 10 { 1 } else { 1 + num_digits(n / 10) }
}

spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn f(a: int, b: int) -> int
  recommends a >= 1 && b >= 1
{
  let digits_a = num_digits(a);
  let digits_b = num_digits(b);
  if digits_a > digits_b { digits_a } else { digits_b }
}

spec fn is_factor_pair(a: int, b: int, n: int) -> bool {
  a >= 1 && b >= 1 && a * b == n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
  requires 
    valid_input(n as int)
  ensures 
    result >= 1,
    exists|a: int, b: int| is_factor_pair(a, b, n as int) && result as int == f(a, b),
    forall|a: int, b: int| is_factor_pair(a, b, n as int) ==> result as int <= f(a, b),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn num_digits(n: int) -> int
  recommends n >= 1
  decreases n
{
  if n < 10 { 1 } else { 1 + num_digits(n / 10) }
}

spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn f(a: int, b: int) -> int
  recommends a >= 1 && b >= 1
{
  let digits_a = num_digits(a);
  let digits_b = num_digits(b);
  if digits_a > digits_b { digits_a } else { digits_b }
}

spec fn is_factor_pair(a: int, b: int, n: int) -> bool {
  a >= 1 && b >= 1 && a * b == n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
  requires 
    valid_input(n as int)
  ensures 
    result >= 1,
    exists|a: int, b: int| is_factor_pair(a, b, n as int) && result as int == f(a, b),
    forall|a: int, b: int| is_factor_pair(a, b, n as int) ==> result as int <= f(a, b),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn num_digits(n: int) -> int\n  recommends n >= 1\n  decreases n\n{\n  if n < 10 { 1 } else { 1 + num_digits(n / 10) }\n}\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn f(a: int, b: int) -> int\n  recommends a >= 1 && b >= 1\n{\n  let digits_a = num_digits(a);\n  let digits_b = num_digits(b);\n  if digits_a > digits_b { digits_a } else { digits_b }\n}\n\nspec fn is_factor_pair(a: int, b: int, n: int) -> bool {\n  a >= 1 && b >= 1 && a * b == n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n  requires \n    valid_input(n as int)\n  ensures \n    result >= 1,\n    exists|a: int, b: int| is_factor_pair(a, b, n as int) && result as int == f(a, b),\n    forall|a: int, b: int| is_factor_pair(a, b, n as int) ==> result as int <= f(a, b),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4220.rs,117,117,1.0,153.385,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    (exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n') &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let k_str = stdin_input.subrange(0, newline_pos as int);
        is_valid_positive_integer(k_str)
    }) &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let k_str = stdin_input.subrange(0, newline_pos as int);
        let k = string_to_int(k_str);
        1 <= k <= 100
    }) &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);
        let s = if rest.len() > 0 && rest[rest.len() - 1] == '\n' { rest.subrange(0, rest.len() - 1) } else { rest };
        1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
    })
}

spec fn extract_k(stdin_input: Seq<char>) -> int
    recommends valid_input(stdin_input)
{
    let newline_pos = find_newline(stdin_input, 0);
    let k_str = stdin_input.subrange(0, newline_pos as int);
    string_to_int(k_str)
}

spec fn extract_s(stdin_input: Seq<char>) -> Seq<char>
    recommends valid_input(stdin_input)
{
    let newline_pos = find_newline(stdin_input, 0);
    let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);
    if rest.len() > 0 && rest[rest.len() - 1] == '\n' { rest.subrange(0, rest.len() - 1) } else { rest }
}

spec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool
    recommends valid_input(stdin_input)
{
    let k = extract_k(stdin_input);
    let s = extract_s(stdin_input);
    k >= 1 && k <= 100 &&
    s.len() >= 1 && s.len() <= 100 &&
    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z') &&
    (s.len() <= k ==> result == s.add(seq!['\n'])) &&
    (s.len() > k ==> result == s.subrange(0, k).add(seq!['.', '.', '.']).add(seq!['\n']))
}

spec fn find_newline(s: Seq<char>, start: nat) -> nat
    recommends start <= s.len()
    decreases s.len() - start
{
    if start >= s.len() { 
        s.len() 
    } else if s[start as int] == '\n' { 
        start 
    } else { 
        find_newline(s, start + 1) 
    }
}

spec fn is_valid_positive_integer(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9') && 
    s != seq!['0']
}

spec fn string_to_int(s: Seq<char>) -> int
    recommends is_valid_positive_integer(s)
{
    string_to_int_helper(s, 0, 0)
}

spec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int
    recommends
        pos <= s.len(),
        acc >= 0,
        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',
        is_valid_positive_integer(s)
    decreases s.len() - pos
{
    if pos >= s.len() { 
        if acc == 0 { 1 } else { acc }
    } else if s[pos as int] >= '0' && s[pos as int] <= '9' {
        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos as int] as int - '0' as int))
    } else {
        if acc == 0 { 1 } else { acc }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures correct_output(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    (exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n') &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let k_str = stdin_input.subrange(0, newline_pos as int);
        is_valid_positive_integer(k_str)
    }) &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let k_str = stdin_input.subrange(0, newline_pos as int);
        let k = string_to_int(k_str);
        1 <= k <= 100
    }) &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);
        let s = if rest.len() > 0 && rest[rest.len() - 1] == '\n' { rest.subrange(0, rest.len() - 1) } else { rest };
        1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
    })
}

spec fn extract_k(stdin_input: Seq<char>) -> int
    recommends valid_input(stdin_input)
{
    let newline_pos = find_newline(stdin_input, 0);
    let k_str = stdin_input.subrange(0, newline_pos as int);
    string_to_int(k_str)
}

spec fn extract_s(stdin_input: Seq<char>) -> Seq<char>
    recommends valid_input(stdin_input)
{
    let newline_pos = find_newline(stdin_input, 0);
    let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);
    if rest.len() > 0 && rest[rest.len() - 1] == '\n' { rest.subrange(0, rest.len() - 1) } else { rest }
}

spec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool
    recommends valid_input(stdin_input)
{
    let k = extract_k(stdin_input);
    let s = extract_s(stdin_input);
    k >= 1 && k <= 100 &&
    s.len() >= 1 && s.len() <= 100 &&
    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z') &&
    (s.len() <= k ==> result == s.add(seq!['\n'])) &&
    (s.len() > k ==> result == s.subrange(0, k).add(seq!['.', '.', '.']).add(seq!['\n']))
}

spec fn find_newline(s: Seq<char>, start: nat) -> nat
    recommends start <= s.len()
    decreases s.len() - start
{
    if start >= s.len() { 
        s.len() 
    } else if s[start as int] == '\n' { 
        start 
    } else { 
        find_newline(s, start + 1) 
    }
}

spec fn is_valid_positive_integer(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9') && 
    s != seq!['0']
}

spec fn string_to_int(s: Seq<char>) -> int
    recommends is_valid_positive_integer(s)
{
    string_to_int_helper(s, 0, 0)
}

spec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int
    recommends
        pos <= s.len(),
        acc >= 0,
        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',
        is_valid_positive_integer(s)
    decreases s.len() - pos
{
    if pos >= s.len() { 
        if acc == 0 { 1 } else { acc }
    } else if s[pos as int] >= '0' && s[pos as int] <= '9' {
        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos as int] as int - '0' as int))
    } else {
        if acc == 0 { 1 } else { acc }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures correct_output(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    (exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n') &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        is_valid_positive_integer(k_str)\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let k_str = stdin_input.subrange(0, newline_pos as int);\n        let k = string_to_int(k_str);\n        1 <= k <= 100\n    }) &&\n    ({\n        let newline_pos = find_newline(stdin_input, 0);\n        let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n        let s = if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest };\n        1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n    })\n}\n\nspec fn extract_k(stdin_input: Seq<char>) -> int\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let k_str = stdin_input.subrange(0, newline_pos as int);\n    string_to_int(k_str)\n}\n\nspec fn extract_s(stdin_input: Seq<char>) -> Seq<char>\n    recommends valid_input(stdin_input)\n{\n    let newline_pos = find_newline(stdin_input, 0);\n    let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);\n    if rest.len() > 0 && rest[rest.len() - 1] == '\\n' { rest.subrange(0, rest.len() - 1) } else { rest }\n}\n\nspec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(stdin_input)\n{\n    let k = extract_k(stdin_input);\n    let s = extract_s(stdin_input);\n    k >= 1 && k <= 100 &&\n    s.len() >= 1 && s.len() <= 100 &&\n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z') &&\n    (s.len() <= k ==> result == s.add(seq!['\\n'])) &&\n    (s.len() > k ==> result == s.subrange(0, k).add(seq!['.', '.', '.']).add(seq!['\\n']))\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> nat\n    recommends start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { \n        s.len() \n    } else if s[start as int] == '\\n' { \n        start \n    } else { \n        find_newline(s, start + 1) \n    }\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9') && \n    s != seq!['0']\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    recommends is_valid_positive_integer(s)\n{\n    string_to_int_helper(s, 0, 0)\n}\n\nspec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int\n    recommends\n        pos <= s.len(),\n        acc >= 0,\n        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',\n        is_valid_positive_integer(s)\n    decreases s.len() - pos\n{\n    if pos >= s.len() { \n        if acc == 0 { 1 } else { acc }\n    } else if s[pos as int] >= '0' && s[pos as int] <= '9' {\n        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos as int] as int - '0' as int))\n    } else {\n        if acc == 0 { 1 } else { acc }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n          fn main() {\n}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4224.rs,54,54,1.0,92.133,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] > 0
}

spec fn count_factors_of_two(n: int) -> int
    decreases n when n > 0
{
    if n > 0 && n % 2 == 0 { 1 + count_factors_of_two(n / 2) }
    else { 0 }
}

spec fn sum_factors(a: Seq<int>, i: int) -> int
    decreases a.len() - i when 0 <= i <= a.len()
{
    if 0 <= i < a.len() && (forall|j: int| 0 <= j < a.len() ==> a[j] > 0) {
        count_factors_of_two(a[i]) + sum_factors(a, i + 1)
    } else if i == a.len() {
        0
    } else {
        0
    }
}

spec fn max_operations(a: Seq<int>) -> int {
    if valid_input(a) { sum_factors(a, 0) } else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(a@.map(|i, x| x as int)),
    ensures 
        result >= 0,
        result as int == max_operations(a@.map(|i, x| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] > 0
}

spec fn count_factors_of_two(n: int) -> int
    decreases n when n > 0
{
    if n > 0 && n % 2 == 0 { 1 + count_factors_of_two(n / 2) }
    else { 0 }
}

spec fn sum_factors(a: Seq<int>, i: int) -> int
    decreases a.len() - i when 0 <= i <= a.len()
{
    if 0 <= i < a.len() && (forall|j: int| 0 <= j < a.len() ==> a[j] > 0) {
        count_factors_of_two(a[i]) + sum_factors(a, i + 1)
    } else if i == a.len() {
        0
    } else {
        0
    }
}

spec fn max_operations(a: Seq<int>) -> int {
    if valid_input(a) { sum_factors(a, 0) } else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(a@.map(|i, x| x as int)),
    ensures 
        result >= 0,
        result as int == max_operations(a@.map(|i, x| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > 0\n}\n\nspec fn count_factors_of_two(n: int) -> int\n    decreases n when n > 0\n{\n    if n > 0 && n % 2 == 0 { 1 + count_factors_of_two(n / 2) }\n    else { 0 }\n}\n\nspec fn sum_factors(a: Seq<int>, i: int) -> int\n    decreases a.len() - i when 0 <= i <= a.len()\n{\n    if 0 <= i < a.len() && (forall|j: int| 0 <= j < a.len() ==> a[j] > 0) {\n        count_factors_of_two(a[i]) + sum_factors(a, i + 1)\n    } else if i == a.len() {\n        0\n    } else {\n        0\n    }\n}\n\nspec fn max_operations(a: Seq<int>) -> int {\n    if valid_input(a) { sum_factors(a, 0) } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(a@.map(|i, x| x as int)),\n    ensures \n        result >= 0,\n        result as int == max_operations(a@.map(|i, x| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4225.rs,117,117,1.0,122.553,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, k: int) -> bool {
    a >= 0 && b >= 0 && c >= 0 && k >= 1 && k <= a + b + c
}

spec fn max_sum(a: int, b: int, c: int, k: int) -> int
    recommends valid_input(a, b, c, k)
{
    if k <= a + b {
        if k <= a { k } else { a }
    } else {
        a - (k - a - b)
    }
}

spec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {
    exists|parts: Seq<Seq<char>>| parts.len() >= 4 && 
        parts == split_string_pure(input) &&
        a == string_to_int_pure(parts[0]) &&
        b == string_to_int_pure(parts[1]) &&
        c == string_to_int_pure(parts[2]) &&
        k == string_to_int_pure(parts[3]) &&
        valid_input(a, b, c, k)
}

spec fn int_to_string_pure(n: int) -> Seq<char>
    recommends n >= -2000000000 && n <= 2000000000
{
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'] + int_to_string_pure_helper(-n) }
    else { int_to_string_pure_helper(n) }
}

spec fn int_to_string_pure_helper(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 { seq![('0' as u8 + n as u8) as char] }
    else { int_to_string_pure_helper(n / 10) + seq![('0' as u8 + (n % 10) as u8) as char] }
}

spec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 { seq![] }
    else { split_string_helper(s, 0, seq![], seq![]) }
}

spec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>
    recommends 0 <= i <= s.len()
    decreases s.len() - i
{
    if i >= s.len() {
        if current.len() > 0 { parts + seq![current] } else { parts }
    } else if s[i] == ' ' || s[i] == '\n' {
        if current.len() > 0 { 
            split_string_helper(s, i+1, seq![], parts + seq![current])
        } else { 
            split_string_helper(s, i+1, seq![], parts)
        }
    } else {
        split_string_helper(s, i+1, current + seq![s[i]], parts)
    }
}

spec fn string_to_int_pure(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s[0] == '-' { -string_to_int_helper(s, 1) }
    else { string_to_int_helper(s, 0) }
}

spec fn string_to_int_helper(s: Seq<char>, start: int) -> int
    recommends 0 <= start <= s.len()
    decreases s.len() - start
{
    if start >= s.len() { 0 }
    else if '0' <= s[start] <= '9' {
        (s[start] as u8 - '0' as u8) as int + 10 * string_to_int_helper(s, start + 1)
    } else {
        string_to_int_helper(s, start + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires input@.len() > 0
    ensures 
        result@.len() > 0 &&
        result@[result@.len() as int - 1] == '\n' &&
        ((exists|a: int, b: int, c: int, k: int| 
            parsed_values(input@, a, b, c, k) &&
            ({
                let max_sum_val = max_sum(a, b, c, k);
                max_sum_val >= -2000000000 && max_sum_val <= 2000000000 &&
                result@ == int_to_string_pure(max_sum_val) + seq!['\n']
            })) ||
        (forall|a: int, b: int, c: int, k: int| !parsed_values(input@, a, b, c, k) ==> result@ == seq!['0', '\n']))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, k: int) -> bool {
    a >= 0 && b >= 0 && c >= 0 && k >= 1 && k <= a + b + c
}

spec fn max_sum(a: int, b: int, c: int, k: int) -> int
    recommends valid_input(a, b, c, k)
{
    if k <= a + b {
        if k <= a { k } else { a }
    } else {
        a - (k - a - b)
    }
}

spec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {
    exists|parts: Seq<Seq<char>>| parts.len() >= 4 && 
        parts == split_string_pure(input) &&
        a == string_to_int_pure(parts[0]) &&
        b == string_to_int_pure(parts[1]) &&
        c == string_to_int_pure(parts[2]) &&
        k == string_to_int_pure(parts[3]) &&
        valid_input(a, b, c, k)
}

spec fn int_to_string_pure(n: int) -> Seq<char>
    recommends n >= -2000000000 && n <= 2000000000
{
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'] + int_to_string_pure_helper(-n) }
    else { int_to_string_pure_helper(n) }
}

spec fn int_to_string_pure_helper(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 { seq![('0' as u8 + n as u8) as char] }
    else { int_to_string_pure_helper(n / 10) + seq![('0' as u8 + (n % 10) as u8) as char] }
}

spec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 { seq![] }
    else { split_string_helper(s, 0, seq![], seq![]) }
}

spec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>
    recommends 0 <= i <= s.len()
    decreases s.len() - i
{
    if i >= s.len() {
        if current.len() > 0 { parts + seq![current] } else { parts }
    } else if s[i] == ' ' || s[i] == '\n' {
        if current.len() > 0 { 
            split_string_helper(s, i+1, seq![], parts + seq![current])
        } else { 
            split_string_helper(s, i+1, seq![], parts)
        }
    } else {
        split_string_helper(s, i+1, current + seq![s[i]], parts)
    }
}

spec fn string_to_int_pure(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s[0] == '-' { -string_to_int_helper(s, 1) }
    else { string_to_int_helper(s, 0) }
}

spec fn string_to_int_helper(s: Seq<char>, start: int) -> int
    recommends 0 <= start <= s.len()
    decreases s.len() - start
{
    if start >= s.len() { 0 }
    else if '0' <= s[start] <= '9' {
        (s[start] as u8 - '0' as u8) as int + 10 * string_to_int_helper(s, start + 1)
    } else {
        string_to_int_helper(s, start + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires input@.len() > 0
    ensures 
        result@.len() > 0 &&
        result@[result@.len() as int - 1] == '\n' &&
        ((exists|a: int, b: int, c: int, k: int| 
            parsed_values(input@, a, b, c, k) &&
            ({
                let max_sum_val = max_sum(a, b, c, k);
                max_sum_val >= -2000000000 && max_sum_val <= 2000000000 &&
                result@ == int_to_string_pure(max_sum_val) + seq!['\n']
            })) ||
        (forall|a: int, b: int, c: int, k: int| !parsed_values(input@, a, b, c, k) ==> result@ == seq!['0', '\n']))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, k: int) -> bool {\n    a >= 0 && b >= 0 && c >= 0 && k >= 1 && k <= a + b + c\n}\n\nspec fn max_sum(a: int, b: int, c: int, k: int) -> int\n    recommends valid_input(a, b, c, k)\n{\n    if k <= a + b {\n        if k <= a { k } else { a }\n    } else {\n        a - (k - a - b)\n    }\n}\n\nspec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {\n    exists|parts: Seq<Seq<char>>| parts.len() >= 4 && \n        parts == split_string_pure(input) &&\n        a == string_to_int_pure(parts[0]) &&\n        b == string_to_int_pure(parts[1]) &&\n        c == string_to_int_pure(parts[2]) &&\n        k == string_to_int_pure(parts[3]) &&\n        valid_input(a, b, c, k)\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char>\n    recommends n >= -2000000000 && n <= 2000000000\n{\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'] + int_to_string_pure_helper(-n) }\n    else { int_to_string_pure_helper(n) }\n}\n\nspec fn int_to_string_pure_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 { seq![('0' as u8 + n as u8) as char] }\n    else { int_to_string_pure_helper(n / 10) + seq![('0' as u8 + (n % 10) as u8) as char] }\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { seq![] }\n    else { split_string_helper(s, 0, seq![], seq![]) }\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= i <= s.len()\n    decreases s.len() - i\n{\n    if i >= s.len() {\n        if current.len() > 0 { parts + seq![current] } else { parts }\n    } else if s[i] == ' ' || s[i] == '\\n' {\n        if current.len() > 0 { \n            split_string_helper(s, i+1, seq![], parts + seq![current])\n        } else { \n            split_string_helper(s, i+1, seq![], parts)\n        }\n    } else {\n        split_string_helper(s, i+1, current + seq![s[i]], parts)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s[0] == '-' { -string_to_int_helper(s, 1) }\n    else { string_to_int_helper(s, 0) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, start: int) -> int\n    recommends 0 <= start <= s.len()\n    decreases s.len() - start\n{\n    if start >= s.len() { 0 }\n    else if '0' <= s[start] <= '9' {\n        (s[start] as u8 - '0' as u8) as int + 10 * string_to_int_helper(s, start + 1)\n    } else {\n        string_to_int_helper(s, start + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input@.len() > 0\n    ensures \n        result@.len() > 0 &&\n        result@[result@.len() as int - 1] == '\\n' &&\n        ((exists|a: int, b: int, c: int, k: int| \n            parsed_values(input@, a, b, c, k) &&\n            ({\n                let max_sum_val = max_sum(a, b, c, k);\n                max_sum_val >= -2000000000 && max_sum_val <= 2000000000 &&\n                result@ == int_to_string_pure(max_sum_val) + seq!['\\n']\n            })) ||\n        (forall|a: int, b: int, c: int, k: int| !parsed_values(input@, a, b, c, k) ==> result@ == seq!['0', '\\n']))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4245.rs,66,66,1.0,152.877,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    a > 1 && b >= 0
}

spec fn sockets_after_strips(strips: int, a: int) -> int
    recommends a > 1 && strips >= 0
{
    1 + strips * (a - 1)
}

spec fn ceiling_division(x: int, y: int) -> int
    recommends y > 0
{
    if x % y == 0 {
        x / y
    } else if x >= 0 {
        x / y + 1
    } else {
        x / y
    }
}

spec fn min_strips_needed(a: int, b: int) -> int
    recommends valid_input(a, b)
{
    if b <= 1 {
        0
    } else {
        ceiling_division(b - 1, a - 1)
    }
}

spec fn correct_result(a: int, b: int, result: int) -> bool
    recommends valid_input(a, b)
{
    result >= 0 &&
    sockets_after_strips(result, a) >= b &&
    (result == 0 || sockets_after_strips(result - 1, a) < b)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8) -> (result: i8)
    requires valid_input(a as int, b as int)
    ensures correct_result(a as int, b as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    a > 1 && b >= 0
}

spec fn sockets_after_strips(strips: int, a: int) -> int
    recommends a > 1 && strips >= 0
{
    1 + strips * (a - 1)
}

spec fn ceiling_division(x: int, y: int) -> int
    recommends y > 0
{
    if x % y == 0 {
        x / y
    } else if x >= 0 {
        x / y + 1
    } else {
        x / y
    }
}

spec fn min_strips_needed(a: int, b: int) -> int
    recommends valid_input(a, b)
{
    if b <= 1 {
        0
    } else {
        ceiling_division(b - 1, a - 1)
    }
}

spec fn correct_result(a: int, b: int, result: int) -> bool
    recommends valid_input(a, b)
{
    result >= 0 &&
    sockets_after_strips(result, a) >= b &&
    (result == 0 || sockets_after_strips(result - 1, a) < b)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8) -> (result: i8)
    requires valid_input(a as int, b as int)
    ensures correct_result(a as int, b as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 1 && b >= 0\n}\n\nspec fn sockets_after_strips(strips: int, a: int) -> int\n    recommends a > 1 && strips >= 0\n{\n    1 + strips * (a - 1)\n}\n\nspec fn ceiling_division(x: int, y: int) -> int\n    recommends y > 0\n{\n    if x % y == 0 {\n        x / y\n    } else if x >= 0 {\n        x / y + 1\n    } else {\n        x / y\n    }\n}\n\nspec fn min_strips_needed(a: int, b: int) -> int\n    recommends valid_input(a, b)\n{\n    if b <= 1 {\n        0\n    } else {\n        ceiling_division(b - 1, a - 1)\n    }\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n    recommends valid_input(a, b)\n{\n    result >= 0 &&\n    sockets_after_strips(result, a) >= b &&\n    (result == 0 || sockets_after_strips(result - 1, a) < b)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures correct_result(a as int, b as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4246.rs,76,76,1.0,154.264,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['S', 'C', 'R'], seq!['S', 'C', 'R']]
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else { seq!['3'] }
}
spec fn is_valid_input(input: Seq<char>) -> bool
    recommends input.len() > 0
{
    let lines = parse_lines(input);
    lines.len() >= 2 && lines[0].len() == 3 && lines[1].len() == 3
}

spec fn count_matches_from_input(input: Seq<char>) -> int
    recommends input.len() > 0 && is_valid_input(input)
{
    let lines = parse_lines(input);
    count_matches(lines[0], lines[1])
}

spec fn count_matches(s: Seq<char>, t: Seq<char>) -> int
    recommends s.len() == 3 && t.len() == 3
{
    (if s[0] == t[0] { 1int } else { 0int }) +
    (if s[1] == t[1] { 1int } else { 0int }) +
    (if s[2] == t[2] { 1int } else { 0int })
}

spec fn compute_result(input: Seq<char>) -> Seq<char>
    recommends input.len() > 0
{
    let lines = parse_lines(input);
    if lines.len() < 2 {
        seq!['0', '\n']
    } else if lines[0].len() != 3 || lines[1].len() != 3 {
        seq!['0', '\n']
    } else {
        int_to_string(count_matches(lines[0], lines[1])).add(seq!['\n'])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        input.len() > 0,
    ensures
        result@ == compute_result(input@),
        result.len() >= 2 && result[result.len() - 1] == '\n',
        result[0] == '0' || result[0] == '1' || result[0] == '2' || result[0] == '3',
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['S', 'C', 'R'], seq!['S', 'C', 'R']]
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else { seq!['3'] }
}
spec fn is_valid_input(input: Seq<char>) -> bool
    recommends input.len() > 0
{
    let lines = parse_lines(input);
    lines.len() >= 2 && lines[0].len() == 3 && lines[1].len() == 3
}

spec fn count_matches_from_input(input: Seq<char>) -> int
    recommends input.len() > 0 && is_valid_input(input)
{
    let lines = parse_lines(input);
    count_matches(lines[0], lines[1])
}

spec fn count_matches(s: Seq<char>, t: Seq<char>) -> int
    recommends s.len() == 3 && t.len() == 3
{
    (if s[0] == t[0] { 1int } else { 0int }) +
    (if s[1] == t[1] { 1int } else { 0int }) +
    (if s[2] == t[2] { 1int } else { 0int })
}

spec fn compute_result(input: Seq<char>) -> Seq<char>
    recommends input.len() > 0
{
    let lines = parse_lines(input);
    if lines.len() < 2 {
        seq!['0', '\n']
    } else if lines[0].len() != 3 || lines[1].len() != 3 {
        seq!['0', '\n']
    } else {
        int_to_string(count_matches(lines[0], lines[1])).add(seq!['\n'])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        input.len() > 0,
    ensures
        result@ == compute_result(input@),
        result.len() >= 2 && result[result.len() - 1] == '\n',
        result[0] == '0' || result[0] == '1' || result[0] == '2' || result[0] == '3',
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['S', 'C', 'R'], seq!['S', 'C', 'R']]\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else { seq!['3'] }\n}\nspec fn is_valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    lines.len() >= 2 && lines[0].len() == 3 && lines[1].len() == 3\n}\n\nspec fn count_matches_from_input(input: Seq<char>) -> int\n    recommends input.len() > 0 && is_valid_input(input)\n{\n    let lines = parse_lines(input);\n    count_matches(lines[0], lines[1])\n}\n\nspec fn count_matches(s: Seq<char>, t: Seq<char>) -> int\n    recommends s.len() == 3 && t.len() == 3\n{\n    (if s[0] == t[0] { 1int } else { 0int }) +\n    (if s[1] == t[1] { 1int } else { 0int }) +\n    (if s[2] == t[2] { 1int } else { 0int })\n}\n\nspec fn compute_result(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    let lines = parse_lines(input);\n    if lines.len() < 2 {\n        seq!['0', '\\n']\n    } else if lines[0].len() != 3 || lines[1].len() != 3 {\n        seq!['0', '\\n']\n    } else {\n        int_to_string(count_matches(lines[0], lines[1])).add(seq!['\\n'])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        input.len() > 0,\n    ensures\n        result@ == compute_result(input@),\n        result.len() >= 2 && result[result.len() - 1] == '\\n',\n        result[0] == '0' || result[0] == '1' || result[0] == '2' || result[0] == '3',\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4252.rs,62,62,1.0,122.883,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3
}

spec fn count_excessive_positions(s: Seq<char>) -> int {
    count_excessive_positions_helper(s, 0, 0)
}

spec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() {
        0
    } else {
        let new_consecutive_x = if s[pos] == 'x' { consecutive_x + 1 } else { 0 };
        let current_contribution: int = if new_consecutive_x > 2 { 1 } else { 0 };
        current_contribution + count_excessive_positions_helper(s, pos + 1, new_consecutive_x)
    }
}

spec fn consecutive_x_count(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos == 0 {
        0
    } else if pos > 0 && pos <= s.len() && s[pos - 1] == 'x' {
        1 + consecutive_x_count(s, pos - 1)
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures 
        result >= 0,
        result as int <= s@.len(),
        result as int == count_excessive_positions(s@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3
}

spec fn count_excessive_positions(s: Seq<char>) -> int {
    count_excessive_positions_helper(s, 0, 0)
}

spec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() {
        0
    } else {
        let new_consecutive_x = if s[pos] == 'x' { consecutive_x + 1 } else { 0 };
        let current_contribution: int = if new_consecutive_x > 2 { 1 } else { 0 };
        current_contribution + count_excessive_positions_helper(s, pos + 1, new_consecutive_x)
    }
}

spec fn consecutive_x_count(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos == 0 {
        0
    } else if pos > 0 && pos <= s.len() && s[pos - 1] == 'x' {
        1 + consecutive_x_count(s, pos - 1)
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures 
        result >= 0,
        result as int <= s@.len(),
        result as int == count_excessive_positions(s@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3\n}\n\nspec fn count_excessive_positions(s: Seq<char>) -> int {\n    count_excessive_positions_helper(s, 0, 0)\n}\n\nspec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let new_consecutive_x = if s[pos] == 'x' { consecutive_x + 1 } else { 0 };\n        let current_contribution: int = if new_consecutive_x > 2 { 1 } else { 0 };\n        current_contribution + count_excessive_positions_helper(s, pos + 1, new_consecutive_x)\n    }\n}\n\nspec fn consecutive_x_count(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos == 0 {\n        0\n    } else if pos > 0 && pos <= s.len() && s[pos - 1] == 'x' {\n        1 + consecutive_x_count(s, pos - 1)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i8)\n    requires valid_input(s@)\n    ensures \n        result >= 0,\n        result as int <= s@.len(),\n        result as int == count_excessive_positions(s@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4253.rs,56,56,1.0,122.771,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(r: int) -> bool {
    1 <= r <= 100
}

spec fn dodecagon_area(r: int) -> int {
    3 * r * r
}

spec fn int_to_string(n: int) -> Seq<char>
    decreases n
{
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string(n / 10) + int_to_string(n % 10)
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else if s.len() > 1 {
        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(r: int) -> bool {
    1 <= r <= 100
}

spec fn dodecagon_area(r: int) -> int {
    3 * r * r
}

spec fn int_to_string(n: int) -> Seq<char>
    decreases n
{
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string(n / 10) + int_to_string(n % 10)
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else if s.len() > 1 {
        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(r: int) -> bool {\n    1 <= r <= 100\n}\n\nspec fn dodecagon_area(r: int) -> int {\n    3 * r * r\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string(n / 10) + int_to_string(n % 10)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 {\n        (s[0] as int) - ('0' as int)\n    } else if s.len() > 1 {\n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4254.rs,102,102,1.0,154.482,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    let trimmed = trim_newlines(input);
    let space_index = find_space(trimmed);
    space_index >= 0 && space_index < trimmed.len() - 1 &&
    is_valid_integer(trimmed.subrange(0, space_index)) &&
    is_valid_integer(trimmed.subrange(space_index + 1, trimmed.len() as int))
}

spec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {
    valid_input_format(input) &&
    {
        let trimmed = trim_newlines(input);
        let space_index = find_space(trimmed);
        let s_str = trimmed.subrange(0, space_index);
        let w_str = trimmed.subrange(space_index + 1, trimmed.len() as int);
        string_to_int(s_str) == s && string_to_int(w_str) == w
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    if s.len() == 0 {
        false
    } else if s[0] == '-' {
        s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
    } else {
        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
    }
}

spec fn trim_newlines(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        s
    } else if s[s.len() - 1] == '\n' {
        trim_newlines(s.subrange(0, s.len() - 1))
    } else {
        s
    }
}

spec fn find_space(s: Seq<char>) -> int {
    find_space_helper(s, 0)
}

spec fn find_space_helper(s: Seq<char>, index: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        -1
    } else if s[index] == ' ' {
        index
    } else {
        find_space_helper(s, index + 1)
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' && s.len() > 1 {
        -string_to_int_helper(s.subrange(1, s.len() as int), 0, 0)
    } else {
        string_to_int_helper(s, 0, 0)
    }
}

spec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        acc
    } else {
        let digit = (s[index] as int) - ('0' as int);
        string_to_int_helper(s, index + 1, acc * 10 + digit)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires input.len() > 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    let trimmed = trim_newlines(input);
    let space_index = find_space(trimmed);
    space_index >= 0 && space_index < trimmed.len() - 1 &&
    is_valid_integer(trimmed.subrange(0, space_index)) &&
    is_valid_integer(trimmed.subrange(space_index + 1, trimmed.len() as int))
}

spec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {
    valid_input_format(input) &&
    {
        let trimmed = trim_newlines(input);
        let space_index = find_space(trimmed);
        let s_str = trimmed.subrange(0, space_index);
        let w_str = trimmed.subrange(space_index + 1, trimmed.len() as int);
        string_to_int(s_str) == s && string_to_int(w_str) == w
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    if s.len() == 0 {
        false
    } else if s[0] == '-' {
        s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
    } else {
        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
    }
}

spec fn trim_newlines(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        s
    } else if s[s.len() - 1] == '\n' {
        trim_newlines(s.subrange(0, s.len() - 1))
    } else {
        s
    }
}

spec fn find_space(s: Seq<char>) -> int {
    find_space_helper(s, 0)
}

spec fn find_space_helper(s: Seq<char>, index: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        -1
    } else if s[index] == ' ' {
        index
    } else {
        find_space_helper(s, index + 1)
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' && s.len() > 1 {
        -string_to_int_helper(s.subrange(1, s.len() as int), 0, 0)
    } else {
        string_to_int_helper(s, 0, 0)
    }
}

spec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        acc
    } else {
        let digit = (s[index] as int) - ('0' as int);
        string_to_int_helper(s, index + 1, acc * 10 + digit)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires input.len() > 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let trimmed = trim_newlines(input);\n    let space_index = find_space(trimmed);\n    space_index >= 0 && space_index < trimmed.len() - 1 &&\n    is_valid_integer(trimmed.subrange(0, space_index)) &&\n    is_valid_integer(trimmed.subrange(space_index + 1, trimmed.len() as int))\n}\n\nspec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {\n    valid_input_format(input) &&\n    {\n        let trimmed = trim_newlines(input);\n        let space_index = find_space(trimmed);\n        let s_str = trimmed.subrange(0, space_index);\n        let w_str = trimmed.subrange(space_index + 1, trimmed.len() as int);\n        string_to_int(s_str) == s && string_to_int(w_str) == w\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    if s.len() == 0 {\n        false\n    } else if s[0] == '-' {\n        s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    } else {\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n    }\n}\n\nspec fn trim_newlines(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        s\n    } else if s[s.len() - 1] == '\\n' {\n        trim_newlines(s.subrange(0, s.len() - 1))\n    } else {\n        s\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    find_space_helper(s, 0)\n}\n\nspec fn find_space_helper(s: Seq<char>, index: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        -1\n    } else if s[index] == ' ' {\n        index\n    } else {\n        find_space_helper(s, index + 1)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' && s.len() > 1 {\n        -string_to_int_helper(s.subrange(1, s.len() as int), 0, 0)\n    } else {\n        string_to_int_helper(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        acc\n    } else {\n        let digit = (s[index] as int) - ('0' as int);\n        string_to_int_helper(s, index + 1, acc * 10 + digit)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4256.rs,112,22,0.19642857142857142,215.916,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|i: int, j: int| 0 <= i < j < input.len() && input[i] == ' ' && input[j] == ' ' &&
    ({
        let parts = split_string_spec(input);
        parts.len() >= 3 && 
        is_valid_integer(parts[0]) && is_valid_integer(parts[1]) && is_valid_integer(parts[2]) &&
        ({
            let a = string_to_int_spec(parts[0]);
            let b = string_to_int_spec(parts[1]);
            let c = string_to_int_spec(parts[2]);
            1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100
        })
    })
}

spec fn compute_drinks(a: int, b: int, c: int) -> int {
    if b / a < c { b / a } else { c }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'
}

spec fn string_to_int_spec(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 1 { 
        s[0] as int - '0' as int
    } else if s.len() > 1 { 
        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)
    } else {
        0
    }
}

spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 { 
        seq![] 
    } else {
        split_helper(s, 0, seq![])
    }
}

spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>
    decreases s.len() - index
{
    if index >= s.len() {
        if current.len() > 0 { seq![current] } else { seq![] }
    } else if s[index] == ' ' || s[index] == '\n' || s[index] == '\t' {
        if current.len() > 0 { 
            seq![current] + split_helper(s, index + 1, seq![])
        } else { 
            split_helper(s, index + 1, seq![])
        }
    } else {
        split_helper(s, index + 1, current.push(s[index]))
    }
}

spec fn int_to_string_spec(n: int) -> Seq<char>
    decreases n
{
    if n == 0 { 
        seq!['0'] 
    } else if n < 10 && n > 0 { 
        seq![('0' as int + n) as char]
    } else if n > 0 { 
        int_to_string_spec(n / 10) + seq![('0' as int + (n % 10)) as char]
    } else {
        seq!['0']
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        valid_input(input@),
    ensures
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        ({
            let parts = split_string_spec(input@);
            let a = string_to_int_spec(parts[0]);
            let b = string_to_int_spec(parts[1]);
            let c = string_to_int_spec(parts[2]);
            let drinks = compute_drinks(a, b, c);
            result@ == int_to_string_spec(drinks) + seq!['\n']
        }),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input(input: Seq<char>) -> bool ;
       spec fn compute_drinks(a: int, b: int, c: int) -> int ;
       spec fn is_valid_integer(s: Seq<char>) -> bool ;
       spec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;
       spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;
       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;
       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;
       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\n',         ({
                  let parts = split_string_spec(input@);
                  let a = string_to_int_spec(parts[0]);
                  let b = string_to_int_spec(parts[1]);
                  let c = string_to_int_spec(parts[2]);
                  let drinks = compute_drinks(a, b, c);
                  result@ == int_to_string_spec(drinks) + seq!['\n']         }
      ), {
          assume(false);
          unreached() }
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|i: int, j: int| 0 <= i < j < input.len() && input[i] == ' ' && input[j] == ' ' &&\n    ({\n        let parts = split_string_spec(input);\n        parts.len() >= 3 && \n        is_valid_integer(parts[0]) && is_valid_integer(parts[1]) && is_valid_integer(parts[2]) &&\n        ({\n            let a = string_to_int_spec(parts[0]);\n            let b = string_to_int_spec(parts[1]);\n            let c = string_to_int_spec(parts[2]);\n            1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n        })\n    })\n}\n\nspec fn compute_drinks(a: int, b: int, c: int) -> int {\n    if b / a < c { b / a } else { c }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn string_to_int_spec(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 1 { \n        s[0] as int - '0' as int\n    } else if s.len() > 1 { \n        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    } else {\n        0\n    }\n}\n\nspec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 { \n        seq![] \n    } else {\n        split_helper(s, 0, seq![])\n    }\n}\n\nspec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        if current.len() > 0 { seq![current] } else { seq![] }\n    } else if s[index] == ' ' || s[index] == '\\n' || s[index] == '\\t' {\n        if current.len() > 0 { \n            seq![current] + split_helper(s, index + 1, seq![])\n        } else { \n            split_helper(s, index + 1, seq![])\n        }\n    } else {\n        split_helper(s, index + 1, current.push(s[index]))\n    }\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 { \n        seq!['0'] \n    } else if n < 10 && n > 0 { \n        seq![('0' as int + n) as char]\n    } else if n > 0 { \n        int_to_string_spec(n / 10) + seq![('0' as int + (n % 10)) as char]\n    } else {\n        seq!['0']\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n',\n        ({\n            let parts = split_string_spec(input@);\n            let a = string_to_int_spec(parts[0]);\n            let b = string_to_int_spec(parts[1]);\n            let c = string_to_int_spec(parts[2]);\n            let drinks = compute_drinks(a, b, c);\n            result@ == int_to_string_spec(drinks) + seq!['\\n']\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', ""use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool ;\n       spec fn compute_drinks(a: int, b: int, c: int) -> int ;\n       spec fn is_valid_integer(s: Seq<char>) -> bool ;\n       spec fn string_to_int_spec(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>     decreases s.len() - index ;\n       spec fn int_to_string_spec(n: int) -> Seq<char>     decreases n ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires         valid_input(input@),     ensures         result@.len() > 0,         result@[result@.len() - 1] == '\\n',         ({\n                  let parts = split_string_spec(input@);\n                  let a = string_to_int_spec(parts[0]);\n                  let b = string_to_int_spec(parts[1]);\n                  let c = string_to_int_spec(parts[2]);\n                  let drinks = compute_drinks(a, b, c);\n                  result@ == int_to_string_spec(drinks) + seq!['\\n']         }\n      ), {\n          assume(false);\n          unreached() }\n       }\n        fn main() {\n      }\n"", 'use vstd::prelude::*;\n           fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4297.rs,58,58,1.0,154.89,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn divisible_by_both(result: int, n: int) -> bool
    recommends n >= 1
{
    result % 2 == 0 && result % n == 0
}

spec fn is_smallest(result: int, n: int) -> bool
    recommends n >= 1
{
    forall|k: int| 1 <= k < result ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n) == 0)
}

spec fn lcm(a: int, b: int) -> int
    recommends a >= 1 && b >= 1
{
    if a % b == 0 {
        a
    } else if b % a == 0 {
        b
    } else {
        a * b
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires 
        n >= 1,
    ensures 
        result >= 1,
        result as int % 2 == 0 && result as int % n as int == 0,
        forall|k: int| 1 <= k < result as int ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n as int) == 0),
        (n as int % 2 == 0 ==> result as int == n as int) && (n as int % 2 != 0 ==> result as int == n as int * 2),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn divisible_by_both(result: int, n: int) -> bool
    recommends n >= 1
{
    result % 2 == 0 && result % n == 0
}

spec fn is_smallest(result: int, n: int) -> bool
    recommends n >= 1
{
    forall|k: int| 1 <= k < result ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n) == 0)
}

spec fn lcm(a: int, b: int) -> int
    recommends a >= 1 && b >= 1
{
    if a % b == 0 {
        a
    } else if b % a == 0 {
        b
    } else {
        a * b
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires 
        n >= 1,
    ensures 
        result >= 1,
        result as int % 2 == 0 && result as int % n as int == 0,
        forall|k: int| 1 <= k < result as int ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n as int) == 0),
        (n as int % 2 == 0 ==> result as int == n as int) && (n as int % 2 != 0 ==> result as int == n as int * 2),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn divisible_by_both(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    result % 2 == 0 && result % n == 0\n}\n\nspec fn is_smallest(result: int, n: int) -> bool\n    recommends n >= 1\n{\n    forall|k: int| 1 <= k < result ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n) == 0)\n}\n\nspec fn lcm(a: int, b: int) -> int\n    recommends a >= 1 && b >= 1\n{\n    if a % b == 0 {\n        a\n    } else if b % a == 0 {\n        b\n    } else {\n        a * b\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        n >= 1,\n    ensures \n        result >= 1,\n        result as int % 2 == 0 && result as int % n as int == 0,\n        forall|k: int| 1 <= k < result as int ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n as int) == 0),\n        (n as int % 2 == 0 ==> result as int == n as int) && (n as int % 2 != 0 ==> result as int == n as int * 2),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n             fn main() {\n   }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4299.rs,51,51,1.0,122.969,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 999
}

spec fn is_hon_digit(digit: int) -> bool {
    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9
}

spec fn is_pon_digit(digit: int) -> bool {
    digit == 0 || digit == 1 || digit == 6 || digit == 8
}

spec fn is_bon_digit(digit: int) -> bool {
    digit == 3
}

spec fn correct_pronunciation(n: int) -> Seq<char> {
    let ones_digit = n % 10;
    if is_hon_digit(ones_digit) {
        seq!['h', 'o', 'n', '\n']
    } else if is_pon_digit(ones_digit) {
        seq!['p', 'o', 'n', '\n']
    } else {
        seq!['b', 'o', 'n', '\n']
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: Vec<char>)
    requires valid_input(n as int)
    ensures result@ == correct_pronunciation(n as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 999
}

spec fn is_hon_digit(digit: int) -> bool {
    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9
}

spec fn is_pon_digit(digit: int) -> bool {
    digit == 0 || digit == 1 || digit == 6 || digit == 8
}

spec fn is_bon_digit(digit: int) -> bool {
    digit == 3
}

spec fn correct_pronunciation(n: int) -> Seq<char> {
    let ones_digit = n % 10;
    if is_hon_digit(ones_digit) {
        seq!['h', 'o', 'n', '\n']
    } else if is_pon_digit(ones_digit) {
        seq!['p', 'o', 'n', '\n']
    } else {
        seq!['b', 'o', 'n', '\n']
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: Vec<char>)
    requires valid_input(n as int)
    ensures result@ == correct_pronunciation(n as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 999\n}\n\nspec fn is_hon_digit(digit: int) -> bool {\n    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9\n}\n\nspec fn is_pon_digit(digit: int) -> bool {\n    digit == 0 || digit == 1 || digit == 6 || digit == 8\n}\n\nspec fn is_bon_digit(digit: int) -> bool {\n    digit == 3\n}\n\nspec fn correct_pronunciation(n: int) -> Seq<char> {\n    let ones_digit = n % 10;\n    if is_hon_digit(ones_digit) {\n        seq!['h', 'o', 'n', '\\n']\n    } else if is_pon_digit(ones_digit) {\n        seq!['p', 'o', 'n', '\\n']\n    } else {\n        seq!['b', 'o', 'n', '\\n']\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: Vec<char>)\n    requires valid_input(n as int)\n    ensures result@ == correct_pronunciation(n as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4317.rs,104,104,1.0,124.097,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 3 &&
    exists|space_pos: int| 0 < space_pos < input.len() - 1 && input[space_pos] == ' ' &&
    (forall|i: int| 0 <= i < space_pos ==> input[i] != ' ') &&
    (forall|i: int| space_pos + 1 <= i < input.len() ==> input[i] != ' ' || input[i] == '\n') &&
    is_valid_integer(get_a_string(input)) && is_valid_integer(get_b_string(input)) &&
    -100 <= get_a(input) <= 100 && -100 <= get_b(input) <= 100
}

spec fn get_a(input: Seq<char>) -> int {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        parse_int(trimmed.subrange(0, space_index))
    } else {
        let space_index = find_space(input);
        parse_int(input.subrange(0, space_index))
    }
}

spec fn get_b(input: Seq<char>) -> int {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        parse_int(trimmed.subrange(space_index + 1, trimmed.len() as int))
    } else {
        let space_index = find_space(input);
        parse_int(input.subrange(space_index + 1, input.len() as int))
    }
}

spec fn get_a_string(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        trimmed.subrange(0, space_index)
    } else {
        let space_index = find_space(input);
        input.subrange(0, space_index)
    }
}

spec fn get_b_string(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        trimmed.subrange(space_index + 1, trimmed.len() as int)
    } else {
        let space_index = find_space(input);
        input.subrange(space_index + 1, input.len() as int)
    }
}

spec fn max3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c {
        a
    } else if b >= c {
        b
    } else {
        c
    }
}

spec fn find_space(s: Seq<char>) -> int {
    0  /* placeholder for finding space position */
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    true  /* placeholder for integer validation */
}

spec fn parse_int(s: Seq<char>) -> int {
    0  /* placeholder for parsing integer */
}

spec fn int_to_string(i: int) -> Seq<char> {
    seq!['0']  /* placeholder for integer to string conversion */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(input@.map_values(|b: u8| b as char))
    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 3 &&
    exists|space_pos: int| 0 < space_pos < input.len() - 1 && input[space_pos] == ' ' &&
    (forall|i: int| 0 <= i < space_pos ==> input[i] != ' ') &&
    (forall|i: int| space_pos + 1 <= i < input.len() ==> input[i] != ' ' || input[i] == '\n') &&
    is_valid_integer(get_a_string(input)) && is_valid_integer(get_b_string(input)) &&
    -100 <= get_a(input) <= 100 && -100 <= get_b(input) <= 100
}

spec fn get_a(input: Seq<char>) -> int {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        parse_int(trimmed.subrange(0, space_index))
    } else {
        let space_index = find_space(input);
        parse_int(input.subrange(0, space_index))
    }
}

spec fn get_b(input: Seq<char>) -> int {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        parse_int(trimmed.subrange(space_index + 1, trimmed.len() as int))
    } else {
        let space_index = find_space(input);
        parse_int(input.subrange(space_index + 1, input.len() as int))
    }
}

spec fn get_a_string(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        trimmed.subrange(0, space_index)
    } else {
        let space_index = find_space(input);
        input.subrange(0, space_index)
    }
}

spec fn get_b_string(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        trimmed.subrange(space_index + 1, trimmed.len() as int)
    } else {
        let space_index = find_space(input);
        input.subrange(space_index + 1, input.len() as int)
    }
}

spec fn max3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c {
        a
    } else if b >= c {
        b
    } else {
        c
    }
}

spec fn find_space(s: Seq<char>) -> int {
    0  /* placeholder for finding space position */
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    true  /* placeholder for integer validation */
}

spec fn parse_int(s: Seq<char>) -> int {
    0  /* placeholder for parsing integer */
}

spec fn int_to_string(i: int) -> Seq<char> {
    seq!['0']  /* placeholder for integer to string conversion */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(input@.map_values(|b: u8| b as char))
    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 3 &&\n    exists|space_pos: int| 0 < space_pos < input.len() - 1 && input[space_pos] == ' ' &&\n    (forall|i: int| 0 <= i < space_pos ==> input[i] != ' ') &&\n    (forall|i: int| space_pos + 1 <= i < input.len() ==> input[i] != ' ' || input[i] == '\\n') &&\n    is_valid_integer(get_a_string(input)) && is_valid_integer(get_b_string(input)) &&\n    -100 <= get_a(input) <= 100 && -100 <= get_b(input) <= 100\n}\n\nspec fn get_a(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(0, space_index))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(0, space_index))\n    }\n}\n\nspec fn get_b(input: Seq<char>) -> int {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        parse_int(trimmed.subrange(space_index + 1, trimmed.len() as int))\n    } else {\n        let space_index = find_space(input);\n        parse_int(input.subrange(space_index + 1, input.len() as int))\n    }\n}\n\nspec fn get_a_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(0, space_index)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(0, space_index)\n    }\n}\n\nspec fn get_b_string(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == '\\n' {\n        let trimmed = input.subrange(0, input.len() as int - 1);\n        let space_index = find_space(trimmed);\n        trimmed.subrange(space_index + 1, trimmed.len() as int)\n    } else {\n        let space_index = find_space(input);\n        input.subrange(space_index + 1, input.len() as int)\n    }\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c {\n        a\n    } else if b >= c {\n        b\n    } else {\n        c\n    }\n}\n\nspec fn find_space(s: Seq<char>) -> int {\n    0  /* placeholder for finding space position */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true  /* placeholder for integer validation */\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0  /* placeholder for parsing integer */\n}\n\nspec fn int_to_string(i: int) -> Seq<char> {\n    seq!['0']  /* placeholder for integer to string conversion */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(input@.map_values(|b: u8| b as char))\n    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4318.rs,67,13,0.19402985074626866,185.737,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int
    decreases up_to_index
{
    if 0 <= up_to_index < heights.len() {
        if up_to_index == 0 {
            heights[0]
        } else if heights[up_to_index] >= max_height_up_to(heights, up_to_index - 1) {
            heights[up_to_index]
        } else {
            max_height_up_to(heights, up_to_index - 1)
        }
    } else {
        0
    }
}

spec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool {
    if 0 <= mountain_index < heights.len() {
        mountain_index == 0 || heights[mountain_index] >= max_height_up_to(heights, mountain_index - 1)
    } else {
        false
    }
}

spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int
    decreases n
{
    if n <= 0 {
        0
    } else if has_ocean_visibility(heights, n - 1) {
        1 + count_visible_mountains(heights, n - 1)
    } else {
        count_visible_mountains(heights, n - 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u32, heights: Vec<i32>) -> (result: u32)
    requires 
        n > 0,
        heights.len() == n,
        n <= 20,
        forall|i: int| 0 <= i < heights.len() ==> 1 <= #[trigger] heights[i] as int <= 100,
    ensures 
        1 <= result <= n,
        result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int     decreases up_to_index ;
       spec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool ;
       spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int     decreases n ;
       fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        
#[trigger] heights[i] as int <= 100,
    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {
          assume(false);
          0 }
       }
        fn main() {
      }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int\n    decreases up_to_index\n{\n    if 0 <= up_to_index < heights.len() {\n        if up_to_index == 0 {\n            heights[0]\n        } else if heights[up_to_index] >= max_height_up_to(heights, up_to_index - 1) {\n            heights[up_to_index]\n        } else {\n            max_height_up_to(heights, up_to_index - 1)\n        }\n    } else {\n        0\n    }\n}\n\nspec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool {\n    if 0 <= mountain_index < heights.len() {\n        mountain_index == 0 || heights[mountain_index] >= max_height_up_to(heights, mountain_index - 1)\n    } else {\n        false\n    }\n}\n\nspec fn count_visible_mountains(heights: Seq<int>, n: int) -> int\n    decreases n\n{\n    if n <= 0 {\n        0\n    } else if has_ocean_visibility(heights, n - 1) {\n        1 + count_visible_mountains(heights, n - 1)\n    } else {\n        count_visible_mountains(heights, n - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u32, heights: Vec<i32>) -> (result: u32)\n    requires \n        n > 0,\n        heights.len() == n,\n        n <= 20,\n        forall|i: int| 0 <= i < heights.len() ==> 1 <= #[trigger] heights[i] as int <= 100,\n    ensures \n        1 <= result <= n,\n        result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int     decreases up_to_index ;\n       spec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool ;\n       spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int     decreases n ;\n       fn solve(n: u32, heights: Vec<i32>) -> (result: u32)     requires          n > 0,         heights.len() == n,         n <= 20,         forall|i: int| 0 <= i < heights.len() ==> 1 <=        \n#[trigger] heights[i] as int <= 100,\n    ensures          1 <= result <= n,         result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int), {\n          assume(false);\n          0 }\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n             fn main() {\n   }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4332.rs,87,11,0.12643678160919541,185.876,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_digit(c: char) -> bool {
    '0' <= c && c <= '9'
}

spec fn digit_value(c: char) -> int
    recommends is_digit(c)
{
    c as int - '0' as int
}

spec fn sum_of_digits(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if is_digit(s[0]) {
        digit_value(s[0]) + sum_of_digits(s.subrange(1, s.len() as int))
    } else {
        sum_of_digits(s.subrange(1, s.len() as int))
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if is_digit(s[0]) {
        string_to_int(s.subrange(1, s.len() as int)) + digit_value(s[0]) * power_10((s.len() - 1) as int)
    } else {
        string_to_int(s.subrange(1, s.len() as int))
    }
}

spec fn power_10(n: int) -> int
    decreases n when n >= 0
{
    if n <= 0 { 1 } else { 10 * power_10(n - 1) }
}

spec fn clean_input(input: Seq<char>) -> Seq<char>
    decreases input.len()
{
    if input.len() == 0 {
        seq![]
    } else if input[input.len() - 1] == '\n' || input[input.len() - 1] == ' ' {
        clean_input(input.subrange(0, input.len() - 1))
    } else {
        input
    }
}

spec fn valid_positive_integer_string(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (forall|i: int| #![auto] 0 <= i < s.len() ==> is_digit(s[i])) && 
    (s.len() > 1 ==> s[0] != '0') && 
    string_to_int(s) > 0
}

spec fn valid_input(input: Seq<char>) -> bool {
    valid_positive_integer_string(clean_input(input))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires valid_input(input@)
    ensures result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No"".to_string()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn is_digit(c: char) -> bool ;
       spec fn digit_value(c: char) -> int     recommends is_digit(c) ;
       spec fn string_to_int(s: Seq<char>) -> int     decreases s.len() ;
       spec fn power_10(n: int) -> int     decreases n when n >= 0 ;
       spec fn valid_positive_integer_string(s: Seq<char>) -> bool {
         (s.len() > 1 ==> s[0] != '0') &&      string_to_int(s) > 0 }
       }
        fn main() {
      }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_digit(c: char) -> bool {\n    \'0\' <= c && c <= \'9\'\n}\n\nspec fn digit_value(c: char) -> int\n    recommends is_digit(c)\n{\n    c as int - \'0\' as int\n}\n\nspec fn sum_of_digits(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if is_digit(s[0]) {\n        digit_value(s[0]) + sum_of_digits(s.subrange(1, s.len() as int))\n    } else {\n        sum_of_digits(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if is_digit(s[0]) {\n        string_to_int(s.subrange(1, s.len() as int)) + digit_value(s[0]) * power_10((s.len() - 1) as int)\n    } else {\n        string_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn power_10(n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 { 1 } else { 10 * power_10(n - 1) }\n}\n\nspec fn clean_input(input: Seq<char>) -> Seq<char>\n    decreases input.len()\n{\n    if input.len() == 0 {\n        seq![]\n    } else if input[input.len() - 1] == \'\\n\' || input[input.len() - 1] == \' \' {\n        clean_input(input.subrange(0, input.len() - 1))\n    } else {\n        input\n    }\n}\n\nspec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (forall|i: int| #![auto] 0 <= i < s.len() ==> is_digit(s[i])) && \n    (s.len() > 1 ==> s[0] != \'0\') && \n    string_to_int(s) > 0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    valid_positive_integer_string(clean_input(input))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == seq![\'Y\', \'e\', \'s\'] || result@ == seq![\'N\', \'o\']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""No"".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', ""use vstd::prelude::*;\n        verus! {\n       spec fn is_digit(c: char) -> bool ;\n       spec fn digit_value(c: char) -> int     recommends is_digit(c) ;\n       spec fn string_to_int(s: Seq<char>) -> int     decreases s.len() ;\n       spec fn power_10(n: int) -> int     decreases n when n >= 0 ;\n       spec fn valid_positive_integer_string(s: Seq<char>) -> bool {\n         (s.len() > 1 ==> s[0] != '0') &&      string_to_int(s) > 0 }\n       }\n        fn main() {\n      }\n"", 'use vstd::prelude::*;\n             fn main() {\n   }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4343.rs,62,26,0.41935483870967744,186.631,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> {
    let s_val = string_to_base26(s);
    let t_val = string_to_base26(t);
    let median_val = (s_val + t_val) / 2;
    base26_to_string(median_val, k)
}

spec fn string_to_base26(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { ((s[0] as int - 'a' as int) * pow26((s.len() - 1) as nat) + string_to_base26(s.subrange(1, s.len() as int))) as nat }
}

spec fn base26_to_string(val: nat, k: int) -> Seq<char>
    decreases k when k >= 1
{
    if k == 1 { seq![((val % 26) + ('a' as int)) as char] }
    else { base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }
}

spec fn pow26(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { 26 * pow26((n - 1) as nat) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)
    requires 
        k >= 1,
        s.len() == k,
        t.len() == k,
        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] s[i] <= 'z',
        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] t[i] <= 'z',
    ensures 
        result.len() == k,
        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] result[i] <= 'z',
        result@ == median_string(s@, t@, k as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> ;
       spec fn string_to_base26(s: Seq<char>) -> nat     decreases s.len() ;
       spec fn base26_to_string(val: nat, k: int) -> Seq<char>     decreases k when k >= 1 {
          if k == 1 {
     seq![((val % 26) + ('a' as int)) as char] }
          else {
     base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }
      }
       spec fn pow26(n: nat) -> nat     decreases n {
          if n == 0 {
     1 }
      else {
     26 * pow26((n - 1) as nat) }
      }
       fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)     requires          k >= 1,         s.len() == k,         t.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        
#[trigger] s[i] <= 'z',
    ensures          result.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        
#[trigger] result[i] <= 'z',
        result@ == median_string(s@, t@, k as int), {
          assume(false);
          Vec::new() }
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> {\n    let s_val = string_to_base26(s);\n    let t_val = string_to_base26(t);\n    let median_val = (s_val + t_val) / 2;\n    base26_to_string(median_val, k)\n}\n\nspec fn string_to_base26(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { ((s[0] as int - 'a' as int) * pow26((s.len() - 1) as nat) + string_to_base26(s.subrange(1, s.len() as int))) as nat }\n}\n\nspec fn base26_to_string(val: nat, k: int) -> Seq<char>\n    decreases k when k >= 1\n{\n    if k == 1 { seq![((val % 26) + ('a' as int)) as char] }\n    else { base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }\n}\n\nspec fn pow26(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 26 * pow26((n - 1) as nat) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)\n    requires \n        k >= 1,\n        s.len() == k,\n        t.len() == k,\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] s[i] <= 'z',\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] t[i] <= 'z',\n    ensures \n        result.len() == k,\n        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] result[i] <= 'z',\n        result@ == median_string(s@, t@, k as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', ""use vstd::prelude::*;\n        verus! {\n       spec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> ;\n       spec fn string_to_base26(s: Seq<char>) -> nat     decreases s.len() ;\n       spec fn base26_to_string(val: nat, k: int) -> Seq<char>     decreases k when k >= 1 {\n          if k == 1 {\n     seq![((val % 26) + ('a' as int)) as char] }\n          else {\n     base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }\n      }\n       spec fn pow26(n: nat) -> nat     decreases n {\n          if n == 0 {\n     1 }\n      else {\n     26 * pow26((n - 1) as nat) }\n      }\n       fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)     requires          k >= 1,         s.len() == k,         t.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n#[trigger] s[i] <= 'z',\n    ensures          result.len() == k,         forall|i: int| 0 <= i < k ==> 'a' <=        \n#[trigger] result[i] <= 'z',\n        result@ == median_string(s@, t@, k as int), {\n          assume(false);\n          Vec::new() }\n       }\n        fn main() {\n      }\n"", 'use vstd::prelude::*;\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4363.rs,68,68,1.0,122.7,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(k: int, s: int) -> bool {
    k >= 0 && s >= 0 && s <= 3 * k
}

spec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {
    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s
}

spec fn count_valid_triples(k: int, s: int) -> int
    recommends k >= 0
{
    count_valid_triples_helper(k, s, 0)
}

spec fn count_valid_triples_helper(k: int, s: int, z: int) -> int
    recommends k >= 0, z >= 0
    decreases if k >= z { k + 1 - z } else { 0 }
{
    if z > k { 0 }
    else { count_valid_triples_for_z(k, s, z) + count_valid_triples_helper(k, s, z + 1) }
}

spec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int
    recommends k >= 0, z >= 0
{
    count_valid_triples_for_z_helper(k, s, z, 0)
}

spec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int
    recommends k >= 0, z >= 0, y >= 0
    decreases if k >= y { k + 1 - y } else { 0 }
{
    if y > k { 0 }
    else { 
        let x = s - y - z;
        let this_count: int = if 0 <= x <= k { 1 } else { 0 };
        this_count + count_valid_triples_for_z_helper(k, s, z, y + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn count_triples(k: i8, s: i8) -> (count: i8)
    requires
        valid_input(k as int, s as int),
    ensures
        count as int == count_valid_triples(k as int, s as int),
        count >= 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(k: int, s: int) -> bool {
    k >= 0 && s >= 0 && s <= 3 * k
}

spec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {
    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s
}

spec fn count_valid_triples(k: int, s: int) -> int
    recommends k >= 0
{
    count_valid_triples_helper(k, s, 0)
}

spec fn count_valid_triples_helper(k: int, s: int, z: int) -> int
    recommends k >= 0, z >= 0
    decreases if k >= z { k + 1 - z } else { 0 }
{
    if z > k { 0 }
    else { count_valid_triples_for_z(k, s, z) + count_valid_triples_helper(k, s, z + 1) }
}

spec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int
    recommends k >= 0, z >= 0
{
    count_valid_triples_for_z_helper(k, s, z, 0)
}

spec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int
    recommends k >= 0, z >= 0, y >= 0
    decreases if k >= y { k + 1 - y } else { 0 }
{
    if y > k { 0 }
    else { 
        let x = s - y - z;
        let this_count: int = if 0 <= x <= k { 1 } else { 0 };
        this_count + count_valid_triples_for_z_helper(k, s, z, y + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn count_triples(k: i8, s: i8) -> (count: i8)
    requires
        valid_input(k as int, s as int),
    ensures
        count as int == count_valid_triples(k as int, s as int),
        count >= 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int, s: int) -> bool {\n    k >= 0 && s >= 0 && s <= 3 * k\n}\n\nspec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {\n    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s\n}\n\nspec fn count_valid_triples(k: int, s: int) -> int\n    recommends k >= 0\n{\n    count_valid_triples_helper(k, s, 0)\n}\n\nspec fn count_valid_triples_helper(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n    decreases if k >= z { k + 1 - z } else { 0 }\n{\n    if z > k { 0 }\n    else { count_valid_triples_for_z(k, s, z) + count_valid_triples_helper(k, s, z + 1) }\n}\n\nspec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int\n    recommends k >= 0, z >= 0\n{\n    count_valid_triples_for_z_helper(k, s, z, 0)\n}\n\nspec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int\n    recommends k >= 0, z >= 0, y >= 0\n    decreases if k >= y { k + 1 - y } else { 0 }\n{\n    if y > k { 0 }\n    else { \n        let x = s - y - z;\n        let this_count: int = if 0 <= x <= k { 1 } else { 0 };\n        this_count + count_valid_triples_for_z_helper(k, s, z, y + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_triples(k: i8, s: i8) -> (count: i8)\n    requires\n        valid_input(k as int, s as int),\n    ensures\n        count as int == count_valid_triples(k as int, s as int),\n        count >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4365.rs,58,58,1.0,153.733,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(k: int) -> bool {
    2 <= k <= 100
}

spec fn count_odd_numbers(k: int) -> int
    recommends k >= 1
{
    (k + 1) / 2
}

spec fn count_even_numbers(k: int) -> int
    recommends k >= 1
{
    k / 2
}

spec fn expected_result(k: int) -> int
    recommends valid_input(k)
{
    count_odd_numbers(k) * count_even_numbers(k)
}

spec fn correct_result(k: int, result: int) -> bool
    recommends valid_input(k)
{
    result == expected_result(k)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn count_even_odd_pairs(k: i8) -> (result: i8)
    requires
        valid_input(k as int),
    ensures
        correct_result(k as int, result as int),
        result >= 0,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(k: int) -> bool {
    2 <= k <= 100
}

spec fn count_odd_numbers(k: int) -> int
    recommends k >= 1
{
    (k + 1) / 2
}

spec fn count_even_numbers(k: int) -> int
    recommends k >= 1
{
    k / 2
}

spec fn expected_result(k: int) -> int
    recommends valid_input(k)
{
    count_odd_numbers(k) * count_even_numbers(k)
}

spec fn correct_result(k: int, result: int) -> bool
    recommends valid_input(k)
{
    result == expected_result(k)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn count_even_odd_pairs(k: i8) -> (result: i8)
    requires
        valid_input(k as int),
    ensures
        correct_result(k as int, result as int),
        result >= 0,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(k: int) -> bool {\n    2 <= k <= 100\n}\n\nspec fn count_odd_numbers(k: int) -> int\n    recommends k >= 1\n{\n    (k + 1) / 2\n}\n\nspec fn count_even_numbers(k: int) -> int\n    recommends k >= 1\n{\n    k / 2\n}\n\nspec fn expected_result(k: int) -> int\n    recommends valid_input(k)\n{\n    count_odd_numbers(k) * count_even_numbers(k)\n}\n\nspec fn correct_result(k: int, result: int) -> bool\n    recommends valid_input(k)\n{\n    result == expected_result(k)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn count_even_odd_pairs(k: i8) -> (result: i8)\n    requires\n        valid_input(k as int),\n    ensures\n        correct_result(k as int, result as int),\n        result >= 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4366.rs,69,69,1.0,123.054,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else if n == 4 { seq!['4'] }
    else if n == 5 { seq!['5'] }
    else if n == 6 { seq!['6'] }
    else if n == 7 { seq!['7'] }
    else if n == 8 { seq!['8'] }
    else if n == 9 { seq!['9'] }
    else if n == 10 { seq!['1', '0'] }
    else if n == 11 { seq!['1', '1'] }
    else if n == 12 { seq!['1', '2'] }
    else if n == 13 { seq!['1', '3'] }
    else if n == 14 { seq!['1', '4'] }
    else if n == 15 { seq!['1', '5'] }
    else if n == 16 { seq!['1', '6'] }
    else if n == 17 { seq!['1', '7'] }
    else if n == 18 { seq!['1', '8'] }
    else if n == 19 { seq!['1', '9'] }
    else if n == 20 { seq!['2', '0'] }
    else if n == 21 { seq!['2', '1'] }
    else if n == 22 { seq!['2', '2'] }
    else if n == 23 { seq!['2', '3'] }
    else { seq!['0'] }
}

spec fn valid_input(input: Seq<char>) -> bool {
    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && 
    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\n'] ||
     input == int_to_string(a) + seq![' '] + int_to_string(b))
}

spec fn contest_start_time(a: int, b: int) -> int {
    (a + b) % 24
}

spec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {
    valid_input(input) ==> 
    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && 
    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\n'] ||
     input == int_to_string(a) + seq![' '] + int_to_string(b)) &&
    result == int_to_string(contest_start_time(a, b)) + seq!['\n']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    ensures correct_output(input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else if n == 4 { seq!['4'] }
    else if n == 5 { seq!['5'] }
    else if n == 6 { seq!['6'] }
    else if n == 7 { seq!['7'] }
    else if n == 8 { seq!['8'] }
    else if n == 9 { seq!['9'] }
    else if n == 10 { seq!['1', '0'] }
    else if n == 11 { seq!['1', '1'] }
    else if n == 12 { seq!['1', '2'] }
    else if n == 13 { seq!['1', '3'] }
    else if n == 14 { seq!['1', '4'] }
    else if n == 15 { seq!['1', '5'] }
    else if n == 16 { seq!['1', '6'] }
    else if n == 17 { seq!['1', '7'] }
    else if n == 18 { seq!['1', '8'] }
    else if n == 19 { seq!['1', '9'] }
    else if n == 20 { seq!['2', '0'] }
    else if n == 21 { seq!['2', '1'] }
    else if n == 22 { seq!['2', '2'] }
    else if n == 23 { seq!['2', '3'] }
    else { seq!['0'] }
}

spec fn valid_input(input: Seq<char>) -> bool {
    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && 
    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\n'] ||
     input == int_to_string(a) + seq![' '] + int_to_string(b))
}

spec fn contest_start_time(a: int, b: int) -> int {
    (a + b) % 24
}

spec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {
    valid_input(input) ==> 
    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && 
    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\n'] ||
     input == int_to_string(a) + seq![' '] + int_to_string(b)) &&
    result == int_to_string(contest_start_time(a, b)) + seq!['\n']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    ensures correct_output(input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else if n == 4 { seq!['4'] }\n    else if n == 5 { seq!['5'] }\n    else if n == 6 { seq!['6'] }\n    else if n == 7 { seq!['7'] }\n    else if n == 8 { seq!['8'] }\n    else if n == 9 { seq!['9'] }\n    else if n == 10 { seq!['1', '0'] }\n    else if n == 11 { seq!['1', '1'] }\n    else if n == 12 { seq!['1', '2'] }\n    else if n == 13 { seq!['1', '3'] }\n    else if n == 14 { seq!['1', '4'] }\n    else if n == 15 { seq!['1', '5'] }\n    else if n == 16 { seq!['1', '6'] }\n    else if n == 17 { seq!['1', '7'] }\n    else if n == 18 { seq!['1', '8'] }\n    else if n == 19 { seq!['1', '9'] }\n    else if n == 20 { seq!['2', '0'] }\n    else if n == 21 { seq!['2', '1'] }\n    else if n == 22 { seq!['2', '2'] }\n    else if n == 23 { seq!['2', '3'] }\n    else { seq!['0'] }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b))\n}\n\nspec fn contest_start_time(a: int, b: int) -> int {\n    (a + b) % 24\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) ==> \n    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && \n    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\\n'] ||\n     input == int_to_string(a) + seq![' '] + int_to_string(b)) &&\n    result == int_to_string(contest_start_time(a, b)) + seq!['\\n']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    ensures correct_output(input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4371.rs,50,50,1.0,154.671,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '1' && #[trigger] s.index(i) <= '9'
}

spec fn string_to_int(s: Seq<char>) -> int {
    100 * ((s.index(0) as int) - ('0' as int)) + 
    10 * ((s.index(1) as int) - ('0' as int)) + 
    ((s.index(2) as int) - ('0' as int))
}

spec fn abs_diff(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {
    s.subrange(i, i + 3)
}

spec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {
    valid_input(s) ==> (
        result >= 0 &&
        (exists|i: int| 0 <= i <= s.len() - 3 && result == abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i)))) &&
        (forall|i: int| 0 <= i <= s.len() - 3 ==> result <= abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i))))
    )
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i32)
    requires valid_input(s@)
    ensures is_minimum_difference(s@, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '1' && #[trigger] s.index(i) <= '9'
}

spec fn string_to_int(s: Seq<char>) -> int {
    100 * ((s.index(0) as int) - ('0' as int)) + 
    10 * ((s.index(1) as int) - ('0' as int)) + 
    ((s.index(2) as int) - ('0' as int))
}

spec fn abs_diff(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {
    s.subrange(i, i + 3)
}

spec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {
    valid_input(s) ==> (
        result >= 0 &&
        (exists|i: int| 0 <= i <= s.len() - 3 && result == abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i)))) &&
        (forall|i: int| 0 <= i <= s.len() - 3 ==> result <= abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i))))
    )
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: i32)
    requires valid_input(s@)
    ensures is_minimum_difference(s@, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '1' && #[trigger] s.index(i) <= '9'\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    100 * ((s.index(0) as int) - ('0' as int)) + \n    10 * ((s.index(1) as int) - ('0' as int)) + \n    ((s.index(2) as int) - ('0' as int))\n}\n\nspec fn abs_diff(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {\n    s.subrange(i, i + 3)\n}\n\nspec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {\n    valid_input(s) ==> (\n        result >= 0 &&\n        (exists|i: int| 0 <= i <= s.len() - 3 && result == abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i)))) &&\n        (forall|i: int| 0 <= i <= s.len() - 3 ==> result <= abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i))))\n    )\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: i32)\n    requires valid_input(s@)\n    ensures is_minimum_difference(s@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4386.rs,50,50,1.0,154.494,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 < i < input.len() && input[i] == '\n') &&
    (forall|i: int| #![trigger input[i]] 0 <= i < input.len() ==> input[i] == '\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&
    (exists|i: int| 0 < i < input.len() && input[i] == '\n' && (forall|j: int| #![trigger input[j]] 0 <= j < i ==> '0' <= input[j] <= '9'))
}

spec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {
    2800 <= a < 5000 &&
    1 <= s.len() <= 10 &&
    (forall|j: int| #![trigger s[j]] 0 <= j < s.len() ==> 'a' <= s[j] <= 'z')
}

spec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {
    (a >= 3200 ==> result == s + seq!['\n']) &&
    (a < 3200 ==> result == seq!['r', 'e', 'd', '\n'])
}

spec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {
    (0, seq!['a'])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n'
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 < i < input.len() && input[i] == '\n') &&
    (forall|i: int| #![trigger input[i]] 0 <= i < input.len() ==> input[i] == '\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&
    (exists|i: int| 0 < i < input.len() && input[i] == '\n' && (forall|j: int| #![trigger input[j]] 0 <= j < i ==> '0' <= input[j] <= '9'))
}

spec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {
    2800 <= a < 5000 &&
    1 <= s.len() <= 10 &&
    (forall|j: int| #![trigger s[j]] 0 <= j < s.len() ==> 'a' <= s[j] <= 'z')
}

spec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {
    (a >= 3200 ==> result == s + seq!['\n']) &&
    (a < 3200 ==> result == seq!['r', 'e', 'd', '\n'])
}

spec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {
    (0, seq!['a'])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n'
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n') &&\n    (forall|i: int| #![trigger input[i]] 0 <= i < input.len() ==> input[i] == '\\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&\n    (exists|i: int| 0 < i < input.len() && input[i] == '\\n' && (forall|j: int| #![trigger input[j]] 0 <= j < i ==> '0' <= input[j] <= '9'))\n}\n\nspec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {\n    2800 <= a < 5000 &&\n    1 <= s.len() <= 10 &&\n    (forall|j: int| #![trigger s[j]] 0 <= j < s.len() ==> 'a' <= s[j] <= 'z')\n}\n\nspec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {\n    (a >= 3200 ==> result == s + seq!['\\n']) &&\n    (a < 3200 ==> result == seq!['r', 'e', 'd', '\\n'])\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {\n    (0, seq!['a'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@)\n    ensures \n        result@.len() > 0,\n        result@[result@.len() - 1] == '\\n'\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n             fn main() {\n   }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4392.rs,101,101,1.0,123.582,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {
    a.len() > 1 && allowed_pos.len() == a.len()
}

spec fn is_sorted(a: Seq<int>) -> bool
    decreases a.len()
{
    if a.len() <= 1 {
        true
    } else {
        a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))
    }
}

spec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {
    original.len() == target.len() && target.len() == allowed.len() &&
    original.to_multiset() == target.to_multiset()
}

spec fn sort_sequence(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_sort_seq(s)
    }
}

spec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_sort_helper(s, s.len() as nat)
    }
}

spec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>
    decreases passes
{
    if passes == 0 {
        s
    } else {
        bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)
    }
}

spec fn bubble_pass(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_pass_helper(s, 0)
    }
}

spec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>
    decreases if pos <= s.len() { s.len() - pos } else { 0 }
{
    if pos >= s.len() || pos >= s.len() - 1 {
        s
    } else if s[pos as int] > s[(pos + 1) as int] {
        bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)
    } else {
        bubble_pass_helper(s, pos + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn can_sort(a: &mut Vec<i8>, allowed_pos: &[bool]) -> (result: bool)
    requires 
        valid_input(old(a)@.map_values(|x: i8| x as int), allowed_pos@),
    ensures 
        a@.map_values(|x: i8| x as int).to_multiset() == old(a)@.map_values(|x: i8| x as int).to_multiset(),
        result == is_sorted(a@.map_values(|x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    false
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {
    a.len() > 1 && allowed_pos.len() == a.len()
}

spec fn is_sorted(a: Seq<int>) -> bool
    decreases a.len()
{
    if a.len() <= 1 {
        true
    } else {
        a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))
    }
}

spec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {
    original.len() == target.len() && target.len() == allowed.len() &&
    original.to_multiset() == target.to_multiset()
}

spec fn sort_sequence(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_sort_seq(s)
    }
}

spec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_sort_helper(s, s.len() as nat)
    }
}

spec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>
    decreases passes
{
    if passes == 0 {
        s
    } else {
        bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)
    }
}

spec fn bubble_pass(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_pass_helper(s, 0)
    }
}

spec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>
    decreases if pos <= s.len() { s.len() - pos } else { 0 }
{
    if pos >= s.len() || pos >= s.len() - 1 {
        s
    } else if s[pos as int] > s[(pos + 1) as int] {
        bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)
    } else {
        bubble_pass_helper(s, pos + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn can_sort(a: &mut Vec<i8>, allowed_pos: &[bool]) -> (result: bool)
    requires 
        valid_input(old(a)@.map_values(|x: i8| x as int), allowed_pos@),
    ensures 
        a@.map_values(|x: i8| x as int).to_multiset() == old(a)@.map_values(|x: i8| x as int).to_multiset(),
        result == is_sorted(a@.map_values(|x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    false
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {\n    a.len() > 1 && allowed_pos.len() == a.len()\n}\n\nspec fn is_sorted(a: Seq<int>) -> bool\n    decreases a.len()\n{\n    if a.len() <= 1 {\n        true\n    } else {\n        a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))\n    }\n}\n\nspec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {\n    original.len() == target.len() && target.len() == allowed.len() &&\n    original.to_multiset() == target.to_multiset()\n}\n\nspec fn sort_sequence(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_seq(s)\n    }\n}\n\nspec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_sort_helper(s, s.len() as nat)\n    }\n}\n\nspec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>\n    decreases passes\n{\n    if passes == 0 {\n        s\n    } else {\n        bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)\n    }\n}\n\nspec fn bubble_pass(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        bubble_pass_helper(s, 0)\n    }\n}\n\nspec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>\n    decreases if pos <= s.len() { s.len() - pos } else { 0 }\n{\n    if pos >= s.len() || pos >= s.len() - 1 {\n        s\n    } else if s[pos as int] > s[(pos + 1) as int] {\n        bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)\n    } else {\n        bubble_pass_helper(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn can_sort(a: &mut Vec<i8>, allowed_pos: &[bool]) -> (result: bool)\n    requires \n        valid_input(old(a)@.map_values(|x: i8| x as int), allowed_pos@),\n    ensures \n        a@.map_values(|x: i8| x as int).to_multiset() == old(a)@.map_values(|x: i8| x as int).to_multiset(),\n        result == is_sorted(a@.map_values(|x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4404.rs,54,54,1.0,123.115,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {
    s.len() >= 10 && 
    s[4] == '/' && s[7] == '/' &&
    string_to_int(s.subrange(0, 4)) == y &&
    string_to_int(s.subrange(5, 7)) == m &&
    string_to_int(s.subrange(8, 10)) == d
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s.len() == 1 { char_to_digit(s[0]) }
    else if s.len() == 2 { char_to_digit(s[0]) * 10 + char_to_digit(s[1]) }
    else if s.len() == 4 { char_to_digit(s[0]) * 1000 + char_to_digit(s[1]) * 100 + char_to_digit(s[2]) * 10 + char_to_digit(s[3]) }
    else { 0 }
}

spec fn char_to_digit(c: char) -> int {
    if '0' <= c && c <= '9' { (c as int) - ('0' as int) } else { 0 }
}

spec fn valid_input(s: Seq<char>) -> bool {
    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31
}

spec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {
    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && 
    ((m < 4 || (m == 4 && d <= 30)) ==> result == seq!['H', 'e', 'i', 's', 'e', 'i']) && 
    ((m > 4 || (m == 4 && d > 30)) ==> result == seq!['T', 'B', 'D'])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires valid_input(stdin_input@)
    ensures correct_output(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {
    s.len() >= 10 && 
    s[4] == '/' && s[7] == '/' &&
    string_to_int(s.subrange(0, 4)) == y &&
    string_to_int(s.subrange(5, 7)) == m &&
    string_to_int(s.subrange(8, 10)) == d
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s.len() == 1 { char_to_digit(s[0]) }
    else if s.len() == 2 { char_to_digit(s[0]) * 10 + char_to_digit(s[1]) }
    else if s.len() == 4 { char_to_digit(s[0]) * 1000 + char_to_digit(s[1]) * 100 + char_to_digit(s[2]) * 10 + char_to_digit(s[3]) }
    else { 0 }
}

spec fn char_to_digit(c: char) -> int {
    if '0' <= c && c <= '9' { (c as int) - ('0' as int) } else { 0 }
}

spec fn valid_input(s: Seq<char>) -> bool {
    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31
}

spec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {
    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && 
    ((m < 4 || (m == 4 && d <= 30)) ==> result == seq!['H', 'e', 'i', 's', 'e', 'i']) && 
    ((m > 4 || (m == 4 && d > 30)) ==> result == seq!['T', 'B', 'D'])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires valid_input(stdin_input@)
    ensures correct_output(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {\n    s.len() >= 10 && \n    s[4] == '/' && s[7] == '/' &&\n    string_to_int(s.subrange(0, 4)) == y &&\n    string_to_int(s.subrange(5, 7)) == m &&\n    string_to_int(s.subrange(8, 10)) == d\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 { char_to_digit(s[0]) }\n    else if s.len() == 2 { char_to_digit(s[0]) * 10 + char_to_digit(s[1]) }\n    else if s.len() == 4 { char_to_digit(s[0]) * 1000 + char_to_digit(s[1]) * 100 + char_to_digit(s[2]) * 10 + char_to_digit(s[3]) }\n    else { 0 }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    if '0' <= c && c <= '9' { (c as int) - ('0' as int) } else { 0 }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31\n}\n\nspec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {\n    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && \n    ((m < 4 || (m == 4 && d <= 30)) ==> result == seq!['H', 'e', 'i', 's', 'e', 'i']) && \n    ((m > 4 || (m == 4 && d > 30)) ==> result == seq!['T', 'B', 'D'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures correct_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_442.rs,52,52,1.0,122.987,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn h(x: int, y: int) -> int {
    x * x + 2 * x * y + x + 1
}

spec fn valid_input(r: int) -> bool {
    r > 0
}

spec fn valid_solution(result: Seq<int>, r: int) -> bool {
    if result.len() == 0 {
        true
    } else {
        result.len() == 2 && result[0] > 0 && result[1] > 0 && h(result[0], result[1]) == r
    }
}

spec fn has_solution(r: int) -> bool {
    r > 4 && r % 2 == 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(r: i8) -> (result: Vec<i8>)
    requires 
        valid_input(r as int)
    ensures 
        valid_solution(result@.map(|i: int, x: i8| x as int), r as int),
        result@.len() == 0 || result@.len() == 2,
        result@.len() == 2 ==> result@[0] as int > 0 && result@[1] as int > 0,
        result@.len() == 2 ==> h(result@[0] as int, result@[1] as int) == r as int,
        r as int <= 4 ==> result@.len() == 0,
        r as int > 4 && (r as int) % 2 == 0 ==> result@.len() == 0,
        r as int > 4 && (r as int) % 2 == 1 ==> result@.len() == 2 && result@[0] as int == 1 && result@[1] as int == ((r as int) - 3) / 2,
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn h(x: int, y: int) -> int {
    x * x + 2 * x * y + x + 1
}

spec fn valid_input(r: int) -> bool {
    r > 0
}

spec fn valid_solution(result: Seq<int>, r: int) -> bool {
    if result.len() == 0 {
        true
    } else {
        result.len() == 2 && result[0] > 0 && result[1] > 0 && h(result[0], result[1]) == r
    }
}

spec fn has_solution(r: int) -> bool {
    r > 4 && r % 2 == 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(r: i8) -> (result: Vec<i8>)
    requires 
        valid_input(r as int)
    ensures 
        valid_solution(result@.map(|i: int, x: i8| x as int), r as int),
        result@.len() == 0 || result@.len() == 2,
        result@.len() == 2 ==> result@[0] as int > 0 && result@[1] as int > 0,
        result@.len() == 2 ==> h(result@[0] as int, result@[1] as int) == r as int,
        r as int <= 4 ==> result@.len() == 0,
        r as int > 4 && (r as int) % 2 == 0 ==> result@.len() == 0,
        r as int > 4 && (r as int) % 2 == 1 ==> result@.len() == 2 && result@[0] as int == 1 && result@[1] as int == ((r as int) - 3) / 2,
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn h(x: int, y: int) -> int {\n    x * x + 2 * x * y + x + 1\n}\n\nspec fn valid_input(r: int) -> bool {\n    r > 0\n}\n\nspec fn valid_solution(result: Seq<int>, r: int) -> bool {\n    if result.len() == 0 {\n        true\n    } else {\n        result.len() == 2 && result[0] > 0 && result[1] > 0 && h(result[0], result[1]) == r\n    }\n}\n\nspec fn has_solution(r: int) -> bool {\n    r > 4 && r % 2 == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(r: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(r as int)\n    ensures \n        valid_solution(result@.map(|i: int, x: i8| x as int), r as int),\n        result@.len() == 0 || result@.len() == 2,\n        result@.len() == 2 ==> result@[0] as int > 0 && result@[1] as int > 0,\n        result@.len() == 2 ==> h(result@[0] as int, result@[1] as int) == r as int,\n        r as int <= 4 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 0 ==> result@.len() == 0,\n        r as int > 4 && (r as int) % 2 == 1 ==> result@.len() == 2 && result@[0] as int == 1 && result@[1] as int == ((r as int) - 3) / 2,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4427.rs,78,78,1.0,123.482,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool
    recommends input.len() > 0
{
    let tokens = parse_input_pure(input);
    tokens.len() == 3 && 
    2 <= tokens[0] <= 5 &&
    1 <= tokens[1] <= 100 &&
    tokens[1] < tokens[2] && tokens[2] <= 200
}

spec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int
    recommends n >= 1
    decreases n when n >= 1
{
    if n == 1 { r * x0 - d }
    else if n >= 2 { r * calculate_recurrence(r, d, x0, n - 1) - d }
    else { 0 }
}

spec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {
    generate_output_up_to_iteration(r, d, x0, 10)
}

spec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>
    recommends iterations >= 0
    decreases iterations when iterations >= 0
{
    if iterations == 0 { 
        Seq::empty() 
    } else if iterations >= 1 { 
        let current_value = calculate_recurrence(r, d, x0, iterations);
        let previous_output = generate_output_up_to_iteration(r, d, x0, iterations - 1);
        previous_output + int_to_string(current_value) + seq!['\n']
    } else {
        Seq::empty()
    }
}

spec fn parse_input_pure(input: Seq<char>) -> Seq<int> {
    seq![1, 1, 100]  /* placeholder */
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']  /* placeholder */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures 
        result@ == generate_expected_output(
            parse_input_pure(input@)[0], 
            parse_input_pure(input@)[1], 
            parse_input_pure(input@)[2]
        )
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool
    recommends input.len() > 0
{
    let tokens = parse_input_pure(input);
    tokens.len() == 3 && 
    2 <= tokens[0] <= 5 &&
    1 <= tokens[1] <= 100 &&
    tokens[1] < tokens[2] && tokens[2] <= 200
}

spec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int
    recommends n >= 1
    decreases n when n >= 1
{
    if n == 1 { r * x0 - d }
    else if n >= 2 { r * calculate_recurrence(r, d, x0, n - 1) - d }
    else { 0 }
}

spec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {
    generate_output_up_to_iteration(r, d, x0, 10)
}

spec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>
    recommends iterations >= 0
    decreases iterations when iterations >= 0
{
    if iterations == 0 { 
        Seq::empty() 
    } else if iterations >= 1 { 
        let current_value = calculate_recurrence(r, d, x0, iterations);
        let previous_output = generate_output_up_to_iteration(r, d, x0, iterations - 1);
        previous_output + int_to_string(current_value) + seq!['\n']
    } else {
        Seq::empty()
    }
}

spec fn parse_input_pure(input: Seq<char>) -> Seq<int> {
    seq![1, 1, 100]  /* placeholder */
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']  /* placeholder */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures 
        result@ == generate_expected_output(
            parse_input_pure(input@)[0], 
            parse_input_pure(input@)[1], 
            parse_input_pure(input@)[2]
        )
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    let tokens = parse_input_pure(input);\n    tokens.len() == 3 && \n    2 <= tokens[0] <= 5 &&\n    1 <= tokens[1] <= 100 &&\n    tokens[1] < tokens[2] && tokens[2] <= 200\n}\n\nspec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int\n    recommends n >= 1\n    decreases n when n >= 1\n{\n    if n == 1 { r * x0 - d }\n    else if n >= 2 { r * calculate_recurrence(r, d, x0, n - 1) - d }\n    else { 0 }\n}\n\nspec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {\n    generate_output_up_to_iteration(r, d, x0, 10)\n}\n\nspec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>\n    recommends iterations >= 0\n    decreases iterations when iterations >= 0\n{\n    if iterations == 0 { \n        Seq::empty() \n    } else if iterations >= 1 { \n        let current_value = calculate_recurrence(r, d, x0, iterations);\n        let previous_output = generate_output_up_to_iteration(r, d, x0, iterations - 1);\n        previous_output + int_to_string(current_value) + seq!['\\n']\n    } else {\n        Seq::empty()\n    }\n}\n\nspec fn parse_input_pure(input: Seq<char>) -> Seq<int> {\n    seq![1, 1, 100]  /* placeholder */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']  /* placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@ == generate_expected_output(\n            parse_input_pure(input@)[0], \n            parse_input_pure(input@)[1], \n            parse_input_pure(input@)[2]\n        )\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_443.rs,58,58,1.0,154.078,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, packets: Seq<int>) -> bool {
    n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1
}

spec fn is_possible(n: int, packets: Seq<int>) -> bool
    recommends valid_input(n, packets)
{
    n >= 2 && (n > 2 || packets[0] != packets[1])
}

spec fn sum_packets(packets: Seq<int>) -> int
    decreases packets.len()
{
    if packets.len() == 0 {
        0
    } else {
        packets[0] + sum_packets(packets.subrange(1, packets.len() as int))
    }
}

spec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool
    recommends valid_input(n, packets)
{
    if !is_possible(n, packets) {
        result.len() == 0
    } else {
        result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&
        exists|min_index: int| 0 <= min_index < packets.len() && 
        result[1] == min_index + 1 &&
        (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&
        (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, packets: Vec<i8>) -> (result: Vec<i8>)
    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))
    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, packets: Seq<int>) -> bool {
    n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1
}

spec fn is_possible(n: int, packets: Seq<int>) -> bool
    recommends valid_input(n, packets)
{
    n >= 2 && (n > 2 || packets[0] != packets[1])
}

spec fn sum_packets(packets: Seq<int>) -> int
    decreases packets.len()
{
    if packets.len() == 0 {
        0
    } else {
        packets[0] + sum_packets(packets.subrange(1, packets.len() as int))
    }
}

spec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool
    recommends valid_input(n, packets)
{
    if !is_possible(n, packets) {
        result.len() == 0
    } else {
        result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&
        exists|min_index: int| 0 <= min_index < packets.len() && 
        result[1] == min_index + 1 &&
        (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&
        (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, packets: Vec<i8>) -> (result: Vec<i8>)
    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))
    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, packets: Seq<int>) -> bool {\n    n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1\n}\n\nspec fn is_possible(n: int, packets: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    n >= 2 && (n > 2 || packets[0] != packets[1])\n}\n\nspec fn sum_packets(packets: Seq<int>) -> int\n    decreases packets.len()\n{\n    if packets.len() == 0 {\n        0\n    } else {\n        packets[0] + sum_packets(packets.subrange(1, packets.len() as int))\n    }\n}\n\nspec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool\n    recommends valid_input(n, packets)\n{\n    if !is_possible(n, packets) {\n        result.len() == 0\n    } else {\n        result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&\n        exists|min_index: int| 0 <= min_index < packets.len() && \n        result[1] == min_index + 1 &&\n        (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&\n        (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, packets: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))\n    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4430.rs,66,66,1.0,123.473,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int
    recommends
        boxes >= 1,
        capacity >= 1,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,
{
    greedy_pack_from_end_helper(a, a.len() - 1, boxes, capacity, capacity)
}

spec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int
    recommends
        capacity >= 1,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,
        boxes_left >= 1,
        0 <= current_box_space <= capacity,
    decreases pos + 1,
{
    if pos < 0 {
        0int
    } else if pos >= a.len() {
        0int
    } else if a[pos] > capacity {
        0int
    } else if a[pos] <= current_box_space {
        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])
    } else if boxes_left > 1 {
        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])
    } else {
        0int
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires
        n >= 0,
        m >= 1,
        k >= 1,
        a.len() == n as usize,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] as int >= 1 && #[trigger] a[i] as int <= k as int,
    ensures
        0 <= result as int <= n as int,
        result as int == greedy_pack_from_end(a@.map(|i, x| x as int), m as int, k as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int
    recommends
        boxes >= 1,
        capacity >= 1,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,
{
    greedy_pack_from_end_helper(a, a.len() - 1, boxes, capacity, capacity)
}

spec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int
    recommends
        capacity >= 1,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,
        boxes_left >= 1,
        0 <= current_box_space <= capacity,
    decreases pos + 1,
{
    if pos < 0 {
        0int
    } else if pos >= a.len() {
        0int
    } else if a[pos] > capacity {
        0int
    } else if a[pos] <= current_box_space {
        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])
    } else if boxes_left > 1 {
        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])
    } else {
        0int
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires
        n >= 0,
        m >= 1,
        k >= 1,
        a.len() == n as usize,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] as int >= 1 && #[trigger] a[i] as int <= k as int,
    ensures
        0 <= result as int <= n as int,
        result as int == greedy_pack_from_end(a@.map(|i, x| x as int), m as int, k as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int\n    recommends\n        boxes >= 1,\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n{\n    greedy_pack_from_end_helper(a, a.len() - 1, boxes, capacity, capacity)\n}\n\nspec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int\n    recommends\n        capacity >= 1,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,\n        boxes_left >= 1,\n        0 <= current_box_space <= capacity,\n    decreases pos + 1,\n{\n    if pos < 0 {\n        0int\n    } else if pos >= a.len() {\n        0int\n    } else if a[pos] > capacity {\n        0int\n    } else if a[pos] <= current_box_space {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])\n    } else if boxes_left > 1 {\n        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])\n    } else {\n        0int\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires\n        n >= 0,\n        m >= 1,\n        k >= 1,\n        a.len() == n as usize,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] as int >= 1 && #[trigger] a[i] as int <= k as int,\n    ensures\n        0 <= result as int <= n as int,\n        result as int == greedy_pack_from_end(a@.map(|i, x| x as int), m as int, k as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4431.rs,82,82,1.0,123.92,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {
    n == s.len() &&
    k == available.len() &&
    forall|i: int, j: int| 0 <= i < j < available.len() ==> available[i] != available[j]
}

spec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else {
        let segments = get_maximal_valid_segments(s, available_set, 0);
        sum_segment_counts(segments)
    }
}

spec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() { Seq::empty() }
    else {
        let segment_length = get_next_segment_length(s, available_set, start_idx);
        if segment_length == 0 {
            get_maximal_valid_segments(s, available_set, start_idx + 1)
        } else {
            let skip_length = skip_invalid_chars(s, available_set, start_idx + segment_length);
            let next_idx = start_idx + segment_length + skip_length;
            if next_idx <= s.len() {
                seq![segment_length].add(get_maximal_valid_segments(s, available_set, next_idx))
            } else {
                seq![segment_length]
            }
        }
    }
}

spec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() || !available_set.contains(s[start_idx as int]) { 0 }
    else { 1 + get_next_segment_length(s, available_set, start_idx + 1) }
}

spec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() || available_set.contains(s[start_idx as int]) { 0 }
    else { 1 + skip_invalid_chars(s, available_set, start_idx + 1) }
}

spec fn sum_segment_counts(segments: Seq<nat>) -> nat
    decreases segments.len()
{
    if segments.len() == 0 { 0 }
    else { segments[0] * (segments[0] + 1) / 2 + sum_segment_counts(segments.subrange(1, segments.len() as int)) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, k: u8, s: Vec<char>, available: Vec<char>) -> (result: u8)
    requires valid_input(n as nat, k as nat, s@, available@)
    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {
    n == s.len() &&
    k == available.len() &&
    forall|i: int, j: int| 0 <= i < j < available.len() ==> available[i] != available[j]
}

spec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else {
        let segments = get_maximal_valid_segments(s, available_set, 0);
        sum_segment_counts(segments)
    }
}

spec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() { Seq::empty() }
    else {
        let segment_length = get_next_segment_length(s, available_set, start_idx);
        if segment_length == 0 {
            get_maximal_valid_segments(s, available_set, start_idx + 1)
        } else {
            let skip_length = skip_invalid_chars(s, available_set, start_idx + segment_length);
            let next_idx = start_idx + segment_length + skip_length;
            if next_idx <= s.len() {
                seq![segment_length].add(get_maximal_valid_segments(s, available_set, next_idx))
            } else {
                seq![segment_length]
            }
        }
    }
}

spec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() || !available_set.contains(s[start_idx as int]) { 0 }
    else { 1 + get_next_segment_length(s, available_set, start_idx + 1) }
}

spec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() || available_set.contains(s[start_idx as int]) { 0 }
    else { 1 + skip_invalid_chars(s, available_set, start_idx + 1) }
}

spec fn sum_segment_counts(segments: Seq<nat>) -> nat
    decreases segments.len()
{
    if segments.len() == 0 { 0 }
    else { segments[0] * (segments[0] + 1) / 2 + sum_segment_counts(segments.subrange(1, segments.len() as int)) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, k: u8, s: Vec<char>, available: Vec<char>) -> (result: u8)
    requires valid_input(n as nat, k as nat, s@, available@)
    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {\n    n == s.len() &&\n    k == available.len() &&\n    forall|i: int, j: int| 0 <= i < j < available.len() ==> available[i] != available[j]\n}\n\nspec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else {\n        let segments = get_maximal_valid_segments(s, available_set, 0);\n        sum_segment_counts(segments)\n    }\n}\n\nspec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() { Seq::empty() }\n    else {\n        let segment_length = get_next_segment_length(s, available_set, start_idx);\n        if segment_length == 0 {\n            get_maximal_valid_segments(s, available_set, start_idx + 1)\n        } else {\n            let skip_length = skip_invalid_chars(s, available_set, start_idx + segment_length);\n            let next_idx = start_idx + segment_length + skip_length;\n            if next_idx <= s.len() {\n                seq![segment_length].add(get_maximal_valid_segments(s, available_set, next_idx))\n            } else {\n                seq![segment_length]\n            }\n        }\n    }\n}\n\nspec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || !available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + get_next_segment_length(s, available_set, start_idx + 1) }\n}\n\nspec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat\n    decreases s.len() - start_idx when start_idx <= s.len()\n{\n    if start_idx >= s.len() || available_set.contains(s[start_idx as int]) { 0 }\n    else { 1 + skip_invalid_chars(s, available_set, start_idx + 1) }\n}\n\nspec fn sum_segment_counts(segments: Seq<nat>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { 0 }\n    else { segments[0] * (segments[0] + 1) / 2 + sum_segment_counts(segments.subrange(1, segments.len() as int)) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8, k: u8, s: Vec<char>, available: Vec<char>) -> (result: u8)\n    requires valid_input(n as nat, k as nat, s@, available@)\n    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4441.rs,102,102,1.0,122.89,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {
    let lines = split_lines_func(stdin_input);
    if lines.len() >= 1 {
        let n = string_to_int(lines[0]);
        if n == 1 {
            seq!['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\n']
        } else if n != 1 && lines.len() >= 3 {
            let a = string_to_int(lines[1]);
            let b = string_to_int(lines[2]);
            int_to_string(a + b) + seq!['\n']
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_func_helper(s, 0, seq![], seq![])
}

spec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i >= s.len() {
        if current.len() == 0 { acc } else { acc.push(current) }
    } else if s[i] == '\n' {
        split_lines_func_helper(s, i + 1, seq![], acc.push(current))
    } else {
        split_lines_func_helper(s, i + 1, current.push(s[i]), acc)
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        -string_to_int_helper(s.subrange(1, s.len() as int))
    } else {
        string_to_int_helper(s)
    }
}

spec fn string_to_int_helper(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'] + int_to_string_helper(-n)
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n when n >= 0
{
    if n <= 0 {
        seq![]
    } else {
        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures result@ == expected_output(stdin_input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {
    let lines = split_lines_func(stdin_input);
    if lines.len() >= 1 {
        let n = string_to_int(lines[0]);
        if n == 1 {
            seq!['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\n']
        } else if n != 1 && lines.len() >= 3 {
            let a = string_to_int(lines[1]);
            let b = string_to_int(lines[2]);
            int_to_string(a + b) + seq!['\n']
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_func_helper(s, 0, seq![], seq![])
}

spec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i >= s.len() {
        if current.len() == 0 { acc } else { acc.push(current) }
    } else if s[i] == '\n' {
        split_lines_func_helper(s, i + 1, seq![], acc.push(current))
    } else {
        split_lines_func_helper(s, i + 1, current.push(s[i]), acc)
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        -string_to_int_helper(s.subrange(1, s.len() as int))
    } else {
        string_to_int_helper(s)
    }
}

spec fn string_to_int_helper(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'] + int_to_string_helper(-n)
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n when n >= 0
{
    if n <= 0 {
        seq![]
    } else {
        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures result@ == expected_output(stdin_input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {\n    let lines = split_lines_func(stdin_input);\n    if lines.len() >= 1 {\n        let n = string_to_int(lines[0]);\n        if n == 1 {\n            seq!['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\n']\n        } else if n != 1 && lines.len() >= 3 {\n            let a = string_to_int(lines[1]);\n            let b = string_to_int(lines[2]);\n            int_to_string(a + b) + seq!['\\n']\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_func_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i >= s.len() {\n        if current.len() == 0 { acc } else { acc.push(current) }\n    } else if s[i] == '\\n' {\n        split_lines_func_helper(s, i + 1, seq![], acc.push(current))\n    } else {\n        split_lines_func_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' {\n        -string_to_int_helper(s.subrange(1, s.len() as int))\n    } else {\n        string_to_int_helper(s)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        seq![]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@ == expected_output(stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4444.rs,67,67,1.0,184.735,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 2 &&
    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ') &&
    (forall|i: int| 0 <= i < input.len() ==> (#[trigger] input[i] == ' ' || input[i] == '\n' || ('a' <= input[i] <= 'z'))) &&
    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ' && 
     (forall|j: int| 0 <= j < i ==> #[trigger] input[j] != ' ' && input[j] != '\n') &&
     (forall|j: int| i+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\n'))
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    output[output.len() as int - 1] == '\n' &&
    (forall|i: int| 0 <= i < output.len() - 1 ==> ('a' <= #[trigger] output[i] <= 'z'))
}

spec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)
    recommends valid_input(input)
{
    let space_pos = choose|space_pos: int| 0 < space_pos < input.len() && input[space_pos] == ' ' &&
                       (forall|j: int| 0 <= j < space_pos ==> #[trigger] input[j] != ' ') &&
                       (forall|j: int| space_pos+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\n');
    let s = input.subrange(0, space_pos);
    let t = if input[input.len() as int - 1] == '\n' { 
        input.subrange(space_pos + 1, input.len() - 1) 
    } else { 
        input.subrange(space_pos + 1, input.len() as int) 
    };
    (s, t)
}

spec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    let (s, t) = extract_strings(input);
    output == t.add(s).push('\n')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires
        valid_input(input@),
    ensures
        valid_output(output@),
        correct_concatenation(input@, output@),
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 2 &&
    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ') &&
    (forall|i: int| 0 <= i < input.len() ==> (#[trigger] input[i] == ' ' || input[i] == '\n' || ('a' <= input[i] <= 'z'))) &&
    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ' && 
     (forall|j: int| 0 <= j < i ==> #[trigger] input[j] != ' ' && input[j] != '\n') &&
     (forall|j: int| i+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\n'))
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    output[output.len() as int - 1] == '\n' &&
    (forall|i: int| 0 <= i < output.len() - 1 ==> ('a' <= #[trigger] output[i] <= 'z'))
}

spec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)
    recommends valid_input(input)
{
    let space_pos = choose|space_pos: int| 0 < space_pos < input.len() && input[space_pos] == ' ' &&
                       (forall|j: int| 0 <= j < space_pos ==> #[trigger] input[j] != ' ') &&
                       (forall|j: int| space_pos+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\n');
    let s = input.subrange(0, space_pos);
    let t = if input[input.len() as int - 1] == '\n' { 
        input.subrange(space_pos + 1, input.len() - 1) 
    } else { 
        input.subrange(space_pos + 1, input.len() as int) 
    };
    (s, t)
}

spec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    let (s, t) = extract_strings(input);
    output == t.add(s).push('\n')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires
        valid_input(input@),
    ensures
        valid_output(output@),
        correct_concatenation(input@, output@),
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 2 &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ') &&\n    (forall|i: int| 0 <= i < input.len() ==> (#[trigger] input[i] == ' ' || input[i] == '\\n' || ('a' <= input[i] <= 'z'))) &&\n    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ' && \n     (forall|j: int| 0 <= j < i ==> #[trigger] input[j] != ' ' && input[j] != '\\n') &&\n     (forall|j: int| i+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n'))\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    output[output.len() as int - 1] == '\\n' &&\n    (forall|i: int| 0 <= i < output.len() - 1 ==> ('a' <= #[trigger] output[i] <= 'z'))\n}\n\nspec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)\n    recommends valid_input(input)\n{\n    let space_pos = choose|space_pos: int| 0 < space_pos < input.len() && input[space_pos] == ' ' &&\n                       (forall|j: int| 0 <= j < space_pos ==> #[trigger] input[j] != ' ') &&\n                       (forall|j: int| space_pos+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\\n');\n    let s = input.subrange(0, space_pos);\n    let t = if input[input.len() as int - 1] == '\\n' { \n        input.subrange(space_pos + 1, input.len() - 1) \n    } else { \n        input.subrange(space_pos + 1, input.len() as int) \n    };\n    (s, t)\n}\n\nspec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let (s, t) = extract_strings(input);\n    output == t.add(s).push('\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (output: Vec<char>)\n    requires\n        valid_input(input@),\n    ensures\n        valid_output(output@),\n        correct_concatenation(input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4446.rs,67,67,1.0,122.821,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {
    n > 0 && a > 0 && b > 0 && k >= 0 && h.len() == n && 
    forall|i: int| 0 <= i < h.len() ==> h[i] > 0
}

spec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>
    decreases h.len()
{
    if h.len() == 0 {
        seq![]
    } else {
        let h_mod = h[0] % (a + b);
        let h_final = if h_mod == 0 { a + b } else { h_mod };
        seq![h_final] + process_health_values(h.drop_first(), a, b)
    }
}

spec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {
    count_killable_helper(sorted_health, a, k, 0, 0)
}

spec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int
    decreases sorted_health.len() - index
{
    if index >= sorted_health.len() {
        acc
    } else {
        let x = sorted_health[index];
        if x <= a {
            count_killable_helper(sorted_health, a, remaining_k, index + 1, acc + 1)
        } else {
            let needed_skips = (x + a - 1) / a - 1;
            if remaining_k >= needed_skips {
                count_killable_helper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)
            } else {
                count_killable_helper(sorted_health, a, remaining_k, index + 1, acc)
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve_core(n: i8, a: i8, b: i8, k: i8, h: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))
    ensures 0 <= result as int <= n as int
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {
    n > 0 && a > 0 && b > 0 && k >= 0 && h.len() == n && 
    forall|i: int| 0 <= i < h.len() ==> h[i] > 0
}

spec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>
    decreases h.len()
{
    if h.len() == 0 {
        seq![]
    } else {
        let h_mod = h[0] % (a + b);
        let h_final = if h_mod == 0 { a + b } else { h_mod };
        seq![h_final] + process_health_values(h.drop_first(), a, b)
    }
}

spec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {
    count_killable_helper(sorted_health, a, k, 0, 0)
}

spec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int
    decreases sorted_health.len() - index
{
    if index >= sorted_health.len() {
        acc
    } else {
        let x = sorted_health[index];
        if x <= a {
            count_killable_helper(sorted_health, a, remaining_k, index + 1, acc + 1)
        } else {
            let needed_skips = (x + a - 1) / a - 1;
            if remaining_k >= needed_skips {
                count_killable_helper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)
            } else {
                count_killable_helper(sorted_health, a, remaining_k, index + 1, acc)
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve_core(n: i8, a: i8, b: i8, k: i8, h: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))
    ensures 0 <= result as int <= n as int
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {\n    n > 0 && a > 0 && b > 0 && k >= 0 && h.len() == n && \n    forall|i: int| 0 <= i < h.len() ==> h[i] > 0\n}\n\nspec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>\n    decreases h.len()\n{\n    if h.len() == 0 {\n        seq![]\n    } else {\n        let h_mod = h[0] % (a + b);\n        let h_final = if h_mod == 0 { a + b } else { h_mod };\n        seq![h_final] + process_health_values(h.drop_first(), a, b)\n    }\n}\n\nspec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {\n    count_killable_helper(sorted_health, a, k, 0, 0)\n}\n\nspec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int\n    decreases sorted_health.len() - index\n{\n    if index >= sorted_health.len() {\n        acc\n    } else {\n        let x = sorted_health[index];\n        if x <= a {\n            count_killable_helper(sorted_health, a, remaining_k, index + 1, acc + 1)\n        } else {\n            let needed_skips = (x + a - 1) / a - 1;\n            if remaining_k >= needed_skips {\n                count_killable_helper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)\n            } else {\n                count_killable_helper(sorted_health, a, remaining_k, index + 1, acc)\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve_core(n: i8, a: i8, b: i8, k: i8, h: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))\n    ensures 0 <= result as int <= n as int\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4469.rs,82,82,1.0,185.219,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(queries: Seq<(char, int)>) -> bool {
    &&& queries.len() > 0
    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].0 == 'L' || queries[i].0 == 'R' || queries[i].0 == '?')
    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].1 > 0)
    &&& (forall|i: int, j: int| 0 <= i < j < queries.len() && (queries[i].0 == 'L' || queries[i].0 == 'R') && (queries[j].0 == 'L' || queries[j].0 == 'R') ==> queries[i].1 != queries[j].1)
    &&& (forall|i: int| 0 <= i < queries.len() && queries[i].0 == '?' ==> 
        exists|j: int| 0 <= j < i && (queries[j].0 == 'L' || queries[j].0 == 'R') && queries[j].1 == queries[i].1)
    &&& (exists|i: int| 0 <= i < queries.len() && queries[i].0 == '?')
}

spec fn count_query_ops(queries: Seq<(char, int)>) -> int
    decreases queries.len()
{
    if queries.len() == 0 {
        0
    } else {
        let head = queries[0];
        let tail = queries.subrange(1, queries.len() as int);
        if head.0 == '?' {
            1 + count_query_ops(tail)
        } else {
            count_query_ops(tail)
        }
    }
}

spec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {
    &&& results.len() == count_query_ops(queries)
    &&& (forall|i: int| 0 <= i < results.len() ==> results[i] >= 0)
    &&& (forall|r_idx: int| #[trigger] results[r_idx] == compute_min_removals(queries, r_idx) ==> 0 <= r_idx < results.len() ==> 
        (exists|q_idx: int| 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' &&
         results[r_idx] == compute_min_removals(queries, q_idx)))
    &&& (forall|q_idx: int| #[trigger] queries[q_idx] == queries[q_idx] ==> 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' ==>
        (exists|r_idx: int| 0 <= r_idx < results.len() &&
         results[r_idx] == compute_min_removals(queries, q_idx)))
}

struct BookshelfState {
    positions: Map<int, int>,
    head: int,
    tail: int,
}

spec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {
    BookshelfState {
        positions: Map::empty(),
        head: 0,
        tail: 0,
    }
}

spec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<(char, i8)>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))
    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(queries: Seq<(char, int)>) -> bool {
    &&& queries.len() > 0
    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].0 == 'L' || queries[i].0 == 'R' || queries[i].0 == '?')
    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].1 > 0)
    &&& (forall|i: int, j: int| 0 <= i < j < queries.len() && (queries[i].0 == 'L' || queries[i].0 == 'R') && (queries[j].0 == 'L' || queries[j].0 == 'R') ==> queries[i].1 != queries[j].1)
    &&& (forall|i: int| 0 <= i < queries.len() && queries[i].0 == '?' ==> 
        exists|j: int| 0 <= j < i && (queries[j].0 == 'L' || queries[j].0 == 'R') && queries[j].1 == queries[i].1)
    &&& (exists|i: int| 0 <= i < queries.len() && queries[i].0 == '?')
}

spec fn count_query_ops(queries: Seq<(char, int)>) -> int
    decreases queries.len()
{
    if queries.len() == 0 {
        0
    } else {
        let head = queries[0];
        let tail = queries.subrange(1, queries.len() as int);
        if head.0 == '?' {
            1 + count_query_ops(tail)
        } else {
            count_query_ops(tail)
        }
    }
}

spec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {
    &&& results.len() == count_query_ops(queries)
    &&& (forall|i: int| 0 <= i < results.len() ==> results[i] >= 0)
    &&& (forall|r_idx: int| #[trigger] results[r_idx] == compute_min_removals(queries, r_idx) ==> 0 <= r_idx < results.len() ==> 
        (exists|q_idx: int| 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' &&
         results[r_idx] == compute_min_removals(queries, q_idx)))
    &&& (forall|q_idx: int| #[trigger] queries[q_idx] == queries[q_idx] ==> 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' ==>
        (exists|r_idx: int| 0 <= r_idx < results.len() &&
         results[r_idx] == compute_min_removals(queries, q_idx)))
}

struct BookshelfState {
    positions: Map<int, int>,
    head: int,
    tail: int,
}

spec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {
    BookshelfState {
        positions: Map::empty(),
        head: 0,
        tail: 0,
    }
}

spec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(queries: Vec<(char, i8)>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))
    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(queries: Seq<(char, int)>) -> bool {\n    &&& queries.len() > 0\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].0 == 'L' || queries[i].0 == 'R' || queries[i].0 == '?')\n    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].1 > 0)\n    &&& (forall|i: int, j: int| 0 <= i < j < queries.len() && (queries[i].0 == 'L' || queries[i].0 == 'R') && (queries[j].0 == 'L' || queries[j].0 == 'R') ==> queries[i].1 != queries[j].1)\n    &&& (forall|i: int| 0 <= i < queries.len() && queries[i].0 == '?' ==> \n        exists|j: int| 0 <= j < i && (queries[j].0 == 'L' || queries[j].0 == 'R') && queries[j].1 == queries[i].1)\n    &&& (exists|i: int| 0 <= i < queries.len() && queries[i].0 == '?')\n}\n\nspec fn count_query_ops(queries: Seq<(char, int)>) -> int\n    decreases queries.len()\n{\n    if queries.len() == 0 {\n        0\n    } else {\n        let head = queries[0];\n        let tail = queries.subrange(1, queries.len() as int);\n        if head.0 == '?' {\n            1 + count_query_ops(tail)\n        } else {\n            count_query_ops(tail)\n        }\n    }\n}\n\nspec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {\n    &&& results.len() == count_query_ops(queries)\n    &&& (forall|i: int| 0 <= i < results.len() ==> results[i] >= 0)\n    &&& (forall|r_idx: int| #[trigger] results[r_idx] == compute_min_removals(queries, r_idx) ==> 0 <= r_idx < results.len() ==> \n        (exists|q_idx: int| 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n    &&& (forall|q_idx: int| #[trigger] queries[q_idx] == queries[q_idx] ==> 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' ==>\n        (exists|r_idx: int| 0 <= r_idx < results.len() &&\n         results[r_idx] == compute_min_removals(queries, q_idx)))\n}\n\nstruct BookshelfState {\n    positions: Map<int, int>,\n    head: int,\n    tail: int,\n}\n\nspec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {\n    BookshelfState {\n        positions: Map::empty(),\n        head: 0,\n        tail: 0,\n    }\n}\n\nspec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(queries: Vec<(char, i8)>) -> (results: Vec<i8>)\n    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))\n    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {\n      }\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4470.rs,80,80,1.0,122.736,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat) -> bool {
    n > 0
}

spec fn can_reach_one(n: nat) -> bool
    recommends n > 0
{
    only_factors_235(n)
}

spec fn only_factors_235(n: nat) -> bool
    recommends n > 0
{
    reduce_by_factors_235(n) == 1
}

spec fn reduce_by_factors_235(n: nat) -> nat
    recommends n > 0
    decreases n
    when n > 0
{
    if n == 1 {
        1
    } else if n % 2 == 0 {
        reduce_by_factors_235(n / 2)
    } else if n % 3 == 0 {
        reduce_by_factors_235(n / 3)
    } else if n % 5 == 0 {
        reduce_by_factors_235(n / 5)
    } else {
        n
    }
}

spec fn min_moves_to_one(n: nat) -> nat
    recommends n > 0 && can_reach_one(n)
    decreases n
    when n > 0
{
    if n == 1 {
        0
    } else if n % 2 == 0 {
        1 + min_moves_to_one(n / 2)
    } else if n % 3 == 0 {
        2 + min_moves_to_one(n / 3)
    } else if n % 5 == 0 {
        3 + min_moves_to_one(n / 5)
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8) -> (result: i8)
    requires
        valid_input(n as nat),
    ensures
        result >= -1,
        result == -1 <==> !can_reach_one(n as nat),
        result >= 0 ==> can_reach_one(n as nat) && result == min_moves_to_one(n as nat) as i8,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat) -> bool {
    n > 0
}

spec fn can_reach_one(n: nat) -> bool
    recommends n > 0
{
    only_factors_235(n)
}

spec fn only_factors_235(n: nat) -> bool
    recommends n > 0
{
    reduce_by_factors_235(n) == 1
}

spec fn reduce_by_factors_235(n: nat) -> nat
    recommends n > 0
    decreases n
    when n > 0
{
    if n == 1 {
        1
    } else if n % 2 == 0 {
        reduce_by_factors_235(n / 2)
    } else if n % 3 == 0 {
        reduce_by_factors_235(n / 3)
    } else if n % 5 == 0 {
        reduce_by_factors_235(n / 5)
    } else {
        n
    }
}

spec fn min_moves_to_one(n: nat) -> nat
    recommends n > 0 && can_reach_one(n)
    decreases n
    when n > 0
{
    if n == 1 {
        0
    } else if n % 2 == 0 {
        1 + min_moves_to_one(n / 2)
    } else if n % 3 == 0 {
        2 + min_moves_to_one(n / 3)
    } else if n % 5 == 0 {
        3 + min_moves_to_one(n / 5)
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8) -> (result: i8)
    requires
        valid_input(n as nat),
    ensures
        result >= -1,
        result == -1 <==> !can_reach_one(n as nat),
        result >= 0 ==> can_reach_one(n as nat) && result == min_moves_to_one(n as nat) as i8,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat) -> bool {\n    n > 0\n}\n\nspec fn can_reach_one(n: nat) -> bool\n    recommends n > 0\n{\n    only_factors_235(n)\n}\n\nspec fn only_factors_235(n: nat) -> bool\n    recommends n > 0\n{\n    reduce_by_factors_235(n) == 1\n}\n\nspec fn reduce_by_factors_235(n: nat) -> nat\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        1\n    } else if n % 2 == 0 {\n        reduce_by_factors_235(n / 2)\n    } else if n % 3 == 0 {\n        reduce_by_factors_235(n / 3)\n    } else if n % 5 == 0 {\n        reduce_by_factors_235(n / 5)\n    } else {\n        n\n    }\n}\n\nspec fn min_moves_to_one(n: nat) -> nat\n    recommends n > 0 && can_reach_one(n)\n    decreases n\n    when n > 0\n{\n    if n == 1 {\n        0\n    } else if n % 2 == 0 {\n        1 + min_moves_to_one(n / 2)\n    } else if n % 3 == 0 {\n        2 + min_moves_to_one(n / 3)\n    } else if n % 5 == 0 {\n        3 + min_moves_to_one(n / 5)\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u8) -> (result: i8)\n    requires\n        valid_input(n as nat),\n    ensures\n        result >= -1,\n        result == -1 <==> !can_reach_one(n as nat),\n        result >= 0 ==> can_reach_one(n as nat) && result == min_moves_to_one(n as nat) as i8,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4477.rs,63,63,1.0,122.75,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_boring_apartment(x: int) -> bool {
    (x >= 1 && x <= 9) ||
    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||
    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||
    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)
}

spec fn digit_count(n: int) -> int {
    if n <= 9 { 1 }
    else if n <= 99 { 2 }
    else if n <= 999 { 3 }
    else { 4 }
}

spec fn boring_apartment_value(digit: int, length: int) -> int {
    if length == 1 { digit }
    else if length == 2 { digit * 11 }
    else if length == 3 { digit * 111 }
    else { digit * 1111 }
}

spec fn total_digits_pressed(x: int) -> int {
    let digit = if x <= 9 { x } 
                 else if x <= 99 { x / 11 }
                 else if x <= 999 { x / 111 }
                 else { x / 1111 };
    let length = digit_count(x);

    let prev_digits = if digit == 1 { 0 } else { (digit - 1) * (1 + 2 + 3 + 4) };

    let current_digits = (length * (length + 1)) / 2;

    prev_digits + current_digits
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x: i32) -> (result: i32)
    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999
    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && 
            (x as int == 1 ==> result as int == 1) &&
            (x as int == 22 ==> result as int == 13) &&
            (x as int == 777 ==> result as int == 66) &&
            (x as int == 9999 ==> result as int == 90)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_boring_apartment(x: int) -> bool {
    (x >= 1 && x <= 9) ||
    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||
    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||
    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)
}

spec fn digit_count(n: int) -> int {
    if n <= 9 { 1 }
    else if n <= 99 { 2 }
    else if n <= 999 { 3 }
    else { 4 }
}

spec fn boring_apartment_value(digit: int, length: int) -> int {
    if length == 1 { digit }
    else if length == 2 { digit * 11 }
    else if length == 3 { digit * 111 }
    else { digit * 1111 }
}

spec fn total_digits_pressed(x: int) -> int {
    let digit = if x <= 9 { x } 
                 else if x <= 99 { x / 11 }
                 else if x <= 999 { x / 111 }
                 else { x / 1111 };
    let length = digit_count(x);

    let prev_digits = if digit == 1 { 0 } else { (digit - 1) * (1 + 2 + 3 + 4) };

    let current_digits = (length * (length + 1)) / 2;

    prev_digits + current_digits
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x: i32) -> (result: i32)
    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999
    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && 
            (x as int == 1 ==> result as int == 1) &&
            (x as int == 22 ==> result as int == 13) &&
            (x as int == 777 ==> result as int == 66) &&
            (x as int == 9999 ==> result as int == 90)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_boring_apartment(x: int) -> bool {\n    (x >= 1 && x <= 9) ||\n    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||\n    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||\n    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)\n}\n\nspec fn digit_count(n: int) -> int {\n    if n <= 9 { 1 }\n    else if n <= 99 { 2 }\n    else if n <= 999 { 3 }\n    else { 4 }\n}\n\nspec fn boring_apartment_value(digit: int, length: int) -> int {\n    if length == 1 { digit }\n    else if length == 2 { digit * 11 }\n    else if length == 3 { digit * 111 }\n    else { digit * 1111 }\n}\n\nspec fn total_digits_pressed(x: int) -> int {\n    let digit = if x <= 9 { x } \n                 else if x <= 99 { x / 11 }\n                 else if x <= 999 { x / 111 }\n                 else { x / 1111 };\n    let length = digit_count(x);\n\n    let prev_digits = if digit == 1 { 0 } else { (digit - 1) * (1 + 2 + 3 + 4) };\n\n    let current_digits = (length * (length + 1)) / 2;\n\n    prev_digits + current_digits\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i32) -> (result: i32)\n    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999\n    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && \n            (x as int == 1 ==> result as int == 1) &&\n            (x as int == 22 ==> result as int == 13) &&\n            (x as int == 777 ==> result as int == 66) &&\n            (x as int == 9999 ==> result as int == 90)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4487.rs,58,58,1.0,122.795,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {
    parts.len() == 3 && parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0
}

spec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {
    a.len() > 0 && b.len() > 0 && c.len() > 0 &&
    a[a.len() - 1] == b[0] && b[b.len() - 1] == c[0]
}

spec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;

spec fn expected_result(input: Seq<char>) -> Seq<char> {
    let stripped = if input.len() > 0 && input[input.len() - 1] == '\n' {
        input.subrange(0, input.len() - 1)
    } else {
        input
    };
    let parts = split_on_spaces(stripped);
    if valid_parsed_input(parts) {
        if is_word_chain(parts[0], parts[1], parts[2]) {
            seq!['Y', 'E', 'S', '\n']
        } else {
            seq!['N', 'O', '\n']
        }
    } else {
        seq![]
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@ == expected_result(input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {
    parts.len() == 3 && parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0
}

spec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {
    a.len() > 0 && b.len() > 0 && c.len() > 0 &&
    a[a.len() - 1] == b[0] && b[b.len() - 1] == c[0]
}

spec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;

spec fn expected_result(input: Seq<char>) -> Seq<char> {
    let stripped = if input.len() > 0 && input[input.len() - 1] == '\n' {
        input.subrange(0, input.len() - 1)
    } else {
        input
    };
    let parts = split_on_spaces(stripped);
    if valid_parsed_input(parts) {
        if is_word_chain(parts[0], parts[1], parts[2]) {
            seq!['Y', 'E', 'S', '\n']
        } else {
            seq!['N', 'O', '\n']
        }
    } else {
        seq![]
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@ == expected_result(input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {\n    parts.len() == 3 && parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0\n}\n\nspec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {\n    a.len() > 0 && b.len() > 0 && c.len() > 0 &&\n    a[a.len() - 1] == b[0] && b[b.len() - 1] == c[0]\n}\n\nspec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn expected_result(input: Seq<char>) -> Seq<char> {\n    let stripped = if input.len() > 0 && input[input.len() - 1] == '\\n' {\n        input.subrange(0, input.len() - 1)\n    } else {\n        input\n    };\n    let parts = split_on_spaces(stripped);\n    if valid_parsed_input(parts) {\n        if is_word_chain(parts[0], parts[1], parts[2]) {\n            seq!['Y', 'E', 'S', '\\n']\n        } else {\n            seq!['N', 'O', '\\n']\n        }\n    } else {\n        seq![]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == expected_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4488.rs,94,94,1.0,216.253,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_spec(input);
    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_integer(lines[1])
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && s[i] <= '9')
}

spec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else if s[0] == '\n' {
        split_lines_spec(s.subrange(1, s.len() as int))
    } else {
        let next_newline = find_next_newline(s, 0);
        if next_newline == -1 {
            seq![s]
        } else if next_newline >= 0 && next_newline < s.len() && next_newline + 1 <= s.len() {
            seq![s.subrange(0, next_newline)] + split_lines_spec(s.subrange(next_newline + 1, s.len() as int))
        } else {
            seq![]
        }
    }
}

spec fn find_next_newline(s: Seq<char>, start: nat) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        -1
    } else if s[start as int] == '\n' {
        start as int
    } else {
        find_next_newline(s, start + 1)
    }
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    parse_int_helper(s, 0)
}

spec fn parse_int_helper(s: Seq<char>, pos: nat) -> int
    decreases s.len() - pos
{
    if pos >= s.len() || s[pos as int] == '\n' || s[pos as int] == '\r' {
        0
    } else if '0' <= s[pos as int] <= '9' {
        (s[pos as int] as int - '0' as int) + 10 * parse_int_helper(s, pos + 1)
    } else {
        parse_int_helper(s, pos + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures ({
        let input_seq = input@;
        valid_input(input_seq) ==> {
            let lines = split_lines_spec(input_seq);
            let a = parse_int_spec(lines[0]);
            let b = parse_int_spec(lines[1]);
            (result@ == ""LESS\n""@) == (a < b) &&
            (result@ == ""GREATER\n""@) == (a > b) &&
            (result@ == ""EQUAL\n""@) == (a == b)
        }
    }) && ({
        let input_seq = input@;
        !valid_input(input_seq) ==> result@ == """"@
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_spec(input);
    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_integer(lines[1])
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && s[i] <= '9')
}

spec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else if s[0] == '\n' {
        split_lines_spec(s.subrange(1, s.len() as int))
    } else {
        let next_newline = find_next_newline(s, 0);
        if next_newline == -1 {
            seq![s]
        } else if next_newline >= 0 && next_newline < s.len() && next_newline + 1 <= s.len() {
            seq![s.subrange(0, next_newline)] + split_lines_spec(s.subrange(next_newline + 1, s.len() as int))
        } else {
            seq![]
        }
    }
}

spec fn find_next_newline(s: Seq<char>, start: nat) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        -1
    } else if s[start as int] == '\n' {
        start as int
    } else {
        find_next_newline(s, start + 1)
    }
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    parse_int_helper(s, 0)
}

spec fn parse_int_helper(s: Seq<char>, pos: nat) -> int
    decreases s.len() - pos
{
    if pos >= s.len() || s[pos as int] == '\n' || s[pos as int] == '\r' {
        0
    } else if '0' <= s[pos as int] <= '9' {
        (s[pos as int] as int - '0' as int) + 10 * parse_int_helper(s, pos + 1)
    } else {
        parse_int_helper(s, pos + 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures ({
        let input_seq = input@;
        valid_input(input_seq) ==> {
            let lines = split_lines_spec(input_seq);
            let a = parse_int_spec(lines[0]);
            let b = parse_int_spec(lines[1]);
            (result@ == ""LESS\n""@) == (a < b) &&
            (result@ == ""GREATER\n""@) == (a > b) &&
            (result@ == ""EQUAL\n""@) == (a == b)
        }
    }) && ({
        let input_seq = input@;
        !valid_input(input_seq) ==> result@ == """"@
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_integer(lines[1])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (\'0\' <= #[trigger] s[i] && s[i] <= \'9\')\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == \'\\n\' {\n        split_lines_spec(s.subrange(1, s.len() as int))\n    } else {\n        let next_newline = find_next_newline(s, 0);\n        if next_newline == -1 {\n            seq![s]\n        } else if next_newline >= 0 && next_newline < s.len() && next_newline + 1 <= s.len() {\n            seq![s.subrange(0, next_newline)] + split_lines_spec(s.subrange(next_newline + 1, s.len() as int))\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn find_next_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        -1\n    } else if s[start as int] == \'\\n\' {\n        start as int\n    } else {\n        find_next_newline(s, start + 1)\n    }\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    parse_int_helper(s, 0)\n}\n\nspec fn parse_int_helper(s: Seq<char>, pos: nat) -> int\n    decreases s.len() - pos\n{\n    if pos >= s.len() || s[pos as int] == \'\\n\' || s[pos as int] == \'\\r\' {\n        0\n    } else if \'0\' <= s[pos as int] <= \'9\' {\n        (s[pos as int] as int - \'0\' as int) + 10 * parse_int_helper(s, pos + 1)\n    } else {\n        parse_int_helper(s, pos + 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures ({\n        let input_seq = input@;\n        valid_input(input_seq) ==> {\n            let lines = split_lines_spec(input_seq);\n            let a = parse_int_spec(lines[0]);\n            let b = parse_int_spec(lines[1]);\n            (result@ == ""LESS\\n""@) == (a < b) &&\n            (result@ == ""GREATER\\n""@) == (a > b) &&\n            (result@ == ""EQUAL\\n""@) == (a == b)\n        }\n    }) && ({\n        let input_seq = input@;\n        !valid_input(input_seq) ==> result@ == """"@\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {\n      }\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4489.rs,109,109,1.0,153.414,True,0.9,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_occurrences(cards: Seq<&str>, target: &str) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else if cards[0] == target {
        1 + count_occurrences(cards.subrange(1, cards.len() as int), target)
    } else {
        count_occurrences(cards.subrange(1, cards.len() as int), target)
    }
}

spec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>
    decreases all_strings.len()
{
    if all_strings.len() == 0 {
        Seq::empty()
    } else {
        let rest_unique = get_unique_strings(all_strings.subrange(1, all_strings.len() as int));
        if rest_unique.contains(all_strings[0]) {
            rest_unique
        } else {
            seq![all_strings[0]].add(rest_unique)
        }
    }
}

spec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {
    let unique_blue = get_unique_strings(blue_cards);
    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)
}

spec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int
    decreases unique_blue.len() - index
{
    if index >= unique_blue.len() {
        current_max
    } else {
        let s = unique_blue[index];
        let blue_count = count_occurrences(blue_cards, s);
        let red_count = count_occurrences(red_cards, s);
        let net = blue_count - red_count;
        let new_max = if net > current_max { net } else { current_max };
        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)
    }
}

proof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)
    ensures count_occurrences(cards, target) >= 0
    decreases cards.len()
{
    if cards.len() == 0 {
    } else if cards[0] == target {
        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);
    } else {
        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);
    }
}

proof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)
    ensures max_net_earnings(blue_cards, red_cards) >= 0
{
    let unique_blue = get_unique_strings(blue_cards);
    max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, 0, 0);
}

proof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)
    requires 
        0 <= index <= unique_blue.len(),
        current_max >= 0
    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max
    decreases unique_blue.len() - index
{
    if index >= unique_blue.len() {
    } else {
        let s = unique_blue[index];
        let blue_count = count_occurrences(blue_cards, s);
        let red_count = count_occurrences(red_cards, s);
        let net = blue_count - red_count;
        let new_max = if net > current_max { net } else { current_max };
        max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, index + 1, new_max);
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(blue_cards: Vec<&str>, red_cards: Vec<&str>) -> (result: i8)
    ensures 
        result >= 0,
        result as int == max_net_earnings(blue_cards@, red_cards@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_occurrences(cards: Seq<&str>, target: &str) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else if cards[0] == target {
        1 + count_occurrences(cards.subrange(1, cards.len() as int), target)
    } else {
        count_occurrences(cards.subrange(1, cards.len() as int), target)
    }
}

spec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>
    decreases all_strings.len()
{
    if all_strings.len() == 0 {
        Seq::empty()
    } else {
        let rest_unique = get_unique_strings(all_strings.subrange(1, all_strings.len() as int));
        if rest_unique.contains(all_strings[0]) {
            rest_unique
        } else {
            seq![all_strings[0]].add(rest_unique)
        }
    }
}

spec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {
    let unique_blue = get_unique_strings(blue_cards);
    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)
}

spec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int
    decreases unique_blue.len() - index
{
    if index >= unique_blue.len() {
        current_max
    } else {
        let s = unique_blue[index];
        let blue_count = count_occurrences(blue_cards, s);
        let red_count = count_occurrences(red_cards, s);
        let net = blue_count - red_count;
        let new_max = if net > current_max { net } else { current_max };
        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)
    }
}

proof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)
    ensures count_occurrences(cards, target) >= 0
    decreases cards.len()
{
    if cards.len() == 0 {
    } else if cards[0] == target {
        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);
    } else {
        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);
    }
}

proof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)
    ensures max_net_earnings(blue_cards, red_cards) >= 0
{
    let unique_blue = get_unique_strings(blue_cards);
    max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, 0, 0);
}

proof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)
    requires 
        0 <= index <= unique_blue.len(),
        current_max >= 0
    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max
    decreases unique_blue.len() - index
{
    if index >= unique_blue.len() {
    } else {
        let s = unique_blue[index];
        let blue_count = count_occurrences(blue_cards, s);
        let red_count = count_occurrences(red_cards, s);
        let net = blue_count - red_count;
        let new_max = if net > current_max { net } else { current_max };
        max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, index + 1, new_max);
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(blue_cards: Vec<&str>, red_cards: Vec<&str>) -> (result: i8)
    ensures 
        result >= 0,
        result as int == max_net_earnings(blue_cards@, red_cards@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(cards: Seq<&str>, target: &str) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else if cards[0] == target {\n        1 + count_occurrences(cards.subrange(1, cards.len() as int), target)\n    } else {\n        count_occurrences(cards.subrange(1, cards.len() as int), target)\n    }\n}\n\nspec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>\n    decreases all_strings.len()\n{\n    if all_strings.len() == 0 {\n        Seq::empty()\n    } else {\n        let rest_unique = get_unique_strings(all_strings.subrange(1, all_strings.len() as int));\n        if rest_unique.contains(all_strings[0]) {\n            rest_unique\n        } else {\n            seq![all_strings[0]].add(rest_unique)\n        }\n    }\n}\n\nspec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)\n}\n\nspec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n        current_max\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)\n    }\n}\n\nproof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)\n    ensures count_occurrences(cards, target) >= 0\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n    } else if cards[0] == target {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    } else {\n        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);\n    }\n}\n\nproof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)\n    ensures max_net_earnings(blue_cards, red_cards) >= 0\n{\n    let unique_blue = get_unique_strings(blue_cards);\n    max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, 0, 0);\n}\n\nproof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)\n    requires \n        0 <= index <= unique_blue.len(),\n        current_max >= 0\n    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max\n    decreases unique_blue.len() - index\n{\n    if index >= unique_blue.len() {\n    } else {\n        let s = unique_blue[index];\n        let blue_count = count_occurrences(blue_cards, s);\n        let red_count = count_occurrences(red_cards, s);\n        let net = blue_count - red_count;\n        let new_max = if net > current_max { net } else { current_max };\n        max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, index + 1, new_max);\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(blue_cards: Vec<&str>, red_cards: Vec<&str>) -> (result: i8)\n    ensures \n        result >= 0,\n        result as int == max_net_earnings(blue_cards@, red_cards@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4490.rs,64,64,1.0,122.781,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_dna_base(c: char) -> bool {
    c == 'A' || c == 'T' || c == 'C' || c == 'G'
}

spec fn dna_complement(c: char) -> char
    recommends valid_dna_base(c)
{
    if c == 'A' { 'T' }
    else if c == 'T' { 'A' }
    else if c == 'C' { 'G' }
    else if c == 'G' { 'C' }
    else { 'A' } /* default case for spec completeness */
}

spec fn find_newline(input: Seq<char>) -> int {
    choose|i: int| 0 <= i < input.len() && input[i] == '\n'
}

spec fn valid_input(input: Seq<char>) -> bool {
    let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\n' {
        input.subrange(0, find_newline(input))
    } else {
        input
    };
    input_line.len() == 1 && valid_dna_base(input_line[0])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input@.len() > 0
    ensures ({
        let input_seq = stdin_input@;
        let input_line = if exists|i: int| 0 <= i < input_seq.len() && input_seq[i] == '\n' {
            input_seq.subrange(0, find_newline(input_seq))
        } else {
            input_seq
        };
        if valid_input(input_seq) {
            result@ == seq![dna_complement(input_line[0]), '\n']
        } else {
            result@ == Seq::<char>::empty()
        }
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_dna_base(c: char) -> bool {
    c == 'A' || c == 'T' || c == 'C' || c == 'G'
}

spec fn dna_complement(c: char) -> char
    recommends valid_dna_base(c)
{
    if c == 'A' { 'T' }
    else if c == 'T' { 'A' }
    else if c == 'C' { 'G' }
    else if c == 'G' { 'C' }
    else { 'A' } /* default case for spec completeness */
}

spec fn find_newline(input: Seq<char>) -> int {
    choose|i: int| 0 <= i < input.len() && input[i] == '\n'
}

spec fn valid_input(input: Seq<char>) -> bool {
    let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\n' {
        input.subrange(0, find_newline(input))
    } else {
        input
    };
    input_line.len() == 1 && valid_dna_base(input_line[0])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input@.len() > 0
    ensures ({
        let input_seq = stdin_input@;
        let input_line = if exists|i: int| 0 <= i < input_seq.len() && input_seq[i] == '\n' {
            input_seq.subrange(0, find_newline(input_seq))
        } else {
            input_seq
        };
        if valid_input(input_seq) {
            result@ == seq![dna_complement(input_line[0]), '\n']
        } else {
            result@ == Seq::<char>::empty()
        }
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_dna_base(c: char) -> bool {\n    c == 'A' || c == 'T' || c == 'C' || c == 'G'\n}\n\nspec fn dna_complement(c: char) -> char\n    recommends valid_dna_base(c)\n{\n    if c == 'A' { 'T' }\n    else if c == 'T' { 'A' }\n    else if c == 'C' { 'G' }\n    else if c == 'G' { 'C' }\n    else { 'A' } /* default case for spec completeness */\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    choose|i: int| 0 <= i < input.len() && input[i] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\\n' {\n        input.subrange(0, find_newline(input))\n    } else {\n        input\n    };\n    input_line.len() == 1 && valid_dna_base(input_line[0])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures ({\n        let input_seq = stdin_input@;\n        let input_line = if exists|i: int| 0 <= i < input_seq.len() && input_seq[i] == '\\n' {\n            input_seq.subrange(0, find_newline(input_seq))\n        } else {\n            input_seq\n        };\n        if valid_input(input_seq) {\n            result@ == seq![dna_complement(input_line[0]), '\\n']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4494.rs,56,56,1.0,123.531,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    ({
        let s = if input[input.len()-1] == '\n' { 
            input.subrange(0, input.len() - 1)
        } else { 
            input
        };
        s == ""ABC""@ || s == ""ARC""@
    })
}

spec fn normalize_input(input: Seq<char>) -> Seq<char>
    recommends input.len() > 0
{
    if input[input.len()-1] == '\n' { 
        input.subrange(0, input.len() - 1)
    } else { 
        input
    }
}

spec fn expected_output(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let s = normalize_input(input);
    if s == ""ABC""@ { ""ARC\n""@ } else { ""ABC\n""@ }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires valid_input(input@)
    ensures result@ == expected_output(input@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    ({
        let s = if input[input.len()-1] == '\n' { 
            input.subrange(0, input.len() - 1)
        } else { 
            input
        };
        s == ""ABC""@ || s == ""ARC""@
    })
}

spec fn normalize_input(input: Seq<char>) -> Seq<char>
    recommends input.len() > 0
{
    if input[input.len()-1] == '\n' { 
        input.subrange(0, input.len() - 1)
    } else { 
        input
    }
}

spec fn expected_output(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let s = normalize_input(input);
    if s == ""ABC""@ { ""ARC\n""@ } else { ""ABC\n""@ }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires valid_input(input@)
    ensures result@ == expected_output(input@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    ({\n        let s = if input[input.len()-1] == \'\\n\' { \n            input.subrange(0, input.len() - 1)\n        } else { \n            input\n        };\n        s == ""ABC""@ || s == ""ARC""@\n    })\n}\n\nspec fn normalize_input(input: Seq<char>) -> Seq<char>\n    recommends input.len() > 0\n{\n    if input[input.len()-1] == \'\\n\' { \n        input.subrange(0, input.len() - 1)\n    } else { \n        input\n    }\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let s = normalize_input(input);\n    if s == ""ABC""@ { ""ARC\\n""@ } else { ""ABC\\n""@ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == expected_output(input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4496.rs,53,53,1.0,122.856,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(d: int) -> bool {
    22 <= d <= 25
}

spec fn expected_output(d: int) -> Seq<char> {
    if valid_input(d) {
        let eve_count = 25 - d;
        let base_string = seq!['C', 'h', 'r', 'i', 's', 't', 'm', 'a', 's'];
        if eve_count == 0 {
            base_string
        } else {
            base_string + repeat_eve(eve_count)
        }
    } else {
        seq![]
    }
}

spec fn repeat_eve(count: int) -> Seq<char>
    decreases count
{
    if count <= 0 {
        seq![]
    } else {
        seq![' ', 'E', 'v', 'e'] + repeat_eve(count - 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(d: i8) -> (result: String)
    requires valid_input(d as int)
    ensures result@ == expected_output(d as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(d: int) -> bool {
    22 <= d <= 25
}

spec fn expected_output(d: int) -> Seq<char> {
    if valid_input(d) {
        let eve_count = 25 - d;
        let base_string = seq!['C', 'h', 'r', 'i', 's', 't', 'm', 'a', 's'];
        if eve_count == 0 {
            base_string
        } else {
            base_string + repeat_eve(eve_count)
        }
    } else {
        seq![]
    }
}

spec fn repeat_eve(count: int) -> Seq<char>
    decreases count
{
    if count <= 0 {
        seq![]
    } else {
        seq![' ', 'E', 'v', 'e'] + repeat_eve(count - 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(d: i8) -> (result: String)
    requires valid_input(d as int)
    ensures result@ == expected_output(d as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(d: int) -> bool {\n    22 <= d <= 25\n}\n\nspec fn expected_output(d: int) -> Seq<char> {\n    if valid_input(d) {\n        let eve_count = 25 - d;\n        let base_string = seq!['C', 'h', 'r', 'i', 's', 't', 'm', 'a', 's'];\n        if eve_count == 0 {\n            base_string\n        } else {\n            base_string + repeat_eve(eve_count)\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn repeat_eve(count: int) -> Seq<char>\n    decreases count\n{\n    if count <= 0 {\n        seq![]\n    } else {\n        seq![' ', 'E', 'v', 'e'] + repeat_eve(count - 1)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(d: i8) -> (result: String)\n    requires valid_input(d as int)\n    ensures result@ == expected_output(d as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_45.rs,62,62,1.0,154.756,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool
{
    n > 0 && k > 0
}

spec fn is_strictly_increasing(s: Seq<int>) -> bool
{
    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i+1]
}

spec fn all_positive(s: Seq<int>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] > 0
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool
{
    s.len() == k && all_positive(s) && is_strictly_increasing(s) && sum_seq(s) == n
}

spec fn is_possible(n: int, k: int) -> bool
{
    k * (k + 1) / 2 <= n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, k as int)
    ensures 
        ((result.len() == 1 && result[0] == -1) || 
         (valid_sequence(result@.map(|_i: int, x: i8| x as int), n as int, k as int))) &&
        ((result.len() == 1 && result[0] == -1) <==> !is_possible(n as int, k as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool
{
    n > 0 && k > 0
}

spec fn is_strictly_increasing(s: Seq<int>) -> bool
{
    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i+1]
}

spec fn all_positive(s: Seq<int>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] > 0
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool
{
    s.len() == k && all_positive(s) && is_strictly_increasing(s) && sum_seq(s) == n
}

spec fn is_possible(n: int, k: int) -> bool
{
    k * (k + 1) / 2 <= n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, k as int)
    ensures 
        ((result.len() == 1 && result[0] == -1) || 
         (valid_sequence(result@.map(|_i: int, x: i8| x as int), n as int, k as int))) &&
        ((result.len() == 1 && result[0] == -1) <==> !is_possible(n as int, k as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int) -> bool\n{\n    n > 0 && k > 0\n}\n\nspec fn is_strictly_increasing(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i+1]\n}\n\nspec fn all_positive(s: Seq<int>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] > 0\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool\n{\n    s.len() == k && all_positive(s) && is_strictly_increasing(s) && sum_seq(s) == n\n}\n\nspec fn is_possible(n: int, k: int) -> bool\n{\n    k * (k + 1) / 2 <= n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, k as int)\n    ensures \n        ((result.len() == 1 && result[0] == -1) || \n         (valid_sequence(result@.map(|_i: int, x: i8| x as int), n as int, k as int))) &&\n        ((result.len() == 1 && result[0] == -1) <==> !is_possible(n as int, k as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n           fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4502.rs,71,71,1.0,122.885,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && a.len() == n
}

spec fn simulate_operations(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
    decreases a.len() when a.len() > 0
{
    if a.len() == 1 {
        seq![a[0]]
    } else {
        let shorter = a.subrange(0, (a.len() - 1) as int);
        let prev = simulate_operations(shorter);
        reverse_seq(prev.push(a[(a.len() - 1) as int]))
    }
}

spec fn compute_result(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
{
    let n = a.len();
    let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);
    let e = Seq::new(n / 2, |i: int| a[2*i + 1]);
    if n % 2 == 0 {
        reverse_seq(e).add(o)
    } else {
        reverse_seq(o).add(e)
    }
}

spec fn reverse_seq(s: Seq<int>) -> Seq<int>
    decreases s.len() when s.len() > 0
{
    if s.len() == 0 {
        seq![]
    } else {
        let rest = s.subrange(1, s.len() as int);
        reverse_seq(rest).push(s[0])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        result.len() == n as int,
        result@.map(|i: int, x: i8| x as int) == compute_result(a@.map(|i: int, x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && a.len() == n
}

spec fn simulate_operations(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
    decreases a.len() when a.len() > 0
{
    if a.len() == 1 {
        seq![a[0]]
    } else {
        let shorter = a.subrange(0, (a.len() - 1) as int);
        let prev = simulate_operations(shorter);
        reverse_seq(prev.push(a[(a.len() - 1) as int]))
    }
}

spec fn compute_result(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
{
    let n = a.len();
    let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);
    let e = Seq::new(n / 2, |i: int| a[2*i + 1]);
    if n % 2 == 0 {
        reverse_seq(e).add(o)
    } else {
        reverse_seq(o).add(e)
    }
}

spec fn reverse_seq(s: Seq<int>) -> Seq<int>
    decreases s.len() when s.len() > 0
{
    if s.len() == 0 {
        seq![]
    } else {
        let rest = s.subrange(1, s.len() as int);
        reverse_seq(rest).push(s[0])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        result.len() == n as int,
        result@.map(|i: int, x: i8| x as int) == compute_result(a@.map(|i: int, x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && a.len() == n\n}\n\nspec fn simulate_operations(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        seq![a[0]]\n    } else {\n        let shorter = a.subrange(0, (a.len() - 1) as int);\n        let prev = simulate_operations(shorter);\n        reverse_seq(prev.push(a[(a.len() - 1) as int]))\n    }\n}\n\nspec fn compute_result(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    let n = a.len();\n    let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);\n    let e = Seq::new(n / 2, |i: int| a[2*i + 1]);\n    if n % 2 == 0 {\n        reverse_seq(e).add(o)\n    } else {\n        reverse_seq(o).add(e)\n    }\n}\n\nspec fn reverse_seq(s: Seq<int>) -> Seq<int>\n    decreases s.len() when s.len() > 0\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let rest = s.subrange(1, s.len() as int);\n        reverse_seq(rest).push(s[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),\n    ensures \n        result.len() == n as int,\n        result@.map(|i: int, x: i8| x as int) == compute_result(a@.map(|i: int, x: i8| x as int)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4508.rs,110,110,1.0,152.913,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {
    n >= 2 && edges.len() == n - 1 &&
    forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1
}

spec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {
    n >= 2 ==> forall|v: int| 2 <= v <= n ==> shortest_path_distance(n, edges, 1, v) <= 2
}

spec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {
    if n >= 1 && 1 <= start <= n && 1 <= end <= n {
        if start == end { 0 } else { compute_shortest_path(n, edges, start, end) }
    } else {
        -1
    }
}

spec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {
    if n >= 1 && 1 <= start <= n && 1 <= end <= n {
        let adj = build_adjacency_list(n, edges);
        bfs(adj, n, start, end)
    } else {
        -1
    }
}

spec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {
    if n >= 1 {
        let adj = Seq::new((n + 1) as nat, |i: int| Seq::<int>::empty());
        add_edges_to_adj_list(adj, edges)
    } else {
        Seq::<Seq<int>>::empty()
    }
}

spec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>
    decreases edges.len()
{
    if adj.len() >= 1 {
        if edges.len() == 0 {
            adj
        } else {
            let e = edges[0];
            if 1 <= e.0 < adj.len() && 1 <= e.1 < adj.len() {
                let new_adj = adj.update(e.0, adj[e.0].push(e.1)).update(e.1, adj[e.1].push(e.0));
                add_edges_to_adj_list(new_adj, edges.subrange(1, edges.len() as int))
            } else {
                add_edges_to_adj_list(adj, edges.subrange(1, edges.len() as int))
            }
        }
    } else {
        adj
    }
}

spec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {
    if n >= 1 && adj.len() == n + 1 && 1 <= start <= n && 1 <= end <= n {
        if start == end { 
            0 
        } else if adj[start].contains(end) { 
            1 
        } else if distance_is_2(adj, start, end) { 
            2 
        } else { 
            3 
        }
    } else {
        -1
    }
}

spec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {
    if adj.len() > 0 && 0 <= start < adj.len() {
        exists|neighbor: int| adj[start].contains(neighbor) && 0 <= neighbor < adj.len() && adj[neighbor].contains(end)
    } else {
        false
    }
}

spec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {
    valid_input(n, original_edges) ==> num_edges_to_add >= 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, edges: Vec<(i8, i8)>) -> (num_edges_to_add: i8)
    requires n >= 2,
             edges.len() == (n - 1) as nat,
             forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1
    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),
            all_vertices_within_distance2(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> num_edges_to_add >= 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {
    n >= 2 && edges.len() == n - 1 &&
    forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1
}

spec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {
    n >= 2 ==> forall|v: int| 2 <= v <= n ==> shortest_path_distance(n, edges, 1, v) <= 2
}

spec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {
    if n >= 1 && 1 <= start <= n && 1 <= end <= n {
        if start == end { 0 } else { compute_shortest_path(n, edges, start, end) }
    } else {
        -1
    }
}

spec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {
    if n >= 1 && 1 <= start <= n && 1 <= end <= n {
        let adj = build_adjacency_list(n, edges);
        bfs(adj, n, start, end)
    } else {
        -1
    }
}

spec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {
    if n >= 1 {
        let adj = Seq::new((n + 1) as nat, |i: int| Seq::<int>::empty());
        add_edges_to_adj_list(adj, edges)
    } else {
        Seq::<Seq<int>>::empty()
    }
}

spec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>
    decreases edges.len()
{
    if adj.len() >= 1 {
        if edges.len() == 0 {
            adj
        } else {
            let e = edges[0];
            if 1 <= e.0 < adj.len() && 1 <= e.1 < adj.len() {
                let new_adj = adj.update(e.0, adj[e.0].push(e.1)).update(e.1, adj[e.1].push(e.0));
                add_edges_to_adj_list(new_adj, edges.subrange(1, edges.len() as int))
            } else {
                add_edges_to_adj_list(adj, edges.subrange(1, edges.len() as int))
            }
        }
    } else {
        adj
    }
}

spec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {
    if n >= 1 && adj.len() == n + 1 && 1 <= start <= n && 1 <= end <= n {
        if start == end { 
            0 
        } else if adj[start].contains(end) { 
            1 
        } else if distance_is_2(adj, start, end) { 
            2 
        } else { 
            3 
        }
    } else {
        -1
    }
}

spec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {
    if adj.len() > 0 && 0 <= start < adj.len() {
        exists|neighbor: int| adj[start].contains(neighbor) && 0 <= neighbor < adj.len() && adj[neighbor].contains(end)
    } else {
        false
    }
}

spec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {
    valid_input(n, original_edges) ==> num_edges_to_add >= 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, edges: Vec<(i8, i8)>) -> (num_edges_to_add: i8)
    requires n >= 2,
             edges.len() == (n - 1) as nat,
             forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1
    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),
            all_vertices_within_distance2(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> num_edges_to_add >= 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 && edges.len() == n - 1 &&\n    forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1\n}\n\nspec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 ==> forall|v: int| 2 <= v <= n ==> shortest_path_distance(n, edges, 1, v) <= 2\n}\n\nspec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { 0 } else { compute_shortest_path(n, edges, start, end) }\n    } else {\n        -1\n    }\n}\n\nspec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {\n    if n >= 1 && 1 <= start <= n && 1 <= end <= n {\n        let adj = build_adjacency_list(n, edges);\n        bfs(adj, n, start, end)\n    } else {\n        -1\n    }\n}\n\nspec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {\n    if n >= 1 {\n        let adj = Seq::new((n + 1) as nat, |i: int| Seq::<int>::empty());\n        add_edges_to_adj_list(adj, edges)\n    } else {\n        Seq::<Seq<int>>::empty()\n    }\n}\n\nspec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>\n    decreases edges.len()\n{\n    if adj.len() >= 1 {\n        if edges.len() == 0 {\n            adj\n        } else {\n            let e = edges[0];\n            if 1 <= e.0 < adj.len() && 1 <= e.1 < adj.len() {\n                let new_adj = adj.update(e.0, adj[e.0].push(e.1)).update(e.1, adj[e.1].push(e.0));\n                add_edges_to_adj_list(new_adj, edges.subrange(1, edges.len() as int))\n            } else {\n                add_edges_to_adj_list(adj, edges.subrange(1, edges.len() as int))\n            }\n        }\n    } else {\n        adj\n    }\n}\n\nspec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {\n    if n >= 1 && adj.len() == n + 1 && 1 <= start <= n && 1 <= end <= n {\n        if start == end { \n            0 \n        } else if adj[start].contains(end) { \n            1 \n        } else if distance_is_2(adj, start, end) { \n            2 \n        } else { \n            3 \n        }\n    } else {\n        -1\n    }\n}\n\nspec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {\n    if adj.len() > 0 && 0 <= start < adj.len() {\n        exists|neighbor: int| adj[start].contains(neighbor) && 0 <= neighbor < adj.len() && adj[neighbor].contains(end)\n    } else {\n        false\n    }\n}\n\nspec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {\n    valid_input(n, original_edges) ==> num_edges_to_add >= 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, edges: Vec<(i8, i8)>) -> (num_edges_to_add: i8)\n    requires n >= 2,\n             edges.len() == (n - 1) as nat,\n             forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1\n    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),\n            all_vertices_within_distance2(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> num_edges_to_add >= 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4551.rs,109,109,1.0,153.086,True,0.9,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_parseable(input: Seq<char>) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4
}

spec fn all_parts_are_integers(input: Seq<char>) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4 &&
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1]) &&
    is_valid_integer(parts[2]) &&
    is_valid_integer(parts[3])
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] <= '9') || (i == 0 && s[i] == '-'))
}

spec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4 && 
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1]) &&
    is_valid_integer(parts[2]) &&
    is_valid_integer(parts[3]) &&
    string_to_int_pure(parts[0]) == a &&
    string_to_int_pure(parts[1]) == b &&
    string_to_int_pure(parts[2]) == c &&
    string_to_int_pure(parts[3]) == d
}

spec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    split_string_helper(s, 0, seq![], seq![])
}

spec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i
{
    if i < 0 || i > s.len() {
        acc
    } else if i == s.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else if s[i] == ' ' || s[i] == '\n' || s[i] == '\t' {
        if current.len() > 0 {
            split_string_helper(s, i + 1, seq![], acc.push(current))
        } else {
            split_string_helper(s, i + 1, seq![], acc)
        }
    } else {
        split_string_helper(s, i + 1, current.push(s[i]), acc)
    }
}

spec fn string_to_int_pure(s: Seq<char>) -> int {
    if !is_valid_integer(s) {
        0
    } else if s.len() > 0 && s[0] == '-' {
        -string_to_int_helper_unsigned(s, 1, 0)
    } else {
        string_to_int_helper_unsigned(s, 0, 0)
    }
}

spec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int
    decreases s.len() - i
{
    if i < 0 || i >= s.len() {
        acc
    } else if '0' <= s[i] <= '9' {
        string_to_int_helper_unsigned(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        acc
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    ensures 
        (forall|a: int, b: int, c: int, d: int| 
            valid_parse(input@, a, b, c, d) ==> 
            ((result@ == ""Left\n""@) <==> (a + b > c + d)) &&
            ((result@ == ""Right\n""@) <==> (a + b < c + d)) &&
            ((result@ == ""Balanced\n""@) <==> (a + b == c + d))) &&
        (valid_parseable(input@) && all_parts_are_integers(input@) ==> 
            (result@ == ""Left\n""@ || result@ == ""Right\n""@ || result@ == ""Balanced\n""@)) &&
        ((!valid_parseable(input@) || !all_parts_are_integers(input@)) ==> result@ == """"@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    """".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_parseable(input: Seq<char>) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4
}

spec fn all_parts_are_integers(input: Seq<char>) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4 &&
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1]) &&
    is_valid_integer(parts[2]) &&
    is_valid_integer(parts[3])
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] <= '9') || (i == 0 && s[i] == '-'))
}

spec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4 && 
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1]) &&
    is_valid_integer(parts[2]) &&
    is_valid_integer(parts[3]) &&
    string_to_int_pure(parts[0]) == a &&
    string_to_int_pure(parts[1]) == b &&
    string_to_int_pure(parts[2]) == c &&
    string_to_int_pure(parts[3]) == d
}

spec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    split_string_helper(s, 0, seq![], seq![])
}

spec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i
{
    if i < 0 || i > s.len() {
        acc
    } else if i == s.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else if s[i] == ' ' || s[i] == '\n' || s[i] == '\t' {
        if current.len() > 0 {
            split_string_helper(s, i + 1, seq![], acc.push(current))
        } else {
            split_string_helper(s, i + 1, seq![], acc)
        }
    } else {
        split_string_helper(s, i + 1, current.push(s[i]), acc)
    }
}

spec fn string_to_int_pure(s: Seq<char>) -> int {
    if !is_valid_integer(s) {
        0
    } else if s.len() > 0 && s[0] == '-' {
        -string_to_int_helper_unsigned(s, 1, 0)
    } else {
        string_to_int_helper_unsigned(s, 0, 0)
    }
}

spec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int
    decreases s.len() - i
{
    if i < 0 || i >= s.len() {
        acc
    } else if '0' <= s[i] <= '9' {
        string_to_int_helper_unsigned(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        acc
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    ensures 
        (forall|a: int, b: int, c: int, d: int| 
            valid_parse(input@, a, b, c, d) ==> 
            ((result@ == ""Left\n""@) <==> (a + b > c + d)) &&
            ((result@ == ""Right\n""@) <==> (a + b < c + d)) &&
            ((result@ == ""Balanced\n""@) <==> (a + b == c + d))) &&
        (valid_parseable(input@) && all_parts_are_integers(input@) ==> 
            (result@ == ""Left\n""@ || result@ == ""Right\n""@ || result@ == ""Balanced\n""@)) &&
        ((!valid_parseable(input@) || !all_parts_are_integers(input@)) ==> result@ == """"@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    """".to_string()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_parseable(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4\n}\n\nspec fn all_parts_are_integers(input: Seq<char>) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3])\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> (\'0\' <= s[i] <= \'9\') || (i == 0 && s[i] == \'-\'))\n}\n\nspec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {\n    let parts = split_string_pure(input);\n    parts.len() >= 4 && \n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1]) &&\n    is_valid_integer(parts[2]) &&\n    is_valid_integer(parts[3]) &&\n    string_to_int_pure(parts[0]) == a &&\n    string_to_int_pure(parts[1]) == b &&\n    string_to_int_pure(parts[2]) == c &&\n    string_to_int_pure(parts[3]) == d\n}\n\nspec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    split_string_helper(s, 0, seq![], seq![])\n}\n\nspec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i\n{\n    if i < 0 || i > s.len() {\n        acc\n    } else if i == s.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else if s[i] == \' \' || s[i] == \'\\n\' || s[i] == \'\\t\' {\n        if current.len() > 0 {\n            split_string_helper(s, i + 1, seq![], acc.push(current))\n        } else {\n            split_string_helper(s, i + 1, seq![], acc)\n        }\n    } else {\n        split_string_helper(s, i + 1, current.push(s[i]), acc)\n    }\n}\n\nspec fn string_to_int_pure(s: Seq<char>) -> int {\n    if !is_valid_integer(s) {\n        0\n    } else if s.len() > 0 && s[0] == \'-\' {\n        -string_to_int_helper_unsigned(s, 1, 0)\n    } else {\n        string_to_int_helper_unsigned(s, 0, 0)\n    }\n}\n\nspec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int\n    decreases s.len() - i\n{\n    if i < 0 || i >= s.len() {\n        acc\n    } else if \'0\' <= s[i] <= \'9\' {\n        string_to_int_helper_unsigned(s, i + 1, acc * 10 + (s[i] as int - \'0\' as int))\n    } else {\n        acc\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    ensures \n        (forall|a: int, b: int, c: int, d: int| \n            valid_parse(input@, a, b, c, d) ==> \n            ((result@ == ""Left\\n""@) <==> (a + b > c + d)) &&\n            ((result@ == ""Right\\n""@) <==> (a + b < c + d)) &&\n            ((result@ == ""Balanced\\n""@) <==> (a + b == c + d))) &&\n        (valid_parseable(input@) && all_parts_are_integers(input@) ==> \n            (result@ == ""Left\\n""@ || result@ == ""Right\\n""@ || result@ == ""Balanced\\n""@)) &&\n        ((!valid_parseable(input@) || !all_parts_are_integers(input@)) ==> result@ == """"@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    """".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4554.rs,52,52,1.0,125.187,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(w: int, a: int, b: int) -> bool {
    w >= 1 && a >= 1 && b >= 1
}

spec fn abs_diff(x: int, y: int) -> int {
    if x >= y { x - y } else { y - x }
}

spec fn min_move_distance(w: int, a: int, b: int) -> int
    recommends valid_input(w, a, b)
{
    let distance = abs_diff(a, b);
    if distance <= w { 0 }
    else { distance - w }
}

spec fn rectangles_connect(w: int, a: int, b: int) -> bool
    recommends valid_input(w, a, b)
{
    abs_diff(a, b) <= w
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(w: i8, a: i8, b: i8) -> (result: i8)
    requires valid_input(w as int, a as int, b as int)
    ensures 
        result as int == min_move_distance(w as int, a as int, b as int) &&
        result >= 0 &&
        (rectangles_connect(w as int, a as int, b as int) <==> result == 0)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(w: int, a: int, b: int) -> bool {
    w >= 1 && a >= 1 && b >= 1
}

spec fn abs_diff(x: int, y: int) -> int {
    if x >= y { x - y } else { y - x }
}

spec fn min_move_distance(w: int, a: int, b: int) -> int
    recommends valid_input(w, a, b)
{
    let distance = abs_diff(a, b);
    if distance <= w { 0 }
    else { distance - w }
}

spec fn rectangles_connect(w: int, a: int, b: int) -> bool
    recommends valid_input(w, a, b)
{
    abs_diff(a, b) <= w
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(w: i8, a: i8, b: i8) -> (result: i8)
    requires valid_input(w as int, a as int, b as int)
    ensures 
        result as int == min_move_distance(w as int, a as int, b as int) &&
        result >= 0 &&
        (rectangles_connect(w as int, a as int, b as int) <==> result == 0)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(w: int, a: int, b: int) -> bool {\n    w >= 1 && a >= 1 && b >= 1\n}\n\nspec fn abs_diff(x: int, y: int) -> int {\n    if x >= y { x - y } else { y - x }\n}\n\nspec fn min_move_distance(w: int, a: int, b: int) -> int\n    recommends valid_input(w, a, b)\n{\n    let distance = abs_diff(a, b);\n    if distance <= w { 0 }\n    else { distance - w }\n}\n\nspec fn rectangles_connect(w: int, a: int, b: int) -> bool\n    recommends valid_input(w, a, b)\n{\n    abs_diff(a, b) <= w\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(w: i8, a: i8, b: i8) -> (result: i8)\n    requires valid_input(w as int, a as int, b as int)\n    ensures \n        result as int == min_move_distance(w as int, a as int, b as int) &&\n        result >= 0 &&\n        (rectangles_connect(w as int, a as int, b as int) <==> result == 0)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4556.rs,56,56,1.0,214.945,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool 
    decreases input.len()
{
    &&& input.len() >= 18
    &&& input[input.len() as int - 1] == '\n'
    &&& input.subrange(0, 7) == seq!['A', 't', 'C', 'o', 'd', 'e', 'r']
    &&& input[7] == ' '
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        input.subrange(space_pos + 1, space_pos + 8) == seq!['C', 'o', 'n', 't', 'e', 's', 't'] &&
        space_pos + 8 == input.len() - 1
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        space_pos > 8 &&
        'A' <= input[8] <= 'Z' &&
        forall|k: int| 9 <= k < space_pos ==> 'a' <= #[trigger] input.index(k) <= 'z'
}

spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool 
    decreases input.len()
{
    &&& result.len() == 4
    &&& result[0] == 'A'
    &&& result[2] == 'C'
    &&& result[3] == '\n'
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        result[1] == input[8]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(input@, result@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool 
    decreases input.len()
{
    &&& input.len() >= 18
    &&& input[input.len() as int - 1] == '\n'
    &&& input.subrange(0, 7) == seq!['A', 't', 'C', 'o', 'd', 'e', 'r']
    &&& input[7] == ' '
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        input.subrange(space_pos + 1, space_pos + 8) == seq!['C', 'o', 'n', 't', 'e', 's', 't'] &&
        space_pos + 8 == input.len() - 1
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        space_pos > 8 &&
        'A' <= input[8] <= 'Z' &&
        forall|k: int| 9 <= k < space_pos ==> 'a' <= #[trigger] input.index(k) <= 'z'
}

spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool 
    decreases input.len()
{
    &&& result.len() == 4
    &&& result[0] == 'A'
    &&& result[2] == 'C'
    &&& result[3] == '\n'
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        result[1] == input[8]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(input@, result@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& input.len() >= 18\n    &&& input[input.len() as int - 1] == '\\n'\n    &&& input.subrange(0, 7) == seq!['A', 't', 'C', 'o', 'd', 'e', 'r']\n    &&& input[7] == ' '\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        input.subrange(space_pos + 1, space_pos + 8) == seq!['C', 'o', 'n', 't', 'e', 's', 't'] &&\n        space_pos + 8 == input.len() - 1\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        space_pos > 8 &&\n        'A' <= input[8] <= 'Z' &&\n        forall|k: int| 9 <= k < space_pos ==> 'a' <= #[trigger] input.index(k) <= 'z'\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool \n    decreases input.len()\n{\n    &&& result.len() == 4\n    &&& result[0] == 'A'\n    &&& result[2] == 'C'\n    &&& result[3] == '\\n'\n    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && \n        #[trigger] input.index(space_pos) == ' ' && \n        result[1] == input[8]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n          fn main() {\n}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4567.rs,62,62,1.0,219.003,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(scores: Seq<int>) -> bool {
    scores.len() > 0 && scores.len() <= 100 &&
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 1 && #[trigger] scores[i] <= 100
}

spec fn sum_seq(scores: Seq<int>) -> int
    decreases scores.len()
{
    if scores.len() == 0 {
        0
    } else {
        scores[0] + sum_seq(scores.subrange(1, scores.len() as int))
    }
}

spec fn all_multiples_of_10(scores: Seq<int>) -> bool {
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] % 10 == 0
}

spec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {
    scores.contains(value) && 
    value % 10 != 0 &&
    forall|x: int| #[trigger] scores.contains(x) && x % 10 != 0 ==> value <= x
}

spec fn correct_result(scores: Seq<int>, result: int) -> bool {
    let total_sum = sum_seq(scores);
    if total_sum % 10 != 0 {
        result == total_sum
    } else if all_multiples_of_10(scores) {
        result == 0
    } else {
        exists|smallest_non_multiple: int| 
            is_smallest_non_multiple(scores, smallest_non_multiple) &&
            result == total_sum - smallest_non_multiple
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(scores: Vec<i8>) -> (result: i8)
    requires valid_input(scores@.map(|i, x| x as int))
    ensures correct_result(scores@.map(|i, x| x as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(scores: Seq<int>) -> bool {
    scores.len() > 0 && scores.len() <= 100 &&
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 1 && #[trigger] scores[i] <= 100
}

spec fn sum_seq(scores: Seq<int>) -> int
    decreases scores.len()
{
    if scores.len() == 0 {
        0
    } else {
        scores[0] + sum_seq(scores.subrange(1, scores.len() as int))
    }
}

spec fn all_multiples_of_10(scores: Seq<int>) -> bool {
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] % 10 == 0
}

spec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {
    scores.contains(value) && 
    value % 10 != 0 &&
    forall|x: int| #[trigger] scores.contains(x) && x % 10 != 0 ==> value <= x
}

spec fn correct_result(scores: Seq<int>, result: int) -> bool {
    let total_sum = sum_seq(scores);
    if total_sum % 10 != 0 {
        result == total_sum
    } else if all_multiples_of_10(scores) {
        result == 0
    } else {
        exists|smallest_non_multiple: int| 
            is_smallest_non_multiple(scores, smallest_non_multiple) &&
            result == total_sum - smallest_non_multiple
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(scores: Vec<i8>) -> (result: i8)
    requires valid_input(scores@.map(|i, x| x as int))
    ensures correct_result(scores@.map(|i, x| x as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(scores: Seq<int>) -> bool {\n    scores.len() > 0 && scores.len() <= 100 &&\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 1 && #[trigger] scores[i] <= 100\n}\n\nspec fn sum_seq(scores: Seq<int>) -> int\n    decreases scores.len()\n{\n    if scores.len() == 0 {\n        0\n    } else {\n        scores[0] + sum_seq(scores.subrange(1, scores.len() as int))\n    }\n}\n\nspec fn all_multiples_of_10(scores: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] % 10 == 0\n}\n\nspec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {\n    scores.contains(value) && \n    value % 10 != 0 &&\n    forall|x: int| #[trigger] scores.contains(x) && x % 10 != 0 ==> value <= x\n}\n\nspec fn correct_result(scores: Seq<int>, result: int) -> bool {\n    let total_sum = sum_seq(scores);\n    if total_sum % 10 != 0 {\n        result == total_sum\n    } else if all_multiples_of_10(scores) {\n        result == 0\n    } else {\n        exists|smallest_non_multiple: int| \n            is_smallest_non_multiple(scores, smallest_non_multiple) &&\n            result == total_sum - smallest_non_multiple\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(scores: Vec<i8>) -> (result: i8)\n    requires valid_input(scores@.map(|i, x| x as int))\n    ensures correct_result(scores@.map(|i, x| x as int), result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4569.rs,50,50,1.0,188.268,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_weather(weather: Seq<char>) -> bool {
    weather == ""Sunny""@ || weather == ""Cloudy""@ || weather == ""Rainy""@
}

spec fn trim_newline(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        input.subrange(0, input.len() as int - 1)
    } else {
        input
    }
}

spec fn next_weather(weather: Seq<char>) -> Seq<char>
    recommends valid_weather(weather)
{
    if weather == ""Sunny""@ { ""Cloudy""@ }
    else if weather == ""Cloudy""@ { ""Rainy""@ }
    else { ""Sunny""@ }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    ensures ({
        let trimmed = trim_newline(input@);
        if valid_weather(trimmed) {
            result@ == next_weather(trimmed) + seq!['\n']
        } else {
            result@ == Seq::<char>::empty()
        }
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_weather(weather: Seq<char>) -> bool {
    weather == ""Sunny""@ || weather == ""Cloudy""@ || weather == ""Rainy""@
}

spec fn trim_newline(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        input.subrange(0, input.len() as int - 1)
    } else {
        input
    }
}

spec fn next_weather(weather: Seq<char>) -> Seq<char>
    recommends valid_weather(weather)
{
    if weather == ""Sunny""@ { ""Cloudy""@ }
    else if weather == ""Cloudy""@ { ""Rainy""@ }
    else { ""Sunny""@ }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    ensures ({
        let trimmed = trim_newline(input@);
        if valid_weather(trimmed) {
            result@ == next_weather(trimmed) + seq!['\n']
        } else {
            result@ == Seq::<char>::empty()
        }
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_weather(weather: Seq<char>) -> bool {\n    weather == ""Sunny""@ || weather == ""Cloudy""@ || weather == ""Rainy""@\n}\n\nspec fn trim_newline(input: Seq<char>) -> Seq<char> {\n    if input.len() > 0 && input[input.len() as int - 1] == \'\\n\' {\n        input.subrange(0, input.len() as int - 1)\n    } else {\n        input\n    }\n}\n\nspec fn next_weather(weather: Seq<char>) -> Seq<char>\n    recommends valid_weather(weather)\n{\n    if weather == ""Sunny""@ { ""Cloudy""@ }\n    else if weather == ""Cloudy""@ { ""Rainy""@ }\n    else { ""Sunny""@ }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    ensures ({\n        let trimmed = trim_newline(input@);\n        if valid_weather(trimmed) {\n            result@ == next_weather(trimmed) + seq![\'\\n\']\n        } else {\n            result@ == Seq::<char>::empty()\n        }\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4570.rs,67,67,1.0,215.721,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    true /* Simplified for now */
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1'], seq!['2'], seq!['3']] /* Simplified for now */
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    if s.len() > 0 && s[0] == '1' { 1 }
    else if s.len() > 0 && s[0] == '2' { 2 }
    else if s.len() > 0 && s[0] == '3' { 3 }
    else { 0 }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else { seq!['0'] }
}

spec fn min_parking_cost(n: int, a: int, b: int) -> int {
    let plan1_cost = n * a;
    let plan2_cost = b;
    if plan1_cost <= plan2_cost { plan1_cost } else { plan2_cost }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        input.len() > 0,
        valid_input(input),
    ensures
        ({
            let parts = split_string_func(input);
            let n = string_to_int_func(parts[0]);
            let a = string_to_int_func(parts[1]);
            let b = string_to_int_func(parts[2]);
            result == int_to_string_func(min_parking_cost(n, a, b)) + seq!['\n']
        })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    true /* Simplified for now */
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1'], seq!['2'], seq!['3']] /* Simplified for now */
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    if s.len() > 0 && s[0] == '1' { 1 }
    else if s.len() > 0 && s[0] == '2' { 2 }
    else if s.len() > 0 && s[0] == '3' { 3 }
    else { 0 }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else { seq!['0'] }
}

spec fn min_parking_cost(n: int, a: int, b: int) -> int {
    let plan1_cost = n * a;
    let plan2_cost = b;
    if plan1_cost <= plan2_cost { plan1_cost } else { plan2_cost }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        input.len() > 0,
        valid_input(input),
    ensures
        ({
            let parts = split_string_func(input);
            let n = string_to_int_func(parts[0]);
            let a = string_to_int_func(parts[1]);
            let b = string_to_int_func(parts[2]);
            result == int_to_string_func(min_parking_cost(n, a, b)) + seq!['\n']
        })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true /* Simplified for now */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2'], seq!['3']] /* Simplified for now */\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    if s.len() > 0 && s[0] == '1' { 1 }\n    else if s.len() > 0 && s[0] == '2' { 2 }\n    else if s.len() > 0 && s[0] == '3' { 3 }\n    else { 0 }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else if n == 2 { seq!['2'] }\n    else if n == 3 { seq!['3'] }\n    else { seq!['0'] }\n}\n\nspec fn min_parking_cost(n: int, a: int, b: int) -> int {\n    let plan1_cost = n * a;\n    let plan2_cost = b;\n    if plan1_cost <= plan2_cost { plan1_cost } else { plan2_cost }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        ({\n            let parts = split_string_func(input);\n            let n = string_to_int_func(parts[0]);\n            let a = string_to_int_func(parts[1]);\n            let b = string_to_int_func(parts[2]);\n            result == int_to_string_func(min_parking_cost(n, a, b)) + seq!['\\n']\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4575.rs,142,12,0.08450704225352113,310.101,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_str(input, '\n');
    lines.len() >= 2 &&
    parse_int(lines[0]) >= 1 &&
    {
        let n = parse_int(lines[0]);
        let second_line_parts = split_str(lines[1], ' ');
        second_line_parts.len() >= 2 &&
        parse_int(second_line_parts[0]) >= 1 &&
        parse_int(second_line_parts[1]) >= 0 &&
        lines.len() >= 2 + n &&
        forall|i: int| 0 <= i < n ==> #[trigger] parse_int(lines[2 + i]) >= 1
    }
}

spec fn compute_expected_result(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let lines = split_str(input, '\n');
    let n = parse_int(lines[0]);
    let second_line_parts = split_str(lines[1], ' ');
    let d = parse_int(second_line_parts[0]);
    let x = parse_int(second_line_parts[1]);
    let total_eaten = sum_eaten_for_participants(lines, d, n);
    int_to_string(x + total_eaten)
}

spec fn sum_eaten_for_participants(lines: Seq<Seq<char>>, d: int, count: int) -> int 
    recommends lines.len() >= 2 + count && d >= 1 && count >= 0
    decreases count
    when count >= 0
{
    if count == 0 {
        0
    } else {
        let a = parse_int(lines[2 + count - 1]);
        let eaten = if a > 0 { (d + a - 1) / a } else { 0 };
        eaten + sum_eaten_for_participants(lines, d, count - 1)
    }
}

spec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![]
    } else {
        split_helper(s, delimiter, 0, 0, seq![])
    }
}

spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    recommends 0 <= start <= current <= s.len()
    decreases s.len() - current
    when 0 <= current <= s.len()
{
    if current == s.len() {
        if start == current {
            acc
        } else {
            acc.push(s.subrange(start, current))
        }
    } else if s[current] == delimiter {
        split_helper(s, delimiter, current + 1, current + 1, acc.push(s.subrange(start, current)))
    } else {
        split_helper(s, delimiter, start, current + 1, acc)
    }
}

spec fn parse_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else {
        parse_int_helper(s, 0, 0)
    }
}

spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int
    recommends 0 <= index <= s.len()
    decreases s.len() - index
    when 0 <= index <= s.len()
{
    if index == s.len() {
        acc
    } else if '0' <= s[index] <= '9' {
        parse_int_helper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))
    } else {
        acc
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'] + int_to_string_helper(-n)
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n > 0
    decreases n
    when n > 0
{
    if n < 10 {
        seq![(n + '0' as int) as char]
    } else {
        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        input@.len() > 0,
        valid_input(input@),
    ensures
        result@.len() > 0,
        result@ == compute_expected_result(input@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input(input: Seq<char>) -> bool ;
       spec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> ;
       spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>     recommends 0 <= start <= current <= s.len()     decreases s.len() - current     when 0 <= current <= s.len() ;
       spec fn parse_int(s: Seq<char>) -> int ;
       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;
       spec fn int_to_string(n: int) -> Seq<char> ;
       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_str(input, '\\n');\n    lines.len() >= 2 &&\n    parse_int(lines[0]) >= 1 &&\n    {\n        let n = parse_int(lines[0]);\n        let second_line_parts = split_str(lines[1], ' ');\n        second_line_parts.len() >= 2 &&\n        parse_int(second_line_parts[0]) >= 1 &&\n        parse_int(second_line_parts[1]) >= 0 &&\n        lines.len() >= 2 + n &&\n        forall|i: int| 0 <= i < n ==> #[trigger] parse_int(lines[2 + i]) >= 1\n    }\n}\n\nspec fn compute_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_str(input, '\\n');\n    let n = parse_int(lines[0]);\n    let second_line_parts = split_str(lines[1], ' ');\n    let d = parse_int(second_line_parts[0]);\n    let x = parse_int(second_line_parts[1]);\n    let total_eaten = sum_eaten_for_participants(lines, d, n);\n    int_to_string(x + total_eaten)\n}\n\nspec fn sum_eaten_for_participants(lines: Seq<Seq<char>>, d: int, count: int) -> int \n    recommends lines.len() >= 2 + count && d >= 1 && count >= 0\n    decreases count\n    when count >= 0\n{\n    if count == 0 {\n        0\n    } else {\n        let a = parse_int(lines[2 + count - 1]);\n        let eaten = if a > 0 { (d + a - 1) / a } else { 0 };\n        eaten + sum_eaten_for_participants(lines, d, count - 1)\n    }\n}\n\nspec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        split_helper(s, delimiter, 0, 0, seq![])\n    }\n}\n\nspec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    recommends 0 <= start <= current <= s.len()\n    decreases s.len() - current\n    when 0 <= current <= s.len()\n{\n    if current == s.len() {\n        if start == current {\n            acc\n        } else {\n            acc.push(s.subrange(start, current))\n        }\n    } else if s[current] == delimiter {\n        split_helper(s, delimiter, current + 1, current + 1, acc.push(s.subrange(start, current)))\n    } else {\n        split_helper(s, delimiter, start, current + 1, acc)\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        parse_int_helper(s, 0, 0)\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int\n    recommends 0 <= index <= s.len()\n    decreases s.len() - index\n    when 0 <= index <= s.len()\n{\n    if index == s.len() {\n        acc\n    } else if '0' <= s[index] <= '9' {\n        parse_int_helper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n    } else {\n        acc\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'] + int_to_string_helper(-n)\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n    when n > 0\n{\n    if n < 10 {\n        seq![(n + '0' as int) as char]\n    } else {\n        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@),\n    ensures\n        result@.len() > 0,\n        result@ == compute_expected_result(input@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool ;\n       spec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> ;\n       spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>     recommends 0 <= start <= current <= s.len()     decreases s.len() - current     when 0 <= current <= s.len() ;\n       spec fn parse_int(s: Seq<char>) -> int ;\n       spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int     recommends 0 <= index <= s.len()     decreases s.len() - index     when 0 <= index <= s.len() ;\n       spec fn int_to_string(n: int) -> Seq<char> ;\n       spec fn int_to_string_helper(n: int) -> Seq<char>     recommends n > 0     decreases n     when n > 0 ;\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4581.rs,69,69,1.0,184.683,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'o' || s[i] == 'x'
}

spec fn count_o(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == 'o' { 1int } else { 0int }) + count_o(s.subrange(1, s.len() as int))
    }
}

spec fn calculate_price(s: Seq<char>) -> int
    recommends valid_input(s)
{
    count_o(s) * 100int + 700int
}

spec fn int_to_string_spec(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 {
        seq!['0']
    } else {
        int_to_string_helper_spec(n, seq![])
    }
}

spec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>
    recommends n >= 0
    decreases n
    when n >= 0
{
    if n == 0 {
        acc
    } else {
        int_to_string_helper_spec(n / 10, seq![((n % 10) + 48) as char] + acc)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(s@)
    ensures 
        result@ == int_to_string_spec(calculate_price(s@)) + seq!['\n'],
        calculate_price(s@) >= 700
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'o' || s[i] == 'x'
}

spec fn count_o(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == 'o' { 1int } else { 0int }) + count_o(s.subrange(1, s.len() as int))
    }
}

spec fn calculate_price(s: Seq<char>) -> int
    recommends valid_input(s)
{
    count_o(s) * 100int + 700int
}

spec fn int_to_string_spec(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 {
        seq!['0']
    } else {
        int_to_string_helper_spec(n, seq![])
    }
}

spec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>
    recommends n >= 0
    decreases n
    when n >= 0
{
    if n == 0 {
        acc
    } else {
        int_to_string_helper_spec(n / 10, seq![((n % 10) + 48) as char] + acc)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(s@)
    ensures 
        result@ == int_to_string_spec(calculate_price(s@)) + seq!['\n'],
        calculate_price(s@) >= 700
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'o' || s[i] == 'x'\n}\n\nspec fn count_o(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == 'o' { 1int } else { 0int }) + count_o(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn calculate_price(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    count_o(s) * 100int + 700int\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        int_to_string_helper_spec(n, seq![])\n    }\n}\n\nspec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n\n    when n >= 0\n{\n    if n == 0 {\n        acc\n    } else {\n        int_to_string_helper_spec(n / 10, seq![((n % 10) + 48) as char] + acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@)\n    ensures \n        result@ == int_to_string_spec(calculate_price(s@)) + seq!['\\n'],\n        calculate_price(s@) >= 700\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4583.rs,77,77,1.0,153.964,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() == 5 && input.subrange(0, 4).len() == 4 &&
    (forall|i: int| 0 <= i < 4 ==> ('0' <= #[trigger] input[i] <= '9')) &&
    input[4] == '\n'
}

spec fn char_to_digit(c: char) -> int {
    (c as int) - ('0' as int)
}

spec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {
    let b_val = if op1 == '+' { b } else { -b };
    let c_val = if op2 == '+' { c } else { -c };
    let d_val = if op3 == '+' { d } else { -d };
    a + b_val + c_val + d_val
}

spec fn solution_exists(input: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& {
        let a = char_to_digit(input[0]);
        let b = char_to_digit(input[1]);
        let c = char_to_digit(input[2]);
        let d = char_to_digit(input[3]);
        exists|op1: char, op2: char, op3: char| 
            (op1 == '+' || op1 == '-') &&
            (op2 == '+' || op2 == '-') &&
            (op3 == '+' || op3 == '-') &&
            evaluate_expression(a, b, c, d, op1, op2, op3) == 7
    }
}

spec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& result.len() == 10 
    &&& result.subrange(7, 9) =~= seq!['=', '7']
    &&& result[9] == '\n'
    &&& result[0] == input[0] && result[2] == input[1] 
    &&& result[4] == input[2] && result[6] == input[3]
    &&& (result[1] == '+' || result[1] == '-')
    &&& (result[3] == '+' || result[3] == '-')
    &&& (result[5] == '+' || result[5] == '-')
    &&& {
        let a = char_to_digit(input[0]);
        let b = char_to_digit(input[1]);
        let c = char_to_digit(input[2]);
        let d = char_to_digit(input[3]);
        evaluate_expression(a, b, c, d, result[1], result[3], result[5]) == 7
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@),
        solution_exists(input@),
    ensures valid_output(result@, input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() == 5 && input.subrange(0, 4).len() == 4 &&
    (forall|i: int| 0 <= i < 4 ==> ('0' <= #[trigger] input[i] <= '9')) &&
    input[4] == '\n'
}

spec fn char_to_digit(c: char) -> int {
    (c as int) - ('0' as int)
}

spec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {
    let b_val = if op1 == '+' { b } else { -b };
    let c_val = if op2 == '+' { c } else { -c };
    let d_val = if op3 == '+' { d } else { -d };
    a + b_val + c_val + d_val
}

spec fn solution_exists(input: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& {
        let a = char_to_digit(input[0]);
        let b = char_to_digit(input[1]);
        let c = char_to_digit(input[2]);
        let d = char_to_digit(input[3]);
        exists|op1: char, op2: char, op3: char| 
            (op1 == '+' || op1 == '-') &&
            (op2 == '+' || op2 == '-') &&
            (op3 == '+' || op3 == '-') &&
            evaluate_expression(a, b, c, d, op1, op2, op3) == 7
    }
}

spec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& result.len() == 10 
    &&& result.subrange(7, 9) =~= seq!['=', '7']
    &&& result[9] == '\n'
    &&& result[0] == input[0] && result[2] == input[1] 
    &&& result[4] == input[2] && result[6] == input[3]
    &&& (result[1] == '+' || result[1] == '-')
    &&& (result[3] == '+' || result[3] == '-')
    &&& (result[5] == '+' || result[5] == '-')
    &&& {
        let a = char_to_digit(input[0]);
        let b = char_to_digit(input[1]);
        let c = char_to_digit(input[2]);
        let d = char_to_digit(input[3]);
        evaluate_expression(a, b, c, d, result[1], result[3], result[5]) == 7
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@),
        solution_exists(input@),
    ensures valid_output(result@, input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() == 5 && input.subrange(0, 4).len() == 4 &&\n    (forall|i: int| 0 <= i < 4 ==> ('0' <= #[trigger] input[i] <= '9')) &&\n    input[4] == '\\n'\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as int) - ('0' as int)\n}\n\nspec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {\n    let b_val = if op1 == '+' { b } else { -b };\n    let c_val = if op2 == '+' { c } else { -c };\n    let d_val = if op3 == '+' { d } else { -d };\n    a + b_val + c_val + d_val\n}\n\nspec fn solution_exists(input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        exists|op1: char, op2: char, op3: char| \n            (op1 == '+' || op1 == '-') &&\n            (op2 == '+' || op2 == '-') &&\n            (op3 == '+' || op3 == '-') &&\n            evaluate_expression(a, b, c, d, op1, op2, op3) == 7\n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& result.len() == 10 \n    &&& result.subrange(7, 9) =~= seq!['=', '7']\n    &&& result[9] == '\\n'\n    &&& result[0] == input[0] && result[2] == input[1] \n    &&& result[4] == input[2] && result[6] == input[3]\n    &&& (result[1] == '+' || result[1] == '-')\n    &&& (result[3] == '+' || result[3] == '-')\n    &&& (result[5] == '+' || result[5] == '-')\n    &&& {\n        let a = char_to_digit(input[0]);\n        let b = char_to_digit(input[1]);\n        let c = char_to_digit(input[2]);\n        let d = char_to_digit(input[3]);\n        evaluate_expression(a, b, c, d, result[1], result[3], result[5]) == 7\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(input@),\n        solution_exists(input@),\n    ensures valid_output(result@, input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n               fn main() {\n     }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4614.rs,84,10,0.11904761904761904,185.217,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn contains_three_space_separated_integers(input: Seq<char>) -> bool {
    exists|i: int, j: int, k: int| (0 <= i < j < k <= input.len() &&
    is_valid_integer_substring(input, 0, i) &&
    input[i] == ' ' &&
    is_valid_integer_substring(input, i+1, j) &&
    input[j] == ' ' &&
    is_valid_integer_substring(input, j+1, k) &&
    (k == input.len() || input[k] == '\n'))
}

spec fn exactly_two_are_equal(input: Seq<char>) -> bool {
    let nums = parse_three_numbers(input);
    (nums.0 == nums.1 && nums.0 != nums.2) ||
    (nums.0 == nums.2 && nums.0 != nums.1) ||
    (nums.1 == nums.2 && nums.1 != nums.0)
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    if s.len() == 0 { false }
    else if s.len() == 1 && s[0] == '0' { true }
    else if s.len() > 0 && s[0] == '-' { 
        s.len() > 1 && is_digit_sequence(s.subrange(1, s.len() as int)) && s[1] != '0'
    }
    else { is_digit_sequence(s) && s[0] != '0' }
}

spec fn is_digit_sequence(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'
}

spec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool {
    if start == end { false }
    else {
        let substr = s.subrange(start, end);
        is_valid_integer_string(substr)
    }
}

spec fn find_different_number(input: Seq<char>) -> Seq<char> {
    let nums = parse_three_numbers(input);
    let different = if nums.0 == nums.1 { nums.2 }
                    else if nums.0 == nums.2 { nums.1 }
                    else { nums.0 };
    int_to_string_pure(different)
}
spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) {
    (0, 0, 0) /* placeholder for parsing logic */
}

spec fn int_to_string_pure(n: int) -> Seq<char> {
    Seq::<char>::new(1 as nat, |i: int| '0') /* placeholder for conversion logic */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        input@.len() > 0,
        contains_three_space_separated_integers(input@),
        exactly_two_are_equal(input@),
    ensures
        result@.len() > 0,
        is_valid_integer_string(result@),
        result@ == find_different_number(input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;
       spec fn is_digit_sequence(s: Seq<char>) -> bool ;
       spec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool ;
       spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) ;
       spec fn int_to_string_pure(n: int) -> Seq<char> ;
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn contains_three_space_separated_integers(input: Seq<char>) -> bool {\n    exists|i: int, j: int, k: int| (0 <= i < j < k <= input.len() &&\n    is_valid_integer_substring(input, 0, i) &&\n    input[i] == ' ' &&\n    is_valid_integer_substring(input, i+1, j) &&\n    input[j] == ' ' &&\n    is_valid_integer_substring(input, j+1, k) &&\n    (k == input.len() || input[k] == '\\n'))\n}\n\nspec fn exactly_two_are_equal(input: Seq<char>) -> bool {\n    let nums = parse_three_numbers(input);\n    (nums.0 == nums.1 && nums.0 != nums.2) ||\n    (nums.0 == nums.2 && nums.0 != nums.1) ||\n    (nums.1 == nums.2 && nums.1 != nums.0)\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    if s.len() == 0 { false }\n    else if s.len() == 1 && s[0] == '0' { true }\n    else if s.len() > 0 && s[0] == '-' { \n        s.len() > 1 && is_digit_sequence(s.subrange(1, s.len() as int)) && s[1] != '0'\n    }\n    else { is_digit_sequence(s) && s[0] != '0' }\n}\n\nspec fn is_digit_sequence(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'\n}\n\nspec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool {\n    if start == end { false }\n    else {\n        let substr = s.subrange(start, end);\n        is_valid_integer_string(substr)\n    }\n}\n\nspec fn find_different_number(input: Seq<char>) -> Seq<char> {\n    let nums = parse_three_numbers(input);\n    let different = if nums.0 == nums.1 { nums.2 }\n                    else if nums.0 == nums.2 { nums.1 }\n                    else { nums.0 };\n    int_to_string_pure(different)\n}\nspec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) {\n    (0, 0, 0) /* placeholder for parsing logic */\n}\n\nspec fn int_to_string_pure(n: int) -> Seq<char> {\n    Seq::<char>::new(1 as nat, |i: int| '0') /* placeholder for conversion logic */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires \n        input@.len() > 0,\n        contains_three_space_separated_integers(input@),\n        exactly_two_are_equal(input@),\n    ensures\n        result@.len() > 0,\n        is_valid_integer_string(result@),\n        result@ == find_different_number(input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn is_digit_sequence(s: Seq<char>) -> bool ;\n       spec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool ;\n       spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) ;\n       spec fn int_to_string_pure(n: int) -> Seq<char> ;\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n               fn main() {\n     }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4615.rs,60,60,1.0,184.553,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {
    1 <= a < b <= 30 &&
    1 <= c < d <= 30 &&
    1 <= e <= 100 &&
    100 * a <= f <= 3000
}

spec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {
    total_mass > 0 && sugar_mass >= 0 &&
    total_mass <= f &&
    sugar_mass <= total_mass
}

spec fn density(total_mass: int, sugar_mass: int) -> int
    recommends total_mass >= 0 && sugar_mass >= 0
{
    if total_mass > 0 { (100 * sugar_mass) / total_mass } else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8) -> (result: (i8, i8))
    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)
    ensures ({
        let (total_mass, sugar_mass) = result;
        valid_solution(a as int, b as int, c as int, d as int, e as int, f as int, total_mass as int, sugar_mass as int) &&
        total_mass as int >= 0 && sugar_mass as int >= 0 &&
        total_mass as int <= f as int &&
        sugar_mass as int <= total_mass as int &&
        (exists|water_units: int| water_units > 0 && total_mass as int == #[trigger] (water_units * 100) + sugar_mass as int) &&
        (exists|water_units: int| water_units > 0 && sugar_mass as int <= #[trigger] (water_units * e as int)) &&
        (exists|i1: int, j1: int, i2: int, j2: int| 
            i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&
            i1 <= 30int / a as int && j1 <= 30int / b as int &&
            i2 <= 3000int / c as int && j2 <= 3000int / d as int &&
            total_mass as int == #[trigger] ((a as int * i1 + b as int * j1) * 100 + (c as int * i2 + d as int * j2)) &&
            sugar_mass as int == #[trigger] (c as int * i2 + d as int * j2) &&
            a as int * i1 + b as int * j1 > 0) &&
        total_mass as int > 0
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {
    1 <= a < b <= 30 &&
    1 <= c < d <= 30 &&
    1 <= e <= 100 &&
    100 * a <= f <= 3000
}

spec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {
    total_mass > 0 && sugar_mass >= 0 &&
    total_mass <= f &&
    sugar_mass <= total_mass
}

spec fn density(total_mass: int, sugar_mass: int) -> int
    recommends total_mass >= 0 && sugar_mass >= 0
{
    if total_mass > 0 { (100 * sugar_mass) / total_mass } else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8) -> (result: (i8, i8))
    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)
    ensures ({
        let (total_mass, sugar_mass) = result;
        valid_solution(a as int, b as int, c as int, d as int, e as int, f as int, total_mass as int, sugar_mass as int) &&
        total_mass as int >= 0 && sugar_mass as int >= 0 &&
        total_mass as int <= f as int &&
        sugar_mass as int <= total_mass as int &&
        (exists|water_units: int| water_units > 0 && total_mass as int == #[trigger] (water_units * 100) + sugar_mass as int) &&
        (exists|water_units: int| water_units > 0 && sugar_mass as int <= #[trigger] (water_units * e as int)) &&
        (exists|i1: int, j1: int, i2: int, j2: int| 
            i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&
            i1 <= 30int / a as int && j1 <= 30int / b as int &&
            i2 <= 3000int / c as int && j2 <= 3000int / d as int &&
            total_mass as int == #[trigger] ((a as int * i1 + b as int * j1) * 100 + (c as int * i2 + d as int * j2)) &&
            sugar_mass as int == #[trigger] (c as int * i2 + d as int * j2) &&
            a as int * i1 + b as int * j1 > 0) &&
        total_mass as int > 0
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    1 <= a < b <= 30 &&\n    1 <= c < d <= 30 &&\n    1 <= e <= 100 &&\n    100 * a <= f <= 3000\n}\n\nspec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {\n    total_mass > 0 && sugar_mass >= 0 &&\n    total_mass <= f &&\n    sugar_mass <= total_mass\n}\n\nspec fn density(total_mass: int, sugar_mass: int) -> int\n    recommends total_mass >= 0 && sugar_mass >= 0\n{\n    if total_mass > 0 { (100 * sugar_mass) / total_mass } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8) -> (result: (i8, i8))\n    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)\n    ensures ({\n        let (total_mass, sugar_mass) = result;\n        valid_solution(a as int, b as int, c as int, d as int, e as int, f as int, total_mass as int, sugar_mass as int) &&\n        total_mass as int >= 0 && sugar_mass as int >= 0 &&\n        total_mass as int <= f as int &&\n        sugar_mass as int <= total_mass as int &&\n        (exists|water_units: int| water_units > 0 && total_mass as int == #[trigger] (water_units * 100) + sugar_mass as int) &&\n        (exists|water_units: int| water_units > 0 && sugar_mass as int <= #[trigger] (water_units * e as int)) &&\n        (exists|i1: int, j1: int, i2: int, j2: int| \n            i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&\n            i1 <= 30int / a as int && j1 <= 30int / b as int &&\n            i2 <= 3000int / c as int && j2 <= 3000int / d as int &&\n            total_mass as int == #[trigger] ((a as int * i1 + b as int * j1) * 100 + (c as int * i2 + d as int * j2)) &&\n            sugar_mass as int == #[trigger] (c as int * i2 + d as int * j2) &&\n            a as int * i1 + b as int * j1 > 0) &&\n        total_mass as int > 0\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4616.rs,59,59,1.0,155.802,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
}

spec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {
    result.len() >= 3 &&
    s.len() >= 3 &&
    result[0] == s[0] &&
    result[result.len() - 1] == s[s.len() - 1] &&
    result == seq![s[0]].add(int_to_string(s.len() - 2)).add(seq![s[s.len() - 1]])
}

spec fn int_to_string(n: int) -> Seq<char>
    decreases if n >= 0 { n } else { -n }
{
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'].add(int_to_string_helper(-n))
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n >= 0
    decreases n
{
    if n <= 0 {
        Seq::new(0 as nat, |_i: int| ' ')
    } else {
        int_to_string_helper(n / 10).add(seq![(('0' as int) + (n % 10)) as char])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(s@)
    ensures valid_abbreviation(s@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
}

spec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {
    result.len() >= 3 &&
    s.len() >= 3 &&
    result[0] == s[0] &&
    result[result.len() - 1] == s[s.len() - 1] &&
    result == seq![s[0]].add(int_to_string(s.len() - 2)).add(seq![s[s.len() - 1]])
}

spec fn int_to_string(n: int) -> Seq<char>
    decreases if n >= 0 { n } else { -n }
{
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'].add(int_to_string_helper(-n))
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n >= 0
    decreases n
{
    if n <= 0 {
        Seq::new(0 as nat, |_i: int| ' ')
    } else {
        int_to_string_helper(n / 10).add(seq![(('0' as int) + (n % 10)) as char])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(s@)
    ensures valid_abbreviation(s@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 3 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'\n}\n\nspec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {\n    result.len() >= 3 &&\n    s.len() >= 3 &&\n    result[0] == s[0] &&\n    result[result.len() - 1] == s[s.len() - 1] &&\n    result == seq![s[0]].add(int_to_string(s.len() - 2)).add(seq![s[s.len() - 1]])\n}\n\nspec fn int_to_string(n: int) -> Seq<char>\n    decreases if n >= 0 { n } else { -n }\n{\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'].add(int_to_string_helper(-n))\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 {\n        Seq::new(0 as nat, |_i: int| ' ')\n    } else {\n        int_to_string_helper(n / 10).add(seq![(('0' as int) + (n % 10)) as char])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(s@)\n    ensures valid_abbreviation(s@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4617.rs,60,60,1.0,122.843,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0
}

spec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {
    reverse_seq(first_row) == second_row
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> 
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else if s[0] == '\n' {
        seq![seq![]] + split_lines(s.subrange(1, s.len() as int))
    } else {
        let rest = split_lines(s.subrange(1, s.len() as int));
        if rest.len() == 0 {
            seq![seq![s[0]]]
        } else {
            seq![rest[0].push(s[0])] + rest.subrange(1, rest.len() as int)
        }
    }
}

spec fn reverse_seq(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input@.len() > 0
    ensures result@ == ""YES\n""@ || result@ == ""NO\n""@
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO\n"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0
}

spec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {
    reverse_seq(first_row) == second_row
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> 
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else if s[0] == '\n' {
        seq![seq![]] + split_lines(s.subrange(1, s.len() as int))
    } else {
        let rest = split_lines(s.subrange(1, s.len() as int));
        if rest.len() == 0 {
            seq![seq![s[0]]]
        } else {
            seq![rest[0].push(s[0])] + rest.subrange(1, rest.len() as int)
        }
    }
}

spec fn reverse_seq(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input@.len() > 0
    ensures result@ == ""YES\n""@ || result@ == ""NO\n""@
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO\n"".to_string()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0\n}\n\nspec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {\n    reverse_seq(first_row) == second_row\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> \n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else if s[0] == \'\\n\' {\n        seq![seq![]] + split_lines(s.subrange(1, s.len() as int))\n    } else {\n        let rest = split_lines(s.subrange(1, s.len() as int));\n        if rest.len() == 0 {\n            seq![seq![s[0]]]\n        } else {\n            seq![rest[0].push(s[0])] + rest.subrange(1, rest.len() as int)\n        }\n    }\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input@.len() > 0\n    ensures result@ == ""YES\\n""@ || result@ == ""NO\\n""@\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""NO\\n"".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4635.rs,80,80,1.0,155.428,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    (exists|lines: Seq<Seq<char>>| lines == split_by_newline(input) && 
     lines.len() >= 1 && 
     is_valid_integer(lines[0]) &&
     string_to_int_val(lines[0]) >= 0 &&
     lines.len() >= string_to_int_val(lines[0]) + 1 &&
     (forall|i: int| 1 <= i <= string_to_int_val(lines[0]) && i < lines.len() ==> valid_test_case_line(lines[i])))
}

spec fn valid_test_case_line(line: Seq<char>) -> bool {
    exists|parts: Seq<Seq<char>>| (parts == split_by_space(line) &&
                    parts.len() >= 2 &&
                    is_valid_integer(parts[0]) &&
                    is_valid_integer(parts[1]) &&
                    string_to_int_val(parts[0]) > 0 &&
                    string_to_int_val(parts[1]) > 0 &&
                    string_to_int_val(parts[1]) <= 26)
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (s.len() == 1 || s[0] != '0' || s == seq!['0']) &&
    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn string_to_int_val(s: Seq<char>) -> int 
    recommends is_valid_integer(s)
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else if s.len() == 1 { 
        (s[0] as int) - 48 
    } else { 
        string_to_int_val(s.subrange(0, s.len() - 1 as int)) * 10 + ((s[s.len() - 1] as int) - 48)
    }
}

spec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool 
    recommends n > 0 && k > 0 && k <= 26
{
    output.len() == n &&
    (forall|j: int| 0 <= j < n ==> (#[trigger] output[j] == ((j % k) + 97) as char))
}

spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['a']]  /* Placeholder implementation for splitting by newlines */
}

spec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1'], seq!['2']]  /* Placeholder implementation for splitting by spaces */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures result@.len() >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    (exists|lines: Seq<Seq<char>>| lines == split_by_newline(input) && 
     lines.len() >= 1 && 
     is_valid_integer(lines[0]) &&
     string_to_int_val(lines[0]) >= 0 &&
     lines.len() >= string_to_int_val(lines[0]) + 1 &&
     (forall|i: int| 1 <= i <= string_to_int_val(lines[0]) && i < lines.len() ==> valid_test_case_line(lines[i])))
}

spec fn valid_test_case_line(line: Seq<char>) -> bool {
    exists|parts: Seq<Seq<char>>| (parts == split_by_space(line) &&
                    parts.len() >= 2 &&
                    is_valid_integer(parts[0]) &&
                    is_valid_integer(parts[1]) &&
                    string_to_int_val(parts[0]) > 0 &&
                    string_to_int_val(parts[1]) > 0 &&
                    string_to_int_val(parts[1]) <= 26)
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (s.len() == 1 || s[0] != '0' || s == seq!['0']) &&
    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn string_to_int_val(s: Seq<char>) -> int 
    recommends is_valid_integer(s)
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else if s.len() == 1 { 
        (s[0] as int) - 48 
    } else { 
        string_to_int_val(s.subrange(0, s.len() - 1 as int)) * 10 + ((s[s.len() - 1] as int) - 48)
    }
}

spec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool 
    recommends n > 0 && k > 0 && k <= 26
{
    output.len() == n &&
    (forall|j: int| 0 <= j < n ==> (#[trigger] output[j] == ((j % k) + 97) as char))
}

spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['a']]  /* Placeholder implementation for splitting by newlines */
}

spec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1'], seq!['2']]  /* Placeholder implementation for splitting by spaces */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures result@.len() >= 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    (exists|lines: Seq<Seq<char>>| lines == split_by_newline(input) && \n     lines.len() >= 1 && \n     is_valid_integer(lines[0]) &&\n     string_to_int_val(lines[0]) >= 0 &&\n     lines.len() >= string_to_int_val(lines[0]) + 1 &&\n     (forall|i: int| 1 <= i <= string_to_int_val(lines[0]) && i < lines.len() ==> valid_test_case_line(lines[i])))\n}\n\nspec fn valid_test_case_line(line: Seq<char>) -> bool {\n    exists|parts: Seq<Seq<char>>| (parts == split_by_space(line) &&\n                    parts.len() >= 2 &&\n                    is_valid_integer(parts[0]) &&\n                    is_valid_integer(parts[1]) &&\n                    string_to_int_val(parts[0]) > 0 &&\n                    string_to_int_val(parts[1]) > 0 &&\n                    string_to_int_val(parts[1]) <= 26)\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s.len() == 1 || s[0] != '0' || s == seq!['0']) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')\n}\n\nspec fn string_to_int_val(s: Seq<char>) -> int \n    recommends is_valid_integer(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0 \n    } else if s.len() == 1 { \n        (s[0] as int) - 48 \n    } else { \n        string_to_int_val(s.subrange(0, s.len() - 1 as int)) * 10 + ((s[s.len() - 1] as int) - 48)\n    }\n}\n\nspec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool \n    recommends n > 0 && k > 0 && k <= 26\n{\n    output.len() == n &&\n    (forall|j: int| 0 <= j < n ==> (#[trigger] output[j] == ((j % k) + 97) as char))\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']]  /* Placeholder implementation for splitting by newlines */\n}\n\nspec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1'], seq!['2']]  /* Placeholder implementation for splitting by spaces */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures result@.len() >= 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {\n      }\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4676.rs,92,92,1.0,155.644,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 &&
    {
        let o = lines[0];
        let e = lines[1];
        let a = o.len();
        let b = e.len();
        (a == b || a == b + 1) &&
        (a > 0 || b == 0)
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    /* Helper function to split input by newlines */
    seq![]  /* Placeholder - would need actual implementation */
}

spec fn get_o(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    split_lines(input)[0]
}

spec fn get_e(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    split_lines(input)[1]
}

spec fn correct_result(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let o = get_o(input);
    let e = get_e(input);
    let a = o.len();
    let b = e.len();
    if a == b {
        interleave_equal(o, e)
    } else {
        interleave_unequal(o, e)
    }
}

spec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>
    recommends o.len() == e.len()
    decreases o.len()
{
    if o.len() == 0 {
        seq![]
    } else {
        seq![o[0], e[0]] + interleave_equal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))
    }
}

spec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>
    recommends o.len() == e.len() + 1
    decreases e.len()
{
    if e.len() == 0 {
        o
    } else {
        seq![o[0], e[0]] + interleave_unequal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@ == correct_result(input@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 &&
    {
        let o = lines[0];
        let e = lines[1];
        let a = o.len();
        let b = e.len();
        (a == b || a == b + 1) &&
        (a > 0 || b == 0)
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    /* Helper function to split input by newlines */
    seq![]  /* Placeholder - would need actual implementation */
}

spec fn get_o(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    split_lines(input)[0]
}

spec fn get_e(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    split_lines(input)[1]
}

spec fn correct_result(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let o = get_o(input);
    let e = get_e(input);
    let a = o.len();
    let b = e.len();
    if a == b {
        interleave_equal(o, e)
    } else {
        interleave_unequal(o, e)
    }
}

spec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>
    recommends o.len() == e.len()
    decreases o.len()
{
    if o.len() == 0 {
        seq![]
    } else {
        seq![o[0], e[0]] + interleave_equal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))
    }
}

spec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>
    recommends o.len() == e.len() + 1
    decreases e.len()
{
    if e.len() == 0 {
        o
    } else {
        seq![o[0], e[0]] + interleave_unequal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@ == correct_result(input@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    {\n        let o = lines[0];\n        let e = lines[1];\n        let a = o.len();\n        let b = e.len();\n        (a == b || a == b + 1) &&\n        (a > 0 || b == 0)\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    /* Helper function to split input by newlines */\n    seq![]  /* Placeholder - would need actual implementation */\n}\n\nspec fn get_o(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[0]\n}\n\nspec fn get_e(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    split_lines(input)[1]\n}\n\nspec fn correct_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let o = get_o(input);\n    let e = get_e(input);\n    let a = o.len();\n    let b = e.len();\n    if a == b {\n        interleave_equal(o, e)\n    } else {\n        interleave_unequal(o, e)\n    }\n}\n\nspec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len()\n    decreases o.len()\n{\n    if o.len() == 0 {\n        seq![]\n    } else {\n        seq![o[0], e[0]] + interleave_equal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n\nspec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>\n    recommends o.len() == e.len() + 1\n    decreases e.len()\n{\n    if e.len() == 0 {\n        o\n    } else {\n        seq![o[0], e[0]] + interleave_unequal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures result@ == correct_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4677.rs,56,56,1.0,124.236,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && s.len() <= 10 && 
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1' || s[i] == 'B'
}

spec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>
    decreases keystrokes.len()
{
    if keystrokes.len() == 0 {
        Seq::<char>::empty()
    } else {
        let prev = simulate_keystrokes(keystrokes.subrange(0, keystrokes.len() - 1));
        let last_key = keystrokes[keystrokes.len() - 1];
        if last_key == 'B' {
            if prev.len() > 0 {
                prev.subrange(0, prev.len() - 1)
            } else {
                prev
            }
        } else {
            prev.push(last_key)
        }
    }
}

spec fn valid_output(result: Seq<char>) -> bool {
    forall|i: int| 0 <= i < result.len() ==> result[i] == '0' || result[i] == '1'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(s@),
    ensures 
        valid_output(result@),
        result@ == simulate_keystrokes(s@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && s.len() <= 10 && 
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1' || s[i] == 'B'
}

spec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>
    decreases keystrokes.len()
{
    if keystrokes.len() == 0 {
        Seq::<char>::empty()
    } else {
        let prev = simulate_keystrokes(keystrokes.subrange(0, keystrokes.len() - 1));
        let last_key = keystrokes[keystrokes.len() - 1];
        if last_key == 'B' {
            if prev.len() > 0 {
                prev.subrange(0, prev.len() - 1)
            } else {
                prev
            }
        } else {
            prev.push(last_key)
        }
    }
}

spec fn valid_output(result: Seq<char>) -> bool {
    forall|i: int| 0 <= i < result.len() ==> result[i] == '0' || result[i] == '1'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(s@),
    ensures 
        valid_output(result@),
        result@ == simulate_keystrokes(s@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 10 && \n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1' || s[i] == 'B'\n}\n\nspec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>\n    decreases keystrokes.len()\n{\n    if keystrokes.len() == 0 {\n        Seq::<char>::empty()\n    } else {\n        let prev = simulate_keystrokes(keystrokes.subrange(0, keystrokes.len() - 1));\n        let last_key = keystrokes[keystrokes.len() - 1];\n        if last_key == 'B' {\n            if prev.len() > 0 {\n                prev.subrange(0, prev.len() - 1)\n            } else {\n                prev\n            }\n        } else {\n            prev.push(last_key)\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < result.len() ==> result[i] == '0' || result[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        valid_input(s@),\n    ensures \n        valid_output(result@),\n        result@ == simulate_keystrokes(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_470.rs,59,59,1.0,123.101,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(cards: Seq<int>) -> bool {
    cards.len() == 5 && forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0
}

spec fn sum(cards: Seq<int>) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else {
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int 
    decreases index when index >= 0
{
    if index <= 0 {
        sum(cards)
    } else {
        min_possible_sum_up_to_index(cards, index - 1)
    }
}

spec fn min_possible_sum(cards: Seq<int>) -> int {
    min_possible_sum_up_to_index(cards, 5)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(cards: Vec<i8>) -> (result: i8)
    requires 
        valid_input(cards@.map(|_index, x: i8| x as int)),
    ensures 
        result >= 0,
        result as int <= sum(cards@.map(|_index, x: i8| x as int)),
        result as int == min_possible_sum(cards@.map(|_index, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(cards: Seq<int>) -> bool {
    cards.len() == 5 && forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0
}

spec fn sum(cards: Seq<int>) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else {
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int 
    decreases index when index >= 0
{
    if index <= 0 {
        sum(cards)
    } else {
        min_possible_sum_up_to_index(cards, index - 1)
    }
}

spec fn min_possible_sum(cards: Seq<int>) -> int {
    min_possible_sum_up_to_index(cards, 5)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(cards: Vec<i8>) -> (result: i8)
    requires 
        valid_input(cards@.map(|_index, x: i8| x as int)),
    ensures 
        result >= 0,
        result as int <= sum(cards@.map(|_index, x: i8| x as int)),
        result as int == min_possible_sum(cards@.map(|_index, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(cards: Seq<int>) -> bool {\n    cards.len() == 5 && forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0\n}\n\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int \n    decreases index when index >= 0\n{\n    if index <= 0 {\n        sum(cards)\n    } else {\n        min_possible_sum_up_to_index(cards, index - 1)\n    }\n}\n\nspec fn min_possible_sum(cards: Seq<int>) -> int {\n    min_possible_sum_up_to_index(cards, 5)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(cards@.map(|_index, x: i8| x as int)),\n    ensures \n        result >= 0,\n        result as int <= sum(cards@.map(|_index, x: i8| x as int)),\n        result as int == min_possible_sum(cards@.map(|_index, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4713.rs,53,53,1.0,92.299,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn max_value(s: Seq<char>) -> int {
    max_value_up_to_index(s, s.len() as int)
}

spec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int
    decreases up_to when 0 <= up_to <= s.len()
{
    if up_to == 0 { 0 }
    else {
        let current_value = current_value_at_index(s, up_to);
        let max_before = max_value_up_to_index(s, up_to - 1);
        if current_value > max_before { current_value } else { max_before }
    }
}

spec fn current_value_at_index(s: Seq<char>, index: int) -> int
    decreases index when 0 <= index <= s.len()
{
    if index == 0 { 0 }
    else { 
        current_value_at_index(s, index - 1) + (if s[index - 1 as nat] == 'I' { 1 } else { -1 })
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, s: Vec<char>) -> (result: i8)
    requires 
        1 <= n <= 100,
        n as int == s@.len(),
        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'I' || s@[i] == 'D',
    ensures 
        result >= 0,
        result as int == max_value(s@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn max_value(s: Seq<char>) -> int {
    max_value_up_to_index(s, s.len() as int)
}

spec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int
    decreases up_to when 0 <= up_to <= s.len()
{
    if up_to == 0 { 0 }
    else {
        let current_value = current_value_at_index(s, up_to);
        let max_before = max_value_up_to_index(s, up_to - 1);
        if current_value > max_before { current_value } else { max_before }
    }
}

spec fn current_value_at_index(s: Seq<char>, index: int) -> int
    decreases index when 0 <= index <= s.len()
{
    if index == 0 { 0 }
    else { 
        current_value_at_index(s, index - 1) + (if s[index - 1 as nat] == 'I' { 1 } else { -1 })
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, s: Vec<char>) -> (result: i8)
    requires 
        1 <= n <= 100,
        n as int == s@.len(),
        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'I' || s@[i] == 'D',
    ensures 
        result >= 0,
        result as int == max_value(s@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_value(s: Seq<char>) -> int {\n    max_value_up_to_index(s, s.len() as int)\n}\n\nspec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int\n    decreases up_to when 0 <= up_to <= s.len()\n{\n    if up_to == 0 { 0 }\n    else {\n        let current_value = current_value_at_index(s, up_to);\n        let max_before = max_value_up_to_index(s, up_to - 1);\n        if current_value > max_before { current_value } else { max_before }\n    }\n}\n\nspec fn current_value_at_index(s: Seq<char>, index: int) -> int\n    decreases index when 0 <= index <= s.len()\n{\n    if index == 0 { 0 }\n    else { \n        current_value_at_index(s, index - 1) + (if s[index - 1 as nat] == 'I' { 1 } else { -1 })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, s: Vec<char>) -> (result: i8)\n    requires \n        1 <= n <= 100,\n        n as int == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'I' || s@[i] == 'D',\n    ensures \n        result >= 0,\n        result as int == max_value(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_4715.rs,55,55,1.0,122.253,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100
}

spec fn count_distinct_colors(a: int, b: int, c: int) -> int {
    if a == b && b == c { 1 }
    else if a == b || b == c || a == c { 2 }
    else { 3 }
}

spec fn all_same(a: int, b: int, c: int) -> bool {
    a == b && b == c
}

spec fn exactly_two_same(a: int, b: int, c: int) -> bool {
    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)
}

spec fn all_different(a: int, b: int, c: int) -> bool {
    a != b && b != c && a != c
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int)
    ensures 
        1 <= result as int <= 3,
        result as int == count_distinct_colors(a as int, b as int, c as int),
        result as int == 1 <==> all_same(a as int, b as int, c as int),
        result as int == 2 <==> exactly_two_same(a as int, b as int, c as int),
        result as int == 3 <==> all_different(a as int, b as int, c as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100
}

spec fn count_distinct_colors(a: int, b: int, c: int) -> int {
    if a == b && b == c { 1 }
    else if a == b || b == c || a == c { 2 }
    else { 3 }
}

spec fn all_same(a: int, b: int, c: int) -> bool {
    a == b && b == c
}

spec fn exactly_two_same(a: int, b: int, c: int) -> bool {
    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)
}

spec fn all_different(a: int, b: int, c: int) -> bool {
    a != b && b != c && a != c
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int)
    ensures 
        1 <= result as int <= 3,
        result as int == count_distinct_colors(a as int, b as int, c as int),
        result as int == 1 <==> all_same(a as int, b as int, c as int),
        result as int == 2 <==> exactly_two_same(a as int, b as int, c as int),
        result as int == 3 <==> all_different(a as int, b as int, c as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nspec fn count_distinct_colors(a: int, b: int, c: int) -> int {\n    if a == b && b == c { 1 }\n    else if a == b || b == c || a == c { 2 }\n    else { 3 }\n}\n\nspec fn all_same(a: int, b: int, c: int) -> bool {\n    a == b && b == c\n}\n\nspec fn exactly_two_same(a: int, b: int, c: int) -> bool {\n    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)\n}\n\nspec fn all_different(a: int, b: int, c: int) -> bool {\n    a != b && b != c && a != c\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int)\n    ensures \n        1 <= result as int <= 3,\n        result as int == count_distinct_colors(a as int, b as int, c as int),\n        result as int == 1 <==> all_same(a as int, b as int, c as int),\n        result as int == 2 <==> exactly_two_same(a as int, b as int, c as int),\n        result as int == 3 <==> all_different(a as int, b as int, c as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_473.rs,95,95,1.0,92.389,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_time_format(time_str: Seq<char>) -> bool {
    time_str.len() == 5 &&
    time_str[2] == ':' &&
    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&
    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&
    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&
    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59
}

spec fn find_first_newline(s: Seq<char>) -> int {
    choose|i: int| 0 <= i < s.len() && s[i] == '\n'
}

spec fn find_second_newline(s: Seq<char>, first: int) -> int {
    choose|i: int| first < i < s.len() && s[i] == '\n'
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n' &&
    exists|i: int, j: int| 0 <= i < j < stdin_input.len() && stdin_input[i] == '\n' && stdin_input[j] == '\n' &&
    {
        let first_nl = find_first_newline(stdin_input);
        let second_nl = find_second_newline(stdin_input, first_nl);
        let s = stdin_input.subrange(0, first_nl);
        let t = stdin_input.subrange(first_nl + 1, second_nl);
        valid_time_format(s) && valid_time_format(t)
    }
}

spec fn parse_time(time_str: Seq<char>) -> (int, int) {
    let h = (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);
    let m = (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);
    (h, m)
}

spec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {
    let wake_total_min = wake_hour * 60 + wake_min;
    let sleep_total_min = sleep_hour * 60 + sleep_min;
    let diff = wake_total_min - sleep_total_min;
    let bed_total_min = if diff >= 0 { diff } else { diff + 24 * 60 };
    (bed_total_min / 60, bed_total_min % 60)
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() == 6 &&
    result[result.len() - 1] == '\n' &&
    result[2] == ':' &&
    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&
    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&
    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&
    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59
}

spec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {
    let first_nl = find_first_newline(stdin_input);
    let second_nl = find_second_newline(stdin_input, first_nl);
    let s = stdin_input.subrange(0, first_nl);
    let t = stdin_input.subrange(first_nl + 1, second_nl);
    let (wake_hour, wake_min) = parse_time(s);
    let (sleep_hour, sleep_min) = parse_time(t);
    let (bed_hour, bed_min) = calculate_bedtime(wake_hour, wake_min, sleep_hour, sleep_min);
    let result_hour = (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);
    let result_min = (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);
    result_hour == bed_hour && result_min == bed_min
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        valid_output(result@) &&
        correct_bedtime(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_time_format(time_str: Seq<char>) -> bool {
    time_str.len() == 5 &&
    time_str[2] == ':' &&
    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&
    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&
    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&
    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59
}

spec fn find_first_newline(s: Seq<char>) -> int {
    choose|i: int| 0 <= i < s.len() && s[i] == '\n'
}

spec fn find_second_newline(s: Seq<char>, first: int) -> int {
    choose|i: int| first < i < s.len() && s[i] == '\n'
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n' &&
    exists|i: int, j: int| 0 <= i < j < stdin_input.len() && stdin_input[i] == '\n' && stdin_input[j] == '\n' &&
    {
        let first_nl = find_first_newline(stdin_input);
        let second_nl = find_second_newline(stdin_input, first_nl);
        let s = stdin_input.subrange(0, first_nl);
        let t = stdin_input.subrange(first_nl + 1, second_nl);
        valid_time_format(s) && valid_time_format(t)
    }
}

spec fn parse_time(time_str: Seq<char>) -> (int, int) {
    let h = (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);
    let m = (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);
    (h, m)
}

spec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {
    let wake_total_min = wake_hour * 60 + wake_min;
    let sleep_total_min = sleep_hour * 60 + sleep_min;
    let diff = wake_total_min - sleep_total_min;
    let bed_total_min = if diff >= 0 { diff } else { diff + 24 * 60 };
    (bed_total_min / 60, bed_total_min % 60)
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() == 6 &&
    result[result.len() - 1] == '\n' &&
    result[2] == ':' &&
    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&
    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&
    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&
    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59
}

spec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {
    let first_nl = find_first_newline(stdin_input);
    let second_nl = find_second_newline(stdin_input, first_nl);
    let s = stdin_input.subrange(0, first_nl);
    let t = stdin_input.subrange(first_nl + 1, second_nl);
    let (wake_hour, wake_min) = parse_time(s);
    let (sleep_hour, sleep_min) = parse_time(t);
    let (bed_hour, bed_min) = calculate_bedtime(wake_hour, wake_min, sleep_hour, sleep_min);
    let result_hour = (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);
    let result_min = (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);
    result_hour == bed_hour && result_min == bed_min
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        valid_output(result@) &&
        correct_bedtime(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_time_format(time_str: Seq<char>) -> bool {\n    time_str.len() == 5 &&\n    time_str[2] == ':' &&\n    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&\n    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&\n    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&\n    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int {\n    choose|i: int| 0 <= i < s.len() && s[i] == '\\n'\n}\n\nspec fn find_second_newline(s: Seq<char>, first: int) -> int {\n    choose|i: int| first < i < s.len() && s[i] == '\\n'\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\\n' &&\n    exists|i: int, j: int| 0 <= i < j < stdin_input.len() && stdin_input[i] == '\\n' && stdin_input[j] == '\\n' &&\n    {\n        let first_nl = find_first_newline(stdin_input);\n        let second_nl = find_second_newline(stdin_input, first_nl);\n        let s = stdin_input.subrange(0, first_nl);\n        let t = stdin_input.subrange(first_nl + 1, second_nl);\n        valid_time_format(s) && valid_time_format(t)\n    }\n}\n\nspec fn parse_time(time_str: Seq<char>) -> (int, int) {\n    let h = (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);\n    let m = (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);\n    (h, m)\n}\n\nspec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {\n    let wake_total_min = wake_hour * 60 + wake_min;\n    let sleep_total_min = sleep_hour * 60 + sleep_min;\n    let diff = wake_total_min - sleep_total_min;\n    let bed_total_min = if diff >= 0 { diff } else { diff + 24 * 60 };\n    (bed_total_min / 60, bed_total_min % 60)\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() == 6 &&\n    result[result.len() - 1] == '\\n' &&\n    result[2] == ':' &&\n    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&\n    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&\n    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&\n    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59\n}\n\nspec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let first_nl = find_first_newline(stdin_input);\n    let second_nl = find_second_newline(stdin_input, first_nl);\n    let s = stdin_input.subrange(0, first_nl);\n    let t = stdin_input.subrange(first_nl + 1, second_nl);\n    let (wake_hour, wake_min) = parse_time(s);\n    let (sleep_hour, sleep_min) = parse_time(t);\n    let (bed_hour, bed_min) = calculate_bedtime(wake_hour, wake_min, sleep_hour, sleep_min);\n    let result_hour = (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);\n    let result_min = (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);\n    result_hour == bed_hour && result_min == bed_min\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        valid_output(result@) &&\n        correct_bedtime(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_475.rs,58,58,1.0,92.077,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat, m: nat, k: nat) -> bool {
    n >= 1 && m >= 1 && k >= 0 && k <= n - 1
}

spec fn factorial(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 }
    else { n * factorial((n - 1) as nat) }
}

spec fn binomial(n: nat, k: nat) -> nat
    decreases n
{
    if k > n { 0 }
    else if factorial(k) == 0 || factorial((n - k) as nat) == 0 { 0 }
    else { factorial(n) / (factorial(k) * factorial((n - k) as nat)) }
}

spec fn power(base: nat, exp: nat) -> nat
    decreases exp
{
    if exp == 0 { 1 }
    else { base * power(base, (exp - 1) as nat) }
}

spec fn expected_result(n: nat, m: nat, k: nat) -> nat {
    if valid_input(n, m, k) {
        (m * power((m - 1) as nat, k) * binomial((n - 1) as nat, k)) % 998244353
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u64, m: u64, k: u64) -> (result: u64)
    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1
    ensures result < 998244353
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat, m: nat, k: nat) -> bool {
    n >= 1 && m >= 1 && k >= 0 && k <= n - 1
}

spec fn factorial(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 }
    else { n * factorial((n - 1) as nat) }
}

spec fn binomial(n: nat, k: nat) -> nat
    decreases n
{
    if k > n { 0 }
    else if factorial(k) == 0 || factorial((n - k) as nat) == 0 { 0 }
    else { factorial(n) / (factorial(k) * factorial((n - k) as nat)) }
}

spec fn power(base: nat, exp: nat) -> nat
    decreases exp
{
    if exp == 0 { 1 }
    else { base * power(base, (exp - 1) as nat) }
}

spec fn expected_result(n: nat, m: nat, k: nat) -> nat {
    if valid_input(n, m, k) {
        (m * power((m - 1) as nat, k) * binomial((n - 1) as nat, k)) % 998244353
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u64, m: u64, k: u64) -> (result: u64)
    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1
    ensures result < 998244353
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: nat, m: nat, k: nat) -> bool {\n    n >= 1 && m >= 1 && k >= 0 && k <= n - 1\n}\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 }\n    else { n * factorial((n - 1) as nat) }\n}\n\nspec fn binomial(n: nat, k: nat) -> nat\n    decreases n\n{\n    if k > n { 0 }\n    else if factorial(k) == 0 || factorial((n - k) as nat) == 0 { 0 }\n    else { factorial(n) / (factorial(k) * factorial((n - k) as nat)) }\n}\n\nspec fn power(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { 1 }\n    else { base * power(base, (exp - 1) as nat) }\n}\n\nspec fn expected_result(n: nat, m: nat, k: nat) -> nat {\n    if valid_input(n, m, k) {\n        (m * power((m - 1) as nat, k) * binomial((n - 1) as nat, k)) % 998244353\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: u64, m: u64, k: u64) -> (result: u64)\n    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1\n    ensures result < 998244353\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_48.rs,54,54,1.0,92.48,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_less_value(n: int, m: int, target: int) -> int
  decreases n
{
  if n <= 0 {
    0
  } else {
    let max_j = (target - 1) / n;
    let actual_max_j = if max_j > m { m } else { max_j };
    let contribution = if actual_max_j >= 1 { actual_max_j } else { 0 };
    contribution + count_less_value(n - 1, m, target)
  }
}

spec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {
  if target <= 0 {
    0
  } else if target >= n * m {
    n * m
  } else {
    count_less_value(n, m, target + 1)
  }
}

spec fn valid_input(n: int, m: int, k: int) -> bool {
  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8) -> (result: i8)
  requires valid_input(n as int, m as int, k as int)
  ensures 
    1 <= result as int <= (n as int) * (m as int),
    count_less_or_equal_value(n as int, m as int, result as int) >= k as int,
    result as int == 1 || count_less_or_equal_value(n as int, m as int, (result as int) - 1) < k as int
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_less_value(n: int, m: int, target: int) -> int
  decreases n
{
  if n <= 0 {
    0
  } else {
    let max_j = (target - 1) / n;
    let actual_max_j = if max_j > m { m } else { max_j };
    let contribution = if actual_max_j >= 1 { actual_max_j } else { 0 };
    contribution + count_less_value(n - 1, m, target)
  }
}

spec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {
  if target <= 0 {
    0
  } else if target >= n * m {
    n * m
  } else {
    count_less_value(n, m, target + 1)
  }
}

spec fn valid_input(n: int, m: int, k: int) -> bool {
  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8) -> (result: i8)
  requires valid_input(n as int, m as int, k as int)
  ensures 
    1 <= result as int <= (n as int) * (m as int),
    count_less_or_equal_value(n as int, m as int, result as int) >= k as int,
    result as int == 1 || count_less_or_equal_value(n as int, m as int, (result as int) - 1) < k as int
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn count_less_value(n: int, m: int, target: int) -> int\n  decreases n\n{\n  if n <= 0 {\n    0\n  } else {\n    let max_j = (target - 1) / n;\n    let actual_max_j = if max_j > m { m } else { max_j };\n    let contribution = if actual_max_j >= 1 { actual_max_j } else { 0 };\n    contribution + count_less_value(n - 1, m, target)\n  }\n}\n\nspec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {\n  if target <= 0 {\n    0\n  } else if target >= n * m {\n    n * m\n  } else {\n    count_less_value(n, m, target + 1)\n  }\n}\n\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8, k: i8) -> (result: i8)\n  requires valid_input(n as int, m as int, k as int)\n  ensures \n    1 <= result as int <= (n as int) * (m as int),\n    count_less_or_equal_value(n as int, m as int, result as int) >= k as int,\n    result as int == 1 || count_less_or_equal_value(n as int, m as int, (result as int) - 1) < k as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_483.rs,64,64,1.0,122.537,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {
    n >= 1 &&
    directions.len() == n &&
    positions.len() == n &&
    (forall|i: int| 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&
    (forall|i: int| 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> positions[i] < positions[j])
}

spec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {
    0 <= i < directions.len()-1 && 
    directions[i] == 'R' && directions[i+1] == 'L'
}

spec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool 
    recommends directions.len() == positions.len()
{
    exists|i: int| #[trigger] has_collision_pair(i, directions)
}

spec fn collision_time(i: int, positions: Seq<int>) -> int
    recommends 0 <= i < positions.len()-1
{
    (positions[i+1] - positions[i]) / 2
}

spec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool
    recommends directions.len() == positions.len()
{
    (forall|i: int| has_collision_pair(i, directions) ==> 
        collision_time(i, positions) >= result) &&
    (exists|i: int| #[trigger] has_collision_pair(i, directions) && 
        collision_time(i, positions) == result)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, directions: Vec<char>, positions: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, directions@, positions@.map(|i: int, v: i8| v as int)),
    ensures 
        result == -1 || result >= 0,
        result != -1 ==> has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),
        result == -1 ==> !has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),
        result != -1 ==> is_minimal_collision_time(result as int, directions@, positions@.map(|i: int, v: i8| v as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {
    n >= 1 &&
    directions.len() == n &&
    positions.len() == n &&
    (forall|i: int| 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&
    (forall|i: int| 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> positions[i] < positions[j])
}

spec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {
    0 <= i < directions.len()-1 && 
    directions[i] == 'R' && directions[i+1] == 'L'
}

spec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool 
    recommends directions.len() == positions.len()
{
    exists|i: int| #[trigger] has_collision_pair(i, directions)
}

spec fn collision_time(i: int, positions: Seq<int>) -> int
    recommends 0 <= i < positions.len()-1
{
    (positions[i+1] - positions[i]) / 2
}

spec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool
    recommends directions.len() == positions.len()
{
    (forall|i: int| has_collision_pair(i, directions) ==> 
        collision_time(i, positions) >= result) &&
    (exists|i: int| #[trigger] has_collision_pair(i, directions) && 
        collision_time(i, positions) == result)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, directions: Vec<char>, positions: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, directions@, positions@.map(|i: int, v: i8| v as int)),
    ensures 
        result == -1 || result >= 0,
        result != -1 ==> has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),
        result == -1 ==> !has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),
        result != -1 ==> is_minimal_collision_time(result as int, directions@, positions@.map(|i: int, v: i8| v as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {\n    n >= 1 &&\n    directions.len() == n &&\n    positions.len() == n &&\n    (forall|i: int| 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&\n    (forall|i: int| 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> positions[i] < positions[j])\n}\n\nspec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {\n    0 <= i < directions.len()-1 && \n    directions[i] == 'R' && directions[i+1] == 'L'\n}\n\nspec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool \n    recommends directions.len() == positions.len()\n{\n    exists|i: int| #[trigger] has_collision_pair(i, directions)\n}\n\nspec fn collision_time(i: int, positions: Seq<int>) -> int\n    recommends 0 <= i < positions.len()-1\n{\n    (positions[i+1] - positions[i]) / 2\n}\n\nspec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool\n    recommends directions.len() == positions.len()\n{\n    (forall|i: int| has_collision_pair(i, directions) ==> \n        collision_time(i, positions) >= result) &&\n    (exists|i: int| #[trigger] has_collision_pair(i, directions) && \n        collision_time(i, positions) == result)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, directions: Vec<char>, positions: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n    ensures \n        result == -1 || result >= 0,\n        result != -1 ==> has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result == -1 ==> !has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),\n        result != -1 ==> is_minimal_collision_time(result as int, directions@, positions@.map(|i: int, v: i8| v as int)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_484.rs,74,74,1.0,122.58,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int
{
    let orientations = seq![(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];

    let area0 = if can_fit(orientations[0].0, orientations[0].1, a, b) {
        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1
    } else {
        0
    };

    let area1 = if can_fit(orientations[1].0, orientations[1].1, a, b) {
        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1
    } else {
        0
    };

    let area2 = if can_fit(orientations[2].0, orientations[2].1, a, b) {
        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1
    } else {
        0
    };

    let area3 = if can_fit(orientations[3].0, orientations[3].1, a, b) {
        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1
    } else {
        0
    };

    max_spec(max_spec(area0, area1), max_spec(area2, area3))
}

spec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool
{
    (r1.0 + r2.0 <= a && max_spec(r1.1, r2.1) <= b) || (max_spec(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)
}

spec fn max_spec(x: int, y: int) -> int
{
    if x >= y { x } else { y }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, seals: Vec<(i8, i8)>) -> (result: i8)
    requires n >= 0,
            a >= 1 && b >= 1,
            seals.len() == n as nat,
            forall|i: int| 0 <= i < n as int ==> seals@[i].0 as int >= 1 && seals@[i].1 as int >= 1,
    ensures result as int >= 0,
            result as int == 0 ==> (forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == 0),
            result as int > 0 ==> (exists|i: int, j: int| 0 <= i < n as int && i < j < n as int && check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == result as int),
            forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) <= result as int,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int
{
    let orientations = seq![(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];

    let area0 = if can_fit(orientations[0].0, orientations[0].1, a, b) {
        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1
    } else {
        0
    };

    let area1 = if can_fit(orientations[1].0, orientations[1].1, a, b) {
        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1
    } else {
        0
    };

    let area2 = if can_fit(orientations[2].0, orientations[2].1, a, b) {
        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1
    } else {
        0
    };

    let area3 = if can_fit(orientations[3].0, orientations[3].1, a, b) {
        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1
    } else {
        0
    };

    max_spec(max_spec(area0, area1), max_spec(area2, area3))
}

spec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool
{
    (r1.0 + r2.0 <= a && max_spec(r1.1, r2.1) <= b) || (max_spec(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)
}

spec fn max_spec(x: int, y: int) -> int
{
    if x >= y { x } else { y }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: i8, b: i8, seals: Vec<(i8, i8)>) -> (result: i8)
    requires n >= 0,
            a >= 1 && b >= 1,
            seals.len() == n as nat,
            forall|i: int| 0 <= i < n as int ==> seals@[i].0 as int >= 1 && seals@[i].1 as int >= 1,
    ensures result as int >= 0,
            result as int == 0 ==> (forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == 0),
            result as int > 0 ==> (exists|i: int, j: int| 0 <= i < n as int && i < j < n as int && check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == result as int),
            forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) <= result as int,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int\n{\n    let orientations = seq![(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];\n\n    let area0 = if can_fit(orientations[0].0, orientations[0].1, a, b) {\n        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1\n    } else {\n        0\n    };\n\n    let area1 = if can_fit(orientations[1].0, orientations[1].1, a, b) {\n        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1\n    } else {\n        0\n    };\n\n    let area2 = if can_fit(orientations[2].0, orientations[2].1, a, b) {\n        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1\n    } else {\n        0\n    };\n\n    let area3 = if can_fit(orientations[3].0, orientations[3].1, a, b) {\n        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1\n    } else {\n        0\n    };\n\n    max_spec(max_spec(area0, area1), max_spec(area2, area3))\n}\n\nspec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool\n{\n    (r1.0 + r2.0 <= a && max_spec(r1.1, r2.1) <= b) || (max_spec(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)\n}\n\nspec fn max_spec(x: int, y: int) -> int\n{\n    if x >= y { x } else { y }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: i8, b: i8, seals: Vec<(i8, i8)>) -> (result: i8)\n    requires n >= 0,\n            a >= 1 && b >= 1,\n            seals.len() == n as nat,\n            forall|i: int| 0 <= i < n as int ==> seals@[i].0 as int >= 1 && seals@[i].1 as int >= 1,\n    ensures result as int >= 0,\n            result as int == 0 ==> (forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == 0),\n            result as int > 0 ==> (exists|i: int, j: int| 0 <= i < n as int && i < j < n as int && check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == result as int),\n            forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) <= result as int,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_486.rs,52,52,1.0,92.229,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn product_of_digits(x: int) -> int
  recommends x >= 0
  decreases x
{
  if x == 0 { 1 }
  else if x < 10 { x }
  else { (x % 10) * product_of_digits(x / 10) }
}

spec fn max_product_of_digits_in_range(n: int) -> int
  recommends n >= 1
  decreases n
  when n >= 1
{
  if n == 1 { 1 }
  else {
    let current = product_of_digits(n);
    let rest = max_product_of_digits_in_range(n - 1);
    if current > rest { current } else { rest }
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
  requires 
    n >= 1
  ensures 
    result as int == max_product_of_digits_in_range(n as int),
    result >= 1,
    forall|k: int| 1 <= k <= n as int ==> product_of_digits(k) <= result as int,
    exists|k: int| 1 <= k <= n as int && product_of_digits(k) == result as int
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn product_of_digits(x: int) -> int
  recommends x >= 0
  decreases x
{
  if x == 0 { 1 }
  else if x < 10 { x }
  else { (x % 10) * product_of_digits(x / 10) }
}

spec fn max_product_of_digits_in_range(n: int) -> int
  recommends n >= 1
  decreases n
  when n >= 1
{
  if n == 1 { 1 }
  else {
    let current = product_of_digits(n);
    let rest = max_product_of_digits_in_range(n - 1);
    if current > rest { current } else { rest }
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
  requires 
    n >= 1
  ensures 
    result as int == max_product_of_digits_in_range(n as int),
    result >= 1,
    forall|k: int| 1 <= k <= n as int ==> product_of_digits(k) <= result as int,
    exists|k: int| 1 <= k <= n as int && product_of_digits(k) == result as int
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn product_of_digits(x: int) -> int\n  recommends x >= 0\n  decreases x\n{\n  if x == 0 { 1 }\n  else if x < 10 { x }\n  else { (x % 10) * product_of_digits(x / 10) }\n}\n\nspec fn max_product_of_digits_in_range(n: int) -> int\n  recommends n >= 1\n  decreases n\n  when n >= 1\n{\n  if n == 1 { 1 }\n  else {\n    let current = product_of_digits(n);\n    let rest = max_product_of_digits_in_range(n - 1);\n    if current > rest { current } else { rest }\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n  requires \n    n >= 1\n  ensures \n    result as int == max_product_of_digits_in_range(n as int),\n    result >= 1,\n    forall|k: int| 1 <= k <= n as int ==> product_of_digits(k) <= result as int,\n    exists|k: int| 1 <= k <= n as int && product_of_digits(k) == result as int\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_506.rs,51,51,1.0,122.393,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    a > 0 && b > 0
}

spec fn count_squares(a: int, b: int) -> int
    recommends a >= 0 && b >= 0
    decreases a + b when a > 0 && b > 0
{
    if a == 0 || b == 0 {
        0
    } else if a > b {
        if b == 0 { 0 } else {
            a / b + count_squares(a % b, b)
        }
    } else if b > a {
        if a == 0 { 0 } else {
            b / a + count_squares(a, b % a)
        }
    } else {
        1
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8) -> (result: i8)
    requires valid_input(a as int, b as int)
    ensures 
        result >= 0,
        a == b ==> result == 1,
        a > b ==> result >= 1,
        result as int == count_squares(a as int, b as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    a > 0 && b > 0
}

spec fn count_squares(a: int, b: int) -> int
    recommends a >= 0 && b >= 0
    decreases a + b when a > 0 && b > 0
{
    if a == 0 || b == 0 {
        0
    } else if a > b {
        if b == 0 { 0 } else {
            a / b + count_squares(a % b, b)
        }
    } else if b > a {
        if a == 0 { 0 } else {
            b / a + count_squares(a, b % a)
        }
    } else {
        1
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8) -> (result: i8)
    requires valid_input(a as int, b as int)
    ensures 
        result >= 0,
        a == b ==> result == 1,
        a > b ==> result >= 1,
        result as int == count_squares(a as int, b as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n    a > 0 && b > 0\n}\n\nspec fn count_squares(a: int, b: int) -> int\n    recommends a >= 0 && b >= 0\n    decreases a + b when a > 0 && b > 0\n{\n    if a == 0 || b == 0 {\n        0\n    } else if a > b {\n        if b == 0 { 0 } else {\n            a / b + count_squares(a % b, b)\n        }\n    } else if b > a {\n        if a == 0 { 0 } else {\n            b / a + count_squares(a, b % a)\n        }\n    } else {\n        1\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: i8)\n    requires valid_input(a as int, b as int)\n    ensures \n        result >= 0,\n        a == b ==> result == 1,\n        a > b ==> result >= 1,\n        result as int == count_squares(a as int, b as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_511.rs,55,55,1.0,122.612,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == ' ') &&
    (forall|j: int| 0 <= j < input.len() ==> 
        ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\n'))
}

spec fn gcd(a: nat, b: nat) -> nat 
    decreases a + b
{
    if a == 0 { b }
    else if b == 0 { a }
    else if a > b { gcd((a - b) as nat, b) }
    else { gcd(a, (b - a) as nat) }
}

#[verifier::opaque]
spec fn f_mathematical(x: nat, y: nat) -> nat
    decreases y
{
    y / 2
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 &&
    (forall|i: int| 0 <= i < result.len() ==> 
        ('0' <= result[i] <= '9' || result[i] == '\n')) &&
    result[result.len() - 1] == '\n'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == ' ') &&
    (forall|j: int| 0 <= j < input.len() ==> 
        ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\n'))
}

spec fn gcd(a: nat, b: nat) -> nat 
    decreases a + b
{
    if a == 0 { b }
    else if b == 0 { a }
    else if a > b { gcd((a - b) as nat, b) }
    else { gcd(a, (b - a) as nat) }
}

#[verifier::opaque]
spec fn f_mathematical(x: nat, y: nat) -> nat
    decreases y
{
    y / 2
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 &&
    (forall|i: int| 0 <= i < result.len() ==> 
        ('0' <= result[i] <= '9' || result[i] == '\n')) &&
    result[result.len() - 1] == '\n'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == ' ') &&\n    (forall|j: int| 0 <= j < input.len() ==> \n        ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\\n'))\n}\n\nspec fn gcd(a: nat, b: nat) -> nat \n    decreases a + b\n{\n    if a == 0 { b }\n    else if b == 0 { a }\n    else if a > b { gcd((a - b) as nat, b) }\n    else { gcd(a, (b - a) as nat) }\n}\n\n#[verifier::opaque]\nspec fn f_mathematical(x: nat, y: nat) -> nat\n    decreases y\n{\n    y / 2\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (forall|i: int| 0 <= i < result.len() ==> \n        ('0' <= result[i] <= '9' || result[i] == '\\n')) &&\n    result[result.len() - 1] == '\\n'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_529.rs,111,111,1.0,92.271,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>, n: int) -> bool {
  0 <= n <= 26
}

spec fn get_comparison_char(n: int) -> char {
  if n == 0 { 'a' }
  else if n == 1 { 'b' }
  else if n == 2 { 'c' }
  else if n == 3 { 'd' }
  else if n == 4 { 'e' }
  else if n == 5 { 'f' }
  else if n == 6 { 'g' }
  else if n == 7 { 'h' }
  else if n == 8 { 'i' }
  else if n == 9 { 'j' }
  else if n == 10 { 'k' }
  else if n == 11 { 'l' }
  else if n == 12 { 'm' }
  else if n == 13 { 'n' }
  else if n == 14 { 'o' }
  else if n == 15 { 'p' }
  else if n == 16 { 'q' }
  else if n == 17 { 'r' }
  else if n == 18 { 's' }
  else if n == 19 { 't' }
  else if n == 20 { 'u' }
  else if n == 21 { 'v' }
  else if n == 22 { 'w' }
  else if n == 23 { 'x' }
  else if n == 24 { 'y' }
  else if n == 25 { 'z' }
  else { '|' }
}

spec fn is_lowercase(c: char) -> bool {
  'a' <= c && c <= 'z'
}

spec fn is_uppercase(c: char) -> bool {
  'A' <= c && c <= 'Z'
}

spec fn to_lowercase(c: char) -> char {
  if is_uppercase(c) {
    ((c as u8) - ('A' as u8) + ('a' as u8)) as char
  } else {
    c
  }
}

spec fn to_uppercase(c: char) -> char {
  if is_lowercase(c) {
    ((c as u8) - ('a' as u8) + ('A' as u8)) as char
  } else {
    c
  }
}

spec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {
  let comp_char = get_comparison_char(n);
  transform_with_comp_char(to_lowercase_string(s), comp_char)
}

spec fn to_lowercase_string(s: Seq<char>) -> Seq<char>
  decreases s.len()
{
  if s.len() == 0 {
    s
  } else {
    s.subrange(0, 1).map(|_i: int, c: char| to_lowercase(c)) + to_lowercase_string(s.skip(1))
  }
}

spec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>
  decreases s.len()
{
  if s.len() == 0 {
    s
  } else if s[0] < comp_char {
    s.subrange(0, 1).map(|_i: int, c: char| to_uppercase(c)) + transform_with_comp_char(s.skip(1), comp_char)
  } else {
    s.subrange(0, 1) + transform_with_comp_char(s.skip(1), comp_char)
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>, n: i8) -> (result: Vec<char>)
  requires valid_input(s@, n as int)
  ensures result@ == transform_string(s@, n as int)
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  s
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>, n: int) -> bool {
  0 <= n <= 26
}

spec fn get_comparison_char(n: int) -> char {
  if n == 0 { 'a' }
  else if n == 1 { 'b' }
  else if n == 2 { 'c' }
  else if n == 3 { 'd' }
  else if n == 4 { 'e' }
  else if n == 5 { 'f' }
  else if n == 6 { 'g' }
  else if n == 7 { 'h' }
  else if n == 8 { 'i' }
  else if n == 9 { 'j' }
  else if n == 10 { 'k' }
  else if n == 11 { 'l' }
  else if n == 12 { 'm' }
  else if n == 13 { 'n' }
  else if n == 14 { 'o' }
  else if n == 15 { 'p' }
  else if n == 16 { 'q' }
  else if n == 17 { 'r' }
  else if n == 18 { 's' }
  else if n == 19 { 't' }
  else if n == 20 { 'u' }
  else if n == 21 { 'v' }
  else if n == 22 { 'w' }
  else if n == 23 { 'x' }
  else if n == 24 { 'y' }
  else if n == 25 { 'z' }
  else { '|' }
}

spec fn is_lowercase(c: char) -> bool {
  'a' <= c && c <= 'z'
}

spec fn is_uppercase(c: char) -> bool {
  'A' <= c && c <= 'Z'
}

spec fn to_lowercase(c: char) -> char {
  if is_uppercase(c) {
    ((c as u8) - ('A' as u8) + ('a' as u8)) as char
  } else {
    c
  }
}

spec fn to_uppercase(c: char) -> char {
  if is_lowercase(c) {
    ((c as u8) - ('a' as u8) + ('A' as u8)) as char
  } else {
    c
  }
}

spec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {
  let comp_char = get_comparison_char(n);
  transform_with_comp_char(to_lowercase_string(s), comp_char)
}

spec fn to_lowercase_string(s: Seq<char>) -> Seq<char>
  decreases s.len()
{
  if s.len() == 0 {
    s
  } else {
    s.subrange(0, 1).map(|_i: int, c: char| to_lowercase(c)) + to_lowercase_string(s.skip(1))
  }
}

spec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>
  decreases s.len()
{
  if s.len() == 0 {
    s
  } else if s[0] < comp_char {
    s.subrange(0, 1).map(|_i: int, c: char| to_uppercase(c)) + transform_with_comp_char(s.skip(1), comp_char)
  } else {
    s.subrange(0, 1) + transform_with_comp_char(s.skip(1), comp_char)
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>, n: i8) -> (result: Vec<char>)
  requires valid_input(s@, n as int)
  ensures result@ == transform_string(s@, n as int)
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  s
  // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>, n: int) -> bool {\n  0 <= n <= 26\n}\n\nspec fn get_comparison_char(n: int) -> char {\n  if n == 0 { 'a' }\n  else if n == 1 { 'b' }\n  else if n == 2 { 'c' }\n  else if n == 3 { 'd' }\n  else if n == 4 { 'e' }\n  else if n == 5 { 'f' }\n  else if n == 6 { 'g' }\n  else if n == 7 { 'h' }\n  else if n == 8 { 'i' }\n  else if n == 9 { 'j' }\n  else if n == 10 { 'k' }\n  else if n == 11 { 'l' }\n  else if n == 12 { 'm' }\n  else if n == 13 { 'n' }\n  else if n == 14 { 'o' }\n  else if n == 15 { 'p' }\n  else if n == 16 { 'q' }\n  else if n == 17 { 'r' }\n  else if n == 18 { 's' }\n  else if n == 19 { 't' }\n  else if n == 20 { 'u' }\n  else if n == 21 { 'v' }\n  else if n == 22 { 'w' }\n  else if n == 23 { 'x' }\n  else if n == 24 { 'y' }\n  else if n == 25 { 'z' }\n  else { '|' }\n}\n\nspec fn is_lowercase(c: char) -> bool {\n  'a' <= c && c <= 'z'\n}\n\nspec fn is_uppercase(c: char) -> bool {\n  'A' <= c && c <= 'Z'\n}\n\nspec fn to_lowercase(c: char) -> char {\n  if is_uppercase(c) {\n    ((c as u8) - ('A' as u8) + ('a' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn to_uppercase(c: char) -> char {\n  if is_lowercase(c) {\n    ((c as u8) - ('a' as u8) + ('A' as u8)) as char\n  } else {\n    c\n  }\n}\n\nspec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {\n  let comp_char = get_comparison_char(n);\n  transform_with_comp_char(to_lowercase_string(s), comp_char)\n}\n\nspec fn to_lowercase_string(s: Seq<char>) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else {\n    s.subrange(0, 1).map(|_i: int, c: char| to_lowercase(c)) + to_lowercase_string(s.skip(1))\n  }\n}\n\nspec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>\n  decreases s.len()\n{\n  if s.len() == 0 {\n    s\n  } else if s[0] < comp_char {\n    s.subrange(0, 1).map(|_i: int, c: char| to_uppercase(c)) + transform_with_comp_char(s.skip(1), comp_char)\n  } else {\n    s.subrange(0, 1) + transform_with_comp_char(s.skip(1), comp_char)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>, n: i8) -> (result: Vec<char>)\n  requires valid_input(s@, n as int)\n  ensures result@ == transform_string(s@, n as int)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  s\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_530.rs,50,50,1.0,122.727,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {
    n > 0 && a.len() == 2 * n && b.len() == 2 * n &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] == '0' || a[i] == '1') &&
    (forall|i: int| 0 <= i < b.len() ==> b[i] == '0' || b[i] == '1')
}

spec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int
    recommends len >= 0 && len <= a.len() && len <= b.len(),
               ac == '0' || ac == '1',
               bc == '0' || bc == '1'
{
    Set::new(|i: int| 0 <= i < len && a[i] == ac && b[i] == bc).len() as int
}

spec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {
    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2
}

spec fn correct_outcome(result: &str, d: int) -> bool {
    (d > 0 ==> result == ""First"") &&
    (d < 0 ==> result == ""Second"") &&
    (d == 0 ==> result == ""Draw"")
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<char>, b: Vec<char>) -> (result: &'static str)
    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&
             (forall|i: int| 0 <= i < a@.len() ==> a@[i] == '0' || a@[i] == '1') &&
             (forall|i: int| 0 <= i < b@.len() ==> b@[i] == '0' || b@[i] == '1')
    ensures result == ""First"" || result == ""Second"" || result == ""Draw""
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""Draw""
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {
    n > 0 && a.len() == 2 * n && b.len() == 2 * n &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] == '0' || a[i] == '1') &&
    (forall|i: int| 0 <= i < b.len() ==> b[i] == '0' || b[i] == '1')
}

spec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int
    recommends len >= 0 && len <= a.len() && len <= b.len(),
               ac == '0' || ac == '1',
               bc == '0' || bc == '1'
{
    Set::new(|i: int| 0 <= i < len && a[i] == ac && b[i] == bc).len() as int
}

spec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {
    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2
}

spec fn correct_outcome(result: &str, d: int) -> bool {
    (d > 0 ==> result == ""First"") &&
    (d < 0 ==> result == ""Second"") &&
    (d == 0 ==> result == ""Draw"")
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<char>, b: Vec<char>) -> (result: &'static str)
    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&
             (forall|i: int| 0 <= i < a@.len() ==> a@[i] == '0' || a@[i] == '1') &&
             (forall|i: int| 0 <= i < b@.len() ==> b@[i] == '0' || b@[i] == '1')
    ensures result == ""First"" || result == ""Second"" || result == ""Draw""
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""Draw""
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {\n    n > 0 && a.len() == 2 * n && b.len() == 2 * n &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] == \'0\' || a[i] == \'1\') &&\n    (forall|i: int| 0 <= i < b.len() ==> b[i] == \'0\' || b[i] == \'1\')\n}\n\nspec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int\n    recommends len >= 0 && len <= a.len() && len <= b.len(),\n               ac == \'0\' || ac == \'1\',\n               bc == \'0\' || bc == \'1\'\n{\n    Set::new(|i: int| 0 <= i < len && a[i] == ac && b[i] == bc).len() as int\n}\n\nspec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {\n    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2\n}\n\nspec fn correct_outcome(result: &str, d: int) -> bool {\n    (d > 0 ==> result == ""First"") &&\n    (d < 0 ==> result == ""Second"") &&\n    (d == 0 ==> result == ""Draw"")\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<char>, b: Vec<char>) -> (result: &\'static str)\n    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&\n             (forall|i: int| 0 <= i < a@.len() ==> a@[i] == \'0\' || a@[i] == \'1\') &&\n             (forall|i: int| 0 <= i < b@.len() ==> b@[i] == \'0\' || b@[i] == \'1\')\n    ensures result == ""First"" || result == ""Second"" || result == ""Draw""\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""Draw""\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_533.rs,61,61,1.0,93.005,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {
    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1
}

spec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int
    recommends valid_input(a1, a2, k1, k2, n)
{
    let max_non_sendoff_cards = (k1 - 1) * a1 + (k2 - 1) * a2;
    if n - max_non_sendoff_cards > 0 { n - max_non_sendoff_cards } else { 0 }
}

spec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int
    recommends valid_input(a1, a2, k1, k2, n)
{
    if k1 < k2 {
        let team1_sent = if n / k1 < a1 { n / k1 } else { a1 };
        let remaining_cards = n - team1_sent * k1;
        team1_sent + remaining_cards / k2
    } else {
        let team2_sent = if n / k2 < a2 { n / k2 } else { a2 };
        let remaining_cards = n - team2_sent * k2;
        team2_sent + remaining_cards / k1
    }
}

spec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool
    recommends valid_input(a1, a2, k1, k2, n)
{
    minimum >= 0 && maximum >= 0 &&
    minimum <= maximum &&
    maximum <= a1 + a2 &&
    minimum <= n &&
    maximum <= n &&
    minimum == minimum_sent_off(a1, a2, k1, k2, n) &&
    maximum == maximum_sent_off(a1, a2, k1, k2, n)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a1: i8, a2: i8, k1: i8, k2: i8, n: i8) -> (ret: (i8, i8))
    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)
    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {
    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1
}

spec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int
    recommends valid_input(a1, a2, k1, k2, n)
{
    let max_non_sendoff_cards = (k1 - 1) * a1 + (k2 - 1) * a2;
    if n - max_non_sendoff_cards > 0 { n - max_non_sendoff_cards } else { 0 }
}

spec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int
    recommends valid_input(a1, a2, k1, k2, n)
{
    if k1 < k2 {
        let team1_sent = if n / k1 < a1 { n / k1 } else { a1 };
        let remaining_cards = n - team1_sent * k1;
        team1_sent + remaining_cards / k2
    } else {
        let team2_sent = if n / k2 < a2 { n / k2 } else { a2 };
        let remaining_cards = n - team2_sent * k2;
        team2_sent + remaining_cards / k1
    }
}

spec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool
    recommends valid_input(a1, a2, k1, k2, n)
{
    minimum >= 0 && maximum >= 0 &&
    minimum <= maximum &&
    maximum <= a1 + a2 &&
    minimum <= n &&
    maximum <= n &&
    minimum == minimum_sent_off(a1, a2, k1, k2, n) &&
    maximum == maximum_sent_off(a1, a2, k1, k2, n)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a1: i8, a2: i8, k1: i8, k2: i8, n: i8) -> (ret: (i8, i8))
    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)
    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {\n    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1\n}\n\nspec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    let max_non_sendoff_cards = (k1 - 1) * a1 + (k2 - 1) * a2;\n    if n - max_non_sendoff_cards > 0 { n - max_non_sendoff_cards } else { 0 }\n}\n\nspec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    if k1 < k2 {\n        let team1_sent = if n / k1 < a1 { n / k1 } else { a1 };\n        let remaining_cards = n - team1_sent * k1;\n        team1_sent + remaining_cards / k2\n    } else {\n        let team2_sent = if n / k2 < a2 { n / k2 } else { a2 };\n        let remaining_cards = n - team2_sent * k2;\n        team2_sent + remaining_cards / k1\n    }\n}\n\nspec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool\n    recommends valid_input(a1, a2, k1, k2, n)\n{\n    minimum >= 0 && maximum >= 0 &&\n    minimum <= maximum &&\n    maximum <= a1 + a2 &&\n    minimum <= n &&\n    maximum <= n &&\n    minimum == minimum_sent_off(a1, a2, k1, k2, n) &&\n    maximum == maximum_sent_off(a1, a2, k1, k2, n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a1: i8, a2: i8, k1: i8, k2: i8, n: i8) -> (ret: (i8, i8))\n    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)\n    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_553.rs,61,61,1.0,92.272,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![s]
}

spec fn parse_integer(s: Seq<char>) -> int {
    6
}

spec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {
    if s1 == s2 { 0 } else { 6 }
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {
    output.len() >= 2 &&
    output[output.len() - 1] == '\n' &&
    ({
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        ({
            let n: int = 6;
            n >= 1 && 
            n == 6 &&
            lines.len() >= 1 &&
            ({
                let k: int = 6;
                0 <= k <= 6 &&
                k == 6 &&
                parse_integer(output.subrange(0, output.len() - 1)) == k
            })
        })
    })
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)
    requires valid_input(stdin_input@.map_values(|x: u8| x as char))
    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![s]
}

spec fn parse_integer(s: Seq<char>) -> int {
    6
}

spec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {
    if s1 == s2 { 0 } else { 6 }
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {
    output.len() >= 2 &&
    output[output.len() - 1] == '\n' &&
    ({
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        ({
            let n: int = 6;
            n >= 1 && 
            n == 6 &&
            lines.len() >= 1 &&
            ({
                let k: int = 6;
                0 <= k <= 6 &&
                k == 6 &&
                parse_integer(output.subrange(0, output.len() - 1)) == k
            })
        })
    })
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)
    requires valid_input(stdin_input@.map_values(|x: u8| x as char))
    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_integer(s: Seq<char>) -> int {\n    6\n}\n\nspec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {\n    if s1 == s2 { 0 } else { 6 }\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {\n    output.len() >= 2 &&\n    output[output.len() - 1] == '\\n' &&\n    ({\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        ({\n            let n: int = 6;\n            n >= 1 && \n            n == 6 &&\n            lines.len() >= 1 &&\n            ({\n                let k: int = 6;\n                0 <= k <= 6 &&\n                k == 6 &&\n                parse_integer(output.subrange(0, output.len() - 1)) == k\n            })\n        })\n    })\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)\n    requires valid_input(stdin_input@.map_values(|x: u8| x as char))\n    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_584.rs,182,182,1.0,92.205,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_letter(c: char) -> bool {
    ('a' <= c <= 'z') || ('A' <= c <= 'Z')
}

spec fn valid_parentheses(input: Seq<char>) -> bool {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        true
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        is_valid_parentheses_sequence(s, 0, 0)
    }
}

spec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool
    recommends 0 <= pos <= s.len(), balance >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        balance == 0
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            balance - 1 
        } else { 
            balance 
        };
        new_balance >= 0 && is_valid_parentheses_sequence(s, pos + 1, new_balance)
    }
}

spec fn longest_word_outside(input: Seq<char>) -> int {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        0
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        compute_longest_outside(s, 0, 0, 0, 0)
    }
}

spec fn count_words_inside(input: Seq<char>) -> int {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        0
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        compute_count_inside(s, 0, 0, 0)
    }
}

spec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {
    len_out >= 0 && count_in >= 0 &&
    len_out == longest_word_outside(input) &&
    count_in == count_words_inside(input)
}

spec fn find_newline(input: Seq<char>) -> int {
    find_newline_helper(input, 0)
}

spec fn find_newline_helper(input: Seq<char>, pos: int) -> int
    recommends 0 <= pos <= input.len()
    decreases input.len() - pos
{
    if pos >= input.len() {
        pos
    } else if input[pos] == '\n' {
        pos
    } else {
        find_newline_helper(input, pos + 1)
    }
}

spec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int
    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        if cur > best && balance == 0 { cur } else { best }
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            if balance > 0 { balance - 1 } else { 0 }
        } else { 
            balance 
        };
        let new_cur = if is_letter(c) { 
            cur + 1
        } else if cur > 0 { 
            0
        } else { 
            cur 
        };
        let new_best = if !is_letter(c) && cur > 0 && balance == 0 {
            if cur > best { cur } else { best }
        } else { 
            best 
        };
        compute_longest_outside(s, pos + 1, new_balance, new_cur, new_best)
    }
}

spec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int
    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        0
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            if balance > 0 { balance - 1 } else { 0 }
        } else { 
            balance 
        };
        let new_cur = if is_letter(c) { 
            cur + 1
        } else if cur > 0 { 
            0
        } else { 
            cur 
        };
        let word_ended = !is_letter(c) && cur > 0;
        let count_increment: int = if word_ended && balance > 0 { 1 } else { 0 };
        count_increment + compute_count_inside(s, pos + 1, new_balance, new_cur)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: (usize, usize))
    requires
        input@.len() > 0,
        exists|i: int| 0 <= i < input@.len() && input@[i] == '\n',
        forall|i: int| 0 <= i < input@.len() ==> (is_letter(input@[i]) || input@[i] == '_' || input@[i] == '(' || input@[i] == ')' || input@[i] == '\n' || input@[i] == '\r' || ('0' <= input@[i] <= '9')),
        valid_parentheses(input@)
    ensures
        result.0 >= 0 && result.1 >= 0,
        result.0 as int == longest_word_outside(input@),
        result.1 as int == count_words_inside(input@),
        valid_output(input@, result.0 as int, result.1 as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    (0, 0)
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_letter(c: char) -> bool {
    ('a' <= c <= 'z') || ('A' <= c <= 'Z')
}

spec fn valid_parentheses(input: Seq<char>) -> bool {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        true
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        is_valid_parentheses_sequence(s, 0, 0)
    }
}

spec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool
    recommends 0 <= pos <= s.len(), balance >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        balance == 0
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            balance - 1 
        } else { 
            balance 
        };
        new_balance >= 0 && is_valid_parentheses_sequence(s, pos + 1, new_balance)
    }
}

spec fn longest_word_outside(input: Seq<char>) -> int {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        0
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        compute_longest_outside(s, 0, 0, 0, 0)
    }
}

spec fn count_words_inside(input: Seq<char>) -> int {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        0
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        compute_count_inside(s, 0, 0, 0)
    }
}

spec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {
    len_out >= 0 && count_in >= 0 &&
    len_out == longest_word_outside(input) &&
    count_in == count_words_inside(input)
}

spec fn find_newline(input: Seq<char>) -> int {
    find_newline_helper(input, 0)
}

spec fn find_newline_helper(input: Seq<char>, pos: int) -> int
    recommends 0 <= pos <= input.len()
    decreases input.len() - pos
{
    if pos >= input.len() {
        pos
    } else if input[pos] == '\n' {
        pos
    } else {
        find_newline_helper(input, pos + 1)
    }
}

spec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int
    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        if cur > best && balance == 0 { cur } else { best }
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            if balance > 0 { balance - 1 } else { 0 }
        } else { 
            balance 
        };
        let new_cur = if is_letter(c) { 
            cur + 1
        } else if cur > 0 { 
            0
        } else { 
            cur 
        };
        let new_best = if !is_letter(c) && cur > 0 && balance == 0 {
            if cur > best { cur } else { best }
        } else { 
            best 
        };
        compute_longest_outside(s, pos + 1, new_balance, new_cur, new_best)
    }
}

spec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int
    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        0
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            if balance > 0 { balance - 1 } else { 0 }
        } else { 
            balance 
        };
        let new_cur = if is_letter(c) { 
            cur + 1
        } else if cur > 0 { 
            0
        } else { 
            cur 
        };
        let word_ended = !is_letter(c) && cur > 0;
        let count_increment: int = if word_ended && balance > 0 { 1 } else { 0 };
        count_increment + compute_count_inside(s, pos + 1, new_balance, new_cur)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: (usize, usize))
    requires
        input@.len() > 0,
        exists|i: int| 0 <= i < input@.len() && input@[i] == '\n',
        forall|i: int| 0 <= i < input@.len() ==> (is_letter(input@[i]) || input@[i] == '_' || input@[i] == '(' || input@[i] == ')' || input@[i] == '\n' || input@[i] == '\r' || ('0' <= input@[i] <= '9')),
        valid_parentheses(input@)
    ensures
        result.0 >= 0 && result.1 >= 0,
        result.0 as int == longest_word_outside(input@),
        result.1 as int == count_words_inside(input@),
        valid_output(input@, result.0 as int, result.1 as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    (0, 0)
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_letter(c: char) -> bool {\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\nspec fn valid_parentheses(input: Seq<char>) -> bool {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        true\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        is_valid_parentheses_sequence(s, 0, 0)\n    }\n}\n\nspec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool\n    recommends 0 <= pos <= s.len(), balance >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        balance == 0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            balance - 1 \n        } else { \n            balance \n        };\n        new_balance >= 0 && is_valid_parentheses_sequence(s, pos + 1, new_balance)\n    }\n}\n\nspec fn longest_word_outside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_longest_outside(s, 0, 0, 0, 0)\n    }\n}\n\nspec fn count_words_inside(input: Seq<char>) -> int {\n    let newline_pos = find_newline(input);\n    if newline_pos >= input.len() {\n        0\n    } else {\n        let s = if newline_pos + 1 < input.len() { \n            input.subrange(newline_pos + 1, input.len() as int) \n        } else { \n            seq![] \n        };\n        compute_count_inside(s, 0, 0, 0)\n    }\n}\n\nspec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {\n    len_out >= 0 && count_in >= 0 &&\n    len_out == longest_word_outside(input) &&\n    count_in == count_words_inside(input)\n}\n\nspec fn find_newline(input: Seq<char>) -> int {\n    find_newline_helper(input, 0)\n}\n\nspec fn find_newline_helper(input: Seq<char>, pos: int) -> int\n    recommends 0 <= pos <= input.len()\n    decreases input.len() - pos\n{\n    if pos >= input.len() {\n        pos\n    } else if input[pos] == '\\n' {\n        pos\n    } else {\n        find_newline_helper(input, pos + 1)\n    }\n}\n\nspec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        if cur > best && balance == 0 { cur } else { best }\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let new_best = if !is_letter(c) && cur > 0 && balance == 0 {\n            if cur > best { cur } else { best }\n        } else { \n            best \n        };\n        compute_longest_outside(s, pos + 1, new_balance, new_cur, new_best)\n    }\n}\n\nspec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int\n    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0\n    decreases s.len() - pos\n{\n    if pos >= s.len() {\n        0\n    } else {\n        let c = s[pos];\n        let new_balance = if c == '(' { \n            balance + 1 \n        } else if c == ')' { \n            if balance > 0 { balance - 1 } else { 0 }\n        } else { \n            balance \n        };\n        let new_cur = if is_letter(c) { \n            cur + 1\n        } else if cur > 0 { \n            0\n        } else { \n            cur \n        };\n        let word_ended = !is_letter(c) && cur > 0;\n        let count_increment: int = if word_ended && balance > 0 { 1 } else { 0 };\n        count_increment + compute_count_inside(s, pos + 1, new_balance, new_cur)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: (usize, usize))\n    requires\n        input@.len() > 0,\n        exists|i: int| 0 <= i < input@.len() && input@[i] == '\\n',\n        forall|i: int| 0 <= i < input@.len() ==> (is_letter(input@[i]) || input@[i] == '_' || input@[i] == '(' || input@[i] == ')' || input@[i] == '\\n' || input@[i] == '\\r' || ('0' <= input@[i] <= '9')),\n        valid_parentheses(input@)\n    ensures\n        result.0 >= 0 && result.1 >= 0,\n        result.0 as int == longest_word_outside(input@),\n        result.1 as int == count_words_inside(input@),\n        valid_output(input@, result.0 as int, result.1 as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_59.rs,58,58,1.0,123.211,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {
    n >= 2 &&
    a.len() == n &&
    p.len() == n - 1 &&
    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] == '0' || #[trigger] p[i] == '1') &&
    (forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= n) &&
    a.to_set() =~= Set::new(|i: int| 1 <= i <= n)
}

spec fn max_up_to(a: Seq<int>, i: int) -> int
    recommends 0 <= i < a.len()
    decreases i when i >= 0
{
    if i == 0 { 
        a[0] 
    } else if i > 0 && a[i] > max_up_to(a, i-1) { 
        a[i] 
    } else if i > 0 { 
        max_up_to(a, i-1) 
    } else {
        a[0]
    }
}

spec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool
    recommends valid_input(n, a, p)
{
    forall|i: int| 0 <= i < n - 1 ==> 
        (#[trigger] p[i] == '0' ==> max_up_to(a, i) <= i + 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>, p: Vec<char>) -> (result: String)
    requires
        valid_input(n as int, a@.map(|i, x| x as int), p@),
    ensures
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        (result@ == seq!['Y', 'E', 'S']) <==> can_sort(n as int, a@.map(|i, x| x as int), p@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {
    n >= 2 &&
    a.len() == n &&
    p.len() == n - 1 &&
    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] == '0' || #[trigger] p[i] == '1') &&
    (forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= n) &&
    a.to_set() =~= Set::new(|i: int| 1 <= i <= n)
}

spec fn max_up_to(a: Seq<int>, i: int) -> int
    recommends 0 <= i < a.len()
    decreases i when i >= 0
{
    if i == 0 { 
        a[0] 
    } else if i > 0 && a[i] > max_up_to(a, i-1) { 
        a[i] 
    } else if i > 0 { 
        max_up_to(a, i-1) 
    } else {
        a[0]
    }
}

spec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool
    recommends valid_input(n, a, p)
{
    forall|i: int| 0 <= i < n - 1 ==> 
        (#[trigger] p[i] == '0' ==> max_up_to(a, i) <= i + 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>, p: Vec<char>) -> (result: String)
    requires
        valid_input(n as int, a@.map(|i, x| x as int), p@),
    ensures
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        (result@ == seq!['Y', 'E', 'S']) <==> can_sort(n as int, a@.map(|i, x| x as int), p@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {\n    n >= 2 &&\n    a.len() == n &&\n    p.len() == n - 1 &&\n    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] == '0' || #[trigger] p[i] == '1') &&\n    (forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= n) &&\n    a.to_set() =~= Set::new(|i: int| 1 <= i <= n)\n}\n\nspec fn max_up_to(a: Seq<int>, i: int) -> int\n    recommends 0 <= i < a.len()\n    decreases i when i >= 0\n{\n    if i == 0 { \n        a[0] \n    } else if i > 0 && a[i] > max_up_to(a, i-1) { \n        a[i] \n    } else if i > 0 { \n        max_up_to(a, i-1) \n    } else {\n        a[0]\n    }\n}\n\nspec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool\n    recommends valid_input(n, a, p)\n{\n    forall|i: int| 0 <= i < n - 1 ==> \n        (#[trigger] p[i] == '0' ==> max_up_to(a, i) <= i + 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>, p: Vec<char>) -> (result: String)\n    requires\n        valid_input(n as int, a@.map(|i, x| x as int), p@),\n    ensures\n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> can_sort(n as int, a@.map(|i, x| x as int), p@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\n   fn main() {\n }\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_613.rs,59,59,1.0,92.29,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(t: int, a: int, b: int) -> bool {
    t > 0 && a > 0 && b > 0
}

spec fn valid_output(res: String) -> bool {
    res@ == ""0""@ || res@ == ""1""@ || res@ == ""2""@ || res@ == ""inf""@
}

spec fn infinite_case(t: int, a: int, b: int) -> bool {
    a == t && a == b && a == 1
}

spec fn two_solutions_case(t: int, a: int, b: int) -> bool {
    a == t && a == b && a != 1
}

spec fn zero_solutions_case(t: int, a: int, b: int) -> bool {
    (t == 2 && a == 3 && b > 10000) ||
    (a == t && a != b) ||
    (a != t && (a - b) % (t - a) == 0) ||
    (a != t && (a - b) % (t - a) != 0 && t == b)
}

spec fn one_solution_case(t: int, a: int, b: int) -> bool {
    a != t && (a - b) % (t - a) != 0 && t != b
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(t: i8, a: i8, b: i8) -> (res: String)
    requires 
        valid_input(t as int, a as int, b as int),
    ensures 
        valid_output(res),
        infinite_case(t as int, a as int, b as int) ==> res@ == ""inf""@,
        two_solutions_case(t as int, a as int, b as int) ==> res@ == ""2""@,
        zero_solutions_case(t as int, a as int, b as int) ==> res@ == ""0""@,
        one_solution_case(t as int, a as int, b as int) ==> res@ == ""1""@
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(t: int, a: int, b: int) -> bool {
    t > 0 && a > 0 && b > 0
}

spec fn valid_output(res: String) -> bool {
    res@ == ""0""@ || res@ == ""1""@ || res@ == ""2""@ || res@ == ""inf""@
}

spec fn infinite_case(t: int, a: int, b: int) -> bool {
    a == t && a == b && a == 1
}

spec fn two_solutions_case(t: int, a: int, b: int) -> bool {
    a == t && a == b && a != 1
}

spec fn zero_solutions_case(t: int, a: int, b: int) -> bool {
    (t == 2 && a == 3 && b > 10000) ||
    (a == t && a != b) ||
    (a != t && (a - b) % (t - a) == 0) ||
    (a != t && (a - b) % (t - a) != 0 && t == b)
}

spec fn one_solution_case(t: int, a: int, b: int) -> bool {
    a != t && (a - b) % (t - a) != 0 && t != b
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(t: i8, a: i8, b: i8) -> (res: String)
    requires 
        valid_input(t as int, a as int, b as int),
    ensures 
        valid_output(res),
        infinite_case(t as int, a as int, b as int) ==> res@ == ""inf""@,
        two_solutions_case(t as int, a as int, b as int) ==> res@ == ""2""@,
        zero_solutions_case(t as int, a as int, b as int) ==> res@ == ""0""@,
        one_solution_case(t as int, a as int, b as int) ==> res@ == ""1""@
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(t: int, a: int, b: int) -> bool {\n    t > 0 && a > 0 && b > 0\n}\n\nspec fn valid_output(res: String) -> bool {\n    res@ == ""0""@ || res@ == ""1""@ || res@ == ""2""@ || res@ == ""inf""@\n}\n\nspec fn infinite_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a == 1\n}\n\nspec fn two_solutions_case(t: int, a: int, b: int) -> bool {\n    a == t && a == b && a != 1\n}\n\nspec fn zero_solutions_case(t: int, a: int, b: int) -> bool {\n    (t == 2 && a == 3 && b > 10000) ||\n    (a == t && a != b) ||\n    (a != t && (a - b) % (t - a) == 0) ||\n    (a != t && (a - b) % (t - a) != 0 && t == b)\n}\n\nspec fn one_solution_case(t: int, a: int, b: int) -> bool {\n    a != t && (a - b) % (t - a) != 0 && t != b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: i8, a: i8, b: i8) -> (res: String)\n    requires \n        valid_input(t as int, a as int, b as int),\n    ensures \n        valid_output(res),\n        infinite_case(t as int, a as int, b as int) ==> res@ == ""inf""@,\n        two_solutions_case(t as int, a as int, b as int) ==> res@ == ""2""@,\n        zero_solutions_case(t as int, a as int, b as int) ==> res@ == ""0""@,\n        one_solution_case(t as int, a as int, b as int) ==> res@ == ""1""@\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_641.rs,51,51,1.0,92.228,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    ({
        let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\n' { input.subrange(0, input.len() as int - 1) } else { input };
        let parts = split_on_space(trimmed);
        parts.len() >= 1
    })
}

spec fn get_expected_result(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\n' { input.subrange(0, input.len() as int - 1) } else { input };
    let parts = split_on_space(trimmed);
    if parts[parts.len() as int - 1] == seq!['m', 'o', 'n', 't', 'h'] {
        if parts[0] == seq!['3', '1'] { seq!['7', '\n'] }
        else if parts[0] == seq!['3', '0'] { seq!['1', '1', '\n'] }
        else { seq!['1', '2', '\n'] }
    } else {
        if parts[0] == seq!['5'] || parts[0] == seq!['6'] { seq!['5', '3', '\n'] }
        else { seq!['5', '2', '\n'] }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires valid_input(input@)
    ensures result@ == get_expected_result(input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    ({
        let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\n' { input.subrange(0, input.len() as int - 1) } else { input };
        let parts = split_on_space(trimmed);
        parts.len() >= 1
    })
}

spec fn get_expected_result(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\n' { input.subrange(0, input.len() as int - 1) } else { input };
    let parts = split_on_space(trimmed);
    if parts[parts.len() as int - 1] == seq!['m', 'o', 'n', 't', 'h'] {
        if parts[0] == seq!['3', '1'] { seq!['7', '\n'] }
        else if parts[0] == seq!['3', '0'] { seq!['1', '1', '\n'] }
        else { seq!['1', '2', '\n'] }
    } else {
        if parts[0] == seq!['5'] || parts[0] == seq!['6'] { seq!['5', '3', '\n'] }
        else { seq!['5', '2', '\n'] }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires valid_input(input@)
    ensures result@ == get_expected_result(input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    ({\n        let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n        let parts = split_on_space(trimmed);\n        parts.len() >= 1\n    })\n}\n\nspec fn get_expected_result(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\\n' { input.subrange(0, input.len() as int - 1) } else { input };\n    let parts = split_on_space(trimmed);\n    if parts[parts.len() as int - 1] == seq!['m', 'o', 'n', 't', 'h'] {\n        if parts[0] == seq!['3', '1'] { seq!['7', '\\n'] }\n        else if parts[0] == seq!['3', '0'] { seq!['1', '1', '\\n'] }\n        else { seq!['1', '2', '\\n'] }\n    } else {\n        if parts[0] == seq!['5'] || parts[0] == seq!['6'] { seq!['5', '3', '\\n'] }\n        else { seq!['5', '2', '\\n'] }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires valid_input(input@)\n    ensures result@ == get_expected_result(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_65.rs,54,54,1.0,123.388,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn seq_min(s: Seq<int>) -> int 
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_min = seq_min(s.subrange(1, s.len() as int));
        if s[0] <= tail_min {
            s[0]
        } else {
            tail_min
        }
    }
}

spec fn valid_input(arr: Seq<int>) -> bool {
    arr.len() >= 2 && 
    exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr[i] == #[trigger] arr[j] && arr[i] == seq_min(arr)
}
// </vc-preamble>

// <vc-helpers>
spec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {
    arr@.map(|i, v| v as int)
}
// </vc-helpers>

// <vc-spec>
fn solve(arr: Vec<i8>) -> (result: u8)
    requires 
        valid_input(arr_to_seq(arr)),
    ensures 
        result > 0,
        result as int <= arr.len() - 1,
        exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) && j - i == result as int,
        forall|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) ==> j - i >= result as int,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn seq_min(s: Seq<int>) -> int 
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_min = seq_min(s.subrange(1, s.len() as int));
        if s[0] <= tail_min {
            s[0]
        } else {
            tail_min
        }
    }
}

spec fn valid_input(arr: Seq<int>) -> bool {
    arr.len() >= 2 && 
    exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr[i] == #[trigger] arr[j] && arr[i] == seq_min(arr)
}
// </vc-preamble>

// <vc-helpers>
spec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {
    arr@.map(|i, v| v as int)
}
// </vc-helpers>

// <vc-spec>
fn solve(arr: Vec<i8>) -> (result: u8)
    requires 
        valid_input(arr_to_seq(arr)),
    ensures 
        result > 0,
        result as int <= arr.len() - 1,
        exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) && j - i == result as int,
        forall|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) ==> j - i >= result as int,
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn seq_min(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_min = seq_min(s.subrange(1, s.len() as int));\n        if s[0] <= tail_min {\n            s[0]\n        } else {\n            tail_min\n        }\n    }\n}\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n    arr.len() >= 2 && \n    exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr[i] == #[trigger] arr[j] && arr[i] == seq_min(arr)\n}\n// </vc-preamble>\n\n// <vc-helpers>\nspec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {\n    arr@.map(|i, v| v as int)\n}\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(arr: Vec<i8>) -> (result: u8)\n    requires \n        valid_input(arr_to_seq(arr)),\n    ensures \n        result > 0,\n        result as int <= arr.len() - 1,\n        exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) && j - i == result as int,\n        forall|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) ==> j - i >= result as int,\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_66.rs,52,52,1.0,92.349,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn gcd(a: int, b: int) -> int 
    decreases (if b == 0 { 0 } else { abs(b) })
{
    if b == 0 { abs(a) } else { gcd(b, a % b) }
}

spec fn valid_input(t: int, w: int, b: int) -> bool {
    t > 0 && w > 0 && b > 0
}

spec fn valid_fraction(numerator: int, denominator: int) -> bool {
    numerator >= 0 && denominator > 0 && numerator <= denominator
}

spec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool
    recommends valid_fraction(numerator, denominator)
{
    gcd(numerator, denominator) == 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(t: u64, w: u64, b: u64) -> (result: (u64, u64))
    requires
        t > 0 && w > 0 && b > 0,
    ensures
        result.1 > 0,
        result.0 <= result.1
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 1)
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn gcd(a: int, b: int) -> int 
    decreases (if b == 0 { 0 } else { abs(b) })
{
    if b == 0 { abs(a) } else { gcd(b, a % b) }
}

spec fn valid_input(t: int, w: int, b: int) -> bool {
    t > 0 && w > 0 && b > 0
}

spec fn valid_fraction(numerator: int, denominator: int) -> bool {
    numerator >= 0 && denominator > 0 && numerator <= denominator
}

spec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool
    recommends valid_fraction(numerator, denominator)
{
    gcd(numerator, denominator) == 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(t: u64, w: u64, b: u64) -> (result: (u64, u64))
    requires
        t > 0 && w > 0 && b > 0,
    ensures
        result.1 > 0,
        result.0 <= result.1
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 1)
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn gcd(a: int, b: int) -> int \n    decreases (if b == 0 { 0 } else { abs(b) })\n{\n    if b == 0 { abs(a) } else { gcd(b, a % b) }\n}\n\nspec fn valid_input(t: int, w: int, b: int) -> bool {\n    t > 0 && w > 0 && b > 0\n}\n\nspec fn valid_fraction(numerator: int, denominator: int) -> bool {\n    numerator >= 0 && denominator > 0 && numerator <= denominator\n}\n\nspec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool\n    recommends valid_fraction(numerator, denominator)\n{\n    gcd(numerator, denominator) == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(t: u64, w: u64, b: u64) -> (result: (u64, u64))\n    requires\n        t > 0 && w > 0 && b > 0,\n    ensures\n        result.1 > 0,\n        result.0 <= result.1\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    (0, 1)\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_682.rs,76,76,1.0,92.118,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_position(r: int, c: int) -> bool {
    1 <= r <= 8 && 1 <= c <= 8
}

spec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    if r1 == r2 && c1 == c2 {
        0
    } else if r1 == r2 || c1 == c2 {
        1
    } else {
        2
    }
}

spec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    if r1 == r2 && c1 == c2 {
        0
    } else {
        let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };
        let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };
        if row_diff == col_diff {
            1
        } else if (r1 + c1) % 2 == (r2 + c2) % 2 {
            2
        } else {
            0
        }
    }
}

spec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };
    let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };
    if row_diff >= col_diff { row_diff } else { col_diff }
}

spec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    result.len() == 3 &&
    result[0] == rook_moves(r1, c1, r2, c2) &&
    result[1] == bishop_moves(r1, c1, r2, c2) &&
    result[2] == king_moves(r1, c1, r2, c2)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(r1: i8, c1: i8, r2: i8, c2: i8) -> (result: Vec<i8>)
    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)
    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_position(r: int, c: int) -> bool {
    1 <= r <= 8 && 1 <= c <= 8
}

spec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    if r1 == r2 && c1 == c2 {
        0
    } else if r1 == r2 || c1 == c2 {
        1
    } else {
        2
    }
}

spec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    if r1 == r2 && c1 == c2 {
        0
    } else {
        let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };
        let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };
        if row_diff == col_diff {
            1
        } else if (r1 + c1) % 2 == (r2 + c2) % 2 {
            2
        } else {
            0
        }
    }
}

spec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };
    let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };
    if row_diff >= col_diff { row_diff } else { col_diff }
}

spec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    result.len() == 3 &&
    result[0] == rook_moves(r1, c1, r2, c2) &&
    result[1] == bishop_moves(r1, c1, r2, c2) &&
    result[2] == king_moves(r1, c1, r2, c2)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(r1: i8, c1: i8, r2: i8, c2: i8) -> (result: Vec<i8>)
    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)
    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_position(r: int, c: int) -> bool {\n    1 <= r <= 8 && 1 <= c <= 8\n}\n\nspec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else if r1 == r2 || c1 == c2 {\n        1\n    } else {\n        2\n    }\n}\n\nspec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    if r1 == r2 && c1 == c2 {\n        0\n    } else {\n        let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n        let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n        if row_diff == col_diff {\n            1\n        } else if (r1 + c1) % 2 == (r2 + c2) % 2 {\n            2\n        } else {\n            0\n        }\n    }\n}\n\nspec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };\n    let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };\n    if row_diff >= col_diff { row_diff } else { col_diff }\n}\n\nspec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool\n    recommends valid_position(r1, c1) && valid_position(r2, c2)\n{\n    result.len() == 3 &&\n    result[0] == rook_moves(r1, c1, r2, c2) &&\n    result[1] == bishop_moves(r1, c1, r2, c2) &&\n    result[2] == king_moves(r1, c1, r2, c2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(r1: i8, c1: i8, r2: i8, c2: i8) -> (result: Vec<i8>)\n    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)\n    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_703.rs,60,60,1.0,92.821,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn min(x: int, y: int) -> int {
    if x <= y { x } else { y }
}

spec fn valid_input(k: int, a: int, b: int, v: int) -> bool {
    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000
}

spec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int
    recommends num_boxes >= 0
{
    v * (num_boxes + min(b, (k - 1) * num_boxes))
}

spec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool
    recommends num_boxes >= 0
{
    a <= box_capacity(num_boxes, k, b, v)
}

spec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool
    recommends result >= 1
{
    can_store_nuts(result, k, a, b, v) &&
    (result == 1 || !can_store_nuts(result - 1, k, a, b, v))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i8, a: i8, b: i8, v: i8) -> (result: i8)
    requires
        valid_input(k as int, a as int, b as int, v as int)
    ensures
        result >= 1,
        result <= 127,
        is_minimal_solution(result as int, k as int, a as int, b as int, v as int),
        exists|i: int| 1 <= i <= 127 && can_store_nuts(i, k as int, a as int, b as int, v as int) && result as int == i && 
            (forall|j: int| 1 <= j < i ==> !can_store_nuts(j, k as int, a as int, b as int, v as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn min(x: int, y: int) -> int {
    if x <= y { x } else { y }
}

spec fn valid_input(k: int, a: int, b: int, v: int) -> bool {
    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000
}

spec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int
    recommends num_boxes >= 0
{
    v * (num_boxes + min(b, (k - 1) * num_boxes))
}

spec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool
    recommends num_boxes >= 0
{
    a <= box_capacity(num_boxes, k, b, v)
}

spec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool
    recommends result >= 1
{
    can_store_nuts(result, k, a, b, v) &&
    (result == 1 || !can_store_nuts(result - 1, k, a, b, v))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(k: i8, a: i8, b: i8, v: i8) -> (result: i8)
    requires
        valid_input(k as int, a as int, b as int, v as int)
    ensures
        result >= 1,
        result <= 127,
        is_minimal_solution(result as int, k as int, a as int, b as int, v as int),
        exists|i: int| 1 <= i <= 127 && can_store_nuts(i, k as int, a as int, b as int, v as int) && result as int == i && 
            (forall|j: int| 1 <= j < i ==> !can_store_nuts(j, k as int, a as int, b as int, v as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn valid_input(k: int, a: int, b: int, v: int) -> bool {\n    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000\n}\n\nspec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int\n    recommends num_boxes >= 0\n{\n    v * (num_boxes + min(b, (k - 1) * num_boxes))\n}\n\nspec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool\n    recommends num_boxes >= 0\n{\n    a <= box_capacity(num_boxes, k, b, v)\n}\n\nspec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool\n    recommends result >= 1\n{\n    can_store_nuts(result, k, a, b, v) &&\n    (result == 1 || !can_store_nuts(result - 1, k, a, b, v))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(k: i8, a: i8, b: i8, v: i8) -> (result: i8)\n    requires\n        valid_input(k as int, a as int, b as int, v as int)\n    ensures\n        result >= 1,\n        result <= 127,\n        is_minimal_solution(result as int, k as int, a as int, b as int, v as int),\n        exists|i: int| 1 <= i <= 127 && can_store_nuts(i, k as int, a as int, b as int, v as int) && result as int == i && \n            (forall|j: int| 1 <= j < i ==> !can_store_nuts(j, k as int, a as int, b as int, v as int))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_719.rs,54,54,1.0,122.287,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn int_to_string(n: int) -> Seq<char> {
    unimplemented!()
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    exists|k: int| k >= 1 && k <= 10000 && stdin_input == int_to_string(k).push('\n')
}

spec fn kth_perfect_number(k: int) -> int
    recommends k >= 1 && k <= 10000
{
    if k == 1 { 19 }
    else if k == 2 { 28 }
    else if k == 3 { 37 }
    else if k == 4 { 46 }
    else if k == 5 { 55 }
    else if k == 6 { 64 }
    else if k == 7 { 73 }
    else if k == 8 { 82 }
    else if k == 9 { 91 }
    else if k == 10 { 109 }
    else { 10 * (k - 9) + 99 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: String) -> (result: String)
    requires valid_input(stdin_input@)
    ensures (exists|k: int| k >= 1 && k <= 10000 && 
        stdin_input@ == int_to_string(k).push('\n') &&
        result@ == int_to_string(kth_perfect_number(k)).push('\n')) &&
        result@.len() > 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn int_to_string(n: int) -> Seq<char> {
    unimplemented!()
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    exists|k: int| k >= 1 && k <= 10000 && stdin_input == int_to_string(k).push('\n')
}

spec fn kth_perfect_number(k: int) -> int
    recommends k >= 1 && k <= 10000
{
    if k == 1 { 19 }
    else if k == 2 { 28 }
    else if k == 3 { 37 }
    else if k == 4 { 46 }
    else if k == 5 { 55 }
    else if k == 6 { 64 }
    else if k == 7 { 73 }
    else if k == 8 { 82 }
    else if k == 9 { 91 }
    else if k == 10 { 109 }
    else { 10 * (k - 9) + 99 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: String) -> (result: String)
    requires valid_input(stdin_input@)
    ensures (exists|k: int| k >= 1 && k <= 10000 && 
        stdin_input@ == int_to_string(k).push('\n') &&
        result@ == int_to_string(kth_perfect_number(k)).push('\n')) &&
        result@.len() > 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn int_to_string(n: int) -> Seq<char> {\n    unimplemented!()\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    exists|k: int| k >= 1 && k <= 10000 && stdin_input == int_to_string(k).push('\\n')\n}\n\nspec fn kth_perfect_number(k: int) -> int\n    recommends k >= 1 && k <= 10000\n{\n    if k == 1 { 19 }\n    else if k == 2 { 28 }\n    else if k == 3 { 37 }\n    else if k == 4 { 46 }\n    else if k == 5 { 55 }\n    else if k == 6 { 64 }\n    else if k == 7 { 73 }\n    else if k == 8 { 82 }\n    else if k == 9 { 91 }\n    else if k == 10 { 109 }\n    else { 10 * (k - 9) + 99 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures (exists|k: int| k >= 1 && k <= 10000 && \n        stdin_input@ == int_to_string(k).push('\\n') &&\n        result@ == int_to_string(kth_perfect_number(k)).push('\\n')) &&\n        result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_736.rs,62,62,1.0,122.421,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
    n > 0 && n <= 10000 && m > 1 && m <= 10
}

spec fn min_moves(n: int) -> int
    recommends n > 0
{
    if n % 2 == 0 { n / 2 } else { n / 2 + 1 }
}

spec fn valid_move_count(n: int, k: int) -> bool
    recommends n > 0
{
    min_moves(n) <= k <= n
}

spec fn is_valid_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result == -1 || (result > 0 && result % m == 0 && valid_move_count(n, result))
}

spec fn no_smaller_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result == -1 ==> forall|k: int| min_moves(n) <= k <= n ==> #[trigger] (k % m) != 0
}

spec fn is_minimal_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result != -1 ==> forall|k: int| (min_moves(n) <= k <= n && k < result) ==> #[trigger] (k % m) != 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int)
    ensures 
        is_valid_solution(n as int, m as int, result as int) &&
        no_smaller_solution(n as int, m as int, result as int) &&
        is_minimal_solution(n as int, m as int, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    -1
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
    n > 0 && n <= 10000 && m > 1 && m <= 10
}

spec fn min_moves(n: int) -> int
    recommends n > 0
{
    if n % 2 == 0 { n / 2 } else { n / 2 + 1 }
}

spec fn valid_move_count(n: int, k: int) -> bool
    recommends n > 0
{
    min_moves(n) <= k <= n
}

spec fn is_valid_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result == -1 || (result > 0 && result % m == 0 && valid_move_count(n, result))
}

spec fn no_smaller_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result == -1 ==> forall|k: int| min_moves(n) <= k <= n ==> #[trigger] (k % m) != 0
}

spec fn is_minimal_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result != -1 ==> forall|k: int| (min_moves(n) <= k <= n && k < result) ==> #[trigger] (k % m) != 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int)
    ensures 
        is_valid_solution(n as int, m as int, result as int) &&
        no_smaller_solution(n as int, m as int, result as int) &&
        is_minimal_solution(n as int, m as int, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    -1
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int) -> bool {\n    n > 0 && n <= 10000 && m > 1 && m <= 10\n}\n\nspec fn min_moves(n: int) -> int\n    recommends n > 0\n{\n    if n % 2 == 0 { n / 2 } else { n / 2 + 1 }\n}\n\nspec fn valid_move_count(n: int, k: int) -> bool\n    recommends n > 0\n{\n    min_moves(n) <= k <= n\n}\n\nspec fn is_valid_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 || (result > 0 && result % m == 0 && valid_move_count(n, result))\n}\n\nspec fn no_smaller_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result == -1 ==> forall|k: int| min_moves(n) <= k <= n ==> #[trigger] (k % m) != 0\n}\n\nspec fn is_minimal_solution(n: int, m: int, result: int) -> bool\n    recommends valid_input(n, m)\n{\n    result != -1 ==> forall|k: int| (min_moves(n) <= k <= n && k < result) ==> #[trigger] (k % m) != 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, m: i8) -> (result: i8)\n    requires \n        valid_input(n as int, m as int)\n    ensures \n        is_valid_solution(n as int, m as int, result as int) &&\n        no_smaller_solution(n as int, m as int, result as int) &&\n        is_minimal_solution(n as int, m as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_744.rs,50,50,1.0,123.694,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_sf_flights(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() <= 1 { 
        0 
    } else { 
        (if s[s.len()-1] == 'F' && s[s.len()-2] != 'F' { 1int } else { 0int }) + count_sf_flights(s.subrange(0, s.len()-1))
    }
}

spec fn count_fs_flights(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() <= 1 { 
        0 
    } else { 
        (if s[s.len()-1] == 'S' && s[s.len()-2] != 'S' { 1int } else { 0int }) + count_fs_flights(s.subrange(0, s.len()-1))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)
    requires 
        n >= 2,
        s@.len() == n,
        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'S' || s@[i] == 'F',
    ensures 
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        (result@ == seq!['Y', 'E', 'S']) <==> count_sf_flights(s@) > count_fs_flights(s@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_sf_flights(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() <= 1 { 
        0 
    } else { 
        (if s[s.len()-1] == 'F' && s[s.len()-2] != 'F' { 1int } else { 0int }) + count_sf_flights(s.subrange(0, s.len()-1))
    }
}

spec fn count_fs_flights(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() <= 1 { 
        0 
    } else { 
        (if s[s.len()-1] == 'S' && s[s.len()-2] != 'S' { 1int } else { 0int }) + count_fs_flights(s.subrange(0, s.len()-1))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)
    requires 
        n >= 2,
        s@.len() == n,
        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'S' || s@[i] == 'F',
    ensures 
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        (result@ == seq!['Y', 'E', 'S']) <==> count_sf_flights(s@) > count_fs_flights(s@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn count_sf_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'F' && s[s.len()-2] != 'F' { 1int } else { 0int }) + count_sf_flights(s.subrange(0, s.len()-1))\n    }\n}\n\nspec fn count_fs_flights(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() <= 1 { \n        0 \n    } else { \n        (if s[s.len()-1] == 'S' && s[s.len()-2] != 'S' { 1int } else { 0int }) + count_fs_flights(s.subrange(0, s.len()-1))\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        n >= 2,\n        s@.len() == n,\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'S' || s@[i] == 'F',\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) <==> count_sf_flights(s@) > count_fs_flights(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_748.rs,57,57,1.0,123.394,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, numbers: Seq<int>) -> bool {
    n >= 3 && n % 3 == 0 &&
    numbers.len() == n &&
    forall|i: int| 0 <= i < numbers.len() ==> 1 <= #[trigger] numbers[i] && #[trigger] numbers[i] <= 7
}

spec fn valid_triplet(triplet: Seq<int>) -> bool {
    triplet.len() == 3 &&
    triplet[0] < triplet[1] && triplet[1] < triplet[2] &&
    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&
    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0
}

spec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>
    decreases result.len()
{
    if result.len() == 0 { 
        seq![]
    } else {
        result[0].add(flatten_partition(result.subrange(1, result.len() as int)))
    }
}

spec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {
    result.len() == numbers.len() / 3 &&
    (forall|i: int| 0 <= i < result.len() ==> valid_triplet(#[trigger] result[i])) &&
    numbers.to_multiset() == flatten_partition(result).to_multiset()
}

spec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {
    result.len() == 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, numbers: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))
    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, numbers: Seq<int>) -> bool {
    n >= 3 && n % 3 == 0 &&
    numbers.len() == n &&
    forall|i: int| 0 <= i < numbers.len() ==> 1 <= #[trigger] numbers[i] && #[trigger] numbers[i] <= 7
}

spec fn valid_triplet(triplet: Seq<int>) -> bool {
    triplet.len() == 3 &&
    triplet[0] < triplet[1] && triplet[1] < triplet[2] &&
    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&
    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0
}

spec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>
    decreases result.len()
{
    if result.len() == 0 { 
        seq![]
    } else {
        result[0].add(flatten_partition(result.subrange(1, result.len() as int)))
    }
}

spec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {
    result.len() == numbers.len() / 3 &&
    (forall|i: int| 0 <= i < result.len() ==> valid_triplet(#[trigger] result[i])) &&
    numbers.to_multiset() == flatten_partition(result).to_multiset()
}

spec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {
    result.len() == 0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, numbers: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))
    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, numbers: Seq<int>) -> bool {\n    n >= 3 && n % 3 == 0 &&\n    numbers.len() == n &&\n    forall|i: int| 0 <= i < numbers.len() ==> 1 <= #[trigger] numbers[i] && #[trigger] numbers[i] <= 7\n}\n\nspec fn valid_triplet(triplet: Seq<int>) -> bool {\n    triplet.len() == 3 &&\n    triplet[0] < triplet[1] && triplet[1] < triplet[2] &&\n    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&\n    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0\n}\n\nspec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>\n    decreases result.len()\n{\n    if result.len() == 0 { \n        seq![]\n    } else {\n        result[0].add(flatten_partition(result.subrange(1, result.len() as int)))\n    }\n}\n\nspec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {\n    result.len() == numbers.len() / 3 &&\n    (forall|i: int| 0 <= i < result.len() ==> valid_triplet(#[trigger] result[i])) &&\n    numbers.to_multiset() == flatten_partition(result).to_multiset()\n}\n\nspec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {\n    result.len() == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, numbers: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))\n    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n               fn main() {\n     }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_777.rs,59,59,1.0,122.577,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && s.len() <= 20 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
}

spec fn distinct_strings_count(s: Seq<char>) -> int
    recommends valid_input(s)
{
    s.len() as int * 25 + 26
}

spec fn int_to_string_spec(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 { seq!['0'] }
    else { seq!['0'] } // Simplified for termination
}

spec fn char_of_digit_spec(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else if d == 9 { '9' }
    else { '0' }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: &str) -> (result: String)
    requires valid_input(s@)
    ensures result@ == int_to_string_spec(distinct_strings_count(s@))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    """".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && s.len() <= 20 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
}

spec fn distinct_strings_count(s: Seq<char>) -> int
    recommends valid_input(s)
{
    s.len() as int * 25 + 26
}

spec fn int_to_string_spec(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 { seq!['0'] }
    else { seq!['0'] } // Simplified for termination
}

spec fn char_of_digit_spec(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else if d == 9 { '9' }
    else { '0' }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: &str) -> (result: String)
    requires valid_input(s@)
    ensures result@ == int_to_string_spec(distinct_strings_count(s@))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    """".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() >= 1 && s.len() <= 20 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= \'a\' && #[trigger] s[i] <= \'z\'\n}\n\nspec fn distinct_strings_count(s: Seq<char>) -> int\n    recommends valid_input(s)\n{\n    s.len() as int * 25 + 26\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 { seq![\'0\'] }\n    else { seq![\'0\'] } // Simplified for termination\n}\n\nspec fn char_of_digit_spec(d: int) -> char\n    recommends 0 <= d <= 9\n{\n    if d == 0 { \'0\' }\n    else if d == 1 { \'1\' }\n    else if d == 2 { \'2\' }\n    else if d == 3 { \'3\' }\n    else if d == 4 { \'4\' }\n    else if d == 5 { \'5\' }\n    else if d == 6 { \'6\' }\n    else if d == 7 { \'7\' }\n    else if d == 8 { \'8\' }\n    else if d == 9 { \'9\' }\n    else { \'0\' }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n    requires valid_input(s@)\n    ensures result@ == int_to_string_spec(distinct_strings_count(s@))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    """".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_789.rs,66,66,1.0,122.891,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_lucky_number(n: Seq<char>) -> bool {
    n.len() > 0 && forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'
}

spec fn convert_to_binary(n: Seq<char>) -> Seq<char>
    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'
    decreases n.len()
{
    if n.len() == 0 {
        Seq::empty()
    } else if n[0] == '4' {
        seq!['0'].add(convert_to_binary(n.subrange(1, n.len() as int)))
    } else {
        seq!['1'].add(convert_to_binary(n.subrange(1, n.len() as int)))
    }
}

spec fn pow2(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { 2 * pow2((n - 1) as nat) }
}

spec fn binary_to_int(s: Seq<char>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '1' {
        pow2((s.len() - 1) as nat) + binary_to_int(s.subrange(1, s.len() as int))
    } else {
        binary_to_int(s.subrange(1, s.len() as int))
    }
}

spec fn valid_result(n: Seq<char>, result: int) -> bool
    recommends valid_lucky_number(n)
{
    result > 0 && result == 2 * (pow2((n.len() - 1) as nat) - 1) + binary_to_int(convert_to_binary(n)) + 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: Vec<char>) -> (result: i8)
    requires valid_lucky_number(n@)
    ensures valid_result(n@, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_lucky_number(n: Seq<char>) -> bool {
    n.len() > 0 && forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'
}

spec fn convert_to_binary(n: Seq<char>) -> Seq<char>
    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'
    decreases n.len()
{
    if n.len() == 0 {
        Seq::empty()
    } else if n[0] == '4' {
        seq!['0'].add(convert_to_binary(n.subrange(1, n.len() as int)))
    } else {
        seq!['1'].add(convert_to_binary(n.subrange(1, n.len() as int)))
    }
}

spec fn pow2(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { 2 * pow2((n - 1) as nat) }
}

spec fn binary_to_int(s: Seq<char>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '1' {
        pow2((s.len() - 1) as nat) + binary_to_int(s.subrange(1, s.len() as int))
    } else {
        binary_to_int(s.subrange(1, s.len() as int))
    }
}

spec fn valid_result(n: Seq<char>, result: int) -> bool
    recommends valid_lucky_number(n)
{
    result > 0 && result == 2 * (pow2((n.len() - 1) as nat) - 1) + binary_to_int(convert_to_binary(n)) + 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: Vec<char>) -> (result: i8)
    requires valid_lucky_number(n@)
    ensures valid_result(n@, result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_lucky_number(n: Seq<char>) -> bool {\n    n.len() > 0 && forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n}\n\nspec fn convert_to_binary(n: Seq<char>) -> Seq<char>\n    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'\n    decreases n.len()\n{\n    if n.len() == 0 {\n        Seq::empty()\n    } else if n[0] == '4' {\n        seq!['0'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    } else {\n        seq!['1'].add(convert_to_binary(n.subrange(1, n.len() as int)))\n    }\n}\n\nspec fn pow2(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 2 * pow2((n - 1) as nat) }\n}\n\nspec fn binary_to_int(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == '1' {\n        pow2((s.len() - 1) as nat) + binary_to_int(s.subrange(1, s.len() as int))\n    } else {\n        binary_to_int(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_result(n: Seq<char>, result: int) -> bool\n    recommends valid_lucky_number(n)\n{\n    result > 0 && result == 2 * (pow2((n.len() - 1) as nat) - 1) + binary_to_int(convert_to_binary(n)) + 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: Vec<char>) -> (result: i8)\n    requires valid_lucky_number(n@)\n    ensures valid_result(n@, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_792.rs,76,76,1.0,123.388,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {
  n >= 1 && d >= 1 &&
  transactions.len() == n &&
  forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000
}

spec fn prefix_sum(transactions: Seq<int>, index: int) -> int
  decreases index
{
  if index < 0 || index >= transactions.len() { 0int }
  else if index == 0 { transactions[0] }
  else { prefix_sum(transactions, index - 1) + transactions[index] }
}

spec fn count_zero_transactions(transactions: Seq<int>) -> int
  decreases transactions.len()
{
  if transactions.len() == 0 { 0int }
  else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }
}

spec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int
  decreases day
{
  if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }
  else if day == 0 { deposits[0] + transactions[0] }
  else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }
}

spec fn count_positive_deposits(deposits: Seq<int>) -> int
  decreases deposits.len()
{
  if deposits.len() == 0 { 0int }
  else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }
}

spec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {
  deposits_schedule.len() == transactions.len() &&
  (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&
  num_deposits == count_positive_deposits(deposits_schedule) &&
  forall|i: int| 0 <= i < transactions.len() ==> 
    (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)
}

spec fn filter_positive(deposits: Seq<int>) -> Seq<int>
  decreases deposits.len()
{
  if deposits.len() == 0 { Seq::empty() }
  else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }
  else { filter_positive(deposits.drop_first()) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, d: i8, transactions: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))
  ensures result == -1 || result >= 0
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {
  n >= 1 && d >= 1 &&
  transactions.len() == n &&
  forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000
}

spec fn prefix_sum(transactions: Seq<int>, index: int) -> int
  decreases index
{
  if index < 0 || index >= transactions.len() { 0int }
  else if index == 0 { transactions[0] }
  else { prefix_sum(transactions, index - 1) + transactions[index] }
}

spec fn count_zero_transactions(transactions: Seq<int>) -> int
  decreases transactions.len()
{
  if transactions.len() == 0 { 0int }
  else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }
}

spec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int
  decreases day
{
  if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }
  else if day == 0 { deposits[0] + transactions[0] }
  else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }
}

spec fn count_positive_deposits(deposits: Seq<int>) -> int
  decreases deposits.len()
{
  if deposits.len() == 0 { 0int }
  else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }
}

spec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {
  deposits_schedule.len() == transactions.len() &&
  (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&
  num_deposits == count_positive_deposits(deposits_schedule) &&
  forall|i: int| 0 <= i < transactions.len() ==> 
    (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)
}

spec fn filter_positive(deposits: Seq<int>) -> Seq<int>
  decreases deposits.len()
{
  if deposits.len() == 0 { Seq::empty() }
  else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }
  else { filter_positive(deposits.drop_first()) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, d: i8, transactions: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))
  ensures result == -1 || result >= 0
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {\n  n >= 1 && d >= 1 &&\n  transactions.len() == n &&\n  forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000\n}\n\nspec fn prefix_sum(transactions: Seq<int>, index: int) -> int\n  decreases index\n{\n  if index < 0 || index >= transactions.len() { 0int }\n  else if index == 0 { transactions[0] }\n  else { prefix_sum(transactions, index - 1) + transactions[index] }\n}\n\nspec fn count_zero_transactions(transactions: Seq<int>) -> int\n  decreases transactions.len()\n{\n  if transactions.len() == 0 { 0int }\n  else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }\n}\n\nspec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int\n  decreases day\n{\n  if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }\n  else if day == 0 { deposits[0] + transactions[0] }\n  else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }\n}\n\nspec fn count_positive_deposits(deposits: Seq<int>) -> int\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { 0int }\n  else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }\n}\n\nspec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {\n  deposits_schedule.len() == transactions.len() &&\n  (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&\n  num_deposits == count_positive_deposits(deposits_schedule) &&\n  forall|i: int| 0 <= i < transactions.len() ==> \n    (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)\n}\n\nspec fn filter_positive(deposits: Seq<int>) -> Seq<int>\n  decreases deposits.len()\n{\n  if deposits.len() == 0 { Seq::empty() }\n  else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }\n  else { filter_positive(deposits.drop_first()) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, d: i8, transactions: Vec<i8>) -> (result: i8)\n  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))\n  ensures result == -1 || result >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_795.rs,56,56,1.0,92.747,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_n(n: int) -> bool {
    n >= 1 && n <= 10000
}

spec fn integer_square_root(n: int) -> int {
    0  /* placeholder implementation */
}

spec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {
    0  /* placeholder implementation */
}

spec fn extract_integer(input: Seq<char>) -> int {
    0  /* placeholder implementation */
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]  /* placeholder implementation */
}

spec fn count_pythagorean_triples_via_primitives(n: int) -> int {
    let m = integer_square_root(n);
    count_from_primitives(n, m, 1, 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures 
        result@.len() > 0,
        result@ == int_to_string(count_pythagorean_triples_via_primitives(extract_integer(stdin_input@)))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_n(n: int) -> bool {
    n >= 1 && n <= 10000
}

spec fn integer_square_root(n: int) -> int {
    0  /* placeholder implementation */
}

spec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {
    0  /* placeholder implementation */
}

spec fn extract_integer(input: Seq<char>) -> int {
    0  /* placeholder implementation */
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]  /* placeholder implementation */
}

spec fn count_pythagorean_triples_via_primitives(n: int) -> int {
    let m = integer_square_root(n);
    count_from_primitives(n, m, 1, 1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures 
        result@.len() > 0,
        result@ == int_to_string(count_pythagorean_triples_via_primitives(extract_integer(stdin_input@)))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_n(n: int) -> bool {\n    n >= 1 && n <= 10000\n}\n\nspec fn integer_square_root(n: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn extract_integer(input: Seq<char>) -> int {\n    0  /* placeholder implementation */\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]  /* placeholder implementation */\n}\n\nspec fn count_pythagorean_triples_via_primitives(n: int) -> int {\n    let m = integer_square_root(n);\n    count_from_primitives(n, m, 1, 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures \n        result@.len() > 0,\n        result@ == int_to_string(count_pythagorean_triples_via_primitives(extract_integer(stdin_input@)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_821.rs,52,52,1.0,92.314,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool
{
    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000
}

spec fn participant_time(s: int, v: int, t: int) -> int
{
    2 * t + s * v
}

spec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>
{
    let time1 = participant_time(s, v1, t1);
    let time2 = participant_time(s, v2, t2);
    if time1 < time2 { seq!['F','i','r','s','t'] }
    else if time1 > time2 { seq!['S','e','c','o','n','d'] }
    else { seq!['F','r','i','e','n','d','s','h','i','p'] }
}

spec fn valid_result(result: Seq<char>) -> bool
{
    result == seq!['F','i','r','s','t'] || result == seq!['S','e','c','o','n','d'] || result == seq!['F','r','i','e','n','d','s','h','i','p']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: i8, v1: i8, v2: i8, t1: i8, t2: i8) -> (result: Vec<char>)
    requires 
        valid_input(s as int, v1 as int, v2 as int, t1 as int, t2 as int)
    ensures 
        valid_result(result@) &&
        result@ == correct_result(s as int, v1 as int, v2 as int, t1 as int, t2 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool
{
    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000
}

spec fn participant_time(s: int, v: int, t: int) -> int
{
    2 * t + s * v
}

spec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>
{
    let time1 = participant_time(s, v1, t1);
    let time2 = participant_time(s, v2, t2);
    if time1 < time2 { seq!['F','i','r','s','t'] }
    else if time1 > time2 { seq!['S','e','c','o','n','d'] }
    else { seq!['F','r','i','e','n','d','s','h','i','p'] }
}

spec fn valid_result(result: Seq<char>) -> bool
{
    result == seq!['F','i','r','s','t'] || result == seq!['S','e','c','o','n','d'] || result == seq!['F','r','i','e','n','d','s','h','i','p']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: i8, v1: i8, v2: i8, t1: i8, t2: i8) -> (result: Vec<char>)
    requires 
        valid_input(s as int, v1 as int, v2 as int, t1 as int, t2 as int)
    ensures 
        valid_result(result@) &&
        result@ == correct_result(s as int, v1 as int, v2 as int, t1 as int, t2 as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool\n{\n    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000\n}\n\nspec fn participant_time(s: int, v: int, t: int) -> int\n{\n    2 * t + s * v\n}\n\nspec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>\n{\n    let time1 = participant_time(s, v1, t1);\n    let time2 = participant_time(s, v2, t2);\n    if time1 < time2 { seq!['F','i','r','s','t'] }\n    else if time1 > time2 { seq!['S','e','c','o','n','d'] }\n    else { seq!['F','r','i','e','n','d','s','h','i','p'] }\n}\n\nspec fn valid_result(result: Seq<char>) -> bool\n{\n    result == seq!['F','i','r','s','t'] || result == seq!['S','e','c','o','n','d'] || result == seq!['F','r','i','e','n','d','s','h','i','p']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: i8, v1: i8, v2: i8, t1: i8, t2: i8) -> (result: Vec<char>)\n    requires \n        valid_input(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n    ensures \n        valid_result(result@) &&\n        result@ == correct_result(s as int, v1 as int, v2 as int, t1 as int, t2 as int)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_823.rs,70,70,1.0,92.505,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(x: int, y: int) -> bool {
    -100 <= x <= 100 && -100 <= y <= 100
}

spec fn is_origin_or_first_point(x: int, y: int) -> bool {
    (x == 0 && y == 0) || (x == 1 && y == 0)
}

spec fn is_right_edge(x: int, y: int) -> bool {
    x >= 1 && -x + 1 < y <= x
}

spec fn is_left_edge(x: int, y: int) -> bool {
    x < 0 && x <= y < -x
}

spec fn is_top_edge(x: int, y: int) -> bool {
    y > 0 && -y <= x < y
}

spec fn compute_turns(x: int, y: int) -> int
    recommends valid_input(x, y)
{
    if is_origin_or_first_point(x, y) { 
        0
    } else if is_right_edge(x, y) { 
        1 + 4 * (x - 1)
    } else if is_left_edge(x, y) { 
        3 + 4 * (-x - 1)
    } else if is_top_edge(x, y) { 
        2 + 4 * (y - 1)
    } else { 
        -4 * y
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x: i8, y: i8) -> (result: i8)
    requires 
        valid_input(x as int, y as int)
    ensures 
        result as int >= 0,
        result as int == compute_turns(x as int, y as int),
        is_origin_or_first_point(x as int, y as int) ==> result as int == 0,
        is_right_edge(x as int, y as int) ==> result as int == 1 + 4 * (x as int - 1),
        is_left_edge(x as int, y as int) ==> result as int == 3 + 4 * (-(x as int) - 1),
        is_top_edge(x as int, y as int) ==> result as int == 2 + 4 * (y as int - 1),
        !(is_origin_or_first_point(x as int, y as int) || is_right_edge(x as int, y as int) || is_left_edge(x as int, y as int) || is_top_edge(x as int, y as int)) ==> result as int == -4 * y as int,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(x: int, y: int) -> bool {
    -100 <= x <= 100 && -100 <= y <= 100
}

spec fn is_origin_or_first_point(x: int, y: int) -> bool {
    (x == 0 && y == 0) || (x == 1 && y == 0)
}

spec fn is_right_edge(x: int, y: int) -> bool {
    x >= 1 && -x + 1 < y <= x
}

spec fn is_left_edge(x: int, y: int) -> bool {
    x < 0 && x <= y < -x
}

spec fn is_top_edge(x: int, y: int) -> bool {
    y > 0 && -y <= x < y
}

spec fn compute_turns(x: int, y: int) -> int
    recommends valid_input(x, y)
{
    if is_origin_or_first_point(x, y) { 
        0
    } else if is_right_edge(x, y) { 
        1 + 4 * (x - 1)
    } else if is_left_edge(x, y) { 
        3 + 4 * (-x - 1)
    } else if is_top_edge(x, y) { 
        2 + 4 * (y - 1)
    } else { 
        -4 * y
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(x: i8, y: i8) -> (result: i8)
    requires 
        valid_input(x as int, y as int)
    ensures 
        result as int >= 0,
        result as int == compute_turns(x as int, y as int),
        is_origin_or_first_point(x as int, y as int) ==> result as int == 0,
        is_right_edge(x as int, y as int) ==> result as int == 1 + 4 * (x as int - 1),
        is_left_edge(x as int, y as int) ==> result as int == 3 + 4 * (-(x as int) - 1),
        is_top_edge(x as int, y as int) ==> result as int == 2 + 4 * (y as int - 1),
        !(is_origin_or_first_point(x as int, y as int) || is_right_edge(x as int, y as int) || is_left_edge(x as int, y as int) || is_top_edge(x as int, y as int)) ==> result as int == -4 * y as int,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(x: int, y: int) -> bool {\n    -100 <= x <= 100 && -100 <= y <= 100\n}\n\nspec fn is_origin_or_first_point(x: int, y: int) -> bool {\n    (x == 0 && y == 0) || (x == 1 && y == 0)\n}\n\nspec fn is_right_edge(x: int, y: int) -> bool {\n    x >= 1 && -x + 1 < y <= x\n}\n\nspec fn is_left_edge(x: int, y: int) -> bool {\n    x < 0 && x <= y < -x\n}\n\nspec fn is_top_edge(x: int, y: int) -> bool {\n    y > 0 && -y <= x < y\n}\n\nspec fn compute_turns(x: int, y: int) -> int\n    recommends valid_input(x, y)\n{\n    if is_origin_or_first_point(x, y) { \n        0\n    } else if is_right_edge(x, y) { \n        1 + 4 * (x - 1)\n    } else if is_left_edge(x, y) { \n        3 + 4 * (-x - 1)\n    } else if is_top_edge(x, y) { \n        2 + 4 * (y - 1)\n    } else { \n        -4 * y\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(x: i8, y: i8) -> (result: i8)\n    requires \n        valid_input(x as int, y as int)\n    ensures \n        result as int >= 0,\n        result as int == compute_turns(x as int, y as int),\n        is_origin_or_first_point(x as int, y as int) ==> result as int == 0,\n        is_right_edge(x as int, y as int) ==> result as int == 1 + 4 * (x as int - 1),\n        is_left_edge(x as int, y as int) ==> result as int == 3 + 4 * (-(x as int) - 1),\n        is_top_edge(x as int, y as int) ==> result as int == 2 + 4 * (y as int - 1),\n        !(is_origin_or_first_point(x as int, y as int) || is_right_edge(x as int, y as int) || is_left_edge(x as int, y as int) || is_top_edge(x as int, y as int)) ==> result as int == -4 * y as int,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_826.rs,55,55,1.0,122.518,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn is_optimal_savings(n: int, savings: int) -> bool {
    n >= 1 ==> (
        savings >= 0 &&
        (2 + savings) * (savings + 1) / 2 > n + 1 &&
        (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)
    )
}

spec fn is_minimal_savings(n: int, savings: int) -> bool {
    n >= 1 ==> (
        is_optimal_savings(n, savings) &&
        (forall|j: int| j >= 0 && j < savings ==> #[trigger] ((2 + j) * (j + 1) / 2) <= n + 1)
    )
}

spec fn optimal_cost(n: int, savings: int) -> int {
    if n >= 1 && is_optimal_savings(n, savings) {
        n - savings + 1
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int)
    ensures 
        result as int >= 1,
        result as int <= n as int,
        exists|savings: int| is_minimal_savings(n as int, savings) && result as int == optimal_cost(n as int, savings),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn is_optimal_savings(n: int, savings: int) -> bool {
    n >= 1 ==> (
        savings >= 0 &&
        (2 + savings) * (savings + 1) / 2 > n + 1 &&
        (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)
    )
}

spec fn is_minimal_savings(n: int, savings: int) -> bool {
    n >= 1 ==> (
        is_optimal_savings(n, savings) &&
        (forall|j: int| j >= 0 && j < savings ==> #[trigger] ((2 + j) * (j + 1) / 2) <= n + 1)
    )
}

spec fn optimal_cost(n: int, savings: int) -> int {
    if n >= 1 && is_optimal_savings(n, savings) {
        n - savings + 1
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int)
    ensures 
        result as int >= 1,
        result as int <= n as int,
        exists|savings: int| is_minimal_savings(n as int, savings) && result as int == optimal_cost(n as int, savings),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn is_optimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        savings >= 0 &&\n        (2 + savings) * (savings + 1) / 2 > n + 1 &&\n        (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)\n    )\n}\n\nspec fn is_minimal_savings(n: int, savings: int) -> bool {\n    n >= 1 ==> (\n        is_optimal_savings(n, savings) &&\n        (forall|j: int| j >= 0 && j < savings ==> #[trigger] ((2 + j) * (j + 1) / 2) <= n + 1)\n    )\n}\n\nspec fn optimal_cost(n: int, savings: int) -> int {\n    if n >= 1 && is_optimal_savings(n, savings) {\n        n - savings + 1\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires \n        valid_input(n as int)\n    ensures \n        result as int >= 1,\n        result as int <= n as int,\n        exists|savings: int| is_minimal_savings(n as int, savings) && result as int == optimal_cost(n as int, savings),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_838.rs,114,114,1.0,92.687,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && 
    (forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0) &&
    (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> 
        grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {
    grid.len() * grid[0].len() + 
    sum_row_contributions(grid) + 
    sum_col_contributions(grid)
}

spec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {
    sum_row_contributions_helper(grid, 0)
}

spec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int
    decreases grid.len() - row
{
    if row >= grid.len() { 0 }
    else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }
}

spec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {
    let cnt0 = count_in_row(grid, row, 0);
    let cnt1 = count_in_row(grid, row, 1);
    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +
    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })
}

spec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {
    sum_col_contributions_helper(grid, 0)
}

spec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int
    decreases grid[0].len() - col
{
    if col >= grid[0].len() { 0 }
    else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }
}

spec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {
    let cnt0 = count_in_col(grid, col, 0);
    let cnt1 = count_in_col(grid, col, 1);
    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +
    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })
}

spec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {
    count_in_row_helper(grid, row, value, 0)
}

spec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int
    decreases grid[row].len() - col
{
    if col >= grid[row].len() { 0 }
    else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }
}

spec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {
    if grid.len() == 0 { 0 }
    else { count_col_helper(grid, col, value, 0) }
}

spec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int
    decreases grid.len() - row
{
    if row >= grid.len() { 0 }
    else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }
}

spec fn power(base: int, exp: int) -> int
    decreases exp
{
    if exp <= 0 { 1 }
    else { base * power(base, exp - 1) }
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0'] /* placeholder implementation */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@),
    ensures result@.len() > 0,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && 
    (forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0) &&
    (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> 
        grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {
    grid.len() * grid[0].len() + 
    sum_row_contributions(grid) + 
    sum_col_contributions(grid)
}

spec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {
    sum_row_contributions_helper(grid, 0)
}

spec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int
    decreases grid.len() - row
{
    if row >= grid.len() { 0 }
    else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }
}

spec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {
    let cnt0 = count_in_row(grid, row, 0);
    let cnt1 = count_in_row(grid, row, 1);
    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +
    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })
}

spec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {
    sum_col_contributions_helper(grid, 0)
}

spec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int
    decreases grid[0].len() - col
{
    if col >= grid[0].len() { 0 }
    else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }
}

spec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {
    let cnt0 = count_in_col(grid, col, 0);
    let cnt1 = count_in_col(grid, col, 1);
    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +
    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })
}

spec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {
    count_in_row_helper(grid, row, value, 0)
}

spec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int
    decreases grid[row].len() - col
{
    if col >= grid[row].len() { 0 }
    else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }
}

spec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {
    if grid.len() == 0 { 0 }
    else { count_col_helper(grid, col, value, 0) }
}

spec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int
    decreases grid.len() - row
{
    if row >= grid.len() { 0 }
    else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }
}

spec fn power(base: int, exp: int) -> int
    decreases exp
{
    if exp <= 0 { 1 }
    else { base * power(base, exp - 1) }
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0'] /* placeholder implementation */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@),
    ensures result@.len() > 0,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<int>>) -> bool {\n    grid.len() > 0 && \n    (forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0) &&\n    (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n        grid[i][j] == 0 || grid[i][j] == 1)\n}\n\nspec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {\n    grid.len() * grid[0].len() + \n    sum_row_contributions(grid) + \n    sum_col_contributions(grid)\n}\n\nspec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_row_contributions_helper(grid, 0)\n}\n\nspec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }\n}\n\nspec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {\n    let cnt0 = count_in_row(grid, row, 0);\n    let cnt1 = count_in_row(grid, row, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {\n    sum_col_contributions_helper(grid, 0)\n}\n\nspec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int\n    decreases grid[0].len() - col\n{\n    if col >= grid[0].len() { 0 }\n    else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }\n}\n\nspec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {\n    let cnt0 = count_in_col(grid, col, 0);\n    let cnt1 = count_in_col(grid, col, 1);\n    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +\n    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })\n}\n\nspec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {\n    count_in_row_helper(grid, row, value, 0)\n}\n\nspec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int\n    decreases grid[row].len() - col\n{\n    if col >= grid[row].len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }\n}\n\nspec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {\n    if grid.len() == 0 { 0 }\n    else { count_col_helper(grid, col, value, 0) }\n}\n\nspec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int\n    decreases grid.len() - row\n{\n    if row >= grid.len() { 0 }\n    else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }\n}\n\nspec fn power(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp <= 0 { 1 }\n    else { base * power(base, exp - 1) }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0'] /* placeholder implementation */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@),\n    ensures result@.len() > 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_842.rs,68,68,1.0,92.192,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn extract_first_line(s: Seq<char>) -> Seq<char>
    recommends s.len() > 0
{
    let newline_pos = find_first_newline(s);
    if newline_pos == -1 { s } else { s.subrange(0, newline_pos) }
}

spec fn find_first_newline(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        -1
    } else if s[0] == '\n' {
        0
    } else {
        let rest_result = find_first_newline(s.subrange(1, s.len() as int));
        if rest_result == -1 { -1 } else { rest_result + 1 }
    }
}

spec fn reverse_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 { 
        Seq::empty() 
    } else { 
        reverse_string(s.subrange(1, s.len() as int)).push(s[0]) 
    }
}

spec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool
    recommends input.len() > 0
{
    result.len() >= 1 &&
    result[result.len() - 1] == '\n' &&
    exists|n: Seq<char>| 
        n == extract_first_line(input) &&
        result == n.add(reverse_string(n)).push('\n')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(result@, stdin_input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn extract_first_line(s: Seq<char>) -> Seq<char>
    recommends s.len() > 0
{
    let newline_pos = find_first_newline(s);
    if newline_pos == -1 { s } else { s.subrange(0, newline_pos) }
}

spec fn find_first_newline(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        -1
    } else if s[0] == '\n' {
        0
    } else {
        let rest_result = find_first_newline(s.subrange(1, s.len() as int));
        if rest_result == -1 { -1 } else { rest_result + 1 }
    }
}

spec fn reverse_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 { 
        Seq::empty() 
    } else { 
        reverse_string(s.subrange(1, s.len() as int)).push(s[0]) 
    }
}

spec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool
    recommends input.len() > 0
{
    result.len() >= 1 &&
    result[result.len() - 1] == '\n' &&
    exists|n: Seq<char>| 
        n == extract_first_line(input) &&
        result == n.add(reverse_string(n)).push('\n')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(result@, stdin_input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn extract_first_line(s: Seq<char>) -> Seq<char>\n    recommends s.len() > 0\n{\n    let newline_pos = find_first_newline(s);\n    if newline_pos == -1 { s } else { s.subrange(0, newline_pos) }\n}\n\nspec fn find_first_newline(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        -1\n    } else if s[0] == '\\n' {\n        0\n    } else {\n        let rest_result = find_first_newline(s.subrange(1, s.len() as int));\n        if rest_result == -1 { -1 } else { rest_result + 1 }\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        Seq::empty() \n    } else { \n        reverse_string(s.subrange(1, s.len() as int)).push(s[0]) \n    }\n}\n\nspec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool\n    recommends input.len() > 0\n{\n    result.len() >= 1 &&\n    result[result.len() - 1] == '\\n' &&\n    exists|n: Seq<char>| \n        n == extract_first_line(input) &&\n        result == n.add(reverse_string(n)).push('\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_847.rs,51,51,1.0,122.627,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum(cards: Seq<int>) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else {
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn valid_input(cards: Seq<int>, x: int) -> bool {
    x > 0 && cards.len() >= 1 && forall|i: int| 0 <= i < cards.len() ==> #[trigger] cards[i] >= -x && #[trigger] cards[i] <= x
}

spec fn solve_result(cards: Seq<int>, x: int) -> int {
    if sum(cards) == 0 { 0 } else { (abs(sum(cards)) + x - 1) / x }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(cards: Vec<i8>, x: i8) -> (result: i8)
    requires 
        valid_input(cards@.map(|i: int, v: i8| v as int), x as int),
    ensures 
        result as int >= 0,
        result as int == solve_result(cards@.map(|i: int, v: i8| v as int), x as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn sum(cards: Seq<int>) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else {
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn valid_input(cards: Seq<int>, x: int) -> bool {
    x > 0 && cards.len() >= 1 && forall|i: int| 0 <= i < cards.len() ==> #[trigger] cards[i] >= -x && #[trigger] cards[i] <= x
}

spec fn solve_result(cards: Seq<int>, x: int) -> int {
    if sum(cards) == 0 { 0 } else { (abs(sum(cards)) + x - 1) / x }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(cards: Vec<i8>, x: i8) -> (result: i8)
    requires 
        valid_input(cards@.map(|i: int, v: i8| v as int), x as int),
    ensures 
        result as int >= 0,
        result as int == solve_result(cards@.map(|i: int, v: i8| v as int), x as int),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn sum(cards: Seq<int>) -> int\n    decreases cards.len()\n{\n    if cards.len() == 0 {\n        0\n    } else {\n        cards[0] + sum(cards.subrange(1, cards.len() as int))\n    }\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn valid_input(cards: Seq<int>, x: int) -> bool {\n    x > 0 && cards.len() >= 1 && forall|i: int| 0 <= i < cards.len() ==> #[trigger] cards[i] >= -x && #[trigger] cards[i] <= x\n}\n\nspec fn solve_result(cards: Seq<int>, x: int) -> int {\n    if sum(cards) == 0 { 0 } else { (abs(sum(cards)) + x - 1) / x }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(cards: Vec<i8>, x: i8) -> (result: i8)\n    requires \n        valid_input(cards@.map(|i: int, v: i8| v as int), x as int),\n    ensures \n        result as int >= 0,\n        result as int == solve_result(cards@.map(|i: int, v: i8| v as int), x as int),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_858.rs,52,52,1.0,122.362,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_power_of_two(n: int) -> bool
    decreases n
{
    if n <= 0 {
        false
    } else if n == 1 {
        true
    } else if n % 2 == 1 {
        false
    } else {
        is_power_of_two(n / 2)
    }
}

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn correct_result(n: int, result: int) -> bool {
    if n % 2 == 1 {
        result == (n - 1) / 2
    } else {
        exists|z: int| 1 <= z <= n && is_power_of_two(z) && z <= n && z * 2 > n && result == (n - z) / 2
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures correct_result(n as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_power_of_two(n: int) -> bool
    decreases n
{
    if n <= 0 {
        false
    } else if n == 1 {
        true
    } else if n % 2 == 1 {
        false
    } else {
        is_power_of_two(n / 2)
    }
}

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn correct_result(n: int, result: int) -> bool {
    if n % 2 == 1 {
        result == (n - 1) / 2
    } else {
        exists|z: int| 1 <= z <= n && is_power_of_two(z) && z <= n && z * 2 > n && result == (n - z) / 2
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures correct_result(n as int, result as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn is_power_of_two(n: int) -> bool\n    decreases n\n{\n    if n <= 0 {\n        false\n    } else if n == 1 {\n        true\n    } else if n % 2 == 1 {\n        false\n    } else {\n        is_power_of_two(n / 2)\n    }\n}\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn correct_result(n: int, result: int) -> bool {\n    if n % 2 == 1 {\n        result == (n - 1) / 2\n    } else {\n        exists|z: int| 1 <= z <= n && is_power_of_two(z) && z <= n && z * 2 > n && result == (n - z) / 2\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures correct_result(n as int, result as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_862.rs,62,62,1.0,123.941,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
  n >= 2 && a.len() == n && (forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0)
}

spec fn compute_b(a: Seq<int>, i: int) -> int
  recommends 0 <= i < a.len()
{
  a[i] - i
}

spec fn compute_c(n: int, b: int) -> int
  recommends n >= 2
{
  if b < 0 { b / n } else { (b + n - 1) / n }
}

spec fn compute_cc(n: int, a: Seq<int>, i: int) -> int
  recommends valid_input(n, a) && 0 <= i < n
{
  let b = compute_b(a, i);
  let c = compute_c(n, b);
  n * c
}

spec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool
  recommends valid_input(n, a) && 1 <= entrance <= n
{
  let i = entrance - 1;
  forall|j: int| 0 <= j < n ==> {
    let cci = compute_cc(n, a, i);
    let ccj = #[trigger] compute_cc(n, a, j);
    cci <= ccj && (cci < ccj || i <= j)
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
  requires
    valid_input(n as int, a@.map(|i, x: i8| x as int)),
  ensures
    1 <= result as int <= n as int,
    is_optimal_entrance(n as int, a@.map(|i, x: i8| x as int), result as int),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
  n >= 2 && a.len() == n && (forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0)
}

spec fn compute_b(a: Seq<int>, i: int) -> int
  recommends 0 <= i < a.len()
{
  a[i] - i
}

spec fn compute_c(n: int, b: int) -> int
  recommends n >= 2
{
  if b < 0 { b / n } else { (b + n - 1) / n }
}

spec fn compute_cc(n: int, a: Seq<int>, i: int) -> int
  recommends valid_input(n, a) && 0 <= i < n
{
  let b = compute_b(a, i);
  let c = compute_c(n, b);
  n * c
}

spec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool
  recommends valid_input(n, a) && 1 <= entrance <= n
{
  let i = entrance - 1;
  forall|j: int| 0 <= j < n ==> {
    let cci = compute_cc(n, a, i);
    let ccj = #[trigger] compute_cc(n, a, j);
    cci <= ccj && (cci < ccj || i <= j)
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
  requires
    valid_input(n as int, a@.map(|i, x: i8| x as int)),
  ensures
    1 <= result as int <= n as int,
    is_optimal_entrance(n as int, a@.map(|i, x: i8| x as int), result as int),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n  n >= 2 && a.len() == n && (forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0)\n}\n\nspec fn compute_b(a: Seq<int>, i: int) -> int\n  recommends 0 <= i < a.len()\n{\n  a[i] - i\n}\n\nspec fn compute_c(n: int, b: int) -> int\n  recommends n >= 2\n{\n  if b < 0 { b / n } else { (b + n - 1) / n }\n}\n\nspec fn compute_cc(n: int, a: Seq<int>, i: int) -> int\n  recommends valid_input(n, a) && 0 <= i < n\n{\n  let b = compute_b(a, i);\n  let c = compute_c(n, b);\n  n * c\n}\n\nspec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool\n  recommends valid_input(n, a) && 1 <= entrance <= n\n{\n  let i = entrance - 1;\n  forall|j: int| 0 <= j < n ==> {\n    let cci = compute_cc(n, a, i);\n    let ccj = #[trigger] compute_cc(n, a, j);\n    cci <= ccj && (cci < ccj || i <= j)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    valid_input(n as int, a@.map(|i, x: i8| x as int)),\n  ensures\n    1 <= result as int <= n as int,\n    is_optimal_entrance(n as int, a@.map(|i, x: i8| x as int), result as int),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n              fn main() {\n    }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_869.rs,52,52,1.0,92.007,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int) -> bool
{
  a >= 1 && b >= 1
}

spec fn max_different_days(a: int, b: int) -> int
{
  if a < b { a } else { b }
}

spec fn remaining_after_different(a: int, b: int) -> int
{
  if a > b { a - max_different_days(a, b) } else { b - max_different_days(a, b) }
}

spec fn same_days(a: int, b: int) -> int
{
  remaining_after_different(a, b) / 2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8) -> (result: (i8, i8))
  requires valid_input(a as int, b as int)
  ensures ({
      let (days_different, days_same) = result;
      days_different as int == max_different_days(a as int, b as int) &&
      days_same as int == same_days(a as int, b as int) &&
      days_different >= 0 &&
      days_same >= 0 &&
      days_different <= a && days_different <= b
  })
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int) -> bool
{
  a >= 1 && b >= 1
}

spec fn max_different_days(a: int, b: int) -> int
{
  if a < b { a } else { b }
}

spec fn remaining_after_different(a: int, b: int) -> int
{
  if a > b { a - max_different_days(a, b) } else { b - max_different_days(a, b) }
}

spec fn same_days(a: int, b: int) -> int
{
  remaining_after_different(a, b) / 2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8) -> (result: (i8, i8))
  requires valid_input(a as int, b as int)
  ensures ({
      let (days_different, days_same) = result;
      days_different as int == max_different_days(a as int, b as int) &&
      days_same as int == same_days(a as int, b as int) &&
      days_different >= 0 &&
      days_same >= 0 &&
      days_different <= a && days_different <= b
  })
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int) -> bool\n{\n  a >= 1 && b >= 1\n}\n\nspec fn max_different_days(a: int, b: int) -> int\n{\n  if a < b { a } else { b }\n}\n\nspec fn remaining_after_different(a: int, b: int) -> int\n{\n  if a > b { a - max_different_days(a, b) } else { b - max_different_days(a, b) }\n}\n\nspec fn same_days(a: int, b: int) -> int\n{\n  remaining_after_different(a, b) / 2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8) -> (result: (i8, i8))\n  requires valid_input(a as int, b as int)\n  ensures ({\n      let (days_different, days_same) = result;\n      days_different as int == max_different_days(a as int, b as int) &&\n      days_same as int == same_days(a as int, b as int) &&\n      days_different >= 0 &&\n      days_same >= 0 &&\n      days_different <= a && days_different <= b\n  })\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_883.rs,69,69,1.0,122.402,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, friends: Seq<int>) -> bool {
  n >= 1 && friends.len() == n && forall|i: int| 0 <= i < friends.len() ==> #[trigger] friends[i] >= 1 && #[trigger] friends[i] <= 5
}

spec fn sum_sequence(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0 } else { s[0] + sum_sequence(s.subrange(1, s.len() as int)) }
}

spec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {
  &&& valid_input(n, friends)
  &&& 1 <= dima_fingers <= 5
  &&& {
    let total_sum = sum_sequence(friends) + dima_fingers;
    let total_people = n + 1;
    total_sum % total_people == 1
  }
}

spec fn count_valid_choices(n: int, friends: Seq<int>) -> int {
  if valid_input(n, friends) {
    count_valid_choices_helper(n, friends, 1)
  } else {
    0
  }
}

spec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int
  decreases 6 - finger_count
{
  if !(valid_input(n, friends) && 1 <= finger_count <= 6) {
    0
  } else if finger_count > 5 {
    0
  } else if !dima_cleans(n, friends, finger_count) {
    1 + count_valid_choices_helper(n, friends, finger_count + 1)
  } else {
    count_valid_choices_helper(n, friends, finger_count + 1)
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, friends: Vec<i8>) -> (result: i8)
  requires 
    valid_input(n as int, friends@.map_values(|x: i8| x as int))
  ensures 
    0 <= result <= 5,
    result as int == count_valid_choices(n as int, friends@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, friends: Seq<int>) -> bool {
  n >= 1 && friends.len() == n && forall|i: int| 0 <= i < friends.len() ==> #[trigger] friends[i] >= 1 && #[trigger] friends[i] <= 5
}

spec fn sum_sequence(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0 } else { s[0] + sum_sequence(s.subrange(1, s.len() as int)) }
}

spec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {
  &&& valid_input(n, friends)
  &&& 1 <= dima_fingers <= 5
  &&& {
    let total_sum = sum_sequence(friends) + dima_fingers;
    let total_people = n + 1;
    total_sum % total_people == 1
  }
}

spec fn count_valid_choices(n: int, friends: Seq<int>) -> int {
  if valid_input(n, friends) {
    count_valid_choices_helper(n, friends, 1)
  } else {
    0
  }
}

spec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int
  decreases 6 - finger_count
{
  if !(valid_input(n, friends) && 1 <= finger_count <= 6) {
    0
  } else if finger_count > 5 {
    0
  } else if !dima_cleans(n, friends, finger_count) {
    1 + count_valid_choices_helper(n, friends, finger_count + 1)
  } else {
    count_valid_choices_helper(n, friends, finger_count + 1)
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, friends: Vec<i8>) -> (result: i8)
  requires 
    valid_input(n as int, friends@.map_values(|x: i8| x as int))
  ensures 
    0 <= result <= 5,
    result as int == count_valid_choices(n as int, friends@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, friends: Seq<int>) -> bool {\n  n >= 1 && friends.len() == n && forall|i: int| 0 <= i < friends.len() ==> #[trigger] friends[i] >= 1 && #[trigger] friends[i] <= 5\n}\n\nspec fn sum_sequence(s: Seq<int>) -> int\n  decreases s.len()\n{\n  if s.len() == 0 { 0 } else { s[0] + sum_sequence(s.subrange(1, s.len() as int)) }\n}\n\nspec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {\n  &&& valid_input(n, friends)\n  &&& 1 <= dima_fingers <= 5\n  &&& {\n    let total_sum = sum_sequence(friends) + dima_fingers;\n    let total_people = n + 1;\n    total_sum % total_people == 1\n  }\n}\n\nspec fn count_valid_choices(n: int, friends: Seq<int>) -> int {\n  if valid_input(n, friends) {\n    count_valid_choices_helper(n, friends, 1)\n  } else {\n    0\n  }\n}\n\nspec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int\n  decreases 6 - finger_count\n{\n  if !(valid_input(n, friends) && 1 <= finger_count <= 6) {\n    0\n  } else if finger_count > 5 {\n    0\n  } else if !dima_cleans(n, friends, finger_count) {\n    1 + count_valid_choices_helper(n, friends, finger_count + 1)\n  } else {\n    count_valid_choices_helper(n, friends, finger_count + 1)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, friends: Vec<i8>) -> (result: i8)\n  requires \n    valid_input(n as int, friends@.map_values(|x: i8| x as int))\n  ensures \n    0 <= result <= 5,\n    result as int == count_valid_choices(n as int, friends@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_895.rs,71,71,1.0,122.615,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {
    n >= 1 && times.len() == n && T >= 1 && 
    forall|i: int| 0 <= i < times.len() ==> 1 <= #[trigger] times[i] <= 1000
}

spec fn max_students_in_window(times: Seq<int>, T: int) -> int {
    max_students_in_window_up_to(times, T, 1000)
}

spec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int
    decreases max_start
{
    if max_start < 1 { 
        0
    } else {
        let count = count_students_in_window(times, max_start, T);
        let rest_max = max_students_in_window_up_to(times, T, max_start - 1);
        if count > rest_max { count } else { rest_max }
    }
}

spec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {
    if times.len() == 0 { 
        0 
    } else { 
        count_students_in_window_helper(times, start, T, 0) 
    }
}

spec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int
    decreases times.len() - index
{
    if index >= times.len() { 
        0
    } else {
        let count_rest = count_students_in_window_helper(times, start, T, index + 1);
        if start <= times[index] <= start + T - 1 { 
            count_rest + 1 
        } else { 
            count_rest 
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, times: Vec<i8>, T: i8) -> (result: i8)
    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)
    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    n
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {
    n >= 1 && times.len() == n && T >= 1 && 
    forall|i: int| 0 <= i < times.len() ==> 1 <= #[trigger] times[i] <= 1000
}

spec fn max_students_in_window(times: Seq<int>, T: int) -> int {
    max_students_in_window_up_to(times, T, 1000)
}

spec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int
    decreases max_start
{
    if max_start < 1 { 
        0
    } else {
        let count = count_students_in_window(times, max_start, T);
        let rest_max = max_students_in_window_up_to(times, T, max_start - 1);
        if count > rest_max { count } else { rest_max }
    }
}

spec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {
    if times.len() == 0 { 
        0 
    } else { 
        count_students_in_window_helper(times, start, T, 0) 
    }
}

spec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int
    decreases times.len() - index
{
    if index >= times.len() { 
        0
    } else {
        let count_rest = count_students_in_window_helper(times, start, T, index + 1);
        if start <= times[index] <= start + T - 1 { 
            count_rest + 1 
        } else { 
            count_rest 
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, times: Vec<i8>, T: i8) -> (result: i8)
    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)
    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    n
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {\n    n >= 1 && times.len() == n && T >= 1 && \n    forall|i: int| 0 <= i < times.len() ==> 1 <= #[trigger] times[i] <= 1000\n}\n\nspec fn max_students_in_window(times: Seq<int>, T: int) -> int {\n    max_students_in_window_up_to(times, T, 1000)\n}\n\nspec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int\n    decreases max_start\n{\n    if max_start < 1 { \n        0\n    } else {\n        let count = count_students_in_window(times, max_start, T);\n        let rest_max = max_students_in_window_up_to(times, T, max_start - 1);\n        if count > rest_max { count } else { rest_max }\n    }\n}\n\nspec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {\n    if times.len() == 0 { \n        0 \n    } else { \n        count_students_in_window_helper(times, start, T, 0) \n    }\n}\n\nspec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int\n    decreases times.len() - index\n{\n    if index >= times.len() { \n        0\n    } else {\n        let count_rest = count_students_in_window_helper(times, start, T, index + 1);\n        if start <= times[index] <= start + T - 1 { \n            count_rest + 1 \n        } else { \n            count_rest \n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, times: Vec<i8>, T: i8) -> (result: i8)\n    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)\n    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    n\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_909.rs,55,55,1.0,92.187,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10
}

spec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {
    seq![a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]
}

spec fn max_expression(a: int, b: int, c: int) -> int
    recommends valid_input(a, b, c)
{
    let exprs = all_expressions(a, b, c);
    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] { exprs[0] }
    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] { exprs[1] }
    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] { exprs[2] }
    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] { exprs[3] }
    else if exprs[4] >= exprs[5] { exprs[4] }
    else { exprs[5] }
}

spec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool
    recommends valid_input(a, b, c)
{
    let exprs = all_expressions(a, b, c);
    exprs.contains(result) && forall|i: int| 0 <= i < exprs.len() ==> result >= exprs[i]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int),
    ensures 
        is_max_of_all_expressions(result as int, a as int, b as int, c as int),
        result as int == max_expression(a as int, b as int, c as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10
}

spec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {
    seq![a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]
}

spec fn max_expression(a: int, b: int, c: int) -> int
    recommends valid_input(a, b, c)
{
    let exprs = all_expressions(a, b, c);
    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] { exprs[0] }
    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] { exprs[1] }
    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] { exprs[2] }
    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] { exprs[3] }
    else if exprs[4] >= exprs[5] { exprs[4] }
    else { exprs[5] }
}

spec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool
    recommends valid_input(a, b, c)
{
    let exprs = all_expressions(a, b, c);
    exprs.contains(result) && forall|i: int| 0 <= i < exprs.len() ==> result >= exprs[i]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int),
    ensures 
        is_max_of_all_expressions(result as int, a as int, b as int, c as int),
        result as int == max_expression(a as int, b as int, c as int),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int) -> bool {\n    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10\n}\n\nspec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {\n    seq![a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]\n}\n\nspec fn max_expression(a: int, b: int, c: int) -> int\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] { exprs[0] }\n    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] { exprs[1] }\n    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] { exprs[2] }\n    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] { exprs[3] }\n    else if exprs[4] >= exprs[5] { exprs[4] }\n    else { exprs[5] }\n}\n\nspec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool\n    recommends valid_input(a, b, c)\n{\n    let exprs = all_expressions(a, b, c);\n    exprs.contains(result) && forall|i: int| 0 <= i < exprs.len() ==> result >= exprs[i]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: i8, b: i8, c: i8) -> (result: i8)\n    requires \n        valid_input(a as int, b as int, c as int),\n    ensures \n        is_max_of_all_expressions(result as int, a as int, b as int, c as int),\n        result as int == max_expression(a as int, b as int, c as int),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_925.rs,60,60,1.0,92.089,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 2 && 
    '0' <= input[0] <= '9' && 
    '0' <= input[1] <= '9' &&
    (input[input.len() - 1] == '\n' || (input[0] != '\n' && input[1] != '\n'))
}

spec fn good_digit_count(digit: char) -> int 
    recommends '0' <= digit <= '9'
{
    if digit == '0' { 2 }
    else if digit == '1' { 7 }
    else if digit == '2' { 2 }
    else if digit == '3' { 3 }
    else if digit == '4' { 3 }
    else if digit == '5' { 4 }
    else if digit == '6' { 2 }
    else if digit == '7' { 5 }
    else if digit == '8' { 1 }
    else { 2 }
}

spec fn compute_total_good_count(input: Seq<char>) -> int 
    recommends valid_input(input)
{
    good_digit_count(input[0]) * good_digit_count(input[1])
}

spec fn valid_output(result: Seq<char>, expected_count: int) -> bool {
    result.len() >= 2 && 
    result[result.len() - 1] == '\n' &&
    (forall|c: char| result.contains(c) ==> c == '\n' || ('0' <= c <= '9')) &&
    expected_count >= 1 && expected_count <= 49
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(result@, compute_total_good_count(input@))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 2 && 
    '0' <= input[0] <= '9' && 
    '0' <= input[1] <= '9' &&
    (input[input.len() - 1] == '\n' || (input[0] != '\n' && input[1] != '\n'))
}

spec fn good_digit_count(digit: char) -> int 
    recommends '0' <= digit <= '9'
{
    if digit == '0' { 2 }
    else if digit == '1' { 7 }
    else if digit == '2' { 2 }
    else if digit == '3' { 3 }
    else if digit == '4' { 3 }
    else if digit == '5' { 4 }
    else if digit == '6' { 2 }
    else if digit == '7' { 5 }
    else if digit == '8' { 1 }
    else { 2 }
}

spec fn compute_total_good_count(input: Seq<char>) -> int 
    recommends valid_input(input)
{
    good_digit_count(input[0]) * good_digit_count(input[1])
}

spec fn valid_output(result: Seq<char>, expected_count: int) -> bool {
    result.len() >= 2 && 
    result[result.len() - 1] == '\n' &&
    (forall|c: char| result.contains(c) ==> c == '\n' || ('0' <= c <= '9')) &&
    expected_count >= 1 && expected_count <= 49
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(result@, compute_total_good_count(input@))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 2 && \n    '0' <= input[0] <= '9' && \n    '0' <= input[1] <= '9' &&\n    (input[input.len() - 1] == '\\n' || (input[0] != '\\n' && input[1] != '\\n'))\n}\n\nspec fn good_digit_count(digit: char) -> int \n    recommends '0' <= digit <= '9'\n{\n    if digit == '0' { 2 }\n    else if digit == '1' { 7 }\n    else if digit == '2' { 2 }\n    else if digit == '3' { 3 }\n    else if digit == '4' { 3 }\n    else if digit == '5' { 4 }\n    else if digit == '6' { 2 }\n    else if digit == '7' { 5 }\n    else if digit == '8' { 1 }\n    else { 2 }\n}\n\nspec fn compute_total_good_count(input: Seq<char>) -> int \n    recommends valid_input(input)\n{\n    good_digit_count(input[0]) * good_digit_count(input[1])\n}\n\nspec fn valid_output(result: Seq<char>, expected_count: int) -> bool {\n    result.len() >= 2 && \n    result[result.len() - 1] == '\\n' &&\n    (forall|c: char| result.contains(c) ==> c == '\\n' || ('0' <= c <= '9')) &&\n    expected_count >= 1 && expected_count <= 49\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(input@)\n    ensures valid_output(result@, compute_total_good_count(input@))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_948.rs,54,54,1.0,92.33,True,0.7999999999999999,True,"['vstd::prelude::', 'vstd::string::']",True,,,,,,"// <vc-preamble>
use vstd::prelude::*;
use vstd::string::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    n >= 1 && m >= 1 && grid.len() == n &&
    forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == m
}

spec fn count_face_squares(input: Seq<char>) -> int
    decreases input.len()
{
    if input.len() == 0 {
        0
    } else {
        /* Parse input and count valid face squares */
        0  /* Placeholder - actual implementation would parse lines and count squares */
    }
}

spec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {
    /* Convert count to string representation */
    seq!['0', '\n']  /* Placeholder */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires 
        valid_input(input@),
    ensures 
        result@.len() > 0,
        result@ == count_face_squares_as_string(input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;
use vstd::string::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    n >= 1 && m >= 1 && grid.len() == n &&
    forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == m
}

spec fn count_face_squares(input: Seq<char>) -> int
    decreases input.len()
{
    if input.len() == 0 {
        0
    } else {
        /* Parse input and count valid face squares */
        0  /* Placeholder - actual implementation would parse lines and count squares */
    }
}

spec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {
    /* Convert count to string representation */
    seq!['0', '\n']  /* Placeholder */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires 
        valid_input(input@),
    ensures 
        result@.len() > 0,
        result@ == count_face_squares_as_string(input@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    n >= 1 && m >= 1 && grid.len() == n &&\n    forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == m\n}\n\nspec fn count_face_squares(input: Seq<char>) -> int\n    decreases input.len()\n{\n    if input.len() == 0 {\n        0\n    } else {\n        /* Parse input and count valid face squares */\n        0  /* Placeholder - actual implementation would parse lines and count squares */\n    }\n}\n\nspec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {\n    /* Convert count to string representation */\n    seq!['0', '\\n']  /* Placeholder */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n    requires \n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        result@ == count_face_squares_as_string(input@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_954.rs,50,50,1.0,92.049,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>
{
    if s.len() > 0 { s.subrange(1, s.len() as int).add(seq![s[0]]) } else { s }
}

spec fn valid_input(s: Seq<char>) -> bool
{
    s.len() > 0
}

spec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>
    decreases steps
{
    if s.len() > 0 && steps > 0 { cyclic_shift_forward(apply_shifts(s, (steps - 1) as nat)) }
    else if s.len() > 0 { s }
    else { s }
}

spec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat
{
    if s.len() > 0 { s.len() } else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: usize)
    requires 
        valid_input(s@),
    ensures 
        1 <= result <= s.len(),
        result == all_distinct_cyclic_shifts(s@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>
{
    if s.len() > 0 { s.subrange(1, s.len() as int).add(seq![s[0]]) } else { s }
}

spec fn valid_input(s: Seq<char>) -> bool
{
    s.len() > 0
}

spec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>
    decreases steps
{
    if s.len() > 0 && steps > 0 { cyclic_shift_forward(apply_shifts(s, (steps - 1) as nat)) }
    else if s.len() > 0 { s }
    else { s }
}

spec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat
{
    if s.len() > 0 { s.len() } else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Vec<char>) -> (result: usize)
    requires 
        valid_input(s@),
    ensures 
        1 <= result <= s.len(),
        result == all_distinct_cyclic_shifts(s@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>\n{\n    if s.len() > 0 { s.subrange(1, s.len() as int).add(seq![s[0]]) } else { s }\n}\n\nspec fn valid_input(s: Seq<char>) -> bool\n{\n    s.len() > 0\n}\n\nspec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>\n    decreases steps\n{\n    if s.len() > 0 && steps > 0 { cyclic_shift_forward(apply_shifts(s, (steps - 1) as nat)) }\n    else if s.len() > 0 { s }\n    else { s }\n}\n\nspec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat\n{\n    if s.len() > 0 { s.len() } else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: Vec<char>) -> (result: usize)\n    requires \n        valid_input(s@),\n    ensures \n        1 <= result <= s.len(),\n        result == all_distinct_cyclic_shifts(s@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_963.rs,72,72,1.0,92.324,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {
    n >= 2 &&
    k >= 1 &&
    segments.len() == k &&
    (forall|i: int| 0 <= i < k ==> segments[i].0 >= 1 && segments[i].1 <= n && segments[i].0 <= segments[i].1) &&
    (forall|i: int, j: int| 0 <= i < j < k ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)
}

spec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {
    let dp = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });
    let prefix_sum = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });
    compute_ways_dp_helper(n, k, segments, dp, prefix_sum, 2)
}

spec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int
    decreases n - pos + 1
{
    if pos > n {
        dp[n] % 998244353
    } else {
        let new_dp_val = compute_segment_contributions(pos, k, segments, prefix_sum, 0, 0);
        let new_prefix_sum_val = (prefix_sum[pos-1] + new_dp_val) % 998244353;
        let updated_dp = dp.insert(pos, new_dp_val);
        let updated_prefix_sum = prefix_sum.insert(pos, new_prefix_sum_val);
        compute_ways_dp_helper(n, k, segments, updated_dp, updated_prefix_sum, pos + 1)
    }
}

spec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int
    decreases k - seg_index
{
    if seg_index >= k {
        acc
    } else {
        let start = segments[seg_index].0;
        let end = segments[seg_index].1;
        let i_s = if pos - start >= 0 { pos - start } else { 0 };
        let i_e = if pos - end - 1 >= 0 { pos - end - 1 } else { 0 };
        let contribution = (prefix_sum[i_s] - prefix_sum[i_e] + 998244353) % 998244353;
        let new_acc = (acc + contribution) % 998244353;
        compute_segment_contributions(pos, k, segments, prefix_sum, seg_index + 1, new_acc)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, segments: Vec<(i8, i8)>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))
    ensures 
        result < 998244353 &&
        result == compute_ways_dp(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {
    n >= 2 &&
    k >= 1 &&
    segments.len() == k &&
    (forall|i: int| 0 <= i < k ==> segments[i].0 >= 1 && segments[i].1 <= n && segments[i].0 <= segments[i].1) &&
    (forall|i: int, j: int| 0 <= i < j < k ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)
}

spec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {
    let dp = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });
    let prefix_sum = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });
    compute_ways_dp_helper(n, k, segments, dp, prefix_sum, 2)
}

spec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int
    decreases n - pos + 1
{
    if pos > n {
        dp[n] % 998244353
    } else {
        let new_dp_val = compute_segment_contributions(pos, k, segments, prefix_sum, 0, 0);
        let new_prefix_sum_val = (prefix_sum[pos-1] + new_dp_val) % 998244353;
        let updated_dp = dp.insert(pos, new_dp_val);
        let updated_prefix_sum = prefix_sum.insert(pos, new_prefix_sum_val);
        compute_ways_dp_helper(n, k, segments, updated_dp, updated_prefix_sum, pos + 1)
    }
}

spec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int
    decreases k - seg_index
{
    if seg_index >= k {
        acc
    } else {
        let start = segments[seg_index].0;
        let end = segments[seg_index].1;
        let i_s = if pos - start >= 0 { pos - start } else { 0 };
        let i_e = if pos - end - 1 >= 0 { pos - end - 1 } else { 0 };
        let contribution = (prefix_sum[i_s] - prefix_sum[i_e] + 998244353) % 998244353;
        let new_acc = (acc + contribution) % 998244353;
        compute_segment_contributions(pos, k, segments, prefix_sum, seg_index + 1, new_acc)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, segments: Vec<(i8, i8)>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))
    ensures 
        result < 998244353 &&
        result == compute_ways_dp(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {\n    n >= 2 &&\n    k >= 1 &&\n    segments.len() == k &&\n    (forall|i: int| 0 <= i < k ==> segments[i].0 >= 1 && segments[i].1 <= n && segments[i].0 <= segments[i].1) &&\n    (forall|i: int, j: int| 0 <= i < j < k ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)\n}\n\nspec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {\n    let dp = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    let prefix_sum = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });\n    compute_ways_dp_helper(n, k, segments, dp, prefix_sum, 2)\n}\n\nspec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int\n    decreases n - pos + 1\n{\n    if pos > n {\n        dp[n] % 998244353\n    } else {\n        let new_dp_val = compute_segment_contributions(pos, k, segments, prefix_sum, 0, 0);\n        let new_prefix_sum_val = (prefix_sum[pos-1] + new_dp_val) % 998244353;\n        let updated_dp = dp.insert(pos, new_dp_val);\n        let updated_prefix_sum = prefix_sum.insert(pos, new_prefix_sum_val);\n        compute_ways_dp_helper(n, k, segments, updated_dp, updated_prefix_sum, pos + 1)\n    }\n}\n\nspec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int\n    decreases k - seg_index\n{\n    if seg_index >= k {\n        acc\n    } else {\n        let start = segments[seg_index].0;\n        let end = segments[seg_index].1;\n        let i_s = if pos - start >= 0 { pos - start } else { 0 };\n        let i_e = if pos - end - 1 >= 0 { pos - end - 1 } else { 0 };\n        let contribution = (prefix_sum[i_s] - prefix_sum[i_e] + 998244353) % 998244353;\n        let new_acc = (acc + contribution) % 998244353;\n        compute_segment_contributions(pos, k, segments, prefix_sum, seg_index + 1, new_acc)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, k: i8, segments: Vec<(i8, i8)>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n    ensures \n        result < 998244353 &&\n        result == compute_ways_dp(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_965.rs,59,59,1.0,92.266,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, statuses: Seq<char>) -> bool {
    n >= 2 && statuses.len() == n && 
    forall|i: int| 0 <= i < statuses.len() ==> (statuses[i] == 'A' || statuses[i] == 'I' || statuses[i] == 'F')
}

spec fn count_status(statuses: Seq<char>, status: char) -> int {
    seq_count(statuses, status)
}

spec fn seq_count(s: Seq<char>, target: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        let rest_count = seq_count(s.drop_first(), target);
        if s[0] == target {
            rest_count + 1
        } else {
            rest_count
        }
    }
}

spec fn expected_result(statuses: Seq<char>) -> int {
    let cnt_i = count_status(statuses, 'I');
    let cnt_a = count_status(statuses, 'A');
    if cnt_i == 0 { cnt_a }
    else if cnt_i == 1 { 1 }
    else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, statuses: Vec<char>) -> (result: i8)
    requires valid_input(n as int, statuses@)
    ensures result as int == expected_result(statuses@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, statuses: Seq<char>) -> bool {
    n >= 2 && statuses.len() == n && 
    forall|i: int| 0 <= i < statuses.len() ==> (statuses[i] == 'A' || statuses[i] == 'I' || statuses[i] == 'F')
}

spec fn count_status(statuses: Seq<char>, status: char) -> int {
    seq_count(statuses, status)
}

spec fn seq_count(s: Seq<char>, target: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        let rest_count = seq_count(s.drop_first(), target);
        if s[0] == target {
            rest_count + 1
        } else {
            rest_count
        }
    }
}

spec fn expected_result(statuses: Seq<char>) -> int {
    let cnt_i = count_status(statuses, 'I');
    let cnt_a = count_status(statuses, 'A');
    if cnt_i == 0 { cnt_a }
    else if cnt_i == 1 { 1 }
    else { 0 }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, statuses: Vec<char>) -> (result: i8)
    requires valid_input(n as int, statuses@)
    ensures result as int == expected_result(statuses@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, statuses: Seq<char>) -> bool {\n    n >= 2 && statuses.len() == n && \n    forall|i: int| 0 <= i < statuses.len() ==> (statuses[i] == 'A' || statuses[i] == 'I' || statuses[i] == 'F')\n}\n\nspec fn count_status(statuses: Seq<char>, status: char) -> int {\n    seq_count(statuses, status)\n}\n\nspec fn seq_count(s: Seq<char>, target: char) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let rest_count = seq_count(s.drop_first(), target);\n        if s[0] == target {\n            rest_count + 1\n        } else {\n            rest_count\n        }\n    }\n}\n\nspec fn expected_result(statuses: Seq<char>) -> int {\n    let cnt_i = count_status(statuses, 'I');\n    let cnt_a = count_status(statuses, 'A');\n    if cnt_i == 0 { cnt_a }\n    else if cnt_i == 1 { 1 }\n    else { 0 }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, statuses: Vec<char>) -> (result: i8)\n    requires valid_input(n as int, statuses@)\n    ensures result as int == expected_result(statuses@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_967.rs,65,65,1.0,122.451,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])
}

spec fn valid_output(n: int, result: int) -> bool {
    0 <= result <= n
}

spec fn reversed_array(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
{
    Seq::new(a.len(), |i: int| a[a.len() - 1 - i])
}

spec fn has_increasing_pair(ar: Seq<int>) -> bool {
    exists|i: int| 1 <= i < ar.len() && #[trigger] ar[i] > ar[i-1]
}

spec fn min_index(ar: Seq<int>, n: int) -> int {
    0
}

spec fn correct_result(n: int, a: Seq<int>) -> int
    recommends valid_input(n, a)
{
    let ar = reversed_array(a);
    if has_increasing_pair(ar) {
        let min_i = min_index(ar, n);
        n - min_i
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map_values(|x: i8| x as int))
    ensures 
        valid_output(n as int, result as int) &&
        result as int == correct_result(n as int, a@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])
}

spec fn valid_output(n: int, result: int) -> bool {
    0 <= result <= n
}

spec fn reversed_array(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
{
    Seq::new(a.len(), |i: int| a[a.len() - 1 - i])
}

spec fn has_increasing_pair(ar: Seq<int>) -> bool {
    exists|i: int| 1 <= i < ar.len() && #[trigger] ar[i] > ar[i-1]
}

spec fn min_index(ar: Seq<int>, n: int) -> int {
    0
}

spec fn correct_result(n: int, a: Seq<int>) -> int
    recommends valid_input(n, a)
{
    let ar = reversed_array(a);
    if has_increasing_pair(ar) {
        let min_i = min_index(ar, n);
        n - min_i
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map_values(|x: i8| x as int))
    ensures 
        valid_output(n as int, result as int) &&
        result as int == correct_result(n as int, a@.map_values(|x: i8| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])\n}\n\nspec fn valid_output(n: int, result: int) -> bool {\n    0 <= result <= n\n}\n\nspec fn reversed_array(a: Seq<int>) -> Seq<int>\n    recommends a.len() >= 1\n{\n    Seq::new(a.len(), |i: int| a[a.len() - 1 - i])\n}\n\nspec fn has_increasing_pair(ar: Seq<int>) -> bool {\n    exists|i: int| 1 <= i < ar.len() && #[trigger] ar[i] > ar[i-1]\n}\n\nspec fn min_index(ar: Seq<int>, n: int) -> int {\n    0\n}\n\nspec fn correct_result(n: int, a: Seq<int>) -> int\n    recommends valid_input(n, a)\n{\n    let ar = reversed_array(a);\n    if has_increasing_pair(ar) {\n        let min_i = min_index(ar, n);\n        n - min_i\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, a@.map_values(|x: i8| x as int))\n    ensures \n        valid_output(n as int, result as int) &&\n        result as int == correct_result(n as int, a@.map_values(|x: i8| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_968.rs,174,23,0.13218390804597702,184.227,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool
  recommends input.len() > 0
{
  let parsed = parse_input(input);
  parsed.valid && 
  parsed.n >= 1 && 
  parsed.names.len() == parsed.n &&
  parsed.permutation.len() == parsed.n &&
  permutation_values_in_range(parsed.permutation, parsed.n) &&
  permutation_is_unique(parsed.permutation, parsed.n) &&
  names_are_non_empty(parsed.names, parsed.n) &&
  all_names_distinct(parsed.names)
}

spec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool {
  forall|i: int| 0 <= i < n ==> {
    let val = #[trigger] permutation[i];
    1 <= val <= n
  }
}

spec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool {
  forall|i: int, j: int| 0 <= i < j < n ==> {
    #[trigger] permutation[i] != #[trigger] permutation[j]
  }
}

spec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool {
  forall|i: int| 0 <= i < n ==> {
    let name_pair = #[trigger] names[i];
    name_pair.0.len() > 0 && name_pair.1.len() > 0
  }
}

spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool
{
  forall|i: int, j: int| 0 <= i < names.len() && 0 <= j < names.len() ==>
    (i != j ==> {
      let name_i = #[trigger] names[i];
      let name_j = #[trigger] names[j];
      name_i.0 != name_j.0 && name_i.0 != name_j.1 && 
      name_i.1 != name_j.0 && name_i.1 != name_j.1
    })
}

spec fn can_assign_handles_greedy(input: Seq<char>) -> bool
  recommends input.len() > 0 && valid_input(input)
{
  let parsed = parse_input(input);
  let all_handles = create_all_handle_pairs(parsed.names);
  let sorted_handles = sort_handle_pairs(all_handles);
  greedy_assignment_works(sorted_handles, parsed.permutation, parsed.n)
}

struct ParseResult {
  valid: bool,
  n: int,
  names: Seq<(Seq<char>, Seq<char>)>,
  permutation: Seq<int>,
}

struct IntResult {
  valid: bool,
  value: int,
}

struct IntSequenceResult {
  valid: bool,
  sequence: Seq<int>,
}

spec fn parse_input(input: Seq<char>) -> ParseResult
  recommends input.len() > 0
{
  let lines = split_lines(input);
  if lines.len() < 2 {
    ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }
  } else {
    let n_result = parse_int(lines[0]);
    if !n_result.valid || n_result.value <= 0 || lines.len() != n_result.value + 2 {
      ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }
    } else {
      let names = parse_names(lines.subrange(1, n_result.value + 1));
      let perm = parse_int_sequence(lines[n_result.value + 1]);
      if names.len() == n_result.value && perm.valid && perm.sequence.len() == n_result.value {
        ParseResult { valid: true, n: n_result.value, names: names, permutation: perm.sequence }
      } else {
        ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }
      }
    }
  }
}

spec fn lex_less(a: Seq<char>, b: Seq<char>) -> bool
  decreases a.len()
{
  if a.len() == 0 {
    b.len() > 0
  } else if b.len() == 0 {
    false
  } else if a[0] < b[0] {
    true
  } else if a[0] > b[0] {
    false
  } else {
    lex_less(a.subrange(1, a.len() as int), b.subrange(1, b.len() as int))
  }
}

spec fn lex_less_or_equal(a: Seq<char>, b: Seq<char>) -> bool
{
  lex_less(a, b) || a == b
}

/* Placeholder spec functions for missing dependencies */
spec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
  seq![]
}

spec(checked) fn parse_int(line: Seq<char>) -> IntResult {
  IntResult { valid: false, value: 0 }
}

spec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> {
  seq![]
}

spec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult {
  IntSequenceResult { valid: false, sequence: seq![] }
}

spec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> {
  seq![]
}

spec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> {
  handles
}

spec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool {
  false
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
  requires
    stdin_input@.len() > 0,
    valid_input(stdin_input@),
  ensures
    result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
    (result@ == seq!['Y', 'E', 'S']) <==> can_assign_handles_greedy(stdin_input@),
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  vec!['N', 'O']
  // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool ;
       spec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool ;
       spec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool ;
       spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool ;
       struct ParseResult {
        valid: bool,   n: int,   names: Seq<(Seq<char>, Seq<char>)>,   permutation: Seq<int>, }
       struct IntResult {
        valid: bool,   value: int, }
       struct IntSequenceResult {
        valid: bool,   sequence: Seq<int>, }
       spec fn parse_input(input: Seq<char>) -> ParseResult   recommends input.len() > 0 ;
       spec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;
       spec(checked) fn parse_int(line: Seq<char>) -> IntResult ;
       spec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> ;
       spec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult ;
       spec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> ;
       spec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> ;
       spec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool ;
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool\n  recommends input.len() > 0\n{\n  let parsed = parse_input(input);\n  parsed.valid && \n  parsed.n >= 1 && \n  parsed.names.len() == parsed.n &&\n  parsed.permutation.len() == parsed.n &&\n  permutation_values_in_range(parsed.permutation, parsed.n) &&\n  permutation_is_unique(parsed.permutation, parsed.n) &&\n  names_are_non_empty(parsed.names, parsed.n) &&\n  all_names_distinct(parsed.names)\n}\n\nspec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool {\n  forall|i: int| 0 <= i < n ==> {\n    let val = #[trigger] permutation[i];\n    1 <= val <= n\n  }\n}\n\nspec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool {\n  forall|i: int, j: int| 0 <= i < j < n ==> {\n    #[trigger] permutation[i] != #[trigger] permutation[j]\n  }\n}\n\nspec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool {\n  forall|i: int| 0 <= i < n ==> {\n    let name_pair = #[trigger] names[i];\n    name_pair.0.len() > 0 && name_pair.1.len() > 0\n  }\n}\n\nspec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool\n{\n  forall|i: int, j: int| 0 <= i < names.len() && 0 <= j < names.len() ==>\n    (i != j ==> {\n      let name_i = #[trigger] names[i];\n      let name_j = #[trigger] names[j];\n      name_i.0 != name_j.0 && name_i.0 != name_j.1 && \n      name_i.1 != name_j.0 && name_i.1 != name_j.1\n    })\n}\n\nspec fn can_assign_handles_greedy(input: Seq<char>) -> bool\n  recommends input.len() > 0 && valid_input(input)\n{\n  let parsed = parse_input(input);\n  let all_handles = create_all_handle_pairs(parsed.names);\n  let sorted_handles = sort_handle_pairs(all_handles);\n  greedy_assignment_works(sorted_handles, parsed.permutation, parsed.n)\n}\n\nstruct ParseResult {\n  valid: bool,\n  n: int,\n  names: Seq<(Seq<char>, Seq<char>)>,\n  permutation: Seq<int>,\n}\n\nstruct IntResult {\n  valid: bool,\n  value: int,\n}\n\nstruct IntSequenceResult {\n  valid: bool,\n  sequence: Seq<int>,\n}\n\nspec fn parse_input(input: Seq<char>) -> ParseResult\n  recommends input.len() > 0\n{\n  let lines = split_lines(input);\n  if lines.len() < 2 {\n    ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n  } else {\n    let n_result = parse_int(lines[0]);\n    if !n_result.valid || n_result.value <= 0 || lines.len() != n_result.value + 2 {\n      ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n    } else {\n      let names = parse_names(lines.subrange(1, n_result.value + 1));\n      let perm = parse_int_sequence(lines[n_result.value + 1]);\n      if names.len() == n_result.value && perm.valid && perm.sequence.len() == n_result.value {\n        ParseResult { valid: true, n: n_result.value, names: names, permutation: perm.sequence }\n      } else {\n        ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }\n      }\n    }\n  }\n}\n\nspec fn lex_less(a: Seq<char>, b: Seq<char>) -> bool\n  decreases a.len()\n{\n  if a.len() == 0 {\n    b.len() > 0\n  } else if b.len() == 0 {\n    false\n  } else if a[0] < b[0] {\n    true\n  } else if a[0] > b[0] {\n    false\n  } else {\n    lex_less(a.subrange(1, a.len() as int), b.subrange(1, b.len() as int))\n  }\n}\n\nspec fn lex_less_or_equal(a: Seq<char>, b: Seq<char>) -> bool\n{\n  lex_less(a, b) || a == b\n}\n\n/* Placeholder spec functions for missing dependencies */\nspec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n  seq![]\n}\n\nspec(checked) fn parse_int(line: Seq<char>) -> IntResult {\n  IntResult { valid: false, value: 0 }\n}\n\nspec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> {\n  seq![]\n}\n\nspec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult {\n  IntSequenceResult { valid: false, sequence: seq![] }\n}\n\nspec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> {\n  seq![]\n}\n\nspec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> {\n  handles\n}\n\nspec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool {\n  false\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n  requires\n    stdin_input@.len() > 0,\n    valid_input(stdin_input@),\n  ensures\n    result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n    (result@ == seq!['Y', 'E', 'S']) <==> can_assign_handles_greedy(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  vec!['N', 'O']\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool ;\n       spec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool ;\n       spec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool ;\n       spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool ;\n       struct ParseResult {\n        valid: bool,   n: int,   names: Seq<(Seq<char>, Seq<char>)>,   permutation: Seq<int>, }\n       struct IntResult {\n        valid: bool,   value: int, }\n       struct IntSequenceResult {\n        valid: bool,   sequence: Seq<int>, }\n       spec fn parse_input(input: Seq<char>) -> ParseResult   recommends input.len() > 0 ;\n       spec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec(checked) fn parse_int(line: Seq<char>) -> IntResult ;\n       spec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> ;\n       spec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult ;\n       spec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> ;\n       spec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> ;\n       spec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool ;\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n          fn main() {\n}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_983.rs,60,60,1.0,92.455,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn max_prefix(s: Seq<int>, i: nat) -> int
    recommends i < s.len()
    decreases i
{
    if i == 0 { s[0] }
    else if s[i as int] > max_prefix(s, (i-1) as nat) { s[i as int] }
    else { max_prefix(s, (i-1) as nat) }
}

spec fn max_seq(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { s[0] }
    else {
        let sub_seq = s.subrange(0, (s.len()-1) as int);
        if s[(s.len()-1) as int] > max_seq(sub_seq) { s[(s.len()-1) as int] }
        else { max_seq(sub_seq) }
    }
}

spec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int
    recommends n > 0 && a.len() == n
{
    let s1 = Seq::new(n as nat, |i: int| a[i] * p);
    let s2 = Seq::new(n as nat, |i: int| max_prefix(s1, i as nat) + a[i] * q);
    let s3 = Seq::new(n as nat, |i: int| max_prefix(s2, i as nat) + a[i] * r);
    max_seq(s3)
}

spec fn valid_input(n: int, a: Seq<int>) -> bool
{
    n > 0 && a.len() == n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: i8, q: i8, r: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|i, x| x as int))
    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn max_prefix(s: Seq<int>, i: nat) -> int
    recommends i < s.len()
    decreases i
{
    if i == 0 { s[0] }
    else if s[i as int] > max_prefix(s, (i-1) as nat) { s[i as int] }
    else { max_prefix(s, (i-1) as nat) }
}

spec fn max_seq(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { s[0] }
    else {
        let sub_seq = s.subrange(0, (s.len()-1) as int);
        if s[(s.len()-1) as int] > max_seq(sub_seq) { s[(s.len()-1) as int] }
        else { max_seq(sub_seq) }
    }
}

spec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int
    recommends n > 0 && a.len() == n
{
    let s1 = Seq::new(n as nat, |i: int| a[i] * p);
    let s2 = Seq::new(n as nat, |i: int| max_prefix(s1, i as nat) + a[i] * q);
    let s3 = Seq::new(n as nat, |i: int| max_prefix(s2, i as nat) + a[i] * r);
    max_seq(s3)
}

spec fn valid_input(n: int, a: Seq<int>) -> bool
{
    n > 0 && a.len() == n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: i8, q: i8, r: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|i, x| x as int))
    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn max_prefix(s: Seq<int>, i: nat) -> int\n    recommends i < s.len()\n    decreases i\n{\n    if i == 0 { s[0] }\n    else if s[i as int] > max_prefix(s, (i-1) as nat) { s[i as int] }\n    else { max_prefix(s, (i-1) as nat) }\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n    decreases s.len()\n    when s.len() > 0\n{\n    if s.len() == 1 { s[0] }\n    else {\n        let sub_seq = s.subrange(0, (s.len()-1) as int);\n        if s[(s.len()-1) as int] > max_seq(sub_seq) { s[(s.len()-1) as int] }\n        else { max_seq(sub_seq) }\n    }\n}\n\nspec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int\n    recommends n > 0 && a.len() == n\n{\n    let s1 = Seq::new(n as nat, |i: int| a[i] * p);\n    let s2 = Seq::new(n as nat, |i: int| max_prefix(s1, i as nat) + a[i] * q);\n    let s3 = Seq::new(n as nat, |i: int| max_prefix(s2, i as nat) + a[i] * r);\n    max_seq(s3)\n}\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool\n{\n    n > 0 && a.len() == n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: i8, p: i8, q: i8, r: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|i, x| x as int))\n    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/files/apps_test_989.rs,101,101,1.0,122.416,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 5 && has_valid_format(input)
}

spec fn has_valid_format(input: Seq<char>) -> bool {
    exists|first_newline: int| 
        0 <= first_newline < input.len() 
        && #[trigger] input[first_newline] == '\n'
        && (input.len() == first_newline + 1 || input[input.len() - 1] == '\n')
}

spec fn is_valid_result_string(result: Seq<char>) -> bool {
    result.len() > 0 && 
    (result == seq!['0'] || (result[0] != '0' && forall|i: int| 0 <= i < result.len() ==> #[trigger] is_digit(result[i])))
}

spec fn is_digit(c: char) -> bool {
    '0' <= c && c <= '9'
}

spec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {
    valid_input(input) && 
    is_valid_result_string(result) &&
    result == seq!['0']
}

spec fn max(a: Seq<int>) -> int
    recommends a.len() > 0
    decreases a.len()
    when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let tail_max = max(a.subrange(1, a.len() as int));
        if a[0] >= tail_max { a[0] } else { tail_max }
    }
}

spec fn min(a: Seq<int>) -> int  
    recommends a.len() > 0
    decreases a.len()
    when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let tail_min = min(a.subrange(1, a.len() as int));
        if a[0] <= tail_min { a[0] } else { tail_min }
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_helper(n)
    } else {
        seq!['-'].add(int_to_string_helper(-n))
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![(n + 48) as char]
    } else {
        int_to_string_helper(n / 10).add(seq![(n % 10 + 48) as char])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        is_valid_result_string(result@),
        represents_minimum_difference(stdin_input@, result@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 5 && has_valid_format(input)
}

spec fn has_valid_format(input: Seq<char>) -> bool {
    exists|first_newline: int| 
        0 <= first_newline < input.len() 
        && #[trigger] input[first_newline] == '\n'
        && (input.len() == first_newline + 1 || input[input.len() - 1] == '\n')
}

spec fn is_valid_result_string(result: Seq<char>) -> bool {
    result.len() > 0 && 
    (result == seq!['0'] || (result[0] != '0' && forall|i: int| 0 <= i < result.len() ==> #[trigger] is_digit(result[i])))
}

spec fn is_digit(c: char) -> bool {
    '0' <= c && c <= '9'
}

spec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {
    valid_input(input) && 
    is_valid_result_string(result) &&
    result == seq!['0']
}

spec fn max(a: Seq<int>) -> int
    recommends a.len() > 0
    decreases a.len()
    when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let tail_max = max(a.subrange(1, a.len() as int));
        if a[0] >= tail_max { a[0] } else { tail_max }
    }
}

spec fn min(a: Seq<int>) -> int  
    recommends a.len() > 0
    decreases a.len()
    when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let tail_min = min(a.subrange(1, a.len() as int));
        if a[0] <= tail_min { a[0] } else { tail_min }
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_helper(n)
    } else {
        seq!['-'].add(int_to_string_helper(-n))
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![(n + 48) as char]
    } else {
        int_to_string_helper(n / 10).add(seq![(n % 10 + 48) as char])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        is_valid_result_string(result@),
        represents_minimum_difference(stdin_input@, result@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() >= 5 && has_valid_format(input)\n}\n\nspec fn has_valid_format(input: Seq<char>) -> bool {\n    exists|first_newline: int| \n        0 <= first_newline < input.len() \n        && #[trigger] input[first_newline] == '\\n'\n        && (input.len() == first_newline + 1 || input[input.len() - 1] == '\\n')\n}\n\nspec fn is_valid_result_string(result: Seq<char>) -> bool {\n    result.len() > 0 && \n    (result == seq!['0'] || (result[0] != '0' && forall|i: int| 0 <= i < result.len() ==> #[trigger] is_digit(result[i])))\n}\n\nspec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {\n    valid_input(input) && \n    is_valid_result_string(result) &&\n    result == seq!['0']\n}\n\nspec fn max(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_max = max(a.subrange(1, a.len() as int));\n        if a[0] >= tail_max { a[0] } else { tail_max }\n    }\n}\n\nspec fn min(a: Seq<int>) -> int  \n    recommends a.len() > 0\n    decreases a.len()\n    when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let tail_min = min(a.subrange(1, a.len() as int));\n        if a[0] <= tail_min { a[0] } else { tail_min }\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n > 0 {\n        int_to_string_helper(n)\n    } else {\n        seq!['-'].add(int_to_string_helper(-n))\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        seq![(n + 48) as char]\n    } else {\n        int_to_string_helper(n / 10).add(seq![(n % 10 + 48) as char])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        is_valid_result_string(result@),\n        represents_minimum_difference(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1013.rs,73,73,1.0,122.981,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['d', 'u', 'm', 'm', 'y']]
}

spec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['d', 'u', 'm', 'm', 'y']]
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {
    seq!['0']
}

spec fn get_n(input: Seq<char>) -> int {
    3
}

spec fn get_m(input: Seq<char>) -> int {
    3
}

spec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {
    seq!['0']
}

spec fn result_two_newline() -> Seq<char> {
    seq!['2', '\n']
}

spec fn result_four_newline() -> Seq<char> {
    seq!['4', '\n']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        input@.len() > 0,
        valid_input(input@)
    ensures
        result@ =~= result_two_newline() || result@ =~= result_four_newline(),
        result@ =~= result_two_newline() <==> (exists|i: int, j: int| 
            0 <= i < get_n(input@) && 0 <= j < get_m(input@) && 
            get_grid_cell(input@, i, j) =~= seq!['1'] && 
            (i == 0 || j == 0 || i == get_n(input@) - 1 || j == get_m(input@) - 1))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""2\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['d', 'u', 'm', 'm', 'y']]
}

spec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['d', 'u', 'm', 'm', 'y']]
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {
    seq!['0']
}

spec fn get_n(input: Seq<char>) -> int {
    3
}

spec fn get_m(input: Seq<char>) -> int {
    3
}

spec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {
    seq!['0']
}

spec fn result_two_newline() -> Seq<char> {
    seq!['2', '\n']
}

spec fn result_four_newline() -> Seq<char> {
    seq!['4', '\n']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        input@.len() > 0,
        valid_input(input@)
    ensures
        result@ =~= result_two_newline() || result@ =~= result_four_newline(),
        result@ =~= result_two_newline() <==> (exists|i: int, j: int| 
            0 <= i < get_n(input@) && 0 <= j < get_m(input@) && 
            get_grid_cell(input@, i, j) =~= seq!['1'] && 
            (i == 0 || j == 0 || i == get_n(input@) - 1 || j == get_m(input@) - 1))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""2\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![\'d\', \'u\', \'m\', \'m\', \'y\']]\n}\n\nspec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![\'d\', \'u\', \'m\', \'m\', \'y\']]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {\n    seq![\'0\']\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_m(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {\n    seq![\'0\']\n}\n\nspec fn result_two_newline() -> Seq<char> {\n    seq![\'2\', \'\\n\']\n}\n\nspec fn result_four_newline() -> Seq<char> {\n    seq![\'4\', \'\\n\']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@)\n    ensures\n        result@ =~= result_two_newline() || result@ =~= result_four_newline(),\n        result@ =~= result_two_newline() <==> (exists|i: int, j: int| \n            0 <= i < get_n(input@) && 0 <= j < get_m(input@) && \n            get_grid_cell(input@, i, j) =~= seq![\'1\'] && \n            (i == 0 || j == 0 || i == get_n(input@) - 1 || j == get_m(input@) - 1))\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    ""2\\n"".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1027.rs,57,57,1.0,92.333,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn can_parse_to_board(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {
    board.len() == 14
}

spec fn string_represents_int(s: Seq<char>, n: int) -> bool {
    s.len() > 0 && n >= 0
}

spec fn max_achievable_score_from_input(input: Seq<char>) -> int {
    0
}

spec fn max_score_from_range(board: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if up_to == 0 { 
        0 
    } else if board.len() == 14 && 0 <= up_to <= 14 && (forall|i: int| 0 <= i < 14 ==> board[i] >= 0) { 
        let prev_max = max_score_from_range(board, up_to - 1);
        let current_score = if board[up_to - 1] == 0 { -1 } else { 0 };
        if current_score > prev_max { current_score } else { prev_max }
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: String) -> (result: String)
    requires
        stdin_input@.len() > 0,
        can_parse_to_board(stdin_input@),
    ensures result@.len() > 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn can_parse_to_board(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {
    board.len() == 14
}

spec fn string_represents_int(s: Seq<char>, n: int) -> bool {
    s.len() > 0 && n >= 0
}

spec fn max_achievable_score_from_input(input: Seq<char>) -> int {
    0
}

spec fn max_score_from_range(board: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if up_to == 0 { 
        0 
    } else if board.len() == 14 && 0 <= up_to <= 14 && (forall|i: int| 0 <= i < 14 ==> board[i] >= 0) { 
        let prev_max = max_score_from_range(board, up_to - 1);
        let current_score = if board[up_to - 1] == 0 { -1 } else { 0 };
        if current_score > prev_max { current_score } else { prev_max }
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: String) -> (result: String)
    requires
        stdin_input@.len() > 0,
        can_parse_to_board(stdin_input@),
    ensures result@.len() > 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn can_parse_to_board(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {\n    board.len() == 14\n}\n\nspec fn string_represents_int(s: Seq<char>, n: int) -> bool {\n    s.len() > 0 && n >= 0\n}\n\nspec fn max_achievable_score_from_input(input: Seq<char>) -> int {\n    0\n}\n\nspec fn max_score_from_range(board: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if up_to == 0 { \n        0 \n    } else if board.len() == 14 && 0 <= up_to <= 14 && (forall|i: int| 0 <= i < 14 ==> board[i] >= 0) { \n        let prev_max = max_score_from_range(board, up_to - 1);\n        let current_score = if board[up_to - 1] == 0 { -1 } else { 0 };\n        if current_score > prev_max { current_score } else { prev_max }\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        can_parse_to_board(stdin_input@),\n    ensures result@.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1035.rs,62,62,1.0,92.316,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
  a > 0 && b > 0
}

spec fn gcd(a: int, b: int) -> int
  recommends a > 0 && b >= 0
  decreases b when b >= 0
{
  if b == 0 { a } else { gcd(b, a % b) }
}

spec fn count_distinct_prime_factors(n: int) -> int
  recommends n > 0
{
  if n == 1 { 0 } else { 0 }
}

spec fn count_distinct_prime_factors_helper(n: int, i: int) -> int
  recommends n > 0 && i >= 2
{
  0
}

spec fn divide_out_factor(n: int, factor: int) -> int
  recommends n > 0 && factor > 1 && n % factor == 0
{
  n / factor
}

spec fn correct_result(a: int, b: int, result: int) -> bool
  recommends a > 0 && b > 0
{
  result == count_distinct_prime_factors(gcd(a, b)) + 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: int, b: int) -> (result: int)
    requires 
        valid_input(a, b),
    ensures
        result > 0,
        correct_result(a, b, result),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
  a > 0 && b > 0
}

spec fn gcd(a: int, b: int) -> int
  recommends a > 0 && b >= 0
  decreases b when b >= 0
{
  if b == 0 { a } else { gcd(b, a % b) }
}

spec fn count_distinct_prime_factors(n: int) -> int
  recommends n > 0
{
  if n == 1 { 0 } else { 0 }
}

spec fn count_distinct_prime_factors_helper(n: int, i: int) -> int
  recommends n > 0 && i >= 2
{
  0
}

spec fn divide_out_factor(n: int, factor: int) -> int
  recommends n > 0 && factor > 1 && n % factor == 0
{
  n / factor
}

spec fn correct_result(a: int, b: int, result: int) -> bool
  recommends a > 0 && b > 0
{
  result == count_distinct_prime_factors(gcd(a, b)) + 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: int, b: int) -> (result: int)
    requires 
        valid_input(a, b),
    ensures
        result > 0,
        correct_result(a, b, result),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n  a > 0 && b > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a > 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn count_distinct_prime_factors(n: int) -> int\n  recommends n > 0\n{\n  if n == 1 { 0 } else { 0 }\n}\n\nspec fn count_distinct_prime_factors_helper(n: int, i: int) -> int\n  recommends n > 0 && i >= 2\n{\n  0\n}\n\nspec fn divide_out_factor(n: int, factor: int) -> int\n  recommends n > 0 && factor > 1 && n % factor == 0\n{\n  n / factor\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n  recommends a > 0 && b > 0\n{\n  result == count_distinct_prime_factors(gcd(a, b)) + 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int) -> (result: int)\n    requires \n        valid_input(a, b),\n    ensures\n        result > 0,\n        correct_result(a, b, result),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1044.rs,137,137,1.0,92.196,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    let lines = split_by_newline_spec(s);
    lines.len() >= 2 &&
    is_valid_integer(lines[0]) &&
    {
        let n = parse_int_spec(lines[0]);
        let numbers = split_by_space_spec(lines[1]);
        numbers.len() == n &&
        forall|i: int| 0 <= i < numbers.len() ==> is_valid_integer(numbers[i])
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'
}

spec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![], seq![]]
}

spec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    0
}

spec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {
    let output_lines = split_by_newline_spec(result);
    computes_correct_players(numbers, output_lines)
}

spec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {
    numbers.len() == outputs.len() &&
    {
        let players = compute_players_sequence(numbers);
        players.len() == outputs.len() &&
        forall|i: int| 0 <= i < outputs.len() ==> 
            (players[i] == 1 ==> outputs[i] == seq!['1']) &&
            (players[i] == 2 ==> outputs[i] == seq!['2'])
    }
}

spec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>
    decreases numbers.len()
{
    if numbers.len() == 0 {
        seq![]
    } else {
        compute_players_helper(numbers, 0, 2)
    }
}

spec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>
    decreases numbers.len() - index
{
    if index >= numbers.len() {
        seq![]
    } else {
        let num = parse_int_spec(numbers[index]);
        let next_player = if num % 2 == 0 { 3 - current_player } else { current_player };
        seq![next_player].add(compute_players_helper(numbers, index + 1, next_player))
    }
}

spec fn count_lines(s: Seq<char>) -> int {
    count_newlines(s, 0, 0)
}

spec fn count_newlines(s: Seq<char>, index: int, count: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        count
    } else if s[index] == '\n' {
        count_newlines(s, index + 1, count + 1)
    } else {
        count_newlines(s, index + 1, count)
    }
}

spec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {
    let output_lines = split_by_newline_spec(result);
    let computed_players = compute_players_sequence(numbers);
    output_lines.len() == computed_players.len() &&
    forall|i: int| 0 <= i < output_lines.len() ==>
        (computed_players[i] == 1 ==> output_lines[i] == seq!['1']) &&
        (computed_players[i] == 2 ==> output_lines[i] == seq!['2'])
}

spec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_by_newline_spec(input);
    lines.len() >= 2 ==> {
        let numbers = split_by_space_spec(lines[1]);
        let output_lines = split_by_newline_spec(output);
        output_lines.len() == numbers.len() &&
        computes_correct_players(numbers, output_lines)
    }
}

spec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {
    let output_lines = split_by_newline_spec(output);
    output_lines.len() == processed &&
    {
        let partial_computed = compute_players_sequence(numbers.subrange(0, processed));
        output_lines.len() == partial_computed.len() &&
        forall|i: int| 0 <= i < output_lines.len() ==>
            (partial_computed[i] == 1 ==> output_lines[i] == seq!['1']) &&
            (partial_computed[i] == 2 ==> output_lines[i] == seq!['2'])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: &str) -> (result: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    let lines = split_by_newline_spec(s);
    lines.len() >= 2 &&
    is_valid_integer(lines[0]) &&
    {
        let n = parse_int_spec(lines[0]);
        let numbers = split_by_space_spec(lines[1]);
        numbers.len() == n &&
        forall|i: int| 0 <= i < numbers.len() ==> is_valid_integer(numbers[i])
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'
}

spec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![], seq![]]
}

spec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    0
}

spec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {
    let output_lines = split_by_newline_spec(result);
    computes_correct_players(numbers, output_lines)
}

spec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {
    numbers.len() == outputs.len() &&
    {
        let players = compute_players_sequence(numbers);
        players.len() == outputs.len() &&
        forall|i: int| 0 <= i < outputs.len() ==> 
            (players[i] == 1 ==> outputs[i] == seq!['1']) &&
            (players[i] == 2 ==> outputs[i] == seq!['2'])
    }
}

spec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>
    decreases numbers.len()
{
    if numbers.len() == 0 {
        seq![]
    } else {
        compute_players_helper(numbers, 0, 2)
    }
}

spec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>
    decreases numbers.len() - index
{
    if index >= numbers.len() {
        seq![]
    } else {
        let num = parse_int_spec(numbers[index]);
        let next_player = if num % 2 == 0 { 3 - current_player } else { current_player };
        seq![next_player].add(compute_players_helper(numbers, index + 1, next_player))
    }
}

spec fn count_lines(s: Seq<char>) -> int {
    count_newlines(s, 0, 0)
}

spec fn count_newlines(s: Seq<char>, index: int, count: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        count
    } else if s[index] == '\n' {
        count_newlines(s, index + 1, count + 1)
    } else {
        count_newlines(s, index + 1, count)
    }
}

spec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {
    let output_lines = split_by_newline_spec(result);
    let computed_players = compute_players_sequence(numbers);
    output_lines.len() == computed_players.len() &&
    forall|i: int| 0 <= i < output_lines.len() ==>
        (computed_players[i] == 1 ==> output_lines[i] == seq!['1']) &&
        (computed_players[i] == 2 ==> output_lines[i] == seq!['2'])
}

spec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_by_newline_spec(input);
    lines.len() >= 2 ==> {
        let numbers = split_by_space_spec(lines[1]);
        let output_lines = split_by_newline_spec(output);
        output_lines.len() == numbers.len() &&
        computes_correct_players(numbers, output_lines)
    }
}

spec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {
    let output_lines = split_by_newline_spec(output);
    output_lines.len() == processed &&
    {
        let partial_computed = compute_players_sequence(numbers.subrange(0, processed));
        output_lines.len() == partial_computed.len() &&
        forall|i: int| 0 <= i < output_lines.len() ==>
            (partial_computed[i] == 1 ==> output_lines[i] == seq!['1']) &&
            (partial_computed[i] == 2 ==> output_lines[i] == seq!['2'])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: &str) -> (result: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(s);\n    lines.len() >= 2 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let n = parse_int_spec(lines[0]);\n        let numbers = split_by_space_spec(lines[1]);\n        numbers.len() == n &&\n        forall|i: int| 0 <= i < numbers.len() ==> is_valid_integer(numbers[i])\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![], seq![]]\n}\n\nspec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    computes_correct_players(numbers, output_lines)\n}\n\nspec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {\n    numbers.len() == outputs.len() &&\n    {\n        let players = compute_players_sequence(numbers);\n        players.len() == outputs.len() &&\n        forall|i: int| 0 <= i < outputs.len() ==> \n            (players[i] == 1 ==> outputs[i] == seq!['1']) &&\n            (players[i] == 2 ==> outputs[i] == seq!['2'])\n    }\n}\n\nspec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        seq![]\n    } else {\n        compute_players_helper(numbers, 0, 2)\n    }\n}\n\nspec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>\n    decreases numbers.len() - index\n{\n    if index >= numbers.len() {\n        seq![]\n    } else {\n        let num = parse_int_spec(numbers[index]);\n        let next_player = if num % 2 == 0 { 3 - current_player } else { current_player };\n        seq![next_player].add(compute_players_helper(numbers, index + 1, next_player))\n    }\n}\n\nspec fn count_lines(s: Seq<char>) -> int {\n    count_newlines(s, 0, 0)\n}\n\nspec fn count_newlines(s: Seq<char>, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s[index] == '\\n' {\n        count_newlines(s, index + 1, count + 1)\n    } else {\n        count_newlines(s, index + 1, count)\n    }\n}\n\nspec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    let computed_players = compute_players_sequence(numbers);\n    output_lines.len() == computed_players.len() &&\n    forall|i: int| 0 <= i < output_lines.len() ==>\n        (computed_players[i] == 1 ==> output_lines[i] == seq!['1']) &&\n        (computed_players[i] == 2 ==> output_lines[i] == seq!['2'])\n}\n\nspec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 ==> {\n        let numbers = split_by_space_spec(lines[1]);\n        let output_lines = split_by_newline_spec(output);\n        output_lines.len() == numbers.len() &&\n        computes_correct_players(numbers, output_lines)\n    }\n}\n\nspec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {\n    let output_lines = split_by_newline_spec(output);\n    output_lines.len() == processed &&\n    {\n        let partial_computed = compute_players_sequence(numbers.subrange(0, processed));\n        output_lines.len() == partial_computed.len() &&\n        forall|i: int| 0 <= i < output_lines.len() ==>\n            (partial_computed[i] == 1 ==> output_lines[i] == seq!['1']) &&\n            (partial_computed[i] == 2 ==> output_lines[i] == seq!['2'])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1046.rs,92,92,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_occurrences(s: Seq<int>, x: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        (if s[0] == x { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), x)
    }
}

spec fn count_pairs(s: Seq<int>) -> int
{
    let positive_sessions = filter_positive(s);
    count_pairs_helper(positive_sessions)
}

spec fn filter_positive(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::empty()
    } else if s[0] > 0 {
        seq![s[0]].add(filter_positive(s.subrange(1, s.len() as int)))
    } else {
        filter_positive(s.subrange(1, s.len() as int))
    }
}

spec fn remove_all_occurrences(s: Seq<int>, x: int) -> Seq<int>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::empty()
    } else if s[0] == x {
        remove_all_occurrences(s.subrange(1, s.len() as int), x)
    } else {
        seq![s[0]].add(remove_all_occurrences(s.subrange(1, s.len() as int), x))
    }
}

spec fn count_pairs_helper(s: Seq<int>) -> int
    decreases s.len()
    when s.len() > 1 ==> remove_all_occurrences(s, s[0]).len() < s.len()
{
    if s.len() <= 1 {
        0
    } else {
        let count = count_occurrences(s, s[0]);
        let remaining = remove_all_occurrences(s, s[0]);
        (if count == 2 { 1int } else { 0int }) + count_pairs_helper(remaining)
    }
}

spec fn exists_index(s: Seq<int>, x: int) -> bool
{
    exists|i: int| 0 <= i < s.len() && s[i] == x
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, sessions: Vec<i8>) -> (result: i8)
    requires 
        n >= 1,
        sessions.len() == n as nat,
        forall|i: int| 0 <= i < sessions.len() ==> sessions[i] as int >= 0,
    ensures 
        result == -1 || result >= 0,
        result == -1 ==> (exists|id: int| id > 0 && #[trigger] count_occurrences(sessions@.map_values(|x: i8| x as int), id) > 2),
        result >= 0 ==> forall|id: int| id > 0 ==> count_occurrences(sessions@.map_values(|x: i8| x as int), id) <= 2,
        result >= 0 ==> result as int == count_pairs(sessions@.map_values(|x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_occurrences(s: Seq<int>, x: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        (if s[0] == x { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), x)
    }
}

spec fn count_pairs(s: Seq<int>) -> int
{
    let positive_sessions = filter_positive(s);
    count_pairs_helper(positive_sessions)
}

spec fn filter_positive(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::empty()
    } else if s[0] > 0 {
        seq![s[0]].add(filter_positive(s.subrange(1, s.len() as int)))
    } else {
        filter_positive(s.subrange(1, s.len() as int))
    }
}

spec fn remove_all_occurrences(s: Seq<int>, x: int) -> Seq<int>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::empty()
    } else if s[0] == x {
        remove_all_occurrences(s.subrange(1, s.len() as int), x)
    } else {
        seq![s[0]].add(remove_all_occurrences(s.subrange(1, s.len() as int), x))
    }
}

spec fn count_pairs_helper(s: Seq<int>) -> int
    decreases s.len()
    when s.len() > 1 ==> remove_all_occurrences(s, s[0]).len() < s.len()
{
    if s.len() <= 1 {
        0
    } else {
        let count = count_occurrences(s, s[0]);
        let remaining = remove_all_occurrences(s, s[0]);
        (if count == 2 { 1int } else { 0int }) + count_pairs_helper(remaining)
    }
}

spec fn exists_index(s: Seq<int>, x: int) -> bool
{
    exists|i: int| 0 <= i < s.len() && s[i] == x
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, sessions: Vec<i8>) -> (result: i8)
    requires 
        n >= 1,
        sessions.len() == n as nat,
        forall|i: int| 0 <= i < sessions.len() ==> sessions[i] as int >= 0,
    ensures 
        result == -1 || result >= 0,
        result == -1 ==> (exists|id: int| id > 0 && #[trigger] count_occurrences(sessions@.map_values(|x: i8| x as int), id) > 2),
        result >= 0 ==> forall|id: int| id > 0 ==> count_occurrences(sessions@.map_values(|x: i8| x as int), id) <= 2,
        result >= 0 ==> result as int == count_pairs(sessions@.map_values(|x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1049.rs,69,69,1.0,122.619,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn input_well_formed(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    {
        let first_line_parts = split_string(lines[0], ' ');
        first_line_parts.len() == 2 &&
        is_valid_int(first_line_parts[0]) &&
        is_valid_int(first_line_parts[1]) &&
        {
            let n = string_to_int(first_line_parts[0]);
            let d = string_to_int(first_line_parts[1]);
            n >= 0 && d >= 0 &&
            lines.len() >= d + 1 &&
            forall|i: int| 1 <= i <= d ==> i < lines.len() && is_valid_binary_string(lines[i], n)
        }
    }
}

spec fn compute_max_consecutive_wins(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line_parts = split_string(lines[0], ' ');
    let n = string_to_int(first_line_parts[0]);
    let d = string_to_int(first_line_parts[1]);
    max_consecutive_wins_up_to(lines, n, d)
}

spec fn is_valid_int(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'
}

spec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {
    s.len() == expected_length && forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

/* Helper function stubs - these would need proper implementations */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }
spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { Seq::empty() }
spec fn string_to_int(s: Seq<char>) -> int { 0 }
spec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int { 0 }
spec fn int_to_string(n: int) -> Seq<char> { Seq::empty() }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires 
        input.len() > 0,
        input_well_formed(input),
    ensures 
        result == int_to_string(compute_max_consecutive_wins(input)).add(seq!['\n']),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn input_well_formed(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    {
        let first_line_parts = split_string(lines[0], ' ');
        first_line_parts.len() == 2 &&
        is_valid_int(first_line_parts[0]) &&
        is_valid_int(first_line_parts[1]) &&
        {
            let n = string_to_int(first_line_parts[0]);
            let d = string_to_int(first_line_parts[1]);
            n >= 0 && d >= 0 &&
            lines.len() >= d + 1 &&
            forall|i: int| 1 <= i <= d ==> i < lines.len() && is_valid_binary_string(lines[i], n)
        }
    }
}

spec fn compute_max_consecutive_wins(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line_parts = split_string(lines[0], ' ');
    let n = string_to_int(first_line_parts[0]);
    let d = string_to_int(first_line_parts[1]);
    max_consecutive_wins_up_to(lines, n, d)
}

spec fn is_valid_int(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'
}

spec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {
    s.len() == expected_length && forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

/* Helper function stubs - these would need proper implementations */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }
spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { Seq::empty() }
spec fn string_to_int(s: Seq<char>) -> int { 0 }
spec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int { 0 }
spec fn int_to_string(n: int) -> Seq<char> { Seq::empty() }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires 
        input.len() > 0,
        input_well_formed(input),
    ensures 
        result == int_to_string(compute_max_consecutive_wins(input)).add(seq!['\n']),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn input_well_formed(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    {\n        let first_line_parts = split_string(lines[0], ' ');\n        first_line_parts.len() == 2 &&\n        is_valid_int(first_line_parts[0]) &&\n        is_valid_int(first_line_parts[1]) &&\n        {\n            let n = string_to_int(first_line_parts[0]);\n            let d = string_to_int(first_line_parts[1]);\n            n >= 0 && d >= 0 &&\n            lines.len() >= d + 1 &&\n            forall|i: int| 1 <= i <= d ==> i < lines.len() && is_valid_binary_string(lines[i], n)\n        }\n    }\n}\n\nspec fn compute_max_consecutive_wins(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line_parts = split_string(lines[0], ' ');\n    let n = string_to_int(first_line_parts[0]);\n    let d = string_to_int(first_line_parts[1]);\n    max_consecutive_wins_up_to(lines, n, d)\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {\n    s.len() == expected_length && forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\n/* Helper function stubs - these would need proper implementations */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { Seq::empty() }\nspec fn string_to_int(s: Seq<char>) -> int { 0 }\nspec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int { 0 }\nspec fn int_to_string(n: int) -> Seq<char> { Seq::empty() }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        input_well_formed(input),\n    ensures \n        result == int_to_string(compute_max_consecutive_wins(input)).add(seq!['\\n']),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1063.rs,106,106,1.0,183.664,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    if lines.len() < 1 { 
        false 
    } else {
        let n = parse_int(lines[0]);
        n >= 0 && lines.len() >= n + 1 &&
        forall|i: int| #![trigger lines[i]] 1 <= i <= n && i < lines.len() ==> {
            let line = lines[i];
            line.len() >= 1 && line.len() <= 8 &&
            forall|j: int| 0 <= j < line.len() ==> 
                ((#[trigger] line[j]) >= '0' && line[j] <= '9') || line[j] == '?'
        }
    }
}

spec fn has_valid_solution(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    let n = parse_int(lines[0]);
    if n <= 0 { 
        true 
    } else {
        let input_strings = lines.subrange(1, n + 1);
        exists|solution: Seq<Seq<char>>| is_valid_sequence_solution(input_strings, solution)
    }
}

spec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {
    input.len() == solution.len() &&
    forall|i: int| #![trigger input[i], solution[i]] 0 <= i < input.len() ==> {
        input[i].len() == solution[i].len() &&
        forall|j: int| 0 <= j < input[i].len() ==> {
            ((#[trigger] input[i][j]) != '?' ==> input[i][j] == solution[i][j]) &&
            (input[i][j] == '?' ==> solution[i][j] >= '0' && solution[i][j] <= '9')
        }
    } &&
    forall|i: int| #![trigger solution[i]] 0 <= i < solution.len() ==> is_valid_positive_integer(solution[i]) &&
    is_strictly_increasing_sequence(solution)
}

spec fn is_valid_positive_integer(s: Seq<char>) -> bool {
    s.len() >= 1 && 
    forall|i: int| 0 <= i < s.len() ==> ((#[trigger] s[i]) >= '0' && s[i] <= '9') &&
    (s.len() == 1 || s[0] != '0')
}

spec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {
    forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() - 1 ==> 
        is_lexicographically_smaller(nums[i], nums[(i + 1) as int])
}

spec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {
    a.len() < b.len() || (a.len() == b.len() && lexicographic_compare(a, b))
}

spec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool 
    decreases a.len()
{
    if a.len() == 0 || b.len() == 0 {
        a.len() < b.len()
    } else if a[0] != b[0] {
        a[0] < b[0]
    } else {
        lexicographic_compare(a.drop_first(), b.drop_first())
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        is_well_formed_input(stdin_input),
    ensures 
        result.len() > 0,
        result == ""NO\n""@ || (result.len() > 4 && result.subrange(0, 4) == ""YES\n""@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    if lines.len() < 1 { 
        false 
    } else {
        let n = parse_int(lines[0]);
        n >= 0 && lines.len() >= n + 1 &&
        forall|i: int| #![trigger lines[i]] 1 <= i <= n && i < lines.len() ==> {
            let line = lines[i];
            line.len() >= 1 && line.len() <= 8 &&
            forall|j: int| 0 <= j < line.len() ==> 
                ((#[trigger] line[j]) >= '0' && line[j] <= '9') || line[j] == '?'
        }
    }
}

spec fn has_valid_solution(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    let n = parse_int(lines[0]);
    if n <= 0 { 
        true 
    } else {
        let input_strings = lines.subrange(1, n + 1);
        exists|solution: Seq<Seq<char>>| is_valid_sequence_solution(input_strings, solution)
    }
}

spec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {
    input.len() == solution.len() &&
    forall|i: int| #![trigger input[i], solution[i]] 0 <= i < input.len() ==> {
        input[i].len() == solution[i].len() &&
        forall|j: int| 0 <= j < input[i].len() ==> {
            ((#[trigger] input[i][j]) != '?' ==> input[i][j] == solution[i][j]) &&
            (input[i][j] == '?' ==> solution[i][j] >= '0' && solution[i][j] <= '9')
        }
    } &&
    forall|i: int| #![trigger solution[i]] 0 <= i < solution.len() ==> is_valid_positive_integer(solution[i]) &&
    is_strictly_increasing_sequence(solution)
}

spec fn is_valid_positive_integer(s: Seq<char>) -> bool {
    s.len() >= 1 && 
    forall|i: int| 0 <= i < s.len() ==> ((#[trigger] s[i]) >= '0' && s[i] <= '9') &&
    (s.len() == 1 || s[0] != '0')
}

spec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {
    forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() - 1 ==> 
        is_lexicographically_smaller(nums[i], nums[(i + 1) as int])
}

spec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {
    a.len() < b.len() || (a.len() == b.len() && lexicographic_compare(a, b))
}

spec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool 
    decreases a.len()
{
    if a.len() == 0 || b.len() == 0 {
        a.len() < b.len()
    } else if a[0] != b[0] {
        a[0] < b[0]
    } else {
        lexicographic_compare(a.drop_first(), b.drop_first())
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        is_well_formed_input(stdin_input),
    ensures 
        result.len() > 0,
        result == ""NO\n""@ || (result.len() > 4 && result.subrange(0, 4) == ""YES\n""@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    if lines.len() < 1 { \n        false \n    } else {\n        let n = parse_int(lines[0]);\n        n >= 0 && lines.len() >= n + 1 &&\n        forall|i: int| #![trigger lines[i]] 1 <= i <= n && i < lines.len() ==> {\n            let line = lines[i];\n            line.len() >= 1 && line.len() <= 8 &&\n            forall|j: int| 0 <= j < line.len() ==> \n                ((#[trigger] line[j]) >= \'0\' && line[j] <= \'9\') || line[j] == \'?\'\n        }\n    }\n}\n\nspec fn has_valid_solution(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    if n <= 0 { \n        true \n    } else {\n        let input_strings = lines.subrange(1, n + 1);\n        exists|solution: Seq<Seq<char>>| is_valid_sequence_solution(input_strings, solution)\n    }\n}\n\nspec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {\n    input.len() == solution.len() &&\n    forall|i: int| #![trigger input[i], solution[i]] 0 <= i < input.len() ==> {\n        input[i].len() == solution[i].len() &&\n        forall|j: int| 0 <= j < input[i].len() ==> {\n            ((#[trigger] input[i][j]) != \'?\' ==> input[i][j] == solution[i][j]) &&\n            (input[i][j] == \'?\' ==> solution[i][j] >= \'0\' && solution[i][j] <= \'9\')\n        }\n    } &&\n    forall|i: int| #![trigger solution[i]] 0 <= i < solution.len() ==> is_valid_positive_integer(solution[i]) &&\n    is_strictly_increasing_sequence(solution)\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() >= 1 && \n    forall|i: int| 0 <= i < s.len() ==> ((#[trigger] s[i]) >= \'0\' && s[i] <= \'9\') &&\n    (s.len() == 1 || s[0] != \'0\')\n}\n\nspec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {\n    forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() - 1 ==> \n        is_lexicographically_smaller(nums[i], nums[(i + 1) as int])\n}\n\nspec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {\n    a.len() < b.len() || (a.len() == b.len() && lexicographic_compare(a, b))\n}\n\nspec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool \n    decreases a.len()\n{\n    if a.len() == 0 || b.len() == 0 {\n        a.len() < b.len()\n    } else if a[0] != b[0] {\n        a[0] < b[0]\n    } else {\n        lexicographic_compare(a.drop_first(), b.drop_first())\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        is_well_formed_input(stdin_input),\n    ensures \n        result.len() > 0,\n        result == ""NO\\n""@ || (result.len() > 4 && result.subrange(0, 4) == ""YES\\n""@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1084.rs,94,94,1.0,123.893,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() < 2 {
        false
    } else {
        let first_line = lines[0];
        let grid_lines = lines.subrange(1, lines.len() as int);
        let dimensions = parse_dimensions(first_line);
        let n = dimensions.0;
        let m = dimensions.1;
        if n <= 0 || m <= 0 || grid_lines.len() != n {
            false
        } else if !valid_grid(grid_lines, m) {
            false
        } else {
            true /* simplified - column pattern constraint implementation omitted for spec purposes */
        }
    }
}

spec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {
    (forall|i: int| 0 <= i < grid_lines.len() ==> #[trigger] grid_lines[i].len() == m) &&
    (forall|i: int, j: int| 0 <= i < grid_lines.len() && 0 <= j < grid_lines[i].len() ==> 
            #[trigger] grid_lines[i][j] == '.' || grid_lines[i][j] == '#')
}

spec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {
    Set::new(|j: int| 0 <= j < m && row[j] == '#')
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(input, 0, Seq::empty())
}

spec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {
    if start >= input.len() {
        acc
    } else {
        acc.push(Seq::empty())
    }
}

spec fn parse_dimensions(line: Seq<char>) -> (int, int) {
    let parts = split_on_space(line);
    if parts.len() >= 2 {
        (string_to_int(parts[0]), string_to_int(parts[1]))
    } else {
        (0, 0)
    }
}

spec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        result@ == ""Yes\n""@ || result@ == ""No\n""@,
        result@.len() > 0,
        (result@ == ""Yes\n""@) <==> can_be_constructed_by_operations(stdin_input@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""No\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() < 2 {
        false
    } else {
        let first_line = lines[0];
        let grid_lines = lines.subrange(1, lines.len() as int);
        let dimensions = parse_dimensions(first_line);
        let n = dimensions.0;
        let m = dimensions.1;
        if n <= 0 || m <= 0 || grid_lines.len() != n {
            false
        } else if !valid_grid(grid_lines, m) {
            false
        } else {
            true /* simplified - column pattern constraint implementation omitted for spec purposes */
        }
    }
}

spec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {
    (forall|i: int| 0 <= i < grid_lines.len() ==> #[trigger] grid_lines[i].len() == m) &&
    (forall|i: int, j: int| 0 <= i < grid_lines.len() && 0 <= j < grid_lines[i].len() ==> 
            #[trigger] grid_lines[i][j] == '.' || grid_lines[i][j] == '#')
}

spec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {
    Set::new(|j: int| 0 <= j < m && row[j] == '#')
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(input, 0, Seq::empty())
}

spec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {
    if start >= input.len() {
        acc
    } else {
        acc.push(Seq::empty())
    }
}

spec fn parse_dimensions(line: Seq<char>) -> (int, int) {
    let parts = split_on_space(line);
    if parts.len() >= 2 {
        (string_to_int(parts[0]), string_to_int(parts[1]))
    } else {
        (0, 0)
    }
}

spec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        result@ == ""Yes\n""@ || result@ == ""No\n""@,
        result@.len() > 0,
        (result@ == ""Yes\n""@) <==> can_be_constructed_by_operations(stdin_input@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""No\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() < 2 {\n        false\n    } else {\n        let first_line = lines[0];\n        let grid_lines = lines.subrange(1, lines.len() as int);\n        let dimensions = parse_dimensions(first_line);\n        let n = dimensions.0;\n        let m = dimensions.1;\n        if n <= 0 || m <= 0 || grid_lines.len() != n {\n            false\n        } else if !valid_grid(grid_lines, m) {\n            false\n        } else {\n            true /* simplified - column pattern constraint implementation omitted for spec purposes */\n        }\n    }\n}\n\nspec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {\n    (forall|i: int| 0 <= i < grid_lines.len() ==> #[trigger] grid_lines[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < grid_lines.len() && 0 <= j < grid_lines[i].len() ==> \n            #[trigger] grid_lines[i][j] == \'.\' || grid_lines[i][j] == \'#\')\n}\n\nspec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {\n    Set::new(|j: int| 0 <= j < m && row[j] == \'#\')\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(input, 0, Seq::empty())\n}\n\nspec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n    if start >= input.len() {\n        acc\n    } else {\n        acc.push(Seq::empty())\n    }\n}\n\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) {\n    let parts = split_on_space(line);\n    if parts.len() >= 2 {\n        (string_to_int(parts[0]), string_to_int(parts[1]))\n    } else {\n        (0, 0)\n    }\n}\n\nspec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        result@ == ""Yes\\n""@ || result@ == ""No\\n""@,\n        result@.len() > 0,\n        (result@ == ""Yes\\n""@) <==> can_be_constructed_by_operations(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    ""No\\n"".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n              fn main() {\n    }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1125.rs,181,181,1.0,92.094,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    let lines = split_lines_func(s);
    lines.len() >= 2 && 
    parse_int_func(lines[0]) >= 2 &&
    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&
    forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] >= 1
}

spec fn is_valid_output(s: Seq<char>) -> bool {
    s == seq!['-', '1'] || (parse_int_func(s) >= 0)
}

spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 2 ==>
    {
        let n = parse_int_func(lines[0]);
        let a = parse_int_array_func(lines[1]);
    
        if n == 2 {
            (output == seq!['-', '1'] <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&
            (output != seq!['-', '1'] ==> parse_int_func(output) == (a[0] - a[1]) / 2)
        } else {
            let xor_rest = xor_range(a, 2, n);
            let and_val = a[0] + a[1] - xor_rest;
            let target_and = and_val / 2;
    
            if and_val % 2 != 0 || a[0] < target_and || and_op(target_and, xor_rest) != 0 {
                output == seq!['-', '1']
            } else {
                let a0 = construct_a0(target_and, xor_rest, a[0]);
                if a0 == 0 {
                    output == seq!['-', '1']
                } else {
                    output != seq!['-', '1'] && parse_int_func(output) == a[0] - a0
                }
            }
        }
    }
}

spec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool
    recommends
        original_piles.len() >= 2,
        0 <= stones_moved < original_piles[0],
        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0
{
    let new_piles = original_piles.update(0, original_piles[0] - stones_moved).update(1, original_piles[1] + stones_moved);
    nim_sum(new_piles) == 0
}

spec fn nim_sum(piles: Seq<int>) -> int
    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0
    decreases piles.len()
{
    if piles.len() == 0 {
        0
    } else {
        xor_op(piles[0], nim_sum(piles.subrange(1, piles.len() as int)))
    }
}

spec fn xor_op(x: int, y: int) -> int
    recommends x >= 0 && y >= 0
{
    if x >= 0 && y >= 0 {
        0  /* placeholder for bitwise XOR operation */
    } else {
        0
    }
}

spec fn and_op(x: int, y: int) -> int
    recommends x >= 0 && y >= 0
{
    if x >= 0 && y >= 0 {
        0  /* placeholder for bitwise AND operation */
    } else {
        0
    }
}

spec fn xor_range(a: Seq<int>, start: int, end: int) -> int
    recommends
        0 <= start <= end <= a.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0
    decreases end - start
{
    if start >= end {
        0
    } else {
        xor_op(a[start], xor_range(a, start + 1, end))
    }
}

spec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int
    recommends initial_and >= 0 && num >= 0
{
    let max_power = find_max_power(num);
    construct_a0_helper(initial_and, num, max_pile, max_power)
}

spec fn find_max_power(num: int) -> int
    recommends num >= 0
{
    if num == 0 {
        1
    } else {
        find_max_power_helper(1, num)
    }
}

spec fn find_max_power_helper(current_power: int, num: int) -> int
    recommends current_power >= 1 && num >= 0
{
    if current_power > num {
        if current_power / 2 >= 1 { current_power / 2 } else { 1 }
    } else {
        1  /* simplified to avoid recursion issues */
    }
}

spec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int
    recommends a0 >= 0 && num >= 0 && power >= 1
    decreases power
{
    if power == 1 {
        if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 }
    } else {
        let new_a0 = if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 };
        if power / 2 >= 1 { construct_a0_helper(new_a0, num, max_pile, power / 2) } else { new_a0 }
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![s]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}

spec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    seq!['0']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input@.len() > 0,
        valid_input(stdin_input@),
    ensures
        result@.len() > 0,
        is_valid_output(result@),
        result@ == seq!['-', '1'] || (parse_int_func(result@) >= 0),
        correct_solution(stdin_input@, result@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    let lines = split_lines_func(s);
    lines.len() >= 2 && 
    parse_int_func(lines[0]) >= 2 &&
    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&
    forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] >= 1
}

spec fn is_valid_output(s: Seq<char>) -> bool {
    s == seq!['-', '1'] || (parse_int_func(s) >= 0)
}

spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 2 ==>
    {
        let n = parse_int_func(lines[0]);
        let a = parse_int_array_func(lines[1]);
    
        if n == 2 {
            (output == seq!['-', '1'] <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&
            (output != seq!['-', '1'] ==> parse_int_func(output) == (a[0] - a[1]) / 2)
        } else {
            let xor_rest = xor_range(a, 2, n);
            let and_val = a[0] + a[1] - xor_rest;
            let target_and = and_val / 2;
    
            if and_val % 2 != 0 || a[0] < target_and || and_op(target_and, xor_rest) != 0 {
                output == seq!['-', '1']
            } else {
                let a0 = construct_a0(target_and, xor_rest, a[0]);
                if a0 == 0 {
                    output == seq!['-', '1']
                } else {
                    output != seq!['-', '1'] && parse_int_func(output) == a[0] - a0
                }
            }
        }
    }
}

spec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool
    recommends
        original_piles.len() >= 2,
        0 <= stones_moved < original_piles[0],
        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0
{
    let new_piles = original_piles.update(0, original_piles[0] - stones_moved).update(1, original_piles[1] + stones_moved);
    nim_sum(new_piles) == 0
}

spec fn nim_sum(piles: Seq<int>) -> int
    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0
    decreases piles.len()
{
    if piles.len() == 0 {
        0
    } else {
        xor_op(piles[0], nim_sum(piles.subrange(1, piles.len() as int)))
    }
}

spec fn xor_op(x: int, y: int) -> int
    recommends x >= 0 && y >= 0
{
    if x >= 0 && y >= 0 {
        0  /* placeholder for bitwise XOR operation */
    } else {
        0
    }
}

spec fn and_op(x: int, y: int) -> int
    recommends x >= 0 && y >= 0
{
    if x >= 0 && y >= 0 {
        0  /* placeholder for bitwise AND operation */
    } else {
        0
    }
}

spec fn xor_range(a: Seq<int>, start: int, end: int) -> int
    recommends
        0 <= start <= end <= a.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0
    decreases end - start
{
    if start >= end {
        0
    } else {
        xor_op(a[start], xor_range(a, start + 1, end))
    }
}

spec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int
    recommends initial_and >= 0 && num >= 0
{
    let max_power = find_max_power(num);
    construct_a0_helper(initial_and, num, max_pile, max_power)
}

spec fn find_max_power(num: int) -> int
    recommends num >= 0
{
    if num == 0 {
        1
    } else {
        find_max_power_helper(1, num)
    }
}

spec fn find_max_power_helper(current_power: int, num: int) -> int
    recommends current_power >= 1 && num >= 0
{
    if current_power > num {
        if current_power / 2 >= 1 { current_power / 2 } else { 1 }
    } else {
        1  /* simplified to avoid recursion issues */
    }
}

spec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int
    recommends a0 >= 0 && num >= 0 && power >= 1
    decreases power
{
    if power == 1 {
        if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 }
    } else {
        let new_a0 = if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 };
        if power / 2 >= 1 { construct_a0_helper(new_a0, num, max_pile, power / 2) } else { new_a0 }
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![s]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}

spec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    seq!['0']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input@.len() > 0,
        valid_input(stdin_input@),
    ensures
        result@.len() > 0,
        is_valid_output(result@),
        result@ == seq!['-', '1'] || (parse_int_func(result@) >= 0),
        correct_solution(stdin_input@, result@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_lines_func(s);\n    lines.len() >= 2 && \n    parse_int_func(lines[0]) >= 2 &&\n    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&\n    forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] >= 1\n}\n\nspec fn is_valid_output(s: Seq<char>) -> bool {\n    s == seq!['-', '1'] || (parse_int_func(s) >= 0)\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 2 ==>\n    {\n        let n = parse_int_func(lines[0]);\n        let a = parse_int_array_func(lines[1]);\n    \n        if n == 2 {\n            (output == seq!['-', '1'] <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&\n            (output != seq!['-', '1'] ==> parse_int_func(output) == (a[0] - a[1]) / 2)\n        } else {\n            let xor_rest = xor_range(a, 2, n);\n            let and_val = a[0] + a[1] - xor_rest;\n            let target_and = and_val / 2;\n    \n            if and_val % 2 != 0 || a[0] < target_and || and_op(target_and, xor_rest) != 0 {\n                output == seq!['-', '1']\n            } else {\n                let a0 = construct_a0(target_and, xor_rest, a[0]);\n                if a0 == 0 {\n                    output == seq!['-', '1']\n                } else {\n                    output != seq!['-', '1'] && parse_int_func(output) == a[0] - a0\n                }\n            }\n        }\n    }\n}\n\nspec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool\n    recommends\n        original_piles.len() >= 2,\n        0 <= stones_moved < original_piles[0],\n        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0\n{\n    let new_piles = original_piles.update(0, original_piles[0] - stones_moved).update(1, original_piles[1] + stones_moved);\n    nim_sum(new_piles) == 0\n}\n\nspec fn nim_sum(piles: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0\n    decreases piles.len()\n{\n    if piles.len() == 0 {\n        0\n    } else {\n        xor_op(piles[0], nim_sum(piles.subrange(1, piles.len() as int)))\n    }\n}\n\nspec fn xor_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise XOR operation */\n    } else {\n        0\n    }\n}\n\nspec fn and_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise AND operation */\n    } else {\n        0\n    }\n}\n\nspec fn xor_range(a: Seq<int>, start: int, end: int) -> int\n    recommends\n        0 <= start <= end <= a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else {\n        xor_op(a[start], xor_range(a, start + 1, end))\n    }\n}\n\nspec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int\n    recommends initial_and >= 0 && num >= 0\n{\n    let max_power = find_max_power(num);\n    construct_a0_helper(initial_and, num, max_pile, max_power)\n}\n\nspec fn find_max_power(num: int) -> int\n    recommends num >= 0\n{\n    if num == 0 {\n        1\n    } else {\n        find_max_power_helper(1, num)\n    }\n}\n\nspec fn find_max_power_helper(current_power: int, num: int) -> int\n    recommends current_power >= 1 && num >= 0\n{\n    if current_power > num {\n        if current_power / 2 >= 1 { current_power / 2 } else { 1 }\n    } else {\n        1  /* simplified to avoid recursion issues */\n    }\n}\n\nspec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int\n    recommends a0 >= 0 && num >= 0 && power >= 1\n    decreases power\n{\n    if power == 1 {\n        if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 }\n    } else {\n        let new_a0 = if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 };\n        if power / 2 >= 1 { construct_a0_helper(new_a0, num, max_pile, power / 2) } else { new_a0 }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    seq!['0']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures\n        result@.len() > 0,\n        is_valid_output(result@),\n        result@ == seq!['-', '1'] || (parse_int_func(result@) >= 0),\n        correct_solution(stdin_input@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_114.rs,124,45,0.3629032258064516,184.83,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n' &&
    exists|lines: Seq<Seq<char>>| {
        &&& lines == split_lines(input)
        &&& lines.len() >= 3
        &&& valid_dimension_line(lines[0])
        &&& {
            let parsed = parse_dimensions(lines[0]);
            let (n, m) = (parsed.0, parsed.1);
            &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50
            &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)
            &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==> 
                parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1
        }
    }
}

spec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() - 1] == '\n' &&
    exists|lines: Seq<Seq<char>>| {
        &&& lines == split_lines(output)
        &&& lines.len() >= 1
        &&& valid_number(lines[0])
        &&& {
            let k = parse_number(lines[0]);
            &&& 0 <= k <= 2500
            &&& lines.len() == k + 1
            &&& {
                let parsed = parse_input(original_input);
                let (n, m) = (parsed.0, parsed.1);
                forall|i: int| 1 <= i <= k ==> valid_coordinate_pair(lines[i], n-1, m-1)
            }
        }
    }
}

spec fn valid_dimension_line(line: Seq<char>) -> bool { line.len() > 0 }
spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool { line.len() > 0 && m > 0 }
spec fn valid_number(s: Seq<char>) -> bool { s.len() > 0 }
spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool { 
    s.len() > 0 && max_x > 0 && max_y > 0 
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> { seq![s] }
spec fn parse_dimensions(line: Seq<char>) -> (int, int) { (2, 2) }
spec fn parse_number(s: Seq<char>) -> int { 0 }
spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) { 
    (2, 2, seq![seq![0, 0], seq![0, 0]]) 
}
spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> { seq![] }
spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int { 0 }
spec fn to_string(n: int) -> Seq<char> { seq!['0'] }

spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) {
    let b = Seq::new(n as nat, |i: int| Seq::new(m as nat, |j: int| 0));
    let ops = seq![];
    greedy_step(a, b, ops, 0, 0, n, m)
}

spec fn greedy_step(a: Seq<Seq<int>>, b: Seq<Seq<int>>, ops: Seq<(int, int)>, 
                   start_i: int, start_j: int, n: int, m: int) -> (Seq<Seq<int>>, Seq<(int, int)>) {
    (b, ops)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures 
        result@.len() > 0,
        result@ == ""-1\n""@ || valid_operation_sequence(result@, stdin_input@),
        result@ != ""-1\n""@ ==> {
            let parsed = parse_input(stdin_input@);
            let (n, m, a) = (parsed.0, parsed.1, parsed.2);
            let ops = parse_operations(result@);
            let algorithm_result = apply_greedy_algorithm(n, m, a);
            let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);
            b == a && ops == expected_ops
        },
        result@ == ""-1\n""@ ==> {
            let parsed = parse_input(stdin_input@);
            let (n, m, a) = (parsed.0, parsed.1, parsed.2);
            let algorithm_result = apply_greedy_algorithm(n, m, a);
            let b = algorithm_result.0;
            b != a
        },
        result@ == ""-1\n""@ || exists|k: nat, lines: Seq<Seq<char>>| {
            &&& lines == split_lines(result@)
            &&& lines.len() == k + 1
            &&& lines[0] == to_string(k as int)
            &&& k <= 2500
            &&& {
                let parsed = parse_input(stdin_input@);
                let (n, m) = (parsed.0, parsed.1);
                forall|i: int| #[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {
                    &&& 1 <= n-1 && 1 <= m-1
                    &&& lines[i] == seq!['d', 'u', 'm', 'm', 'y']
                }
            }
        },
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""-1\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input_format(input: Seq<char>) -> bool {
          input.len() > 0 && input[input.len() - 1] == '\n' &&     exists|lines: Seq<Seq<char>>| {
             &&& lines == split_lines(input)         &&& lines.len() >= 3         &&& valid_dimension_line(lines[0])         &&& {
                let parsed = parse_dimensions(lines[0]);
                let (n, m) = (parsed.0, parsed.1);
                &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50             &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)             &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>                  parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1         }
         }
      }
       spec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool ;
       spec fn valid_dimension_line(line: Seq<char>) -> bool ;
       spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool ;
       spec fn valid_number(s: Seq<char>) -> bool ;
       spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;
       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
      seq![s] }
       spec fn parse_dimensions(line: Seq<char>) -> (int, int) ;
       spec fn parse_number(s: Seq<char>) -> int ;
       spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) ;
       spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> ;
       spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;
       spec fn to_string(n: int) -> Seq<char> ;
       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;
       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == ""-1\n""@ || valid_operation_sequence(result@, stdin_input@),         result@ != ""-1\n""@ ==> {
                  let parsed = parse_input(stdin_input@);
                  let (n, m, a) = (parsed.0, parsed.1, parsed.2);
                  let ops = parse_operations(result@);
                  let algorithm_result = apply_greedy_algorithm(n, m, a);
                  let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);
                  b == a && ops == expected_ops         }
      ,         result@ == ""-1\n""@ || exists|k: nat, lines: Seq<Seq<char>>| {
                  &&& lines == split_lines(result@)             &&& lines.len() == k + 1             &&& lines[0] == to_string(k as int)             &&& k <= 2500             &&& {
                     let parsed = parse_input(stdin_input@);
                     let (n, m) = (parsed.0, parsed.1);
                     forall|i: int|        
#[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {
                    &&& 1 <= n-1 && 1 <= m-1                     &&& lines[i] == seq!['d', 'u', 'm', 'm', 'y']                 }
                  }
               }
       , {
           ""-1\n"".to_string() }
        }
        fn main() {
       }
","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == \'\\n\' &&\n    exists|lines: Seq<Seq<char>>| {\n        &&& lines == split_lines(input)\n        &&& lines.len() >= 3\n        &&& valid_dimension_line(lines[0])\n        &&& {\n            let parsed = parse_dimensions(lines[0]);\n            let (n, m) = (parsed.0, parsed.1);\n            &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50\n            &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)\n            &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==> \n                parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1\n        }\n    }\n}\n\nspec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == \'\\n\' &&\n    exists|lines: Seq<Seq<char>>| {\n        &&& lines == split_lines(output)\n        &&& lines.len() >= 1\n        &&& valid_number(lines[0])\n        &&& {\n            let k = parse_number(lines[0]);\n            &&& 0 <= k <= 2500\n            &&& lines.len() == k + 1\n            &&& {\n                let parsed = parse_input(original_input);\n                let (n, m) = (parsed.0, parsed.1);\n                forall|i: int| 1 <= i <= k ==> valid_coordinate_pair(lines[i], n-1, m-1)\n            }\n        }\n    }\n}\n\nspec fn valid_dimension_line(line: Seq<char>) -> bool { line.len() > 0 }\nspec fn valid_matrix_row(line: Seq<char>, m: int) -> bool { line.len() > 0 && m > 0 }\nspec fn valid_number(s: Seq<char>) -> bool { s.len() > 0 }\nspec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool { \n    s.len() > 0 && max_x > 0 && max_y > 0 \n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> { seq![s] }\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) { (2, 2) }\nspec fn parse_number(s: Seq<char>) -> int { 0 }\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) { \n    (2, 2, seq![seq![0, 0], seq![0, 0]]) \n}\nspec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> { seq![] }\nspec fn parse_matrix_element(line: Seq<char>, pos: int) -> int { 0 }\nspec fn to_string(n: int) -> Seq<char> { seq![\'0\'] }\n\nspec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) {\n    let b = Seq::new(n as nat, |i: int| Seq::new(m as nat, |j: int| 0));\n    let ops = seq![];\n    greedy_step(a, b, ops, 0, 0, n, m)\n}\n\nspec fn greedy_step(a: Seq<Seq<int>>, b: Seq<Seq<int>>, ops: Seq<(int, int)>, \n                   start_i: int, start_j: int, n: int, m: int) -> (Seq<Seq<int>>, Seq<(int, int)>) {\n    (b, ops)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@ == ""-1\\n""@ || valid_operation_sequence(result@, stdin_input@),\n        result@ != ""-1\\n""@ ==> {\n            let parsed = parse_input(stdin_input@);\n            let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n            let ops = parse_operations(result@);\n            let algorithm_result = apply_greedy_algorithm(n, m, a);\n            let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);\n            b == a && ops == expected_ops\n        },\n        result@ == ""-1\\n""@ ==> {\n            let parsed = parse_input(stdin_input@);\n            let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n            let algorithm_result = apply_greedy_algorithm(n, m, a);\n            let b = algorithm_result.0;\n            b != a\n        },\n        result@ == ""-1\\n""@ || exists|k: nat, lines: Seq<Seq<char>>| {\n            &&& lines == split_lines(result@)\n            &&& lines.len() == k + 1\n            &&& lines[0] == to_string(k as int)\n            &&& k <= 2500\n            &&& {\n                let parsed = parse_input(stdin_input@);\n                let (n, m) = (parsed.0, parsed.1);\n                forall|i: int| #[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {\n                    &&& 1 <= n-1 && 1 <= m-1\n                    &&& lines[i] == seq![\'d\', \'u\', \'m\', \'m\', \'y\']\n                }\n            }\n        },\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    ""-1\\n"".to_string()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n          input.len() > 0 && input[input.len() - 1] == \'\\n\' &&     exists|lines: Seq<Seq<char>>| {\n             &&& lines == split_lines(input)         &&& lines.len() >= 3         &&& valid_dimension_line(lines[0])         &&& {\n                let parsed = parse_dimensions(lines[0]);\n                let (n, m) = (parsed.0, parsed.1);\n                &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50             &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)             &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>                  parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1         }\n         }\n      }\n       spec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool ;\n       spec fn valid_dimension_line(line: Seq<char>) -> bool ;\n       spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool ;\n       spec fn valid_number(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool ;\n       spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n      seq![s] }\n       spec fn parse_dimensions(line: Seq<char>) -> (int, int) ;\n       spec fn parse_number(s: Seq<char>) -> int ;\n       spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) ;\n       spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> ;\n       spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int ;\n       spec fn to_string(n: int) -> Seq<char> ;\n       spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) ;\n       fn solve(stdin_input: &str) -> (result: String)     requires          stdin_input@.len() > 0,         valid_input_format(stdin_input@),     ensures          result@.len() > 0,         result@ == ""-1\\n""@ || valid_operation_sequence(result@, stdin_input@),         result@ != ""-1\\n""@ ==> {\n                  let parsed = parse_input(stdin_input@);\n                  let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n                  let ops = parse_operations(result@);\n                  let algorithm_result = apply_greedy_algorithm(n, m, a);\n                  let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);\n                  b == a && ops == expected_ops         }\n      ,         result@ == ""-1\\n""@ || exists|k: nat, lines: Seq<Seq<char>>| {\n                  &&& lines == split_lines(result@)             &&& lines.len() == k + 1             &&& lines[0] == to_string(k as int)             &&& k <= 2500             &&& {\n                     let parsed = parse_input(stdin_input@);\n                     let (n, m) = (parsed.0, parsed.1);\n                     forall|i: int|        \n#[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {\n                    &&& 1 <= n-1 && 1 <= m-1                     &&& lines[i] == seq![\'d\', \'u\', \'m\', \'m\', \'y\']                 }\n                  }\n               }\n       , {\n           ""-1\\n"".to_string() }\n        }\n        fn main() {\n       }\n', 'use vstd::prelude::*;\n             fn main() {\n   }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1209.rs,115,115,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool 
{
    input.len() > 0 && contains_newline(input) && 
    has_valid_structure(input) && 
    first_line_is_valid_integer(input) &&
    remaining_lines_are_valid_reals(input)
}

spec fn input_sum_is_zero(input: Seq<char>) -> bool
{
    has_valid_structure(input) ==> sum_of_input_reals(input) == 0.0
}

spec fn valid_output_format(output: Seq<char>) -> bool
{
    output.len() >= 0 && 
    (output.len() == 0 || (ends_with_newline(output) && all_lines_are_integers(output)))
}

spec fn output_has_correct_length(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    count_lines(output) == get_n_from_input(input)
}

spec fn each_output_is_floor_or_ceiling(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    forall|i: int| 0 <= i < get_n_from_input(input) ==> 
        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>
        {
            let input_val = get_ith_real(input, i);
            let output_val = get_ith_integer(output, i);
            output_val == floor_of(input_val) || output_val == ceiling_of(input_val)
        }
}

spec fn output_sum_is_zero(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    sum_of_output_integers(output) == 0
}

spec fn output_preserves_integers(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    forall|i: int| 0 <= i < get_n_from_input(input) ==> 
        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>
        {
            let input_val = get_ith_real(input, i);
            is_integer(input_val) ==> get_ith_integer(output, i) == int_value_of(input_val)
        }
}

spec fn contains_newline(s: Seq<char>) -> bool
{
    exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == '\n'
}

spec fn ends_with_newline(s: Seq<char>) -> bool
{
    s.len() > 0 && s[s.len()-1] == '\n'
}

spec fn has_valid_structure(s: Seq<char>) -> bool { true }
spec fn first_line_is_valid_integer(s: Seq<char>) -> bool { true }
spec fn remaining_lines_are_valid_reals(s: Seq<char>) -> bool { true }
spec fn all_lines_are_integers(s: Seq<char>) -> bool { true }
spec fn is_integer(r: f64) -> bool { true }

spec fn sum_of_input_reals(input: Seq<char>) -> f64 { 0.0 }
spec fn sum_of_output_integers(output: Seq<char>) -> int { 0 }
spec fn get_n_from_input(input: Seq<char>) -> nat { 1 }
spec fn count_lines(s: Seq<char>) -> nat { if s == seq![48 as char, '\n'] { 1 } else { 0 } }
spec fn get_ith_real(input: Seq<char>, i: int) -> f64 { 0.0 }
spec fn get_ith_integer(output: Seq<char>, i: int) -> int { 0 }
spec fn floor_of(r: f64) -> int { 0 }
spec fn ceiling_of(r: f64) -> int { 0 }
spec fn int_value_of(r: f64) -> int { 0 }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (output: Seq<char>)
    requires
        stdin_input.len() > 0,
        valid_input_format(stdin_input),
        input_sum_is_zero(stdin_input),
    ensures
        valid_output_format(output),
        output_has_correct_length(stdin_input, output),
        each_output_is_floor_or_ceiling(stdin_input, output),
        output_sum_is_zero(stdin_input, output),
        output_preserves_integers(stdin_input, output),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool 
{
    input.len() > 0 && contains_newline(input) && 
    has_valid_structure(input) && 
    first_line_is_valid_integer(input) &&
    remaining_lines_are_valid_reals(input)
}

spec fn input_sum_is_zero(input: Seq<char>) -> bool
{
    has_valid_structure(input) ==> sum_of_input_reals(input) == 0.0
}

spec fn valid_output_format(output: Seq<char>) -> bool
{
    output.len() >= 0 && 
    (output.len() == 0 || (ends_with_newline(output) && all_lines_are_integers(output)))
}

spec fn output_has_correct_length(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    count_lines(output) == get_n_from_input(input)
}

spec fn each_output_is_floor_or_ceiling(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    forall|i: int| 0 <= i < get_n_from_input(input) ==> 
        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>
        {
            let input_val = get_ith_real(input, i);
            let output_val = get_ith_integer(output, i);
            output_val == floor_of(input_val) || output_val == ceiling_of(input_val)
        }
}

spec fn output_sum_is_zero(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    sum_of_output_integers(output) == 0
}

spec fn output_preserves_integers(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    forall|i: int| 0 <= i < get_n_from_input(input) ==> 
        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>
        {
            let input_val = get_ith_real(input, i);
            is_integer(input_val) ==> get_ith_integer(output, i) == int_value_of(input_val)
        }
}

spec fn contains_newline(s: Seq<char>) -> bool
{
    exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == '\n'
}

spec fn ends_with_newline(s: Seq<char>) -> bool
{
    s.len() > 0 && s[s.len()-1] == '\n'
}

spec fn has_valid_structure(s: Seq<char>) -> bool { true }
spec fn first_line_is_valid_integer(s: Seq<char>) -> bool { true }
spec fn remaining_lines_are_valid_reals(s: Seq<char>) -> bool { true }
spec fn all_lines_are_integers(s: Seq<char>) -> bool { true }
spec fn is_integer(r: f64) -> bool { true }

spec fn sum_of_input_reals(input: Seq<char>) -> f64 { 0.0 }
spec fn sum_of_output_integers(output: Seq<char>) -> int { 0 }
spec fn get_n_from_input(input: Seq<char>) -> nat { 1 }
spec fn count_lines(s: Seq<char>) -> nat { if s == seq![48 as char, '\n'] { 1 } else { 0 } }
spec fn get_ith_real(input: Seq<char>, i: int) -> f64 { 0.0 }
spec fn get_ith_integer(output: Seq<char>, i: int) -> int { 0 }
spec fn floor_of(r: f64) -> int { 0 }
spec fn ceiling_of(r: f64) -> int { 0 }
spec fn int_value_of(r: f64) -> int { 0 }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (output: Seq<char>)
    requires
        stdin_input.len() > 0,
        valid_input_format(stdin_input),
        input_sum_is_zero(stdin_input),
    ensures
        valid_output_format(output),
        output_has_correct_length(stdin_input, output),
        each_output_is_floor_or_ceiling(stdin_input, output),
        output_sum_is_zero(stdin_input, output),
        output_preserves_integers(stdin_input, output),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1268.rs,55,55,1.0,122.438,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {
    a.len() == b.len() && a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> 0 <= #[trigger] a[i] <= #[trigger] b[i]
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn find_two_largest_sum(s: Seq<int>) -> int
    recommends s.len() >= 2
{
    0
}

spec fn find_max(s: Seq<int>) -> int
    recommends s.len() >= 1
{
    0
}

spec fn find_max_excluding(s: Seq<int>, exclude: int) -> int
    recommends s.len() >= 2 && 0 <= exclude < s.len()
{
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Seq<int>, b: Seq<int>) -> (result: String)
    requires 
        valid_input(a, b),
    ensures 
        result@ == seq!['Y','E','S'] || result@ == seq!['N','O'],
        (result@ == seq!['Y','E','S']) <==> find_two_largest_sum(b) >= sum_seq(a),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {
    a.len() == b.len() && a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> 0 <= #[trigger] a[i] <= #[trigger] b[i]
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn find_two_largest_sum(s: Seq<int>) -> int
    recommends s.len() >= 2
{
    0
}

spec fn find_max(s: Seq<int>) -> int
    recommends s.len() >= 1
{
    0
}

spec fn find_max_excluding(s: Seq<int>, exclude: int) -> int
    recommends s.len() >= 2 && 0 <= exclude < s.len()
{
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: Seq<int>, b: Seq<int>) -> (result: String)
    requires 
        valid_input(a, b),
    ensures 
        result@ == seq!['Y','E','S'] || result@ == seq!['N','O'],
        (result@ == seq!['Y','E','S']) <==> find_two_largest_sum(b) >= sum_seq(a),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO"".to_string()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {\n    a.len() == b.len() && a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> 0 <= #[trigger] a[i] <= #[trigger] b[i]\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_two_largest_sum(s: Seq<int>) -> int\n    recommends s.len() >= 2\n{\n    0\n}\n\nspec fn find_max(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nspec fn find_max_excluding(s: Seq<int>, exclude: int) -> int\n    recommends s.len() >= 2 && 0 <= exclude < s.len()\n{\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: Seq<int>, b: Seq<int>) -> (result: String)\n    requires \n        valid_input(a, b),\n    ensures \n        result@ == seq![\'Y\',\'E\',\'S\'] || result@ == seq![\'N\',\'O\'],\n        (result@ == seq![\'Y\',\'E\',\'S\']) <==> find_two_largest_sum(b) >= sum_seq(a),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""NO"".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_131.rs,61,61,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 && 
    parse_int(lines[0]) > 0 &&
    parse_int_array(lines[1]).len() == parse_int(lines[0]) &&
    parse_int_array(lines[2]).len() == parse_int(lines[0])
}

spec fn get_initial_sum(input: &str) -> int
    recommends is_valid_input(input)
{
    let lines = split_lines(input);
    sum_seq(parse_int_array(lines[1]))
}

spec fn get_target_sum(input: &str) -> int
    recommends is_valid_input(input)
{
    let lines = split_lines(input);
    sum_seq(parse_int_array(lines[2]))
}

spec fn sum_seq(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() == 0 {
        0
    } else {
        nums[0] + sum_seq(nums.subrange(1, nums.len() as int))
    }
}

uninterp spec fn split_lines(input: &str) -> Seq<&str>;
uninterp spec fn parse_int(s: &str) -> int;
uninterp spec fn parse_int_array(s: &str) -> Seq<int>;
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires is_valid_input(input)
    ensures (result == ""Yes"") <==> get_initial_sum(input) >= get_target_sum(input)
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 && 
    parse_int(lines[0]) > 0 &&
    parse_int_array(lines[1]).len() == parse_int(lines[0]) &&
    parse_int_array(lines[2]).len() == parse_int(lines[0])
}

spec fn get_initial_sum(input: &str) -> int
    recommends is_valid_input(input)
{
    let lines = split_lines(input);
    sum_seq(parse_int_array(lines[1]))
}

spec fn get_target_sum(input: &str) -> int
    recommends is_valid_input(input)
{
    let lines = split_lines(input);
    sum_seq(parse_int_array(lines[2]))
}

spec fn sum_seq(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() == 0 {
        0
    } else {
        nums[0] + sum_seq(nums.subrange(1, nums.len() as int))
    }
}

uninterp spec fn split_lines(input: &str) -> Seq<&str>;
uninterp spec fn parse_int(s: &str) -> int;
uninterp spec fn parse_int_array(s: &str) -> Seq<int>;
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires is_valid_input(input)
    ensures (result == ""Yes"") <==> get_initial_sum(input) >= get_target_sum(input)
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No"".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1339.rs,70,70,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: int, segments: Seq<(int, int)>) -> bool {
    n >= 1 && segments.len() == n && 
    forall|i: int| 0 <= i < n ==> segments[i].0 <= segments[i].1
}

spec fn covers_all(segments: Seq<(int, int)>, idx: int) -> bool {
    0 <= idx < segments.len() &&
    forall|j: int| 0 <= j < segments.len() ==> 
        segments[idx].0 <= segments[j].0 && segments[j].1 <= segments[idx].1
}

spec fn has_min_left_and_max_right(segments: Seq<(int, int)>, idx: int) -> bool {
    0 <= idx < segments.len() &&
    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].0 <= segments[j].0) &&
    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].1 >= segments[j].1)
}

spec fn min_left(segments: Seq<(int, int)>) -> int
    requires segments.len() > 0
    decreases segments.len()
{
    if segments.len() == 1 { 
        segments[0].0
    } else if segments[0].0 <= min_left(segments.subrange(1, segments.len() as int)) { 
        segments[0].0
    } else { 
        min_left(segments.subrange(1, segments.len() as int))
    }
}

spec fn max_right(segments: Seq<(int, int)>) -> int
    requires segments.len() > 0
    decreases segments.len()
{
    if segments.len() == 1 { 
        segments[0].1
    } else if segments[0].1 >= max_right(segments.subrange(1, segments.len() as int)) { 
        segments[0].1
    } else { 
        max_right(segments.subrange(1, segments.len() as int))
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(n: i32, segments: &[i32]) -> (result: i32)
    requires 
        n >= 1 && segments.len() == n && 
        forall|i: int| 0 <= i < n ==> i % 2 == 0 ==> segments[i] <= segments[i + 1]
    ensures 
        result == -1 || (1 <= result <= n)
// </vc-spec>
// <vc-code>
{
    assume(false);
    -1
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: int, segments: Seq<(int, int)>) -> bool {
    n >= 1 && segments.len() == n && 
    forall|i: int| 0 <= i < n ==> segments[i].0 <= segments[i].1
}

spec fn covers_all(segments: Seq<(int, int)>, idx: int) -> bool {
    0 <= idx < segments.len() &&
    forall|j: int| 0 <= j < segments.len() ==> 
        segments[idx].0 <= segments[j].0 && segments[j].1 <= segments[idx].1
}

spec fn has_min_left_and_max_right(segments: Seq<(int, int)>, idx: int) -> bool {
    0 <= idx < segments.len() &&
    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].0 <= segments[j].0) &&
    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].1 >= segments[j].1)
}

spec fn min_left(segments: Seq<(int, int)>) -> int
    requires segments.len() > 0
    decreases segments.len()
{
    if segments.len() == 1 { 
        segments[0].0
    } else if segments[0].0 <= min_left(segments.subrange(1, segments.len() as int)) { 
        segments[0].0
    } else { 
        min_left(segments.subrange(1, segments.len() as int))
    }
}

spec fn max_right(segments: Seq<(int, int)>) -> int
    requires segments.len() > 0
    decreases segments.len()
{
    if segments.len() == 1 { 
        segments[0].1
    } else if segments[0].1 >= max_right(segments.subrange(1, segments.len() as int)) { 
        segments[0].1
    } else { 
        max_right(segments.subrange(1, segments.len() as int))
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(n: i32, segments: &[i32]) -> (result: i32)
    requires 
        n >= 1 && segments.len() == n && 
        forall|i: int| 0 <= i < n ==> i % 2 == 0 ==> segments[i] <= segments[i + 1]
    ensures 
        result == -1 || (1 <= result <= n)
// </vc-spec>
// <vc-code>
{
    assume(false);
    -1
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1354.rs,120,120,1.0,153.531,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {
    n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&
    (forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n)
}

spec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool
    recommends
        n > 0 && k > 0 && a > 0 && num_shots >= 0,
        num_shots <= shots.len(),
        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n
{
    let hit_cells = Set::new(|cell: int| exists|i: int| 0 <= i < num_shots && i < shots.len() && shots[i] == cell);
    greedy_ship_placement(n, k, a, hit_cells) >= k
}

spec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int
    recommends
        n > 0 && k > 0 && a > 0,
        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n
{
    greedy_place_ships_from_position(1, n, k, a, hit_cells)
}

spec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int
    recommends
        pos >= 1 && n > 0 && k >= 0 && a > 0,
        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n
{
    if k == 0 || pos > n {
        0
    } else {
        // Simplified implementation without termination issues
        if pos + a - 1 <= n { 1 } else { 0 }
    }
}

spec fn is_natural_number_string(s: Seq<char>) -> bool {
    s.len() > 0 && s[0] != '0' && (forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> '0' <= s[i] <= '9')
}

spec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>
    recommends input.len() > 0
{
    seq![]
}

spec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {
    (1, 1, 1)
}

spec fn parse_int_spec(line: Seq<char>) -> int {
    0
}

spec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn int_to_string_spec(value: int) -> Seq<char>
    recommends value >= 1
{
    seq!['1']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len()-1] == '\n'
    ensures
        result.len() > 0,
        result[result.len()-1] == '\n',
        result == seq!['-', '1', '\n'] || (exists|shot_num_str: Seq<char>| #![auto] shot_num_str.len() > 0 && 
                             result == shot_num_str + seq!['\n'] && 
                             is_natural_number_string(shot_num_str)),
        ({
            let lines = parse_input_spec(stdin_input);
            if lines.len() >= 3 {
                let first_line = parse_three_ints_spec(lines[0]);
                let (n, k, a) = (first_line.0, first_line.1, first_line.2);
                let m = parse_int_spec(lines[1]);
                let shots = parse_int_array_spec(lines[2]);
                if valid_input(n, k, a, m, shots) {
                    if can_place_ships_func(n, k, a, shots, m) {
                        result == seq!['-', '1', '\n']
                    } else {
                        exists|shot_idx: int| #![auto] 1 <= shot_idx <= m && 
                                            result == int_to_string_spec(shot_idx) + seq!['\n'] &&
                                            !can_place_ships_func(n, k, a, shots, shot_idx) &&
                                            (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))
                    }
                } else {
                    true
                }
            } else {
                true
            }
        })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {
    n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&
    (forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n)
}

spec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool
    recommends
        n > 0 && k > 0 && a > 0 && num_shots >= 0,
        num_shots <= shots.len(),
        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n
{
    let hit_cells = Set::new(|cell: int| exists|i: int| 0 <= i < num_shots && i < shots.len() && shots[i] == cell);
    greedy_ship_placement(n, k, a, hit_cells) >= k
}

spec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int
    recommends
        n > 0 && k > 0 && a > 0,
        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n
{
    greedy_place_ships_from_position(1, n, k, a, hit_cells)
}

spec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int
    recommends
        pos >= 1 && n > 0 && k >= 0 && a > 0,
        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n
{
    if k == 0 || pos > n {
        0
    } else {
        // Simplified implementation without termination issues
        if pos + a - 1 <= n { 1 } else { 0 }
    }
}

spec fn is_natural_number_string(s: Seq<char>) -> bool {
    s.len() > 0 && s[0] != '0' && (forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> '0' <= s[i] <= '9')
}

spec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>
    recommends input.len() > 0
{
    seq![]
}

spec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {
    (1, 1, 1)
}

spec fn parse_int_spec(line: Seq<char>) -> int {
    0
}

spec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn int_to_string_spec(value: int) -> Seq<char>
    recommends value >= 1
{
    seq!['1']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len()-1] == '\n'
    ensures
        result.len() > 0,
        result[result.len()-1] == '\n',
        result == seq!['-', '1', '\n'] || (exists|shot_num_str: Seq<char>| #![auto] shot_num_str.len() > 0 && 
                             result == shot_num_str + seq!['\n'] && 
                             is_natural_number_string(shot_num_str)),
        ({
            let lines = parse_input_spec(stdin_input);
            if lines.len() >= 3 {
                let first_line = parse_three_ints_spec(lines[0]);
                let (n, k, a) = (first_line.0, first_line.1, first_line.2);
                let m = parse_int_spec(lines[1]);
                let shots = parse_int_array_spec(lines[2]);
                if valid_input(n, k, a, m, shots) {
                    if can_place_ships_func(n, k, a, shots, m) {
                        result == seq!['-', '1', '\n']
                    } else {
                        exists|shot_idx: int| #![auto] 1 <= shot_idx <= m && 
                                            result == int_to_string_spec(shot_idx) + seq!['\n'] &&
                                            !can_place_ships_func(n, k, a, shots, shot_idx) &&
                                            (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))
                    }
                } else {
                    true
                }
            } else {
                true
            }
        })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {\n    n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&\n    (forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n)\n}\n\nspec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool\n    recommends\n        n > 0 && k > 0 && a > 0 && num_shots >= 0,\n        num_shots <= shots.len(),\n        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n\n{\n    let hit_cells = Set::new(|cell: int| exists|i: int| 0 <= i < num_shots && i < shots.len() && shots[i] == cell);\n    greedy_ship_placement(n, k, a, hit_cells) >= k\n}\n\nspec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        n > 0 && k > 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    greedy_place_ships_from_position(1, n, k, a, hit_cells)\n}\n\nspec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        pos >= 1 && n > 0 && k >= 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    if k == 0 || pos > n {\n        0\n    } else {\n        // Simplified implementation without termination issues\n        if pos + a - 1 <= n { 1 } else { 0 }\n    }\n}\n\nspec fn is_natural_number_string(s: Seq<char>) -> bool {\n    s.len() > 0 && s[0] != '0' && (forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> '0' <= s[i] <= '9')\n}\n\nspec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>\n    recommends input.len() > 0\n{\n    seq![]\n}\n\nspec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {\n    (1, 1, 1)\n}\n\nspec fn parse_int_spec(line: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_spec(value: int) -> Seq<char>\n    recommends value >= 1\n{\n    seq!['1']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len()-1] == '\\n'\n    ensures\n        result.len() > 0,\n        result[result.len()-1] == '\\n',\n        result == seq!['-', '1', '\\n'] || (exists|shot_num_str: Seq<char>| #![auto] shot_num_str.len() > 0 && \n                             result == shot_num_str + seq!['\\n'] && \n                             is_natural_number_string(shot_num_str)),\n        ({\n            let lines = parse_input_spec(stdin_input);\n            if lines.len() >= 3 {\n                let first_line = parse_three_ints_spec(lines[0]);\n                let (n, k, a) = (first_line.0, first_line.1, first_line.2);\n                let m = parse_int_spec(lines[1]);\n                let shots = parse_int_array_spec(lines[2]);\n                if valid_input(n, k, a, m, shots) {\n                    if can_place_ships_func(n, k, a, shots, m) {\n                        result == seq!['-', '1', '\\n']\n                    } else {\n                        exists|shot_idx: int| #![auto] 1 <= shot_idx <= m && \n                                            result == int_to_string_spec(shot_idx) + seq!['\\n'] &&\n                                            !can_place_ships_func(n, k, a, shots, shot_idx) &&\n                                            (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))\n                    }\n                } else {\n                    true\n                }\n            } else {\n                true\n            }\n        })\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1386.rs,79,79,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|i: int| 0 < i < input.len() - 1 && input[i] == ' ' &&
    (forall|j: int| 0 <= j < i ==> '0' <= input[j] <= '9') &&
    (forall|j: int| i < j < input.len() ==> '0' <= input[j] <= '9')
}

spec fn valid_dimensions(w: int, h: int) -> bool {
    w >= 1 && h >= 1 && w <= 1000 && h <= 1000
}

spec fn parse_two_ints(input: Seq<char>) -> (int, int) {
    let space_index = find_space_spec(input, 0);
    let w = string_to_int_spec(input.subrange(0, space_index));
    let h = string_to_int_spec(input.subrange(space_index + 1, input.len() as int));
    (w, h)
}

spec fn find_space_spec(s: Seq<char>, start: int) -> int
    decreases s.len() - start
{
    if s[start] == ' ' {
        start
    } else {
        find_space_spec(s, start + 1)
    }
}

spec fn string_to_int_spec(s: Seq<char>) -> int {
    if s.len() == 1 {
        s[0] as int - '0' as int
    } else {
        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)
    }
}

spec fn int_to_string_spec(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_spec(n / 10).add(int_to_string_spec(n % 10))
    }
}

spec fn mod_pow_spec(base: int, exp: int, mod_val: int) -> int {
    if exp == 0 {
        1int % mod_val
    } else if exp % 2 == 0 {
        let half = mod_pow_spec(base, exp / 2, mod_val);
        (half * half) % mod_val
    } else {
        (base * mod_pow_spec(base, exp - 1, mod_val)) % mod_val
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn main_function() -> (result: int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|i: int| 0 < i < input.len() - 1 && input[i] == ' ' &&
    (forall|j: int| 0 <= j < i ==> '0' <= input[j] <= '9') &&
    (forall|j: int| i < j < input.len() ==> '0' <= input[j] <= '9')
}

spec fn valid_dimensions(w: int, h: int) -> bool {
    w >= 1 && h >= 1 && w <= 1000 && h <= 1000
}

spec fn parse_two_ints(input: Seq<char>) -> (int, int) {
    let space_index = find_space_spec(input, 0);
    let w = string_to_int_spec(input.subrange(0, space_index));
    let h = string_to_int_spec(input.subrange(space_index + 1, input.len() as int));
    (w, h)
}

spec fn find_space_spec(s: Seq<char>, start: int) -> int
    decreases s.len() - start
{
    if s[start] == ' ' {
        start
    } else {
        find_space_spec(s, start + 1)
    }
}

spec fn string_to_int_spec(s: Seq<char>) -> int {
    if s.len() == 1 {
        s[0] as int - '0' as int
    } else {
        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)
    }
}

spec fn int_to_string_spec(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_spec(n / 10).add(int_to_string_spec(n % 10))
    }
}

spec fn mod_pow_spec(base: int, exp: int, mod_val: int) -> int {
    if exp == 0 {
        1int % mod_val
    } else if exp % 2 == 0 {
        let half = mod_pow_spec(base, exp / 2, mod_val);
        (half * half) % mod_val
    } else {
        (base * mod_pow_spec(base, exp - 1, mod_val)) % mod_val
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn main_function() -> (result: int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_144.rs,159,159,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn can_partition_into_equal_sum_segments(input: Seq<char>) -> bool {
    if input.len() == 0 {
        false
    } else {
        let lines = split_lines(input);
        if lines.len() < 2 {
            false
        } else {
            let n_str = trim(lines[0]);
            let digits_str = trim(lines[1]);
            let n = parse_int(n_str);
            if n < 2 || n > 100 || digits_str.len() != n {
                false
            } else {
                let digits = parse_digits(digits_str);
                if digits.len() != n {
                    false
                } else {
                    exists|i: int| 0 <= i < n - 1 && {
                        let first_sum = sum(digits.subrange(0, i + 1));
                        first_sum >= 0 &&
                        can_partition_remainder(digits, i + 1, first_sum)
                    }
                }
            }
        }
    }
}

spec fn can_partition_remainder(digits: Seq<int>, start: int, target_sum: int) -> bool 
    decreases digits.len() - start
{
    if start < 0 || start > digits.len() || target_sum < 0 {
        false
    } else if start >= digits.len() {
        true
    } else {
        exists|segment_end: int| start < segment_end <= digits.len() && 
            sum(digits.subrange(start, segment_end)) == target_sum &&
            can_partition_remainder(digits, segment_end, target_sum)
    }
}

spec fn sum(s: Seq<int>) -> int {
    if s.len() == 0 {
        0
    } else {
        s[0] + sum(s.skip(1))
    }
}

spec fn parse_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        char_to_digit(s[0])
    } else {
        char_to_digit(s[0]) * power10(s.len() - 1) + parse_int(s.skip(1))
    }
}

spec fn char_to_digit(c: char) -> int {
    if '0' <= c && c <= '9' {
        (c as int) - ('0' as int)
    } else {
        0
    }
}

spec fn power10(n: int) -> int {
    if n <= 0 {
        1
    } else {
        10 * power10(n - 1)
    }
}

spec fn parse_digits(s: Seq<char>) -> Seq<int> {
    if s.len() == 0 {
        seq![]
    } else {
        seq![char_to_digit(s[0])] + parse_digits(s.skip(1))
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    split_by_char(s, '\n')
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![seq![]]
    } else if s[0] == delimiter {
        seq![seq![]] + split_by_char(s.skip(1), delimiter)
    } else {
        let rest = split_by_char(s.skip(1), delimiter);
        if rest.len() == 0 {
            seq![s.subrange(0, 1)]
        } else {
            seq![s.subrange(0, 1) + rest[0]] + rest.skip(1)
        }
    }
}

spec fn trim(s: Seq<char>) -> Seq<char> {
    trim_left(trim_right(s))
}

spec fn trim_left(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[0] == ' ' || s[0] == '\t' || s[0] == '\n' || s[0] == '\r' {
        trim_left(s.skip(1))
    } else {
        s
    }
}

spec fn trim_right(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[s.len() - 1] == ' ' || s[s.len() - 1] == '\t' || s[s.len() - 1] == '\n' || s[s.len() - 1] == '\r' {
        trim_right(s.subrange(0, s.len() - 1))
    } else {
        s
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Seq<char>) -> (result: Seq<char>)
    requires s.len() > 0
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    Seq::new(3 as nat, |i: nat| match i {
        0 => 'N',
        1 => 'O',
        2 => '\n',
        _ => 'N'
    })
    /* impl-end */
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn can_partition_into_equal_sum_segments(input: Seq<char>) -> bool {
    if input.len() == 0 {
        false
    } else {
        let lines = split_lines(input);
        if lines.len() < 2 {
            false
        } else {
            let n_str = trim(lines[0]);
            let digits_str = trim(lines[1]);
            let n = parse_int(n_str);
            if n < 2 || n > 100 || digits_str.len() != n {
                false
            } else {
                let digits = parse_digits(digits_str);
                if digits.len() != n {
                    false
                } else {
                    exists|i: int| 0 <= i < n - 1 && {
                        let first_sum = sum(digits.subrange(0, i + 1));
                        first_sum >= 0 &&
                        can_partition_remainder(digits, i + 1, first_sum)
                    }
                }
            }
        }
    }
}

spec fn can_partition_remainder(digits: Seq<int>, start: int, target_sum: int) -> bool 
    decreases digits.len() - start
{
    if start < 0 || start > digits.len() || target_sum < 0 {
        false
    } else if start >= digits.len() {
        true
    } else {
        exists|segment_end: int| start < segment_end <= digits.len() && 
            sum(digits.subrange(start, segment_end)) == target_sum &&
            can_partition_remainder(digits, segment_end, target_sum)
    }
}

spec fn sum(s: Seq<int>) -> int {
    if s.len() == 0 {
        0
    } else {
        s[0] + sum(s.skip(1))
    }
}

spec fn parse_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        char_to_digit(s[0])
    } else {
        char_to_digit(s[0]) * power10(s.len() - 1) + parse_int(s.skip(1))
    }
}

spec fn char_to_digit(c: char) -> int {
    if '0' <= c && c <= '9' {
        (c as int) - ('0' as int)
    } else {
        0
    }
}

spec fn power10(n: int) -> int {
    if n <= 0 {
        1
    } else {
        10 * power10(n - 1)
    }
}

spec fn parse_digits(s: Seq<char>) -> Seq<int> {
    if s.len() == 0 {
        seq![]
    } else {
        seq![char_to_digit(s[0])] + parse_digits(s.skip(1))
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    split_by_char(s, '\n')
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![seq![]]
    } else if s[0] == delimiter {
        seq![seq![]] + split_by_char(s.skip(1), delimiter)
    } else {
        let rest = split_by_char(s.skip(1), delimiter);
        if rest.len() == 0 {
            seq![s.subrange(0, 1)]
        } else {
            seq![s.subrange(0, 1) + rest[0]] + rest.skip(1)
        }
    }
}

spec fn trim(s: Seq<char>) -> Seq<char> {
    trim_left(trim_right(s))
}

spec fn trim_left(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[0] == ' ' || s[0] == '\t' || s[0] == '\n' || s[0] == '\r' {
        trim_left(s.skip(1))
    } else {
        s
    }
}

spec fn trim_right(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[s.len() - 1] == ' ' || s[s.len() - 1] == '\t' || s[s.len() - 1] == '\n' || s[s.len() - 1] == '\r' {
        trim_right(s.subrange(0, s.len() - 1))
    } else {
        s
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: Seq<char>) -> (result: Seq<char>)
    requires s.len() > 0
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    Seq::new(3 as nat, |i: nat| match i {
        0 => 'N',
        1 => 'O',
        2 => '\n',
        _ => 'N'
    })
    /* impl-end */
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1448.rs,112,112,1.0,122.328,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 && 
    valid_first_line(lines[0]) &&
    valid_second_line(lines[1]) &&
    valid_grasshopper_lines_simple(lines) &&
    ({
        let first_line = split_spaces(lines[0]);
        let n = string_to_int(first_line[0]);
        let d = string_to_int(first_line[1]);
        let m = string_to_int(lines[1]);
        d >= 1 && d < n && n <= 100 &&
        m >= 1 && m <= 100 &&
        lines.len() >= 2 + m &&
        forall|i: int| #[trigger] valid_grasshopper_line(lines[2 + i], n) && 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)
    })
}

spec fn valid_first_line(line: Seq<char>) -> bool {
    let parts = split_spaces(line);
    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])
}

spec fn valid_second_line(line: Seq<char>) -> bool {
    is_valid_integer(line)
}

spec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 3 &&
    ({
        let m = string_to_int(lines[1]);
        lines.len() >= 2 + m
    })
}

spec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {
    let parts = split_spaces(line);
    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&
    string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&
    string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn get_n(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line = split_spaces(lines[0]);
    string_to_int(first_line[0])
}

spec fn get_d(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line = split_spaces(lines[0]);
    string_to_int(first_line[1])
}

spec fn get_number_of_grasshoppers(input: Seq<char>) -> int {
    let lines = split_lines(input);
    string_to_int(lines[1])
}

spec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {
    let lines = split_lines(input);
    let coords = split_spaces(lines[2 + i]);
    (string_to_int(coords[0]), string_to_int(coords[1]))
}

spec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {
    let (x, y) = grasshopper;
    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d
}

/* Helper functions for string processing */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: Vec<String>)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 && 
    valid_first_line(lines[0]) &&
    valid_second_line(lines[1]) &&
    valid_grasshopper_lines_simple(lines) &&
    ({
        let first_line = split_spaces(lines[0]);
        let n = string_to_int(first_line[0]);
        let d = string_to_int(first_line[1]);
        let m = string_to_int(lines[1]);
        d >= 1 && d < n && n <= 100 &&
        m >= 1 && m <= 100 &&
        lines.len() >= 2 + m &&
        forall|i: int| #[trigger] valid_grasshopper_line(lines[2 + i], n) && 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)
    })
}

spec fn valid_first_line(line: Seq<char>) -> bool {
    let parts = split_spaces(line);
    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])
}

spec fn valid_second_line(line: Seq<char>) -> bool {
    is_valid_integer(line)
}

spec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 3 &&
    ({
        let m = string_to_int(lines[1]);
        lines.len() >= 2 + m
    })
}

spec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {
    let parts = split_spaces(line);
    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&
    string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&
    string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn get_n(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line = split_spaces(lines[0]);
    string_to_int(first_line[0])
}

spec fn get_d(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line = split_spaces(lines[0]);
    string_to_int(first_line[1])
}

spec fn get_number_of_grasshoppers(input: Seq<char>) -> int {
    let lines = split_lines(input);
    string_to_int(lines[1])
}

spec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {
    let lines = split_lines(input);
    let coords = split_spaces(lines[2 + i]);
    (string_to_int(coords[0]), string_to_int(coords[1]))
}

spec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {
    let (x, y) = grasshopper;
    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d
}

/* Helper functions for string processing */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: Vec<String>)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && \n    valid_first_line(lines[0]) &&\n    valid_second_line(lines[1]) &&\n    valid_grasshopper_lines_simple(lines) &&\n    ({\n        let first_line = split_spaces(lines[0]);\n        let n = string_to_int(first_line[0]);\n        let d = string_to_int(first_line[1]);\n        let m = string_to_int(lines[1]);\n        d >= 1 && d < n && n <= 100 &&\n        m >= 1 && m <= 100 &&\n        lines.len() >= 2 + m &&\n        forall|i: int| #[trigger] valid_grasshopper_line(lines[2 + i], n) && 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)\n    })\n}\n\nspec fn valid_first_line(line: Seq<char>) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])\n}\n\nspec fn valid_second_line(line: Seq<char>) -> bool {\n    is_valid_integer(line)\n}\n\nspec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 3 &&\n    ({\n        let m = string_to_int(lines[1]);\n        lines.len() >= 2 + m\n    })\n}\n\nspec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&\n    string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&\n    string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[0])\n}\n\nspec fn get_d(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[1])\n}\n\nspec fn get_number_of_grasshoppers(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    string_to_int(lines[1])\n}\n\nspec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {\n    let lines = split_lines(input);\n    let coords = split_spaces(lines[2 + i]);\n    (string_to_int(coords[0]), string_to_int(coords[1]))\n}\n\nspec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {\n    let (x, y) = grasshopper;\n    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d\n}\n\n/* Helper functions for string processing */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: Vec<String>)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1512.rs,67,67,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_permutation(p: Seq<int>, n: int) -> bool {
  p.len() == n && n >= 1 &&
  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&
  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn count_records(s: Seq<int>) -> int {
  if s.len() == 0 { 0 }
  else { 1 + count_records_from_index(s, 1, s[0]) }
}

spec fn count_records_after_removal(p: Seq<int>, to_remove: int) -> int {
  let filtered = Seq::new((p.len() - 1) as nat, |i: int| 
    if index_of(p, to_remove) <= i { p[i + 1] } else { p[i] });
  count_records(filtered)
}
spec fn count_records_from_index(s: Seq<int>, idx: int, max_so_far: int) -> int
  decreases s.len() - idx
{
  if idx >= s.len() { 0 }
  else if s[idx] > max_so_far { 
    1 + count_records_from_index(s, idx + 1, s[idx])
  } else { 
    count_records_from_index(s, idx + 1, max_so_far)
  }
}

spec fn index_of(s: Seq<int>, elem: int) -> int {
  choose|i: int| 0 <= i < s.len() && s[i] == elem
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: Vec<i8>) -> (result: i8)
  requires 
    valid_permutation(p@.map(|i, x: i8| x as int), n as int)
  ensures 
    1 <= result as int <= n as int,
    p@.map(|i, x: i8| x as int).contains(result as int),
    {
      let p_int = p@.map(|i, x: i8| x as int);
      forall|x: int| p_int.contains(x) ==> count_records_after_removal(p_int, result as int) >= count_records_after_removal(p_int, x)
    },
    {
      let p_int = p@.map(|i, x: i8| x as int);
      forall|x: int| p_int.contains(x) && count_records_after_removal(p_int, x) == count_records_after_removal(p_int, result as int) ==> result as int <= x
    }
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_permutation(p: Seq<int>, n: int) -> bool {
  p.len() == n && n >= 1 &&
  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&
  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn count_records(s: Seq<int>) -> int {
  if s.len() == 0 { 0 }
  else { 1 + count_records_from_index(s, 1, s[0]) }
}

spec fn count_records_after_removal(p: Seq<int>, to_remove: int) -> int {
  let filtered = Seq::new((p.len() - 1) as nat, |i: int| 
    if index_of(p, to_remove) <= i { p[i + 1] } else { p[i] });
  count_records(filtered)
}
spec fn count_records_from_index(s: Seq<int>, idx: int, max_so_far: int) -> int
  decreases s.len() - idx
{
  if idx >= s.len() { 0 }
  else if s[idx] > max_so_far { 
    1 + count_records_from_index(s, idx + 1, s[idx])
  } else { 
    count_records_from_index(s, idx + 1, max_so_far)
  }
}

spec fn index_of(s: Seq<int>, elem: int) -> int {
  choose|i: int| 0 <= i < s.len() && s[i] == elem
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, p: Vec<i8>) -> (result: i8)
  requires 
    valid_permutation(p@.map(|i, x: i8| x as int), n as int)
  ensures 
    1 <= result as int <= n as int,
    p@.map(|i, x: i8| x as int).contains(result as int),
    {
      let p_int = p@.map(|i, x: i8| x as int);
      forall|x: int| p_int.contains(x) ==> count_records_after_removal(p_int, result as int) >= count_records_after_removal(p_int, x)
    },
    {
      let p_int = p@.map(|i, x: i8| x as int);
      forall|x: int| p_int.contains(x) && count_records_after_removal(p_int, x) == count_records_after_removal(p_int, result as int) ==> result as int <= x
    }
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1547.rs,80,80,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 && split_string(&lines[0], ' ').len() == 3 &&
    {
        let n = string_to_int(&split_string(&lines[0], ' ')[0]);
        let m = string_to_int(&split_string(&lines[0], ' ')[1]);
        let k = string_to_int(&split_string(&lines[0], ' ')[2]);
        n > 0 && m > 0 && k >= 0 && lines.len() >= k + 1
    }
}

spec fn get_dimensions(input: &str) -> (int, int, int)
{
    let lines = split_lines(input);
    let first_line = split_string(&lines[0], ' ');
    (string_to_int(&first_line[0]), string_to_int(&first_line[1]), string_to_int(&first_line[2]))
}

spec fn compute_grid(lines: Seq<String>, n: int, m: int, k: int) -> Seq<Seq<int>>
{
    let row = Seq::new(n as nat, |i: int| (0, -1));
    let col = Seq::new(m as nat, |i: int| (0, -1));
    let processed_arrays = process_operations(lines, n, m, k, 0, row, col);
    build_grid(n, m, processed_arrays.0, processed_arrays.1)
}
// </vc-preamble>

// <vc-helpers>
/* Helper functions would be defined here */
spec fn split_lines(input: &str) -> Seq<String> {
    Seq::empty()
}

spec fn split_string(s: &str, delimiter: char) -> Seq<String> {
    Seq::empty()
}

spec fn string_to_int(s: &str) -> int {
    0
}

spec fn process_operations(lines: Seq<String>, n: int, m: int, k: int, index: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> (Seq<(int, int)>, Seq<(int, int)>) {
    (Seq::empty(), Seq::empty())
}

spec fn build_grid(n: int, m: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> Seq<Seq<int>> {
    Seq::empty()
}

spec fn format_grid(grid: Seq<Seq<int>>) -> String {
    """".to_string()
}
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures !valid_input(input) ==> result@ == """"@
    ensures valid_input(input) ==> (
        let (n, m, k) = get_dimensions(input);
        let lines = split_lines(input);
        result == format_grid(compute_grid(lines, n, m, k))
    )
// </vc-spec>
// <vc-code>
{
    assume(false);
    """".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 && split_string(&lines[0], ' ').len() == 3 &&
    {
        let n = string_to_int(&split_string(&lines[0], ' ')[0]);
        let m = string_to_int(&split_string(&lines[0], ' ')[1]);
        let k = string_to_int(&split_string(&lines[0], ' ')[2]);
        n > 0 && m > 0 && k >= 0 && lines.len() >= k + 1
    }
}

spec fn get_dimensions(input: &str) -> (int, int, int)
{
    let lines = split_lines(input);
    let first_line = split_string(&lines[0], ' ');
    (string_to_int(&first_line[0]), string_to_int(&first_line[1]), string_to_int(&first_line[2]))
}

spec fn compute_grid(lines: Seq<String>, n: int, m: int, k: int) -> Seq<Seq<int>>
{
    let row = Seq::new(n as nat, |i: int| (0, -1));
    let col = Seq::new(m as nat, |i: int| (0, -1));
    let processed_arrays = process_operations(lines, n, m, k, 0, row, col);
    build_grid(n, m, processed_arrays.0, processed_arrays.1)
}
// </vc-preamble>

// <vc-helpers>
/* Helper functions would be defined here */
spec fn split_lines(input: &str) -> Seq<String> {
    Seq::empty()
}

spec fn split_string(s: &str, delimiter: char) -> Seq<String> {
    Seq::empty()
}

spec fn string_to_int(s: &str) -> int {
    0
}

spec fn process_operations(lines: Seq<String>, n: int, m: int, k: int, index: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> (Seq<(int, int)>, Seq<(int, int)>) {
    (Seq::empty(), Seq::empty())
}

spec fn build_grid(n: int, m: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> Seq<Seq<int>> {
    Seq::empty()
}

spec fn format_grid(grid: Seq<Seq<int>>) -> String {
    """".to_string()
}
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures !valid_input(input) ==> result@ == """"@
    ensures valid_input(input) ==> (
        let (n, m, k) = get_dimensions(input);
        let lines = split_lines(input);
        result == format_grid(compute_grid(lines, n, m, k))
    )
// </vc-spec>
// <vc-code>
{
    assume(false);
    """".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_155.rs,54,54,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int) -> bool {
    n >= 2 && m >= 2 && n % 2 == 0 && k >= 0 && k < n * m
}

spec fn valid_output(result: &Vec<int>, n: int, m: int) -> bool {
    result.len() == 2 && result[0] >= 1 && result[0] <= n && result[1] >= 1 && result[1] <= m
}

spec fn correct_position(result: &Vec<int>, n: int, m: int, k: int) -> bool
    recommends valid_input(n, m, k) && result.len() == 2
{
    if k < n {
        result[0] == k + 1 && result[1] == 1
    } else {
        let k_remaining = k - n;
        let r = n - k_remaining / (m - 1);
        result[0] == r &&
        (r % 2 == 1 ==> result[1] == m - k_remaining % (m - 1)) &&
        (r % 2 == 0 ==> result[1] == 2 + k_remaining % (m - 1))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8) -> (result: Vec<i8>)
    requires
        valid_input(n as int, m as int, k as int)
    ensures
        result.len() == 2,
        {
            let spec_result: Vec<int> = result@.map(|i, x: i8| x as int);
            valid_output(&spec_result, n as int, m as int) && correct_position(&spec_result, n as int, m as int, k as int)
        }
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int) -> bool {
    n >= 2 && m >= 2 && n % 2 == 0 && k >= 0 && k < n * m
}

spec fn valid_output(result: &Vec<int>, n: int, m: int) -> bool {
    result.len() == 2 && result[0] >= 1 && result[0] <= n && result[1] >= 1 && result[1] <= m
}

spec fn correct_position(result: &Vec<int>, n: int, m: int, k: int) -> bool
    recommends valid_input(n, m, k) && result.len() == 2
{
    if k < n {
        result[0] == k + 1 && result[1] == 1
    } else {
        let k_remaining = k - n;
        let r = n - k_remaining / (m - 1);
        result[0] == r &&
        (r % 2 == 1 ==> result[1] == m - k_remaining % (m - 1)) &&
        (r % 2 == 0 ==> result[1] == 2 + k_remaining % (m - 1))
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, k: i8) -> (result: Vec<i8>)
    requires
        valid_input(n as int, m as int, k as int)
    ensures
        result.len() == 2,
        {
            let spec_result: Vec<int> = result@.map(|i, x: i8| x as int);
            valid_output(&spec_result, n as int, m as int) && correct_position(&spec_result, n as int, m as int, k as int)
        }
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1615.rs,103,103,1.0,123.226,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input_format(s: Seq<u8>) -> bool {
    let lines = split_lines(s);
    lines.len() >= 1 &&
    exists|n: nat, k: nat| 
        parses_as_integers_pair(lines[0], n as int, k as int) && n > 0 && k > 0 && lines.len() >= n + 1 &&
        forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i] == lines[i] && 
            exists|a: int, b: int| parses_as_integers_pair(lines[i], a, b)
}

spec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {
    let lines = split_lines(input);
    lines.len() >= n + 1 && segments.len() == n &&
    parses_as_integers_pair(lines[0], n as int, k as int) &&
    forall|i: int| 0 <= i < n && i + 1 < lines.len() ==> #[trigger] segments[i] == segments[i] && 
        parses_as_integers_pair(lines[i + 1], segments[i].0, segments[i].1)
}

spec fn is_valid_output(s: Seq<u8>) -> bool {
    s.len() > 0 && s[s.len() - 1] == 10u8 && 
    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] == s[i] && s[i] != 10u8 &&
    is_numeric_output(s.subrange(0, s.len() - 1))
}

spec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat
    recommends k > 0
{
    let total_coverage = total_coverage(segments);
    let remainder = total_coverage % k;
    if remainder == 0 { 0 } else { (k - remainder) as nat }
}

spec fn total_coverage(segments: Seq<(int, int)>) -> nat
    decreases segments.len()
{
    if segments.len() == 0 { 
        0 
    } else { 
        segment_length(segments[0]) + total_coverage(segments.subrange(1, segments.len() as int))
    }
}

spec fn segment_length(segment: (int, int)) -> nat {
    let max_val = if segment.0 >= segment.1 { segment.0 } else { segment.1 };
    let min_val = if segment.0 <= segment.1 { segment.0 } else { segment.1 };
    if max_val >= min_val { (max_val - min_val + 1) as nat } else { 1 }
}

/* Helper functions that would need to be implemented */
spec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {
    seq![seq![]]
}

spec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {
    true
}

spec fn is_numeric_output(s: Seq<u8>) -> bool {
    true
}

spec fn contains_newline(s: Seq<u8>) -> bool {
    exists|i: int| 0 <= i < s.len() && s[i] == 10u8
}

spec fn int_to_string(n: nat) -> Seq<u8> {
    seq![48u8]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() - 1] == 10u8 || !contains_newline(stdin_input@),
    ensures
        result.len() == 0 || result[result.len() - 1] == 10u8,
        valid_input_format(stdin_input@) ==> 
            exists|n: nat, k: nat, segments: Seq<(int, int)>|
                n > 0 && k > 0 && segments.len() == n &&
                parsed_correctly(stdin_input@, n, k, segments) &&
                result@ == int_to_string(min_moves_to_divisible(segments, k)).add(seq![10u8]),
        valid_input_format(stdin_input@) ==> is_valid_output(result@),
        !valid_input_format(stdin_input@) ==> 
            (result.len() == 0 || (result.len() > 0 && result[result.len() - 1] == 10u8)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input_format(s: Seq<u8>) -> bool {
    let lines = split_lines(s);
    lines.len() >= 1 &&
    exists|n: nat, k: nat| 
        parses_as_integers_pair(lines[0], n as int, k as int) && n > 0 && k > 0 && lines.len() >= n + 1 &&
        forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i] == lines[i] && 
            exists|a: int, b: int| parses_as_integers_pair(lines[i], a, b)
}

spec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {
    let lines = split_lines(input);
    lines.len() >= n + 1 && segments.len() == n &&
    parses_as_integers_pair(lines[0], n as int, k as int) &&
    forall|i: int| 0 <= i < n && i + 1 < lines.len() ==> #[trigger] segments[i] == segments[i] && 
        parses_as_integers_pair(lines[i + 1], segments[i].0, segments[i].1)
}

spec fn is_valid_output(s: Seq<u8>) -> bool {
    s.len() > 0 && s[s.len() - 1] == 10u8 && 
    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] == s[i] && s[i] != 10u8 &&
    is_numeric_output(s.subrange(0, s.len() - 1))
}

spec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat
    recommends k > 0
{
    let total_coverage = total_coverage(segments);
    let remainder = total_coverage % k;
    if remainder == 0 { 0 } else { (k - remainder) as nat }
}

spec fn total_coverage(segments: Seq<(int, int)>) -> nat
    decreases segments.len()
{
    if segments.len() == 0 { 
        0 
    } else { 
        segment_length(segments[0]) + total_coverage(segments.subrange(1, segments.len() as int))
    }
}

spec fn segment_length(segment: (int, int)) -> nat {
    let max_val = if segment.0 >= segment.1 { segment.0 } else { segment.1 };
    let min_val = if segment.0 <= segment.1 { segment.0 } else { segment.1 };
    if max_val >= min_val { (max_val - min_val + 1) as nat } else { 1 }
}

/* Helper functions that would need to be implemented */
spec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {
    seq![seq![]]
}

spec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {
    true
}

spec fn is_numeric_output(s: Seq<u8>) -> bool {
    true
}

spec fn contains_newline(s: Seq<u8>) -> bool {
    exists|i: int| 0 <= i < s.len() && s[i] == 10u8
}

spec fn int_to_string(n: nat) -> Seq<u8> {
    seq![48u8]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() - 1] == 10u8 || !contains_newline(stdin_input@),
    ensures
        result.len() == 0 || result[result.len() - 1] == 10u8,
        valid_input_format(stdin_input@) ==> 
            exists|n: nat, k: nat, segments: Seq<(int, int)>|
                n > 0 && k > 0 && segments.len() == n &&
                parsed_correctly(stdin_input@, n, k, segments) &&
                result@ == int_to_string(min_moves_to_divisible(segments, k)).add(seq![10u8]),
        valid_input_format(stdin_input@) ==> is_valid_output(result@),
        !valid_input_format(stdin_input@) ==> 
            (result.len() == 0 || (result.len() > 0 && result[result.len() - 1] == 10u8)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input_format(s: Seq<u8>) -> bool {\n    let lines = split_lines(s);\n    lines.len() >= 1 &&\n    exists|n: nat, k: nat| \n        parses_as_integers_pair(lines[0], n as int, k as int) && n > 0 && k > 0 && lines.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i] == lines[i] && \n            exists|a: int, b: int| parses_as_integers_pair(lines[i], a, b)\n}\n\nspec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= n + 1 && segments.len() == n &&\n    parses_as_integers_pair(lines[0], n as int, k as int) &&\n    forall|i: int| 0 <= i < n && i + 1 < lines.len() ==> #[trigger] segments[i] == segments[i] && \n        parses_as_integers_pair(lines[i + 1], segments[i].0, segments[i].1)\n}\n\nspec fn is_valid_output(s: Seq<u8>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == 10u8 && \n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] == s[i] && s[i] != 10u8 &&\n    is_numeric_output(s.subrange(0, s.len() - 1))\n}\n\nspec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat\n    recommends k > 0\n{\n    let total_coverage = total_coverage(segments);\n    let remainder = total_coverage % k;\n    if remainder == 0 { 0 } else { (k - remainder) as nat }\n}\n\nspec fn total_coverage(segments: Seq<(int, int)>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { \n        0 \n    } else { \n        segment_length(segments[0]) + total_coverage(segments.subrange(1, segments.len() as int))\n    }\n}\n\nspec fn segment_length(segment: (int, int)) -> nat {\n    let max_val = if segment.0 >= segment.1 { segment.0 } else { segment.1 };\n    let min_val = if segment.0 <= segment.1 { segment.0 } else { segment.1 };\n    if max_val >= min_val { (max_val - min_val + 1) as nat } else { 1 }\n}\n\n/* Helper functions that would need to be implemented */\nspec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {\n    seq![seq![]]\n}\n\nspec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {\n    true\n}\n\nspec fn is_numeric_output(s: Seq<u8>) -> bool {\n    true\n}\n\nspec fn contains_newline(s: Seq<u8>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == 10u8\n}\n\nspec fn int_to_string(n: nat) -> Seq<u8> {\n    seq![48u8]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == 10u8 || !contains_newline(stdin_input@),\n    ensures\n        result.len() == 0 || result[result.len() - 1] == 10u8,\n        valid_input_format(stdin_input@) ==> \n            exists|n: nat, k: nat, segments: Seq<(int, int)>|\n                n > 0 && k > 0 && segments.len() == n &&\n                parsed_correctly(stdin_input@, n, k, segments) &&\n                result@ == int_to_string(min_moves_to_divisible(segments, k)).add(seq![10u8]),\n        valid_input_format(stdin_input@) ==> is_valid_output(result@),\n        !valid_input_format(stdin_input@) ==> \n            (result.len() == 0 || (result.len() > 0 && result[result.len() - 1] == 10u8)),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n           fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_162.rs,51,51,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {
    n >= 1 && k >= 1 && a.len() == n &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1) &&
    (exists|i: int| 0 <= i < a.len() && k % a[i] == 0)
}

spec fn valid_bucket(k: int, bucket_size: int) -> bool {
    bucket_size >= 1 && k % bucket_size == 0
}

spec fn hours_needed(k: int, bucket_size: int) -> int
    recommends valid_bucket(k, bucket_size)
{
    k / bucket_size
}

spec fn is_optimal_choice(k: int, a: Seq<int>, chosen_bucket: int) -> bool {
    0 <= chosen_bucket < a.len() &&
    valid_bucket(k, a[chosen_bucket]) &&
    (forall|i: int| 0 <= i < a.len() && valid_bucket(k, a[i]) ==> a[i] <= a[chosen_bucket])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, a@.map(|i, x| x as int)),
    ensures 
        result >= 1,
        #[trigger] exists|i: int| is_optimal_choice(k as int, a@.map(|i, x| x as int), i) && result as int == hours_needed(k as int, a@.map(|i, x| x as int)[i]),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {
    n >= 1 && k >= 1 && a.len() == n &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1) &&
    (exists|i: int| 0 <= i < a.len() && k % a[i] == 0)
}

spec fn valid_bucket(k: int, bucket_size: int) -> bool {
    bucket_size >= 1 && k % bucket_size == 0
}

spec fn hours_needed(k: int, bucket_size: int) -> int
    recommends valid_bucket(k, bucket_size)
{
    k / bucket_size
}

spec fn is_optimal_choice(k: int, a: Seq<int>, chosen_bucket: int) -> bool {
    0 <= chosen_bucket < a.len() &&
    valid_bucket(k, a[chosen_bucket]) &&
    (forall|i: int| 0 <= i < a.len() && valid_bucket(k, a[i]) ==> a[i] <= a[chosen_bucket])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, a@.map(|i, x| x as int)),
    ensures 
        result >= 1,
        #[trigger] exists|i: int| is_optimal_choice(k as int, a@.map(|i, x| x as int), i) && result as int == hours_needed(k as int, a@.map(|i, x| x as int)[i]),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_163.rs,65,65,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {
    n >= 2 &&
    1 <= k < n &&
    s.len() == n &&
    (exists|i: int| 0 <= i < s.len() && s[i] == 'G') &&
    (exists|i: int| 0 <= i < s.len() && s[i] == 'T') &&
    (forall|i: int| 0 <= i < s.len() ==> (s[i] == 'G' || s[i] == 'T' || s[i] == '.' || s[i] == '#')) &&
    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'G' ==> s[j] != 'G') &&
    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'T' ==> s[j] != 'T')
}

spec fn find_first_g_or_t(s: Seq<char>) -> int
    recommends exists|i: int| 0 <= i < s.len() && (s[i] == 'G' || s[i] == 'T')
    decreases s.len()
{
    if s.len() > 0 && (s[0] == 'G' || s[0] == 'T') {
        0
    } else if s.len() > 1 {
        find_first_g_or_t(s.subrange(1, s.len() as int)) + 1
    } else {
        0
    }
}

spec fn can_reach_target(s: Seq<char>, k: int) -> bool
    recommends k > 0
{
    exists|start: int| 
        0 <= start < s.len() && 
        (s[start] == 'G' || s[start] == 'T') &&
        (forall|j: int| 0 <= j < start ==> !(s[j] == 'G' || s[j] == 'T')) &&
        (exists|final_pos: int| 
            start < final_pos < s.len() &&
            (s[final_pos] == 'G' || s[final_pos] == 'T') &&
            (final_pos - start) % k == 0 &&
            (forall|pos: int| start < pos < final_pos && (pos - start) % k == 0 ==> !(s[pos] == 'G' || s[pos] == 'T' || s[pos] == '#'))
        )
}
// </vc-helpers>

// <vc-spec>
fn solve(n: int, k: int, s: Seq<char>) -> (result: Seq<char>)
    requires valid_input(n, k, s)
    ensures 
        result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O'],
        (result == seq!['Y', 'E', 'S']) <==> can_reach_target(s, k)
// </vc-spec>
// <vc-code>
{
    assume(false);
    seq!['N', 'O']
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {
    n >= 2 &&
    1 <= k < n &&
    s.len() == n &&
    (exists|i: int| 0 <= i < s.len() && s[i] == 'G') &&
    (exists|i: int| 0 <= i < s.len() && s[i] == 'T') &&
    (forall|i: int| 0 <= i < s.len() ==> (s[i] == 'G' || s[i] == 'T' || s[i] == '.' || s[i] == '#')) &&
    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'G' ==> s[j] != 'G') &&
    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'T' ==> s[j] != 'T')
}

spec fn find_first_g_or_t(s: Seq<char>) -> int
    recommends exists|i: int| 0 <= i < s.len() && (s[i] == 'G' || s[i] == 'T')
    decreases s.len()
{
    if s.len() > 0 && (s[0] == 'G' || s[0] == 'T') {
        0
    } else if s.len() > 1 {
        find_first_g_or_t(s.subrange(1, s.len() as int)) + 1
    } else {
        0
    }
}

spec fn can_reach_target(s: Seq<char>, k: int) -> bool
    recommends k > 0
{
    exists|start: int| 
        0 <= start < s.len() && 
        (s[start] == 'G' || s[start] == 'T') &&
        (forall|j: int| 0 <= j < start ==> !(s[j] == 'G' || s[j] == 'T')) &&
        (exists|final_pos: int| 
            start < final_pos < s.len() &&
            (s[final_pos] == 'G' || s[final_pos] == 'T') &&
            (final_pos - start) % k == 0 &&
            (forall|pos: int| start < pos < final_pos && (pos - start) % k == 0 ==> !(s[pos] == 'G' || s[pos] == 'T' || s[pos] == '#'))
        )
}
// </vc-helpers>

// <vc-spec>
fn solve(n: int, k: int, s: Seq<char>) -> (result: Seq<char>)
    requires valid_input(n, k, s)
    ensures 
        result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O'],
        (result == seq!['Y', 'E', 'S']) <==> can_reach_target(s, k)
// </vc-spec>
// <vc-code>
{
    assume(false);
    seq!['N', 'O']
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1631.rs,92,92,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(stdin_input: Seq<char>, n: int) -> bool {
    exists|lines: Seq<Seq<char>>| (parse_input(stdin_input) == lines &&
    lines.len() >= 1 &&
    lines.len() == n + 1 &&
    parse_int(lines[0]) == n &&
    n >= 1 && n <= 100 &&
    (forall|i: int| 1 <= i < lines.len() ==> 
        1 <= lines[i].len() <= 100 && 
        forall|j: int| 0 <= j < lines[i].len() ==> 'a' <= lines[i][j] <= 'z'))
}

spec fn valid_alphabet_ordering(stdin_input: Seq<char>, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]
{
    exists|lines: Seq<Seq<char>>, n: int| (parse_input(stdin_input) == lines &&
    lines.len() >= 1 &&
    lines.len() == n + 1 &&
    parse_int(lines[0]) == n &&
    (forall|i: int| 1 <= i < n ==> lexicographically_less_or_equal(lines[i], lines[i+1], alphabet)))
}

spec fn lexicographically_less_or_equal(s1: Seq<char>, s2: Seq<char>, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]
{
    if s1 == s2 {
        true
    } else if s1.len() <= s2.len() && s1 == s2.subrange(0, s1.len() as int) {
        true
    } else if s2.len() < s1.len() && s2 == s1.subrange(0, s2.len() as int) {
        false
    } else {
        exists|i: int| (0 <= i < s1.len() && i < s2.len() && s1[i] != s2[i] &&
        (forall|j: int| 0 <= j < i ==> s1[j] == s2[j]) &&
        'a' <= s1[i] <= 'z' && 'a' <= s2[i] <= 'z' &&
        alphabet_order(s1[i], s2[i], alphabet))
    }
}

spec fn alphabet_order(c1: char, c2: char, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j],
              'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'
{
    exists|i: int, j: int| 0 <= i < j < alphabet.len() && alphabet[i] == c1 && alphabet[j] == c2
}

spec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>
{
    Seq::<Seq<char>>::empty()
}

spec fn parse_int(s: Seq<char>) -> int
{
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: String)
    requires
        stdin_input@.len() > 0,
        exists|n: int| n >= 1 && valid_input(stdin_input@, n),
    ensures
        result@ == ""Impossible""@ || (result@.len() == 26 && forall|i: int| 0 <= i < result@.len() ==> 'a' <= result@[i] <= 'z'),
        result@ != ""Impossible""@ ==> (forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] != result@[j]),
        result@ != ""Impossible""@ ==> valid_alphabet_ordering(stdin_input@, result@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""Impossible"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(stdin_input: Seq<char>, n: int) -> bool {
    exists|lines: Seq<Seq<char>>| (parse_input(stdin_input) == lines &&
    lines.len() >= 1 &&
    lines.len() == n + 1 &&
    parse_int(lines[0]) == n &&
    n >= 1 && n <= 100 &&
    (forall|i: int| 1 <= i < lines.len() ==> 
        1 <= lines[i].len() <= 100 && 
        forall|j: int| 0 <= j < lines[i].len() ==> 'a' <= lines[i][j] <= 'z'))
}

spec fn valid_alphabet_ordering(stdin_input: Seq<char>, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]
{
    exists|lines: Seq<Seq<char>>, n: int| (parse_input(stdin_input) == lines &&
    lines.len() >= 1 &&
    lines.len() == n + 1 &&
    parse_int(lines[0]) == n &&
    (forall|i: int| 1 <= i < n ==> lexicographically_less_or_equal(lines[i], lines[i+1], alphabet)))
}

spec fn lexicographically_less_or_equal(s1: Seq<char>, s2: Seq<char>, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]
{
    if s1 == s2 {
        true
    } else if s1.len() <= s2.len() && s1 == s2.subrange(0, s1.len() as int) {
        true
    } else if s2.len() < s1.len() && s2 == s1.subrange(0, s2.len() as int) {
        false
    } else {
        exists|i: int| (0 <= i < s1.len() && i < s2.len() && s1[i] != s2[i] &&
        (forall|j: int| 0 <= j < i ==> s1[j] == s2[j]) &&
        'a' <= s1[i] <= 'z' && 'a' <= s2[i] <= 'z' &&
        alphabet_order(s1[i], s2[i], alphabet))
    }
}

spec fn alphabet_order(c1: char, c2: char, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j],
              'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'
{
    exists|i: int, j: int| 0 <= i < j < alphabet.len() && alphabet[i] == c1 && alphabet[j] == c2
}

spec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>
{
    Seq::<Seq<char>>::empty()
}

spec fn parse_int(s: Seq<char>) -> int
{
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: String)
    requires
        stdin_input@.len() > 0,
        exists|n: int| n >= 1 && valid_input(stdin_input@, n),
    ensures
        result@ == ""Impossible""@ || (result@.len() == 26 && forall|i: int| 0 <= i < result@.len() ==> 'a' <= result@[i] <= 'z'),
        result@ != ""Impossible""@ ==> (forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] != result@[j]),
        result@ != ""Impossible""@ ==> valid_alphabet_ordering(stdin_input@, result@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""Impossible"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1634.rs,91,91,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_costs(c: &[int]) -> bool {
  c.len() == 4 &&
  c[0] >= 1 && c[1] >= 1 && c[2] >= 1 && c[3] >= 1 &&
  c[0] <= 1000 && c[1] <= 1000 && c[2] <= 1000 && c[3] <= 1000
}

spec fn valid_rides(rides: &[int]) -> bool {
  rides.len() >= 1 && rides.len() <= 1000 &&
  forall|i: int| #![trigger rides[i]] 0 <= i < rides.len() ==> 0 <= rides[i] <= 1000
}

spec fn sum_array(arr: Seq<int>) -> int
  decreases arr.len(),
{
  if arr.len() == 0 { 
    0 
  } else { 
    arr[0] + sum_array(arr.drop_first()) 
  }
}

spec fn optimized_cost(rides: Seq<int>, individual_cost: int, unlimited_cost: int) -> int {
  let initial_cost = sum_array(rides) * individual_cost;
  min_with_unlimited(rides, initial_cost, individual_cost, unlimited_cost, 0)
}

spec fn min_with_unlimited(rides: Seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int) -> int
  decreases rides.len() - index,
{
  if index >= rides.len() { 
    current_cost 
  } else {
    let new_cost = current_cost - rides[index] * individual_cost + unlimited_cost;
    let updated_cost = if new_cost < current_cost && new_cost >= 0 { new_cost } else { current_cost };
    min_with_unlimited(rides, updated_cost, individual_cost, unlimited_cost, index + 1)
  }
}

spec fn min5(a: int, b: int, c: int, d: int, e: int) -> int {
  let min_ab = if a <= b { a } else { b };
  let min_cd = if c <= d { c } else { d };
  let min_abcd = if min_ab <= min_cd { min_ab } else { min_cd };
  if min_abcd <= e { min_abcd } else { e }
}

spec fn correct_result(c: &[int], a: &[int], b: &[int], result: int) -> bool {
  result == min5(optimized_cost(a@, c[0], c[1]) + optimized_cost(b@, c[0], c[1]),
                 optimized_cost(a@, c[0], c[1]) + c[2],
                 optimized_cost(b@, c[0], c[1]) + c[2],
                 c[2] + c[2],
                 c[3])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(c: &Vec<i8>, a: &Vec<i8>, b: &Vec<i8>) -> (result: i8)
  requires 
    c.len() == 4,
    c@[0] as int >= 1 && c@[1] as int >= 1 && c@[2] as int >= 1 && c@[3] as int >= 1,
    c@[0] as int <= 1000 && c@[1] as int <= 1000 && c@[2] as int <= 1000 && c@[3] as int <= 1000,
    a.len() >= 1 && a.len() <= 1000,
    b.len() >= 1 && b.len() <= 1000,
    forall|i: int| #![trigger a@[i]] 0 <= i < a.len() ==> 0 <= a@[i] as int <= 1000,
    forall|i: int| #![trigger b@[i]] 0 <= i < b.len() ==> 0 <= b@[i] as int <= 1000,
  ensures 
    result >= 0,
    result as int <= min5(sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int), 
                  sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),
                  sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),
                  (c@[2] as int) + (c@[2] as int),
                  c@[3] as int),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_costs(c: &[int]) -> bool {
  c.len() == 4 &&
  c[0] >= 1 && c[1] >= 1 && c[2] >= 1 && c[3] >= 1 &&
  c[0] <= 1000 && c[1] <= 1000 && c[2] <= 1000 && c[3] <= 1000
}

spec fn valid_rides(rides: &[int]) -> bool {
  rides.len() >= 1 && rides.len() <= 1000 &&
  forall|i: int| #![trigger rides[i]] 0 <= i < rides.len() ==> 0 <= rides[i] <= 1000
}

spec fn sum_array(arr: Seq<int>) -> int
  decreases arr.len(),
{
  if arr.len() == 0 { 
    0 
  } else { 
    arr[0] + sum_array(arr.drop_first()) 
  }
}

spec fn optimized_cost(rides: Seq<int>, individual_cost: int, unlimited_cost: int) -> int {
  let initial_cost = sum_array(rides) * individual_cost;
  min_with_unlimited(rides, initial_cost, individual_cost, unlimited_cost, 0)
}

spec fn min_with_unlimited(rides: Seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int) -> int
  decreases rides.len() - index,
{
  if index >= rides.len() { 
    current_cost 
  } else {
    let new_cost = current_cost - rides[index] * individual_cost + unlimited_cost;
    let updated_cost = if new_cost < current_cost && new_cost >= 0 { new_cost } else { current_cost };
    min_with_unlimited(rides, updated_cost, individual_cost, unlimited_cost, index + 1)
  }
}

spec fn min5(a: int, b: int, c: int, d: int, e: int) -> int {
  let min_ab = if a <= b { a } else { b };
  let min_cd = if c <= d { c } else { d };
  let min_abcd = if min_ab <= min_cd { min_ab } else { min_cd };
  if min_abcd <= e { min_abcd } else { e }
}

spec fn correct_result(c: &[int], a: &[int], b: &[int], result: int) -> bool {
  result == min5(optimized_cost(a@, c[0], c[1]) + optimized_cost(b@, c[0], c[1]),
                 optimized_cost(a@, c[0], c[1]) + c[2],
                 optimized_cost(b@, c[0], c[1]) + c[2],
                 c[2] + c[2],
                 c[3])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(c: &Vec<i8>, a: &Vec<i8>, b: &Vec<i8>) -> (result: i8)
  requires 
    c.len() == 4,
    c@[0] as int >= 1 && c@[1] as int >= 1 && c@[2] as int >= 1 && c@[3] as int >= 1,
    c@[0] as int <= 1000 && c@[1] as int <= 1000 && c@[2] as int <= 1000 && c@[3] as int <= 1000,
    a.len() >= 1 && a.len() <= 1000,
    b.len() >= 1 && b.len() <= 1000,
    forall|i: int| #![trigger a@[i]] 0 <= i < a.len() ==> 0 <= a@[i] as int <= 1000,
    forall|i: int| #![trigger b@[i]] 0 <= i < b.len() ==> 0 <= b@[i] as int <= 1000,
  ensures 
    result >= 0,
    result as int <= min5(sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int), 
                  sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),
                  sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),
                  (c@[2] as int) + (c@[2] as int),
                  c@[3] as int),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1661.rs,50,50,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_buyable_games(games: Seq<int>, bills: Seq<int>) -> int
    decreases games.len()
{
    if games.len() == 0 {
        0
    } else if bills.len() == 0 {
        0
    } else if bills[0] >= games[0] {
        1 + count_buyable_games(games.subrange(1, games.len() as int), bills.subrange(1, bills.len() as int))
    } else {
        count_buyable_games(games.subrange(1, games.len() as int), bills)
    }
}

spec fn valid_input(n: int, m: int, games: Seq<int>, bills: Seq<int>) -> bool {
    n >= 1 && m >= 1 &&
    games.len() == n && bills.len() == m &&
    (forall|i: int| 0 <= i < games.len() ==> #[trigger] games[i] >= 1 && #[trigger] games[i] <= 1000) &&
    (forall|i: int| 0 <= i < bills.len() ==> #[trigger] bills[i] >= 1 && #[trigger] bills[i] <= 1000)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, games: Vec<i8>, bills: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),
    ensures 
        0 <= result as int <= n as int,
        result as int <= m as int,
        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn count_buyable_games(games: Seq<int>, bills: Seq<int>) -> int
    decreases games.len()
{
    if games.len() == 0 {
        0
    } else if bills.len() == 0 {
        0
    } else if bills[0] >= games[0] {
        1 + count_buyable_games(games.subrange(1, games.len() as int), bills.subrange(1, bills.len() as int))
    } else {
        count_buyable_games(games.subrange(1, games.len() as int), bills)
    }
}

spec fn valid_input(n: int, m: int, games: Seq<int>, bills: Seq<int>) -> bool {
    n >= 1 && m >= 1 &&
    games.len() == n && bills.len() == m &&
    (forall|i: int| 0 <= i < games.len() ==> #[trigger] games[i] >= 1 && #[trigger] games[i] <= 1000) &&
    (forall|i: int| 0 <= i < bills.len() ==> #[trigger] bills[i] >= 1 && #[trigger] bills[i] <= 1000)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, games: Vec<i8>, bills: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),
    ensures 
        0 <= result as int <= n as int,
        result as int <= m as int,
        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1684.rs,66,66,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
pub struct InputData {
    pub n: int,
    pub m: int,
    pub segments: Set<(int, int)>,
}

spec fn valid_input_format(stdin_input: &str) -> bool {
    stdin_input.len() > 0
}

spec fn parse_input(stdin_input: &str) -> InputData
    requires valid_input_format(stdin_input)
{
    InputData {
        n: 2,
        m: 0,
        segments: Set::empty(),
    }
}

spec fn rotate_segment(seg: (int, int), k: int, n: int) -> (int, int)
    requires 1 <= seg.0 <= n && 1 <= seg.1 <= n && k >= 0 && n > 0
{
    let temp_a = (seg.0 + k) % n;
    let a = if temp_a == 0 { n } else { temp_a };
    let temp_b = (seg.1 + k) % n;
    let b = if temp_b == 0 { n } else { temp_b };
    (a, b)
}

spec fn exists_rotational_symmetry(data: InputData) -> bool {
    exists|k: int| 1 <= k < data.n && 
        data.n % k == 0 &&
        (forall|seg: (int, int)| data.segments.contains(seg) ==> 
            seg.0 >= 1 && seg.0 <= data.n && seg.1 >= 1 && seg.1 <= data.n &&
            data.segments.contains(rotate_segment(seg, k, data.n)))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0
    requires valid_input_format(stdin_input)
    ensures result == ""Yes"" || result == ""No""
    ensures (result == ""Yes"") == exists_rotational_symmetry(parse_input(stdin_input))
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
pub struct InputData {
    pub n: int,
    pub m: int,
    pub segments: Set<(int, int)>,
}

spec fn valid_input_format(stdin_input: &str) -> bool {
    stdin_input.len() > 0
}

spec fn parse_input(stdin_input: &str) -> InputData
    requires valid_input_format(stdin_input)
{
    InputData {
        n: 2,
        m: 0,
        segments: Set::empty(),
    }
}

spec fn rotate_segment(seg: (int, int), k: int, n: int) -> (int, int)
    requires 1 <= seg.0 <= n && 1 <= seg.1 <= n && k >= 0 && n > 0
{
    let temp_a = (seg.0 + k) % n;
    let a = if temp_a == 0 { n } else { temp_a };
    let temp_b = (seg.1 + k) % n;
    let b = if temp_b == 0 { n } else { temp_b };
    (a, b)
}

spec fn exists_rotational_symmetry(data: InputData) -> bool {
    exists|k: int| 1 <= k < data.n && 
        data.n % k == 0 &&
        (forall|seg: (int, int)| data.segments.contains(seg) ==> 
            seg.0 >= 1 && seg.0 <= data.n && seg.1 >= 1 && seg.1 <= data.n &&
            data.segments.contains(rotate_segment(seg, k, data.n)))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0
    requires valid_input_format(stdin_input)
    ensures result == ""Yes"" || result == ""No""
    ensures (result == ""Yes"") == exists_rotational_symmetry(parse_input(stdin_input))
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No"".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1724.rs,62,62,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: int, a: Seq<int>, k: Seq<char>) -> bool {
  n >= 1 && a.len() == n && k.len() == n && 
  (forall|i: int| 0 <= i < n ==> a[i] >= 0) &&
  is_binary_string(k)
}

spec fn is_binary_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn pow(base: int, exp: int) -> int
  decreases exp
{
  if exp == 0 { 1 }
  else if exp > 0 { base * pow(base, exp - 1) }
  else { 1 }
}

spec fn binary_string_to_int(s: Seq<char>) -> int
  requires is_binary_string(s)
  ensures binary_string_to_int(s) >= 0
  decreases s.len()
{
  if s.len() == 0 { 0 }
  else { (if s[0] == '1' { 1 } else { 0 }) * pow(2, s.len() as int - 1) + binary_string_to_int(s.subrange(1, s.len() as int)) }
}

spec fn f(a: Seq<int>, x: int, n: int) -> int
  requires n >= 0 && a.len() == n
  ensures (forall|i: int| 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0
  decreases n
{
  if n == 0 { 0 }
  else { (if (x / pow(2, n-1)) % 2 == 1 { a[n-1] } else { 0 }) + f(a.subrange(0, n-1), x % pow(2, n-1), n-1) }
}
// </vc-helpers>

// <vc-spec>
fn solve(n: int, a: Seq<int>, k: Seq<char>) -> (result: int)
  requires valid_input(n, a, k)
  ensures result >= 0,
  ensures exists|x: int| 0 <= x <= binary_string_to_int(k) && result == f(a, x, n),
  ensures forall|x: int| 0 <= x <= binary_string_to_int(k) ==> f(a, x, n) <= result
// </vc-spec>
// <vc-code>
{
  assume(false);
  0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: int, a: Seq<int>, k: Seq<char>) -> bool {
  n >= 1 && a.len() == n && k.len() == n && 
  (forall|i: int| 0 <= i < n ==> a[i] >= 0) &&
  is_binary_string(k)
}

spec fn is_binary_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn pow(base: int, exp: int) -> int
  decreases exp
{
  if exp == 0 { 1 }
  else if exp > 0 { base * pow(base, exp - 1) }
  else { 1 }
}

spec fn binary_string_to_int(s: Seq<char>) -> int
  requires is_binary_string(s)
  ensures binary_string_to_int(s) >= 0
  decreases s.len()
{
  if s.len() == 0 { 0 }
  else { (if s[0] == '1' { 1 } else { 0 }) * pow(2, s.len() as int - 1) + binary_string_to_int(s.subrange(1, s.len() as int)) }
}

spec fn f(a: Seq<int>, x: int, n: int) -> int
  requires n >= 0 && a.len() == n
  ensures (forall|i: int| 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0
  decreases n
{
  if n == 0 { 0 }
  else { (if (x / pow(2, n-1)) % 2 == 1 { a[n-1] } else { 0 }) + f(a.subrange(0, n-1), x % pow(2, n-1), n-1) }
}
// </vc-helpers>

// <vc-spec>
fn solve(n: int, a: Seq<int>, k: Seq<char>) -> (result: int)
  requires valid_input(n, a, k)
  ensures result >= 0,
  ensures exists|x: int| 0 <= x <= binary_string_to_int(k) && result == f(a, x, n),
  ensures forall|x: int| 0 <= x <= binary_string_to_int(k) ==> f(a, x, n) <= result
// </vc-spec>
// <vc-code>
{
  assume(false);
  0
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1745.rs,67,67,1.0,122.279,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.index(input.len() - 1) == '\n'
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 && output.index(output.len() - 1) == '\n'
}

spec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {
    (seq![], 0, 0)
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn find_newline(s: Seq<char>, start: int) -> int {
    -1
}

spec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {
    grid.len() == rows &&
    rows >= 0 && cols >= 0 &&
    (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&
    (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> 
        grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')
}

spec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {
    i == 0 || i == rows - 1 || j == 0 || j == cols - 1
}

spec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {
    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||
    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)
}

spec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)
    requires valid_input(input)
    ensures valid_output(output)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.index(input.len() - 1) == '\n'
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 && output.index(output.len() - 1) == '\n'
}

spec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {
    (seq![], 0, 0)
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn find_newline(s: Seq<char>, start: int) -> int {
    -1
}

spec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {
    grid.len() == rows &&
    rows >= 0 && cols >= 0 &&
    (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&
    (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> 
        grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')
}

spec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {
    i == 0 || i == rows - 1 || j == 0 || j == cols - 1
}

spec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {
    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||
    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)
}

spec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)
    requires valid_input(input)
    ensures valid_output(output)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.index(input.len() - 1) == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output.index(output.len() - 1) == '\\n'\n}\n\nspec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {\n    (seq![], 0, 0)\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn find_newline(s: Seq<char>, start: int) -> int {\n    -1\n}\n\nspec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {\n    grid.len() == rows &&\n    rows >= 0 && cols >= 0 &&\n    (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&\n    (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> \n        grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')\n}\n\nspec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    i == 0 || i == rows - 1 || j == 0 || j == cols - 1\n}\n\nspec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||\n    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)\n}\n\nspec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(output)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1780.rs,122,122,1.0,92.546,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['0']]
}

spec fn extract_m_from_line(line: Seq<char>) -> int {
    0
}

spec fn extract_n(line: Seq<char>) -> int {
    0
}

spec fn extract_m(input: Seq<char>) -> int {
    0
}

spec fn extract_query(line: Seq<char>) -> (int, int) {
    (0, 0)
}

spec fn count_ones(line: Seq<char>) -> int {
    0
}

spec fn count_dashes(line: Seq<char>) -> int {
    0
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {
    seq!['0']
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 &&
    contains_valid_first_line(lines[0]) &&
    contains_valid_second_line(lines[1]) &&
    lines.len() == 2 + extract_m_from_line(lines[0]) &&
    (forall|i: int| 2 <= i < lines.len() ==> contains_valid_query(lines[i])) &&
    extract_n(lines[0]) == lines[1].len()
}

spec fn contains_valid_first_line(line: Seq<char>) -> bool {
    true
}

spec fn contains_valid_second_line(line: Seq<char>) -> bool {
    line.len() >= 0 &&
    forall|i: int| 0 <= i < line.len() ==> line[i] == '1' || line[i] == '-'
}

spec fn contains_valid_query(line: Seq<char>) -> bool {
    true
}

spec fn compute_correct_result(input: Seq<char>) -> Seq<char> {
    let lines = split_lines(input);
    let first_line = lines[0];
    let n = extract_n(first_line);
    let m = extract_m(input);
    let array_line = lines[1];
    let positives = count_ones(array_line);
    let negatives = count_dashes(array_line);
    let max_balanceable = 2 * min(positives, negatives);

    let outputs: Seq<Seq<char>> = Seq::new(m as nat, |i: int| {
        let query = extract_query(lines[i + 2]);
        let l = query.0;
        let r = query.1;
        let range_length = r - l + 1;
        if range_length % 2 == 0 && range_length <= max_balanceable {
            seq!['1']
        } else {
            seq!['0']
        }
    });

    join_with_newlines(outputs)
}

spec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {
    s.len() == 0 || (s.len() > 0 && s[s.len() - 1] == '\n')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        valid_input(stdin_input),
    ensures
        result.len() >= 0,
        result == compute_correct_result(stdin_input),
        forall|line: Seq<char>| split_lines(result).contains(line) ==> line == seq!['0'] || line == seq!['1'],
        split_lines(result).len() == extract_m(stdin_input),
        ends_with_newline_if_non_empty(result),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['0']]
}

spec fn extract_m_from_line(line: Seq<char>) -> int {
    0
}

spec fn extract_n(line: Seq<char>) -> int {
    0
}

spec fn extract_m(input: Seq<char>) -> int {
    0
}

spec fn extract_query(line: Seq<char>) -> (int, int) {
    (0, 0)
}

spec fn count_ones(line: Seq<char>) -> int {
    0
}

spec fn count_dashes(line: Seq<char>) -> int {
    0
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {
    seq!['0']
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 &&
    contains_valid_first_line(lines[0]) &&
    contains_valid_second_line(lines[1]) &&
    lines.len() == 2 + extract_m_from_line(lines[0]) &&
    (forall|i: int| 2 <= i < lines.len() ==> contains_valid_query(lines[i])) &&
    extract_n(lines[0]) == lines[1].len()
}

spec fn contains_valid_first_line(line: Seq<char>) -> bool {
    true
}

spec fn contains_valid_second_line(line: Seq<char>) -> bool {
    line.len() >= 0 &&
    forall|i: int| 0 <= i < line.len() ==> line[i] == '1' || line[i] == '-'
}

spec fn contains_valid_query(line: Seq<char>) -> bool {
    true
}

spec fn compute_correct_result(input: Seq<char>) -> Seq<char> {
    let lines = split_lines(input);
    let first_line = lines[0];
    let n = extract_n(first_line);
    let m = extract_m(input);
    let array_line = lines[1];
    let positives = count_ones(array_line);
    let negatives = count_dashes(array_line);
    let max_balanceable = 2 * min(positives, negatives);

    let outputs: Seq<Seq<char>> = Seq::new(m as nat, |i: int| {
        let query = extract_query(lines[i + 2]);
        let l = query.0;
        let r = query.1;
        let range_length = r - l + 1;
        if range_length % 2 == 0 && range_length <= max_balanceable {
            seq!['1']
        } else {
            seq!['0']
        }
    });

    join_with_newlines(outputs)
}

spec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {
    s.len() == 0 || (s.len() > 0 && s[s.len() - 1] == '\n')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        valid_input(stdin_input),
    ensures
        result.len() >= 0,
        result == compute_correct_result(stdin_input),
        forall|line: Seq<char>| split_lines(result).contains(line) ==> line == seq!['0'] || line == seq!['1'],
        split_lines(result).len() == extract_m(stdin_input),
        ends_with_newline_if_non_empty(result),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['0']]\n}\n\nspec fn extract_m_from_line(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_n(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_query(line: Seq<char>) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_ones(line: Seq<char>) -> int {\n    0\n}\n\nspec fn count_dashes(line: Seq<char>) -> int {\n    0\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    contains_valid_first_line(lines[0]) &&\n    contains_valid_second_line(lines[1]) &&\n    lines.len() == 2 + extract_m_from_line(lines[0]) &&\n    (forall|i: int| 2 <= i < lines.len() ==> contains_valid_query(lines[i])) &&\n    extract_n(lines[0]) == lines[1].len()\n}\n\nspec fn contains_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn contains_valid_second_line(line: Seq<char>) -> bool {\n    line.len() >= 0 &&\n    forall|i: int| 0 <= i < line.len() ==> line[i] == '1' || line[i] == '-'\n}\n\nspec fn contains_valid_query(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn compute_correct_result(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let first_line = lines[0];\n    let n = extract_n(first_line);\n    let m = extract_m(input);\n    let array_line = lines[1];\n    let positives = count_ones(array_line);\n    let negatives = count_dashes(array_line);\n    let max_balanceable = 2 * min(positives, negatives);\n\n    let outputs: Seq<Seq<char>> = Seq::new(m as nat, |i: int| {\n        let query = extract_query(lines[i + 2]);\n        let l = query.0;\n        let r = query.1;\n        let range_length = r - l + 1;\n        if range_length % 2 == 0 && range_length <= max_balanceable {\n            seq!['1']\n        } else {\n            seq!['0']\n        }\n    });\n\n    join_with_newlines(outputs)\n}\n\nspec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {\n    s.len() == 0 || (s.len() > 0 && s[s.len() - 1] == '\\n')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        result == compute_correct_result(stdin_input),\n        forall|line: Seq<char>| split_lines(result).contains(line) ==> line == seq!['0'] || line == seq!['1'],\n        split_lines(result).len() == extract_m(stdin_input),\n        ends_with_newline_if_non_empty(result),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1824.rs,133,133,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_by_newline(input);
    lines.len() >= 4 && 
    is_valid_integer(lines[0]) &&
    string_to_int(lines[0]) >= 3 &&
    split_by_space(lines[1]).len() == string_to_int(lines[0]) &&
    split_by_space(lines[2]).len() == string_to_int(lines[0]) - 1 &&
    split_by_space(lines[3]).len() == string_to_int(lines[0]) - 2 &&
    (forall|i: int| 0 <= i < split_by_space(lines[1]).len() ==> is_valid_integer(split_by_space(lines[1])[i])) &&
    (forall|i: int| 0 <= i < split_by_space(lines[2]).len() ==> is_valid_integer(split_by_space(lines[2])[i])) &&
    (forall|i: int| 0 <= i < split_by_space(lines[3]).len() ==> is_valid_integer(split_by_space(lines[3])[i]))
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (s[0] == '-' ==> s.len() > 1) && 
    (forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9')
}

spec fn get_first_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let first_line = split_by_space(lines[1]);
    sum_sequence(first_line)
}

spec fn get_second_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let second_line = split_by_space(lines[2]);
    sum_sequence(second_line)
}

spec fn get_third_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let third_line = split_by_space(lines[3]);
    sum_sequence(third_line)
}

spec fn sum_sequence(numbers: Seq<Seq<char>>) -> int
    decreases numbers.len()
{
    if numbers.len() == 0 { 0 }
    else { string_to_int(numbers[0]) + sum_sequence(numbers.drop_first()) }
}

spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else if s[0] == '\n' { split_by_newline(s.drop_first()) }
    else {
        let rest = split_by_newline(s.drop_first());
        if rest.len() == 0 { seq![s] }
        else { seq![seq![s[0]].add(rest[0])].add(rest.drop_first()) }
    }
}

spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>> {
    split_by_char(s, ' ')
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else {
        let pos = find_char(s, delimiter, 0);
        if pos == -1 { seq![s] }
        else if pos == 0 { split_by_char(s.drop_first(), delimiter) }
        else { seq![s.take(pos)].add(split_by_char(s.skip(pos + 1), delimiter)) }
    }
}

spec fn find_char(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start] == c { start }
    else { find_char(s, c, start + 1) }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s[0] == '-' { -string_to_int_helper(s.drop_first(), 0) }
    else { string_to_int_helper(s, 0) }
}

spec fn string_to_int_helper(s: Seq<char>, acc: int) -> int
    decreases s.len()
{
    if s.len() == 0 { acc }
    else if '0' <= s[0] <= '9' {
        string_to_int_helper(s.drop_first(), acc * 10 + (s[0] as int - '0' as int))
    } else { acc }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'].add(int_to_string_helper(-n)) }
    else { int_to_string_helper(n) }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n
{
    if n == 0 { seq![] }
    else { int_to_string_helper(n / 10).add(seq![((n % 10) + '0' as int) as char]) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    requires valid_input(input@)
    ensures result@ == int_to_string(get_first_sum(input@) - get_second_sum(input@)).add(seq!['\n']).add(int_to_string(get_second_sum(input@) - get_third_sum(input@))).add(seq!['\n'])
// </vc-spec>
// <vc-code>
{
    assume(false);
    String::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_by_newline(input);
    lines.len() >= 4 && 
    is_valid_integer(lines[0]) &&
    string_to_int(lines[0]) >= 3 &&
    split_by_space(lines[1]).len() == string_to_int(lines[0]) &&
    split_by_space(lines[2]).len() == string_to_int(lines[0]) - 1 &&
    split_by_space(lines[3]).len() == string_to_int(lines[0]) - 2 &&
    (forall|i: int| 0 <= i < split_by_space(lines[1]).len() ==> is_valid_integer(split_by_space(lines[1])[i])) &&
    (forall|i: int| 0 <= i < split_by_space(lines[2]).len() ==> is_valid_integer(split_by_space(lines[2])[i])) &&
    (forall|i: int| 0 <= i < split_by_space(lines[3]).len() ==> is_valid_integer(split_by_space(lines[3])[i]))
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (s[0] == '-' ==> s.len() > 1) && 
    (forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9')
}

spec fn get_first_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let first_line = split_by_space(lines[1]);
    sum_sequence(first_line)
}

spec fn get_second_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let second_line = split_by_space(lines[2]);
    sum_sequence(second_line)
}

spec fn get_third_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let third_line = split_by_space(lines[3]);
    sum_sequence(third_line)
}

spec fn sum_sequence(numbers: Seq<Seq<char>>) -> int
    decreases numbers.len()
{
    if numbers.len() == 0 { 0 }
    else { string_to_int(numbers[0]) + sum_sequence(numbers.drop_first()) }
}

spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else if s[0] == '\n' { split_by_newline(s.drop_first()) }
    else {
        let rest = split_by_newline(s.drop_first());
        if rest.len() == 0 { seq![s] }
        else { seq![seq![s[0]].add(rest[0])].add(rest.drop_first()) }
    }
}

spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>> {
    split_by_char(s, ' ')
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else {
        let pos = find_char(s, delimiter, 0);
        if pos == -1 { seq![s] }
        else if pos == 0 { split_by_char(s.drop_first(), delimiter) }
        else { seq![s.take(pos)].add(split_by_char(s.skip(pos + 1), delimiter)) }
    }
}

spec fn find_char(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start] == c { start }
    else { find_char(s, c, start + 1) }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s[0] == '-' { -string_to_int_helper(s.drop_first(), 0) }
    else { string_to_int_helper(s, 0) }
}

spec fn string_to_int_helper(s: Seq<char>, acc: int) -> int
    decreases s.len()
{
    if s.len() == 0 { acc }
    else if '0' <= s[0] <= '9' {
        string_to_int_helper(s.drop_first(), acc * 10 + (s[0] as int - '0' as int))
    } else { acc }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'].add(int_to_string_helper(-n)) }
    else { int_to_string_helper(n) }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n
{
    if n == 0 { seq![] }
    else { int_to_string_helper(n / 10).add(seq![((n % 10) + '0' as int) as char]) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    requires valid_input(input@)
    ensures result@ == int_to_string(get_first_sum(input@) - get_second_sum(input@)).add(seq!['\n']).add(int_to_string(get_second_sum(input@) - get_third_sum(input@))).add(seq!['\n'])
// </vc-spec>
// <vc-code>
{
    assume(false);
    String::new()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1835.rs,83,83,1.0,92.165,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    true
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn count_test_cases(input: Seq<char>) -> nat
    recommends valid_input_format(input)
{
    1
}

spec fn count_lines(s: Seq<char>) -> nat {
    1
}

spec fn get_line(s: Seq<char>, i: nat) -> Seq<char>
    recommends i < count_lines(s)
{
    seq!['1']
}

spec fn get_string_count(input: Seq<char>, test_case: nat) -> nat
    recommends test_case < count_test_cases(input) && valid_input_format(input)
{
    1
}

spec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>
    recommends test_case < count_test_cases(input) && valid_input_format(input)
{
    seq![seq!['0']]
}

spec fn string_to_int(s: Seq<char>) -> int {
    1
}

spec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)
{
    0
}

spec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)
{
    greedy_palindrome_count(strings)
}

spec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()
{
    k <= greedy_palindrome_count(strings)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    true
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn count_test_cases(input: Seq<char>) -> nat
    recommends valid_input_format(input)
{
    1
}

spec fn count_lines(s: Seq<char>) -> nat {
    1
}

spec fn get_line(s: Seq<char>, i: nat) -> Seq<char>
    recommends i < count_lines(s)
{
    seq!['1']
}

spec fn get_string_count(input: Seq<char>, test_case: nat) -> nat
    recommends test_case < count_test_cases(input) && valid_input_format(input)
{
    1
}

spec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>
    recommends test_case < count_test_cases(input) && valid_input_format(input)
{
    seq![seq!['0']]
}

spec fn string_to_int(s: Seq<char>) -> int {
    1
}

spec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)
{
    0
}

spec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)
{
    greedy_palindrome_count(strings)
}

spec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()
{
    k <= greedy_palindrome_count(strings)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_test_cases(input: Seq<char>) -> nat\n    recommends valid_input_format(input)\n{\n    1\n}\n\nspec fn count_lines(s: Seq<char>) -> nat {\n    1\n}\n\nspec fn get_line(s: Seq<char>, i: nat) -> Seq<char>\n    recommends i < count_lines(s)\n{\n    seq!['1']\n}\n\nspec fn get_string_count(input: Seq<char>, test_case: nat) -> nat\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    1\n}\n\nspec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    seq![seq!['0']]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    1\n}\n\nspec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    0\n}\n\nspec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    greedy_palindrome_count(strings)\n}\n\nspec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()\n{\n    k <= greedy_palindrome_count(strings)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1912.rs,84,84,1.0,92.106,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() as int - 1] == '\n' &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output_format(output: Seq<char>) -> bool {
    output.len() == 0 || output[output.len() as int - 1] == '\n'
}

spec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input) && valid_output_format(output)
{
    true
}

spec fn process_input(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    input.subrange(0, 0)
}

spec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool
    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0
{
    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + 
                    (if g % 2 == 1 { 1int } else { 0int }) + 
                    (if b % 2 == 1 { 1int } else { 0int }) + 
                    (if w % 2 == 1 { 1int } else { 0int });
    odd_count <= 1 || 
    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))
}

spec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool
    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0
{
    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + 
                    (if g % 2 == 1 { 1int } else { 0int }) + 
                    (if b % 2 == 1 { 1int } else { 0int }) + 
                    (if w % 2 == 1 { 1int } else { 0int });
    odd_count <= 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() as int - 1] == '\n' || 
        !stdin_input.subrange(0, stdin_input.len() as int - 1).contains('\n'),
        valid_input(stdin_input),
    ensures
        result.len() >= 0,
        forall|i: int| 0 <= i < result.len() ==> 
            result[i] == 'Y' || result[i] == 'e' || result[i] == 's' || 
            result[i] == 'N' || result[i] == 'o' || result[i] == '\n' || result[i] == ' ',
        result.len() == 0 || result[result.len() as int - 1] == '\n',
        valid_output_format(result),
        input_output_correspondence(stdin_input, result),
        result == process_input(stdin_input),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() as int - 1] == '\n' &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output_format(output: Seq<char>) -> bool {
    output.len() == 0 || output[output.len() as int - 1] == '\n'
}

spec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input) && valid_output_format(output)
{
    true
}

spec fn process_input(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    input.subrange(0, 0)
}

spec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool
    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0
{
    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + 
                    (if g % 2 == 1 { 1int } else { 0int }) + 
                    (if b % 2 == 1 { 1int } else { 0int }) + 
                    (if w % 2 == 1 { 1int } else { 0int });
    odd_count <= 1 || 
    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))
}

spec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool
    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0
{
    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + 
                    (if g % 2 == 1 { 1int } else { 0int }) + 
                    (if b % 2 == 1 { 1int } else { 0int }) + 
                    (if w % 2 == 1 { 1int } else { 0int });
    odd_count <= 1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() as int - 1] == '\n' || 
        !stdin_input.subrange(0, stdin_input.len() as int - 1).contains('\n'),
        valid_input(stdin_input),
    ensures
        result.len() >= 0,
        forall|i: int| 0 <= i < result.len() ==> 
            result[i] == 'Y' || result[i] == 'e' || result[i] == 's' || 
            result[i] == 'N' || result[i] == 'o' || result[i] == '\n' || result[i] == ' ',
        result.len() == 0 || result[result.len() as int - 1] == '\n',
        valid_output_format(result),
        input_output_correspondence(stdin_input, result),
        result == process_input(stdin_input),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() as int - 1] == '\\n' &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    output.len() == 0 || output[output.len() as int - 1] == '\\n'\n}\n\nspec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input) && valid_output_format(output)\n{\n    true\n}\n\nspec fn process_input(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    input.subrange(0, 0)\n}\n\nspec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1 || \n    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))\n}\n\nspec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() as int - 1] == '\\n' || \n        !stdin_input.subrange(0, stdin_input.len() as int - 1).contains('\\n'),\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == 'Y' || result[i] == 'e' || result[i] == 's' || \n            result[i] == 'N' || result[i] == 'o' || result[i] == '\\n' || result[i] == ' ',\n        result.len() == 0 || result[result.len() as int - 1] == '\\n',\n        valid_output_format(result),\n        input_output_correspondence(stdin_input, result),\n        result == process_input(stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1932.rs,135,135,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(input: String) -> bool {
        input.len() > 0 && 
        {
            let lines = split_lines_func(input);
            lines.len() >= 2 && 
            string_to_int_func(lines[0]) >= 1 &&
            string_to_int_func(lines[0]) <= (lines.len() as int) - 1
        }
    }
    
    spec fn get_faces(polyhedron: String) -> int {
        if polyhedron == ""Tetrahedron"" { 4 }
        else if polyhedron == ""Cube"" { 6 }
        else if polyhedron == ""Octahedron"" { 8 }
        else if polyhedron == ""Dodecahedron"" { 12 }
        else if polyhedron == ""Icosahedron"" { 20 }
        else { 0 }
    }
    
    spec fn split_lines_func(s: String) -> Seq<String> {
        split_lines_helper(s, 0, 0, seq![])
    }
    
    spec fn split_lines_helper(s: String, start: int, i: int, acc: Seq<String>) -> Seq<String>
        decreases s.len() - i
    {
        if i >= s.len() {
            if start < s.len() { acc.push(s.substring_char(start as usize, s.len()).to_string()) }
            else { acc }
        } else if s.get_char(i as usize) == '\n' {
            let new_acc = if start <= i { acc.push(s.substring_char(start as usize, i as usize).to_string()) } else { acc };
            split_lines_helper(s, i + 1, i + 1, new_acc)
        } else {
            split_lines_helper(s, start, i + 1, acc)
        }
    }
    
    spec fn string_to_int_func(s: String) -> int {
        let trimmed = trim_func(s);
        if trimmed.len() == 0 { 0 }
        else { string_to_int_helper(trimmed, 0, 0) }
    }
    
    spec fn string_to_int_helper(s: String, i: int, acc: int) -> int
        decreases s.len() - i
    {
        if i >= s.len() { acc }
        else if '0' <= s.get_char(i as usize) <= '9' {
            string_to_int_helper(s, i + 1, acc * 10 + (s.get_char(i as usize) as int - '0' as int))
        } else {
            string_to_int_helper(s, i + 1, acc)
        }
    }
    
    spec fn int_to_string_func(n: int) -> String {
        if n == 0 { ""0"".to_string() }
        else { int_to_string_helper(n) }
    }
    
    spec fn int_to_string_helper(n: int) -> String
        decreases n
    {
        if n < 10 { 
            char::from_u32((n + ('0' as int)) as u32).unwrap().to_string()
        } else { 
            int_to_string_helper(n / 10) + char::from_u32((n % 10 + ('0' as int)) as u32).unwrap().to_string()
        }
    }
    
    spec fn trim_func(s: String) -> String {
        let start = trim_start(s, 0);
        let end = trim_end(s, s.len() as int, start);
        if start < end { s.substring_char(start as usize, end as usize).to_string() } else { """".to_string() }
    }
    
    spec fn trim_start(s: String, i: int) -> int
        decreases s.len() - i
    {
        if i >= s.len() { i }
        else if s.get_char(i as usize) == ' ' || s.get_char(i as usize) == '\t' || s.get_char(i as usize) == '\r' || s.get_char(i as usize) == '\n' {
            trim_start(s, i + 1)
        } else { i }
    }
    
    spec fn trim_end(s: String, j: int, start: int) -> int
        decreases j - start
    {
        if j <= start { start }
        else if s.get_char((j-1) as usize) == ' ' || s.get_char((j-1) as usize) == '\t' || s.get_char((j-1) as usize) == '\r' || s.get_char((j-1) as usize) == '\n' {
            trim_end(s, j - 1, start)
        } else { j }
    }
    
    spec fn compute_total_up_to(lines: Seq<String>, count: int) -> int {
        if count == 0 { 0 }
        else if count >= lines.len() { 0 }
        else { get_faces(trim_func(lines[count])) + compute_total_up_to(lines, count - 1) }
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires
        valid_input(input),
    ensures
        result.len() > 0,
        result.get_char((result.len() - 1) as usize) == '\n',
        exists|total_faces: int| total_faces >= 0 && result == int_to_string_func(total_faces) + ""\n"",
        valid_input(input) ==> {
            let lines = split_lines_func(input);
            let n = string_to_int_func(lines[0]);
            let expected_total = compute_total_up_to(lines, n);
            result == int_to_string_func(expected_total) + ""\n""
        },
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""0\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(input: String) -> bool {
        input.len() > 0 && 
        {
            let lines = split_lines_func(input);
            lines.len() >= 2 && 
            string_to_int_func(lines[0]) >= 1 &&
            string_to_int_func(lines[0]) <= (lines.len() as int) - 1
        }
    }
    
    spec fn get_faces(polyhedron: String) -> int {
        if polyhedron == ""Tetrahedron"" { 4 }
        else if polyhedron == ""Cube"" { 6 }
        else if polyhedron == ""Octahedron"" { 8 }
        else if polyhedron == ""Dodecahedron"" { 12 }
        else if polyhedron == ""Icosahedron"" { 20 }
        else { 0 }
    }
    
    spec fn split_lines_func(s: String) -> Seq<String> {
        split_lines_helper(s, 0, 0, seq![])
    }
    
    spec fn split_lines_helper(s: String, start: int, i: int, acc: Seq<String>) -> Seq<String>
        decreases s.len() - i
    {
        if i >= s.len() {
            if start < s.len() { acc.push(s.substring_char(start as usize, s.len()).to_string()) }
            else { acc }
        } else if s.get_char(i as usize) == '\n' {
            let new_acc = if start <= i { acc.push(s.substring_char(start as usize, i as usize).to_string()) } else { acc };
            split_lines_helper(s, i + 1, i + 1, new_acc)
        } else {
            split_lines_helper(s, start, i + 1, acc)
        }
    }
    
    spec fn string_to_int_func(s: String) -> int {
        let trimmed = trim_func(s);
        if trimmed.len() == 0 { 0 }
        else { string_to_int_helper(trimmed, 0, 0) }
    }
    
    spec fn string_to_int_helper(s: String, i: int, acc: int) -> int
        decreases s.len() - i
    {
        if i >= s.len() { acc }
        else if '0' <= s.get_char(i as usize) <= '9' {
            string_to_int_helper(s, i + 1, acc * 10 + (s.get_char(i as usize) as int - '0' as int))
        } else {
            string_to_int_helper(s, i + 1, acc)
        }
    }
    
    spec fn int_to_string_func(n: int) -> String {
        if n == 0 { ""0"".to_string() }
        else { int_to_string_helper(n) }
    }
    
    spec fn int_to_string_helper(n: int) -> String
        decreases n
    {
        if n < 10 { 
            char::from_u32((n + ('0' as int)) as u32).unwrap().to_string()
        } else { 
            int_to_string_helper(n / 10) + char::from_u32((n % 10 + ('0' as int)) as u32).unwrap().to_string()
        }
    }
    
    spec fn trim_func(s: String) -> String {
        let start = trim_start(s, 0);
        let end = trim_end(s, s.len() as int, start);
        if start < end { s.substring_char(start as usize, end as usize).to_string() } else { """".to_string() }
    }
    
    spec fn trim_start(s: String, i: int) -> int
        decreases s.len() - i
    {
        if i >= s.len() { i }
        else if s.get_char(i as usize) == ' ' || s.get_char(i as usize) == '\t' || s.get_char(i as usize) == '\r' || s.get_char(i as usize) == '\n' {
            trim_start(s, i + 1)
        } else { i }
    }
    
    spec fn trim_end(s: String, j: int, start: int) -> int
        decreases j - start
    {
        if j <= start { start }
        else if s.get_char((j-1) as usize) == ' ' || s.get_char((j-1) as usize) == '\t' || s.get_char((j-1) as usize) == '\r' || s.get_char((j-1) as usize) == '\n' {
            trim_end(s, j - 1, start)
        } else { j }
    }
    
    spec fn compute_total_up_to(lines: Seq<String>, count: int) -> int {
        if count == 0 { 0 }
        else if count >= lines.len() { 0 }
        else { get_faces(trim_func(lines[count])) + compute_total_up_to(lines, count - 1) }
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
    requires
        valid_input(input),
    ensures
        result.len() > 0,
        result.get_char((result.len() - 1) as usize) == '\n',
        exists|total_faces: int| total_faces >= 0 && result == int_to_string_func(total_faces) + ""\n"",
        valid_input(input) ==> {
            let lines = split_lines_func(input);
            let n = string_to_int_func(lines[0]);
            let expected_total = compute_total_up_to(lines, n);
            result == int_to_string_func(expected_total) + ""\n""
        },
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""0\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1948.rs,81,81,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, x: int, edges: Seq<(int, int)>) -> bool {
  n > 0 && 1 <= x <= n && edges.len() == n - 1 &&
  forall|e: (int, int)| #[trigger] edges.contains(e) ==> 0 <= e.0 < n && 0 <= e.1 < n
}

spec fn valid_distances(way_a: Seq<int>, way_b: Seq<int>, n: int, x: int) -> bool {
  way_a.len() == n && way_b.len() == n && n > 0 && 1 <= x <= n &&
  way_a[0] == 0 && way_b[x-1] == 0 &&
  forall|i: int| 0 <= i < n ==> #[trigger] way_a[i] >= 0 && #[trigger] way_b[i] >= 0
}

spec fn valid_leaves(leaves: Seq<int>, edges: Seq<(int, int)>, n: int) -> bool {
  valid_input(n, 1, edges) ==>
  (forall|i: int| 0 <= i < leaves.len() ==> 0 <= #[trigger] leaves[i] < n) &&
  (forall|i: int| 0 <= i < leaves.len() ==> is_leaf_node(#[trigger] leaves[i], edges, n)) &&
  (forall|i: int| 0 <= i < n ==> is_leaf_node(i, edges, n) ==> #[trigger] leaves.contains(i)) &&
  no_duplicates(leaves)
}

spec fn optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {
  2 * compute_optimal_moves(way_a, way_b, leaves, x-1)
}
spec fn is_leaf_node(node: int, edges: Seq<(int, int)>, n: int) -> bool {
  if 0 <= node < n {
    let degree = edges.filter(|e: (int, int)| e.0 == node || e.1 == node).len();
    degree <= 1
  } else {
    false
  }
}

spec fn no_duplicates(s: Seq<int>) -> bool {
  forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j ==> #[trigger] s[i] != #[trigger] s[j]
}

spec fn compute_optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {
  if leaves.len() == 0 {
    0
  } else {
    let max_leaf = leaves.fold_left(0, |acc: int, leaf: int| 
      if way_a[leaf] + way_b[leaf] > acc { way_a[leaf] + way_b[leaf] } else { acc }
    );
    max_leaf
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, x: i8, edges: Vec<(i8, i8)>, leaves: Vec<i8>, way_a: Vec<i8>, way_b: Vec<i8>) -> (result: i8)
  requires 
    valid_input(n as int, x as int, edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int))) &&
    valid_distances(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), n as int, x as int) &&
    valid_leaves(leaves@.map(|l: i8| l as int), edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int)), n as int) &&
    (forall|i: int| 0 <= i < leaves@.len() ==> 
      (0 <= leaves@[i] as int < way_a@.len()) && 
      (0 <= leaves@[i] as int < way_b@.len()))
  ensures 
    result >= 0 &&
    result as int == optimal_moves(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), leaves@.map(|l: i8| l as int), x as int) &&
    (result as int) % 2 == 0 &&
    result as int >= 2 * way_a@[(x-1) as int] as int
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, x: int, edges: Seq<(int, int)>) -> bool {
  n > 0 && 1 <= x <= n && edges.len() == n - 1 &&
  forall|e: (int, int)| #[trigger] edges.contains(e) ==> 0 <= e.0 < n && 0 <= e.1 < n
}

spec fn valid_distances(way_a: Seq<int>, way_b: Seq<int>, n: int, x: int) -> bool {
  way_a.len() == n && way_b.len() == n && n > 0 && 1 <= x <= n &&
  way_a[0] == 0 && way_b[x-1] == 0 &&
  forall|i: int| 0 <= i < n ==> #[trigger] way_a[i] >= 0 && #[trigger] way_b[i] >= 0
}

spec fn valid_leaves(leaves: Seq<int>, edges: Seq<(int, int)>, n: int) -> bool {
  valid_input(n, 1, edges) ==>
  (forall|i: int| 0 <= i < leaves.len() ==> 0 <= #[trigger] leaves[i] < n) &&
  (forall|i: int| 0 <= i < leaves.len() ==> is_leaf_node(#[trigger] leaves[i], edges, n)) &&
  (forall|i: int| 0 <= i < n ==> is_leaf_node(i, edges, n) ==> #[trigger] leaves.contains(i)) &&
  no_duplicates(leaves)
}

spec fn optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {
  2 * compute_optimal_moves(way_a, way_b, leaves, x-1)
}
spec fn is_leaf_node(node: int, edges: Seq<(int, int)>, n: int) -> bool {
  if 0 <= node < n {
    let degree = edges.filter(|e: (int, int)| e.0 == node || e.1 == node).len();
    degree <= 1
  } else {
    false
  }
}

spec fn no_duplicates(s: Seq<int>) -> bool {
  forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j ==> #[trigger] s[i] != #[trigger] s[j]
}

spec fn compute_optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {
  if leaves.len() == 0 {
    0
  } else {
    let max_leaf = leaves.fold_left(0, |acc: int, leaf: int| 
      if way_a[leaf] + way_b[leaf] > acc { way_a[leaf] + way_b[leaf] } else { acc }
    );
    max_leaf
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, x: i8, edges: Vec<(i8, i8)>, leaves: Vec<i8>, way_a: Vec<i8>, way_b: Vec<i8>) -> (result: i8)
  requires 
    valid_input(n as int, x as int, edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int))) &&
    valid_distances(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), n as int, x as int) &&
    valid_leaves(leaves@.map(|l: i8| l as int), edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int)), n as int) &&
    (forall|i: int| 0 <= i < leaves@.len() ==> 
      (0 <= leaves@[i] as int < way_a@.len()) && 
      (0 <= leaves@[i] as int < way_b@.len()))
  ensures 
    result >= 0 &&
    result as int == optimal_moves(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), leaves@.map(|l: i8| l as int), x as int) &&
    (result as int) % 2 == 0 &&
    result as int >= 2 * way_a@[(x-1) as int] as int
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1966.rs,127,27,0.2125984251968504,154.77,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn contains_valid_input_format(input: Seq<char>) -> bool {
    exists|n: int| 1 <= n <= 100 && n % 2 == 1 && 
        input_has_correct_structure_for_n(input, n) &&
        input_contains_exactly_four_pieces_of_size_n(input, n) &&
        all_pieces_contain_only_binary_chars(input, n)
}

spec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool
    recommends 1 <= n <= 100 && n % 2 == 1
{
    let lines = split_by_newline(input);
    lines.len() >= 4*n + 4 &&
    is_valid_integer_string(lines[0]) &&
    string_to_int(lines[0]) == n &&
    (lines.len() > n+1 ==> equal(lines[n+1], seq![])) && 
    (lines.len() > 2*n+2 ==> equal(lines[2*n+2], seq![])) && 
    (lines.len() > 3*n+3 ==> equal(lines[3*n+3], seq![]))
}

spec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool
    recommends 1 <= n <= 100 && n % 2 == 1
{
    let lines = split_by_newline(input);
    lines.len() >= 4*n + 4 &&
    (forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i].len() == n) &&
    (forall|i: int| n+2 <= i <= 2*n+1 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&
    (forall|i: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&
    (forall|i: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() ==> #[trigger] lines[i].len() == n)
}

spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool
    recommends 1 <= n <= 100 && n % 2 == 1
{
    let lines = split_by_newline(input);
    lines.len() >= 4*n + 4 &&
    (forall|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() ==> 
        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&
    (forall|i: int, j: int| n+2 <= i <= 2*n+1 && i < lines.len() && 0 <= j < lines[i].len() ==> 
        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&
    (forall|i: int, j: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() && 0 <= j < lines[i].len() ==> 
        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&
    (forall|i: int, j: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() && 0 <= j < lines[i].len() ==> 
        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1'))
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (s[0] != '0' || s.len() == 1) &&
    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && #[trigger] s[i] <= '9')
}

spec fn represents_minimum_recoloring_count(input: Seq<char>, output: Seq<char>) -> bool {
    is_valid_integer_string(output) &&
    contains_valid_input_format(input) &&
    {
        let n = extract_n_from_input(input);
        let pieces = extract_pieces_from_input(input);
        pieces.len() == 4 &&
        (forall|piece: Seq<Seq<char>>| pieces.contains(piece) ==> 
            piece.len() == n && 
            (forall|row: Seq<char>| piece.contains(row) ==> 
                row.len() == n &&
                (forall|i: int| 0 <= i < row.len() ==> (row[i] == '0' || row[i] == '1')))) &&
        string_to_int(output) == minimum_recoloring_for_pieces(pieces, n)
    }
}

spec fn extract_n_from_input(input: Seq<char>) -> int
    recommends contains_valid_input_format(input)
{
    let lines = split_by_newline(input);
    if lines.len() > 0 && is_valid_integer_string(lines[0]) {
        string_to_int(lines[0])
    } else {
        1
    }
}

spec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>
    recommends contains_valid_input_format(input)
{
    let lines = split_by_newline(input);
    let n = extract_n_from_input(input);
    seq![
        lines.subrange(1, n+1),
        lines.subrange(n+2, 2*n+2), 
        lines.subrange(2*n+3, 3*n+3),
        lines.subrange(3*n+4, 4*n+4)
    ]
}

spec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {
    0
}

spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn contains_valid_input_format(input: Seq<char>) -> bool ;
       spec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;
       spec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;
       spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;
       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;
       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {
          let lines = split_by_newline(input);
          if lines.len() > 0 && is_valid_integer_string(lines[0]) {
             string_to_int(lines[0])     }
      else {
             1     }
      }
       spec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>     recommends contains_valid_input_format(input) {
          let lines = split_by_newline(input);
          let n = extract_n_from_input(input);
          seq![         lines.subrange(1, n+1),         lines.subrange(n+2, 2*n+2),          lines.subrange(2*n+3, 3*n+3),         lines.subrange(3*n+4, 4*n+4)     ] }
       spec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {
          0 }
       spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {
          seq![] }
       spec fn string_to_int(s: Seq<char>) -> int {
          0 }
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn contains_valid_input_format(input: Seq<char>) -> bool {\n    exists|n: int| 1 <= n <= 100 && n % 2 == 1 && \n        input_has_correct_structure_for_n(input, n) &&\n        input_contains_exactly_four_pieces_of_size_n(input, n) &&\n        all_pieces_contain_only_binary_chars(input, n)\n}\n\nspec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    is_valid_integer_string(lines[0]) &&\n    string_to_int(lines[0]) == n &&\n    (lines.len() > n+1 ==> equal(lines[n+1], seq![])) && \n    (lines.len() > 2*n+2 ==> equal(lines[2*n+2], seq![])) && \n    (lines.len() > 3*n+3 ==> equal(lines[3*n+3], seq![]))\n}\n\nspec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    (forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| n+2 <= i <= 2*n+1 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() ==> #[trigger] lines[i].len() == n)\n}\n\nspec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    (forall|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| n+2 <= i <= 2*n+1 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1'))\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s[0] != '0' || s.len() == 1) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && #[trigger] s[i] <= '9')\n}\n\nspec fn represents_minimum_recoloring_count(input: Seq<char>, output: Seq<char>) -> bool {\n    is_valid_integer_string(output) &&\n    contains_valid_input_format(input) &&\n    {\n        let n = extract_n_from_input(input);\n        let pieces = extract_pieces_from_input(input);\n        pieces.len() == 4 &&\n        (forall|piece: Seq<Seq<char>>| pieces.contains(piece) ==> \n            piece.len() == n && \n            (forall|row: Seq<char>| piece.contains(row) ==> \n                row.len() == n &&\n                (forall|i: int| 0 <= i < row.len() ==> (row[i] == '0' || row[i] == '1')))) &&\n        string_to_int(output) == minimum_recoloring_for_pieces(pieces, n)\n    }\n}\n\nspec fn extract_n_from_input(input: Seq<char>) -> int\n    recommends contains_valid_input_format(input)\n{\n    let lines = split_by_newline(input);\n    if lines.len() > 0 && is_valid_integer_string(lines[0]) {\n        string_to_int(lines[0])\n    } else {\n        1\n    }\n}\n\nspec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>\n    recommends contains_valid_input_format(input)\n{\n    let lines = split_by_newline(input);\n    let n = extract_n_from_input(input);\n    seq![\n        lines.subrange(1, n+1),\n        lines.subrange(n+2, 2*n+2), \n        lines.subrange(2*n+3, 3*n+3),\n        lines.subrange(3*n+4, 4*n+4)\n    ]\n}\n\nspec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {\n    0\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn contains_valid_input_format(input: Seq<char>) -> bool ;\n       spec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool     recommends 1 <= n <= 100 && n % 2 == 1 ;\n       spec fn is_valid_integer_string(s: Seq<char>) -> bool ;\n       spec fn extract_n_from_input(input: Seq<char>) -> int     recommends contains_valid_input_format(input) {\n          let lines = split_by_newline(input);\n          if lines.len() > 0 && is_valid_integer_string(lines[0]) {\n             string_to_int(lines[0])     }\n      else {\n             1     }\n      }\n       spec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>     recommends contains_valid_input_format(input) {\n          let lines = split_by_newline(input);\n          let n = extract_n_from_input(input);\n          seq![         lines.subrange(1, n+1),         lines.subrange(n+2, 2*n+2),          lines.subrange(2*n+3, 3*n+3),         lines.subrange(3*n+4, 4*n+4)     ] }\n       spec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {\n          0 }\n       spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n          seq![] }\n       spec fn string_to_int(s: Seq<char>) -> int {\n          0 }\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n             fn main() {\n   }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1968.rs,61,61,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, v: int, sellers: Seq<Seq<int>>) -> bool {
    n >= 0 && v >= 0 && sellers.len() == n && 
    forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0
}

spec fn valid_output(count: int, indices: Seq<int>, n: int) -> bool {
    count == indices.len() && count >= 0 && count <= n &&
    (forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= n) &&
    (forall|i: int| 0 <= i < indices.len() - 1 ==> indices[i] < indices[i+1])
}

spec fn correct_solution(v: int, sellers: Seq<Seq<int>>, indices: Seq<int>) -> bool 
    recommends forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0,
              forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= sellers.len()
{
    (forall|i: int| 0 <= i < indices.len() ==> v > seq_min(sellers[indices[i] - 1])) &&
    (forall|i: int| 0 <= i < sellers.len() ==> (v > seq_min(sellers[i]) <==> indices.contains(i + 1)))
}

spec fn seq_min(s: Seq<int>) -> int
    recommends s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else {
        let first = s[0];
        let rest_min = seq_min(s.subrange(1, s.len() as int));
        if first < rest_min { first } else { rest_min }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i32, v: i32, sellers: Vec<Vec<i32>>) -> (result: (i32, Vec<i32>))
    requires valid_input(n as int, v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)))
    ensures ({
        let (count, indices) = result;
        valid_output(count as int, indices@.map(|i: int, x: i32| x as int), n as int) && 
        correct_solution(v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)), indices@.map(|i: int, x: i32| x as int))
    })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    (0, Vec::new())
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, v: int, sellers: Seq<Seq<int>>) -> bool {
    n >= 0 && v >= 0 && sellers.len() == n && 
    forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0
}

spec fn valid_output(count: int, indices: Seq<int>, n: int) -> bool {
    count == indices.len() && count >= 0 && count <= n &&
    (forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= n) &&
    (forall|i: int| 0 <= i < indices.len() - 1 ==> indices[i] < indices[i+1])
}

spec fn correct_solution(v: int, sellers: Seq<Seq<int>>, indices: Seq<int>) -> bool 
    recommends forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0,
              forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= sellers.len()
{
    (forall|i: int| 0 <= i < indices.len() ==> v > seq_min(sellers[indices[i] - 1])) &&
    (forall|i: int| 0 <= i < sellers.len() ==> (v > seq_min(sellers[i]) <==> indices.contains(i + 1)))
}

spec fn seq_min(s: Seq<int>) -> int
    recommends s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else {
        let first = s[0];
        let rest_min = seq_min(s.subrange(1, s.len() as int));
        if first < rest_min { first } else { rest_min }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i32, v: i32, sellers: Vec<Vec<i32>>) -> (result: (i32, Vec<i32>))
    requires valid_input(n as int, v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)))
    ensures ({
        let (count, indices) = result;
        valid_output(count as int, indices@.map(|i: int, x: i32| x as int), n as int) && 
        correct_solution(v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)), indices@.map(|i: int, x: i32| x as int))
    })
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    (0, Vec::new())
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1972.rs,61,61,1.0,92.12,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() - 1] == '\n'
}

spec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {
    true
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    if input.len() == 0 { 
        seq![]
    } else { 
        seq![seq!['1'], seq!['q', 'u', 'e', 'r', 'y', '1']] 
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {
    0
}

spec fn int_to_string(x: int) -> Seq<char> {
    seq!['1']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (output: Seq<char>)
    requires 
        input.len() > 0,
        valid_input(input),
    ensures 
        valid_output(output, input),
        output.len() > 0 && output[output.len() - 1] == '\n',
        correct_incremental_query_processing(input, output),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() - 1] == '\n'
}

spec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {
    true
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    if input.len() == 0 { 
        seq![]
    } else { 
        seq![seq!['1'], seq!['q', 'u', 'e', 'r', 'y', '1']] 
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {
    0
}

spec fn int_to_string(x: int) -> Seq<char> {
    seq!['1']
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (output: Seq<char>)
    requires 
        input.len() > 0,
        valid_input(input),
    ensures 
        valid_output(output, input),
        output.len() > 0 && output[output.len() - 1] == '\n',
        correct_incremental_query_processing(input, output),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {\n    true\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 { \n        seq![]\n    } else { \n        seq![seq!['1'], seq!['q', 'u', 'e', 'r', 'y', '1']] \n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {\n    0\n}\n\nspec fn int_to_string(x: int) -> Seq<char> {\n    seq!['1']\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input(input),\n    ensures \n        valid_output(output, input),\n        output.len() > 0 && output[output.len() - 1] == '\\n',\n        correct_incremental_query_processing(input, output),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1980.rs,120,120,1.0,92.156,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_spec(input);
    lines.len() >= 1 && 
    split_whitespace_spec(lines[0]).len() >= 2 &&
    {
        let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);
        let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);
        n > 0 && k > 0 && lines.len() >= n + 1 &&
        (forall|i: int| 1 <= i <= n ==> 
            i < lines.len() && split_whitespace_spec(lines[i]).len() >= 2)
    }
}

spec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {
    let lines = split_lines_spec(input);
    let difficulties = Seq::new(n, |i: int| 
        parse_int_spec(split_whitespace_spec(lines[i + 1])[0]));
    let costs = Seq::new(n, |i: int| 
        parse_int_spec(split_whitespace_spec(lines[i + 1])[1]));

    max_subsegment_profit(difficulties, costs, k)
}

spec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {
    if difficulties.len() == 0 {
        0
    } else {
        let all_segment_profits = Seq::new(difficulties.len(), |l: int| 
            Seq::new((difficulties.len() - l) as nat, |len: int|
                subsegment_profit(difficulties, costs, k, l as nat, (l + len) as nat)));
        max_value(0, max_in_nested_seq(all_segment_profits))
    }
}

spec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {
    let length = r - l + 1;
    let revenue = length * k;
    let cost_sum = sum_range(costs, l, r);
    let gap = if l == r { 0 } else { max_gap_squared(difficulties, l, r) };
    revenue - cost_sum - gap
}

spec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    0
}

spec fn int_to_string_result(n: int) -> Seq<char> {
    seq!['0']
}

spec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {
    0
}

spec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {
    0
}

spec fn max_value(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        input@.len() > 0,
    ensures
        result@.len() > 0,
        result@.last() == '\n',
        ({
            let lines = split_lines_spec(input@);
            (lines.len() == 0 || lines.len() == 1 || 
             split_whitespace_spec(lines[0]).len() < 2 ||
             parse_int_spec(split_whitespace_spec(lines[0])[0]) <= 0) ==> 
            result@ == ""0\n""@
        }),
        (valid_input(input@) ==> {
            let lines = split_lines_spec(input@);
            let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);
            let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);
            exists|profit: int| 
                profit >= 0 && 
                result@ == int_to_string_result(profit) + ""\n""@ &&
                profit == optimal_segment_profit(input@, n as nat, k)
        }),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_spec(input);
    lines.len() >= 1 && 
    split_whitespace_spec(lines[0]).len() >= 2 &&
    {
        let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);
        let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);
        n > 0 && k > 0 && lines.len() >= n + 1 &&
        (forall|i: int| 1 <= i <= n ==> 
            i < lines.len() && split_whitespace_spec(lines[i]).len() >= 2)
    }
}

spec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {
    let lines = split_lines_spec(input);
    let difficulties = Seq::new(n, |i: int| 
        parse_int_spec(split_whitespace_spec(lines[i + 1])[0]));
    let costs = Seq::new(n, |i: int| 
        parse_int_spec(split_whitespace_spec(lines[i + 1])[1]));

    max_subsegment_profit(difficulties, costs, k)
}

spec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {
    if difficulties.len() == 0 {
        0
    } else {
        let all_segment_profits = Seq::new(difficulties.len(), |l: int| 
            Seq::new((difficulties.len() - l) as nat, |len: int|
                subsegment_profit(difficulties, costs, k, l as nat, (l + len) as nat)));
        max_value(0, max_in_nested_seq(all_segment_profits))
    }
}

spec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {
    let length = r - l + 1;
    let revenue = length * k;
    let cost_sum = sum_range(costs, l, r);
    let gap = if l == r { 0 } else { max_gap_squared(difficulties, l, r) };
    revenue - cost_sum - gap
}

spec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    0
}

spec fn int_to_string_result(n: int) -> Seq<char> {
    seq!['0']
}

spec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {
    0
}

spec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {
    0
}

spec fn max_value(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        input@.len() > 0,
    ensures
        result@.len() > 0,
        result@.last() == '\n',
        ({
            let lines = split_lines_spec(input@);
            (lines.len() == 0 || lines.len() == 1 || 
             split_whitespace_spec(lines[0]).len() < 2 ||
             parse_int_spec(split_whitespace_spec(lines[0])[0]) <= 0) ==> 
            result@ == ""0\n""@
        }),
        (valid_input(input@) ==> {
            let lines = split_lines_spec(input@);
            let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);
            let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);
            exists|profit: int| 
                profit >= 0 && 
                result@ == int_to_string_result(profit) + ""\n""@ &&
                profit == optimal_segment_profit(input@, n as nat, k)
        }),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 1 && \n    split_whitespace_spec(lines[0]).len() >= 2 &&\n    {\n        let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n        let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n        n > 0 && k > 0 && lines.len() >= n + 1 &&\n        (forall|i: int| 1 <= i <= n ==> \n            i < lines.len() && split_whitespace_spec(lines[i]).len() >= 2)\n    }\n}\n\nspec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {\n    let lines = split_lines_spec(input);\n    let difficulties = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[0]));\n    let costs = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[1]));\n\n    max_subsegment_profit(difficulties, costs, k)\n}\n\nspec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {\n    if difficulties.len() == 0 {\n        0\n    } else {\n        let all_segment_profits = Seq::new(difficulties.len(), |l: int| \n            Seq::new((difficulties.len() - l) as nat, |len: int|\n                subsegment_profit(difficulties, costs, k, l as nat, (l + len) as nat)));\n        max_value(0, max_in_nested_seq(all_segment_profits))\n    }\n}\n\nspec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {\n    let length = r - l + 1;\n    let revenue = length * k;\n    let cost_sum = sum_range(costs, l, r);\n    let gap = if l == r { 0 } else { max_gap_squared(difficulties, l, r) };\n    revenue - cost_sum - gap\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string_result(n: int) -> Seq<char> {\n    seq![\'0\']\n}\n\nspec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_value(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n    ensures\n        result@.len() > 0,\n        result@.last() == \'\\n\',\n        ({\n            let lines = split_lines_spec(input@);\n            (lines.len() == 0 || lines.len() == 1 || \n             split_whitespace_spec(lines[0]).len() < 2 ||\n             parse_int_spec(split_whitespace_spec(lines[0])[0]) <= 0) ==> \n            result@ == ""0\\n""@\n        }),\n        (valid_input(input@) ==> {\n            let lines = split_lines_spec(input@);\n            let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n            let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n            exists|profit: int| \n                profit >= 0 && \n                result@ == int_to_string_result(profit) + ""\\n""@ &&\n                profit == optimal_segment_profit(input@, n as nat, k)\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_1984.rs,85,85,1.0,92.182,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {
    (1, 1, 1, 1)
}

spec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {
    seq![]
}

spec fn int_to_string(n: nat) -> Seq<char> {
    seq![]
}

spec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {
    (1, 0)
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    stdin_input[stdin_input.len() as int - 1] == '\n' &&
    {
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        lines.len() > 0 &&
        1 <= parse_first_line(lines[0]).0 <= 10 &&
        1 <= parse_first_line(lines[0]).1 <= 10 &&
        1 <= parse_first_line(lines[0]).2 <= 1000 &&
        1 <= parse_first_line(lines[0]).3 <= 1000
    }
}

spec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {
    result.len() > 0 &&
    result[result.len() as int - 1] == '\n' &&
    {
        let result_lines = split_lines(result);
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        result_lines.len() >= 1 &&
        is_valid_spanning_tree(result_lines, parse_first_line(lines[0]).2)
    }
}

spec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {
    0
}

spec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {
    true
}

spec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires valid_input(stdin_input@)
    ensures valid_output(result@, stdin_input@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {
    (1, 1, 1, 1)
}

spec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {
    seq![]
}

spec fn int_to_string(n: nat) -> Seq<char> {
    seq![]
}

spec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {
    (1, 0)
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    stdin_input[stdin_input.len() as int - 1] == '\n' &&
    {
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        lines.len() > 0 &&
        1 <= parse_first_line(lines[0]).0 <= 10 &&
        1 <= parse_first_line(lines[0]).1 <= 10 &&
        1 <= parse_first_line(lines[0]).2 <= 1000 &&
        1 <= parse_first_line(lines[0]).3 <= 1000
    }
}

spec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {
    result.len() > 0 &&
    result[result.len() as int - 1] == '\n' &&
    {
        let result_lines = split_lines(result);
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        result_lines.len() >= 1 &&
        is_valid_spanning_tree(result_lines, parse_first_line(lines[0]).2)
    }
}

spec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {
    0
}

spec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {
    true
}

spec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires valid_input(stdin_input@)
    ensures valid_output(result@, stdin_input@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {\n    (1, 1, 1, 1)\n}\n\nspec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {\n    seq![]\n}\n\nspec fn int_to_string(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {\n    (1, 0)\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input[stdin_input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        lines.len() > 0 &&\n        1 <= parse_first_line(lines[0]).0 <= 10 &&\n        1 <= parse_first_line(lines[0]).1 <= 10 &&\n        1 <= parse_first_line(lines[0]).2 <= 1000 &&\n        1 <= parse_first_line(lines[0]).3 <= 1000\n    }\n}\n\nspec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {\n    result.len() > 0 &&\n    result[result.len() as int - 1] == '\\n' &&\n    {\n        let result_lines = split_lines(result);\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        result_lines.len() >= 1 &&\n        is_valid_spanning_tree(result_lines, parse_first_line(lines[0]).2)\n    }\n}\n\nspec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {\n    0\n}\n\nspec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {\n    true\n}\n\nspec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2086.rs,55,55,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>, s: int, f: int) -> bool {
  n >= 2 && a.len() == n && s >= 1 && f > s && f <= n &&
  forall|i: int| 0 <= i < n ==> a[i] >= 1
}

spec fn participant_count(a: Seq<int>, s: int, f: int, n: int, start: int) -> int {
  participant_count_helper(a, s, f, n, start, 0)
}

spec fn participant_count_helper(a: Seq<int>, s: int, f: int, n: int, start: int, i: int) -> int
  decreases n - i
{
  if i >= n {
    0
  } else {
    let local_hour = (start + i - 1) % n + 1;
    let contribution = if s <= local_hour < f { a[i] } else { 0 };
    contribution + participant_count_helper(a, s, f, n, start, i + 1)
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>, s: i8, f: i8) -> (result: i8)
  requires 
    valid_input(n as int, a@.map(|i, x| x as int), s as int, f as int),
  ensures 
    1 <= result <= n &&
    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) 
      && 1 <= start <= n as int ==> 
      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) >= participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)) &&
    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)
      && 1 <= start <= n as int && 
      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) == participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) 
      ==> result as int <= start)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>, s: int, f: int) -> bool {
  n >= 2 && a.len() == n && s >= 1 && f > s && f <= n &&
  forall|i: int| 0 <= i < n ==> a[i] >= 1
}

spec fn participant_count(a: Seq<int>, s: int, f: int, n: int, start: int) -> int {
  participant_count_helper(a, s, f, n, start, 0)
}

spec fn participant_count_helper(a: Seq<int>, s: int, f: int, n: int, start: int, i: int) -> int
  decreases n - i
{
  if i >= n {
    0
  } else {
    let local_hour = (start + i - 1) % n + 1;
    let contribution = if s <= local_hour < f { a[i] } else { 0 };
    contribution + participant_count_helper(a, s, f, n, start, i + 1)
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>, s: i8, f: i8) -> (result: i8)
  requires 
    valid_input(n as int, a@.map(|i, x| x as int), s as int, f as int),
  ensures 
    1 <= result <= n &&
    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) 
      && 1 <= start <= n as int ==> 
      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) >= participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)) &&
    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)
      && 1 <= start <= n as int && 
      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) == participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) 
      ==> result as int <= start)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2100.rs,96,96,1.0,123.161,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    is_valid_number(lines[0]) &&
    {
        let n = string_to_int(lines[0]);
        n >= 0 && n + 1 <= lines.len() &&
        forall|i: int| 1 <= i <= n && i < lines.len() ==>
            {
                let parts = split_spaces(#[trigger] lines[i as int]);
                parts.len() >= 2 && is_valid_door_state(parts[0]) && is_valid_door_state(parts[1])
            }
    }
}

spec fn valid_output(output: Seq<char>) -> bool {
    is_valid_number(output)
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] >= '0' && #[trigger] s[i] <= '9')
}

spec fn is_valid_door_state(s: Seq<char>) -> bool {
    s == seq!['0'] || s == seq!['1']
}

spec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {
    let lines = split_lines(input);
    let n = string_to_int(lines[0]);
    if n == 0 {
        seq!['0']
    } else {
        let left_zeros = count_left_zeros(lines, 1, n);
        let right_zeros = count_right_zeros(lines, 1, n);
        let left_ops = if left_zeros < n - left_zeros { left_zeros } else { n - left_zeros };
        let right_ops = if right_zeros < n - right_zeros { right_zeros } else { n - right_zeros };
        int_to_string(left_ops + right_ops)
    }
}

/* Helper functions for string operations */
spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']
}

spec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {
    0
}

spec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures 
        result@.len() > 0,
        valid_output(result@),
        result@ == calculate_min_operations(input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    is_valid_number(lines[0]) &&
    {
        let n = string_to_int(lines[0]);
        n >= 0 && n + 1 <= lines.len() &&
        forall|i: int| 1 <= i <= n && i < lines.len() ==>
            {
                let parts = split_spaces(#[trigger] lines[i as int]);
                parts.len() >= 2 && is_valid_door_state(parts[0]) && is_valid_door_state(parts[1])
            }
    }
}

spec fn valid_output(output: Seq<char>) -> bool {
    is_valid_number(output)
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] >= '0' && #[trigger] s[i] <= '9')
}

spec fn is_valid_door_state(s: Seq<char>) -> bool {
    s == seq!['0'] || s == seq!['1']
}

spec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {
    let lines = split_lines(input);
    let n = string_to_int(lines[0]);
    if n == 0 {
        seq!['0']
    } else {
        let left_zeros = count_left_zeros(lines, 1, n);
        let right_zeros = count_right_zeros(lines, 1, n);
        let left_ops = if left_zeros < n - left_zeros { left_zeros } else { n - left_zeros };
        let right_ops = if right_zeros < n - right_zeros { right_zeros } else { n - right_zeros };
        int_to_string(left_ops + right_ops)
    }
}

/* Helper functions for string operations */
spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']
}

spec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {
    0
}

spec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures 
        result@.len() > 0,
        valid_output(result@),
        result@ == calculate_min_operations(input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    is_valid_number(lines[0]) &&\n    {\n        let n = string_to_int(lines[0]);\n        n >= 0 && n + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==>\n            {\n                let parts = split_spaces(#[trigger] lines[i as int]);\n                parts.len() >= 2 && is_valid_door_state(parts[0]) && is_valid_door_state(parts[1])\n            }\n    }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    is_valid_number(output)\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] >= '0' && #[trigger] s[i] <= '9')\n}\n\nspec fn is_valid_door_state(s: Seq<char>) -> bool {\n    s == seq!['0'] || s == seq!['1']\n}\n\nspec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let n = string_to_int(lines[0]);\n    if n == 0 {\n        seq!['0']\n    } else {\n        let left_zeros = count_left_zeros(lines, 1, n);\n        let right_zeros = count_right_zeros(lines, 1, n);\n        let left_ops = if left_zeros < n - left_zeros { left_zeros } else { n - left_zeros };\n        let right_ops = if right_zeros < n - right_zeros { right_zeros } else { n - right_zeros };\n        int_to_string(left_ops + right_ops)\n    }\n}\n\n/* Helper functions for string operations */\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n\nspec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        valid_output(result@),\n        result@ == calculate_min_operations(input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2113.rs,73,73,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn is_connected_tree(n: int, edges: Seq<(int, int)>) -> bool {
        n >= 1 && edges.len() == n - 1 &&
        (n == 1 ==> edges.len() == 0) &&
        (n > 1 ==> is_connected_graph(n, edges))
    }
    
    spec fn is_connected_graph(n: int, edges: Seq<(int, int)>) -> bool {
        n > 1 ==>
        (forall|node: int| 2 <= node <= n ==> 
            can_reach_node_one(node, edges, n))
    }
    
    spec fn can_reach_node_one(target: int, edges: Seq<(int, int)>, max_depth: int) -> bool
        decreases max_depth
    {
        if max_depth <= 0 { 
            false
        } else if target == 1 { 
            true
        } else {
            exists|i: int| 0 <= i < edges.len() && 
                ((edges[i].0 == target && can_reach_node_one(edges[i].1, edges, max_depth - 1)) ||
                 (edges[i].1 == target && can_reach_node_one(edges[i].0, edges, max_depth - 1)))
        }
    }
    
    spec fn valid_tree_input(n: int, edges: Seq<(int, int)>) -> bool {
        n >= 1 &&
        edges.len() == n - 1 &&
        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n) &&
        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> edges[i].0 != edges[i].1) &&
        (forall|i: int, j: int| #[trigger] edges.index(i).0 == edges[i].0 && #[trigger] edges.index(j).0 == edges[j].0 && 0 <= i < j < edges.len() ==> 
            !(edges[i].0 == edges[j].0 && edges[i].1 == edges[j].1) && 
            !(edges[i].0 == edges[j].1 && edges[i].1 == edges[j].0)) &&
        (n == 1 ==> edges.len() == 0) &&
        (n > 1 ==> (forall|node: int| #[trigger] (node + 1 - 1) == node && 1 <= node <= n ==> 
            (exists|i: int| 0 <= i < edges.len() && (edges[i].0 == node || edges[i].1 == node)))) &&
        is_connected_tree(n, edges)
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, edges: Vec<(i8, i8)>) -> (result: i8)
    requires
        valid_tree_input(n as int, Seq::from_vec(edges).map(|i, e| (e.0 as int, e.1 as int))),
    ensures
        result >= 0,
        exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&
            blue >= 0 && red >= 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),
        n == 1 ==> result == 0,
        n == 2 ==> result == 0,
        n > 2 ==> exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&
            blue > 0 && red > 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),
        result as int <= (n as int * n as int) / 4 - (n as int - 1) + (if n % 2 == 0 { 0int } else { 1int }),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn is_connected_tree(n: int, edges: Seq<(int, int)>) -> bool {
        n >= 1 && edges.len() == n - 1 &&
        (n == 1 ==> edges.len() == 0) &&
        (n > 1 ==> is_connected_graph(n, edges))
    }
    
    spec fn is_connected_graph(n: int, edges: Seq<(int, int)>) -> bool {
        n > 1 ==>
        (forall|node: int| 2 <= node <= n ==> 
            can_reach_node_one(node, edges, n))
    }
    
    spec fn can_reach_node_one(target: int, edges: Seq<(int, int)>, max_depth: int) -> bool
        decreases max_depth
    {
        if max_depth <= 0 { 
            false
        } else if target == 1 { 
            true
        } else {
            exists|i: int| 0 <= i < edges.len() && 
                ((edges[i].0 == target && can_reach_node_one(edges[i].1, edges, max_depth - 1)) ||
                 (edges[i].1 == target && can_reach_node_one(edges[i].0, edges, max_depth - 1)))
        }
    }
    
    spec fn valid_tree_input(n: int, edges: Seq<(int, int)>) -> bool {
        n >= 1 &&
        edges.len() == n - 1 &&
        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n) &&
        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> edges[i].0 != edges[i].1) &&
        (forall|i: int, j: int| #[trigger] edges.index(i).0 == edges[i].0 && #[trigger] edges.index(j).0 == edges[j].0 && 0 <= i < j < edges.len() ==> 
            !(edges[i].0 == edges[j].0 && edges[i].1 == edges[j].1) && 
            !(edges[i].0 == edges[j].1 && edges[i].1 == edges[j].0)) &&
        (n == 1 ==> edges.len() == 0) &&
        (n > 1 ==> (forall|node: int| #[trigger] (node + 1 - 1) == node && 1 <= node <= n ==> 
            (exists|i: int| 0 <= i < edges.len() && (edges[i].0 == node || edges[i].1 == node)))) &&
        is_connected_tree(n, edges)
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, edges: Vec<(i8, i8)>) -> (result: i8)
    requires
        valid_tree_input(n as int, Seq::from_vec(edges).map(|i, e| (e.0 as int, e.1 as int))),
    ensures
        result >= 0,
        exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&
            blue >= 0 && red >= 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),
        n == 1 ==> result == 0,
        n == 2 ==> result == 0,
        n > 2 ==> exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&
            blue > 0 && red > 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),
        result as int <= (n as int * n as int) / 4 - (n as int - 1) + (if n % 2 == 0 { 0int } else { 1int }),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2133.rs,156,38,0.24358974358974358,184.761,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_tree_input(input: Seq<char>) -> bool {
  let lines = split_lines(input);
  lines.len() >= 2 &&
  {
    let n = parse_int(lines[0]);
    n >= 1 && n <= 200000 &&
    lines.len() == n + 1 &&
    valid_color_line(lines[1], n) &&
    valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&
    {
      let edges = Seq::new((lines.len() - 2) as nat, |i: int| {
        let edge = parse_int_seq(lines[i + 2]);
        (edge[0], edge[1])
      });
      is_valid_tree(n, edges)
    }
  }
}

spec fn valid_color_line(line: Seq<char>, n: int) -> bool {
  let colors = parse_int_seq(line);
  colors.len() == n &&
  forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == 0 || colors[i] == 1
}

spec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool {
  lines.len() == n - 1 &&
  forall|i: int| #![trigger lines[i]] 0 <= i < lines.len() ==> {
    let edge = parse_int_seq(lines[i]);
    edge.len() == 2 && 
    1 <= edge[0] <= n && 
    1 <= edge[1] <= n && 
    edge[0] != edge[1]
  }
}

spec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool {
  n >= 1 &&
  edges.len() == n - 1 &&
  is_connected(n, edges) &&
  (forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1) &&
  no_duplicate_edges(edges)
}

spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool {
  true
}

spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool {
  forall|i: int, j: int| #![trigger edges[i], edges[j]] 0 <= i < j < edges.len() ==> 
    edges[i] != edges[j] && 
    (edges[i].0, edges[i].1) != (edges[j].1, edges[j].0)
}

spec fn valid_integer_output(output: Seq<char>) -> bool {
  let trimmed = trim_whitespace(output);
  trimmed.len() > 0 &&
  forall|c: char| trimmed.contains(c) ==> '0' <= c <= '9'
}

spec fn all_same_color(colors: Seq<int>) -> bool {
  colors.len() > 0 ==> forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == colors[0]
}

spec fn parse_input(input: Seq<char>) -> (int, Seq<int>, Seq<(int, int)>) {
  let lines = split_lines(input);
  let n = parse_int(lines[0]);
  let colors = parse_int_seq(lines[1]);
  let edges = Seq::new((lines.len() - 2) as nat, |i: int| {
    let edge = parse_int_seq(lines[i + 2]);
    (edge[0], edge[1])
  });
  (n, colors, edges)
}

spec fn parse_output(output: Seq<char>) -> int {
  parse_int(trim_whitespace(output))
}

spec fn compute_min_paint_ops(n: int, colors: Seq<int>, edges: Seq<(int, int)>) -> int {
  if all_same_color(colors) {
    0
  } else {
    let components = build_same_color_components(colors, edges);
    let component_graph = build_component_graph(components, colors, edges);
    (tree_diameter(component_graph) + 1) / 2
  }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }
spec fn parse_int(line: Seq<char>) -> int { 0 }
spec fn parse_int_seq(line: Seq<char>) -> Seq<int> { Seq::empty() }
spec fn trim_whitespace(output: Seq<char>) -> Seq<char> { output }
spec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> { Seq::empty() }
spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> { Seq::empty() }
spec fn tree_diameter(graph: Seq<(int, int)>) -> int { 0 }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
  requires 
    stdin_input@ .len() > 0,
    valid_tree_input(stdin_input@),
  ensures 
    output@ .len() > 0,
    valid_integer_output(output@),
    ({
      let result = parse_output(output@);
      result >= 0
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      n >= 1 ==> {
        let result = parse_output(output@);
        result <= n
      }
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      all_same_color(colors) ==> parse_output(output@) == 0
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      n == 1 ==> parse_output(output@) == 0
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      is_valid_tree(n, edges) && n >= 1
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      let result = parse_output(output@);
      result == compute_min_paint_ops(n, colors, edges)
    }),
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_tree_input(input: Seq<char>) -> bool {
        let lines = split_lines(input);
        lines.len() >= 2 &&   {
         let n = parse_int(lines[0]);
         n >= 1 && n <= 200000 &&     lines.len() == n + 1 &&     valid_color_line(lines[1], n) &&     valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&     {
          let edges = Seq::new(0 as nat, |i: int| {
           let edge = parse_int_seq(lines[i + 2]);
           (edge[0], edge[1])       }
   );
          is_valid_tree(n, edges)     }
       }
      }
       spec fn valid_color_line(line: Seq<char>, n: int) -> bool ;
       spec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool ;
        spec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool ;
        spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool ;
        spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;
        spec fn valid_integer_output(output: Seq<char>) -> bool ;
        spec fn all_same_color(colors: Seq<int>) -> bool ;
        spec fn parse_output(output: Seq<char>) -> int ;
        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;
        spec fn parse_int(line: Seq<char>) -> int {
       0 }
        spec fn parse_int_seq(line: Seq<char>) -> Seq<int> ;
        spec fn trim_whitespace(output: Seq<char>) -> Seq<char> ;
        spec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> ;
        spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> ;
        spec fn tree_diameter(graph: Seq<(int, int)>) -> int ;
        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({
             let result = parse_output(output@);
             result >= 0     }
       ), {
         unreached() }
        }
        fn main() {
       }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_tree_input(input: Seq<char>) -> bool {\n  let lines = split_lines(input);\n  lines.len() >= 2 &&\n  {\n    let n = parse_int(lines[0]);\n    n >= 1 && n <= 200000 &&\n    lines.len() == n + 1 &&\n    valid_color_line(lines[1], n) &&\n    valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&\n    {\n      let edges = Seq::new((lines.len() - 2) as nat, |i: int| {\n        let edge = parse_int_seq(lines[i + 2]);\n        (edge[0], edge[1])\n      });\n      is_valid_tree(n, edges)\n    }\n  }\n}\n\nspec fn valid_color_line(line: Seq<char>, n: int) -> bool {\n  let colors = parse_int_seq(line);\n  colors.len() == n &&\n  forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == 0 || colors[i] == 1\n}\n\nspec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool {\n  lines.len() == n - 1 &&\n  forall|i: int| #![trigger lines[i]] 0 <= i < lines.len() ==> {\n    let edge = parse_int_seq(lines[i]);\n    edge.len() == 2 && \n    1 <= edge[0] <= n && \n    1 <= edge[1] <= n && \n    edge[0] != edge[1]\n  }\n}\n\nspec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool {\n  n >= 1 &&\n  edges.len() == n - 1 &&\n  is_connected(n, edges) &&\n  (forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1) &&\n  no_duplicate_edges(edges)\n}\n\nspec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool {\n  true\n}\n\nspec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool {\n  forall|i: int, j: int| #![trigger edges[i], edges[j]] 0 <= i < j < edges.len() ==> \n    edges[i] != edges[j] && \n    (edges[i].0, edges[i].1) != (edges[j].1, edges[j].0)\n}\n\nspec fn valid_integer_output(output: Seq<char>) -> bool {\n  let trimmed = trim_whitespace(output);\n  trimmed.len() > 0 &&\n  forall|c: char| trimmed.contains(c) ==> '0' <= c <= '9'\n}\n\nspec fn all_same_color(colors: Seq<int>) -> bool {\n  colors.len() > 0 ==> forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == colors[0]\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<int>, Seq<(int, int)>) {\n  let lines = split_lines(input);\n  let n = parse_int(lines[0]);\n  let colors = parse_int_seq(lines[1]);\n  let edges = Seq::new((lines.len() - 2) as nat, |i: int| {\n    let edge = parse_int_seq(lines[i + 2]);\n    (edge[0], edge[1])\n  });\n  (n, colors, edges)\n}\n\nspec fn parse_output(output: Seq<char>) -> int {\n  parse_int(trim_whitespace(output))\n}\n\nspec fn compute_min_paint_ops(n: int, colors: Seq<int>, edges: Seq<(int, int)>) -> int {\n  if all_same_color(colors) {\n    0\n  } else {\n    let components = build_same_color_components(colors, edges);\n    let component_graph = build_component_graph(components, colors, edges);\n    (tree_diameter(component_graph) + 1) / 2\n  }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn parse_int(line: Seq<char>) -> int { 0 }\nspec fn parse_int_seq(line: Seq<char>) -> Seq<int> { Seq::empty() }\nspec fn trim_whitespace(output: Seq<char>) -> Seq<char> { output }\nspec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> { Seq::empty() }\nspec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> { Seq::empty() }\nspec fn tree_diameter(graph: Seq<(int, int)>) -> int { 0 }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n  requires \n    stdin_input@ .len() > 0,\n    valid_tree_input(stdin_input@),\n  ensures \n    output@ .len() > 0,\n    valid_integer_output(output@),\n    ({\n      let result = parse_output(output@);\n      result >= 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      n >= 1 ==> {\n        let result = parse_output(output@);\n        result <= n\n      }\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      all_same_color(colors) ==> parse_output(output@) == 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      n == 1 ==> parse_output(output@) == 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      is_valid_tree(n, edges) && n >= 1\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      let result = parse_output(output@);\n      result == compute_min_paint_ops(n, colors, edges)\n    }),\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn valid_tree_input(input: Seq<char>) -> bool {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&   {\n         let n = parse_int(lines[0]);\n         n >= 1 && n <= 200000 &&     lines.len() == n + 1 &&     valid_color_line(lines[1], n) &&     valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&     {\n          let edges = Seq::new(0 as nat, |i: int| {\n           let edge = parse_int_seq(lines[i + 2]);\n           (edge[0], edge[1])       }\n   );\n          is_valid_tree(n, edges)     }\n       }\n      }\n       spec fn valid_color_line(line: Seq<char>, n: int) -> bool ;\n       spec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool ;\n        spec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool ;\n        spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool ;\n        spec fn valid_integer_output(output: Seq<char>) -> bool ;\n        spec fn all_same_color(colors: Seq<int>) -> bool ;\n        spec fn parse_output(output: Seq<char>) -> int ;\n        spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn parse_int(line: Seq<char>) -> int {\n       0 }\n        spec fn parse_int_seq(line: Seq<char>) -> Seq<int> ;\n        spec fn trim_whitespace(output: Seq<char>) -> Seq<char> ;\n        spec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> ;\n        spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> ;\n        spec fn tree_diameter(graph: Seq<(int, int)>) -> int ;\n        fn solve(stdin_input: &str) -> (output: String)   requires      stdin_input@ .len() > 0,     valid_tree_input(stdin_input@),   ensures      output@ .len() > 0,     valid_integer_output(output@),     ({\n             let result = parse_output(output@);\n             result >= 0     }\n       ), {\n         unreached() }\n        }\n        fn main() {\n       }\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\n  fn main() {\n}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2168.rs,145,145,1.0,123.572,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_company_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 1 && 
    is_valid_positive_int(lines[0]) &&
    {
        let n = parse_int_func(lines[0]);
        n >= 1 && lines.len() >= n + 1 &&
        (forall|i: int| #![auto] 1 <= i <= n ==> valid_company_line(lines[i]))
    }
}

spec fn valid_company_line(line: Seq<char>) -> bool {
    let parts = split_spaces_func(line);
    parts.len() >= 1 && is_valid_positive_int(parts[0]) &&
    {
        let m = parse_int_func(parts[0]);
        m >= 1 && parts.len() == m + 1 &&
        (forall|j: int| #![auto] 1 <= j <= m ==> is_valid_positive_int(parts[j]))
    }
}

spec fn is_valid_positive_int(s: Seq<char>) -> bool {
    s.len() >= 1 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9')
}

spec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {
    let lines = split_lines_func(input);
    let n = parse_int_func(lines[0]);
    Seq::new(n as nat, |i: int| {
        let parts = split_spaces_func(lines[i + 1]);
        let m = parse_int_func(parts[0]);
        Seq::new(m as nat, |j: int| parse_int_func(parts[j + 1]))
    })
}

spec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {
    let global_max = global_max_salary(companies);
    sum_over_companies(companies, global_max)
}

spec fn global_max_salary(companies: Seq<Seq<int>>) -> int {
    max_in_seq_of_seq(Seq::new(companies.len(), |i: int| max_in_seq_func(companies[i])))
}

spec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int
    decreases companies.len()
{
    if companies.len() == 0 {
        0
    } else if companies.len() == 1 {
        let company_max = max_in_seq_func(companies[0]);
        let increase_per_employee = global_max - company_max;
        increase_per_employee * companies[0].len()
    } else {
        let company_max = max_in_seq_func(companies[0]);
        let increase_per_employee = global_max - company_max;
        increase_per_employee * companies[0].len() + sum_over_companies(companies.subrange(1, companies.len() as int), global_max)
    }
}

spec fn max_in_seq_func(s: Seq<int>) -> int {
    if s.len() > 0 {
        max_in_seq(s)
    } else {
        0
    }
}

spec fn max_in_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_max = max_in_seq(s.subrange(1, s.len() as int));
        if s[0] >= tail_max {
            s[0]
        } else {
            tail_max
        }
    }
}

spec fn max_in_seq_of_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_max = max_in_seq_of_seq(s.subrange(1, s.len() as int));
        if s[0] >= tail_max {
            s[0]
        } else {
            tail_max
        }
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: int)
    requires
        input@.len() > 0,
        valid_company_input(input@),
    ensures
        result >= 0,
        result == calculate_minimum_increase(parse_companies(input@)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_company_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 1 && 
    is_valid_positive_int(lines[0]) &&
    {
        let n = parse_int_func(lines[0]);
        n >= 1 && lines.len() >= n + 1 &&
        (forall|i: int| #![auto] 1 <= i <= n ==> valid_company_line(lines[i]))
    }
}

spec fn valid_company_line(line: Seq<char>) -> bool {
    let parts = split_spaces_func(line);
    parts.len() >= 1 && is_valid_positive_int(parts[0]) &&
    {
        let m = parse_int_func(parts[0]);
        m >= 1 && parts.len() == m + 1 &&
        (forall|j: int| #![auto] 1 <= j <= m ==> is_valid_positive_int(parts[j]))
    }
}

spec fn is_valid_positive_int(s: Seq<char>) -> bool {
    s.len() >= 1 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9')
}

spec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {
    let lines = split_lines_func(input);
    let n = parse_int_func(lines[0]);
    Seq::new(n as nat, |i: int| {
        let parts = split_spaces_func(lines[i + 1]);
        let m = parse_int_func(parts[0]);
        Seq::new(m as nat, |j: int| parse_int_func(parts[j + 1]))
    })
}

spec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {
    let global_max = global_max_salary(companies);
    sum_over_companies(companies, global_max)
}

spec fn global_max_salary(companies: Seq<Seq<int>>) -> int {
    max_in_seq_of_seq(Seq::new(companies.len(), |i: int| max_in_seq_func(companies[i])))
}

spec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int
    decreases companies.len()
{
    if companies.len() == 0 {
        0
    } else if companies.len() == 1 {
        let company_max = max_in_seq_func(companies[0]);
        let increase_per_employee = global_max - company_max;
        increase_per_employee * companies[0].len()
    } else {
        let company_max = max_in_seq_func(companies[0]);
        let increase_per_employee = global_max - company_max;
        increase_per_employee * companies[0].len() + sum_over_companies(companies.subrange(1, companies.len() as int), global_max)
    }
}

spec fn max_in_seq_func(s: Seq<int>) -> int {
    if s.len() > 0 {
        max_in_seq(s)
    } else {
        0
    }
}

spec fn max_in_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_max = max_in_seq(s.subrange(1, s.len() as int));
        if s[0] >= tail_max {
            s[0]
        } else {
            tail_max
        }
    }
}

spec fn max_in_seq_of_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_max = max_in_seq_of_seq(s.subrange(1, s.len() as int));
        if s[0] >= tail_max {
            s[0]
        } else {
            tail_max
        }
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: int)
    requires
        input@.len() > 0,
        valid_company_input(input@),
    ensures
        result >= 0,
        result == calculate_minimum_increase(parse_companies(input@)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_company_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 1 && \n    is_valid_positive_int(lines[0]) &&\n    {\n        let n = parse_int_func(lines[0]);\n        n >= 1 && lines.len() >= n + 1 &&\n        (forall|i: int| #![auto] 1 <= i <= n ==> valid_company_line(lines[i]))\n    }\n}\n\nspec fn valid_company_line(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() >= 1 && is_valid_positive_int(parts[0]) &&\n    {\n        let m = parse_int_func(parts[0]);\n        m >= 1 && parts.len() == m + 1 &&\n        (forall|j: int| #![auto] 1 <= j <= m ==> is_valid_positive_int(parts[j]))\n    }\n}\n\nspec fn is_valid_positive_int(s: Seq<char>) -> bool {\n    s.len() >= 1 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {\n    let lines = split_lines_func(input);\n    let n = parse_int_func(lines[0]);\n    Seq::new(n as nat, |i: int| {\n        let parts = split_spaces_func(lines[i + 1]);\n        let m = parse_int_func(parts[0]);\n        Seq::new(m as nat, |j: int| parse_int_func(parts[j + 1]))\n    })\n}\n\nspec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {\n    let global_max = global_max_salary(companies);\n    sum_over_companies(companies, global_max)\n}\n\nspec fn global_max_salary(companies: Seq<Seq<int>>) -> int {\n    max_in_seq_of_seq(Seq::new(companies.len(), |i: int| max_in_seq_func(companies[i])))\n}\n\nspec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int\n    decreases companies.len()\n{\n    if companies.len() == 0 {\n        0\n    } else if companies.len() == 1 {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len()\n    } else {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len() + sum_over_companies(companies.subrange(1, companies.len() as int), global_max)\n    }\n}\n\nspec fn max_in_seq_func(s: Seq<int>) -> int {\n    if s.len() > 0 {\n        max_in_seq(s)\n    } else {\n        0\n    }\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn max_in_seq_of_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq_of_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: int)\n    requires\n        input@.len() > 0,\n        valid_company_input(input@),\n    ensures\n        result >= 0,\n        result == calculate_minimum_increase(parse_companies(input@)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n         verus! {}\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2195.rs,178,178,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    is_valid_integer(lines[0]) &&
    {
        let t = string_to_int(lines[0]);
        t >= 0 &&
        lines.len() >= 1 + 2 * t &&
        forall|i: int| 0 <= i < t ==> {
            let line1_idx = 1 + 2 * i;
            let line2_idx = 1 + 2 * i + 1;
            line1_idx < lines.len() && line2_idx < lines.len() &&
            {
                let xy_parts = split_whitespace(lines[line1_idx]);
                let ab_parts = split_whitespace(lines[line2_idx]);
                xy_parts.len() >= 2 && ab_parts.len() >= 2 &&
                is_valid_integer(xy_parts[0]) &&
                is_valid_integer(xy_parts[1]) &&
                is_valid_integer(ab_parts[0]) &&
                is_valid_integer(ab_parts[1]) &&
                string_to_int(xy_parts[0]) >= 0 &&
                string_to_int(xy_parts[1]) >= 0 &&
                string_to_int(ab_parts[0]) >= 1 &&
                string_to_int(ab_parts[1]) >= 1
            }
        }
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() == 0 {
        output.len() == 0
    } else {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == (if t == 0 { 0 } else { t }) &&
        forall|i: int| 0 <= i < output_lines.len() ==> is_valid_integer(output_lines[i])
    }
}

spec fn correct_computation(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() == 0 {
        output.len() == 0
    } else {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == (if t == 0 { 0 } else { t }) &&
        forall|i: int| 0 <= i < t && 1 + 2 * i + 1 < lines.len() ==> {
            let xy_line = split_whitespace(lines[1 + 2 * i]);
            let ab_line = split_whitespace(lines[1 + 2 * i + 1]);
            (xy_line.len() >= 2 && ab_line.len() >= 2) ==> {
                let x = string_to_int(xy_line[0]);
                let y = string_to_int(xy_line[1]);
                let a = string_to_int(ab_line[0]);
                let b = string_to_int(ab_line[1]);
                let expected_result = if b <= 2 * a {
                    b * (if x <= y { x } else { y }) + (if x >= y { x } else { y } - if x <= y { x } else { y }) * a
                } else {
                    a * (x + y)
                };
                i < output_lines.len() && string_to_int(output_lines[i]) == expected_result
            }
        }
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 &&
    (s[0] == '-' ==> s.len() > 1) &&
    forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 {
        Seq::empty()
    } else {
        split_by_char(s, '\n')
    }
}

spec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 {
        Seq::empty()
    } else {
        split_by_char(s, ' ')
    }
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![Seq::empty()]
    } else if s[0] == delimiter {
        seq![Seq::empty()].add(split_by_char(s.subrange(1, s.len() as int), delimiter))
    } else {
        let rest = split_by_char(s.subrange(1, s.len() as int), delimiter);
        if rest.len() == 0 {
            seq![s]
        } else {
            seq![s.subrange(0, 1).add(rest[0])].add(rest.subrange(1, rest.len() as int))
        }
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' && s.len() > 1 {
        -string_to_int_helper(s.subrange(1, s.len() as int))
    } else {
        string_to_int_helper(s)
    }
}

spec fn string_to_int_helper(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        if '0' <= s[0] <= '9' { s[0] as int - '0' as int } else { 0 }
    } else {
        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 +
        (if '0' <= s[s.len() - 1] <= '9' { s[s.len() - 1] as int - '0' as int } else { 0 })
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'].add(int_to_string_helper(-n))
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 {
        Seq::empty()
    } else {
        let digit_char = ((n % 10) + ('0' as int)) as char;
        int_to_string_helper(n / 10).push(digit_char)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (output: String)
    requires
        input@.len() > 0,
        valid_input(input@),
    ensures
        valid_output(output@, input@),
        correct_computation(input@, output@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    is_valid_integer(lines[0]) &&
    {
        let t = string_to_int(lines[0]);
        t >= 0 &&
        lines.len() >= 1 + 2 * t &&
        forall|i: int| 0 <= i < t ==> {
            let line1_idx = 1 + 2 * i;
            let line2_idx = 1 + 2 * i + 1;
            line1_idx < lines.len() && line2_idx < lines.len() &&
            {
                let xy_parts = split_whitespace(lines[line1_idx]);
                let ab_parts = split_whitespace(lines[line2_idx]);
                xy_parts.len() >= 2 && ab_parts.len() >= 2 &&
                is_valid_integer(xy_parts[0]) &&
                is_valid_integer(xy_parts[1]) &&
                is_valid_integer(ab_parts[0]) &&
                is_valid_integer(ab_parts[1]) &&
                string_to_int(xy_parts[0]) >= 0 &&
                string_to_int(xy_parts[1]) >= 0 &&
                string_to_int(ab_parts[0]) >= 1 &&
                string_to_int(ab_parts[1]) >= 1
            }
        }
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() == 0 {
        output.len() == 0
    } else {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == (if t == 0 { 0 } else { t }) &&
        forall|i: int| 0 <= i < output_lines.len() ==> is_valid_integer(output_lines[i])
    }
}

spec fn correct_computation(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() == 0 {
        output.len() == 0
    } else {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == (if t == 0 { 0 } else { t }) &&
        forall|i: int| 0 <= i < t && 1 + 2 * i + 1 < lines.len() ==> {
            let xy_line = split_whitespace(lines[1 + 2 * i]);
            let ab_line = split_whitespace(lines[1 + 2 * i + 1]);
            (xy_line.len() >= 2 && ab_line.len() >= 2) ==> {
                let x = string_to_int(xy_line[0]);
                let y = string_to_int(xy_line[1]);
                let a = string_to_int(ab_line[0]);
                let b = string_to_int(ab_line[1]);
                let expected_result = if b <= 2 * a {
                    b * (if x <= y { x } else { y }) + (if x >= y { x } else { y } - if x <= y { x } else { y }) * a
                } else {
                    a * (x + y)
                };
                i < output_lines.len() && string_to_int(output_lines[i]) == expected_result
            }
        }
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 &&
    (s[0] == '-' ==> s.len() > 1) &&
    forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 {
        Seq::empty()
    } else {
        split_by_char(s, '\n')
    }
}

spec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 {
        Seq::empty()
    } else {
        split_by_char(s, ' ')
    }
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![Seq::empty()]
    } else if s[0] == delimiter {
        seq![Seq::empty()].add(split_by_char(s.subrange(1, s.len() as int), delimiter))
    } else {
        let rest = split_by_char(s.subrange(1, s.len() as int), delimiter);
        if rest.len() == 0 {
            seq![s]
        } else {
            seq![s.subrange(0, 1).add(rest[0])].add(rest.subrange(1, rest.len() as int))
        }
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' && s.len() > 1 {
        -string_to_int_helper(s.subrange(1, s.len() as int))
    } else {
        string_to_int_helper(s)
    }
}

spec fn string_to_int_helper(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        if '0' <= s[0] <= '9' { s[0] as int - '0' as int } else { 0 }
    } else {
        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 +
        (if '0' <= s[s.len() - 1] <= '9' { s[s.len() - 1] as int - '0' as int } else { 0 })
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'].add(int_to_string_helper(-n))
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 {
        Seq::empty()
    } else {
        let digit_char = ((n % 10) + ('0' as int)) as char;
        int_to_string_helper(n / 10).push(digit_char)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (output: String)
    requires
        input@.len() > 0,
        valid_input(input@),
    ensures
        valid_output(output@, input@),
        correct_computation(input@, output@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2219.rs,94,94,1.0,153.408,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn min_steps_to_zero(n: nat, k: nat) -> nat {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    {
        let lines = split_lines_func(input);
        lines.len() >= 1 &&
        is_valid_number(lines[0]) && {
            let t = string_to_int_func(lines[0]);
            t >= 1 && t <= 100 &&
            lines.len() >= t + 1 &&
            forall|i: int| 1 <= i <= t ==> valid_test_case(#[trigger] lines[i])
        }
    }
}

spec fn valid_test_case(line: Seq<char>) -> bool {
    let parts = split_spaces_func(line);
    parts.len() == 2 &&
    is_valid_number(parts[0]) &&
    is_valid_number(parts[1]) && {
        let n = string_to_int_func(parts[0]);
        let k = string_to_int_func(parts[1]);
        n >= 1 && k >= 2
    }
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() >= 1 &&
    (s =~= seq!['0'] || (s[0] != '0' && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9')) &&
    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn expected_output(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let lines = split_lines_func(input);
    let t = string_to_int_func(lines[0]);
    let results = Seq::new(t as nat, |i: int| {
        let parts = split_spaces_func(lines[i+1]);
        let n = string_to_int_func(parts[0]);
        let k = string_to_int_func(parts[1]);
        nat_to_string_func(min_steps_to_zero(n as nat, k as nat))
    });
    join_lines_seq(results)
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    0
}

spec fn nat_to_string_func(n: nat) -> Seq<char> {
    seq![]
}

spec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn min_steps_to_zero(n: nat, k: nat) -> nat {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    {
        let lines = split_lines_func(input);
        lines.len() >= 1 &&
        is_valid_number(lines[0]) && {
            let t = string_to_int_func(lines[0]);
            t >= 1 && t <= 100 &&
            lines.len() >= t + 1 &&
            forall|i: int| 1 <= i <= t ==> valid_test_case(#[trigger] lines[i])
        }
    }
}

spec fn valid_test_case(line: Seq<char>) -> bool {
    let parts = split_spaces_func(line);
    parts.len() == 2 &&
    is_valid_number(parts[0]) &&
    is_valid_number(parts[1]) && {
        let n = string_to_int_func(parts[0]);
        let k = string_to_int_func(parts[1]);
        n >= 1 && k >= 2
    }
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() >= 1 &&
    (s =~= seq!['0'] || (s[0] != '0' && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9')) &&
    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn expected_output(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let lines = split_lines_func(input);
    let t = string_to_int_func(lines[0]);
    let results = Seq::new(t as nat, |i: int| {
        let parts = split_spaces_func(lines[i+1]);
        let n = string_to_int_func(parts[0]);
        let k = string_to_int_func(parts[1]);
        nat_to_string_func(min_steps_to_zero(n as nat, k as nat))
    });
    join_lines_seq(results)
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    0
}

spec fn nat_to_string_func(n: nat) -> Seq<char> {
    seq![]
}

spec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: String) -> (result: String)
// </vc-spec>
// <vc-code>
{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn min_steps_to_zero(n: nat, k: nat) -> nat {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    {\n        let lines = split_lines_func(input);\n        lines.len() >= 1 &&\n        is_valid_number(lines[0]) && {\n            let t = string_to_int_func(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() >= t + 1 &&\n            forall|i: int| 1 <= i <= t ==> valid_test_case(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn valid_test_case(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() == 2 &&\n    is_valid_number(parts[0]) &&\n    is_valid_number(parts[1]) && {\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        n >= 1 && k >= 2\n    }\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() >= 1 &&\n    (s =~= seq!['0'] || (s[0] != '0' && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9')) &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_lines_func(input);\n    let t = string_to_int_func(lines[0]);\n    let results = Seq::new(t as nat, |i: int| {\n        let parts = split_spaces_func(lines[i+1]);\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        nat_to_string_func(min_steps_to_zero(n as nat, k as nat))\n    });\n    join_lines_seq(results)\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn nat_to_string_func(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: String) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2252.rs,128,128,1.0,183.813,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && 
    {
        let first_line = parse_integers(lines[0]);
        first_line.len() == 2 &&
        {
            let n = first_line[0];
            let m = first_line[1];
            n >= 1 && m >= 0 &&
            parse_integers(lines[1]).len() == n &&
            is_valid_permutation(parse_integers(lines[1]), n) &&
            lines.len() == 2 + m &&
            (forall|i: int| 2 <= i < lines.len() ==> {
                let query = parse_integers(#[trigger] lines[i]);
                query.len() == 3 &&
                {
                    let l = query[0];
                    let r = query[1];
                    let x = query[2];
                    1 <= l <= x <= r <= n
                }
            })
        }
    }
}

spec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {
    p.len() == n && 
    (forall|i: int| 0 <= i < p.len() ==> 1 <= #[trigger] p[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < p.len() ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn valid_output_format(output: Seq<char>) -> bool {
    let lines = split_lines(output);
    forall|line: Seq<char>| #[trigger] lines.contains(line) ==> (seq_equals(line, seq!['Y','e','s']) || seq_equals(line, seq!['N','o']))
}

spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {
    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == s2[i]
}

spec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {
    let input_lines = split_lines(input);
    let output_lines = split_lines(output);
    if input_lines.len() < 2 { false }
    else {
        let first_line = parse_integers(input_lines[0]);
        if first_line.len() != 2 { false }
        else {
            let n = first_line[0];
            let m = first_line[1];
            input_lines.len() == 2 + m &&
            output_lines.len() == m &&
            {
                let p = parse_integers(input_lines[1]);
                forall|i: int| 0 <= i < m ==> {
                    let query = parse_integers(input_lines[2 + i]);
                    let l = query[0];
                    let r = query[1]; 
                    let x = query[2];
                    let px = p[x - 1];
                    let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);
                    seq_equals(#[trigger] output_lines[i], if cnt == x { seq!['Y','e','s'] } else { seq!['N','o'] })
                }
            }
        }
    }
}

spec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int
    decreases if start <= end { end - start + 1 } else { 0 }
{
    if start > end { 0int }
    else if start < 0 || start >= p.len() { 0int }
    else { (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value) }
}

spec fn parse_integers(line: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else {
        let idx = find_newline(s, 0);
        if idx == -1 { seq![s] }
        else if idx >= 0 && idx < s.len() && idx + 1 <= s.len() {
            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx+1, s.len() as int)))
        } else { seq![s] }
    }
}

spec fn find_newline(s: Seq<char>, start: nat) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start as int] == '\n' { start as int }
    else { find_newline(s, start + 1) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && 
    {
        let first_line = parse_integers(lines[0]);
        first_line.len() == 2 &&
        {
            let n = first_line[0];
            let m = first_line[1];
            n >= 1 && m >= 0 &&
            parse_integers(lines[1]).len() == n &&
            is_valid_permutation(parse_integers(lines[1]), n) &&
            lines.len() == 2 + m &&
            (forall|i: int| 2 <= i < lines.len() ==> {
                let query = parse_integers(#[trigger] lines[i]);
                query.len() == 3 &&
                {
                    let l = query[0];
                    let r = query[1];
                    let x = query[2];
                    1 <= l <= x <= r <= n
                }
            })
        }
    }
}

spec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {
    p.len() == n && 
    (forall|i: int| 0 <= i < p.len() ==> 1 <= #[trigger] p[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < p.len() ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn valid_output_format(output: Seq<char>) -> bool {
    let lines = split_lines(output);
    forall|line: Seq<char>| #[trigger] lines.contains(line) ==> (seq_equals(line, seq!['Y','e','s']) || seq_equals(line, seq!['N','o']))
}

spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {
    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == s2[i]
}

spec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {
    let input_lines = split_lines(input);
    let output_lines = split_lines(output);
    if input_lines.len() < 2 { false }
    else {
        let first_line = parse_integers(input_lines[0]);
        if first_line.len() != 2 { false }
        else {
            let n = first_line[0];
            let m = first_line[1];
            input_lines.len() == 2 + m &&
            output_lines.len() == m &&
            {
                let p = parse_integers(input_lines[1]);
                forall|i: int| 0 <= i < m ==> {
                    let query = parse_integers(input_lines[2 + i]);
                    let l = query[0];
                    let r = query[1]; 
                    let x = query[2];
                    let px = p[x - 1];
                    let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);
                    seq_equals(#[trigger] output_lines[i], if cnt == x { seq!['Y','e','s'] } else { seq!['N','o'] })
                }
            }
        }
    }
}

spec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int
    decreases if start <= end { end - start + 1 } else { 0 }
{
    if start > end { 0int }
    else if start < 0 || start >= p.len() { 0int }
    else { (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value) }
}

spec fn parse_integers(line: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else {
        let idx = find_newline(s, 0);
        if idx == -1 { seq![s] }
        else if idx >= 0 && idx < s.len() && idx + 1 <= s.len() {
            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx+1, s.len() as int)))
        } else { seq![s] }
    }
}

spec fn find_newline(s: Seq<char>, start: nat) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start as int] == '\n' { start as int }
    else { find_newline(s, start + 1) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && \n    {\n        let first_line = parse_integers(lines[0]);\n        first_line.len() == 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 0 &&\n            parse_integers(lines[1]).len() == n &&\n            is_valid_permutation(parse_integers(lines[1]), n) &&\n            lines.len() == 2 + m &&\n            (forall|i: int| 2 <= i < lines.len() ==> {\n                let query = parse_integers(#[trigger] lines[i]);\n                query.len() == 3 &&\n                {\n                    let l = query[0];\n                    let r = query[1];\n                    let x = query[2];\n                    1 <= l <= x <= r <= n\n                }\n            })\n        }\n    }\n}\n\nspec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {\n    p.len() == n && \n    (forall|i: int| 0 <= i < p.len() ==> 1 <= #[trigger] p[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < p.len() ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    let lines = split_lines(output);\n    forall|line: Seq<char>| #[trigger] lines.contains(line) ==> (seq_equals(line, seq!['Y','e','s']) || seq_equals(line, seq!['N','o']))\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == s2[i]\n}\n\nspec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_lines(input);\n    let output_lines = split_lines(output);\n    if input_lines.len() < 2 { false }\n    else {\n        let first_line = parse_integers(input_lines[0]);\n        if first_line.len() != 2 { false }\n        else {\n            let n = first_line[0];\n            let m = first_line[1];\n            input_lines.len() == 2 + m &&\n            output_lines.len() == m &&\n            {\n                let p = parse_integers(input_lines[1]);\n                forall|i: int| 0 <= i < m ==> {\n                    let query = parse_integers(input_lines[2 + i]);\n                    let l = query[0];\n                    let r = query[1]; \n                    let x = query[2];\n                    let px = p[x - 1];\n                    let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);\n                    seq_equals(#[trigger] output_lines[i], if cnt == x { seq!['Y','e','s'] } else { seq!['N','o'] })\n                }\n            }\n        }\n    }\n}\n\nspec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int\n    decreases if start <= end { end - start + 1 } else { 0 }\n{\n    if start > end { 0int }\n    else if start < 0 || start >= p.len() { 0int }\n    else { (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value) }\n}\n\nspec fn parse_integers(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else {\n        let idx = find_newline(s, 0);\n        if idx == -1 { seq![s] }\n        else if idx >= 0 && idx < s.len() && idx + 1 <= s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx+1, s.len() as int)))\n        } else { seq![s] }\n    }\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start as int] == '\\n' { start as int }\n    else { find_newline(s, start + 1) }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_232.rs,64,64,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_occurrences(s: Seq<nat>, value: nat) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == value {
        1 + count_occurrences(s.subrange(1, s.len() as int), value)
    } else {
        count_occurrences(s.subrange(1, s.len() as int), value)
    }
}

spec fn sum_seq(s: Seq<nat>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn subarray_matches_desired(subarray: Seq<nat>, desired: Seq<nat>, m: nat) -> bool
{
    desired.len() == m &&
    forall|color: nat| #[trigger] count_occurrences(subarray, color) == desired[color as int - 1] && 1 <= color <= m
}

spec fn valid_input(n: nat, m: nat, colors: Seq<nat>, desired: Seq<nat>) -> bool
{
    colors.len() == n &&
    desired.len() == m &&
    (forall|i: int| #[trigger] colors[i] >= 1 && colors[i] <= m && 0 <= i < colors.len()) &&
    (forall|i: int| #[trigger] desired[i] >= 0 && 0 <= i < desired.len()) &&
    sum_seq(desired) <= n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, m: u8, colors: Vec<u8>, desired: Vec<u8>) -> (result: String)
    requires
        valid_input(n as nat, m as nat, colors@.map(|i, x| x as nat), desired@.map(|i, x| x as nat)),
    ensures
        result@ == seq!['Y' as char, 'E' as char, 'S' as char] <==> exists|i: int, j: int| 0 <= i <= j < n as int && #[trigger] subarray_matches_desired(colors@.map(|k, x| x as nat).subrange(i, j + 1), desired@.map(|k, x| x as nat), m as nat),
        result@ == seq!['Y' as char, 'E' as char, 'S' as char] || result@ == seq!['N' as char, 'O' as char],
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_occurrences(s: Seq<nat>, value: nat) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == value {
        1 + count_occurrences(s.subrange(1, s.len() as int), value)
    } else {
        count_occurrences(s.subrange(1, s.len() as int), value)
    }
}

spec fn sum_seq(s: Seq<nat>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn subarray_matches_desired(subarray: Seq<nat>, desired: Seq<nat>, m: nat) -> bool
{
    desired.len() == m &&
    forall|color: nat| #[trigger] count_occurrences(subarray, color) == desired[color as int - 1] && 1 <= color <= m
}

spec fn valid_input(n: nat, m: nat, colors: Seq<nat>, desired: Seq<nat>) -> bool
{
    colors.len() == n &&
    desired.len() == m &&
    (forall|i: int| #[trigger] colors[i] >= 1 && colors[i] <= m && 0 <= i < colors.len()) &&
    (forall|i: int| #[trigger] desired[i] >= 0 && 0 <= i < desired.len()) &&
    sum_seq(desired) <= n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: u8, m: u8, colors: Vec<u8>, desired: Vec<u8>) -> (result: String)
    requires
        valid_input(n as nat, m as nat, colors@.map(|i, x| x as nat), desired@.map(|i, x| x as nat)),
    ensures
        result@ == seq!['Y' as char, 'E' as char, 'S' as char] <==> exists|i: int, j: int| 0 <= i <= j < n as int && #[trigger] subarray_matches_desired(colors@.map(|k, x| x as nat).subrange(i, j + 1), desired@.map(|k, x| x as nat), m as nat),
        result@ == seq!['Y' as char, 'E' as char, 'S' as char] || result@ == seq!['N' as char, 'O' as char],
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO"".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2321.rs,129,129,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_valid_string(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn is_valid_problem_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == '>' || #[trigger] s[i] == '<'
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn string_to_int(s: Seq<char>) -> int {
    if is_valid_integer_string(s) {
        string_to_int_helper(s, s.len() as int)
    } else {
        0
    }
}

spec fn string_to_int_helper(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos <= 0 || pos > s.len() { 
        0 
    } else if !forall|i: int| 0 <= i < pos ==> '0' <= #[trigger] s[i] <= '9' {
        0
    } else if pos == 0 { 
        0 
    } else { 
        string_to_int_helper(s, pos - 1) * 10 + (s[pos - 1] as int - '0' as int) 
    }
}

spec fn min_deletions_needed(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        let first_greater = first_greater_from_left(s);
        let first_less_from_right = first_less_from_right(s);
        if first_greater < first_less_from_right { first_greater } else { first_less_from_right }
    } else {
        0
    }
}

spec fn first_greater_from_left(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        first_greater_from_left_helper(s, 0)
    } else {
        s.len() as int
    }
}

spec fn first_greater_from_left_helper(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if !is_valid_problem_string(s) || pos < 0 || pos > s.len() {
        s.len() as int
    } else if pos >= s.len() { 
        s.len() as int 
    } else if s[pos] == '>' { 
        pos 
    } else { 
        first_greater_from_left_helper(s, pos + 1) 
    }
}

spec fn first_less_from_right(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        first_less_from_right_helper(s, s.len() as int - 1)
    } else {
        s.len() as int
    }
}

spec fn first_less_from_right_helper(s: Seq<char>, pos: int) -> int
    decreases pos + 1
{
    if !is_valid_problem_string(s) || pos >= s.len() || pos < -1 {
        s.len() as int
    } else if pos < 0 { 
        s.len() as int 
    } else if s[pos] == '<' { 
        s.len() as int - 1 - pos 
    } else { 
        first_less_from_right_helper(s, pos - 1) 
    }
}

spec fn min(a: int, b: int) -> int {
    if a < b { a } else { b }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(lines: Vec<Vec<char>>) -> (results: Vec<i8>)
    requires 
        lines@.len() > 0,
        forall|i: int| 0 <= i < lines@.len() ==> is_valid_string(lines@[i]),
        is_valid_integer_string(lines@[0]),
        ({let t = string_to_int(lines@[0]); lines@.len() >= 1 + 2 * t}),
        forall|i: int| 0 <= i < string_to_int(lines@[0]) ==> 
            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])
    ensures 
        results@.len() == string_to_int(lines@[0]),
        forall|r: i8| #[trigger] results@.contains(r) ==> r as int >= 0,
        forall|i: int| 0 <= i < results@.len() ==> 
            #[trigger] results@[i] as int == min_deletions_needed(lines@[2 + 2*i])
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_valid_string(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn is_valid_problem_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == '>' || #[trigger] s[i] == '<'
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn string_to_int(s: Seq<char>) -> int {
    if is_valid_integer_string(s) {
        string_to_int_helper(s, s.len() as int)
    } else {
        0
    }
}

spec fn string_to_int_helper(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos <= 0 || pos > s.len() { 
        0 
    } else if !forall|i: int| 0 <= i < pos ==> '0' <= #[trigger] s[i] <= '9' {
        0
    } else if pos == 0 { 
        0 
    } else { 
        string_to_int_helper(s, pos - 1) * 10 + (s[pos - 1] as int - '0' as int) 
    }
}

spec fn min_deletions_needed(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        let first_greater = first_greater_from_left(s);
        let first_less_from_right = first_less_from_right(s);
        if first_greater < first_less_from_right { first_greater } else { first_less_from_right }
    } else {
        0
    }
}

spec fn first_greater_from_left(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        first_greater_from_left_helper(s, 0)
    } else {
        s.len() as int
    }
}

spec fn first_greater_from_left_helper(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if !is_valid_problem_string(s) || pos < 0 || pos > s.len() {
        s.len() as int
    } else if pos >= s.len() { 
        s.len() as int 
    } else if s[pos] == '>' { 
        pos 
    } else { 
        first_greater_from_left_helper(s, pos + 1) 
    }
}

spec fn first_less_from_right(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        first_less_from_right_helper(s, s.len() as int - 1)
    } else {
        s.len() as int
    }
}

spec fn first_less_from_right_helper(s: Seq<char>, pos: int) -> int
    decreases pos + 1
{
    if !is_valid_problem_string(s) || pos >= s.len() || pos < -1 {
        s.len() as int
    } else if pos < 0 { 
        s.len() as int 
    } else if s[pos] == '<' { 
        s.len() as int - 1 - pos 
    } else { 
        first_less_from_right_helper(s, pos - 1) 
    }
}

spec fn min(a: int, b: int) -> int {
    if a < b { a } else { b }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(lines: Vec<Vec<char>>) -> (results: Vec<i8>)
    requires 
        lines@.len() > 0,
        forall|i: int| 0 <= i < lines@.len() ==> is_valid_string(lines@[i]),
        is_valid_integer_string(lines@[0]),
        ({let t = string_to_int(lines@[0]); lines@.len() >= 1 + 2 * t}),
        forall|i: int| 0 <= i < string_to_int(lines@[0]) ==> 
            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])
    ensures 
        results@.len() == string_to_int(lines@[0]),
        forall|r: i8| #[trigger] results@.contains(r) ==> r as int >= 0,
        forall|i: int| 0 <= i < results@.len() ==> 
            #[trigger] results@[i] as int == min_deletions_needed(lines@[2 + 2*i])
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2362.rs,109,109,1.0,92.094,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
  stdin_input.len() > 0 && 
  has_valid_tree_structure(stdin_input) &&
  all_vertex_values_in_range(stdin_input) &&
  vertex_count_in_range(stdin_input)
}

spec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)
}

spec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && exists_path_with_common_prime_factor(stdin_input)
}

spec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && !has_common_prime_paths(stdin_input)
}

spec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {
  if valid_input_format(stdin_input) && has_common_prime_paths(stdin_input) {
    1
  } else {
    0
  }
}

spec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {
  true
}

spec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {
  true
}

spec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {
  true
}

spec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {
  true
}

spec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {
  0
}

spec fn get_vertex_count(stdin_input: Seq<char>) -> int {
  if valid_input_format(stdin_input) {
    1
  } else {
    0
  }
}

spec fn int_to_string_spec(x: int) -> Seq<char>
  decreases x
{
  if x >= 0 {
    if x == 0 { seq!['0'] }
    else if x < 10 { seq![char_of_digit(x)] }
    else { int_to_string_spec(x / 10).add(seq![char_of_digit(x % 10)]) }
  } else {
    seq!['0']
  }
}

spec fn char_of_digit(d: int) -> char {
  if 0 <= d && d <= 9 {
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else { '9' }
  } else {
    '0'
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
  stdin_input.len() > 0 && 
  has_valid_tree_structure(stdin_input) &&
  all_vertex_values_in_range(stdin_input) &&
  vertex_count_in_range(stdin_input)
}

spec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)
}

spec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && exists_path_with_common_prime_factor(stdin_input)
}

spec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && !has_common_prime_paths(stdin_input)
}

spec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {
  if valid_input_format(stdin_input) && has_common_prime_paths(stdin_input) {
    1
  } else {
    0
  }
}

spec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {
  true
}

spec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {
  true
}

spec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {
  true
}

spec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {
  true
}

spec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {
  0
}

spec fn get_vertex_count(stdin_input: Seq<char>) -> int {
  if valid_input_format(stdin_input) {
    1
  } else {
    0
  }
}

spec fn int_to_string_spec(x: int) -> Seq<char>
  decreases x
{
  if x >= 0 {
    if x == 0 { seq!['0'] }
    else if x < 10 { seq![char_of_digit(x)] }
    else { int_to_string_spec(x / 10).add(seq![char_of_digit(x % 10)]) }
  } else {
    seq!['0']
  }
}

spec fn char_of_digit(d: int) -> char {
  if 0 <= d && d <= 9 {
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else { '9' }
  } else {
    '0'
  }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n  stdin_input.len() > 0 && \n  has_valid_tree_structure(stdin_input) &&\n  all_vertex_values_in_range(stdin_input) &&\n  vertex_count_in_range(stdin_input)\n}\n\nspec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)\n}\n\nspec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && exists_path_with_common_prime_factor(stdin_input)\n}\n\nspec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && !has_common_prime_paths(stdin_input)\n}\n\nspec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) && has_common_prime_paths(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {\n  0\n}\n\nspec fn get_vertex_count(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn int_to_string_spec(x: int) -> Seq<char>\n  decreases x\n{\n  if x >= 0 {\n    if x == 0 { seq!['0'] }\n    else if x < 10 { seq![char_of_digit(x)] }\n    else { int_to_string_spec(x / 10).add(seq![char_of_digit(x % 10)]) }\n  } else {\n    seq!['0']\n  }\n}\n\nspec fn char_of_digit(d: int) -> char {\n  if 0 <= d && d <= 9 {\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else { '9' }\n  } else {\n    '0'\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2411.rs,126,55,0.4365079365079365,215.086,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn is_valid_first_line(line: Seq<char>) -> bool {
    true
}

spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {
    0
}

spec fn is_valid_coordinate_line(line: Seq<char>) -> bool {
    true
}

spec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> {
    seq![]
}

spec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> {
    seq![]
}

spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat {
    0
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() as int - 1] == '\n' &&
    {
        let lines = split_lines(input);
        lines.len() >= 3 && lines.len() <= 1001 &&
        is_valid_first_line(lines[0]) &&
        {
            let n = parse_first_line_as_nat(lines[0]);
            n >= 2 && n <= 1000 && lines.len() == n + 1 &&
            forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(#[trigger] lines[i])
        }
    }
}

spec fn is_non_negative_numeric_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn valid_coordinate(point: (int, int)) -> bool {
    let (x, y) = point;
    -10000 <= x <= 10000 && -10000 <= y <= 10000
}

spec fn extract_n(input: Seq<char>) -> nat {
    if valid_input_format(input) {
        let lines = split_lines(input);
        parse_first_line_as_nat(lines[0])
    } else {
        0
    }
}

spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {
    if valid_input_format(input) {
        seq![(0, 0), (1, 1)]
    } else {
        seq![]
    }
}

spec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {
    if points.len() >= 2 &&
       forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j] &&
       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i]) {
        let distinct_lines = get_distinct_lines(points);
        let slope_groups = group_lines_by_slope(distinct_lines);
        let total_lines = distinct_lines.len();
        (sum_over_slope_groups(slope_groups, total_lines)) / 2
    } else {
        0
    }
}

spec fn string_to_int(s: Seq<char>) -> nat {
    if is_non_negative_numeric_string(s) {
        0
    } else {
        0
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0 &&
        valid_input_format(stdin_input)
    ensures 
        result.len() > 0 &&
        is_non_negative_numeric_string(result) &&
        ({
            let n = extract_n(stdin_input);
            let points = extract_points(stdin_input);
            points.len() == n && n >= 2 && n <= 1000 &&
            (forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i])) &&
            (forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j]) &&
            string_to_int(result) == count_intersecting_line_pairs(points)
        })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;
       spec fn is_valid_first_line(line: Seq<char>) -> bool ;
       spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {
          0 }
       spec fn is_valid_coordinate_line(line: Seq<char>) -> bool ;
       spec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> ;
       spec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> ;
       spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat ;
       spec fn valid_input_format(input: Seq<char>) -> bool {
          input.len() > 0 && input[input.len() as int - 1] == '\n' &&     {
             let lines = split_lines(input);
             lines.len() >= 3 && lines.len() <= 1001 &&         is_valid_first_line(lines[0]) &&         {
                let n = parse_first_line_as_nat(lines[0]);
                n >= 2 && n <= 1000 && lines.len() == n + 1 &&             forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(       
#[trigger] lines[i])
        }
         }
      }
       spec fn is_non_negative_numeric_string(s: Seq<char>) -> bool ;
       spec fn valid_coordinate(point: (int, int)) -> bool ;
       spec fn extract_n(input: Seq<char>) -> nat ;
       spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {
          if valid_input_format(input) {
             seq![(0, 0), (1, 1)]     }
      else {
             seq![]     }
      }
       spec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {
          if points.len() >= 2 &&        forall|i: int, j: int| 0 <= i < j < points.len() ==>        
#[trigger] points[i] != #[trigger] points[j] &&
       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(       
#[trigger] points[i]) {
        let distinct_lines = get_distinct_lines(points);
              let slope_groups = group_lines_by_slope(distinct_lines);
              let total_lines = distinct_lines.len();
              (sum_over_slope_groups(slope_groups, total_lines)) / 2     }
       else {
              0     }
       }
        spec fn string_to_int(s: Seq<char>) -> nat {
           if is_non_negative_numeric_string(s) {
              0     }
       else {
              0     }
       }
        fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)     requires          stdin_input.len() > 0 &&         valid_input_format(stdin_input)     ensures          result.len() > 0 &&         is_non_negative_numeric_string(result) &&         ({
                   let points = extract_points(stdin_input);
                 string_to_int(result) == count_intersecting_line_pairs(points)         }
       ) {
           unreached() }
        }
        fn main() {
       }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n    0\n}\n\nspec fn is_valid_coordinate_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> {\n    seq![]\n}\n\nspec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> {\n    seq![]\n}\n\nspec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat {\n    0\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 3 && lines.len() <= 1001 &&\n        is_valid_first_line(lines[0]) &&\n        {\n            let n = parse_first_line_as_nat(lines[0]);\n            n >= 2 && n <= 1000 && lines.len() == n + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn is_non_negative_numeric_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn valid_coordinate(point: (int, int)) -> bool {\n    let (x, y) = point;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000\n}\n\nspec fn extract_n(input: Seq<char>) -> nat {\n    if valid_input_format(input) {\n        let lines = split_lines(input);\n        parse_first_line_as_nat(lines[0])\n    } else {\n        0\n    }\n}\n\nspec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n    if valid_input_format(input) {\n        seq![(0, 0), (1, 1)]\n    } else {\n        seq![]\n    }\n}\n\nspec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {\n    if points.len() >= 2 &&\n       forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j] &&\n       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i]) {\n        let distinct_lines = get_distinct_lines(points);\n        let slope_groups = group_lines_by_slope(distinct_lines);\n        let total_lines = distinct_lines.len();\n        (sum_over_slope_groups(slope_groups, total_lines)) / 2\n    } else {\n        0\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    if is_non_negative_numeric_string(s) {\n        0\n    } else {\n        0\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0 &&\n        valid_input_format(stdin_input)\n    ensures \n        result.len() > 0 &&\n        is_non_negative_numeric_string(result) &&\n        ({\n            let n = extract_n(stdin_input);\n            let points = extract_points(stdin_input);\n            points.len() == n && n >= 2 && n <= 1000 &&\n            (forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i])) &&\n            (forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j]) &&\n            string_to_int(result) == count_intersecting_line_pairs(points)\n        })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', ""use vstd::prelude::*;\n        verus! {\n       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn is_valid_first_line(line: Seq<char>) -> bool ;\n       spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n          0 }\n       spec fn is_valid_coordinate_line(line: Seq<char>) -> bool ;\n       spec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> ;\n       spec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> ;\n       spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat ;\n       spec fn valid_input_format(input: Seq<char>) -> bool {\n          input.len() > 0 && input[input.len() as int - 1] == '\\n' &&     {\n             let lines = split_lines(input);\n             lines.len() >= 3 && lines.len() <= 1001 &&         is_valid_first_line(lines[0]) &&         {\n                let n = parse_first_line_as_nat(lines[0]);\n                n >= 2 && n <= 1000 && lines.len() == n + 1 &&             forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(       \n#[trigger] lines[i])\n        }\n         }\n      }\n       spec fn is_non_negative_numeric_string(s: Seq<char>) -> bool ;\n       spec fn valid_coordinate(point: (int, int)) -> bool ;\n       spec fn extract_n(input: Seq<char>) -> nat ;\n       spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n          if valid_input_format(input) {\n             seq![(0, 0), (1, 1)]     }\n      else {\n             seq![]     }\n      }\n       spec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {\n          if points.len() >= 2 &&        forall|i: int, j: int| 0 <= i < j < points.len() ==>        \n#[trigger] points[i] != #[trigger] points[j] &&\n       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(       \n#[trigger] points[i]) {\n        let distinct_lines = get_distinct_lines(points);\n              let slope_groups = group_lines_by_slope(distinct_lines);\n              let total_lines = distinct_lines.len();\n              (sum_over_slope_groups(slope_groups, total_lines)) / 2     }\n       else {\n              0     }\n       }\n        spec fn string_to_int(s: Seq<char>) -> nat {\n           if is_non_negative_numeric_string(s) {\n              0     }\n       else {\n              0     }\n       }\n        fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)     requires          stdin_input.len() > 0 &&         valid_input_format(stdin_input)     ensures          result.len() > 0 &&         is_non_negative_numeric_string(result) &&         ({\n                   let points = extract_points(stdin_input);\n                 string_to_int(result) == count_intersecting_line_pairs(points)         }\n       ) {\n           unreached() }\n        }\n        fn main() {\n       }\n"", 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2431.rs,77,77,1.0,92.237,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

struct TestCase {
    n: nat,
    x: nat,
    y: nat,
    z: nat,
    castles: Seq<nat>,
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    true /* TODO: implement input validation */
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    output.len() > 0 &&
    valid_output_structure(input, output)
}

spec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {
    true /* TODO: implement output validation */
}

spec fn get_test_count(s: Seq<char>) -> nat
    recommends valid_input(s)
{
    1 /* TODO: implement test count parsing */
}

spec fn get_test_case(s: Seq<char>, i: nat) -> TestCase
    recommends valid_input(s) && i < get_test_count(s)
{
    TestCase {
        n: 1,
        x: 1,
        y: 1,
        z: 1,
        castles: seq![1],
    }
}

spec fn count_winning_first_moves(tc: TestCase) -> nat {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

struct TestCase {
    n: nat,
    x: nat,
    y: nat,
    z: nat,
    castles: Seq<nat>,
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    true /* TODO: implement input validation */
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    output.len() > 0 &&
    valid_output_structure(input, output)
}

spec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {
    true /* TODO: implement output validation */
}

spec fn get_test_count(s: Seq<char>) -> nat
    recommends valid_input(s)
{
    1 /* TODO: implement test count parsing */
}

spec fn get_test_case(s: Seq<char>, i: nat) -> TestCase
    recommends valid_input(s) && i < get_test_count(s)
{
    TestCase {
        n: 1,
        x: 1,
        y: 1,
        z: 1,
        castles: seq![1],
    }
}

spec fn count_winning_first_moves(tc: TestCase) -> nat {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nstruct TestCase {\n    n: nat,\n    x: nat,\n    y: nat,\n    z: nat,\n    castles: Seq<nat>,\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    true /* TODO: implement input validation */\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    output.len() > 0 &&\n    valid_output_structure(input, output)\n}\n\nspec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {\n    true /* TODO: implement output validation */\n}\n\nspec fn get_test_count(s: Seq<char>) -> nat\n    recommends valid_input(s)\n{\n    1 /* TODO: implement test count parsing */\n}\n\nspec fn get_test_case(s: Seq<char>, i: nat) -> TestCase\n    recommends valid_input(s) && i < get_test_count(s)\n{\n    TestCase {\n        n: 1,\n        x: 1,\n        y: 1,\n        z: 1,\n        castles: seq![1],\n    }\n}\n\nspec fn count_winning_first_moves(tc: TestCase) -> nat {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2446.rs,144,144,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 3 &&
    parse_int_func(lines[0]) > 0 &&
    parse_int_func(lines[2]) >= 0 &&
    lines.len() >= 3 + parse_int_func(lines[2]) &&
    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&
    (forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] > 0) &&
    forall|i: int| 0 <= i < parse_int_func(lines[2]) ==> parse_int_func(lines[3 + i]) > 0
}

spec fn get_expected_results(input: Seq<char>) -> Seq<int> {
    let lines = split_lines_func(input);
    let arr = parse_int_array_func(lines[1]);
    let q = parse_int_func(lines[2]);
    Seq::new(q as nat, |i: int| count_subarrays_with_gcd(arr, parse_int_func(lines[3 + i])))
}

spec fn format_output(results: Seq<int>) -> Seq<char> {
    if results.len() == 0 { seq![] }
    else if results.len() == 1 { 
        int_to_string_func(results[0])
    }
    else {
        int_to_string_func(results[0]) + seq!['\n'] + format_output(results.subrange(1, results.len() as int))
    }
}

spec fn count_subarrays_with_gcd(arr: Seq<int>, target: int) -> int {
    let pairs = subarray_pairs(arr);
    pairs.filter(|pair: (int, int)| subarray_gcd(arr, pair.0, pair.1) == target).len() as int
}

spec fn subarray_pairs(arr: Seq<int>) -> Set<(int, int)> {
    Set::new(|pair: (int, int)| 0 <= pair.0 <= pair.1 < arr.len())
}

spec fn subarray_gcd(arr: Seq<int>, start: int, end: int) -> int
    decreases end - start
{
    if start == end { arr[start] }
    else {
        let rest = subarray_gcd(arr, start + 1, end);
        gcd(arr[start], rest)
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(s, 0, seq![], seq![])
}

spec fn parse_int_func(s: Seq<char>) -> int {
    parse_int_helper(s, 0, 0)
}

spec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {
    parse_int_array_helper(s, 0, seq![], seq![])
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n, seq![]) }
}

spec fn split_lines_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {
    if pos >= s.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else {
        if s[pos] == '\n' {
            split_lines_helper(s, pos + 1, seq![], acc.push(current))
        } else {
            split_lines_helper(s, pos + 1, current.push(s[pos]), acc)
        }
    }
}

spec fn parse_int_helper(s: Seq<char>, pos: int, acc: int) -> int {
    if pos >= s.len() { acc }
    else {
        let c = s[pos];
        if c >= '0' && c <= '9' {
            parse_int_helper(s, pos + 1, acc * 10 + (c as int - '0' as int))
        } else {
            acc
        }
    }
}

spec fn parse_int_array_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<int>) -> Seq<int> {
    if pos >= s.len() {
        if current.len() > 0 { acc.push(parse_int_func(current)) } else { acc }
    } else {
        let c = s[pos];
        if c == ' ' || c == '\t' {
            if current.len() > 0 {
                parse_int_array_helper(s, pos + 1, seq![], acc.push(parse_int_func(current)))
            } else {
                parse_int_array_helper(s, pos + 1, current, acc)
            }
        } else {
            parse_int_array_helper(s, pos + 1, current.push(c), acc)
        }
    }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char> {
    if n == 0 { acc }
    else { int_to_string_helper(n / 10, seq![(n % 10) as char] + acc) }
}

spec fn gcd(a: int, b: int) -> int {
    if b == 0 { a } else { gcd(b, a % b) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires 
        input.len() > 0,
        valid_input(input),
    ensures 
        result == format_output(get_expected_results(input)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 3 &&
    parse_int_func(lines[0]) > 0 &&
    parse_int_func(lines[2]) >= 0 &&
    lines.len() >= 3 + parse_int_func(lines[2]) &&
    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&
    (forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] > 0) &&
    forall|i: int| 0 <= i < parse_int_func(lines[2]) ==> parse_int_func(lines[3 + i]) > 0
}

spec fn get_expected_results(input: Seq<char>) -> Seq<int> {
    let lines = split_lines_func(input);
    let arr = parse_int_array_func(lines[1]);
    let q = parse_int_func(lines[2]);
    Seq::new(q as nat, |i: int| count_subarrays_with_gcd(arr, parse_int_func(lines[3 + i])))
}

spec fn format_output(results: Seq<int>) -> Seq<char> {
    if results.len() == 0 { seq![] }
    else if results.len() == 1 { 
        int_to_string_func(results[0])
    }
    else {
        int_to_string_func(results[0]) + seq!['\n'] + format_output(results.subrange(1, results.len() as int))
    }
}

spec fn count_subarrays_with_gcd(arr: Seq<int>, target: int) -> int {
    let pairs = subarray_pairs(arr);
    pairs.filter(|pair: (int, int)| subarray_gcd(arr, pair.0, pair.1) == target).len() as int
}

spec fn subarray_pairs(arr: Seq<int>) -> Set<(int, int)> {
    Set::new(|pair: (int, int)| 0 <= pair.0 <= pair.1 < arr.len())
}

spec fn subarray_gcd(arr: Seq<int>, start: int, end: int) -> int
    decreases end - start
{
    if start == end { arr[start] }
    else {
        let rest = subarray_gcd(arr, start + 1, end);
        gcd(arr[start], rest)
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(s, 0, seq![], seq![])
}

spec fn parse_int_func(s: Seq<char>) -> int {
    parse_int_helper(s, 0, 0)
}

spec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {
    parse_int_array_helper(s, 0, seq![], seq![])
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n, seq![]) }
}

spec fn split_lines_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {
    if pos >= s.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else {
        if s[pos] == '\n' {
            split_lines_helper(s, pos + 1, seq![], acc.push(current))
        } else {
            split_lines_helper(s, pos + 1, current.push(s[pos]), acc)
        }
    }
}

spec fn parse_int_helper(s: Seq<char>, pos: int, acc: int) -> int {
    if pos >= s.len() { acc }
    else {
        let c = s[pos];
        if c >= '0' && c <= '9' {
            parse_int_helper(s, pos + 1, acc * 10 + (c as int - '0' as int))
        } else {
            acc
        }
    }
}

spec fn parse_int_array_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<int>) -> Seq<int> {
    if pos >= s.len() {
        if current.len() > 0 { acc.push(parse_int_func(current)) } else { acc }
    } else {
        let c = s[pos];
        if c == ' ' || c == '\t' {
            if current.len() > 0 {
                parse_int_array_helper(s, pos + 1, seq![], acc.push(parse_int_func(current)))
            } else {
                parse_int_array_helper(s, pos + 1, current, acc)
            }
        } else {
            parse_int_array_helper(s, pos + 1, current.push(c), acc)
        }
    }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char> {
    if n == 0 { acc }
    else { int_to_string_helper(n / 10, seq![(n % 10) as char] + acc) }
}

spec fn gcd(a: int, b: int) -> int {
    if b == 0 { a } else { gcd(b, a % b) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires 
        input.len() > 0,
        valid_input(input),
    ensures 
        result == format_output(get_expected_results(input)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2447.rs,102,102,1.0,153.573,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    true
}

spec fn parse_int(s: Seq<char>) -> int
    recommends is_valid_number(s)
{
    0
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    true
}

spec fn ends_with_newline(s: Seq<char>) -> bool {
    s.len() > 0 && s[s.len() - 1] == '\n'
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() - 1] == '\n' &&
    {
        let lines = split_lines(input);
        lines.len() >= 2 &&
        is_valid_number(lines[0]) &&
        {
            let t = parse_int(lines[0]);
            t >= 1 && t <= 100 &&
            lines.len() == t + 1 &&
            forall|i: int| 1 <= i < lines.len() ==> 
                is_binary_string(lines[i]) && lines[i].len() >= 1 && lines[i].len() <= 1000
        }
    }
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 &&
    (ends_with_newline(result) || result.len() == 0) &&
    {
        let output_lines = split_lines(result);
        output_lines.len() >= 1 &&
        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> is_valid_number(output_lines[i])) &&
        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> parse_int(output_lines[i]) >= 0)
    }
}

spec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool
    recommends valid_input(input)
{
    {
        let input_lines = split_lines(input);
        let t = parse_int(input_lines[0]);
        let output_lines = split_lines(result);
        output_lines.len() == t + 1 &&
        forall|test_case: int| 0 <= test_case < t ==> #[trigger] parse_int(output_lines[test_case]) == min_operations_to_make_good(input_lines[test_case + 1])
    }
}

spec fn min_operations_to_make_good(s: Seq<char>) -> int
    recommends is_binary_string(s)
{
    if s.len() == 0 { 0 } else { min_ops_helper(s, 0, s.len() as int) }
}

spec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        valid_input(input),
    ensures
        valid_output(result),
        correct_result(input, result),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    true
}

spec fn parse_int(s: Seq<char>) -> int
    recommends is_valid_number(s)
{
    0
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    true
}

spec fn ends_with_newline(s: Seq<char>) -> bool {
    s.len() > 0 && s[s.len() - 1] == '\n'
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() - 1] == '\n' &&
    {
        let lines = split_lines(input);
        lines.len() >= 2 &&
        is_valid_number(lines[0]) &&
        {
            let t = parse_int(lines[0]);
            t >= 1 && t <= 100 &&
            lines.len() == t + 1 &&
            forall|i: int| 1 <= i < lines.len() ==> 
                is_binary_string(lines[i]) && lines[i].len() >= 1 && lines[i].len() <= 1000
        }
    }
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 &&
    (ends_with_newline(result) || result.len() == 0) &&
    {
        let output_lines = split_lines(result);
        output_lines.len() >= 1 &&
        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> is_valid_number(output_lines[i])) &&
        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> parse_int(output_lines[i]) >= 0)
    }
}

spec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool
    recommends valid_input(input)
{
    {
        let input_lines = split_lines(input);
        let t = parse_int(input_lines[0]);
        let output_lines = split_lines(result);
        output_lines.len() == t + 1 &&
        forall|test_case: int| 0 <= test_case < t ==> #[trigger] parse_int(output_lines[test_case]) == min_operations_to_make_good(input_lines[test_case + 1])
    }
}

spec fn min_operations_to_make_good(s: Seq<char>) -> int
    recommends is_binary_string(s)
{
    if s.len() == 0 { 0 } else { min_ops_helper(s, 0, s.len() as int) }
}

spec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {
    0
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        valid_input(input),
    ensures
        valid_output(result),
        correct_result(input, result),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    recommends is_valid_number(s)\n{\n    0\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn ends_with_newline(s: Seq<char>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&\n        is_valid_number(lines[0]) &&\n        {\n            let t = parse_int(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() == t + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> \n                is_binary_string(lines[i]) && lines[i].len() >= 1 && lines[i].len() <= 1000\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (ends_with_newline(result) || result.len() == 0) &&\n    {\n        let output_lines = split_lines(result);\n        output_lines.len() >= 1 &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> is_valid_number(output_lines[i])) &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> parse_int(output_lines[i]) >= 0)\n    }\n}\n\nspec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    {\n        let input_lines = split_lines(input);\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_lines(result);\n        output_lines.len() == t + 1 &&\n        forall|test_case: int| 0 <= test_case < t ==> #[trigger] parse_int(output_lines[test_case]) == min_operations_to_make_good(input_lines[test_case + 1])\n    }\n}\n\nspec fn min_operations_to_make_good(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    if s.len() == 0 { 0 } else { min_ops_helper(s, 0, s.len() as int) }\n}\n\nspec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {\n    0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        correct_result(input, result),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2457.rs,56,56,1.0,92.183,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {
    n >= 1 && n <= 1000 &&
    a >= 0 && a <= 1000 &&
    b >= 0 && b < a &&
    c >= 0 && c <= 1000 &&
    d >= 0 && d < c
}

spec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {
    let min_weight = (a - b) * n;
    let max_weight = (a + b) * n;
    let target_min = c - d;
    let target_max = c + d;
    !(min_weight > target_max || max_weight < target_min)
}

spec fn valid_output(output: Seq<char>) -> bool {
    true
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        valid_input(input),
    ensures
        valid_output(result),
        (input.len() == 0 || (input.len() == 1 && input[0] == '\n')) ==> result.len() == 0,
        !(input.len() == 0 || (input.len() == 1 && input[0] == '\n')) ==> 
            (result.len() > 0 ==> 
                result[result.len() - 1] == '\n' || 
                (result.len() > 3 && (result.subrange(result.len() - 4, result.len() as int) == seq!['Y', 'e', 's', '\n'] || 
                                     result.subrange(result.len() - 3, result.len() as int) == seq!['N', 'o', '\n']))),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {
    n >= 1 && n <= 1000 &&
    a >= 0 && a <= 1000 &&
    b >= 0 && b < a &&
    c >= 0 && c <= 1000 &&
    d >= 0 && d < c
}

spec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {
    let min_weight = (a - b) * n;
    let max_weight = (a + b) * n;
    let target_min = c - d;
    let target_max = c + d;
    !(min_weight > target_max || max_weight < target_min)
}

spec fn valid_output(output: Seq<char>) -> bool {
    true
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        valid_input(input),
    ensures
        valid_output(result),
        (input.len() == 0 || (input.len() == 1 && input[0] == '\n')) ==> result.len() == 0,
        !(input.len() == 0 || (input.len() == 1 && input[0] == '\n')) ==> 
            (result.len() > 0 ==> 
                result[result.len() - 1] == '\n' || 
                (result.len() > 3 && (result.subrange(result.len() - 4, result.len() as int) == seq!['Y', 'e', 's', '\n'] || 
                                     result.subrange(result.len() - 3, result.len() as int) == seq!['N', 'o', '\n']))),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    a >= 0 && a <= 1000 &&\n    b >= 0 && b < a &&\n    c >= 0 && c <= 1000 &&\n    d >= 0 && d < c\n}\n\nspec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {\n    let min_weight = (a - b) * n;\n    let max_weight = (a + b) * n;\n    let target_min = c - d;\n    let target_max = c + d;\n    !(min_weight > target_max || max_weight < target_min)\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        (input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> result.len() == 0,\n        !(input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> \n            (result.len() > 0 ==> \n                result[result.len() - 1] == '\\n' || \n                (result.len() > 3 && (result.subrange(result.len() - 4, result.len() as int) == seq!['Y', 'e', 's', '\\n'] || \n                                     result.subrange(result.len() - 3, result.len() as int) == seq!['N', 'o', '\\n']))),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2522.rs,50,50,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>) -> bool {
        a.len() == n && b.len() == n && n >= 1 &&
        (forall|i: int| 0 <= i < n-1 ==> a[i] <= a[i+1]) &&
        (forall|i: int| 0 <= i < n-1 ==> b[i] <= b[i+1])
    }
    
    spec fn valid_reordering(a: Seq<int>, reordered_b: Seq<int>) -> bool
        recommends a.len() == reordered_b.len()
    {
        forall|i: int| 0 <= i < a.len() ==> a[i] != reordered_b[i]
    }
    
    spec fn is_reordering_of(original: Seq<int>, reordered: Seq<int>) -> bool {
        original.len() == reordered.len() && original.to_multiset() == reordered.to_multiset()
    }
    
    spec fn is_rotation(original: Seq<int>, rotated: Seq<int>) -> bool {
        original.len() == rotated.len() && 
        (exists|k: int| 0 <= k < original.len() && rotated == original.subrange(k, original.len() as int) + original.subrange(0, k))
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: int, a: Seq<int>, b: Seq<int>) -> (result: (bool, Seq<int>))
    requires 
        valid_input(n, a, b)
    ensures 
        result.0 ==> result.1.len() == n,
        result.0 ==> is_reordering_of(b, result.1),
        result.0 ==> valid_reordering(a, result.1),
        !result.0 ==> result.1 == seq![],
        result.0 ==> is_rotation(b, result.1),
// </vc-spec>
// <vc-code>
{
    assume(false);
    (false, seq![])
}
// </vc-code>

}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>) -> bool {
        a.len() == n && b.len() == n && n >= 1 &&
        (forall|i: int| 0 <= i < n-1 ==> a[i] <= a[i+1]) &&
        (forall|i: int| 0 <= i < n-1 ==> b[i] <= b[i+1])
    }
    
    spec fn valid_reordering(a: Seq<int>, reordered_b: Seq<int>) -> bool
        recommends a.len() == reordered_b.len()
    {
        forall|i: int| 0 <= i < a.len() ==> a[i] != reordered_b[i]
    }
    
    spec fn is_reordering_of(original: Seq<int>, reordered: Seq<int>) -> bool {
        original.len() == reordered.len() && original.to_multiset() == reordered.to_multiset()
    }
    
    spec fn is_rotation(original: Seq<int>, rotated: Seq<int>) -> bool {
        original.len() == rotated.len() && 
        (exists|k: int| 0 <= k < original.len() && rotated == original.subrange(k, original.len() as int) + original.subrange(0, k))
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: int, a: Seq<int>, b: Seq<int>) -> (result: (bool, Seq<int>))
    requires 
        valid_input(n, a, b)
    ensures 
        result.0 ==> result.1.len() == n,
        result.0 ==> is_reordering_of(b, result.1),
        result.0 ==> valid_reordering(a, result.1),
        !result.0 ==> result.1 == seq![],
        result.0 ==> is_rotation(b, result.1),
// </vc-spec>
// <vc-code>
{
    assume(false);
    (false, seq![])
}
// </vc-code>

}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2553.rs,141,141,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() as int - 1] == '\n' &&
    count_lines(input) >= 1 &&
    exists|q: nat| (1 <= q <= 100 && 
        parse_first_line(input) == q &&
        count_lines(input) == 1 + 2 * q &&
        valid_test_cases_format(input, q))
}

spec fn valid_test_cases_format(input: Seq<char>, q: nat) -> bool
    recommends 1 <= q <= 100,
              count_lines(input) >= 1 + 2 * q
{
    forall|i: int| 0 <= i < q ==> 
        exists|n: nat, x: nat| (1 <= x <= n <= 1000 &&
        get_test_case_n(input, i) == n &&
        get_test_case_x(input, i) == x &&
        get_test_case_array(input, i).len() == n &&
        forall|j: int| 0 <= j < n ==> 1 <= get_test_case_array(input, i)[j] <= 1000)
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() >= 0 && 
    (output.len() == 0 || output[output.len() as int - 1] == '\n') &&
    forall|i: int| 0 <= i < count_lines(output) ==> 
        (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])
}

spec fn output_matches_algorithm(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    let q = parse_first_line(input);
    count_lines(output) == q &&
    forall|i: int| 0 <= i < q ==> {
        let arr = get_test_case_array(input, i);
        let x = get_test_case_x(input, i);
        let expected = if can_select_odd_sum(arr, x) { seq!['Y', 'e', 's'] } else { seq!['N', 'o'] };
        get_line(output, i) == expected
    }
}

spec fn can_select_odd_sum(arr: Seq<int>, x: nat) -> bool
    recommends x <= arr.len()
{
    let odd_count = count_odd_elements(arr);
    let even_count = arr.len() - odd_count;

    if x == arr.len() {
        odd_count % 2 == 1
    } else if odd_count > 0 && even_count > 0 {
        true
    } else if even_count == 0 {
        x % 2 == 1
    } else {
        false
    }
}

spec fn count_odd_elements(arr: Seq<int>) -> nat
    decreases arr.len()
{
    if arr.len() == 0 {
        0
    } else if arr[0] % 2 == 1 {
        1 + count_odd_elements(arr.subrange(1, arr.len() as int))
    } else {
        count_odd_elements(arr.subrange(1, arr.len() as int))
    }
}

spec fn parse_first_line(input: Seq<char>) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1
{
    1
}

spec fn get_test_case_n(input: Seq<char>, case_index: int) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    1
}

spec fn get_test_case_x(input: Seq<char>, case_index: int) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    1
}

spec fn get_test_case_array(input: Seq<char>, case_index: int) -> Seq<int>
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    seq![1]
}

spec fn count_lines(s: Seq<char>) -> nat {
    if s.len() == 0 { 0 } else { 1 }
}

spec fn get_line(s: Seq<char>, line_index: int) -> Seq<char>
    recommends line_index < count_lines(s)
{
    if line_index == 0 { seq!['N', 'o'] } else { seq![] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (output: Seq<char>)
    requires 
        valid_input(stdin_input),
    ensures 
        valid_output(output),
        output_matches_algorithm(stdin_input, output),
        count_lines(output) == parse_first_line(stdin_input),
        forall|i: int| 0 <= i < count_lines(output) ==> 
            (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() as int - 1] == '\n' &&
    count_lines(input) >= 1 &&
    exists|q: nat| (1 <= q <= 100 && 
        parse_first_line(input) == q &&
        count_lines(input) == 1 + 2 * q &&
        valid_test_cases_format(input, q))
}

spec fn valid_test_cases_format(input: Seq<char>, q: nat) -> bool
    recommends 1 <= q <= 100,
              count_lines(input) >= 1 + 2 * q
{
    forall|i: int| 0 <= i < q ==> 
        exists|n: nat, x: nat| (1 <= x <= n <= 1000 &&
        get_test_case_n(input, i) == n &&
        get_test_case_x(input, i) == x &&
        get_test_case_array(input, i).len() == n &&
        forall|j: int| 0 <= j < n ==> 1 <= get_test_case_array(input, i)[j] <= 1000)
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() >= 0 && 
    (output.len() == 0 || output[output.len() as int - 1] == '\n') &&
    forall|i: int| 0 <= i < count_lines(output) ==> 
        (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])
}

spec fn output_matches_algorithm(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    let q = parse_first_line(input);
    count_lines(output) == q &&
    forall|i: int| 0 <= i < q ==> {
        let arr = get_test_case_array(input, i);
        let x = get_test_case_x(input, i);
        let expected = if can_select_odd_sum(arr, x) { seq!['Y', 'e', 's'] } else { seq!['N', 'o'] };
        get_line(output, i) == expected
    }
}

spec fn can_select_odd_sum(arr: Seq<int>, x: nat) -> bool
    recommends x <= arr.len()
{
    let odd_count = count_odd_elements(arr);
    let even_count = arr.len() - odd_count;

    if x == arr.len() {
        odd_count % 2 == 1
    } else if odd_count > 0 && even_count > 0 {
        true
    } else if even_count == 0 {
        x % 2 == 1
    } else {
        false
    }
}

spec fn count_odd_elements(arr: Seq<int>) -> nat
    decreases arr.len()
{
    if arr.len() == 0 {
        0
    } else if arr[0] % 2 == 1 {
        1 + count_odd_elements(arr.subrange(1, arr.len() as int))
    } else {
        count_odd_elements(arr.subrange(1, arr.len() as int))
    }
}

spec fn parse_first_line(input: Seq<char>) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1
{
    1
}

spec fn get_test_case_n(input: Seq<char>, case_index: int) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    1
}

spec fn get_test_case_x(input: Seq<char>, case_index: int) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    1
}

spec fn get_test_case_array(input: Seq<char>, case_index: int) -> Seq<int>
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    seq![1]
}

spec fn count_lines(s: Seq<char>) -> nat {
    if s.len() == 0 { 0 } else { 1 }
}

spec fn get_line(s: Seq<char>, line_index: int) -> Seq<char>
    recommends line_index < count_lines(s)
{
    if line_index == 0 { seq!['N', 'o'] } else { seq![] }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (output: Seq<char>)
    requires 
        valid_input(stdin_input),
    ensures 
        valid_output(output),
        output_matches_algorithm(stdin_input, output),
        count_lines(output) == parse_first_line(stdin_input),
        forall|i: int| 0 <= i < count_lines(output) ==> 
            (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2556.rs,97,97,1.0,92.14,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& {
        let input_pairs = get_input_pairs(input);
        let expected_results = Seq::new(input_pairs.len(), |i: int| 
            if input_pairs[i].0 > 0 && input_pairs[i].1 >= 0 {
                compute_minimum_cost(input_pairs[i].0, input_pairs[i].1)
            } else {
                0
            });
        output == format_results(expected_results)
    }
}

spec fn compute_minimum_cost(c: int, s: int) -> int {
    if c > 0 && s >= 0 {
        let a = s / c;
        let r = s % c;
        (c - r) * a * a + r * (a + 1) * (a + 1)
    } else {
        0
    }
}

spec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {
    if input.len() > 0 {
        let lines = split_lines(input);
        if lines.len() == 0 {
            Seq::new(0, |i: int| (0, 0))
        } else {
            let n = parse_int(lines[0]);
            get_pairs_from_lines(lines, 1, n)
        }
    } else {
        Seq::new(0, |i: int| (0, 0))
    }
}

spec fn format_results(results: Seq<int>) -> Seq<char> {
    if forall|j: int| 0 <= j < results.len() ==> results[j] >= 0 {
        format_results_helper(results, 0, Seq::new(0, |i: int| 'a'))
    } else {
        Seq::new(0, |i: int| 'a')
    }
}

#[verifier::external_body]
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::new(0, |i: int| Seq::new(0, |j: int| 'a'))
}

#[verifier::external_body]
spec fn parse_int(line: Seq<char>) -> int {
    0
}

#[verifier::external_body]
spec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {
    Seq::new(0, |i: int| (0, 0))
}

#[verifier::external_body]
spec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {
    Seq::new(0, |i: int| 'a')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures valid_output(input, result)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& {
        let input_pairs = get_input_pairs(input);
        let expected_results = Seq::new(input_pairs.len(), |i: int| 
            if input_pairs[i].0 > 0 && input_pairs[i].1 >= 0 {
                compute_minimum_cost(input_pairs[i].0, input_pairs[i].1)
            } else {
                0
            });
        output == format_results(expected_results)
    }
}

spec fn compute_minimum_cost(c: int, s: int) -> int {
    if c > 0 && s >= 0 {
        let a = s / c;
        let r = s % c;
        (c - r) * a * a + r * (a + 1) * (a + 1)
    } else {
        0
    }
}

spec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {
    if input.len() > 0 {
        let lines = split_lines(input);
        if lines.len() == 0 {
            Seq::new(0, |i: int| (0, 0))
        } else {
            let n = parse_int(lines[0]);
            get_pairs_from_lines(lines, 1, n)
        }
    } else {
        Seq::new(0, |i: int| (0, 0))
    }
}

spec fn format_results(results: Seq<int>) -> Seq<char> {
    if forall|j: int| 0 <= j < results.len() ==> results[j] >= 0 {
        format_results_helper(results, 0, Seq::new(0, |i: int| 'a'))
    } else {
        Seq::new(0, |i: int| 'a')
    }
}

#[verifier::external_body]
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::new(0, |i: int| Seq::new(0, |j: int| 'a'))
}

#[verifier::external_body]
spec fn parse_int(line: Seq<char>) -> int {
    0
}

#[verifier::external_body]
spec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {
    Seq::new(0, |i: int| (0, 0))
}

#[verifier::external_body]
spec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {
    Seq::new(0, |i: int| 'a')
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures valid_output(input, result)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let input_pairs = get_input_pairs(input);\n        let expected_results = Seq::new(input_pairs.len(), |i: int| \n            if input_pairs[i].0 > 0 && input_pairs[i].1 >= 0 {\n                compute_minimum_cost(input_pairs[i].0, input_pairs[i].1)\n            } else {\n                0\n            });\n        output == format_results(expected_results)\n    }\n}\n\nspec fn compute_minimum_cost(c: int, s: int) -> int {\n    if c > 0 && s >= 0 {\n        let a = s / c;\n        let r = s % c;\n        (c - r) * a * a + r * (a + 1) * (a + 1)\n    } else {\n        0\n    }\n}\n\nspec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {\n    if input.len() > 0 {\n        let lines = split_lines(input);\n        if lines.len() == 0 {\n            Seq::new(0, |i: int| (0, 0))\n        } else {\n            let n = parse_int(lines[0]);\n            get_pairs_from_lines(lines, 1, n)\n        }\n    } else {\n        Seq::new(0, |i: int| (0, 0))\n    }\n}\n\nspec fn format_results(results: Seq<int>) -> Seq<char> {\n    if forall|j: int| 0 <= j < results.len() ==> results[j] >= 0 {\n        format_results_helper(results, 0, Seq::new(0, |i: int| 'a'))\n    } else {\n        Seq::new(0, |i: int| 'a')\n    }\n}\n\n#[verifier::external_body]\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::new(0, |i: int| Seq::new(0, |j: int| 'a'))\n}\n\n#[verifier::external_body]\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {\n    Seq::new(0, |i: int| (0, 0))\n}\n\n#[verifier::external_body]\nspec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {\n    Seq::new(0, |i: int| 'a')\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(input, result)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_256.rs,126,126,1.0,123.299,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn split_lines(input: &str) -> Seq<&str> {
    Seq::empty()
}

#[verifier::external_body]
spec fn split_by_char(line: &str, c: char) -> Seq<&str> {
    Seq::empty()
}

#[verifier::external_body]
spec fn char_at(s: &str, i: int) -> char {
    ' '
}

#[verifier::external_body]
spec fn str_len(s: &str) -> int {
    0
}

#[verifier::external_body]
spec fn empty_string() -> String {
    String::new()
}

#[verifier::external_body]
spec fn team1_string() -> String {
    ""Team 1\n"".to_string()
}

#[verifier::external_body]
spec fn team2_string() -> String {
    ""Team 2\n"".to_string()
}

#[verifier::external_body]
spec fn draw_string() -> String {
    ""Draw\n"".to_string()
}

spec fn is_valid_integer(s: &str) -> bool {
    str_len(s) > 0 && forall|i: int| 0 <= i < str_len(s) ==> ('0' <= char_at(s, i) && char_at(s, i) <= '9')
}

spec fn valid_player_line(line: &str) -> bool {
    let parts = split_by_char(line, ' ');
    parts.len() == 2 &&
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1])
}

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 4 &&
    forall|i: int| 0 <= i < 4 ==> valid_player_line(lines[i])
}

#[verifier::external_body]
spec fn parse_line(line: &str) -> Seq<int> {
    Seq::empty()
}

spec fn compute_result(input: &str) -> String {
    let lines = split_lines(input);
    if lines.len() < 4 {
        empty_string()
    } else {
        let player1 = parse_line(lines[0]);
        let player2 = parse_line(lines[1]);
        let player3 = parse_line(lines[2]);
        let player4 = parse_line(lines[3]);

        if player1.len() != 2 || player2.len() != 2 || player3.len() != 2 || player4.len() != 2 {
            empty_string()
        } else {
            let a = player1[0];
            let b = player1[1];
            let c = player2[0];
            let d = player2[1];
            let x = player3[0];
            let y = player3[1];
            let z = player4[0];
            let w = player4[1];

            let team1 = (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);
            let team2 = ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));

            if team1 {
                team1_string()
            } else if team2 {
                team2_string()
            } else {
                draw_string()
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        valid_input(input)
    ensures 
        result == compute_result(input),
        (result@ == ""Team 1\n""@) || (result@ == ""Team 2\n""@) || (result@ == ""Draw\n""@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""Draw\n"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn split_lines(input: &str) -> Seq<&str> {
    Seq::empty()
}

#[verifier::external_body]
spec fn split_by_char(line: &str, c: char) -> Seq<&str> {
    Seq::empty()
}

#[verifier::external_body]
spec fn char_at(s: &str, i: int) -> char {
    ' '
}

#[verifier::external_body]
spec fn str_len(s: &str) -> int {
    0
}

#[verifier::external_body]
spec fn empty_string() -> String {
    String::new()
}

#[verifier::external_body]
spec fn team1_string() -> String {
    ""Team 1\n"".to_string()
}

#[verifier::external_body]
spec fn team2_string() -> String {
    ""Team 2\n"".to_string()
}

#[verifier::external_body]
spec fn draw_string() -> String {
    ""Draw\n"".to_string()
}

spec fn is_valid_integer(s: &str) -> bool {
    str_len(s) > 0 && forall|i: int| 0 <= i < str_len(s) ==> ('0' <= char_at(s, i) && char_at(s, i) <= '9')
}

spec fn valid_player_line(line: &str) -> bool {
    let parts = split_by_char(line, ' ');
    parts.len() == 2 &&
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1])
}

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 4 &&
    forall|i: int| 0 <= i < 4 ==> valid_player_line(lines[i])
}

#[verifier::external_body]
spec fn parse_line(line: &str) -> Seq<int> {
    Seq::empty()
}

spec fn compute_result(input: &str) -> String {
    let lines = split_lines(input);
    if lines.len() < 4 {
        empty_string()
    } else {
        let player1 = parse_line(lines[0]);
        let player2 = parse_line(lines[1]);
        let player3 = parse_line(lines[2]);
        let player4 = parse_line(lines[3]);

        if player1.len() != 2 || player2.len() != 2 || player3.len() != 2 || player4.len() != 2 {
            empty_string()
        } else {
            let a = player1[0];
            let b = player1[1];
            let c = player2[0];
            let d = player2[1];
            let x = player3[0];
            let y = player3[1];
            let z = player4[0];
            let w = player4[1];

            let team1 = (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);
            let team2 = ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));

            if team1 {
                team1_string()
            } else if team2 {
                team2_string()
            } else {
                draw_string()
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        valid_input(input)
    ensures 
        result == compute_result(input),
        (result@ == ""Team 1\n""@) || (result@ == ""Team 2\n""@) || (result@ == ""Draw\n""@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""Draw\n"".to_string()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn split_lines(input: &str) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn split_by_char(line: &str, c: char) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn char_at(s: &str, i: int) -> char {\n    \' \'\n}\n\n#[verifier::external_body]\nspec fn str_len(s: &str) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn empty_string() -> String {\n    String::new()\n}\n\n#[verifier::external_body]\nspec fn team1_string() -> String {\n    ""Team 1\\n"".to_string()\n}\n\n#[verifier::external_body]\nspec fn team2_string() -> String {\n    ""Team 2\\n"".to_string()\n}\n\n#[verifier::external_body]\nspec fn draw_string() -> String {\n    ""Draw\\n"".to_string()\n}\n\nspec fn is_valid_integer(s: &str) -> bool {\n    str_len(s) > 0 && forall|i: int| 0 <= i < str_len(s) ==> (\'0\' <= char_at(s, i) && char_at(s, i) <= \'9\')\n}\n\nspec fn valid_player_line(line: &str) -> bool {\n    let parts = split_by_char(line, \' \');\n    parts.len() == 2 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1])\n}\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 4 &&\n    forall|i: int| 0 <= i < 4 ==> valid_player_line(lines[i])\n}\n\n#[verifier::external_body]\nspec fn parse_line(line: &str) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn compute_result(input: &str) -> String {\n    let lines = split_lines(input);\n    if lines.len() < 4 {\n        empty_string()\n    } else {\n        let player1 = parse_line(lines[0]);\n        let player2 = parse_line(lines[1]);\n        let player3 = parse_line(lines[2]);\n        let player4 = parse_line(lines[3]);\n\n        if player1.len() != 2 || player2.len() != 2 || player3.len() != 2 || player4.len() != 2 {\n            empty_string()\n        } else {\n            let a = player1[0];\n            let b = player1[1];\n            let c = player2[0];\n            let d = player2[1];\n            let x = player3[0];\n            let y = player3[1];\n            let z = player4[0];\n            let w = player4[1];\n\n            let team1 = (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);\n            let team2 = ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));\n\n            if team1 {\n                team1_string()\n            } else if team2 {\n                team2_string()\n            } else {\n                draw_string()\n            }\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input)\n    ensures \n        result == compute_result(input),\n        (result@ == ""Team 1\\n""@) || (result@ == ""Team 2\\n""@) || (result@ == ""Draw\\n""@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""Draw\\n"".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n           fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2616.rs,79,79,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {
    forall|i: int| 0 <= i < test_cases.len() ==> 
        test_cases[i].len() >= 1 && 
        forall|j: int| 0 <= j < test_cases[i].len() ==> test_cases[i][j] >= 1
}

spec fn valid_results(results: Seq<Seq<char>>) -> bool {
    forall|i: int| 0 <= i < results.len() ==> 
        results[i] == seq!['F', 'i', 'r', 's', 't'] || results[i] == seq!['S', 'e', 'c', 'o', 'n', 'd']
}

spec fn count_leading_ones(piles: Seq<int>) -> nat
    decreases piles.len()
{
    if piles.len() == 0 {
        0
    } else if piles[0] != 1 {
        0
    } else {
        1 + count_leading_ones(piles.subrange(1, piles.len() as int))
    }
}

spec fn count_ones_in_seq(piles: Seq<int>) -> nat {
    piles.filter(|x: int| x == 1).len()
}

spec fn correct_game_result(piles: Seq<int>, result: Seq<char>) -> bool {
    &&& piles.len() >= 1
    &&& (forall|j: int| 0 <= j < piles.len() ==> piles[j] >= 1)
    &&& (result == seq!['F', 'i', 'r', 's', 't'] || result == seq!['S', 'e', 'c', 'o', 'n', 'd'])
    &&& {
        let ones_count = count_ones_in_seq(piles);
        let all_ones = (ones_count == piles.len());
        let leading_ones = count_leading_ones(piles);
        if all_ones {
            if ones_count % 2 == 1 {
                result == seq!['F', 'i', 'r', 's', 't']
            } else {
                result == seq!['S', 'e', 'c', 'o', 'n', 'd']
            }
        } else {
            if leading_ones % 2 == 1 {
                result == seq!['S', 'e', 'c', 'o', 'n', 'd']
            } else {
                result == seq!['F', 'i', 'r', 's', 't']
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(test_cases: Vec<Vec<i8>>) -> (results: Vec<Vec<char>>)
    requires 
        valid_input(test_cases@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)))
    ensures 
        results.len() == test_cases.len(),
        valid_results(results@.map(|i: int, v: Vec<char>| v@)),
        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {
    forall|i: int| 0 <= i < test_cases.len() ==> 
        test_cases[i].len() >= 1 && 
        forall|j: int| 0 <= j < test_cases[i].len() ==> test_cases[i][j] >= 1
}

spec fn valid_results(results: Seq<Seq<char>>) -> bool {
    forall|i: int| 0 <= i < results.len() ==> 
        results[i] == seq!['F', 'i', 'r', 's', 't'] || results[i] == seq!['S', 'e', 'c', 'o', 'n', 'd']
}

spec fn count_leading_ones(piles: Seq<int>) -> nat
    decreases piles.len()
{
    if piles.len() == 0 {
        0
    } else if piles[0] != 1 {
        0
    } else {
        1 + count_leading_ones(piles.subrange(1, piles.len() as int))
    }
}

spec fn count_ones_in_seq(piles: Seq<int>) -> nat {
    piles.filter(|x: int| x == 1).len()
}

spec fn correct_game_result(piles: Seq<int>, result: Seq<char>) -> bool {
    &&& piles.len() >= 1
    &&& (forall|j: int| 0 <= j < piles.len() ==> piles[j] >= 1)
    &&& (result == seq!['F', 'i', 'r', 's', 't'] || result == seq!['S', 'e', 'c', 'o', 'n', 'd'])
    &&& {
        let ones_count = count_ones_in_seq(piles);
        let all_ones = (ones_count == piles.len());
        let leading_ones = count_leading_ones(piles);
        if all_ones {
            if ones_count % 2 == 1 {
                result == seq!['F', 'i', 'r', 's', 't']
            } else {
                result == seq!['S', 'e', 'c', 'o', 'n', 'd']
            }
        } else {
            if leading_ones % 2 == 1 {
                result == seq!['S', 'e', 'c', 'o', 'n', 'd']
            } else {
                result == seq!['F', 'i', 'r', 's', 't']
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(test_cases: Vec<Vec<i8>>) -> (results: Vec<Vec<char>>)
    requires 
        valid_input(test_cases@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)))
    ensures 
        results.len() == test_cases.len(),
        valid_results(results@.map(|i: int, v: Vec<char>| v@)),
        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2621.rs,94,94,1.0,92.495,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {
    n >= 1 && n == h.len() && m >= 0 && k >= 0 && 
    (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)
}

spec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool
{
    &&& valid_input(n, m, k, h)
    &&& simulate_game(0, m, n, k, h)
}

spec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool
    decreases n - pos
{
    &&& 0 <= pos < n
    &&& n == h.len()
    &&& k >= 0
    &&& blocks >= 0
    &&& (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)
    &&& if pos == n - 1 {
        true
    } else {
        let h1 = h[pos];
        let h2 = h[pos + 1];
        if h1 >= h2 {
            let new_blocks = if h2 >= k { blocks + (h1 - h2) + k } else { blocks + h1 };
            simulate_game(pos + 1, new_blocks, n, k, h)
        } else {
            if h2 > h1 + blocks + k {
                false
            } else {
                let new_blocks = 
                    if h2 <= k { blocks + h1 }
                    else if (h2 - h1) <= k { blocks + k - (h2 - h1) }
                    else { blocks - (h2 - h1 - k) };
                new_blocks >= 0 && simulate_game(pos + 1, new_blocks, n, k, h)
            }
        }
    }
}

spec fn valid_complete_input_format(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {
    output.len() >= 0 && 
    (output.len() == 0 || output[output.len() - 1] == '\n') &&
    (forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\n')
}

spec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {
    true
}

spec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {
    true
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() - 1] == '\n',
        valid_complete_input_format(stdin_input),
    ensures 
        result.len() >= 0,
        forall|i: int| 0 <= i < result.len() ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\n',
        result.len() == 0 || result[result.len() - 1] == '\n',
        valid_output_format(result, stdin_input),
        correct_game_results(result, stdin_input),
        output_matches_test_case_count(result, stdin_input),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {
    n >= 1 && n == h.len() && m >= 0 && k >= 0 && 
    (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)
}

spec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool
{
    &&& valid_input(n, m, k, h)
    &&& simulate_game(0, m, n, k, h)
}

spec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool
    decreases n - pos
{
    &&& 0 <= pos < n
    &&& n == h.len()
    &&& k >= 0
    &&& blocks >= 0
    &&& (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)
    &&& if pos == n - 1 {
        true
    } else {
        let h1 = h[pos];
        let h2 = h[pos + 1];
        if h1 >= h2 {
            let new_blocks = if h2 >= k { blocks + (h1 - h2) + k } else { blocks + h1 };
            simulate_game(pos + 1, new_blocks, n, k, h)
        } else {
            if h2 > h1 + blocks + k {
                false
            } else {
                let new_blocks = 
                    if h2 <= k { blocks + h1 }
                    else if (h2 - h1) <= k { blocks + k - (h2 - h1) }
                    else { blocks - (h2 - h1 - k) };
                new_blocks >= 0 && simulate_game(pos + 1, new_blocks, n, k, h)
            }
        }
    }
}

spec fn valid_complete_input_format(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {
    output.len() >= 0 && 
    (output.len() == 0 || output[output.len() - 1] == '\n') &&
    (forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\n')
}

spec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {
    true
}

spec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {
    true
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() - 1] == '\n',
        valid_complete_input_format(stdin_input),
    ensures 
        result.len() >= 0,
        forall|i: int| 0 <= i < result.len() ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\n',
        result.len() == 0 || result[result.len() - 1] == '\n',
        valid_output_format(result, stdin_input),
        correct_game_results(result, stdin_input),
        output_matches_test_case_count(result, stdin_input),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {\n    n >= 1 && n == h.len() && m >= 0 && k >= 0 && \n    (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n}\n\nspec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool\n{\n    &&& valid_input(n, m, k, h)\n    &&& simulate_game(0, m, n, k, h)\n}\n\nspec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool\n    decreases n - pos\n{\n    &&& 0 <= pos < n\n    &&& n == h.len()\n    &&& k >= 0\n    &&& blocks >= 0\n    &&& (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n    &&& if pos == n - 1 {\n        true\n    } else {\n        let h1 = h[pos];\n        let h2 = h[pos + 1];\n        if h1 >= h2 {\n            let new_blocks = if h2 >= k { blocks + (h1 - h2) + k } else { blocks + h1 };\n            simulate_game(pos + 1, new_blocks, n, k, h)\n        } else {\n            if h2 > h1 + blocks + k {\n                false\n            } else {\n                let new_blocks = \n                    if h2 <= k { blocks + h1 }\n                    else if (h2 - h1) <= k { blocks + k - (h2 - h1) }\n                    else { blocks - (h2 - h1 - k) };\n                new_blocks >= 0 && simulate_game(pos + 1, new_blocks, n, k, h)\n            }\n        }\n    }\n}\n\nspec fn valid_complete_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() >= 0 && \n    (output.len() == 0 || output[output.len() - 1] == '\\n') &&\n    (forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n')\n}\n\nspec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n\nspec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == '\\n',\n        valid_complete_input_format(stdin_input),\n    ensures \n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\\n',\n        result.len() == 0 || result[result.len() - 1] == '\\n',\n        valid_output_format(result, stdin_input),\n        correct_game_results(result, stdin_input),\n        output_matches_test_case_count(result, stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_263.rs,54,54,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: nat, m: nat, benches: Seq<nat>) -> bool {
    n > 0 && m > 0 && benches.len() == n && forall|i: int| 0 <= i < n ==> benches[i] > 0
}

spec fn max_seq(s: Seq<nat>) -> nat
    recommends s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) {
        s[0]
    } else {
        max_seq(s.subrange(1, s.len() as int))
    }
}

spec fn sum_seq(s: Seq<nat>) -> nat {
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(n: nat, m: nat, benches: Seq<nat>) -> (result: (nat, nat))
    requires valid_input(n, m, benches)
    ensures result.1 == max_seq(benches) + m
    ensures {
        let total = sum_seq(benches) + m;
        let current_max = max_seq(benches);
        if total <= current_max * n { result.0 == current_max } 
        else { result.0 == (total + n - 1) / n }
    }
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 0)
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: nat, m: nat, benches: Seq<nat>) -> bool {
    n > 0 && m > 0 && benches.len() == n && forall|i: int| 0 <= i < n ==> benches[i] > 0
}

spec fn max_seq(s: Seq<nat>) -> nat
    recommends s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) {
        s[0]
    } else {
        max_seq(s.subrange(1, s.len() as int))
    }
}

spec fn sum_seq(s: Seq<nat>) -> nat {
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(n: nat, m: nat, benches: Seq<nat>) -> (result: (nat, nat))
    requires valid_input(n, m, benches)
    ensures result.1 == max_seq(benches) + m
    ensures {
        let total = sum_seq(benches) + m;
        let current_max = max_seq(benches);
        if total <= current_max * n { result.0 == current_max } 
        else { result.0 == (total + n - 1) / n }
    }
// </vc-spec>
// <vc-code>
{
    assume(false);
    (0, 0)
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_2647.rs,75,75,1.0,122.5,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    true
}

spec fn is_valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    (output == seq!['-', '1', '\n'] || 
     (output != seq!['-', '1', '\n'] && output.len() > 1 && output.last() == '\n'))
}

struct GridData {
    h: int,
    w: int,
    cells: Seq<Seq<char>>,
}

spec fn valid_grid(grid: GridData) -> bool {
    grid.h > 0 && grid.w > 0 && 
    grid.cells.len() == grid.h &&
    (forall|i: int| 0 <= i < grid.h ==> grid.cells[i].len() == grid.w) &&
    (forall|i: int, j: int| 0 <= i < grid.h && 0 <= j < grid.w ==> 
        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&
    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'
}

spec fn parse_input(input: Seq<char>) -> GridData {
    GridData {
        h: 1,
        w: 1,
        cells: seq![seq!['.']]
    }
}

spec fn path_exists(grid: GridData) -> bool {
    true
}

spec fn max_changeable_white_cells(grid: GridData) -> int {
    0
}

spec fn count_white_cells(grid: GridData) -> int {
    2
}

spec fn min_cut_size(grid: GridData) -> int {
    2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn is_valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    true
}

spec fn is_valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    (output == seq!['-', '1', '\n'] || 
     (output != seq!['-', '1', '\n'] && output.len() > 1 && output.last() == '\n'))
}

struct GridData {
    h: int,
    w: int,
    cells: Seq<Seq<char>>,
}

spec fn valid_grid(grid: GridData) -> bool {
    grid.h > 0 && grid.w > 0 && 
    grid.cells.len() == grid.h &&
    (forall|i: int| 0 <= i < grid.h ==> grid.cells[i].len() == grid.w) &&
    (forall|i: int, j: int| 0 <= i < grid.h && 0 <= j < grid.w ==> 
        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&
    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'
}

spec fn parse_input(input: Seq<char>) -> GridData {
    GridData {
        h: 1,
        w: 1,
        cells: seq![seq!['.']]
    }
}

spec fn path_exists(grid: GridData) -> bool {
    true
}

spec fn max_changeable_white_cells(grid: GridData) -> int {
    0
}

spec fn count_white_cells(grid: GridData) -> int {
    2
}

spec fn min_cut_size(grid: GridData) -> int {
    2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    true\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    (output == seq!['-', '1', '\\n'] || \n     (output != seq!['-', '1', '\\n'] && output.len() > 1 && output.last() == '\\n'))\n}\n\nstruct GridData {\n    h: int,\n    w: int,\n    cells: Seq<Seq<char>>,\n}\n\nspec fn valid_grid(grid: GridData) -> bool {\n    grid.h > 0 && grid.w > 0 && \n    grid.cells.len() == grid.h &&\n    (forall|i: int| 0 <= i < grid.h ==> grid.cells[i].len() == grid.w) &&\n    (forall|i: int, j: int| 0 <= i < grid.h && 0 <= j < grid.w ==> \n        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&\n    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'\n}\n\nspec fn parse_input(input: Seq<char>) -> GridData {\n    GridData {\n        h: 1,\n        w: 1,\n        cells: seq![seq!['.']]\n    }\n}\n\nspec fn path_exists(grid: GridData) -> bool {\n    true\n}\n\nspec fn max_changeable_white_cells(grid: GridData) -> int {\n    0\n}\n\nspec fn count_white_cells(grid: GridData) -> int {\n    2\n}\n\nspec fn min_cut_size(grid: GridData) -> int {\n    2\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_29.rs,67,67,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn char_to_int(c: char) -> int {
    c as int - '0' as int
}

spec fn is_lucky(digits: Seq<int>) -> bool {
    digits.len() == 6 ==> {
        let sum1 = digits[0] + digits[1] + digits[2];
        let sum2 = digits[3] + digits[4] + digits[5];
        sum1 == sum2
    }
}

spec fn valid_ticket(ticket: Seq<char>) -> bool {
    ticket.len() == 6 && forall|i: int| 0 <= i < ticket.len() ==> '0' <= ticket[i] <= '9'
}

spec fn can_make_lucky_with_0_changes(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> is_lucky(digits)
}

spec fn can_make_lucky_with_1_change(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {
        exists|pos: int| 0 <= pos < 6 &&
            exists|new_digit: int| 0 <= new_digit <= 9 && {
                let new_digits = digits.subrange(0, pos).add(seq![new_digit]).add(digits.subrange(pos + 1, digits.len() as int));
                is_lucky(new_digits)
            }
    }
}

spec fn can_make_lucky_with_2_changes(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {
        exists|i: int, j: int| 0 <= j < i < 6 &&
            exists|k: int, l: int| 0 <= k <= 9 && 0 <= l <= 9 && {
                let new_digits = digits.subrange(0, i).add(seq![k]).add(digits.subrange(i + 1, digits.len() as int));
                let final_digits = new_digits.subrange(0, j).add(seq![l]).add(new_digits.subrange(j + 1, new_digits.len() as int));
                is_lucky(final_digits)
            }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(ticket: &Vec<char>) -> (result: u32)
    requires valid_ticket(ticket@)
    ensures 0 <= result <= 3
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    0
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn char_to_int(c: char) -> int {
    c as int - '0' as int
}

spec fn is_lucky(digits: Seq<int>) -> bool {
    digits.len() == 6 ==> {
        let sum1 = digits[0] + digits[1] + digits[2];
        let sum2 = digits[3] + digits[4] + digits[5];
        sum1 == sum2
    }
}

spec fn valid_ticket(ticket: Seq<char>) -> bool {
    ticket.len() == 6 && forall|i: int| 0 <= i < ticket.len() ==> '0' <= ticket[i] <= '9'
}

spec fn can_make_lucky_with_0_changes(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> is_lucky(digits)
}

spec fn can_make_lucky_with_1_change(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {
        exists|pos: int| 0 <= pos < 6 &&
            exists|new_digit: int| 0 <= new_digit <= 9 && {
                let new_digits = digits.subrange(0, pos).add(seq![new_digit]).add(digits.subrange(pos + 1, digits.len() as int));
                is_lucky(new_digits)
            }
    }
}

spec fn can_make_lucky_with_2_changes(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {
        exists|i: int, j: int| 0 <= j < i < 6 &&
            exists|k: int, l: int| 0 <= k <= 9 && 0 <= l <= 9 && {
                let new_digits = digits.subrange(0, i).add(seq![k]).add(digits.subrange(i + 1, digits.len() as int));
                let final_digits = new_digits.subrange(0, j).add(seq![l]).add(new_digits.subrange(j + 1, new_digits.len() as int));
                is_lucky(final_digits)
            }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(ticket: &Vec<char>) -> (result: u32)
    requires valid_ticket(ticket@)
    ensures 0 <= result <= 3
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    0
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4147.rs,97,97,1.0,186.567,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {
    true
}

spec fn has_all_three_groups(assignment: Seq<nat>) -> bool {
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)
}

spec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {
    composition_cost(assignment) + adjustment_cost(input, assignment)
}

spec fn composition_cost(assignment: Seq<nat>) -> nat {
    let group_a_size = count_group_members(assignment, 1);
    let group_b_size = count_group_members(assignment, 2);
    let group_c_size = count_group_members(assignment, 3);
    (if group_a_size > 0 { ((group_a_size - 1) * 10) as nat } else { 0nat }) +
    (if group_b_size > 0 { ((group_b_size - 1) * 10) as nat } else { 0nat }) +
    (if group_c_size > 0 { ((group_c_size - 1) * 10) as nat } else { 0nat })
}

spec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {
    let lines = split_lines(input);
    let (n, a, b, c) = parse_first_line_bamboo(lines[0]);
    let sum_a = calculate_group_sum(input, assignment, 1);
    let sum_b = calculate_group_sum(input, assignment, 2);
    let sum_c = calculate_group_sum(input, assignment, 3);
    abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)
}

spec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat
    decreases assignment.len()
{
    if assignment.len() == 0 {
        0nat
    } else {
        (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.drop_first(), group)
    }
}

spec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {
    0nat
}

spec fn abs_diff(a: nat, b: nat) -> nat {
    if a >= b { (a - b) as nat } else { (b - a) as nat }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::<Seq<char>>::empty()
}

spec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {
    (0nat, 0nat, 0nat, 0nat)
}

spec fn parse_bamboo_length(line: Seq<char>) -> nat {
    0nat
}

fn int_to_string(n: nat) -> String {
    """".to_string()
}

spec fn string_to_int(s: Seq<char>) -> nat {
    0nat
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {
    true
}

spec fn has_all_three_groups(assignment: Seq<nat>) -> bool {
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)
}

spec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {
    composition_cost(assignment) + adjustment_cost(input, assignment)
}

spec fn composition_cost(assignment: Seq<nat>) -> nat {
    let group_a_size = count_group_members(assignment, 1);
    let group_b_size = count_group_members(assignment, 2);
    let group_c_size = count_group_members(assignment, 3);
    (if group_a_size > 0 { ((group_a_size - 1) * 10) as nat } else { 0nat }) +
    (if group_b_size > 0 { ((group_b_size - 1) * 10) as nat } else { 0nat }) +
    (if group_c_size > 0 { ((group_c_size - 1) * 10) as nat } else { 0nat })
}

spec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {
    let lines = split_lines(input);
    let (n, a, b, c) = parse_first_line_bamboo(lines[0]);
    let sum_a = calculate_group_sum(input, assignment, 1);
    let sum_b = calculate_group_sum(input, assignment, 2);
    let sum_c = calculate_group_sum(input, assignment, 3);
    abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)
}

spec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat
    decreases assignment.len()
{
    if assignment.len() == 0 {
        0nat
    } else {
        (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.drop_first(), group)
    }
}

spec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {
    0nat
}

spec fn abs_diff(a: nat, b: nat) -> nat {
    if a >= b { (a - b) as nat } else { (b - a) as nat }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::<Seq<char>>::empty()
}

spec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {
    (0nat, 0nat, 0nat, 0nat)
}

spec fn parse_bamboo_length(line: Seq<char>) -> nat {
    0nat
}

fn int_to_string(n: nat) -> String {
    """".to_string()
}

spec fn string_to_int(s: Seq<char>) -> nat {
    0nat
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {\n    true\n}\n\nspec fn has_all_three_groups(assignment: Seq<nat>) -> bool {\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)\n}\n\nspec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    composition_cost(assignment) + adjustment_cost(input, assignment)\n}\n\nspec fn composition_cost(assignment: Seq<nat>) -> nat {\n    let group_a_size = count_group_members(assignment, 1);\n    let group_b_size = count_group_members(assignment, 2);\n    let group_c_size = count_group_members(assignment, 3);\n    (if group_a_size > 0 { ((group_a_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_b_size > 0 { ((group_b_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_c_size > 0 { ((group_c_size - 1) * 10) as nat } else { 0nat })\n}\n\nspec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    let lines = split_lines(input);\n    let (n, a, b, c) = parse_first_line_bamboo(lines[0]);\n    let sum_a = calculate_group_sum(input, assignment, 1);\n    let sum_b = calculate_group_sum(input, assignment, 2);\n    let sum_c = calculate_group_sum(input, assignment, 3);\n    abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)\n}\n\nspec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat\n    decreases assignment.len()\n{\n    if assignment.len() == 0 {\n        0nat\n    } else {\n        (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.drop_first(), group)\n    }\n}\n\nspec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {\n    0nat\n}\n\nspec fn abs_diff(a: nat, b: nat) -> nat {\n    if a >= b { (a - b) as nat } else { (b - a) as nat }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::<Seq<char>>::empty()\n}\n\nspec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {\n    (0nat, 0nat, 0nat, 0nat)\n}\n\nspec fn parse_bamboo_length(line: Seq<char>) -> nat {\n    0nat\n}\n\nfn int_to_string(n: nat) -> String {\n    """".to_string()\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    0nat\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4148.rs,102,102,1.0,,,0.9,True,['vstd::prelude::'],False,other,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>
    requires input.len() > 0
{
    let newline_pos = find_newline(input, 0);
    if newline_pos == -1 {
        seq![input]
    } else if newline_pos >= 0 && newline_pos < input.len() {
        if newline_pos + 1 >= input.len() {
            seq![input.subrange(0, newline_pos), seq![]]
        } else {
            seq![input.subrange(0, newline_pos), input.subrange(newline_pos + 1, input.len() as int)]
        }
    } else {
        seq![input]
    }
}

spec fn find_newline(input: Seq<char>, start: int) -> int
    requires 0 <= start <= input.len()
    ensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < input.len())
    decreases input.len() - start
{
    if start >= input.len() {
        -1
    } else if input[start] == '\n' {
        start
    } else {
        find_newline(input, start + 1)
    }
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn string_to_nat(s: Seq<char>) -> nat
    requires is_valid_number(s)
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int - '0' as int) as nat
    } else {
        (s[0] as int - '0' as int) as nat * 10 + string_to_nat(s.subrange(1, s.len() as int))
    }
}

spec fn caesar_shift(s: Seq<char>, n: nat) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let shifted_val = (s[0] as int - 'A' as int + n) % 26;
        let shifted_char = ('A' as int + shifted_val) as char;
        seq![shifted_char].add(caesar_shift(s.subrange(1, s.len() as int), n))
    }
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == '\n') &&
    {
        let lines = split_lines(input);
        lines.len() >= 2 &&
        is_valid_number(lines[0]) &&
        string_to_nat(lines[0]) <= 26 &&
        lines[1].len() >= 1 && lines[1].len() <= 10000 &&
        (forall|j: int| 0 <= j < lines[1].len() ==> 'A' <= lines[1][j] <= 'Z')
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures ({
        let lines = split_lines(input);
        let n = string_to_nat(lines[0]);
        let s = lines[1];
        result == caesar_shift(s, n).add(seq!['\n'])
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>
    requires input.len() > 0
{
    let newline_pos = find_newline(input, 0);
    if newline_pos == -1 {
        seq![input]
    } else if newline_pos >= 0 && newline_pos < input.len() {
        if newline_pos + 1 >= input.len() {
            seq![input.subrange(0, newline_pos), seq![]]
        } else {
            seq![input.subrange(0, newline_pos), input.subrange(newline_pos + 1, input.len() as int)]
        }
    } else {
        seq![input]
    }
}

spec fn find_newline(input: Seq<char>, start: int) -> int
    requires 0 <= start <= input.len()
    ensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < input.len())
    decreases input.len() - start
{
    if start >= input.len() {
        -1
    } else if input[start] == '\n' {
        start
    } else {
        find_newline(input, start + 1)
    }
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn string_to_nat(s: Seq<char>) -> nat
    requires is_valid_number(s)
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int - '0' as int) as nat
    } else {
        (s[0] as int - '0' as int) as nat * 10 + string_to_nat(s.subrange(1, s.len() as int))
    }
}

spec fn caesar_shift(s: Seq<char>, n: nat) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let shifted_val = (s[0] as int - 'A' as int + n) % 26;
        let shifted_char = ('A' as int + shifted_val) as char;
        seq![shifted_char].add(caesar_shift(s.subrange(1, s.len() as int), n))
    }
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == '\n') &&
    {
        let lines = split_lines(input);
        lines.len() >= 2 &&
        is_valid_number(lines[0]) &&
        string_to_nat(lines[0]) <= 26 &&
        lines[1].len() >= 1 && lines[1].len() <= 10000 &&
        (forall|j: int| 0 <= j < lines[1].len() ==> 'A' <= lines[1][j] <= 'Z')
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures ({
        let lines = split_lines(input);
        let n = string_to_nat(lines[0]);
        let s = lines[1];
        result == caesar_shift(s, n).add(seq!['\n'])
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4165.rs,60,60,1.0,252.297,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(sides: Seq<int>) -> bool {
    sides.len() >= 3 && forall|i: int| 0 <= i < sides.len() ==> sides[i] > 0
}

spec fn can_form_polygon(sides: Seq<int>) -> bool
    recommends valid_input(sides)
{
    let sorted_sides = quicksort(sides);
    let longest = sorted_sides[sorted_sides.len() - 1];
    let sum_of_others = sum_except_last(sorted_sides);
    sum_of_others > longest
}

spec fn quicksort(s: Seq<int>) -> Seq<int> {
    seq![]
}

spec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {
    seq![]
}

spec fn sum_except_last(s: Seq<int>) -> int
    recommends s.len() >= 1
{
    0
}

proof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)
    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)
{
    assume(false); /* TODO: Remove this line and implement the proof */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(sides: Seq<int>) -> (result: String)
    requires
        valid_input(sides),
    ensures
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],
        (result@ == seq!['Y', 'e', 's']) == can_form_polygon(sides),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(sides: Seq<int>) -> bool {
    sides.len() >= 3 && forall|i: int| 0 <= i < sides.len() ==> sides[i] > 0
}

spec fn can_form_polygon(sides: Seq<int>) -> bool
    recommends valid_input(sides)
{
    let sorted_sides = quicksort(sides);
    let longest = sorted_sides[sorted_sides.len() - 1];
    let sum_of_others = sum_except_last(sorted_sides);
    sum_of_others > longest
}

spec fn quicksort(s: Seq<int>) -> Seq<int> {
    seq![]
}

spec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {
    seq![]
}

spec fn sum_except_last(s: Seq<int>) -> int
    recommends s.len() >= 1
{
    0
}

proof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)
    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)
{
    assume(false); /* TODO: Remove this line and implement the proof */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(sides: Seq<int>) -> (result: String)
    requires
        valid_input(sides),
    ensures
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],
        (result@ == seq!['Y', 'e', 's']) == can_form_polygon(sides),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No"".to_string()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(sides: Seq<int>) -> bool {\n    sides.len() >= 3 && forall|i: int| 0 <= i < sides.len() ==> sides[i] > 0\n}\n\nspec fn can_form_polygon(sides: Seq<int>) -> bool\n    recommends valid_input(sides)\n{\n    let sorted_sides = quicksort(sides);\n    let longest = sorted_sides[sorted_sides.len() - 1];\n    let sum_of_others = sum_except_last(sorted_sides);\n    sum_of_others > longest\n}\n\nspec fn quicksort(s: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {\n    seq![]\n}\n\nspec fn sum_except_last(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nproof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)\n    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(sides: Seq<int>) -> (result: String)\n    requires\n        valid_input(sides),\n    ensures\n        result@ == seq![\'Y\', \'e\', \'s\'] || result@ == seq![\'N\', \'o\'],\n        (result@ == seq![\'Y\', \'e\', \'s\']) == can_form_polygon(sides),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""No"".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd::prelude::*;\n              fn main() {\n    }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4229.rs,58,58,1.0,218.029,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn int_to_string(i: int) -> Seq<char>
    recommends i >= 0
{
    seq!['1']
}

spec fn parse_int_from_string(s: Seq<char>) -> int
    recommends s.len() > 0
{
    1
}

spec fn valid_input(stdin_input: Seq<char>) -> bool
{
    stdin_input.len() > 0
}

spec fn sum_of_non_fizzbuzz_numbers(n: int) -> int
    recommends n >= 0
    decreases n when n >= 0
{
    if n <= 0 {
        0
    } else {
        let num = n;
        if num % 3 != 0 && num % 5 != 0 {
            sum_of_non_fizzbuzz_numbers(n - 1) + num
        } else {
            sum_of_non_fizzbuzz_numbers(n - 1)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(stdin_input)
    ensures result.len() > 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn int_to_string(i: int) -> Seq<char>
    recommends i >= 0
{
    seq!['1']
}

spec fn parse_int_from_string(s: Seq<char>) -> int
    recommends s.len() > 0
{
    1
}

spec fn valid_input(stdin_input: Seq<char>) -> bool
{
    stdin_input.len() > 0
}

spec fn sum_of_non_fizzbuzz_numbers(n: int) -> int
    recommends n >= 0
    decreases n when n >= 0
{
    if n <= 0 {
        0
    } else {
        let num = n;
        if num % 3 != 0 && num % 5 != 0 {
            sum_of_non_fizzbuzz_numbers(n - 1) + num
        } else {
            sum_of_non_fizzbuzz_numbers(n - 1)
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(stdin_input)
    ensures result.len() > 0
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn int_to_string(i: int) -> Seq<char>\n    recommends i >= 0\n{\n    seq!['1']\n}\n\nspec fn parse_int_from_string(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    1\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool\n{\n    stdin_input.len() > 0\n}\n\nspec fn sum_of_non_fizzbuzz_numbers(n: int) -> int\n    recommends n >= 0\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        0\n    } else {\n        let num = n;\n        if num % 3 != 0 && num % 5 != 0 {\n            sum_of_non_fizzbuzz_numbers(n - 1) + num\n        } else {\n            sum_of_non_fizzbuzz_numbers(n - 1)\n        }\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(stdin_input)\n    ensures result.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        fn main() {}\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4233.rs,147,147,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn min_int(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_input(input: Seq<u8>) -> bool {
    input.len() >= 1 && 
    parse_grid_dimensions(input).is_some() &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => n >= 3 && m >= 3 && grid_has_valid_format(input, n, m),
        None => false
    })
}

spec fn parse_grid_dimensions(input: Seq<u8>) -> Option<(int, int)> {
    Some((3, 3)) /* Placeholder - actual parsing would be complex */
}

spec fn grid_has_valid_format(input: Seq<u8>, n: int, m: int) -> bool {
    true /* Placeholder - check that grid has n rows of m characters each, containing only '*' and '.' */
}

spec fn exists_valid_star_decomposition(input: Seq<u8>) -> bool {
    valid_input(input) &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => exists|k: int, stars: Seq<(int, int, int)>| 
            0 <= k <= n * m && stars.len() == k &&
            (forall|s: (int, int, int)| stars.contains(s) ==> 
                1 <= s.0 <= n && 1 <= s.1 <= m && 1 <= s.2 <= min_int(n, m)) &&
            valid_star_decomposition(input, stars),
        None => false
    })
}

spec fn valid_star_decomposition(input: Seq<u8>, stars: Seq<(int, int, int)>) -> bool {
    valid_input(input) &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => 
            (forall|s: (int, int, int)| stars.contains(s) ==> 
                s.0 >= 1 && s.0 <= n && s.1 >= 1 && s.1 <= m && s.2 > 0 &&
                valid_star(n, m, s.0, s.1, s.2)) &&
            (forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>
                (grid_char_at(input, i, j) == b'*') <==> covered_by_stars(stars, i, j)),
        None => false
    })
}

spec fn valid_star(n: int, m: int, x: int, y: int, s: int) -> bool {
    x >= 1 && x <= n && y >= 1 && y <= m && s > 0 &&
    x - s >= 1 && x + s <= n && y - s >= 1 && y + s <= m
}

spec fn covered_by_stars(stars: Seq<(int, int, int)>, i: int, j: int) -> bool {
    exists|s: (int, int, int)| stars.contains(s) && covered_by_star(s.0, s.1, s.2, i, j)
}

spec fn covered_by_star(x: int, y: int, size: int, i: int, j: int) -> bool {
    (i == x && j == y) ||
    (i == x && 1 <= abs_int(j - y) <= size) ||
    (j == y && 1 <= abs_int(i - x) <= size)
}

spec fn abs_int(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn grid_char_at(input: Seq<u8>, i: int, j: int) -> u8 {
    b'*' /* Placeholder - actual grid parsing would be complex */
}

spec fn starts_with_int_and_valid_format(s: Seq<u8>, k: int) -> bool {
    s.len() > 0 && 
    int_to_string_len(k) <= s.len() && 
    s.subrange(0, int_to_string_len(k) as int) == int_to_string_seq(k)
}

spec fn int_to_string_len(k: int) -> nat {
    1 /* Placeholder */
}

spec fn int_to_string_seq(k: int) -> Seq<u8> {
    seq![b'0'] /* Placeholder */
}

spec fn format_star_output(k: int, stars: Seq<(int, int, int)>) -> Seq<u8> {
    if k >= 0 && stars.len() == k {
        let result = int_to_string_seq(k).add(seq![b'\n']);
        format_star_output_helper(result, stars, 0)
    } else {
        seq![]
    }
}

spec fn format_star_output_helper(result: Seq<u8>, stars: Seq<(int, int, int)>, idx: int) -> Seq<u8> 
    decreases stars.len() - idx
{
    if 0 <= idx <= stars.len() {
        if idx >= stars.len() { 
            result 
        } else { 
            let new_result = result.add(int_to_string_seq(stars[idx].0))
                .add(seq![b' ']).add(int_to_string_seq(stars[idx].1))
                .add(seq![b' ']).add(int_to_string_seq(stars[idx].2))
                .add(seq![b'\n']);
            format_star_output_helper(new_result, stars, idx + 1)
        }
    } else {
        result
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures
        valid_input(input.as_bytes()@) ==> 
            (result.as_bytes()@ == seq![b'-', b'1', b'\n']) <==> !exists_valid_star_decomposition(input.as_bytes()@),
        valid_input(input.as_bytes()@) && result.as_bytes()@ != seq![b'-', b'1', b'\n'] ==>
            (exists|k: int, stars: Seq<(int, int, int)>|
                k >= 0 && stars.len() == k &&
                valid_star_decomposition(input.as_bytes()@, stars) &&
                result.as_bytes()@ == format_star_output(k, stars)),
        valid_input(input.as_bytes()@) ==> result.as_bytes()@ != seq![],
        !valid_input(input.as_bytes()@) ==> result.as_bytes()@ == seq![b'-', b'1', b'\n'],
        result.as_bytes()@ == seq![b'-', b'1', b'\n'] || (exists|k: int| k >= 0 && starts_with_int_and_valid_format(result.as_bytes()@, k)),
        result.as_bytes()@ == seq![] || result.as_bytes()@[result.as_bytes()@.len()-1] == b'\n',
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""-1\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn min_int(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_input(input: Seq<u8>) -> bool {
    input.len() >= 1 && 
    parse_grid_dimensions(input).is_some() &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => n >= 3 && m >= 3 && grid_has_valid_format(input, n, m),
        None => false
    })
}

spec fn parse_grid_dimensions(input: Seq<u8>) -> Option<(int, int)> {
    Some((3, 3)) /* Placeholder - actual parsing would be complex */
}

spec fn grid_has_valid_format(input: Seq<u8>, n: int, m: int) -> bool {
    true /* Placeholder - check that grid has n rows of m characters each, containing only '*' and '.' */
}

spec fn exists_valid_star_decomposition(input: Seq<u8>) -> bool {
    valid_input(input) &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => exists|k: int, stars: Seq<(int, int, int)>| 
            0 <= k <= n * m && stars.len() == k &&
            (forall|s: (int, int, int)| stars.contains(s) ==> 
                1 <= s.0 <= n && 1 <= s.1 <= m && 1 <= s.2 <= min_int(n, m)) &&
            valid_star_decomposition(input, stars),
        None => false
    })
}

spec fn valid_star_decomposition(input: Seq<u8>, stars: Seq<(int, int, int)>) -> bool {
    valid_input(input) &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => 
            (forall|s: (int, int, int)| stars.contains(s) ==> 
                s.0 >= 1 && s.0 <= n && s.1 >= 1 && s.1 <= m && s.2 > 0 &&
                valid_star(n, m, s.0, s.1, s.2)) &&
            (forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>
                (grid_char_at(input, i, j) == b'*') <==> covered_by_stars(stars, i, j)),
        None => false
    })
}

spec fn valid_star(n: int, m: int, x: int, y: int, s: int) -> bool {
    x >= 1 && x <= n && y >= 1 && y <= m && s > 0 &&
    x - s >= 1 && x + s <= n && y - s >= 1 && y + s <= m
}

spec fn covered_by_stars(stars: Seq<(int, int, int)>, i: int, j: int) -> bool {
    exists|s: (int, int, int)| stars.contains(s) && covered_by_star(s.0, s.1, s.2, i, j)
}

spec fn covered_by_star(x: int, y: int, size: int, i: int, j: int) -> bool {
    (i == x && j == y) ||
    (i == x && 1 <= abs_int(j - y) <= size) ||
    (j == y && 1 <= abs_int(i - x) <= size)
}

spec fn abs_int(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn grid_char_at(input: Seq<u8>, i: int, j: int) -> u8 {
    b'*' /* Placeholder - actual grid parsing would be complex */
}

spec fn starts_with_int_and_valid_format(s: Seq<u8>, k: int) -> bool {
    s.len() > 0 && 
    int_to_string_len(k) <= s.len() && 
    s.subrange(0, int_to_string_len(k) as int) == int_to_string_seq(k)
}

spec fn int_to_string_len(k: int) -> nat {
    1 /* Placeholder */
}

spec fn int_to_string_seq(k: int) -> Seq<u8> {
    seq![b'0'] /* Placeholder */
}

spec fn format_star_output(k: int, stars: Seq<(int, int, int)>) -> Seq<u8> {
    if k >= 0 && stars.len() == k {
        let result = int_to_string_seq(k).add(seq![b'\n']);
        format_star_output_helper(result, stars, 0)
    } else {
        seq![]
    }
}

spec fn format_star_output_helper(result: Seq<u8>, stars: Seq<(int, int, int)>, idx: int) -> Seq<u8> 
    decreases stars.len() - idx
{
    if 0 <= idx <= stars.len() {
        if idx >= stars.len() { 
            result 
        } else { 
            let new_result = result.add(int_to_string_seq(stars[idx].0))
                .add(seq![b' ']).add(int_to_string_seq(stars[idx].1))
                .add(seq![b' ']).add(int_to_string_seq(stars[idx].2))
                .add(seq![b'\n']);
            format_star_output_helper(new_result, stars, idx + 1)
        }
    } else {
        result
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures
        valid_input(input.as_bytes()@) ==> 
            (result.as_bytes()@ == seq![b'-', b'1', b'\n']) <==> !exists_valid_star_decomposition(input.as_bytes()@),
        valid_input(input.as_bytes()@) && result.as_bytes()@ != seq![b'-', b'1', b'\n'] ==>
            (exists|k: int, stars: Seq<(int, int, int)>|
                k >= 0 && stars.len() == k &&
                valid_star_decomposition(input.as_bytes()@, stars) &&
                result.as_bytes()@ == format_star_output(k, stars)),
        valid_input(input.as_bytes()@) ==> result.as_bytes()@ != seq![],
        !valid_input(input.as_bytes()@) ==> result.as_bytes()@ == seq![b'-', b'1', b'\n'],
        result.as_bytes()@ == seq![b'-', b'1', b'\n'] || (exists|k: int| k >= 0 && starts_with_int_and_valid_format(result.as_bytes()@, k)),
        result.as_bytes()@ == seq![] || result.as_bytes()@[result.as_bytes()@.len()-1] == b'\n',
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""-1\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4271.rs,66,66,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>, c: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    b.len() == n &&
    c.len() == n - 1 &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] a[i] != #[trigger] a[j])
}

spec fn sum_satisfaction(a: Seq<int>, b: Seq<int>, c: Seq<int>, n: int) -> int
    recommends
        n >= 1,
        a.len() == n,
        b.len() == n,
        c.len() == n - 1,
        forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n
{
    sum_satisfaction_up_to(a, b, c, n)
}

spec fn sum_satisfaction_up_to(a: Seq<int>, b: Seq<int>, c: Seq<int>, k: int) -> int
    recommends
        0 <= k <= a.len(),
        b.len() == a.len(),
        c.len() == a.len() - 1,
        forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= a.len()
    decreases k
{
    if k <= 0 {
        0
    } else {
        let prev_sum = sum_satisfaction_up_to(a, b, c, k - 1);
        let base_contrib = b[a[k - 1] - 1];
        let bonus_contrib = if k > 1 && a[k - 1] == a[k - 2] + 1 {
            c[a[k - 1] - 2]
        } else {
            0
        };
        prev_sum + base_contrib + bonus_contrib
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>, b: Vec<i8>, c: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))
    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>, c: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    b.len() == n &&
    c.len() == n - 1 &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] a[i] != #[trigger] a[j])
}

spec fn sum_satisfaction(a: Seq<int>, b: Seq<int>, c: Seq<int>, n: int) -> int
    recommends
        n >= 1,
        a.len() == n,
        b.len() == n,
        c.len() == n - 1,
        forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n
{
    sum_satisfaction_up_to(a, b, c, n)
}

spec fn sum_satisfaction_up_to(a: Seq<int>, b: Seq<int>, c: Seq<int>, k: int) -> int
    recommends
        0 <= k <= a.len(),
        b.len() == a.len(),
        c.len() == a.len() - 1,
        forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= a.len()
    decreases k
{
    if k <= 0 {
        0
    } else {
        let prev_sum = sum_satisfaction_up_to(a, b, c, k - 1);
        let base_contrib = b[a[k - 1] - 1];
        let bonus_contrib = if k > 1 && a[k - 1] == a[k - 2] + 1 {
            c[a[k - 1] - 2]
        } else {
            0
        };
        prev_sum + base_contrib + bonus_contrib
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>, b: Vec<i8>, c: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))
    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4274.rs,60,60,1.0,215.815,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { seq![] }

spec fn str_to_int(s: Seq<char>) -> int { 0 }

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|lines: Seq<Seq<char>>| lines == split_string(input, '\n') && lines.len() > 0 &&
    exists|parts: Seq<Seq<char>>| parts == split_string(lines[0], ' ') && parts.len() == 2 &&
    {
        let n = str_to_int(parts[0]);
        let m = str_to_int(parts[1]);
        1 <= n <= 100 && 0 <= m <= n
    }
}

spec fn extract_n(input: Seq<char>) -> int {
    let lines = split_string(input, '\n');
    let parts = split_string(lines[0], ' ');
    str_to_int(parts[0])
}

spec fn extract_m(input: Seq<char>) -> int {
    let lines = split_string(input, '\n');
    let parts = split_string(lines[0], ' ');
    str_to_int(parts[1])
}

spec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {
    let n = extract_n(input);
    let m = extract_m(input);
    (n == m ==> result == seq!['Y', 'e', 's']) && (n != m ==> result == seq!['N', 'o'])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
requires 
    valid_input(input@)
ensures 
    correct_output(input@, result@),
    result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { seq![] }

spec fn str_to_int(s: Seq<char>) -> int { 0 }

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|lines: Seq<Seq<char>>| lines == split_string(input, '\n') && lines.len() > 0 &&
    exists|parts: Seq<Seq<char>>| parts == split_string(lines[0], ' ') && parts.len() == 2 &&
    {
        let n = str_to_int(parts[0]);
        let m = str_to_int(parts[1]);
        1 <= n <= 100 && 0 <= m <= n
    }
}

spec fn extract_n(input: Seq<char>) -> int {
    let lines = split_string(input, '\n');
    let parts = split_string(lines[0], ' ');
    str_to_int(parts[0])
}

spec fn extract_m(input: Seq<char>) -> int {
    let lines = split_string(input, '\n');
    let parts = split_string(lines[0], ' ');
    str_to_int(parts[1])
}

spec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {
    let n = extract_n(input);
    let m = extract_m(input);
    (n == m ==> result == seq!['Y', 'e', 's']) && (n != m ==> result == seq!['N', 'o'])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
requires 
    valid_input(input@)
ensures 
    correct_output(input@, result@),
    result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { seq![] }\n\nspec fn str_to_int(s: Seq<char>) -> int { 0 }\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|lines: Seq<Seq<char>>| lines == split_string(input, '\\n') && lines.len() > 0 &&\n    exists|parts: Seq<Seq<char>>| parts == split_string(lines[0], ' ') && parts.len() == 2 &&\n    {\n        let n = str_to_int(parts[0]);\n        let m = str_to_int(parts[1]);\n        1 <= n <= 100 && 0 <= m <= n\n    }\n}\n\nspec fn extract_n(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[0])\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[1])\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let n = extract_n(input);\n    let m = extract_m(input);\n    (n == m ==> result == seq!['Y', 'e', 's']) && (n != m ==> result == seq!['N', 'o'])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\nrequires \n    valid_input(input@)\nensures \n    correct_output(input@, result@),\n    result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4307.rs,56,56,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn is_odd(n: int) -> bool {
    n % 2 == 1
}

spec fn count_divisors(n: nat) -> nat
    recommends n > 0
{
    Set::new(|d: nat| 1 <= d <= n && n % d == 0).len()
}

spec fn has_eight_divisors(n: nat) -> bool
    recommends n > 0
{
    count_divisors(n) == 8
}

spec fn count_odd_with_eight_divisors(n: nat) -> nat {
    Set::new(|i: nat| 1 <= i <= n && is_odd(i as int) && i > 0 && has_eight_divisors(i)).len()
}

spec fn valid_input(n: int) -> bool {
    1 <= n <= 200
}
// </vc-helpers>

// <vc-spec>
fn solve(n: int) -> (count: int)
    requires 
        valid_input(n)
    ensures 
        n < 105 ==> count == 0,
        105 <= n && n < 135 ==> count == 1,
        135 <= n && n < 165 ==> count == 2,
        165 <= n && n < 189 ==> count == 3,
        189 <= n && n < 195 ==> count == 4,
        n >= 195 ==> count == 5,
        0 <= count && count <= 5,
// </vc-spec>
// <vc-code>
{
    assume(false);
    0int
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn is_odd(n: int) -> bool {
    n % 2 == 1
}

spec fn count_divisors(n: nat) -> nat
    recommends n > 0
{
    Set::new(|d: nat| 1 <= d <= n && n % d == 0).len()
}

spec fn has_eight_divisors(n: nat) -> bool
    recommends n > 0
{
    count_divisors(n) == 8
}

spec fn count_odd_with_eight_divisors(n: nat) -> nat {
    Set::new(|i: nat| 1 <= i <= n && is_odd(i as int) && i > 0 && has_eight_divisors(i)).len()
}

spec fn valid_input(n: int) -> bool {
    1 <= n <= 200
}
// </vc-helpers>

// <vc-spec>
fn solve(n: int) -> (count: int)
    requires 
        valid_input(n)
    ensures 
        n < 105 ==> count == 0,
        105 <= n && n < 135 ==> count == 1,
        135 <= n && n < 165 ==> count == 2,
        165 <= n && n < 189 ==> count == 3,
        189 <= n && n < 195 ==> count == 4,
        n >= 195 ==> count == 5,
        0 <= count && count <= 5,
// </vc-spec>
// <vc-code>
{
    assume(false);
    0int
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4346.rs,108,108,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]
}

spec fn join_lines(lines: Seq<Seq<char>>) -> Seq<char> {
    seq![]
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 &&
    is_valid_integer(lines[0]) &&
    {
        let t = parse_int(lines[0]);
        t >= 0 && lines.len() >= t + 1 &&
        forall|i: int| 1 <= i <= t ==> {
            let line_parts = split_spaces(lines[i]);
            line_parts.len() >= 4 &&
            forall|j: int| 0 <= j < 4 ==> is_valid_integer(line_parts[j]) &&
            {
                let parts = split_spaces(lines[i]);
                let L = parse_int(parts[0]);
                let v = parse_int(parts[1]);
                let l = parse_int(parts[2]);
                let r = parse_int(parts[3]);
                L >= 1 && v >= 1 && l >= 1 && r >= l && r <= L
            }
        }
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    forall|c: char| output.contains(c) ==> (c >= '0' && c <= '9') || c == '-' || c == '\n'
}

spec fn output_matches_algorithm(output: Seq<char>, input: Seq<char>) -> bool
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let t = parse_int(lines[0]);
    t >= 0 &&
    {
        let expected_lines = Seq::new(t as nat, |i: int| {
            if i + 1 < lines.len() && split_spaces(lines[i + 1]).len() >= 4 {
                let parts = split_spaces(lines[i + 1]);
                let L = parse_int(parts[0]);
                let v = parse_int(parts[1]);
                let l = parse_int(parts[2]);
                let r = parse_int(parts[3]);
                let total_lanterns = L / v;
                let blocked_lanterns = r / v - (l - 1) / v;
                let visible_lanterns = total_lanterns - blocked_lanterns;
                int_to_string(visible_lanterns)
            } else {
                seq!['0']
            }
        });
        output == join_lines(expected_lines)
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (
        (s[0] == '-' && s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9') ||
        (s[0] != '-' && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9')
    )
}
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (output: String)
    requires 
        input.len() > 0,
        valid_input(input@),
    ensures 
        valid_output(output@, input@),
        output_matches_algorithm(output@, input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    String::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]
}

spec fn join_lines(lines: Seq<Seq<char>>) -> Seq<char> {
    seq![]
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 &&
    is_valid_integer(lines[0]) &&
    {
        let t = parse_int(lines[0]);
        t >= 0 && lines.len() >= t + 1 &&
        forall|i: int| 1 <= i <= t ==> {
            let line_parts = split_spaces(lines[i]);
            line_parts.len() >= 4 &&
            forall|j: int| 0 <= j < 4 ==> is_valid_integer(line_parts[j]) &&
            {
                let parts = split_spaces(lines[i]);
                let L = parse_int(parts[0]);
                let v = parse_int(parts[1]);
                let l = parse_int(parts[2]);
                let r = parse_int(parts[3]);
                L >= 1 && v >= 1 && l >= 1 && r >= l && r <= L
            }
        }
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    forall|c: char| output.contains(c) ==> (c >= '0' && c <= '9') || c == '-' || c == '\n'
}

spec fn output_matches_algorithm(output: Seq<char>, input: Seq<char>) -> bool
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let t = parse_int(lines[0]);
    t >= 0 &&
    {
        let expected_lines = Seq::new(t as nat, |i: int| {
            if i + 1 < lines.len() && split_spaces(lines[i + 1]).len() >= 4 {
                let parts = split_spaces(lines[i + 1]);
                let L = parse_int(parts[0]);
                let v = parse_int(parts[1]);
                let l = parse_int(parts[2]);
                let r = parse_int(parts[3]);
                let total_lanterns = L / v;
                let blocked_lanterns = r / v - (l - 1) / v;
                let visible_lanterns = total_lanterns - blocked_lanterns;
                int_to_string(visible_lanterns)
            } else {
                seq!['0']
            }
        });
        output == join_lines(expected_lines)
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (
        (s[0] == '-' && s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9') ||
        (s[0] != '-' && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9')
    )
}
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (output: String)
    requires 
        input.len() > 0,
        valid_input(input@),
    ensures 
        valid_output(output@, input@),
        output_matches_algorithm(output@, input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    String::new()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4364.rs,68,68,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<u8>) -> bool {
    s.len() >= 4 && forall|i: int| 0 <= i < 4 ==> b'0' <= s[i] <= b'9'
}

spec fn char_pair_to_int(c1: u8, c2: u8) -> int 
    recommends b'0' <= c1 <= b'9' && b'0' <= c2 <= b'9'
{
    (c1 as int - b'0' as int) * 10 + (c2 as int - b'0' as int)
}

spec fn valid_month(n: int) -> bool {
    1 <= n <= 12
}

spec fn get_first_pair(s: Seq<u8>) -> int 
    recommends valid_input(s)
{
    char_pair_to_int(s[0], s[1])
}

spec fn get_second_pair(s: Seq<u8>) -> int 
    recommends valid_input(s)
{
    char_pair_to_int(s[2], s[3])
}

spec fn correct_result(s: Seq<u8>, result: Seq<u8>) -> bool 
    recommends valid_input(s)
{
    let s1 = get_first_pair(s);
    let s2 = get_second_pair(s);
    let s1_valid = valid_month(s1);
    let s2_valid = valid_month(s2);
    (s1_valid && s2_valid ==> result == ""AMBIGUOUS\n"".as_bytes()) &&
    (s1_valid && !s2_valid ==> result == ""MMYY\n"".as_bytes()) &&
    (!s1_valid && s2_valid ==> result == ""YYMM\n"".as_bytes()) &&
    (!s1_valid && !s2_valid ==> result == ""NA\n"".as_bytes())
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(stdin_input@),
    ensures (result@ == ""AMBIGUOUS\n"".as_bytes() || 
             result@ == ""MMYY\n"".as_bytes() || 
             result@ == ""YYMM\n"".as_bytes() || 
             result@ == ""NA\n"".as_bytes()) &&
            correct_result(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<u8>) -> bool {
    s.len() >= 4 && forall|i: int| 0 <= i < 4 ==> b'0' <= s[i] <= b'9'
}

spec fn char_pair_to_int(c1: u8, c2: u8) -> int 
    recommends b'0' <= c1 <= b'9' && b'0' <= c2 <= b'9'
{
    (c1 as int - b'0' as int) * 10 + (c2 as int - b'0' as int)
}

spec fn valid_month(n: int) -> bool {
    1 <= n <= 12
}

spec fn get_first_pair(s: Seq<u8>) -> int 
    recommends valid_input(s)
{
    char_pair_to_int(s[0], s[1])
}

spec fn get_second_pair(s: Seq<u8>) -> int 
    recommends valid_input(s)
{
    char_pair_to_int(s[2], s[3])
}

spec fn correct_result(s: Seq<u8>, result: Seq<u8>) -> bool 
    recommends valid_input(s)
{
    let s1 = get_first_pair(s);
    let s2 = get_second_pair(s);
    let s1_valid = valid_month(s1);
    let s2_valid = valid_month(s2);
    (s1_valid && s2_valid ==> result == ""AMBIGUOUS\n"".as_bytes()) &&
    (s1_valid && !s2_valid ==> result == ""MMYY\n"".as_bytes()) &&
    (!s1_valid && s2_valid ==> result == ""YYMM\n"".as_bytes()) &&
    (!s1_valid && !s2_valid ==> result == ""NA\n"".as_bytes())
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(stdin_input@),
    ensures (result@ == ""AMBIGUOUS\n"".as_bytes() || 
             result@ == ""MMYY\n"".as_bytes() || 
             result@ == ""YYMM\n"".as_bytes() || 
             result@ == ""NA\n"".as_bytes()) &&
            correct_result(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4398.rs,82,82,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

/* Helper functions for string processing - these would need to be defined elsewhere */
spec fn split_lines(input: &str) -> Seq<&str>;
spec fn string_to_int(s: &str) -> int;
spec fn split_by_space(s: &str) -> Seq<&str>;

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && {
        let n = string_to_int(lines[0]);
        let parts = split_by_space(lines[1]);
        parts.len() >= 2 &&
        n >= 0 &&
        n <= parts[0].len() && n <= parts[1].len()
    }
}

spec fn get_n(input: &str) -> int
    recommends valid_input(input)
{
    let lines = split_lines(input);
    string_to_int(lines[0])
}

spec fn get_s(input: &str) -> &str
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let parts = split_by_space(lines[1]);
    parts[0]
}

spec fn get_t(input: &str) -> &str
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let parts = split_by_space(lines[1]);
    parts[1]
}

spec fn alternate_chars(s: &str, t: &str, n: int) -> Seq<char>
    recommends n >= 0 && n <= s.len() && n <= t.len()
{
    if n == 0 {
        seq![]
    } else {
        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures
        valid_input(input) ==> {
            let n = get_n(input);
            let s = get_s(input);
            let t = get_t(input);
            result.len() == 2 * n + 1 &&
            result.get_char((result.len() - 1) as int) == '\n' &&
            result.substring_char(0, (result.len() - 1) as int).view() == alternate_chars(s, t, n)
        } && !valid_input(input) ==> result == """"
// </vc-spec>
// <vc-code>
{
    assume(false);
    String::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

/* Helper functions for string processing - these would need to be defined elsewhere */
spec fn split_lines(input: &str) -> Seq<&str>;
spec fn string_to_int(s: &str) -> int;
spec fn split_by_space(s: &str) -> Seq<&str>;

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && {
        let n = string_to_int(lines[0]);
        let parts = split_by_space(lines[1]);
        parts.len() >= 2 &&
        n >= 0 &&
        n <= parts[0].len() && n <= parts[1].len()
    }
}

spec fn get_n(input: &str) -> int
    recommends valid_input(input)
{
    let lines = split_lines(input);
    string_to_int(lines[0])
}

spec fn get_s(input: &str) -> &str
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let parts = split_by_space(lines[1]);
    parts[0]
}

spec fn get_t(input: &str) -> &str
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let parts = split_by_space(lines[1]);
    parts[1]
}

spec fn alternate_chars(s: &str, t: &str, n: int) -> Seq<char>
    recommends n >= 0 && n <= s.len() && n <= t.len()
{
    if n == 0 {
        seq![]
    } else {
        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures
        valid_input(input) ==> {
            let n = get_n(input);
            let s = get_s(input);
            let t = get_t(input);
            result.len() == 2 * n + 1 &&
            result.get_char((result.len() - 1) as int) == '\n' &&
            result.substring_char(0, (result.len() - 1) as int).view() == alternate_chars(s, t, n)
        } && !valid_input(input) ==> result == """"
// </vc-spec>
// <vc-code>
{
    assume(false);
    String::new()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4418.rs,98,98,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 0 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> 
        #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || 
        #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int
}

spec fn number_of_complete_subsequences(n: int, a: Seq<int>) -> int {
    let k = seq![4int, 8int, 15int, 16int, 23int, 42int];
    let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];
    let final_s = process_array(s, a, k, 0int);
    final_s[6int]
}

spec fn process_array(s: Seq<int>, a: Seq<int>, k: Seq<int>, index: int) -> Seq<int>
    decreases a.len() - index
{
    if s.len() == 7 && k.len() == 6 && 0 <= index <= a.len() &&
       (forall|i: int| 0 <= i < a.len() ==> 
            #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || 
            #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int) &&
       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&
       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {
        if index == a.len() {
            s
        } else {
            let ai = a[index];
            let new_s = update_state(s, ai, k);
            process_array(new_s, a, k, index + 1)
        }
    } else {
        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]
    }
}

spec fn update_state(s: Seq<int>, ai: int, k: Seq<int>) -> Seq<int> {
    if s.len() == 7 && k.len() == 6 &&
       (ai == 4int || ai == 8int || ai == 15int || ai == 16int || ai == 23int || ai == 42int) &&
       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&
       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {
        if ai == k[5int] && s[5int] > 0 {
            s.update(6int, s[6int] + 1).update(5int, s[5int] - 1)
        } else if ai == k[4int] && s[4int] > 0 {
            s.update(5int, s[5int] + 1).update(4int, s[4int] - 1)
        } else if ai == k[3int] && s[3int] > 0 {
            s.update(4int, s[4int] + 1).update(3int, s[3int] - 1)
        } else if ai == k[2int] && s[2int] > 0 {
            s.update(3int, s[3int] + 1).update(2int, s[2int] - 1)
        } else if ai == k[1int] && s[1int] > 0 {
            s.update(2int, s[2int] + 1).update(1int, s[1int] - 1)
        } else if ai == k[0int] && s[0int] > 0 {
            s.update(1int, s[1int] + 1).update(0int, s[0int] - 1)
        } else {
            s
        }
    } else {
        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]
    }
}

spec fn number_of_complete_subsequences_partial(n: int, a: Seq<int>, k: Seq<int>, index: int) -> int {
    if valid_input(n, a) && k.len() == 6 && k == seq![4int, 8int, 15int, 16int, 23int, 42int] && 0 <= index <= a.len() {
        let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];
        let partial_a = if index == 0 { seq![] } else { a.subrange(0int, index) };
        let final_s = process_array(s, partial_a, k, 0int);
        final_s[6int]
    } else {
        0int
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
  requires
    valid_input(n as int, a@.map(|x: i8| x as int)),
  ensures
    0 <= result as int <= n as int,
    result as int == n as int - 6 * number_of_complete_subsequences(n as int, a@.map(|x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 0 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> 
        #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || 
        #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int
}

spec fn number_of_complete_subsequences(n: int, a: Seq<int>) -> int {
    let k = seq![4int, 8int, 15int, 16int, 23int, 42int];
    let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];
    let final_s = process_array(s, a, k, 0int);
    final_s[6int]
}

spec fn process_array(s: Seq<int>, a: Seq<int>, k: Seq<int>, index: int) -> Seq<int>
    decreases a.len() - index
{
    if s.len() == 7 && k.len() == 6 && 0 <= index <= a.len() &&
       (forall|i: int| 0 <= i < a.len() ==> 
            #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || 
            #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int) &&
       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&
       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {
        if index == a.len() {
            s
        } else {
            let ai = a[index];
            let new_s = update_state(s, ai, k);
            process_array(new_s, a, k, index + 1)
        }
    } else {
        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]
    }
}

spec fn update_state(s: Seq<int>, ai: int, k: Seq<int>) -> Seq<int> {
    if s.len() == 7 && k.len() == 6 &&
       (ai == 4int || ai == 8int || ai == 15int || ai == 16int || ai == 23int || ai == 42int) &&
       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&
       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {
        if ai == k[5int] && s[5int] > 0 {
            s.update(6int, s[6int] + 1).update(5int, s[5int] - 1)
        } else if ai == k[4int] && s[4int] > 0 {
            s.update(5int, s[5int] + 1).update(4int, s[4int] - 1)
        } else if ai == k[3int] && s[3int] > 0 {
            s.update(4int, s[4int] + 1).update(3int, s[3int] - 1)
        } else if ai == k[2int] && s[2int] > 0 {
            s.update(3int, s[3int] + 1).update(2int, s[2int] - 1)
        } else if ai == k[1int] && s[1int] > 0 {
            s.update(2int, s[2int] + 1).update(1int, s[1int] - 1)
        } else if ai == k[0int] && s[0int] > 0 {
            s.update(1int, s[1int] + 1).update(0int, s[0int] - 1)
        } else {
            s
        }
    } else {
        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]
    }
}

spec fn number_of_complete_subsequences_partial(n: int, a: Seq<int>, k: Seq<int>, index: int) -> int {
    if valid_input(n, a) && k.len() == 6 && k == seq![4int, 8int, 15int, 16int, 23int, 42int] && 0 <= index <= a.len() {
        let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];
        let partial_a = if index == 0 { seq![] } else { a.subrange(0int, index) };
        let final_s = process_array(s, partial_a, k, 0int);
        final_s[6int]
    } else {
        0int
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
  requires
    valid_input(n as int, a@.map(|x: i8| x as int)),
  ensures
    0 <= result as int <= n as int,
    result as int == n as int - 6 * number_of_complete_subsequences(n as int, a@.map(|x: i8| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4460.rs,88,88,1.0,216.487,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> 
        s[i] == ' ' || s[i] == '\n' || ('0' <= s[i] <= '9') || s[i] == '-')
}

spec fn valid_number(s: Seq<char>) -> bool {
    s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> 
        '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))
}

spec fn count_zeros(numbers: Seq<int>) -> int
    decreases numbers.len()
{
    if numbers.len() == 0 {
        0int
    } else {
        (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))
    }
}

spec fn find_zero_index(numbers: Seq<int>) -> int
    decreases numbers.len()
{
    if numbers.len() > 0 && count_zeros(numbers) == 1 {
        if numbers[0] == 0 {
            0int
        } else if numbers.len() > 1 {
            1int + find_zero_index(numbers.subrange(1, numbers.len() as int))
        } else {
            0int
        }
    } else {
        0int
    }
}

spec fn parse_ints(s: Seq<char>) -> Seq<int> {
    if s.len() > 0 && valid_input(s) {
        parse_ints_helper(s, 0, seq![], seq![])
    } else {
        seq![]
    }
}

spec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>
    decreases s.len() - pos
{
    seq![]
}

spec fn generate_output(numbers: Seq<int>) -> Seq<char> {
    generate_output_helper(numbers, 0, seq![])
}

spec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        valid_input(input@),
        input@.len() > 0,
    ensures 
        ({
            let numbers = parse_ints(input@);
            result@ == generate_output(numbers)
        }),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> 
        s[i] == ' ' || s[i] == '\n' || ('0' <= s[i] <= '9') || s[i] == '-')
}

spec fn valid_number(s: Seq<char>) -> bool {
    s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> 
        '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))
}

spec fn count_zeros(numbers: Seq<int>) -> int
    decreases numbers.len()
{
    if numbers.len() == 0 {
        0int
    } else {
        (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))
    }
}

spec fn find_zero_index(numbers: Seq<int>) -> int
    decreases numbers.len()
{
    if numbers.len() > 0 && count_zeros(numbers) == 1 {
        if numbers[0] == 0 {
            0int
        } else if numbers.len() > 1 {
            1int + find_zero_index(numbers.subrange(1, numbers.len() as int))
        } else {
            0int
        }
    } else {
        0int
    }
}

spec fn parse_ints(s: Seq<char>) -> Seq<int> {
    if s.len() > 0 && valid_input(s) {
        parse_ints_helper(s, 0, seq![], seq![])
    } else {
        seq![]
    }
}

spec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>
    decreases s.len() - pos
{
    seq![]
}

spec fn generate_output(numbers: Seq<int>) -> Seq<char> {
    generate_output_helper(numbers, 0, seq![])
}

spec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        valid_input(input@),
        input@.len() > 0,
    ensures 
        ({
            let numbers = parse_ints(input@);
            result@ == generate_output(numbers)
        }),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> \n        s[i] == ' ' || s[i] == '\\n' || ('0' <= s[i] <= '9') || s[i] == '-')\n}\n\nspec fn valid_number(s: Seq<char>) -> bool {\n    s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> \n        '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))\n}\n\nspec fn count_zeros(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        0int\n    } else {\n        (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))\n    }\n}\n\nspec fn find_zero_index(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() > 0 && count_zeros(numbers) == 1 {\n        if numbers[0] == 0 {\n            0int\n        } else if numbers.len() > 1 {\n            1int + find_zero_index(numbers.subrange(1, numbers.len() as int))\n        } else {\n            0int\n        }\n    } else {\n        0int\n    }\n}\n\nspec fn parse_ints(s: Seq<char>) -> Seq<int> {\n    if s.len() > 0 && valid_input(s) {\n        parse_ints_helper(s, 0, seq![], seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>\n    decreases s.len() - pos\n{\n    seq![]\n}\n\nspec fn generate_output(numbers: Seq<int>) -> Seq<char> {\n    generate_output_helper(numbers, 0, seq![])\n}\n\nspec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input@),\n        input@.len() > 0,\n    ensures \n        ({\n            let numbers = parse_ints(input@);\n            result@ == generate_output(numbers)\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4492.rs,106,106,1.0,186.616,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

/* Helper spec functions for string parsing */
spec fn split_by_newline_spec(s: &str) -> Seq<&str> { Seq::empty() }
spec fn split_by_space_spec(s: &str) -> Seq<&str> { Seq::empty() }
spec fn parse_int_spec(s: &str) -> int { 0 }
spec fn int_to_string_spec(n: int) -> Seq<char> { Seq::empty() }
spec fn string_len_spec(s: &str) -> nat { 0 }
spec fn string_result_len_spec(s: String) -> nat { 0 }

spec fn valid_input(input: &str) -> bool {
    let lines = split_by_newline_spec(input);
    lines.len() >= 2 &&
    {
        let first_line = split_by_space_spec(lines[0]);
        first_line.len() >= 2 &&
        {
            let n = parse_int_spec(first_line[0]);
            let x = parse_int_spec(first_line[1]);
            n >= 2 && x >= 0 &&
            {
                let second_line = split_by_space_spec(lines[1]);
                second_line.len() == n &&
                forall|i: int| 0 <= i < n ==> parse_int_spec(second_line[i]) >= 0
            }
        }
    }
}

spec fn minimum_candies_needed(input: &str) -> int
    recommends valid_input(input)
{
    let lines = split_by_newline_spec(input);
    let first_line = split_by_space_spec(lines[0]);
    let n = parse_int_spec(first_line[0]);
    let x = parse_int_spec(first_line[1]);
    let second_line = split_by_space_spec(lines[1]);
    let a = Seq::new(n as nat, |i: int| parse_int_spec(second_line[i]));
    compute_minimum_operations(a, x)
}

spec fn compute_minimum_operations(a: Seq<int>, x: int) -> int
    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0
{
    let a0 = if a[0] > x { x } else { a[0] };
    let cnt0 = if a[0] > x { a[0] - x } else { 0 };
    let new_a = a.update(0, a0);
    compute_operations_from_index(a, x, 1, new_a, cnt0)
}

spec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int
    recommends 
        original_a.len() >= 2 &&
        x >= 0 &&
        1 <= index <= original_a.len() &&
        current_a.len() == original_a.len() &&
        current_count >= 0 &&
        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0
    decreases original_a.len() - index
{
    if index >= original_a.len() {
        current_count
    } else {
        let new_value = if current_a[index] + current_a[index - 1] > x {
            x - current_a[index - 1]
        } else {
            current_a[index]
        };
        let additional_ops = if current_a[index] + current_a[index - 1] > x {
            current_a[index] + current_a[index - 1] - x
        } else {
            0
        };
        let new_a = current_a.update(index, new_value);
        compute_operations_from_index(original_a, x, index + 1, new_a, current_count + additional_ops)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        string_len_spec(input) > 0,
        valid_input(input),
    ensures 
        string_result_len_spec(result) > 0,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

/* Helper spec functions for string parsing */
spec fn split_by_newline_spec(s: &str) -> Seq<&str> { Seq::empty() }
spec fn split_by_space_spec(s: &str) -> Seq<&str> { Seq::empty() }
spec fn parse_int_spec(s: &str) -> int { 0 }
spec fn int_to_string_spec(n: int) -> Seq<char> { Seq::empty() }
spec fn string_len_spec(s: &str) -> nat { 0 }
spec fn string_result_len_spec(s: String) -> nat { 0 }

spec fn valid_input(input: &str) -> bool {
    let lines = split_by_newline_spec(input);
    lines.len() >= 2 &&
    {
        let first_line = split_by_space_spec(lines[0]);
        first_line.len() >= 2 &&
        {
            let n = parse_int_spec(first_line[0]);
            let x = parse_int_spec(first_line[1]);
            n >= 2 && x >= 0 &&
            {
                let second_line = split_by_space_spec(lines[1]);
                second_line.len() == n &&
                forall|i: int| 0 <= i < n ==> parse_int_spec(second_line[i]) >= 0
            }
        }
    }
}

spec fn minimum_candies_needed(input: &str) -> int
    recommends valid_input(input)
{
    let lines = split_by_newline_spec(input);
    let first_line = split_by_space_spec(lines[0]);
    let n = parse_int_spec(first_line[0]);
    let x = parse_int_spec(first_line[1]);
    let second_line = split_by_space_spec(lines[1]);
    let a = Seq::new(n as nat, |i: int| parse_int_spec(second_line[i]));
    compute_minimum_operations(a, x)
}

spec fn compute_minimum_operations(a: Seq<int>, x: int) -> int
    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0
{
    let a0 = if a[0] > x { x } else { a[0] };
    let cnt0 = if a[0] > x { a[0] - x } else { 0 };
    let new_a = a.update(0, a0);
    compute_operations_from_index(a, x, 1, new_a, cnt0)
}

spec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int
    recommends 
        original_a.len() >= 2 &&
        x >= 0 &&
        1 <= index <= original_a.len() &&
        current_a.len() == original_a.len() &&
        current_count >= 0 &&
        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0
    decreases original_a.len() - index
{
    if index >= original_a.len() {
        current_count
    } else {
        let new_value = if current_a[index] + current_a[index - 1] > x {
            x - current_a[index - 1]
        } else {
            current_a[index]
        };
        let additional_ops = if current_a[index] + current_a[index - 1] > x {
            current_a[index] + current_a[index - 1] - x
        } else {
            0
        };
        let new_a = current_a.update(index, new_value);
        compute_operations_from_index(original_a, x, index + 1, new_a, current_count + additional_ops)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires 
        string_len_spec(input) > 0,
        valid_input(input),
    ensures 
        string_result_len_spec(result) > 0,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n/* Helper spec functions for string parsing */\nspec fn split_by_newline_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn split_by_space_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn parse_int_spec(s: &str) -> int { 0 }\nspec fn int_to_string_spec(n: int) -> Seq<char> { Seq::empty() }\nspec fn string_len_spec(s: &str) -> nat { 0 }\nspec fn string_result_len_spec(s: String) -> nat { 0 }\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_by_space_spec(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = parse_int_spec(first_line[0]);\n            let x = parse_int_spec(first_line[1]);\n            n >= 2 && x >= 0 &&\n            {\n                let second_line = split_by_space_spec(lines[1]);\n                second_line.len() == n &&\n                forall|i: int| 0 <= i < n ==> parse_int_spec(second_line[i]) >= 0\n            }\n        }\n    }\n}\n\nspec fn minimum_candies_needed(input: &str) -> int\n    recommends valid_input(input)\n{\n    let lines = split_by_newline_spec(input);\n    let first_line = split_by_space_spec(lines[0]);\n    let n = parse_int_spec(first_line[0]);\n    let x = parse_int_spec(first_line[1]);\n    let second_line = split_by_space_spec(lines[1]);\n    let a = Seq::new(n as nat, |i: int| parse_int_spec(second_line[i]));\n    compute_minimum_operations(a, x)\n}\n\nspec fn compute_minimum_operations(a: Seq<int>, x: int) -> int\n    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n{\n    let a0 = if a[0] > x { x } else { a[0] };\n    let cnt0 = if a[0] > x { a[0] - x } else { 0 };\n    let new_a = a.update(0, a0);\n    compute_operations_from_index(a, x, 1, new_a, cnt0)\n}\n\nspec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int\n    recommends \n        original_a.len() >= 2 &&\n        x >= 0 &&\n        1 <= index <= original_a.len() &&\n        current_a.len() == original_a.len() &&\n        current_count >= 0 &&\n        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0\n    decreases original_a.len() - index\n{\n    if index >= original_a.len() {\n        current_count\n    } else {\n        let new_value = if current_a[index] + current_a[index - 1] > x {\n            x - current_a[index - 1]\n        } else {\n            current_a[index]\n        };\n        let additional_ops = if current_a[index] + current_a[index - 1] > x {\n            current_a[index] + current_a[index - 1] - x\n        } else {\n            0\n        };\n        let new_a = current_a.update(index, new_value);\n        compute_operations_from_index(original_a, x, index + 1, new_a, current_count + additional_ops)\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: &str) -> (result: String)\n    requires \n        string_len_spec(input) > 0,\n        valid_input(input),\n    ensures \n        string_result_len_spec(result) > 0,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n          fn main() {\n}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4501.rs,128,128,1.0,185.383,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>
{
    Seq::empty()
}

spec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>
{
    Seq::empty()
}

spec fn is_valid_integer(s: Seq<char>) -> bool
{
    true
}

spec fn string_to_int_func(s: Seq<char>) -> int
{
    0
}

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
    let lines = split_lines_func(stdin_input);
    lines.len() >= 2 &&
    {
        let first_line = split_spaces_func(lines[0]);
        let second_line = split_spaces_func(lines[1]);
        first_line.len() == 2 &&
        is_valid_integer(first_line[0]) &&
        is_valid_integer(first_line[1]) &&
        {
            let N = string_to_int_func(first_line[0]);
            let A = string_to_int_func(first_line[1]);
            1 <= N <= 50 &&
            1 <= A <= 50 &&
            second_line.len() == N &&
            (forall|j: int| 0 <= j < second_line.len() ==> 
                is_valid_integer(second_line[j]) &&
                1 <= string_to_int_func(second_line[j]) <= 50)
        }
    }
}

spec fn is_valid_output(output: Seq<char>) -> bool {
    output.len() > 1 && 
    output[output.len() as int - 1] == '\n' &&
    {
        let result_str = output.subrange(0, output.len() as int - 1);
        is_valid_integer(result_str) &&
        string_to_int_func(result_str) >= 0
    }
}

spec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool
    recommends
        valid_input_format(stdin_input),
        is_valid_output(output)
{
    let lines = split_lines_func(stdin_input);
    let first_line = split_spaces_func(lines[0]);
    let second_line = split_spaces_func(lines[1]);
    let N = string_to_int_func(first_line[0]);
    let A = string_to_int_func(first_line[1]);
    let cards = Seq::new(N as nat, |i: int| string_to_int_func(second_line[i]));
    let result = string_to_int_func(output.subrange(0, output.len() as int - 1));
    result == count_valid_selections(cards, A)
}

spec fn count_valid_selections(cards: Seq<int>, A: int) -> int {
    let differences = Seq::new(cards.len(), |i: int| cards[i] - A);
    let total = count_zero_sum_subsets(differences);
    if total > 0 { total - 1 } else { 0 }
}

spec fn count_zero_sum_subsets(differences: Seq<int>) -> nat
    decreases differences.len()
{
    if differences.len() == 0 {
        1
    } else {
        let rest_count = count_zero_sum_subsets(differences.subrange(1, differences.len() as int));
        rest_count + count_subsets_with_sum(differences.subrange(1, differences.len() as int), -differences[0])
    }
}

spec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat
    decreases differences.len()
{
    if differences.len() == 0 {
        if target == 0 { 1 } else { 0 }
    } else {
        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target) +
        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target - differences[0])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
    requires
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures
        output@.len() > 0,
        output@[output@.len() as int - 1] == '\n',
        is_valid_output(output@),
        output_represents_correct_count(stdin_input@, output@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>
{
    Seq::empty()
}

spec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>
{
    Seq::empty()
}

spec fn is_valid_integer(s: Seq<char>) -> bool
{
    true
}

spec fn string_to_int_func(s: Seq<char>) -> int
{
    0
}

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
    let lines = split_lines_func(stdin_input);
    lines.len() >= 2 &&
    {
        let first_line = split_spaces_func(lines[0]);
        let second_line = split_spaces_func(lines[1]);
        first_line.len() == 2 &&
        is_valid_integer(first_line[0]) &&
        is_valid_integer(first_line[1]) &&
        {
            let N = string_to_int_func(first_line[0]);
            let A = string_to_int_func(first_line[1]);
            1 <= N <= 50 &&
            1 <= A <= 50 &&
            second_line.len() == N &&
            (forall|j: int| 0 <= j < second_line.len() ==> 
                is_valid_integer(second_line[j]) &&
                1 <= string_to_int_func(second_line[j]) <= 50)
        }
    }
}

spec fn is_valid_output(output: Seq<char>) -> bool {
    output.len() > 1 && 
    output[output.len() as int - 1] == '\n' &&
    {
        let result_str = output.subrange(0, output.len() as int - 1);
        is_valid_integer(result_str) &&
        string_to_int_func(result_str) >= 0
    }
}

spec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool
    recommends
        valid_input_format(stdin_input),
        is_valid_output(output)
{
    let lines = split_lines_func(stdin_input);
    let first_line = split_spaces_func(lines[0]);
    let second_line = split_spaces_func(lines[1]);
    let N = string_to_int_func(first_line[0]);
    let A = string_to_int_func(first_line[1]);
    let cards = Seq::new(N as nat, |i: int| string_to_int_func(second_line[i]));
    let result = string_to_int_func(output.subrange(0, output.len() as int - 1));
    result == count_valid_selections(cards, A)
}

spec fn count_valid_selections(cards: Seq<int>, A: int) -> int {
    let differences = Seq::new(cards.len(), |i: int| cards[i] - A);
    let total = count_zero_sum_subsets(differences);
    if total > 0 { total - 1 } else { 0 }
}

spec fn count_zero_sum_subsets(differences: Seq<int>) -> nat
    decreases differences.len()
{
    if differences.len() == 0 {
        1
    } else {
        let rest_count = count_zero_sum_subsets(differences.subrange(1, differences.len() as int));
        rest_count + count_subsets_with_sum(differences.subrange(1, differences.len() as int), -differences[0])
    }
}

spec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat
    decreases differences.len()
{
    if differences.len() == 0 {
        if target == 0 { 1 } else { 0 }
    } else {
        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target) +
        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target - differences[0])
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (output: String)
    requires
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures
        output@.len() > 0,
        output@[output@.len() as int - 1] == '\n',
        is_valid_output(output@),
        output_represents_correct_count(stdin_input@, output@),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool\n{\n    true\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int\n{\n    0\n}\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines_func(stdin_input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_spaces_func(lines[0]);\n        let second_line = split_spaces_func(lines[1]);\n        first_line.len() == 2 &&\n        is_valid_integer(first_line[0]) &&\n        is_valid_integer(first_line[1]) &&\n        {\n            let N = string_to_int_func(first_line[0]);\n            let A = string_to_int_func(first_line[1]);\n            1 <= N <= 50 &&\n            1 <= A <= 50 &&\n            second_line.len() == N &&\n            (forall|j: int| 0 <= j < second_line.len() ==> \n                is_valid_integer(second_line[j]) &&\n                1 <= string_to_int_func(second_line[j]) <= 50)\n        }\n    }\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 1 && \n    output[output.len() as int - 1] == '\\n' &&\n    {\n        let result_str = output.subrange(0, output.len() as int - 1);\n        is_valid_integer(result_str) &&\n        string_to_int_func(result_str) >= 0\n    }\n}\n\nspec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool\n    recommends\n        valid_input_format(stdin_input),\n        is_valid_output(output)\n{\n    let lines = split_lines_func(stdin_input);\n    let first_line = split_spaces_func(lines[0]);\n    let second_line = split_spaces_func(lines[1]);\n    let N = string_to_int_func(first_line[0]);\n    let A = string_to_int_func(first_line[1]);\n    let cards = Seq::new(N as nat, |i: int| string_to_int_func(second_line[i]));\n    let result = string_to_int_func(output.subrange(0, output.len() as int - 1));\n    result == count_valid_selections(cards, A)\n}\n\nspec fn count_valid_selections(cards: Seq<int>, A: int) -> int {\n    let differences = Seq::new(cards.len(), |i: int| cards[i] - A);\n    let total = count_zero_sum_subsets(differences);\n    if total > 0 { total - 1 } else { 0 }\n}\n\nspec fn count_zero_sum_subsets(differences: Seq<int>) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        1\n    } else {\n        let rest_count = count_zero_sum_subsets(differences.subrange(1, differences.len() as int));\n        rest_count + count_subsets_with_sum(differences.subrange(1, differences.len() as int), -differences[0])\n    }\n}\n\nspec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        if target == 0 { 1 } else { 0 }\n    } else {\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target) +\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target - differences[0])\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (output: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        output@.len() > 0,\n        output@[output@.len() as int - 1] == '\\n',\n        is_valid_output(output@),\n        output_represents_correct_count(stdin_input@, output@),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4550.rs,63,7,0.1111111111111111,220.052,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> {
    Seq::empty()
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0 &&
    {
        let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());
        nums.len() >= 3 && 
        (forall|i: int| 0 <= i < 3 ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100)
    }
}

spec fn parse_three_ints_func(input: Seq<char>) -> (int, int, int) {
    let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());
    (nums[0], nums[1], nums[2])
}

spec fn can_distribute_equally(a: int, b: int, c: int) -> bool {
    a + b == c || b + c == a || c + a == b
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires 
        input.len() > 0,
        valid_input_format(input),
    ensures 
        result == seq!['Y', 'e', 's', '\n'] || result == seq!['N', 'o', '\n'],
        ({
            let numbers = parse_three_ints_func(input);
            let a = numbers.0;
            let b = numbers.1; 
            let c = numbers.2;
            (result == seq!['Y', 'e', 's', '\n']) <==> can_distribute_equally(a, b, c)
        }),
        ({
            let numbers = parse_three_ints_func(input);
            numbers.0 >= 1 && numbers.1 >= 1 && numbers.2 >= 1 &&
            numbers.0 <= 100 && numbers.1 <= 100 && numbers.2 <= 100
        }),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> ;
       spec fn valid_input_format(input: Seq<char>) -> bool ;
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());\n        nums.len() >= 3 && \n        (forall|i: int| 0 <= i < 3 ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100)\n    }\n}\n\nspec fn parse_three_ints_func(input: Seq<char>) -> (int, int, int) {\n    let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());\n    (nums[0], nums[1], nums[2])\n}\n\nspec fn can_distribute_equally(a: int, b: int, c: int) -> bool {\n    a + b == c || b + c == a || c + a == b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input_format(input),\n    ensures \n        result == seq!['Y', 'e', 's', '\\n'] || result == seq!['N', 'o', '\\n'],\n        ({\n            let numbers = parse_three_ints_func(input);\n            let a = numbers.0;\n            let b = numbers.1; \n            let c = numbers.2;\n            (result == seq!['Y', 'e', 's', '\\n']) <==> can_distribute_equally(a, b, c)\n        }),\n        ({\n            let numbers = parse_three_ints_func(input);\n            numbers.0 >= 1 && numbers.1 >= 1 && numbers.2 >= 1 &&\n            numbers.0 <= 100 && numbers.1 <= 100 && numbers.2 <= 100\n        }),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> ;\n       spec fn valid_input_format(input: Seq<char>) -> bool ;\n       }\n        fn main() {\n      }\n', 'use vstd::prelude::*;\n          fn main() {\n}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4602.rs,113,22,0.19469026548672566,308.396,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    let lines = split_by_newlines(s);
    lines.len() >= 3 &&
    is_positive_integer(lines[0]) &&
    is_positive_integer(lines[1]) &&
    {
        let n = string_to_int(lines[0]);
        let k = string_to_int(lines[1]);
        1 <= n <= 100 &&
        1 <= k <= 100 &&
        is_valid_x_array(lines[2], n, k)
    }
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() >= 2 &&
    result[result.len() - 1] == '\n' &&
    is_non_negative_integer(result.subrange(0, result.len() - 1))
}

spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {
    valid_input(input) && valid_output(output) ==>
        {
            let lines = split_by_newlines(input);
            let n = string_to_int(lines[0]);
            let k = string_to_int(lines[1]);
            let x = parse_int_array(lines[2]);
            x.len() == n &&
            (forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k) &&
            {
                let expected_sum = compute_min_distance(x, k);
                string_to_int(output.subrange(0, output.len() - 1)) == expected_sum
            }
        }
}

spec fn is_positive_integer(s: Seq<char>) -> bool {
    is_non_negative_integer(s) && s.len() > 0 && 
    (s.len() > 1 || s[0] != '0') && 
    string_to_int(s) > 0
}

spec fn is_non_negative_integer(s: Seq<char>) -> bool {
    s.len() > 0 && 
    forall|i: int| #[trigger] s[i] == s[i] && 0 <= i < s.len() ==> {
        let c = s[i];
        '0' <= c && c <= '9'
    }
}

spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool {
    let x = parse_int_array(s);
    x.len() == n && 
    forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k
}

spec fn compute_min_distance(x: Seq<int>, k: int) -> int {
    /* requires forall|i: int| 0 <= i < x.len() ==> 0 < x[i] < k */
    /* ensures compute_min_distance(x, k) >= 0 */
    sum_seq(Seq::new(x.len(), |i: int| 2 * min(k - x[i], x[i])))
}

spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> { 
    seq![]
}

spec fn string_to_int(s: Seq<char>) -> int { 
    0
}

spec fn parse_int_array(s: Seq<char>) -> Seq<int> { 
    seq![]
}

spec fn sum_seq(seq: Seq<int>) -> int { 
    0
}

spec fn min(a: int, b: int) -> int { 
    if a <= b { a } else { b } 
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(s: &str) -> (result: String)
requires
    s@.len() > 0,
    valid_input(s@),
ensures
    result@.len() > 0,
    result@[result@.len() - 1] == '\n',
    valid_output(result@),
    correct_solution(s@, result@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input(s: Seq<char>) -> bool ;
       spec fn valid_output(result: Seq<char>) -> bool ;
       spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool ;
       spec fn is_positive_integer(s: Seq<char>) -> bool ;
       spec fn is_non_negative_integer(s: Seq<char>) -> bool ;
        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;
        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;
        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;
        spec fn string_to_int(s: Seq<char>) -> int ;
        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;
        spec fn sum_seq(seq: Seq<int>) -> int ;
        spec fn min(a: int, b: int) -> int {
            if a <= b {
      a }
       else {
      b }
        }
        }
        fn main() {
       }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newlines(s);\n    lines.len() >= 3 &&\n    is_positive_integer(lines[0]) &&\n    is_positive_integer(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        1 <= n <= 100 &&\n        1 <= k <= 100 &&\n        is_valid_x_array(lines[2], n, k)\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 2 &&\n    result[result.len() - 1] == '\\n' &&\n    is_non_negative_integer(result.subrange(0, result.len() - 1))\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    valid_input(input) && valid_output(output) ==>\n        {\n            let lines = split_by_newlines(input);\n            let n = string_to_int(lines[0]);\n            let k = string_to_int(lines[1]);\n            let x = parse_int_array(lines[2]);\n            x.len() == n &&\n            (forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k) &&\n            {\n                let expected_sum = compute_min_distance(x, k);\n                string_to_int(output.subrange(0, output.len() - 1)) == expected_sum\n            }\n        }\n}\n\nspec fn is_positive_integer(s: Seq<char>) -> bool {\n    is_non_negative_integer(s) && s.len() > 0 && \n    (s.len() > 1 || s[0] != '0') && \n    string_to_int(s) > 0\n}\n\nspec fn is_non_negative_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    forall|i: int| #[trigger] s[i] == s[i] && 0 <= i < s.len() ==> {\n        let c = s[i];\n        '0' <= c && c <= '9'\n    }\n}\n\nspec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool {\n    let x = parse_int_array(s);\n    x.len() == n && \n    forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k\n}\n\nspec fn compute_min_distance(x: Seq<int>, k: int) -> int {\n    /* requires forall|i: int| 0 <= i < x.len() ==> 0 < x[i] < k */\n    /* ensures compute_min_distance(x, k) >= 0 */\n    sum_seq(Seq::new(x.len(), |i: int| 2 * min(k - x[i], x[i])))\n}\n\nspec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> { \n    seq![]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int { \n    0\n}\n\nspec fn parse_int_array(s: Seq<char>) -> Seq<int> { \n    seq![]\n}\n\nspec fn sum_seq(seq: Seq<int>) -> int { \n    0\n}\n\nspec fn min(a: int, b: int) -> int { \n    if a <= b { a } else { b } \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(s: &str) -> (result: String)\nrequires\n    s@.len() > 0,\n    valid_input(s@),\nensures\n    result@.len() > 0,\n    result@[result@.len() - 1] == '\\n',\n    valid_output(result@),\n    correct_solution(s@, result@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(s: Seq<char>) -> bool ;\n       spec fn valid_output(result: Seq<char>) -> bool ;\n       spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool ;\n       spec fn is_positive_integer(s: Seq<char>) -> bool ;\n       spec fn is_non_negative_integer(s: Seq<char>) -> bool ;\n        spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool ;\n        spec fn compute_min_distance(x: Seq<int>, k: int) -> int ;\n        spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> ;\n        spec fn string_to_int(s: Seq<char>) -> int ;\n        spec fn parse_int_array(s: Seq<char>) -> Seq<int> ;\n        spec fn sum_seq(seq: Seq<int>) -> int ;\n        spec fn min(a: int, b: int) -> int {\n            if a <= b {\n      a }\n       else {\n      b }\n        }\n        }\n        fn main() {\n       }\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4611.rs,101,101,1.0,186.721,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
struct Checkpoint {
    t: int,
    x: int,
    y: int,
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 && is_valid_integer(lines[0]) && 
    ({
        let n = parse_int(lines[0]);
        n >= 0 && n + 1 == lines.len() &&
        (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(lines[i]))
    })
}

spec fn can_visit_all_checkpoints(input: Seq<char>) -> bool
    recommends valid_input_format(input)
{
    let lines = split_lines(input);
    let n = parse_int(lines[0]);
    if n == 0 { 
        true 
    } else {
        let checkpoints = parse_checkpoints(lines.subrange(1, lines.len() as int));
        checkpoints.len() == n &&
        checkpoints_feasible(checkpoints, 0, 0, 0)
    }
}

spec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool
    decreases checkpoints.len()
{
    if checkpoints.len() == 0 { 
        true 
    } else {
        let cp = checkpoints[0];
        let dt = cp.t - current_t;
        let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };
        let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };
        let dis = dx + dy;
        if dt < dis { 
            false 
        } else if (dt - dis) % 2 != 0 { 
            false 
        } else { 
            checkpoints_feasible(checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) 
        }
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn is_valid_integer(line: Seq<char>) -> bool {
    true
}

spec fn parse_int(line: Seq<char>) -> int {
    0
}

spec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {
    true
}

spec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures
        result@ == seq!['Y', 'e', 's', '\n'] || result@ == seq!['N', 'o', '\n'],
        (result@ == seq!['Y', 'e', 's', '\n']) <==> can_visit_all_checkpoints(stdin_input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No\n"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
struct Checkpoint {
    t: int,
    x: int,
    y: int,
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 && is_valid_integer(lines[0]) && 
    ({
        let n = parse_int(lines[0]);
        n >= 0 && n + 1 == lines.len() &&
        (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(lines[i]))
    })
}

spec fn can_visit_all_checkpoints(input: Seq<char>) -> bool
    recommends valid_input_format(input)
{
    let lines = split_lines(input);
    let n = parse_int(lines[0]);
    if n == 0 { 
        true 
    } else {
        let checkpoints = parse_checkpoints(lines.subrange(1, lines.len() as int));
        checkpoints.len() == n &&
        checkpoints_feasible(checkpoints, 0, 0, 0)
    }
}

spec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool
    decreases checkpoints.len()
{
    if checkpoints.len() == 0 { 
        true 
    } else {
        let cp = checkpoints[0];
        let dt = cp.t - current_t;
        let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };
        let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };
        let dis = dx + dy;
        if dt < dis { 
            false 
        } else if (dt - dis) % 2 != 0 { 
            false 
        } else { 
            checkpoints_feasible(checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) 
        }
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn is_valid_integer(line: Seq<char>) -> bool {
    true
}

spec fn parse_int(line: Seq<char>) -> int {
    0
}

spec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {
    true
}

spec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures
        result@ == seq!['Y', 'e', 's', '\n'] || result@ == seq!['N', 'o', '\n'],
        (result@ == seq!['Y', 'e', 's', '\n']) <==> can_visit_all_checkpoints(stdin_input@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""No\n"".to_string()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Checkpoint {\n    t: int,\n    x: int,\n    y: int,\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 && is_valid_integer(lines[0]) && \n    ({\n        let n = parse_int(lines[0]);\n        n >= 0 && n + 1 == lines.len() &&\n        (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(lines[i]))\n    })\n}\n\nspec fn can_visit_all_checkpoints(input: Seq<char>) -> bool\n    recommends valid_input_format(input)\n{\n    let lines = split_lines(input);\n    let n = parse_int(lines[0]);\n    if n == 0 { \n        true \n    } else {\n        let checkpoints = parse_checkpoints(lines.subrange(1, lines.len() as int));\n        checkpoints.len() == n &&\n        checkpoints_feasible(checkpoints, 0, 0, 0)\n    }\n}\n\nspec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool\n    decreases checkpoints.len()\n{\n    if checkpoints.len() == 0 { \n        true \n    } else {\n        let cp = checkpoints[0];\n        let dt = cp.t - current_t;\n        let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };\n        let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };\n        let dis = dx + dy;\n        if dt < dis { \n            false \n        } else if (dt - dis) % 2 != 0 { \n            false \n        } else { \n            checkpoints_feasible(checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) \n        }\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\nspec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        result@ == seq![\'Y\', \'e\', \'s\', \'\\n\'] || result@ == seq![\'N\', \'o\', \'\\n\'],\n        (result@ == seq![\'Y\', \'e\', \'s\', \'\\n\']) <==> can_visit_all_checkpoints(stdin_input@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""No\\n"".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n         fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4695.rs,67,67,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(input: &str) -> bool
        recommends input.len() > 0
    {
        let parts = split_string_pure(input);
        parts.len() >= 2 && is_valid_int(&parts[0]) && is_valid_int(&parts[1])
    }
    
    spec fn same_group(a: int, b: int) -> bool {
        let n1 = seq![1, 3, 5, 7, 8, 10, 12];
        let n2 = seq![4, 6, 9, 11];
        (n1.contains(a) && n1.contains(b)) || (n2.contains(a) && n2.contains(b)) || (a == 2 && b == 2)
    }
    
    spec fn correct_output(input: &str, result: Seq<char>) -> bool
        recommends input.len() > 0
    {
        if valid_input(input) {
            let parts = split_string_pure(input);
            let a = string_to_int_pure(&parts[0]);
            let b = string_to_int_pure(&parts[1]);
            let yes_str = seq!['Y', 'e', 's', '\n'];
            let no_str = seq!['N', 'o', '\n'];
            (result == yes_str <==> same_group(a, b)) && (result == no_str <==> !same_group(a, b))
        } else {
            result == seq![]
        }
    }
// </vc-preamble>

// <vc-helpers>
/* Helper functions for string parsing */
spec fn split_string_pure(s: &str) -> Seq<String> {
    Seq::empty() /* placeholder for string splitting */
}

spec fn is_valid_int(s: &str) -> bool {
    true /* placeholder for integer validation */
}

spec fn string_to_int_pure(s: &str) -> int {
    0 /* placeholder for string to int conversion */
}
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        input.len() > 0,
    ensures
        result@ == seq!['Y', 'e', 's', '\n'] || result@ == seq!['N', 'o', '\n'] || result@ == seq![],
        correct_output(input, result@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    """".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn valid_input(input: &str) -> bool
        recommends input.len() > 0
    {
        let parts = split_string_pure(input);
        parts.len() >= 2 && is_valid_int(&parts[0]) && is_valid_int(&parts[1])
    }
    
    spec fn same_group(a: int, b: int) -> bool {
        let n1 = seq![1, 3, 5, 7, 8, 10, 12];
        let n2 = seq![4, 6, 9, 11];
        (n1.contains(a) && n1.contains(b)) || (n2.contains(a) && n2.contains(b)) || (a == 2 && b == 2)
    }
    
    spec fn correct_output(input: &str, result: Seq<char>) -> bool
        recommends input.len() > 0
    {
        if valid_input(input) {
            let parts = split_string_pure(input);
            let a = string_to_int_pure(&parts[0]);
            let b = string_to_int_pure(&parts[1]);
            let yes_str = seq!['Y', 'e', 's', '\n'];
            let no_str = seq!['N', 'o', '\n'];
            (result == yes_str <==> same_group(a, b)) && (result == no_str <==> !same_group(a, b))
        } else {
            result == seq![]
        }
    }
// </vc-preamble>

// <vc-helpers>
/* Helper functions for string parsing */
spec fn split_string_pure(s: &str) -> Seq<String> {
    Seq::empty() /* placeholder for string splitting */
}

spec fn is_valid_int(s: &str) -> bool {
    true /* placeholder for integer validation */
}

spec fn string_to_int_pure(s: &str) -> int {
    0 /* placeholder for string to int conversion */
}
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires
        input.len() > 0,
    ensures
        result@ == seq!['Y', 'e', 's', '\n'] || result@ == seq!['N', 'o', '\n'] || result@ == seq![],
        correct_output(input, result@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    """".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4708.rs,74,74,1.0,186.564,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_string(input, '\n');
    lines.len() >= 4 &&
    is_valid_integer(lines[0]) &&
    is_valid_integer(lines[1]) &&
    is_valid_integer(lines[2]) &&
    is_valid_integer(lines[3]) &&
    {
        let n = string_to_int(lines[0]);
        let k = string_to_int(lines[1]);
        let x = string_to_int(lines[2]);
        let y = string_to_int(lines[3]);
        1 <= n <= 10000 && 1 <= k <= 10000 && 1 <= y < x <= 10000
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_string(input, '\n');
    if lines.len() >= 4 && 
       is_valid_integer(lines[0]) &&
       is_valid_integer(lines[1]) &&
       is_valid_integer(lines[2]) &&
       is_valid_integer(lines[3]) {
        let n = string_to_int(lines[0]);
        let k = string_to_int(lines[1]);
        let x = string_to_int(lines[2]);
        let y = string_to_int(lines[3]);
        let expected_ans = if k < n { k * x + (n - k) * y } else { n * x };
        output == int_to_string(expected_ans) + seq!['\n']
    } else {
        output.len() == 0
    }
}

spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    seq![]
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    true
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (output: Seq<char>)
    requires input.len() > 0
    ensures valid_output(output, input)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_string(input, '\n');
    lines.len() >= 4 &&
    is_valid_integer(lines[0]) &&
    is_valid_integer(lines[1]) &&
    is_valid_integer(lines[2]) &&
    is_valid_integer(lines[3]) &&
    {
        let n = string_to_int(lines[0]);
        let k = string_to_int(lines[1]);
        let x = string_to_int(lines[2]);
        let y = string_to_int(lines[3]);
        1 <= n <= 10000 && 1 <= k <= 10000 && 1 <= y < x <= 10000
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_string(input, '\n');
    if lines.len() >= 4 && 
       is_valid_integer(lines[0]) &&
       is_valid_integer(lines[1]) &&
       is_valid_integer(lines[2]) &&
       is_valid_integer(lines[3]) {
        let n = string_to_int(lines[0]);
        let k = string_to_int(lines[1]);
        let x = string_to_int(lines[2]);
        let y = string_to_int(lines[3]);
        let expected_ans = if k < n { k * x + (n - k) * y } else { n * x };
        output == int_to_string(expected_ans) + seq!['\n']
    } else {
        output.len() == 0
    }
}

spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    seq![]
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    true
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (output: Seq<char>)
    requires input.len() > 0
    ensures valid_output(output, input)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    lines.len() >= 4 &&\n    is_valid_integer(lines[0]) &&\n    is_valid_integer(lines[1]) &&\n    is_valid_integer(lines[2]) &&\n    is_valid_integer(lines[3]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        1 <= n <= 10000 && 1 <= k <= 10000 && 1 <= y < x <= 10000\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    if lines.len() >= 4 && \n       is_valid_integer(lines[0]) &&\n       is_valid_integer(lines[1]) &&\n       is_valid_integer(lines[2]) &&\n       is_valid_integer(lines[3]) {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        let expected_ans = if k < n { k * x + (n - k) * y } else { n * x };\n        output == int_to_string(expected_ans) + seq!['\\n']\n    } else {\n        output.len() == 0\n    }\n}\n\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires input.len() > 0\n    ensures valid_output(output, input)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_4714.rs,74,74,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn is_palindromic(n: int) -> bool
  recommends n >= 0
{
  let s = int_to_string(n);
  forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]
}

spec fn count_palindromic_numbers(a: int, b: int) -> int
  recommends 10000 <= a <= b <= 99999
  decreases b - a + 1
{
  if a > b { 
    0
  } else if a == b { 
    if is_palindromic(a) { 1 } else { 0 }
  } else {
    (if is_palindromic(a) { 1 } else { 0 }) + count_palindromic_numbers(a + 1, b)
  }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
  s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
  stdin_input.len() > 0 &&
  exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == ' ' &&
  {
    let parts = split_on_space(stdin_input);
    parts.len() == 2 && 
    is_valid_integer(parts[0]) && 
    is_valid_integer(parts[1]) &&
    string_to_int(parts[0]) >= 10000 &&
    string_to_int(parts[1]) >= 10000 &&
    string_to_int(parts[0]) <= 99999 &&
    string_to_int(parts[1]) <= 99999 &&
    string_to_int(parts[0]) <= string_to_int(parts[1])
  }
}
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
  requires 
    valid_input(stdin_input@)
  ensures 
    result@.len() > 0
  ensures 
    result@[result@.len() as int - 1] == '\n'
  ensures {
    let parts = split_on_space(stdin_input@);
    let a = string_to_int(parts[0]);
    let b = string_to_int(parts[1]);
    result@ == int_to_string(count_palindromic_numbers(a, b)) + seq!['\n']
  }
// </vc-spec>
// <vc-code>
{
  assume(false);
  String::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn is_palindromic(n: int) -> bool
  recommends n >= 0
{
  let s = int_to_string(n);
  forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]
}

spec fn count_palindromic_numbers(a: int, b: int) -> int
  recommends 10000 <= a <= b <= 99999
  decreases b - a + 1
{
  if a > b { 
    0
  } else if a == b { 
    if is_palindromic(a) { 1 } else { 0 }
  } else {
    (if is_palindromic(a) { 1 } else { 0 }) + count_palindromic_numbers(a + 1, b)
  }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
  s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
  stdin_input.len() > 0 &&
  exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == ' ' &&
  {
    let parts = split_on_space(stdin_input);
    parts.len() == 2 && 
    is_valid_integer(parts[0]) && 
    is_valid_integer(parts[1]) &&
    string_to_int(parts[0]) >= 10000 &&
    string_to_int(parts[1]) >= 10000 &&
    string_to_int(parts[0]) <= 99999 &&
    string_to_int(parts[1]) <= 99999 &&
    string_to_int(parts[0]) <= string_to_int(parts[1])
  }
}
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
  requires 
    valid_input(stdin_input@)
  ensures 
    result@.len() > 0
  ensures 
    result@[result@.len() as int - 1] == '\n'
  ensures {
    let parts = split_on_space(stdin_input@);
    let a = string_to_int(parts[0]);
    let b = string_to_int(parts[1]);
    result@ == int_to_string(count_palindromic_numbers(a, b)) + seq!['\n']
  }
// </vc-spec>
// <vc-code>
{
  assume(false);
  String::new()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_5.rs,55,55,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, pos: int, l: int, r: int) -> bool {
    1 <= n <= 100 && 1 <= pos <= n && 1 <= l <= r <= n
}

spec fn no_tabs_to_close(l: int, r: int, n: int) -> bool {
    l == 1 && r == n
}

spec fn only_close_right(l: int, r: int, n: int) -> bool {
    l == 1 && r < n
}

spec fn only_close_left(l: int, r: int, n: int) -> bool {
    l > 1 && r == n
}

spec fn close_both_sides(l: int, r: int, n: int) -> bool {
    l > 1 && r < n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, pos: i8, l: i8, r: i8) -> (result: i8)
    requires 
        valid_input(n as int, pos as int, l as int, r as int)
    ensures 
        result as int >= 0,
        no_tabs_to_close(l as int, r as int, n as int) ==> result as int == 0,
        only_close_right(l as int, r as int, n as int) ==> result as int == if pos as int >= r as int { pos as int - r as int } else { r as int - pos as int } + 1,
        only_close_left(l as int, r as int, n as int) ==> result as int == if pos as int >= l as int { pos as int - l as int } else { l as int - pos as int } + 1,
        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) < (r as int - pos as int) ==> result as int == (pos as int - l as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) >= (r as int - pos as int) ==> result as int == (r as int - pos as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && pos as int > r as int ==> result as int == (pos as int - r as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && pos as int < l as int ==> result as int == (l as int - pos as int) + 1 + (r as int - l as int) + 1,
        result as int <= 2 * n as int
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, pos: int, l: int, r: int) -> bool {
    1 <= n <= 100 && 1 <= pos <= n && 1 <= l <= r <= n
}

spec fn no_tabs_to_close(l: int, r: int, n: int) -> bool {
    l == 1 && r == n
}

spec fn only_close_right(l: int, r: int, n: int) -> bool {
    l == 1 && r < n
}

spec fn only_close_left(l: int, r: int, n: int) -> bool {
    l > 1 && r == n
}

spec fn close_both_sides(l: int, r: int, n: int) -> bool {
    l > 1 && r < n
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, pos: i8, l: i8, r: i8) -> (result: i8)
    requires 
        valid_input(n as int, pos as int, l as int, r as int)
    ensures 
        result as int >= 0,
        no_tabs_to_close(l as int, r as int, n as int) ==> result as int == 0,
        only_close_right(l as int, r as int, n as int) ==> result as int == if pos as int >= r as int { pos as int - r as int } else { r as int - pos as int } + 1,
        only_close_left(l as int, r as int, n as int) ==> result as int == if pos as int >= l as int { pos as int - l as int } else { l as int - pos as int } + 1,
        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) < (r as int - pos as int) ==> result as int == (pos as int - l as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) >= (r as int - pos as int) ==> result as int == (r as int - pos as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && pos as int > r as int ==> result as int == (pos as int - r as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && pos as int < l as int ==> result as int == (l as int - pos as int) + 1 + (r as int - l as int) + 1,
        result as int <= 2 * n as int
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_502.rs,94,94,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn length_sqr(p1: (int, int), p2: (int, int)) -> int {
    (p1.0 - p2.0) * (p1.0 - p2.0) + (p1.1 - p2.1) * (p1.1 - p2.1)
}

spec fn valid_rotation_exists(a: (int, int), b: (int, int), c: (int, int)) -> bool {
    let dist_ab_sqr = length_sqr(a, b);
    let dist_bc_sqr = length_sqr(b, c);
    let dx1 = c.0 - b.0;
    let dy1 = c.1 - b.1;
    let dx2 = b.0 - a.0;
    let dy2 = b.1 - a.1;
    dist_ab_sqr == dist_bc_sqr && dx1 * dy2 != dy1 * dx2
}

spec fn parse_input_func(input: Seq<char>) -> Seq<int>
    recommends input.len() > 0
{
    parse_input_helper(input, 0, seq![], seq![])
}

spec fn parse_input_helper(input: Seq<char>, i: int, result: Seq<int>, current: Seq<char>) -> Seq<int>
    recommends 0 <= i <= input.len()
    decreases input.len() - i
{
    if i == input.len() {
        if current.len() > 0 { result.push(string_to_int(current)) }
        else { result }
    } else {
        let ch = input[i];
        if ch == ' ' || ch == '\n' || ch == '\t' {
            if current.len() > 0 {
                parse_input_helper(input, i + 1, result.push(string_to_int(current)), seq![])
            } else {
                parse_input_helper(input, i + 1, result, seq![])
            }
        } else if ('0' <= ch <= '9') || ch == '-' {
            parse_input_helper(input, i + 1, result, current.push(ch))
        } else {
            parse_input_helper(input, i + 1, result, current)
        }
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s.len() == 1 && s[0] == '-' { 0 }
    else if s[0] == '-' && s.len() > 1 && is_digit_string(s.subrange(1, s.len() as int)) { -string_to_int_helper(s.subrange(1, s.len() as int)) }
    else if is_digit_string(s) { string_to_int_helper(s) }
    else { 0 }
}

spec fn is_digit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn string_to_int_helper(s: Seq<char>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
{
    if s.len() == 0 { 0 }
    else if s.len() == 1 { char_to_digit(s[0]) }
    else { string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + char_to_digit(s[s.len() - 1]) }
}

spec fn char_to_digit(c: char) -> int
    recommends '0' <= c <= '9'
{
    (c as int) - ('0' as int)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures result@ == ""Yes""@ || result@ == ""No""@ || result@ == """"@
// </vc-spec>
// <vc-code>
{
    assume(false);
    """".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn length_sqr(p1: (int, int), p2: (int, int)) -> int {
    (p1.0 - p2.0) * (p1.0 - p2.0) + (p1.1 - p2.1) * (p1.1 - p2.1)
}

spec fn valid_rotation_exists(a: (int, int), b: (int, int), c: (int, int)) -> bool {
    let dist_ab_sqr = length_sqr(a, b);
    let dist_bc_sqr = length_sqr(b, c);
    let dx1 = c.0 - b.0;
    let dy1 = c.1 - b.1;
    let dx2 = b.0 - a.0;
    let dy2 = b.1 - a.1;
    dist_ab_sqr == dist_bc_sqr && dx1 * dy2 != dy1 * dx2
}

spec fn parse_input_func(input: Seq<char>) -> Seq<int>
    recommends input.len() > 0
{
    parse_input_helper(input, 0, seq![], seq![])
}

spec fn parse_input_helper(input: Seq<char>, i: int, result: Seq<int>, current: Seq<char>) -> Seq<int>
    recommends 0 <= i <= input.len()
    decreases input.len() - i
{
    if i == input.len() {
        if current.len() > 0 { result.push(string_to_int(current)) }
        else { result }
    } else {
        let ch = input[i];
        if ch == ' ' || ch == '\n' || ch == '\t' {
            if current.len() > 0 {
                parse_input_helper(input, i + 1, result.push(string_to_int(current)), seq![])
            } else {
                parse_input_helper(input, i + 1, result, seq![])
            }
        } else if ('0' <= ch <= '9') || ch == '-' {
            parse_input_helper(input, i + 1, result, current.push(ch))
        } else {
            parse_input_helper(input, i + 1, result, current)
        }
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s.len() == 1 && s[0] == '-' { 0 }
    else if s[0] == '-' && s.len() > 1 && is_digit_string(s.subrange(1, s.len() as int)) { -string_to_int_helper(s.subrange(1, s.len() as int)) }
    else if is_digit_string(s) { string_to_int_helper(s) }
    else { 0 }
}

spec fn is_digit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn string_to_int_helper(s: Seq<char>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
{
    if s.len() == 0 { 0 }
    else if s.len() == 1 { char_to_digit(s[0]) }
    else { string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + char_to_digit(s[s.len() - 1]) }
}

spec fn char_to_digit(c: char) -> int
    recommends '0' <= c <= '9'
{
    (c as int) - ('0' as int)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures result@ == ""Yes""@ || result@ == ""No""@ || result@ == """"@
// </vc-spec>
// <vc-code>
{
    assume(false);
    """".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_505.rs,130,130,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, k: int, grid: Seq<Seq<char>>) -> bool {
    n > 0 && m > 0 && k >= 0 &&
    grid.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] grid[i].len() == m) &&
    (exists|i: int, j: int| 0 <= i < n && 0 <= j < m && grid[i][j] == 'X')
}

spec fn get_next_position(x: int, y: int, move_char: char) -> (int, int) {
    match move_char {
        'D' => (x + 1, y),
        'L' => (x, y - 1),
        'R' => (x, y + 1),
        'U' => (x - 1, y),
        _ => (x, y)
    }
}

spec fn simulate_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> (int, int)
    decreases path.len()
{
    if path.len() == 0 {
        (start_x, start_y)
    } else {
        let next_pos = get_next_position(start_x, start_y, path[0]);
        simulate_path(next_pos.0, next_pos.1, path.subrange(1, path.len() as int), grid, n, m)
    }
}

spec fn valid_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    forall|i: int| #![trigger simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m)] 
        0 <= i <= path.len() ==> {
            let pos = simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m);
            0 <= pos.0 < n && 0 <= pos.1 < m && 
            pos.0 < grid.len() && pos.1 < grid[pos.0].len() &&
            grid[pos.0][pos.1] != '*'
        }
}

spec fn path_returns_to_start(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    let final_pos = simulate_path(start_x, start_y, path, grid, n, m);
    final_pos.0 == start_x && final_pos.1 == start_y
}

spec fn valid_directions(path: Seq<char>) -> bool {
    forall|i: int| 0 <= i < path.len() ==> 
        #[trigger] path[i] == 'D' || path[i] == 'L' || path[i] == 'R' || path[i] == 'U'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize, m: usize, k: usize, grid: Vec<Vec<char>>) -> (result: String)
    requires
        valid_input(n as int, m as int, k as int, grid@.map_values(|row: Vec<char>| row@))
    ensures
        result == ""IMPOSSIBLE"" || (
            result.len() == k &&
            valid_directions(result@) &&
            {
                let mut start_x = 0;
                let mut start_y = 0;
                let mut found = false;
                let mut i = 0;
                while i < n {
                    let mut j = 0;
                    while j < m {
                        if grid[i][j] == 'X' {
                            start_x = i as int;
                            start_y = j as int;
                            found = true;
                        }
                        j += 1;
                    }
                    i += 1;
                }
                found
            } ==> {
                let start_x = {
                    let mut sx = 0;
                    let mut i = 0;
                    while i < n {
                        let mut j = 0;
                        while j < m {
                            if grid[i][j] == 'X' {
                                sx = i as int;
                            }
                            j += 1;
                        }
                        i += 1;
                    }
                    sx
                };
                let start_y = {
                    let mut sy = 0;
                    let mut i = 0;
                    while i < n {
                        let mut j = 0;
                        while j < m {
                            if grid[i][j] == 'X' {
                                sy = j as int;
                            }
                            j += 1;
                        }
                        i += 1;
                    }
                    sy
                };
                valid_path(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int) &&
                path_returns_to_start(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int)
            }
        )
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""IMPOSSIBLE"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, k: int, grid: Seq<Seq<char>>) -> bool {
    n > 0 && m > 0 && k >= 0 &&
    grid.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] grid[i].len() == m) &&
    (exists|i: int, j: int| 0 <= i < n && 0 <= j < m && grid[i][j] == 'X')
}

spec fn get_next_position(x: int, y: int, move_char: char) -> (int, int) {
    match move_char {
        'D' => (x + 1, y),
        'L' => (x, y - 1),
        'R' => (x, y + 1),
        'U' => (x - 1, y),
        _ => (x, y)
    }
}

spec fn simulate_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> (int, int)
    decreases path.len()
{
    if path.len() == 0 {
        (start_x, start_y)
    } else {
        let next_pos = get_next_position(start_x, start_y, path[0]);
        simulate_path(next_pos.0, next_pos.1, path.subrange(1, path.len() as int), grid, n, m)
    }
}

spec fn valid_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    forall|i: int| #![trigger simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m)] 
        0 <= i <= path.len() ==> {
            let pos = simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m);
            0 <= pos.0 < n && 0 <= pos.1 < m && 
            pos.0 < grid.len() && pos.1 < grid[pos.0].len() &&
            grid[pos.0][pos.1] != '*'
        }
}

spec fn path_returns_to_start(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    let final_pos = simulate_path(start_x, start_y, path, grid, n, m);
    final_pos.0 == start_x && final_pos.1 == start_y
}

spec fn valid_directions(path: Seq<char>) -> bool {
    forall|i: int| 0 <= i < path.len() ==> 
        #[trigger] path[i] == 'D' || path[i] == 'L' || path[i] == 'R' || path[i] == 'U'
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: usize, m: usize, k: usize, grid: Vec<Vec<char>>) -> (result: String)
    requires
        valid_input(n as int, m as int, k as int, grid@.map_values(|row: Vec<char>| row@))
    ensures
        result == ""IMPOSSIBLE"" || (
            result.len() == k &&
            valid_directions(result@) &&
            {
                let mut start_x = 0;
                let mut start_y = 0;
                let mut found = false;
                let mut i = 0;
                while i < n {
                    let mut j = 0;
                    while j < m {
                        if grid[i][j] == 'X' {
                            start_x = i as int;
                            start_y = j as int;
                            found = true;
                        }
                        j += 1;
                    }
                    i += 1;
                }
                found
            } ==> {
                let start_x = {
                    let mut sx = 0;
                    let mut i = 0;
                    while i < n {
                        let mut j = 0;
                        while j < m {
                            if grid[i][j] == 'X' {
                                sx = i as int;
                            }
                            j += 1;
                        }
                        i += 1;
                    }
                    sx
                };
                let start_y = {
                    let mut sy = 0;
                    let mut i = 0;
                    while i < n {
                        let mut j = 0;
                        while j < m {
                            if grid[i][j] == 'X' {
                                sy = j as int;
                            }
                            j += 1;
                        }
                        i += 1;
                    }
                    sy
                };
                valid_path(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int) &&
                path_returns_to_start(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int)
            }
        )
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""IMPOSSIBLE"".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_510.rs,59,59,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn pos1(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            a
        } else if b <= a && b <= c {
            b
        } else {
            c
        }
    }
    
    spec fn pos2(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            if b <= c { b } else { c }
        } else if b <= a && b <= c {
            if a <= c { a } else { c }
        } else {
            if a <= b { a } else { b }
        }
    }
    
    spec fn pos3(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            if b <= c { c } else { b }
        } else if b <= a && b <= c {
            if a <= c { c } else { a }
        } else {
            if a <= b { b } else { a }
        }
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: int, b: int, c: int, d: int) -> (result: int)
    requires 1 <= a && a <= 1_000_000_000
    requires 1 <= b && b <= 1_000_000_000
    requires 1 <= c && c <= 1_000_000_000
    requires 1 <= d && d <= 1_000_000_000
    ensures result >= 0
    ensures result == (if d > (pos2(a, b, c) - pos1(a, b, c)) { d - (pos2(a, b, c) - pos1(a, b, c)) } else { 0 }) +
                     (if d > (pos3(a, b, c) - pos2(a, b, c)) { d - (pos3(a, b, c) - pos2(a, b, c)) } else { 0 })
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
    spec fn pos1(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            a
        } else if b <= a && b <= c {
            b
        } else {
            c
        }
    }
    
    spec fn pos2(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            if b <= c { b } else { c }
        } else if b <= a && b <= c {
            if a <= c { a } else { c }
        } else {
            if a <= b { a } else { b }
        }
    }
    
    spec fn pos3(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            if b <= c { c } else { b }
        } else if b <= a && b <= c {
            if a <= c { c } else { a }
        } else {
            if a <= b { b } else { a }
        }
    }
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: int, b: int, c: int, d: int) -> (result: int)
    requires 1 <= a && a <= 1_000_000_000
    requires 1 <= b && b <= 1_000_000_000
    requires 1 <= c && c <= 1_000_000_000
    requires 1 <= d && d <= 1_000_000_000
    ensures result >= 0
    ensures result == (if d > (pos2(a, b, c) - pos1(a, b, c)) { d - (pos2(a, b, c) - pos1(a, b, c)) } else { 0 }) +
                     (if d > (pos3(a, b, c) - pos2(a, b, c)) { d - (pos3(a, b, c) - pos2(a, b, c)) } else { 0 })
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_540.rs,132,132,1.0,220.501,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    stdin_input.len() >= 7 &&
    contains_required_newlines(stdin_input) &&
    ends_with_newline_or_can_append(stdin_input) &&
    has_valid_structure(stdin_input) &&
    all_grid_characters_valid(stdin_input) &&
    has_exactly_required_lines(stdin_input)
}

spec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {
    let parsed = parse_dimensions(stdin_input);
    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500
}

spec fn valid_coordinates(stdin_input: Seq<char>) -> bool {
    let dims = parse_dimensions(stdin_input);
    let coords = parse_coordinates(stdin_input);
    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&
    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1
}

spec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {
    let grid = parse_grid(stdin_input);
    let coords = parse_coordinates(stdin_input);
    valid_grid_index(grid, coords.0-1, coords.1-1) &&
    grid.index(coords.0-1).index(coords.1-1) == 'X'
}

spec fn well_formed_input(stdin_input: Seq<char>) -> bool {
    valid_input_format(stdin_input) &&
    valid_grid_bounds(stdin_input) &&
    valid_coordinates(stdin_input) &&
    starting_cell_is_cracked(stdin_input) &&
    grid_contains_only_valid_chars(stdin_input) &&
    coordinates_within_bounds(stdin_input)
}

spec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {
    let grid = parse_grid(stdin_input);
    let coords = parse_coordinates(stdin_input);
    let r1 = coords.0-1;
    let c1 = coords.1-1;
    let r2 = coords.2-1;
    let c2 = coords.3-1;
    let target_is_cracked = grid.index(r2).index(c2) == 'X';
    let surrounding_dots = count_surrounding_intact_ice(grid, r2, c2);

    if target_is_cracked {
        if r1 == r2 && c1 == c2 {
            surrounding_dots >= 1
        } else {
            can_reach_target_with_bfs(grid, r1, c1, r2, c2)
        }
    } else {
        if surrounding_dots >= 2 {
            can_reach_target_with_bfs(grid, r1, c1, r2, c2)
        } else if surrounding_dots == 0 {
            false
        } else {
            is_adjacent(r1+1, c1+1, r2+1, c2+1)
        }
    }
}

spec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {
    (1, 1)
}

spec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['X']]
}

spec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {
    (1, 1, 1, 1)
}

spec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {
    0 <= r < grid.len() && 0 <= c < grid.index(r).len()
}

/* Helper functions that are referenced but not defined */
spec fn contains_required_newlines(input: Seq<char>) -> bool { true }
spec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool { true }
spec fn has_valid_structure(input: Seq<char>) -> bool { true }
spec fn all_grid_characters_valid(input: Seq<char>) -> bool { true }
spec fn has_exactly_required_lines(input: Seq<char>) -> bool { true }
spec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool { true }
spec fn coordinates_within_bounds(input: Seq<char>) -> bool { true }
spec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int { 0 }
spec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool { true }
spec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool { 
    (r1 == r2 && (c1 == c2 + 1 || c1 == c2 - 1)) ||
    (c1 == c2 && (r1 == r2 + 1 || r1 == r2 - 1))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        valid_input_format(stdin_input),
        valid_grid_bounds(stdin_input),
        valid_coordinates(stdin_input),
        starting_cell_is_cracked(stdin_input),
        well_formed_input(stdin_input),
    ensures 
        result == seq!['Y', 'E', 'S', '\n'] || result == seq!['N', 'O', '\n'],
        result.len() > 0,
        (result == seq!['Y', 'E', 'S', '\n']) <==> can_solve_ice_maze(stdin_input),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    stdin_input.len() >= 7 &&
    contains_required_newlines(stdin_input) &&
    ends_with_newline_or_can_append(stdin_input) &&
    has_valid_structure(stdin_input) &&
    all_grid_characters_valid(stdin_input) &&
    has_exactly_required_lines(stdin_input)
}

spec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {
    let parsed = parse_dimensions(stdin_input);
    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500
}

spec fn valid_coordinates(stdin_input: Seq<char>) -> bool {
    let dims = parse_dimensions(stdin_input);
    let coords = parse_coordinates(stdin_input);
    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&
    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1
}

spec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {
    let grid = parse_grid(stdin_input);
    let coords = parse_coordinates(stdin_input);
    valid_grid_index(grid, coords.0-1, coords.1-1) &&
    grid.index(coords.0-1).index(coords.1-1) == 'X'
}

spec fn well_formed_input(stdin_input: Seq<char>) -> bool {
    valid_input_format(stdin_input) &&
    valid_grid_bounds(stdin_input) &&
    valid_coordinates(stdin_input) &&
    starting_cell_is_cracked(stdin_input) &&
    grid_contains_only_valid_chars(stdin_input) &&
    coordinates_within_bounds(stdin_input)
}

spec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {
    let grid = parse_grid(stdin_input);
    let coords = parse_coordinates(stdin_input);
    let r1 = coords.0-1;
    let c1 = coords.1-1;
    let r2 = coords.2-1;
    let c2 = coords.3-1;
    let target_is_cracked = grid.index(r2).index(c2) == 'X';
    let surrounding_dots = count_surrounding_intact_ice(grid, r2, c2);

    if target_is_cracked {
        if r1 == r2 && c1 == c2 {
            surrounding_dots >= 1
        } else {
            can_reach_target_with_bfs(grid, r1, c1, r2, c2)
        }
    } else {
        if surrounding_dots >= 2 {
            can_reach_target_with_bfs(grid, r1, c1, r2, c2)
        } else if surrounding_dots == 0 {
            false
        } else {
            is_adjacent(r1+1, c1+1, r2+1, c2+1)
        }
    }
}

spec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {
    (1, 1)
}

spec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['X']]
}

spec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {
    (1, 1, 1, 1)
}

spec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {
    0 <= r < grid.len() && 0 <= c < grid.index(r).len()
}

/* Helper functions that are referenced but not defined */
spec fn contains_required_newlines(input: Seq<char>) -> bool { true }
spec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool { true }
spec fn has_valid_structure(input: Seq<char>) -> bool { true }
spec fn all_grid_characters_valid(input: Seq<char>) -> bool { true }
spec fn has_exactly_required_lines(input: Seq<char>) -> bool { true }
spec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool { true }
spec fn coordinates_within_bounds(input: Seq<char>) -> bool { true }
spec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int { 0 }
spec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool { true }
spec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool { 
    (r1 == r2 && (c1 == c2 + 1 || c1 == c2 - 1)) ||
    (c1 == c2 && (r1 == r2 + 1 || r1 == r2 - 1))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        valid_input_format(stdin_input),
        valid_grid_bounds(stdin_input),
        valid_coordinates(stdin_input),
        starting_cell_is_cracked(stdin_input),
        well_formed_input(stdin_input),
    ensures 
        result == seq!['Y', 'E', 'S', '\n'] || result == seq!['N', 'O', '\n'],
        result.len() > 0,
        (result == seq!['Y', 'E', 'S', '\n']) <==> can_solve_ice_maze(stdin_input),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input.len() >= 7 &&\n    contains_required_newlines(stdin_input) &&\n    ends_with_newline_or_can_append(stdin_input) &&\n    has_valid_structure(stdin_input) &&\n    all_grid_characters_valid(stdin_input) &&\n    has_exactly_required_lines(stdin_input)\n}\n\nspec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {\n    let parsed = parse_dimensions(stdin_input);\n    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500\n}\n\nspec fn valid_coordinates(stdin_input: Seq<char>) -> bool {\n    let dims = parse_dimensions(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&\n    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1\n}\n\nspec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    valid_grid_index(grid, coords.0-1, coords.1-1) &&\n    grid.index(coords.0-1).index(coords.1-1) == 'X'\n}\n\nspec fn well_formed_input(stdin_input: Seq<char>) -> bool {\n    valid_input_format(stdin_input) &&\n    valid_grid_bounds(stdin_input) &&\n    valid_coordinates(stdin_input) &&\n    starting_cell_is_cracked(stdin_input) &&\n    grid_contains_only_valid_chars(stdin_input) &&\n    coordinates_within_bounds(stdin_input)\n}\n\nspec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    let r1 = coords.0-1;\n    let c1 = coords.1-1;\n    let r2 = coords.2-1;\n    let c2 = coords.3-1;\n    let target_is_cracked = grid.index(r2).index(c2) == 'X';\n    let surrounding_dots = count_surrounding_intact_ice(grid, r2, c2);\n\n    if target_is_cracked {\n        if r1 == r2 && c1 == c2 {\n            surrounding_dots >= 1\n        } else {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        }\n    } else {\n        if surrounding_dots >= 2 {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        } else if surrounding_dots == 0 {\n            false\n        } else {\n            is_adjacent(r1+1, c1+1, r2+1, c2+1)\n        }\n    }\n}\n\nspec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {\n    (1, 1)\n}\n\nspec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['X']]\n}\n\nspec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {\n    (1, 1, 1, 1)\n}\n\nspec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {\n    0 <= r < grid.len() && 0 <= c < grid.index(r).len()\n}\n\n/* Helper functions that are referenced but not defined */\nspec fn contains_required_newlines(input: Seq<char>) -> bool { true }\nspec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool { true }\nspec fn has_valid_structure(input: Seq<char>) -> bool { true }\nspec fn all_grid_characters_valid(input: Seq<char>) -> bool { true }\nspec fn has_exactly_required_lines(input: Seq<char>) -> bool { true }\nspec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool { true }\nspec fn coordinates_within_bounds(input: Seq<char>) -> bool { true }\nspec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int { 0 }\nspec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool { true }\nspec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool { \n    (r1 == r2 && (c1 == c2 + 1 || c1 == c2 - 1)) ||\n    (c1 == c2 && (r1 == r2 + 1 || r1 == r2 - 1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        valid_input_format(stdin_input),\n        valid_grid_bounds(stdin_input),\n        valid_coordinates(stdin_input),\n        starting_cell_is_cracked(stdin_input),\n        well_formed_input(stdin_input),\n    ensures \n        result == seq!['Y', 'E', 'S', '\\n'] || result == seq!['N', 'O', '\\n'],\n        result.len() > 0,\n        (result == seq!['Y', 'E', 'S', '\\n']) <==> can_solve_ice_maze(stdin_input),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        fn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_543.rs,51,51,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(pizzas: Seq<int>) -> bool {
    forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] >= 0
}

spec fn validate_pizza_solution(pizzas: Seq<int>, index: int, d: bool, p: int) -> bool
    decreases pizzas.len() - index
    when 0 <= index <= pizzas.len() && (p == 0 || p == 1)
{
    if index == pizzas.len() {
        d && p == 0
    } else {
        let requirement = pizzas[index];
        let new_p = if requirement % 2 == 1 { 1 - p } else { p };
        let new_d = if requirement % 2 == 0 && p == 1 && requirement == 0 { false } else { d };
        validate_pizza_solution(pizzas, index + 1, new_d, new_p)
    }
}

spec fn can_fulfill_requirements(pizzas: Seq<int>) -> bool {
    validate_pizza_solution(pizzas, 0, true, 0)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(pizzas: Vec<i8>) -> (result: String)
    requires
        forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] as int >= 0,
        valid_input(pizzas@.map(|i, x| x as int)),
    ensures
        result == ""YES"" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),
        result == ""NO"" ==> !can_fulfill_requirements(pizzas@.map(|i, x| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(pizzas: Seq<int>) -> bool {
    forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] >= 0
}

spec fn validate_pizza_solution(pizzas: Seq<int>, index: int, d: bool, p: int) -> bool
    decreases pizzas.len() - index
    when 0 <= index <= pizzas.len() && (p == 0 || p == 1)
{
    if index == pizzas.len() {
        d && p == 0
    } else {
        let requirement = pizzas[index];
        let new_p = if requirement % 2 == 1 { 1 - p } else { p };
        let new_d = if requirement % 2 == 0 && p == 1 && requirement == 0 { false } else { d };
        validate_pizza_solution(pizzas, index + 1, new_d, new_p)
    }
}

spec fn can_fulfill_requirements(pizzas: Seq<int>) -> bool {
    validate_pizza_solution(pizzas, 0, true, 0)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(pizzas: Vec<i8>) -> (result: String)
    requires
        forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] as int >= 0,
        valid_input(pizzas@.map(|i, x| x as int)),
    ensures
        result == ""YES"" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),
        result == ""NO"" ==> !can_fulfill_requirements(pizzas@.map(|i, x| x as int)),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO"".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_601.rs,71,71,1.0,185.849,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}

spec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {
    seq![]
}

spec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {
    seq![]
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    {
        let lines = split_func(input, '\n');
        lines.len() >= 1 &&
        parse_int_func(lines[0]) >= 0 &&
        lines.len() >= 1 + 3 * parse_int_func(lines[0])
    }
}

spec fn process_test_cases(input: Seq<char>) -> Seq<int> {
    if valid_input(input) {
        let lines = split_func(input, '\n');
        let t = parse_int_func(lines[0]);
        process_test_cases_helper(input, lines, 1, 0, t, seq![])
    } else {
        seq![]
    }
}

spec fn format_output(results: Seq<int>) -> Seq<char> {
    format_output_helper(results, 0, seq![])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        input.len() > 0,
        valid_input(input),
    ensures
        result.len() >= 0,
        result == format_output(process_test_cases(input)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}

spec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {
    seq![]
}

spec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {
    seq![]
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    {
        let lines = split_func(input, '\n');
        lines.len() >= 1 &&
        parse_int_func(lines[0]) >= 0 &&
        lines.len() >= 1 + 3 * parse_int_func(lines[0])
    }
}

spec fn process_test_cases(input: Seq<char>) -> Seq<int> {
    if valid_input(input) {
        let lines = split_func(input, '\n');
        let t = parse_int_func(lines[0]);
        process_test_cases_helper(input, lines, 1, 0, t, seq![])
    } else {
        seq![]
    }
}

spec fn format_output(results: Seq<int>) -> Seq<char> {
    format_output_helper(results, 0, seq![])
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        input.len() > 0,
        valid_input(input),
    ensures
        result.len() >= 0,
        result == format_output(process_test_cases(input)),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {\n    seq![]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let lines = split_func(input, '\\n');\n        lines.len() >= 1 &&\n        parse_int_func(lines[0]) >= 0 &&\n        lines.len() >= 1 + 3 * parse_int_func(lines[0])\n    }\n}\n\nspec fn process_test_cases(input: Seq<char>) -> Seq<int> {\n    if valid_input(input) {\n        let lines = split_func(input, '\\n');\n        let t = parse_int_func(lines[0]);\n        process_test_cases_helper(input, lines, 1, 0, t, seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n    format_output_helper(results, 0, seq![])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        result.len() >= 0,\n        result == format_output(process_test_cases(input)),\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n          fn main() {\n}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_631.rs,76,76,1.0,248.085,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(s: Seq<char>) -> bool {
    s.len() >= 7 && 
    exists|pos: int| 0 < pos < s.len() && s[pos] == '\n'
}

spec fn get_test_count(stdin_input: Seq<char>) -> int {
    1
}

spec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {
    0
}

spec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {
    0
}

spec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {
    seq![]
}

spec fn count_responses(result: Seq<char>) -> int {
    0
}

spec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {
    seq![]
}

spec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {
    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))
}

spec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {
    let T = get_test_count(stdin_input);
    count_responses(result) == T &&
    (forall|i: int| #![trigger get_array_sum(stdin_input, i)] 0 <= i < T ==> {
        let array_sum = get_array_sum(stdin_input, i);
        let target_m = get_target_m(stdin_input, i);
        let response = get_response_at_index(result, i);
        let yes_response = seq![
            'Y' as char, 'E' as char, 'S' as char, '\n' as char
        ];
        let no_response = seq![
            'N' as char, 'O' as char, '\n' as char
        ];
        (array_sum == target_m <==> response == yes_response) &&
        (array_sum != target_m <==> response == no_response)
    })
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires valid_input_format(stdin_input@)
    ensures behavioral_correctness(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input_format(s: Seq<char>) -> bool {
    s.len() >= 7 && 
    exists|pos: int| 0 < pos < s.len() && s[pos] == '\n'
}

spec fn get_test_count(stdin_input: Seq<char>) -> int {
    1
}

spec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {
    0
}

spec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {
    0
}

spec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {
    seq![]
}

spec fn count_responses(result: Seq<char>) -> int {
    0
}

spec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {
    seq![]
}

spec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {
    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))
}

spec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {
    let T = get_test_count(stdin_input);
    count_responses(result) == T &&
    (forall|i: int| #![trigger get_array_sum(stdin_input, i)] 0 <= i < T ==> {
        let array_sum = get_array_sum(stdin_input, i);
        let target_m = get_target_m(stdin_input, i);
        let response = get_response_at_index(result, i);
        let yes_response = seq![
            'Y' as char, 'E' as char, 'S' as char, '\n' as char
        ];
        let no_response = seq![
            'N' as char, 'O' as char, '\n' as char
        ];
        (array_sum == target_m <==> response == yes_response) &&
        (array_sum != target_m <==> response == no_response)
    })
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires valid_input_format(stdin_input@)
    ensures behavioral_correctness(stdin_input@, result@)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(s: Seq<char>) -> bool {\n    s.len() >= 7 && \n    exists|pos: int| 0 < pos < s.len() && s[pos] == '\\n'\n}\n\nspec fn get_test_count(stdin_input: Seq<char>) -> int {\n    1\n}\n\nspec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn count_responses(result: Seq<char>) -> int {\n    0\n}\n\nspec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {\n    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))\n}\n\nspec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let T = get_test_count(stdin_input);\n    count_responses(result) == T &&\n    (forall|i: int| #![trigger get_array_sum(stdin_input, i)] 0 <= i < T ==> {\n        let array_sum = get_array_sum(stdin_input, i);\n        let target_m = get_target_m(stdin_input, i);\n        let response = get_response_at_index(result, i);\n        let yes_response = seq![\n            'Y' as char, 'E' as char, 'S' as char, '\\n' as char\n        ];\n        let no_response = seq![\n            'N' as char, 'O' as char, '\\n' as char\n        ];\n        (array_sum == target_m <==> response == yes_response) &&\n        (array_sum != target_m <==> response == no_response)\n    })\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(stdin_input: &str) -> (result: String)\n    requires valid_input_format(stdin_input@)\n    ensures behavioral_correctness(stdin_input@, result@)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_651.rs,122,122,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_two_ints(s: Seq<char>) -> (int, int) {
    (0, 0)
}

spec fn count_occurrences(lines: Seq<Seq<char>>, n: int, m: int, c: char) -> int {
    0
}

spec fn find_start(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {
    (0, 0)
}

spec fn find_end(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {
    (0, 0)
}

spec fn count_permutations_reaching_goal(lines: Seq<Seq<char>>, n: int, m: int, path: Seq<char>, start: (int, int), end: (int, int)) -> int {
    0
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 &&
    has_valid_dimensions(lines) &&
    has_valid_grid(lines) &&
    has_start_and_end(lines) &&
    has_valid_path(lines)
}

spec fn has_valid_dimensions(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2
}

spec fn has_valid_grid(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    forall|i: int| 1 <= i <= n && i < lines.len() ==>
        forall|j: int| 0 <= j < lines[i].len() && j < m ==>
            lines[i][j] == '.' || lines[i][j] == '#' || 
            lines[i][j] == 'S' || lines[i][j] == 'E'
}

spec fn has_start_and_end(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'S') &&
    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'E') &&
    count_occurrences(lines, n, m, 'S') == 1 &&
    count_occurrences(lines, n, m, 'E') == 1
}

spec fn has_valid_path(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    valid_path_string(lines[n + 1])
}

spec fn valid_path_string(path: Seq<char>) -> bool {
    forall|i: int| 0 <= i < path.len() ==> 
        '0' <= path[i] && path[i] <= '3'
}

spec fn valid_result(result: Seq<char>) -> bool {
    result.len() > 0 &&
    forall|c: char| result.contains(c) ==> 
        ('0' <= c && c <= '9') || c == '\n'
}

spec fn count_valid_ways(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    let start = find_start(lines, n, m);
    let end = find_end(lines, n, m);
    let path = lines[n + 1];
    count_permutations_reaching_goal(lines, n, m, path, start, end)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    String::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_two_ints(s: Seq<char>) -> (int, int) {
    (0, 0)
}

spec fn count_occurrences(lines: Seq<Seq<char>>, n: int, m: int, c: char) -> int {
    0
}

spec fn find_start(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {
    (0, 0)
}

spec fn find_end(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {
    (0, 0)
}

spec fn count_permutations_reaching_goal(lines: Seq<Seq<char>>, n: int, m: int, path: Seq<char>, start: (int, int), end: (int, int)) -> int {
    0
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 &&
    has_valid_dimensions(lines) &&
    has_valid_grid(lines) &&
    has_start_and_end(lines) &&
    has_valid_path(lines)
}

spec fn has_valid_dimensions(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2
}

spec fn has_valid_grid(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    forall|i: int| 1 <= i <= n && i < lines.len() ==>
        forall|j: int| 0 <= j < lines[i].len() && j < m ==>
            lines[i][j] == '.' || lines[i][j] == '#' || 
            lines[i][j] == 'S' || lines[i][j] == 'E'
}

spec fn has_start_and_end(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'S') &&
    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'E') &&
    count_occurrences(lines, n, m, 'S') == 1 &&
    count_occurrences(lines, n, m, 'E') == 1
}

spec fn has_valid_path(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    valid_path_string(lines[n + 1])
}

spec fn valid_path_string(path: Seq<char>) -> bool {
    forall|i: int| 0 <= i < path.len() ==> 
        '0' <= path[i] && path[i] <= '3'
}

spec fn valid_result(result: Seq<char>) -> bool {
    result.len() > 0 &&
    forall|c: char| result.contains(c) ==> 
        ('0' <= c && c <= '9') || c == '\n'
}

spec fn count_valid_ways(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    let start = find_start(lines, n, m);
    let end = find_end(lines, n, m);
    let path = lines[n + 1];
    count_permutations_reaching_goal(lines, n, m, path, start, end)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    String::new()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_701.rs,105,105,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn parse_lines(stdin_input: Seq<char>) -> Seq<Seq<char>>
    decreases stdin_input.len()
{
    if stdin_input.len() == 0 {
        seq![]
    } else {
        let newline_pos = find_newline(stdin_input, 0);
        if newline_pos == -1 {
            seq![stdin_input]
        } else if newline_pos == 0 {
            parse_lines(stdin_input.subrange(1, stdin_input.len() as int))
        } else if newline_pos < stdin_input.len() && newline_pos >= 0 {
            seq![stdin_input.subrange(0, newline_pos)] + parse_lines(stdin_input.subrange(newline_pos + 1, stdin_input.len() as int))
        } else {
            seq![]
        }
    }
}

spec fn find_newline(s: Seq<char>, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        -1
    } else if s[start] == '\n' {
        start
    } else {
        find_newline(s, start + 1)
    }
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    let lines = parse_lines(stdin_input);
    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0 &&
    (forall|i: int| 0 <= i < lines[0].len() ==> 'a' <= lines[0][i] <= 'z') &&
    (forall|i: int| 0 <= i < lines[1].len() ==> 'a' <= lines[1][i] <= 'z')
}

spec fn is_subsequence(s: Seq<char>, t: Seq<char>) -> bool {
    if s.len() == 0 {
        true
    } else if t.len() == 0 {
        false
    } else if s[0] == t[0] {
        is_subsequence(s.subrange(1, s.len() as int), t.subrange(1, t.len() as int))
    } else {
        is_subsequence(s, t.subrange(1, t.len() as int))
    }
}

spec fn sort_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        let pivot = s[0];
        let smaller = filter_chars(s.subrange(1, s.len() as int), pivot, true, false);
        let equal = filter_chars(s, pivot, false, true);
        let larger = filter_chars(s.subrange(1, s.len() as int), pivot, false, false);
        sort_string(smaller) + equal + sort_string(larger)
    }
}

spec fn filter_chars(s: Seq<char>, pivot: char, take_less: bool, take_equal: bool) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let first = s[0];
        let rest = filter_chars(s.subrange(1, s.len() as int), pivot, take_less, take_equal);
        if (take_less && first < pivot) || (take_equal && first == pivot) || (!take_less && !take_equal && first > pivot) {
            seq![first] + rest
        } else {
            rest
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: &'static str)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""array""
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn parse_lines(stdin_input: Seq<char>) -> Seq<Seq<char>>
    decreases stdin_input.len()
{
    if stdin_input.len() == 0 {
        seq![]
    } else {
        let newline_pos = find_newline(stdin_input, 0);
        if newline_pos == -1 {
            seq![stdin_input]
        } else if newline_pos == 0 {
            parse_lines(stdin_input.subrange(1, stdin_input.len() as int))
        } else if newline_pos < stdin_input.len() && newline_pos >= 0 {
            seq![stdin_input.subrange(0, newline_pos)] + parse_lines(stdin_input.subrange(newline_pos + 1, stdin_input.len() as int))
        } else {
            seq![]
        }
    }
}

spec fn find_newline(s: Seq<char>, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        -1
    } else if s[start] == '\n' {
        start
    } else {
        find_newline(s, start + 1)
    }
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    let lines = parse_lines(stdin_input);
    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0 &&
    (forall|i: int| 0 <= i < lines[0].len() ==> 'a' <= lines[0][i] <= 'z') &&
    (forall|i: int| 0 <= i < lines[1].len() ==> 'a' <= lines[1][i] <= 'z')
}

spec fn is_subsequence(s: Seq<char>, t: Seq<char>) -> bool {
    if s.len() == 0 {
        true
    } else if t.len() == 0 {
        false
    } else if s[0] == t[0] {
        is_subsequence(s.subrange(1, s.len() as int), t.subrange(1, t.len() as int))
    } else {
        is_subsequence(s, t.subrange(1, t.len() as int))
    }
}

spec fn sort_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        let pivot = s[0];
        let smaller = filter_chars(s.subrange(1, s.len() as int), pivot, true, false);
        let equal = filter_chars(s, pivot, false, true);
        let larger = filter_chars(s.subrange(1, s.len() as int), pivot, false, false);
        sort_string(smaller) + equal + sort_string(larger)
    }
}

spec fn filter_chars(s: Seq<char>, pivot: char, take_less: bool, take_equal: bool) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let first = s[0];
        let rest = filter_chars(s.subrange(1, s.len() as int), pivot, take_less, take_equal);
        if (take_less && first < pivot) || (take_equal && first == pivot) || (!take_less && !take_equal && first > pivot) {
            seq![first] + rest
        } else {
            rest
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: &'static str)
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""array""
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_72.rs,62,62,1.0,184.594,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output(result: Seq<char>) -> bool {
    result =~= seq!['K','u','r','o'] || result =~= seq!['S','h','i','r','o'] || result =~= seq!['K','a','t','i','e'] || result =~= seq!['D','r','a','w'] || result.len() == 0
}

spec fn optimal_score(ribbon: Seq<char>, turns: int) -> int 
    recommends ribbon.len() >= 0 && turns >= 0
{
    let max_freq = max_char_freq(ribbon);
    let length = ribbon.len() as int;
    if turns == 1 && max_freq == length {
        if max_freq > 0 { max_freq - 1 } else { 0 }
    } else if length < max_freq + turns {
        length
    } else {
        max_freq + turns
    }
}
spec fn max_char_freq(s: Seq<char>) -> int {
    0
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn max3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c { a } else if b >= c { b } else { c }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures valid_output(result)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output(result: Seq<char>) -> bool {
    result =~= seq!['K','u','r','o'] || result =~= seq!['S','h','i','r','o'] || result =~= seq!['K','a','t','i','e'] || result =~= seq!['D','r','a','w'] || result.len() == 0
}

spec fn optimal_score(ribbon: Seq<char>, turns: int) -> int 
    recommends ribbon.len() >= 0 && turns >= 0
{
    let max_freq = max_char_freq(ribbon);
    let length = ribbon.len() as int;
    if turns == 1 && max_freq == length {
        if max_freq > 0 { max_freq - 1 } else { 0 }
    } else if length < max_freq + turns {
        length
    } else {
        max_freq + turns
    }
}
spec fn max_char_freq(s: Seq<char>) -> int {
    0
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn max3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c { a } else if b >= c { b } else { c }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures valid_output(result)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result =~= seq!['K','u','r','o'] || result =~= seq!['S','h','i','r','o'] || result =~= seq!['K','a','t','i','e'] || result =~= seq!['D','r','a','w'] || result.len() == 0\n}\n\nspec fn optimal_score(ribbon: Seq<char>, turns: int) -> int \n    recommends ribbon.len() >= 0 && turns >= 0\n{\n    let max_freq = max_char_freq(ribbon);\n    let length = ribbon.len() as int;\n    if turns == 1 && max_freq == length {\n        if max_freq > 0 { max_freq - 1 } else { 0 }\n    } else if length < max_freq + turns {\n        length\n    } else {\n        max_freq + turns\n    }\n}\nspec fn max_char_freq(s: Seq<char>) -> int {\n    0\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a } else if b >= c { b } else { c }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(result)\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_726.rs,60,60,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_sorted(hotels: Seq<int>, n: int) -> bool
    decreases n
{
    if n <= 1 {
        true
    } else {
        hotels[n-2] < hotels[n-1] && is_sorted(hotels, n-1)
    }
}

spec fn valid_input(n: int, d: int, hotels: Seq<int>) -> bool {
    n > 0 && d > 0 && hotels.len() == n && is_sorted(hotels, n)
}

spec fn sum_contributions(hotels: Seq<int>, d: int, i: int) -> int
    recommends 0 <= i && i <= hotels.len() - 1,
                d > 0,
                is_sorted(hotels, hotels.len() as int)
    decreases i
    when i >= 0
{
    if i == 0 { 
        0 
    } else {
        let gap = hotels[i as int] - hotels[(i-1) as int];
        let contribution: int = if gap == 2*d { 1 } else if gap > 2*d { 2 } else { 0 };
        contribution + sum_contributions(hotels, d, i-1)
    }
}

spec fn correct_result(n: int, d: int, hotels: Seq<int>, result: int) -> bool
    recommends valid_input(n, d, hotels)
{
    result == 2 + sum_contributions(hotels, d, n-1) && result >= 2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, d: i8, hotels: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, d as int, hotels@.map(|_, x: i8| x as int))
    ensures correct_result(n as int, d as int, hotels@.map(|_, x: i8| x as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn is_sorted(hotels: Seq<int>, n: int) -> bool
    decreases n
{
    if n <= 1 {
        true
    } else {
        hotels[n-2] < hotels[n-1] && is_sorted(hotels, n-1)
    }
}

spec fn valid_input(n: int, d: int, hotels: Seq<int>) -> bool {
    n > 0 && d > 0 && hotels.len() == n && is_sorted(hotels, n)
}

spec fn sum_contributions(hotels: Seq<int>, d: int, i: int) -> int
    recommends 0 <= i && i <= hotels.len() - 1,
                d > 0,
                is_sorted(hotels, hotels.len() as int)
    decreases i
    when i >= 0
{
    if i == 0 { 
        0 
    } else {
        let gap = hotels[i as int] - hotels[(i-1) as int];
        let contribution: int = if gap == 2*d { 1 } else if gap > 2*d { 2 } else { 0 };
        contribution + sum_contributions(hotels, d, i-1)
    }
}

spec fn correct_result(n: int, d: int, hotels: Seq<int>, result: int) -> bool
    recommends valid_input(n, d, hotels)
{
    result == 2 + sum_contributions(hotels, d, n-1) && result >= 2
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, d: i8, hotels: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, d as int, hotels@.map(|_, x: i8| x as int))
    ensures correct_result(n as int, d as int, hotels@.map(|_, x: i8| x as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_743.rs,55,55,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,,1.0,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: int, ar: Seq<int>) -> bool {
    n >= 2 && ar.len() == n && (forall|i: int| 0 <= i < n ==> ar[i] > 0)
}

spec fn gcd(x: int, y: int) -> int
    requires x > 0 && y > 0,
    ensures gcd(x, y) > 0,
    decreases if x < y { y } else { x },
{
    if x == y { x }
    else if x < y { gcd(x, y - x) }
    else { gcd(x - y, y) }
}

spec fn gcd_of_sequence(ar: Seq<int>) -> int
    requires ar.len() >= 1,
    requires (forall|i: int| 0 <= i < ar.len() ==> ar[i] > 0),
    ensures gcd_of_sequence(ar) > 0,
    decreases ar.len(),
{
    if ar.len() == 1 { ar[0] }
    else { gcd(ar[0], gcd_of_sequence(ar.subrange(1, ar.len() as int))) }
}

spec fn minimal_sum(n: int, ar: Seq<int>) -> int
    requires valid_input(n, ar),
{
    gcd_of_sequence(ar) * n
}
// </vc-helpers>

// <vc-spec>
fn solve(n: int, ar: Seq<int>) -> (result: int)
    requires valid_input(n, ar),
    ensures result == minimal_sum(n, ar),
    ensures result > 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn valid_input(n: int, ar: Seq<int>) -> bool {
    n >= 2 && ar.len() == n && (forall|i: int| 0 <= i < n ==> ar[i] > 0)
}

spec fn gcd(x: int, y: int) -> int
    requires x > 0 && y > 0,
    ensures gcd(x, y) > 0,
    decreases if x < y { y } else { x },
{
    if x == y { x }
    else if x < y { gcd(x, y - x) }
    else { gcd(x - y, y) }
}

spec fn gcd_of_sequence(ar: Seq<int>) -> int
    requires ar.len() >= 1,
    requires (forall|i: int| 0 <= i < ar.len() ==> ar[i] > 0),
    ensures gcd_of_sequence(ar) > 0,
    decreases ar.len(),
{
    if ar.len() == 1 { ar[0] }
    else { gcd(ar[0], gcd_of_sequence(ar.subrange(1, ar.len() as int))) }
}

spec fn minimal_sum(n: int, ar: Seq<int>) -> int
    requires valid_input(n, ar),
{
    gcd_of_sequence(ar) * n
}
// </vc-helpers>

// <vc-spec>
fn solve(n: int, ar: Seq<int>) -> (result: int)
    requires valid_input(n, ar),
    ensures result == minimal_sum(n, ar),
    ensures result > 0,
// </vc-spec>
// <vc-code>
{
    assume(false);
    0
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_752.rs,83,83,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(input: &str) -> Seq<&str>
    uninterp;

spec fn parse_integer(s: &str) -> int
    uninterp;

spec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>
    uninterp;

spec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat
    uninterp;

spec fn int_to_string(n: nat) -> String
    uninterp;

spec fn valid_input(stdin_input: &str) -> bool {
    let lines = split_lines(stdin_input);
    lines.len() >= 1 && {
        let n = parse_integer(lines[0]);
        n >= 0 && lines.len() >= (2 * n + 1) && 
        (forall|i: int| 1 <= i <= 2 * n ==> 
            i < lines.len() && lines[i].len() > 0)
    }
}

spec fn compute_mismatches(stdin_input: &str) -> nat
    decreases stdin_input.len()
{
    let lines = split_lines(stdin_input);
    let n = parse_integer(lines[0]);
    if n == 0 { 
        0 
    } else {
        let prev_sizes = count_sizes(lines.subrange(1, n + 1));
        let current_sizes = lines.subrange(n + 1, 2 * n + 1);
        count_unmatched_sizes(prev_sizes, current_sizes)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        stdin_input.len() > 0,
        valid_input(stdin_input),
    ensures 
        result.len() > 0,
        result.as_bytes()[result.len()-1] == b'\n' || 
            (result.len() > 1 && result.as_bytes().subrange(result.len()-2, result.len()) == seq![b'\r', b'\n']),
        exists|mismatches: nat| 
            result == int_to_string(mismatches) + ""\n"" && 
            mismatches == compute_mismatches(stdin_input),
        ({
            let lines = split_lines(stdin_input);
            let n = parse_integer(lines[0]);
            n >= 0 ==> {
                let mismatches = compute_mismatches(stdin_input);
                mismatches <= n &&
                result == int_to_string(mismatches) + ""\n""
            }
        }),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    String::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn split_lines(input: &str) -> Seq<&str>
    uninterp;

spec fn parse_integer(s: &str) -> int
    uninterp;

spec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>
    uninterp;

spec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat
    uninterp;

spec fn int_to_string(n: nat) -> String
    uninterp;

spec fn valid_input(stdin_input: &str) -> bool {
    let lines = split_lines(stdin_input);
    lines.len() >= 1 && {
        let n = parse_integer(lines[0]);
        n >= 0 && lines.len() >= (2 * n + 1) && 
        (forall|i: int| 1 <= i <= 2 * n ==> 
            i < lines.len() && lines[i].len() > 0)
    }
}

spec fn compute_mismatches(stdin_input: &str) -> nat
    decreases stdin_input.len()
{
    let lines = split_lines(stdin_input);
    let n = parse_integer(lines[0]);
    if n == 0 { 
        0 
    } else {
        let prev_sizes = count_sizes(lines.subrange(1, n + 1));
        let current_sizes = lines.subrange(n + 1, 2 * n + 1);
        count_unmatched_sizes(prev_sizes, current_sizes)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires 
        stdin_input.len() > 0,
        valid_input(stdin_input),
    ensures 
        result.len() > 0,
        result.as_bytes()[result.len()-1] == b'\n' || 
            (result.len() > 1 && result.as_bytes().subrange(result.len()-2, result.len()) == seq![b'\r', b'\n']),
        exists|mismatches: nat| 
            result == int_to_string(mismatches) + ""\n"" && 
            mismatches == compute_mismatches(stdin_input),
        ({
            let lines = split_lines(stdin_input);
            let n = parse_integer(lines[0]);
            n >= 0 ==> {
                let mismatches = compute_mismatches(stdin_input);
                mismatches <= n &&
                result == int_to_string(mismatches) + ""\n""
            }
        }),
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    String::new()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_753.rs,59,59,1.0,187.005,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn gcd(a: int, b: int) -> int
    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })
{
    if b == 0 {
        if a >= 0 { a } else { -a }
    } else {
        gcd(b, a % b)
    }
}

spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    a > 0 && b > 0 && c > 0 && d > 0
}

spec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {
    num >= 0 && den > 0 && 
    gcd(num, den) == 1
    /* && s == int_to_string(num) + ""/"" + int_to_string(den) */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: int, b: int, c: int, d: int) -> (result: Seq<char>)
    requires valid_input(a, b, c, d)
    ensures ({
        let equal_case = a * d == b * c;
        let greater_case = a * d > b * c;
        let less_case = a * d < b * c;
        
        (equal_case ==> result == seq!['0', '/', '1']) &&
        (greater_case ==> exists|numerator: int, denominator: int| 
            numerator > 0 && denominator > 0 && 
            gcd(numerator, denominator) == 1 &&
            numerator * a * d == (a * d - b * c) * denominator) &&
        (less_case ==> exists|numerator: int, denominator: int| 
            numerator > 0 && denominator > 0 && 
            gcd(numerator, denominator) == 1 &&
            numerator * b * c == (b * c - a * d) * denominator)
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn gcd(a: int, b: int) -> int
    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })
{
    if b == 0 {
        if a >= 0 { a } else { -a }
    } else {
        gcd(b, a % b)
    }
}

spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    a > 0 && b > 0 && c > 0 && d > 0
}

spec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {
    num >= 0 && den > 0 && 
    gcd(num, den) == 1
    /* && s == int_to_string(num) + ""/"" + int_to_string(den) */
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(a: int, b: int, c: int, d: int) -> (result: Seq<char>)
    requires valid_input(a, b, c, d)
    ensures ({
        let equal_case = a * d == b * c;
        let greater_case = a * d > b * c;
        let less_case = a * d < b * c;
        
        (equal_case ==> result == seq!['0', '/', '1']) &&
        (greater_case ==> exists|numerator: int, denominator: int| 
            numerator > 0 && denominator > 0 && 
            gcd(numerator, denominator) == 1 &&
            numerator * a * d == (a * d - b * c) * denominator) &&
        (less_case ==> exists|numerator: int, denominator: int| 
            numerator > 0 && denominator > 0 && 
            gcd(numerator, denominator) == 1 &&
            numerator * b * c == (b * c - a * d) * denominator)
    })
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })\n{\n    if b == 0 {\n        if a >= 0 { a } else { -a }\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a > 0 && b > 0 && c > 0 && d > 0\n}\n\nspec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {\n    num >= 0 && den > 0 && \n    gcd(num, den) == 1\n    /* && s == int_to_string(num) + ""/"" + int_to_string(den) */\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(a: int, b: int, c: int, d: int) -> (result: Seq<char>)\n    requires valid_input(a, b, c, d)\n    ensures ({\n        let equal_case = a * d == b * c;\n        let greater_case = a * d > b * c;\n        let less_case = a * d < b * c;\n        \n        (equal_case ==> result == seq![\'0\', \'/\', \'1\']) &&\n        (greater_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * a * d == (a * d - b * c) * denominator) &&\n        (less_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * b * c == (b * c - a * d) * denominator)\n    })\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_756.rs,56,56,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && n <= 90 &&
    a.len() == n &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= 90) &&
    (forall|i: int, j: int| i + 1 == j && 0 <= i < n - 1 ==> #[trigger] a[i] < #[trigger] a[j])
}

spec fn find_cutoff(a: Seq<int>, index: int, cutoff: int) -> int
    decreases a.len() - index
    when 0 <= index <= a.len()
{
    if index >= a.len() {
        cutoff
    } else if a[index] > cutoff {
        cutoff
    } else {
        find_cutoff(a, index + 1, a[index] + 15)
    }
}

spec fn min(x: int, y: int) -> int {
    if x <= y { x } else { y }
}

spec fn valid_output(result: int, n: int, a: Seq<int>) -> bool {
    valid_input(n, a) ==>
    (1 <= result <= 90 &&
     result == min(90, find_cutoff(a, 0, 15)))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|x| x as int))
    ensures valid_output(result as int, n as int, a@.map(|x| x as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && n <= 90 &&
    a.len() == n &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= 90) &&
    (forall|i: int, j: int| i + 1 == j && 0 <= i < n - 1 ==> #[trigger] a[i] < #[trigger] a[j])
}

spec fn find_cutoff(a: Seq<int>, index: int, cutoff: int) -> int
    decreases a.len() - index
    when 0 <= index <= a.len()
{
    if index >= a.len() {
        cutoff
    } else if a[index] > cutoff {
        cutoff
    } else {
        find_cutoff(a, index + 1, a[index] + 15)
    }
}

spec fn min(x: int, y: int) -> int {
    if x <= y { x } else { y }
}

spec fn valid_output(result: int, n: int, a: Seq<int>) -> bool {
    valid_input(n, a) ==>
    (1 <= result <= 90 &&
     result == min(90, find_cutoff(a, 0, 15)))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|x| x as int))
    ensures valid_output(result as int, n as int, a@.map(|x| x as int))
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_807.rs,79,79,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, c: int, prices: Seq<int>) -> bool {
    n >= 2 && prices.len() == n && c >= 0 &&
    (forall|i: int| 0 <= i < prices.len() ==> prices[i] >= 0)
}

spec fn profit_for_day(prices: Seq<int>, day: int, c: int) -> int {
    if 0 <= day < prices.len() - 1 {
        prices[day] - prices[day + 1] - c
    } else {
        0
    }
}

spec fn max_possible_profit(prices: Seq<int>, c: int) -> int {
    if prices.len() >= 2 {
        let profits = Seq::new((prices.len() - 1) as nat, |i: int| profit_for_day(prices, i, c));
        if profits.len() == 0 { 
            0 
        } else {
            let max_profit = profits[0];
            if profits.len() == 1 { 
                max_profit 
            } else { 
                seq_max(profits) 
            }
        }
    } else {
        0
    }
}

spec fn seq_max(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() > 0 {
        if s.len() == 1 { 
            s[0] 
        } else if s[0] >= seq_max(s.subrange(1, s.len() as int)) { 
            s[0] 
        } else { 
            seq_max(s.subrange(1, s.len() as int)) 
        }
    } else {
        0
    }
}

spec fn correct_result(n: int, c: int, prices: Seq<int>, result: int) -> bool {
    valid_input(n, c, prices) ==>
    (result >= 0 &&
     (result == 0 <==> (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= 0)) &&
     (result > 0 ==> (exists|i: int| 0 <= i < n - 1 && profit_for_day(prices, i, c) == result)) &&
     (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= result))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, c: i8, prices: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, c as int, prices@.map(|v| v as int))
    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, c: int, prices: Seq<int>) -> bool {
    n >= 2 && prices.len() == n && c >= 0 &&
    (forall|i: int| 0 <= i < prices.len() ==> prices[i] >= 0)
}

spec fn profit_for_day(prices: Seq<int>, day: int, c: int) -> int {
    if 0 <= day < prices.len() - 1 {
        prices[day] - prices[day + 1] - c
    } else {
        0
    }
}

spec fn max_possible_profit(prices: Seq<int>, c: int) -> int {
    if prices.len() >= 2 {
        let profits = Seq::new((prices.len() - 1) as nat, |i: int| profit_for_day(prices, i, c));
        if profits.len() == 0 { 
            0 
        } else {
            let max_profit = profits[0];
            if profits.len() == 1 { 
                max_profit 
            } else { 
                seq_max(profits) 
            }
        }
    } else {
        0
    }
}

spec fn seq_max(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() > 0 {
        if s.len() == 1 { 
            s[0] 
        } else if s[0] >= seq_max(s.subrange(1, s.len() as int)) { 
            s[0] 
        } else { 
            seq_max(s.subrange(1, s.len() as int)) 
        }
    } else {
        0
    }
}

spec fn correct_result(n: int, c: int, prices: Seq<int>, result: int) -> bool {
    valid_input(n, c, prices) ==>
    (result >= 0 &&
     (result == 0 <==> (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= 0)) &&
     (result > 0 ==> (exists|i: int| 0 <= i < n - 1 && profit_for_day(prices, i, c) == result)) &&
     (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= result))
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, c: i8, prices: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, c as int, prices@.map(|v| v as int))
    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_813.rs,71,22,0.30985915492957744,311.649,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&
    {
        let n = parse_int(split_spaces(lines[0])[0]);
        n > 0
    }
}

spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool {
    let lines = split_lines(input);
    let n = parse_int(split_spaces(lines[0])[0]);
    result.len() == 2 * n - 1 &&
    (forall|i: int| 0 <= i < n ==> #[trigger] result[2*i] == '1' || result[2*i] == '2') &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[2*i+1] == ' ')
}

spec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool {
    let lines = split_lines(input);
    let n = parse_int(split_spaces(lines[0])[0]);
    let arthur_apples = parse_int_seq(split_spaces(lines[1]));
    let arthur_set = Set::new(|x: int| arthur_apples.contains(x));
    forall|i: int| 1 <= i <= n ==> 
        (arthur_set.contains(i) ==> #[trigger] result[2*(i-1)] == '1') &&
        (!arthur_set.contains(i) ==> result[2*(i-1)] == '2')
}

/* Helper functions for parsing (spec functions) */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> {
    Seq::empty()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires input.len() > 0
    ensures 
        !valid_input(input@) ==> result.len() == 0,
        valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',
// </vc-spec>
// <vc-code>
{
    assume(false);
    Vec::new()
}
// </vc-code>


}

fn main() {}","use vstd::prelude::*;
        verus! {
       spec fn valid_input(input: Seq<char>) -> bool {
          let lines = split_lines(input);
          lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&     {
             let n = parse_int(split_spaces(lines[0])[0]);
             n > 0     }
      }
       spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool ;
       spec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool ;
       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;
       spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> ;
       spec fn parse_int(s: Seq<char>) -> int {
          0 }
       spec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> ;
       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires input.len() > 0     ensures          !valid_input(input@) ==> result.len() == 0,         valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),         forall|i: int| 0 <= i < result.len() ==>        
#[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',
{
          Vec::new() }
       }
        fn main() {
      }
","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&\n    {\n        let n = parse_int(split_spaces(lines[0])[0]);\n        n > 0\n    }\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    let n = parse_int(split_spaces(lines[0])[0]);\n    result.len() == 2 * n - 1 &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[2*i] == '1' || result[2*i] == '2') &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[2*i+1] == ' ')\n}\n\nspec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    let n = parse_int(split_spaces(lines[0])[0]);\n    let arthur_apples = parse_int_seq(split_spaces(lines[1]));\n    let arthur_set = Set::new(|x: int| arthur_apples.contains(x));\n    forall|i: int| 1 <= i <= n ==> \n        (arthur_set.contains(i) ==> #[trigger] result[2*(i-1)] == '1') &&\n        (!arthur_set.contains(i) ==> result[2*(i-1)] == '2')\n}\n\n/* Helper functions for parsing (spec functions) */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> {\n    Seq::empty()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n    ensures \n        !valid_input(input@) ==> result.len() == 0,\n        valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', ""use vstd::prelude::*;\n        verus! {\n       spec fn valid_input(input: Seq<char>) -> bool {\n          let lines = split_lines(input);\n          lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&     {\n             let n = parse_int(split_spaces(lines[0])[0]);\n             n > 0     }\n      }\n       spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool ;\n       spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> ;\n       spec fn parse_int(s: Seq<char>) -> int {\n          0 }\n       spec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> ;\n       fn solve(input: Vec<char>) -> (result: Vec<char>)     requires input.len() > 0     ensures          !valid_input(input@) ==> result.len() == 0,         valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),         forall|i: int| 0 <= i < result.len() ==>        \n#[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',\n{\n          Vec::new() }\n       }\n        fn main() {\n      }\n"", 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd::prelude::*;\n            fn main() {\n  }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_864.rs,63,63,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn possible(n: int, food_types: Seq<int>, days: int) -> bool
    recommends n >= 0, days >= 0, forall|i: int| 0 <= i < food_types.len() ==> food_types[i] >= 1
{
    if days == 0 { true }
    else {
        let total_participants = count_total_participants(food_types, days, 1);
        total_participants >= n
    }
}

spec fn count_total_participants(food_types: Seq<int>, days: int, current_type: int) -> int
    recommends days >= 0, current_type >= 1
    decreases 101 - current_type
{
    if current_type > 100 { 0 }
    else {
        let packages_of_this_type = count_packages(food_types, current_type);
        let participants_for_this_type = if days > 0 { packages_of_this_type / days } else { 0 };
        participants_for_this_type + count_total_participants(food_types, days, current_type + 1)
    }
}

spec fn count_packages(food_types: Seq<int>, target_type: int) -> int
    recommends target_type >= 1
    decreases food_types.len()
{
    if food_types.len() == 0 { 0 }
    else if food_types[0] == target_type { 1 + count_packages(food_types.subrange(1, food_types.len() as int), target_type) }
    else { count_packages(food_types.subrange(1, food_types.len() as int), target_type) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, food_types: Vec<i8>) -> (result: i8)
    requires 1 <= n <= 100,
             1 <= m <= 100,
             food_types@.len() == m as int,
             forall|i: int| 0 <= i < food_types@.len() ==> #[trigger] food_types@[i] >= 1 && #[trigger] food_types@[i] <= 100
    ensures result >= 0,
            result <= m,
            result > 0 ==> possible(n as int, food_types@.map(|i, x: i8| x as int), result as int),
            !possible(n as int, food_types@.map(|i, x: i8| x as int), result as int + 1),
            forall|d: int| #[trigger] possible(n as int, food_types@.map(|i, x: i8| x as int), d) ==> d <= result as int
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn possible(n: int, food_types: Seq<int>, days: int) -> bool
    recommends n >= 0, days >= 0, forall|i: int| 0 <= i < food_types.len() ==> food_types[i] >= 1
{
    if days == 0 { true }
    else {
        let total_participants = count_total_participants(food_types, days, 1);
        total_participants >= n
    }
}

spec fn count_total_participants(food_types: Seq<int>, days: int, current_type: int) -> int
    recommends days >= 0, current_type >= 1
    decreases 101 - current_type
{
    if current_type > 100 { 0 }
    else {
        let packages_of_this_type = count_packages(food_types, current_type);
        let participants_for_this_type = if days > 0 { packages_of_this_type / days } else { 0 };
        participants_for_this_type + count_total_participants(food_types, days, current_type + 1)
    }
}

spec fn count_packages(food_types: Seq<int>, target_type: int) -> int
    recommends target_type >= 1
    decreases food_types.len()
{
    if food_types.len() == 0 { 0 }
    else if food_types[0] == target_type { 1 + count_packages(food_types.subrange(1, food_types.len() as int), target_type) }
    else { count_packages(food_types.subrange(1, food_types.len() as int), target_type) }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, food_types: Vec<i8>) -> (result: i8)
    requires 1 <= n <= 100,
             1 <= m <= 100,
             food_types@.len() == m as int,
             forall|i: int| 0 <= i < food_types@.len() ==> #[trigger] food_types@[i] >= 1 && #[trigger] food_types@[i] <= 100
    ensures result >= 0,
            result <= m,
            result > 0 ==> possible(n as int, food_types@.map(|i, x: i8| x as int), result as int),
            !possible(n as int, food_types@.map(|i, x: i8| x as int), result as int + 1),
            forall|d: int| #[trigger] possible(n as int, food_types@.map(|i, x: i8| x as int), d) ==> d <= result as int
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_877.rs,68,68,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, pairs: Seq<(int, int)>) -> bool {
    n >= 2 && 
    m >= 0 && 
    pairs.len() == m &&
    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 >= 1 && #[trigger] pairs[i].0 <= n && #[trigger] pairs[i].1 >= 1 && #[trigger] pairs[i].1 <= n) &&
    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 != #[trigger] pairs[i].1)
}

spec fn compute_final_l(pairs: Seq<(int, int)>) -> int
    decreases pairs.len()
{
    if pairs.len() == 0 { 1 }
    else {
        let x = pairs[pairs.len() - 1].0;
        let y = pairs[pairs.len() - 1].1;
        let min_val = if x < y { x } else { y };
        let rest_l = compute_final_l(pairs.subrange(0, pairs.len() - 1));
        if rest_l > min_val { rest_l } else { min_val }
    }
}

spec fn compute_final_r(n: int, pairs: Seq<(int, int)>) -> int
    decreases pairs.len()
{
    if pairs.len() == 0 { n }
    else {
        let x = pairs[pairs.len() - 1].0;
        let y = pairs[pairs.len() - 1].1;
        let max_val = if x > y { x } else { y };
        let rest_r = compute_final_r(n, pairs.subrange(0, pairs.len() - 1));
        if rest_r < max_val { rest_r } else { max_val }
    }
}

spec fn max(a: int, b: int) -> int {
    if a > b { a } else { b }
}

spec fn valid_result(n: int, pairs: Seq<(int, int)>, result: int) -> bool {
    result >= 0 &&
    result <= n - 1 &&
    result == max(compute_final_r(n, pairs) - compute_final_l(pairs), 0)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, pairs: Vec<(i8, i8)>) -> (result: i8)
    requires valid_input(n as int, m as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)))
    ensures valid_result(n as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, pairs: Seq<(int, int)>) -> bool {
    n >= 2 && 
    m >= 0 && 
    pairs.len() == m &&
    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 >= 1 && #[trigger] pairs[i].0 <= n && #[trigger] pairs[i].1 >= 1 && #[trigger] pairs[i].1 <= n) &&
    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 != #[trigger] pairs[i].1)
}

spec fn compute_final_l(pairs: Seq<(int, int)>) -> int
    decreases pairs.len()
{
    if pairs.len() == 0 { 1 }
    else {
        let x = pairs[pairs.len() - 1].0;
        let y = pairs[pairs.len() - 1].1;
        let min_val = if x < y { x } else { y };
        let rest_l = compute_final_l(pairs.subrange(0, pairs.len() - 1));
        if rest_l > min_val { rest_l } else { min_val }
    }
}

spec fn compute_final_r(n: int, pairs: Seq<(int, int)>) -> int
    decreases pairs.len()
{
    if pairs.len() == 0 { n }
    else {
        let x = pairs[pairs.len() - 1].0;
        let y = pairs[pairs.len() - 1].1;
        let max_val = if x > y { x } else { y };
        let rest_r = compute_final_r(n, pairs.subrange(0, pairs.len() - 1));
        if rest_r < max_val { rest_r } else { max_val }
    }
}

spec fn max(a: int, b: int) -> int {
    if a > b { a } else { b }
}

spec fn valid_result(n: int, pairs: Seq<(int, int)>, result: int) -> bool {
    result >= 0 &&
    result <= n - 1 &&
    result == max(compute_final_r(n, pairs) - compute_final_l(pairs), 0)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: i8, m: i8, pairs: Vec<(i8, i8)>) -> (result: i8)
    requires valid_input(n as int, m as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)))
    ensures valid_result(n as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)), result as int)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_889.rs,84,84,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn parse_input_lines(input: Seq<char>) -> Seq<Seq<char>>
{
    split_by_newline_simple(input, 0, seq![])
}

spec fn split_by_newline_simple(input: Seq<char>, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - pos
{
    if pos >= input.len() {
        acc
    } else {
        let next_newline = find_next_newline(input, pos);
        if next_newline == -1 {
            if pos < input.len() {
                acc.push(input.subrange(pos, input.len() as int))
            } else {
                acc
            }
        } else {
            split_by_newline_simple(input, next_newline + 1, acc.push(input.subrange(pos, next_newline)))
        }
    }
}

spec fn find_next_newline(input: Seq<char>, start: int) -> int
    decreases input.len() - start
{
    if start >= input.len() {
        -1
    } else if input[start] == '\n' {
        start
    } else {
        find_next_newline(input, start + 1)
    }
}

spec fn count_black_in_square(lines: Seq<Seq<char>>, row: int, col: int) -> int
{
    (if lines[row][col] == '#' { 1int } else { 0int }) +
    (if lines[row][col + 1] == '#' { 1int } else { 0int }) +
    (if lines[row + 1][col] == '#' { 1int } else { 0int }) +
    (if lines[row + 1][col + 1] == '#' { 1int } else { 0int })
}

spec fn valid_grid(lines: Seq<Seq<char>>) -> bool
{
    lines.len() == 4 && (forall|k: int| 0 <= k < 4 ==> lines[k].len() >= 4)
}

spec fn can_make_uniform_square(lines: Seq<Seq<char>>) -> bool
{
    exists|i: int, j: int| 0 <= i <= 2 && 0 <= j <= 2 && 
        i + 1 < lines.len() && j + 1 < lines[i].len() && j + 1 < lines[i + 1].len() &&
        {
            let black_count = count_black_in_square(lines, i, j);
            black_count >= 3 || black_count <= 1
        }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']
// </vc-spec>
// <vc-code>
{
    assume(false);
    String::new()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn parse_input_lines(input: Seq<char>) -> Seq<Seq<char>>
{
    split_by_newline_simple(input, 0, seq![])
}

spec fn split_by_newline_simple(input: Seq<char>, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - pos
{
    if pos >= input.len() {
        acc
    } else {
        let next_newline = find_next_newline(input, pos);
        if next_newline == -1 {
            if pos < input.len() {
                acc.push(input.subrange(pos, input.len() as int))
            } else {
                acc
            }
        } else {
            split_by_newline_simple(input, next_newline + 1, acc.push(input.subrange(pos, next_newline)))
        }
    }
}

spec fn find_next_newline(input: Seq<char>, start: int) -> int
    decreases input.len() - start
{
    if start >= input.len() {
        -1
    } else if input[start] == '\n' {
        start
    } else {
        find_next_newline(input, start + 1)
    }
}

spec fn count_black_in_square(lines: Seq<Seq<char>>, row: int, col: int) -> int
{
    (if lines[row][col] == '#' { 1int } else { 0int }) +
    (if lines[row][col + 1] == '#' { 1int } else { 0int }) +
    (if lines[row + 1][col] == '#' { 1int } else { 0int }) +
    (if lines[row + 1][col + 1] == '#' { 1int } else { 0int })
}

spec fn valid_grid(lines: Seq<Seq<char>>) -> bool
{
    lines.len() == 4 && (forall|k: int| 0 <= k < 4 ==> lines[k].len() >= 4)
}

spec fn can_make_uniform_square(lines: Seq<Seq<char>>) -> bool
{
    exists|i: int, j: int| 0 <= i <= 2 && 0 <= j <= 2 && 
        i + 1 < lines.len() && j + 1 < lines[i].len() && j + 1 < lines[i + 1].len() &&
        {
            let black_count = count_black_in_square(lines, i, j);
            black_count >= 3 || black_count <= 1
        }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']
// </vc-spec>
// <vc-code>
{
    assume(false);
    String::new()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_901.rs,72,72,1.0,,,0.9999999999999999,True,['vstd::prelude::'],False,other,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn split_lines(s: &str) -> Seq<&str>
{
    if s.len() == 0 { seq![] } else { seq![s] }
}

spec fn split_ints(s: &str) -> Seq<int>
{
    seq![]
}

spec fn seq_to_set(s: Seq<int>) -> Set<int>
{
    s.to_set()
}

spec fn is_dangerous_group(group_data: Seq<int>) -> bool
{
    if group_data.len() <= 1 { 
        false 
    } else {
        let group_members = group_data.subrange(1, group_data.len() as int);
        let member_set = seq_to_set(group_members);
        forall|member: int| member_set.contains(member) ==> !member_set.contains(-member)
    }
}

spec fn exists_dangerous_group(stdin_input: &str) -> bool
{
    let lines = split_lines(stdin_input);
    if lines.len() == 0 { 
        false 
    } else {
        let first_line = split_ints(lines[0]);
        if first_line.len() < 2 { 
            false 
        } else {
            let n = first_line[0];
            let m = first_line[1];
            if m <= 0 || n <= 0 { 
                false 
            } else {
                exists|i: int| 1 <= i <= m && i < lines.len() && 
                    is_dangerous_group(split_ints(lines[i]))
            }
        }
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0
    ensures (result == ""YES\n"") || (result == ""NO\n"")
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO\n"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
// </vc-preamble>

// <vc-helpers>
spec fn split_lines(s: &str) -> Seq<&str>
{
    if s.len() == 0 { seq![] } else { seq![s] }
}

spec fn split_ints(s: &str) -> Seq<int>
{
    seq![]
}

spec fn seq_to_set(s: Seq<int>) -> Set<int>
{
    s.to_set()
}

spec fn is_dangerous_group(group_data: Seq<int>) -> bool
{
    if group_data.len() <= 1 { 
        false 
    } else {
        let group_members = group_data.subrange(1, group_data.len() as int);
        let member_set = seq_to_set(group_members);
        forall|member: int| member_set.contains(member) ==> !member_set.contains(-member)
    }
}

spec fn exists_dangerous_group(stdin_input: &str) -> bool
{
    let lines = split_lines(stdin_input);
    if lines.len() == 0 { 
        false 
    } else {
        let first_line = split_ints(lines[0]);
        if first_line.len() < 2 { 
            false 
        } else {
            let n = first_line[0];
            let m = first_line[1];
            if m <= 0 || n <= 0 { 
                false 
            } else {
                exists|i: int| 1 <= i <= m && i < lines.len() && 
                    is_dangerous_group(split_ints(lines[i]))
            }
        }
    }
}
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0
    ensures (result == ""YES\n"") || (result == ""NO\n"")
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO\n"".to_string()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_911.rs,92,92,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, c: int, p: Seq<int>, t: Seq<int>) -> bool {
    n > 0 && c > 0 && p.len() == n && t.len() == n &&
    (forall|i: int| 0 <= i < n ==> p[i] > 0) &&
    (forall|i: int| 0 <= i < n ==> t[i] > 0) &&
    (forall|i: int| 0 <= i < n-1 ==> p[i] < p[i+1]) &&
    (forall|i: int| 0 <= i < n-1 ==> t[i] < t[i+1])
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { s[0] + sum_seq(s.drop_first()) }
}

spec fn calculate_limak_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int
    requires n > 0 && p.len() == n && t.len() == n
    decreases n
{
    if n == 0 { 0 }
    else { 
        let cumulative_time = sum_seq(t.take(1));
        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };
        score + calculate_limak_score_helper(n-1, c, p.skip(1), t.skip(1), cumulative_time)
    }
}

spec fn calculate_limak_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int
    requires remaining >= 0 && p.len() == remaining && t.len() == remaining
    decreases remaining
{
    if remaining == 0 { 0 }
    else { 
        let cumulative_time = prev_time + t[0];
        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };
        score + calculate_limak_score_helper(remaining-1, c, p.skip(1), t.skip(1), cumulative_time)
    }
}

spec fn calculate_radewoosh_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int
    requires n > 0 && p.len() == n && t.len() == n
{
    calculate_radewoosh_score_helper(n, c, p, t, 0)
}

spec fn calculate_radewoosh_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int
    requires remaining >= 0 && p.len() >= remaining && t.len() >= remaining
    decreases remaining
{
    if remaining == 0 { 0 }
    else { 
        let idx = remaining - 1;
        let cumulative_time = prev_time + t[idx];
        let score = if p[idx] - c * cumulative_time > 0 { p[idx] - c * cumulative_time } else { 0 };
        score + calculate_radewoosh_score_helper(remaining-1, c, p, t, cumulative_time)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: int, c: int, p: Seq<int>, t: Seq<int>) -> (result: String)
    requires valid_input(n, c, p, t)
    ensures result == ""Limak"" || result == ""Radewoosh"" || result == ""Tie""
    ensures {
            let limak_score = calculate_limak_score(n, c, p, t);
            let radewoosh_score = calculate_radewoosh_score(n, c, p, t);
            (result == ""Limak"") == (limak_score > radewoosh_score) &&
            (result == ""Radewoosh"") == (limak_score < radewoosh_score) &&
            (result == ""Tie"") == (limak_score == radewoosh_score)
    }
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, c: int, p: Seq<int>, t: Seq<int>) -> bool {
    n > 0 && c > 0 && p.len() == n && t.len() == n &&
    (forall|i: int| 0 <= i < n ==> p[i] > 0) &&
    (forall|i: int| 0 <= i < n ==> t[i] > 0) &&
    (forall|i: int| 0 <= i < n-1 ==> p[i] < p[i+1]) &&
    (forall|i: int| 0 <= i < n-1 ==> t[i] < t[i+1])
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { s[0] + sum_seq(s.drop_first()) }
}

spec fn calculate_limak_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int
    requires n > 0 && p.len() == n && t.len() == n
    decreases n
{
    if n == 0 { 0 }
    else { 
        let cumulative_time = sum_seq(t.take(1));
        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };
        score + calculate_limak_score_helper(n-1, c, p.skip(1), t.skip(1), cumulative_time)
    }
}

spec fn calculate_limak_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int
    requires remaining >= 0 && p.len() == remaining && t.len() == remaining
    decreases remaining
{
    if remaining == 0 { 0 }
    else { 
        let cumulative_time = prev_time + t[0];
        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };
        score + calculate_limak_score_helper(remaining-1, c, p.skip(1), t.skip(1), cumulative_time)
    }
}

spec fn calculate_radewoosh_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int
    requires n > 0 && p.len() == n && t.len() == n
{
    calculate_radewoosh_score_helper(n, c, p, t, 0)
}

spec fn calculate_radewoosh_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int
    requires remaining >= 0 && p.len() >= remaining && t.len() >= remaining
    decreases remaining
{
    if remaining == 0 { 0 }
    else { 
        let idx = remaining - 1;
        let cumulative_time = prev_time + t[idx];
        let score = if p[idx] - c * cumulative_time > 0 { p[idx] - c * cumulative_time } else { 0 };
        score + calculate_radewoosh_score_helper(remaining-1, c, p, t, cumulative_time)
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: int, c: int, p: Seq<int>, t: Seq<int>) -> (result: String)
    requires valid_input(n, c, p, t)
    ensures result == ""Limak"" || result == ""Radewoosh"" || result == ""Tie""
    ensures {
            let limak_score = calculate_limak_score(n, c, p, t);
            let radewoosh_score = calculate_radewoosh_score(n, c, p, t);
            (result == ""Limak"") == (limak_score > radewoosh_score) &&
            (result == ""Radewoosh"") == (limak_score < radewoosh_score) &&
            (result == ""Tie"") == (limak_score == radewoosh_score)
    }
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_93.rs,100,100,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_newlines(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == '\n' { 1int } else { 0int }) + count_newlines(s.subrange(1, s.len() as int))
    }
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.contains('\n') && count_newlines(input) >= 3
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    /* Implementation details for splitting lines */
    seq![seq![]]
}

spec fn reverse_seq(s: Seq<char>) -> Seq<char> {
    s.reverse()
}

spec fn remove_first_x(s: Seq<char>) -> Seq<char> {
    /* Implementation details for removing first X */
    s
}

spec fn extract_and_normalize_puzzle1(input: Seq<char>) -> Seq<char> {
    if valid_input(input) {
        let lines = split_lines(input);
        if lines.len() >= 2 {
            let line1 = lines[0];
            let line2 = reverse_seq(lines[1]);
            let combined = line1.add(line2);
            remove_first_x(combined)
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn extract_and_normalize_puzzle2(input: Seq<char>) -> Seq<char> {
    if valid_input(input) {
        let lines = split_lines(input);
        if lines.len() >= 4 {
            let line3 = lines[2];
            let line4 = reverse_seq(lines[3]);
            let combined = line3.add(line4);
            remove_first_x(combined)
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn rotate_puzzle_left(puzzle: Seq<char>, rotation: int) -> Seq<char> {
    /* Implementation details for rotating puzzle */
    puzzle
}

spec fn can_reach_same_config(input: Seq<char>) -> bool {
    if valid_input(input) {
        exists|rotation: int| 0 <= rotation < 4 && 
            extract_and_normalize_puzzle1(input) == rotate_puzzle_left(extract_and_normalize_puzzle2(input), rotation)
    } else {
        false
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    ensures can_reach_same_config(input@) ==> result@ == seq!['Y', 'E', 'S']
    ensures !can_reach_same_config(input@) ==> result@ == seq!['N', 'O']
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn count_newlines(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == '\n' { 1int } else { 0int }) + count_newlines(s.subrange(1, s.len() as int))
    }
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.contains('\n') && count_newlines(input) >= 3
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    /* Implementation details for splitting lines */
    seq![seq![]]
}

spec fn reverse_seq(s: Seq<char>) -> Seq<char> {
    s.reverse()
}

spec fn remove_first_x(s: Seq<char>) -> Seq<char> {
    /* Implementation details for removing first X */
    s
}

spec fn extract_and_normalize_puzzle1(input: Seq<char>) -> Seq<char> {
    if valid_input(input) {
        let lines = split_lines(input);
        if lines.len() >= 2 {
            let line1 = lines[0];
            let line2 = reverse_seq(lines[1]);
            let combined = line1.add(line2);
            remove_first_x(combined)
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn extract_and_normalize_puzzle2(input: Seq<char>) -> Seq<char> {
    if valid_input(input) {
        let lines = split_lines(input);
        if lines.len() >= 4 {
            let line3 = lines[2];
            let line4 = reverse_seq(lines[3]);
            let combined = line3.add(line4);
            remove_first_x(combined)
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn rotate_puzzle_left(puzzle: Seq<char>, rotation: int) -> Seq<char> {
    /* Implementation details for rotating puzzle */
    puzzle
}

spec fn can_reach_same_config(input: Seq<char>) -> bool {
    if valid_input(input) {
        exists|rotation: int| 0 <= rotation < 4 && 
            extract_and_normalize_puzzle1(input) == rotate_puzzle_left(extract_and_normalize_puzzle2(input), rotation)
    } else {
        false
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: &str) -> (result: String)
    ensures can_reach_same_config(input@) ==> result@ == seq!['Y', 'E', 'S']
    ensures !can_reach_same_config(input@) ==> result@ == seq!['N', 'O']
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_95.rs,64,64,1.0,278.826,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, arr: Seq<int>) -> bool {
    n > 0 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1
}

spec fn is_unimodal(arr: Seq<int>) -> bool {
    if arr.len() <= 1 { 
        true 
    } else {
        let phases = compute_phases(arr);
        phases.0 <= phases.1 && phases.1 <= phases.2 && phases.2 == arr.len() &&
        (forall|i: int, j: int| 0 <= i < j < phases.0 ==> #[trigger] arr[i] < #[trigger] arr[j]) &&
        (forall|i: int| phases.0 <= i < phases.1 ==> #[trigger] arr[i] == (if phases.0 > 0 { arr[phases.0] } else { arr[0] })) &&
        (forall|i: int, j: int| phases.1 <= i < j < phases.2 ==> #[trigger] arr[i] > #[trigger] arr[j]) &&
        (phases.0 > 0 && phases.1 < arr.len() ==> arr[phases.0-1] >= (if phases.1 > phases.0 { arr[phases.0] } else { arr[phases.1] }))
    }
}

spec fn compute_phases(arr: Seq<int>) -> (int, int, int) {
    let inc_end = compute_increasing_end(arr, 0, 0);
    let const_end = compute_constant_end(arr, inc_end, if inc_end > 0 { arr[inc_end-1] } else { 0 });
    let dec_end = compute_decreasing_end(arr, const_end, if const_end > inc_end { arr[inc_end] } else if inc_end > 0 { arr[inc_end-1] } else { 0 });
    (inc_end, const_end, dec_end)
}

spec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {
    0
}

spec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {
    start
}

spec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {
    arr.len() as int
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: nat, arr: Seq<int>) -> (result: String)
    requires 
        valid_input(n, arr),
    ensures 
        result@ == ""YES""@ || result@ == ""NO""@,
        result@ == ""YES""@ <==> is_unimodal(arr),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO"".to_string()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, arr: Seq<int>) -> bool {
    n > 0 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1
}

spec fn is_unimodal(arr: Seq<int>) -> bool {
    if arr.len() <= 1 { 
        true 
    } else {
        let phases = compute_phases(arr);
        phases.0 <= phases.1 && phases.1 <= phases.2 && phases.2 == arr.len() &&
        (forall|i: int, j: int| 0 <= i < j < phases.0 ==> #[trigger] arr[i] < #[trigger] arr[j]) &&
        (forall|i: int| phases.0 <= i < phases.1 ==> #[trigger] arr[i] == (if phases.0 > 0 { arr[phases.0] } else { arr[0] })) &&
        (forall|i: int, j: int| phases.1 <= i < j < phases.2 ==> #[trigger] arr[i] > #[trigger] arr[j]) &&
        (phases.0 > 0 && phases.1 < arr.len() ==> arr[phases.0-1] >= (if phases.1 > phases.0 { arr[phases.0] } else { arr[phases.1] }))
    }
}

spec fn compute_phases(arr: Seq<int>) -> (int, int, int) {
    let inc_end = compute_increasing_end(arr, 0, 0);
    let const_end = compute_constant_end(arr, inc_end, if inc_end > 0 { arr[inc_end-1] } else { 0 });
    let dec_end = compute_decreasing_end(arr, const_end, if const_end > inc_end { arr[inc_end] } else if inc_end > 0 { arr[inc_end-1] } else { 0 });
    (inc_end, const_end, dec_end)
}

spec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {
    0
}

spec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {
    start
}

spec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {
    arr.len() as int
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(n: nat, arr: Seq<int>) -> (result: String)
    requires 
        valid_input(n, arr),
    ensures 
        result@ == ""YES""@ || result@ == ""NO""@,
        result@ == ""YES""@ <==> is_unimodal(arr),
// </vc-spec>
// <vc-code>
{
    assume(false);
    ""NO"".to_string()
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, arr: Seq<int>) -> bool {\n    n > 0 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn is_unimodal(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 { \n        true \n    } else {\n        let phases = compute_phases(arr);\n        phases.0 <= phases.1 && phases.1 <= phases.2 && phases.2 == arr.len() &&\n        (forall|i: int, j: int| 0 <= i < j < phases.0 ==> #[trigger] arr[i] < #[trigger] arr[j]) &&\n        (forall|i: int| phases.0 <= i < phases.1 ==> #[trigger] arr[i] == (if phases.0 > 0 { arr[phases.0] } else { arr[0] })) &&\n        (forall|i: int, j: int| phases.1 <= i < j < phases.2 ==> #[trigger] arr[i] > #[trigger] arr[j]) &&\n        (phases.0 > 0 && phases.1 < arr.len() ==> arr[phases.0-1] >= (if phases.1 > phases.0 { arr[phases.0] } else { arr[phases.1] }))\n    }\n}\n\nspec fn compute_phases(arr: Seq<int>) -> (int, int, int) {\n    let inc_end = compute_increasing_end(arr, 0, 0);\n    let const_end = compute_constant_end(arr, inc_end, if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    let dec_end = compute_decreasing_end(arr, const_end, if const_end > inc_end { arr[inc_end] } else if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    (inc_end, const_end, dec_end)\n}\n\nspec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    0\n}\n\nspec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {\n    start\n}\n\nspec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    arr.len() as int\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(n: nat, arr: Seq<int>) -> (result: String)\n    requires \n        valid_input(n, arr),\n    ensures \n        result@ == ""YES""@ || result@ == ""NO""@,\n        result@ == ""YES""@ <==> is_unimodal(arr),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    ""NO"".to_string()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus! {}\n        fn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_966.rs,54,54,1.0,,,0.7999999999999999,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(y: int) -> bool {
    1000 <= y <= 9000
}

spec fn has_distinct_digits(n: int) -> bool {
    let digits = number_to_digits(n);
    all_distinct(digits)
}

spec fn number_to_digits(n: int) -> Seq<int> {
    if n == 0 { seq![0] }
    else if n > 0 { number_to_digits_helper(n, seq![]) }
    else { number_to_digits_helper(-n, seq![]) }
}

spec fn number_to_digits_helper(n: int, acc: Seq<int>) -> Seq<int>
    decreases n when n >= 0
{
    if n == 0 { acc }
    else { number_to_digits_helper(n / 10, seq![n % 10].add(acc)) }
}

spec fn all_distinct(digits: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < digits.len() ==> digits[i] != digits[j]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(y: i8) -> (result: i8)
    requires valid_input(y as int)
    ensures 
        result as int > y as int,
        has_distinct_digits(result as int),
        forall|n: int| y as int < n && n < result as int ==> !has_distinct_digits(n)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(y: int) -> bool {
    1000 <= y <= 9000
}

spec fn has_distinct_digits(n: int) -> bool {
    let digits = number_to_digits(n);
    all_distinct(digits)
}

spec fn number_to_digits(n: int) -> Seq<int> {
    if n == 0 { seq![0] }
    else if n > 0 { number_to_digits_helper(n, seq![]) }
    else { number_to_digits_helper(-n, seq![]) }
}

spec fn number_to_digits_helper(n: int, acc: Seq<int>) -> Seq<int>
    decreases n when n >= 0
{
    if n == 0 { acc }
    else { number_to_digits_helper(n / 10, seq![n % 10].add(acc)) }
}

spec fn all_distinct(digits: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < digits.len() ==> digits[i] != digits[j]
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(y: i8) -> (result: i8)
    requires valid_input(y as int)
    ensures 
        result as int > y as int,
        has_distinct_digits(result as int),
        forall|n: int| y as int < n && n < result as int ==> !has_distinct_digits(n)
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_98.rs,71,71,1.0,221.255,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 3 &&
    {
        let board_parts = split_spaces_func(lines[0]);
        let paint1_parts = split_spaces_func(lines[1]);
        let paint2_parts = split_spaces_func(lines[2]);
        board_parts.len() >= 2 && paint1_parts.len() >= 2 && paint2_parts.len() >= 2 &&
        is_valid_int(board_parts[0]) && is_valid_int(board_parts[1]) &&
        is_valid_int(paint1_parts[0]) && is_valid_int(paint1_parts[1]) &&
        is_valid_int(paint2_parts[0]) && is_valid_int(paint2_parts[1])
    }
}

spec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {
    (c+e <= a && max(d,f) <= b) ||
    (c+e <= b && max(d,f) <= a) ||
    (c+f <= a && max(d,e) <= b) ||
    (c+f <= b && max(d,e) <= a) ||
    (d+e <= a && max(c,f) <= b) ||
    (d+e <= b && max(c,f) <= a) ||
    (d+f <= a && max(c,e) <= b) ||
    (d+f <= b && max(c,e) <= a)
}

spec fn max(x: int, y: int) -> int {
    if x >= y { x } else { y }
}

spec fn is_valid_int(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['a']; 3]
}

spec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1']; 2]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Vec<char>)
    requires input.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 3 &&
    {
        let board_parts = split_spaces_func(lines[0]);
        let paint1_parts = split_spaces_func(lines[1]);
        let paint2_parts = split_spaces_func(lines[2]);
        board_parts.len() >= 2 && paint1_parts.len() >= 2 && paint2_parts.len() >= 2 &&
        is_valid_int(board_parts[0]) && is_valid_int(board_parts[1]) &&
        is_valid_int(paint1_parts[0]) && is_valid_int(paint1_parts[1]) &&
        is_valid_int(paint2_parts[0]) && is_valid_int(paint2_parts[1])
    }
}

spec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {
    (c+e <= a && max(d,f) <= b) ||
    (c+e <= b && max(d,f) <= a) ||
    (c+f <= a && max(d,e) <= b) ||
    (c+f <= b && max(d,e) <= a) ||
    (d+e <= a && max(c,f) <= b) ||
    (d+e <= b && max(c,f) <= a) ||
    (d+f <= a && max(c,e) <= b) ||
    (d+f <= b && max(c,e) <= a)
}

spec fn max(x: int, y: int) -> int {
    if x >= y { x } else { y }
}

spec fn is_valid_int(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['a']; 3]
}

spec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1']; 2]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    1
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(input: Seq<char>) -> (result: Vec<char>)
    requires input.len() > 0
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let board_parts = split_spaces_func(lines[0]);\n        let paint1_parts = split_spaces_func(lines[1]);\n        let paint2_parts = split_spaces_func(lines[2]);\n        board_parts.len() >= 2 && paint1_parts.len() >= 2 && paint2_parts.len() >= 2 &&\n        is_valid_int(board_parts[0]) && is_valid_int(board_parts[1]) &&\n        is_valid_int(paint1_parts[0]) && is_valid_int(paint1_parts[1]) &&\n        is_valid_int(paint2_parts[0]) && is_valid_int(paint2_parts[1])\n    }\n}\n\nspec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    (c+e <= a && max(d,f) <= b) ||\n    (c+e <= b && max(d,f) <= a) ||\n    (c+f <= a && max(d,e) <= b) ||\n    (c+f <= b && max(d,e) <= a) ||\n    (d+e <= a && max(c,f) <= b) ||\n    (d+e <= b && max(c,f) <= a) ||\n    (d+f <= a && max(c,e) <= b) ||\n    (d+f <= b && max(c,e) <= a)\n}\n\nspec fn max(x: int, y: int) -> int {\n    if x >= y { x } else { y }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']; 3]\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1']; 2]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn solve(input: Seq<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        fn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/apps/issues/apps_test_992.rs,122,122,1.0,,,0.7,True,['vstd::prelude::'],False,other,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {
    n >= 1 && n <= 3000 &&
    s >= 1 && s <= 3000 &&
    a.len() == n &&
    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000
}

spec fn compute_subset_sum_ways(n: int, s: int, a: Seq<int>) -> int {
    let dp = compute_dp_table(n, s, a);
    if dp.len() > n && dp[n].len() > s { dp[n][s] } else { 0 }
}

spec fn compute_dp_table(n: int, s: int, a: Seq<int>) -> Seq<Seq<int>>
    decreases n
{
    if n == 1 {
        let base = Seq::new(s+1, |j: int| if j == 0 { 1 } else { 0 });
        let new_row = Seq::new(s+1, |j: int| {
            let doubled = (base[j] * 2) % 998244353;
            if j >= a[0] && j - a[0] >= 0 && j - a[0] < s+1 { 
                (doubled + base[j - a[0]]) % 998244353
            } else { 
                doubled
            }
        });
        seq![base, new_row]
    } else {
        let prev_dp = compute_dp_table(n-1, s, a.subrange(0, n-1));
        let new_row = Seq::new(s+1, |j: int| {
            let doubled = (prev_dp[n-1][j] * 2) % 998244353;
            if j >= a[n-1] && j - a[n-1] >= 0 && j - a[n-1] < s+1 {
                (doubled + prev_dp[n-1][j - a[n-1]]) % 998244353
            } else {
                doubled
            }
        });
        prev_dp.push(new_row)
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![], seq![]]
}

spec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']
}

spec fn valid_parsed_input(input: Seq<char>, n: int, s: int, a: Seq<int>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && {
        let first_line = split_whitespace(lines[0]);
        let second_line = split_whitespace(lines[1]);
        first_line.len() >= 2 && second_line.len() == n &&
        n == string_to_int(first_line[0]) &&
        s == string_to_int(first_line[1]) &&
        a.len() == n &&
        (forall|i: int| 0 <= i < n ==> (a[i] == string_to_int(second_line[i]))) &&
        valid_input(n, s, a)
    }
}

spec fn valid_parsed_input_exists(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() < 2 {
        false
    } else {
        let first_line = split_whitespace(lines[0]);
        let second_line = split_whitespace(lines[1]);
        if first_line.len() < 2 || second_line.len() == 0 {
            false
        } else {
            let n = string_to_int(first_line[0]);
            let s = string_to_int(first_line[1]);
            n >= 1 && n <= 3000 && s >= 1 && s <= 3000 && second_line.len() == n &&
            forall|i: int| 0 <= i < n ==> {
                let ai = string_to_int(second_line[i]);
                ai >= 1 && ai <= 3000
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input.len() > 0,
    ensures
        result.len() > 0,
    ensures
        result.as_bytes()[result.len()-1] == 10u8
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""0\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {
    n >= 1 && n <= 3000 &&
    s >= 1 && s <= 3000 &&
    a.len() == n &&
    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000
}

spec fn compute_subset_sum_ways(n: int, s: int, a: Seq<int>) -> int {
    let dp = compute_dp_table(n, s, a);
    if dp.len() > n && dp[n].len() > s { dp[n][s] } else { 0 }
}

spec fn compute_dp_table(n: int, s: int, a: Seq<int>) -> Seq<Seq<int>>
    decreases n
{
    if n == 1 {
        let base = Seq::new(s+1, |j: int| if j == 0 { 1 } else { 0 });
        let new_row = Seq::new(s+1, |j: int| {
            let doubled = (base[j] * 2) % 998244353;
            if j >= a[0] && j - a[0] >= 0 && j - a[0] < s+1 { 
                (doubled + base[j - a[0]]) % 998244353
            } else { 
                doubled
            }
        });
        seq![base, new_row]
    } else {
        let prev_dp = compute_dp_table(n-1, s, a.subrange(0, n-1));
        let new_row = Seq::new(s+1, |j: int| {
            let doubled = (prev_dp[n-1][j] * 2) % 998244353;
            if j >= a[n-1] && j - a[n-1] >= 0 && j - a[n-1] < s+1 {
                (doubled + prev_dp[n-1][j - a[n-1]]) % 998244353
            } else {
                doubled
            }
        });
        prev_dp.push(new_row)
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![], seq![]]
}

spec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']
}

spec fn valid_parsed_input(input: Seq<char>, n: int, s: int, a: Seq<int>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && {
        let first_line = split_whitespace(lines[0]);
        let second_line = split_whitespace(lines[1]);
        first_line.len() >= 2 && second_line.len() == n &&
        n == string_to_int(first_line[0]) &&
        s == string_to_int(first_line[1]) &&
        a.len() == n &&
        (forall|i: int| 0 <= i < n ==> (a[i] == string_to_int(second_line[i]))) &&
        valid_input(n, s, a)
    }
}

spec fn valid_parsed_input_exists(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() < 2 {
        false
    } else {
        let first_line = split_whitespace(lines[0]);
        let second_line = split_whitespace(lines[1]);
        if first_line.len() < 2 || second_line.len() == 0 {
            false
        } else {
            let n = string_to_int(first_line[0]);
            let s = string_to_int(first_line[1]);
            n >= 1 && n <= 3000 && s >= 1 && s <= 3000 && second_line.len() == n &&
            forall|i: int| 0 <= i < n ==> {
                let ai = string_to_int(second_line[i]);
                ai >= 1 && ai <= 3000
            }
        }
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input.len() > 0,
    ensures
        result.len() > 0,
    ensures
        result.as_bytes()[result.len()-1] == 10u8
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    ""0\n"".to_string()
    // impl-end
}
// </vc-code>


}

fn main() {}",[]
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_Add_NormalizeBitString.rs,53,53,1.0,220.234,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
    valid_bit_string(t),
    t.len() > 0,
    t.len() > 1 ==> t[0] != '0',
    valid_bit_string(s) ==> str2int(s) == str2int(t),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn add(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@),
  ensures 
    valid_bit_string(res@),
    str2int(res@) == str2int(s1@) + str2int(s2@),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
    valid_bit_string(t),
    t.len() > 0,
    t.len() > 1 ==> t[0] != '0',
    valid_bit_string(s) ==> str2int(s) == str2int(t),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn add(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@),
  ensures 
    valid_bit_string(res@),
    str2int(res@) == str2int(s1@) + str2int(s2@),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn add(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(s1@) && valid_bit_string(s2@),\n  ensures \n    valid_bit_string(res@),\n    str2int(res@) == str2int(s1@) + str2int(s2@),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        fn main() {}\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_Compare_CompareUnequal.rs,61,61,1.0,219.05,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + 
    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
    s1.len() > 0,
    s1.len() > 1 ==> s1[0] != '0',
    s2.len() > 0,
    s2.len() > 1 ==> s2[0] != '0',
    s1.len() > s2.len()
  ensures 
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
    str2int(s1@) < str2int(s2@) ==> res == -1,
    str2int(s1@) == str2int(s2@) ==> res == 0,
    str2int(s1@) > str2int(s2@) ==> res == 1
  decreases str2int(s1@) + str2int(s2@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + 
    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
    s1.len() > 0,
    s1.len() > 1 ==> s1[0] != '0',
    s2.len() > 0,
    s2.len() > 1 ==> s2[0] != '0',
    s1.len() > s2.len()
  ensures 
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
    str2int(s1@) < str2int(s2@) ==> res == -1,
    str2int(s1@) == str2int(s2@) ==> res == 0,
    str2int(s1@) > str2int(s2@) ==> res == 1
  decreases str2int(s1@) + str2int(s2@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + \n    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len()\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n    str2int(s1@) < str2int(s2@) ==> res == -1,\n    str2int(s1@) == str2int(s2@) ==> res == 0,\n    str2int(s1@) > str2int(s2@) ==> res == 1\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_Compare_CompareUnequal_NormalizeBitString.rs,68,68,1.0,184.191,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1 as int)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures
    valid_bit_string(t),
    t.len() > 0,
    t.len() > 1 ==> t[0] != '0',
    valid_bit_string(s) ==> str2int(s) == str2int(t),
{
  assume(false);
  unreached()
}

fn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires
    valid_bit_string(s1) && valid_bit_string(s2),
    s1.len() > 0,
    s1.len() > 1 ==> s1[0] != '0',
    s2.len() > 0,
    s2.len() > 1 ==> s2[0] != '0',
    s1.len() > s2.len(),
  ensures
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1,
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures
    str2int(s1@) < str2int(s2@) ==> res == -1,
    str2int(s1@) == str2int(s2@) ==> res == 0,
    str2int(s1@) > str2int(s2@) ==> res == 1,
  decreases str2int(s1@) + str2int(s2@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1 as int)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures
    valid_bit_string(t),
    t.len() > 0,
    t.len() > 1 ==> t[0] != '0',
    valid_bit_string(s) ==> str2int(s) == str2int(t),
{
  assume(false);
  unreached()
}

fn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires
    valid_bit_string(s1) && valid_bit_string(s2),
    s1.len() > 0,
    s1.len() > 1 ==> s1[0] != '0',
    s2.len() > 0,
    s2.len() > 1 ==> s2[0] != '0',
    s1.len() > s2.len(),
  ensures
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1,
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures
    str2int(s1@) < str2int(s2@) ==> res == -1,
    str2int(s1@) == str2int(s2@) ==> res == 0,
    str2int(s1@) > str2int(s2@) ==> res == 1,
  decreases str2int(s1@) + str2int(s2@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1 as int)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures\n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires\n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len(),\n  ensures\n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1,\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures\n    str2int(s1@) < str2int(s2@) ==> res == -1,\n    str2int(s1@) == str2int(s2@) ==> res == 0,\n    str2int(s1@) > str2int(s2@) ==> res == 1,\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_Compare_NormalizeBitString.rs,53,53,1.0,185.847,True,0.9999999999999999,True,['vstd::prelude::'],True,,,,,1.0,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 {
      0nat
  } else {
      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
      valid_bit_string(t) &&
      t.len() > 0 &&
      (t.len() > 1 ==> t[0] != '0') &&
      (valid_bit_string(s) ==> str2int(s) == str2int(t))
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i8)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
      (str2int(s1@) < str2int(s2@) ==> res as int == -1) &&
      (str2int(s1@) == str2int(s2@) ==> res as int == 0) &&
      (str2int(s1@) > str2int(s2@) ==> res as int == 1)
  decreases str2int(s1@) + str2int(s2@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 {
      0nat
  } else {
      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
      valid_bit_string(t) &&
      t.len() > 0 &&
      (t.len() > 1 ==> t[0] != '0') &&
      (valid_bit_string(s) ==> str2int(s) == str2int(t))
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i8)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
      (str2int(s1@) < str2int(s2@) ==> res as int == -1) &&
      (str2int(s1@) == str2int(s2@) ==> res as int == 0) &&
      (str2int(s1@) > str2int(s2@) ==> res as int == 1)
  decreases str2int(s1@) + str2int(s2@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n      0nat\n  } else {\n      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n      valid_bit_string(t) &&\n      t.len() > 0 &&\n      (t.len() > 1 ==> t[0] != '0') &&\n      (valid_bit_string(s) ==> str2int(s) == str2int(t))\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i8)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n      (str2int(s1@) < str2int(s2@) ==> res as int == -1) &&\n      (str2int(s1@) == str2int(s2@) ==> res as int == 0) &&\n      (str2int(s1@) > str2int(s2@) ==> res as int == 1)\n  decreases str2int(s1@) + str2int(s2@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_DivMod_Compare.rs,57,57,1.0,153.715,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1
  decreases str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))
  requires 
    valid_bit_string(dividend@) && valid_bit_string(divisor@),
    str2int(divisor@) > 0
  ensures 
    valid_bit_string(res.0@) && valid_bit_string(res.1@),
    str2int(res.0@) == str2int(dividend@) / str2int(divisor@),
    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1
  decreases str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))
  requires 
    valid_bit_string(dividend@) && valid_bit_string(divisor@),
    str2int(divisor@) > 0
  ensures 
    valid_bit_string(res.0@) && valid_bit_string(res.1@),
    str2int(res.0@) == str2int(dividend@) / str2int(divisor@),
    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n  decreases str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@),\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(res.0@) && valid_bit_string(res.1@),\n    str2int(res.0@) == str2int(dividend@) / str2int(divisor@),\n    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_DivMod_Compare_Sub.rs,66,66,1.0,153.815,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    recommends valid_bit_string(s)
    decreases s.len()
{
    if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
        str2int(s1) >= str2int(s2),
    ensures 
        valid_bit_string(res),
        str2int(res) == str2int(s1) - str2int(s2),
{
    assume(false);
    unreached()
}

fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
    requires valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        str2int(s1) < str2int(s2) ==> res == -1,
        str2int(s1) == str2int(s2) ==> res == 0,
        str2int(s1) > str2int(s2) ==> res == 1,
    decreases str2int(s1) + str2int(s2),
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))
    requires 
        valid_bit_string(dividend@) && valid_bit_string(divisor@),
        str2int(divisor@) > 0,
    ensures 
        valid_bit_string(res.0@) && valid_bit_string(res.1@),
        str2int(res.0@) == str2int(dividend@) / str2int(divisor@),
        str2int(res.1@) == str2int(dividend@) % str2int(divisor@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    recommends valid_bit_string(s)
    decreases s.len()
{
    if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
        str2int(s1) >= str2int(s2),
    ensures 
        valid_bit_string(res),
        str2int(res) == str2int(s1) - str2int(s2),
{
    assume(false);
    unreached()
}

fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
    requires valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        str2int(s1) < str2int(s2) ==> res == -1,
        str2int(s1) == str2int(s2) ==> res == 0,
        str2int(s1) > str2int(s2) ==> res == 1,
    decreases str2int(s1) + str2int(s2),
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))
    requires 
        valid_bit_string(dividend@) && valid_bit_string(divisor@),
        str2int(divisor@) > 0,
    ensures 
        valid_bit_string(res.0@) && valid_bit_string(res.1@),
        str2int(res.0@) == str2int(dividend@) / str2int(divisor@),
        str2int(res.1@) == str2int(dividend@) % str2int(divisor@),
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n        str2int(s1) >= str2int(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) - str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n    requires valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        str2int(s1) < str2int(s2) ==> res == -1,\n        str2int(s1) == str2int(s2) ==> res == 0,\n        str2int(s1) > str2int(s2) ==> res == 1,\n    decreases str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n    requires \n        valid_bit_string(dividend@) && valid_bit_string(divisor@),\n        str2int(divisor@) > 0,\n    ensures \n        valid_bit_string(res.0@) && valid_bit_string(res.1@),\n        str2int(res.0@) == str2int(dividend@) / str2int(divisor@),\n        str2int(res.1@) == str2int(dividend@) % str2int(divisor@),\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_DivMod_Sub.rs,53,53,1.0,154.594,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
    str2int(s1) >= str2int(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) - str2int(s2)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (result: (Vec<char>, Vec<char>))
  requires 
    valid_bit_string(dividend@) && valid_bit_string(divisor@),
    str2int(divisor@) > 0
  ensures 
    valid_bit_string(result.0@) && valid_bit_string(result.1@),
    str2int(result.0@) == str2int(dividend@) / str2int(divisor@),
    str2int(result.1@) == str2int(dividend@) % str2int(divisor@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
    str2int(s1) >= str2int(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) - str2int(s2)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (result: (Vec<char>, Vec<char>))
  requires 
    valid_bit_string(dividend@) && valid_bit_string(divisor@),
    str2int(divisor@) > 0
  ensures 
    valid_bit_string(result.0@) && valid_bit_string(result.1@),
    str2int(result.0@) == str2int(dividend@) / str2int(divisor@),
    str2int(result.1@) == str2int(dividend@) % str2int(divisor@)
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    str2int(s1) >= str2int(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) - str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (result: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@),\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(result.0@) && valid_bit_string(result.1@),\n    str2int(result.0@) == str2int(dividend@) / str2int(divisor@),\n    str2int(result.1@) == str2int(dividend@) % str2int(divisor@)\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2.rs,54,54,1.0,187.343,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy@.len() == n as int + 1,
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy@.len() == n as int + 1,
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy@.len() == n as int + 1,\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Add.rs,64,64,1.0,153.634,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + 
        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + 
        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Add_DivMod.rs,76,76,1.0,153.573,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1) &&
    str2int(res.0) == str2int(dividend) / str2int(divisor) &&
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
    sy@.len() == n as int + 1 &&
    str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases n
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1) &&
    str2int(res.0) == str2int(dividend) / str2int(divisor) &&
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
    sy@.len() == n as int + 1 &&
    str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases n
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n    sy@.len() == n as int + 1 &&\n    str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Add_DivMod_Mul.rs,91,91,1.0,153.722,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    recommends valid_bit_string(s)
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + 
        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2),
{
    assume(false);
    unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) &&
        str2int(divisor) > 0,
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1) &&
        str2int(res.0) == str2int(dividend) / str2int(divisor) &&
        str2int(res.1) == str2int(dividend) % str2int(divisor),
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2),
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    recommends valid_bit_string(s)
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + 
        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2),
{
    assume(false);
    unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) &&
        str2int(divisor) > 0,
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1) &&
        str2int(res.0) == str2int(dividend) / str2int(divisor) &&
        str2int(res.1) == str2int(dividend) % str2int(divisor),
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2),
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n,
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n,\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Add_Mul.rs,74,74,1.0,154.26,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n as nat
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n as nat
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires\n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures\n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n as nat\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_DivMod.rs,67,67,1.0,183.951,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0nat
    } else {
        if valid_bit_string(s) {
            2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
        } else {
            0nat
        }
    }
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0
    ensures 
        valid_bit_string(result.0) && valid_bit_string(result.1),
        str2int(result.0) == str2int(dividend) / str2int(divisor),
        str2int(result.1) == str2int(dividend) % str2int(divisor)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy.len() == n as int + 1,
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0nat
    } else {
        if valid_bit_string(s) {
            2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
        } else {
            0nat
        }
    }
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0
    ensures 
        valid_bit_string(result.0) && valid_bit_string(result.1),
        str2int(result.0) == str2int(dividend) / str2int(divisor),
        str2int(result.1) == str2int(dividend) % str2int(divisor)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy.len() == n as int + 1,
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        if valid_bit_string(s) {\n            2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n        } else {\n            0nat\n        }\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n    ensures \n        valid_bit_string(result.0) && valid_bit_string(result.1),\n        str2int(result.0) == str2int(dividend) / str2int(divisor),\n        str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy.len() == n as int + 1,\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_DivMod_Mul.rs,79,79,1.0,183.929,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if !valid_bit_string(s) {
        0nat
    } else if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor),
        str2int(divisor) > 0,
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1),
        str2int(res.0) == str2int(dividend) / str2int(divisor),
        str2int(res.1) == str2int(dividend) % str2int(divisor),
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res),
        str2int(res) == str2int(s1) * str2int(s2),
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy@.len() == n as int + 1,
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if !valid_bit_string(s) {
        0nat
    } else if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor),
        str2int(divisor) > 0,
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1),
        str2int(res.0) == str2int(dividend) / str2int(divisor),
        str2int(res.1) == str2int(dividend) % str2int(divisor),
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res),
        str2int(res) == str2int(s1) * str2int(s2),
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy@.len() == n as int + 1,
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if !valid_bit_string(s) {\n        0nat\n    } else if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor),\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1),\n        str2int(res.0) == str2int(dividend) / str2int(divisor),\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,\n        sy@.len() == n as int + 1,\n        str2int(sz@) > 1,\n    ensures \n        valid_bit_string(res@),\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_Mul.rs,63,63,1.0,183.996,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)\n    requires \n        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&\n        sy@.len() == n as int + 1 &&\n        str2int(sz@) > 1\n    ensures \n        valid_bit_string(res@) &&\n        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n    decreases n\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add.rs,57,57,1.0,184.278,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s.index(s.len() - 1) == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s.index(i) == '0' || s.index(i) == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy@.len(),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s.index(s.len() - 1) == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s.index(i) == '0' || s.index(i) == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy@.len(),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s.index(s.len() - 1) == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s.index(i) == '0' || s.index(i) == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n  decreases sy@.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod.rs,70,70,1.0,184.411,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2_int(divisor) > 0,
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1) &&
    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&
    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2_int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),
  decreases sy@.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2_int(divisor) > 0,
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1) &&
    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&
    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2_int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),
  decreases sy@.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2_int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_ModExpPow2.rs,88,88,1.0,184.049,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(s1) && valid_bit_string(s2)
  ensures
      valid_bit_string(res) &&
      str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires
      valid_bit_string(dividend) && valid_bit_string(divisor) &&
      str2int(divisor) > 0
  ensures
      valid_bit_string(result.0) && valid_bit_string(result.1) &&
      str2int(result.0) == str2int(dividend) / str2int(divisor) &&
      str2int(result.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
      sy.len() == n + 1 &&
      str2int(sz) > 1
  ensures
      valid_bit_string(res) &&
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
      sy.len() > 0 && str2int(sz) > 1
  ensures
      valid_bit_string(res) &&
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(s1) && valid_bit_string(s2)
  ensures
      valid_bit_string(res) &&
      str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires
      valid_bit_string(dividend) && valid_bit_string(divisor) &&
      str2int(divisor) > 0
  ensures
      valid_bit_string(result.0) && valid_bit_string(result.1) &&
      str2int(result.0) == str2int(dividend) / str2int(divisor) &&
      str2int(result.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
      sy.len() == n + 1 &&
      str2int(sz) > 1
  ensures
      valid_bit_string(res) &&
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
      sy.len() > 0 && str2int(sz) > 1
  ensures
      valid_bit_string(res) &&
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(s1) && valid_bit_string(s2)\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires\n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures\n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n      sy.len() == n + 1 &&\n      str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      sy.len() > 0 && str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_Mul.rs,81,81,1.0,154.105,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2int(divisor) > 0,
  ensures 
    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&
    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&
    str2int(ret.1) == str2int(dividend) % str2int(divisor),
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) * str2int(s2),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy@.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2int(divisor) > 0,
  ensures 
    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&
    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&
    str2int(ret.1) == str2int(dividend) % str2int(divisor),
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) * str2int(s2),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy@.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&\n    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(ret.1) == str2int(dividend) % str2int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_Mul_Zeroes.rs,97,97,1.0,153.757,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1),
    str2int(res.0) == str2int(dividend) / str2int(divisor),
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1),
    str2int(res.0) == str2int(dividend) / str2int(divisor),
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_Zeroes.rs,95,95,1.0,153.202,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    if valid_bit_string(s) {
      2 * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    } else {
      0nat
    }
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2_int(divisor) > 0,
  ensures 
    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&
    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&
    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n &&
    valid_bit_string(s) &&
    str2_int(s) == 0 &&
    all_zero(s),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
    sy.len() > 0 && str2_int(sz) > 1,
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),
  decreases sy.len(),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    if valid_bit_string(s) {
      2 * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    } else {
      0nat
    }
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2_int(divisor) > 0,
  ensures 
    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&
    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&
    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n &&
    valid_bit_string(s) &&
    str2_int(s) == 0 &&
    all_zero(s),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
    sy.len() > 0 && str2_int(sz) > 1,
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),
  decreases sy.len(),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    if valid_bit_string(s) {\n      2 * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    } else {\n      0nat\n    }\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&\n    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2_int(s) == 0 &&\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2_int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),\n  decreases sy.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_ModExpPow2.rs,78,78,1.0,185.564,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<u8>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == 49u8 { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<u8>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)
}

fn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
    sy.len() == n + 1 &&
    str2int(sz) > 1
  ensures 
    valid_bit_string(res) &&
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<u8>, sy: Vec<u8>, sz: Vec<u8>) -> (res: Vec<u8>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<u8>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == 49u8 { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<u8>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)
}

fn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
    sy.len() == n + 1 &&
    str2int(sz) > 1
  ensures 
    valid_bit_string(res) &&
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<u8>, sy: Vec<u8>, sz: Vec<u8>) -> (res: Vec<u8>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","['// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<u8>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == 49u8 { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<u8>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)\n}\n\nfn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n    sy.len() == n + 1 &&\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<u8>, sy: Vec<u8>, sz: Vec<u8>) -> (res: Vec<u8>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_ModExpPow2_Mul.rs,88,88,1.0,155.112,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
        sy.len() == n + 1 &&
        str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases n
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        sy.len() > 0 && str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases sy.len()
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
        sy.len() == n + 1 &&
        str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases n
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        sy.len() > 0 && str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases sy.len()
// </vc-spec>
// <vc-code>
{
    assume(false);
    unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.rs,105,105,1.0,183.69,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0nat { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0nat { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0nat { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_ModExpPow2_Zeroes.rs,95,95,1.0,185.087,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
      0nat 
  } else { 
      2nat * str2int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
      valid_bit_string(res),
      str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
      sy.len() == n + 1,
      str2int(sz) > 1,
  ensures 
      valid_bit_string(res),
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases n
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
      s.len() == n,
      valid_bit_string(s),
      str2int(s) == 0,
      all_zero(s),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
      sy.len() > 0 && str2int(sz) > 1,
  ensures 
      valid_bit_string(res),
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
      0nat 
  } else { 
      2nat * str2int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
      valid_bit_string(res),
      str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
      sy.len() == n + 1,
      str2int(sz) > 1,
  ensures 
      valid_bit_string(res),
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases n
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
      s.len() == n,
      valid_bit_string(s),
      str2int(s) == 0,
      all_zero(s),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
      sy.len() > 0 && str2int(sz) > 1,
  ensures 
      valid_bit_string(res),
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n      0nat \n  } else { \n      2nat * str2int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n      valid_bit_string(res),\n      str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n      sy.len() == n + 1,\n      str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n      s.len() == n,\n      valid_bit_string(s),\n      str2int(s) == 0,\n      all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      sy.len() > 0 && str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_Mul.rs,69,69,1.0,153.945,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) * str2_int(s2),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2_int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),
  decreases sy@.len(),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) * str2_int(s2),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2_int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),
  decreases sy@.len(),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) * str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2_int(sz@) > 1,\n  ensures \n    valid_bit_string(res@) &&\n    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),\n  decreases sy@.len(),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_Mul_Zeroes.rs,83,83,1.0,182.917,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n &&
    valid_bit_string(s) &&
    str2int(s) == 0 &&
    all_zero(s)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n &&
    valid_bit_string(s) &&
    str2int(s) == 0 &&
    all_zero(s)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2int(s) == 0 &&\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_ModExpPow2_Mul.rs,103,103,1.0,184.686,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1),
    str2int(res.0) == str2int(dividend) / str2int(divisor),
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1),
    str2int(res.0) == str2int(dividend) / str2int(divisor),
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()
// </vc-spec>
// <vc-code>
{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.rs,106,106,1.0,183.545,True,0.7,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) &&
        str2int(divisor) > 0
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1) &&
        str2int(res.0) == str2int(dividend) / str2int(divisor) &&
        str2int(res.1) == str2int(dividend) % str2int(divisor)
{
    assume(false);
    unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&
        sy.len() == n + 1 &&
        str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases n
{
    assume(false);
    unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
    ensures 
        s.len() == n &&
        valid_bit_string(s) &&
        str2int(s) == 0 &&
        all_zero(s)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        sy.len() > 0 && str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases sy.len()
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) &&
        str2int(divisor) > 0
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1) &&
        str2int(res.0) == str2int(dividend) / str2int(divisor) &&
        str2int(res.1) == str2int(dividend) % str2int(divisor)
{
    assume(false);
    unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&
        sy.len() == n + 1 &&
        str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases n
{
    assume(false);
    unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
    ensures 
        s.len() == n &&
        valid_bit_string(s) &&
        str2int(s) == 0 &&
        all_zero(s)
{
    assume(false);
    unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        sy.len() > 0 && str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases sy.len()
// </vc-spec>
// <vc-code>
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()\n// </vc-spec>\n// <vc-code>\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_Zeroes.rs,73,73,1.0,184.544,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s),
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),\n    sy@.len() > 0 && str2int(sz@) > 1,\n  ensures \n    valid_bit_string(res@),\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_DivMod.rs,59,59,1.0,223.057,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, (s.len() - 1) as int)) + (if s[(s.len() - 1) as int] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires 
      valid_bit_string(dividend) && valid_bit_string(divisor) &&
      str2int(divisor) > 0
  ensures 
      valid_bit_string(result.0) && valid_bit_string(result.1) &&
      str2int(result.0) == str2int(dividend) / str2int(divisor) &&
      str2int(result.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
      valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
      sy@.len() > 0 && str2int(sz@) > 1
  ensures 
      valid_bit_string(res@) &&
      str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy@.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","// <vc-preamble>
use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, (s.len() - 1) as int)) + (if s[(s.len() - 1) as int] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires 
      valid_bit_string(dividend) && valid_bit_string(divisor) &&
      str2int(divisor) > 0
  ensures 
      valid_bit_string(result.0) && valid_bit_string(result.1) &&
      str2int(result.0) == str2int(dividend) / str2int(divisor) &&
      str2int(result.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
      valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
      sy@.len() > 0 && str2int(sz@) > 1
  ensures 
      valid_bit_string(res@) &&
      str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy@.len()
// </vc-spec>
// <vc-code>
{
  assume(false);
  unreached()
}
// </vc-code>


}

fn main() {}","[""// <vc-preamble>\nuse vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, (s.len() - 1) as int)) + (if s[(s.len() - 1) as int] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures \n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n      valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n      sy@.len() > 0 && str2int(sz@) > 1\n  ensures \n      valid_bit_string(res@) &&\n      str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy@.len()\n// </vc-spec>\n// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>\n\n\n}\n\nfn main() {}"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        fn main() {}\n', 'use vstd::prelude::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/adts.rs,85,12,0.1411764705882353,456.36,True,0.7999999999999999,True,"['verus_builtin_macros::', 'vstd::prelude::']",True,,,,,,"use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::prelude::*;

verus! {

#[derive(Structural, PartialEq, Eq)]
struct Car<P> {
    four_doors: bool,
    passengers: P,
}

#[derive(Structural, PartialEq, Eq)]
enum Vehicle {
    Car(Car<u64>),
    Train(bool),
}

fn test_struct_1(p: u64) {
    let c1 = Car { four_doors: true, passengers: p };
    assert(c1.passengers == p);
    assert((Car { passengers: p, four_doors: true }).passengers == p);
}

fn test_structural_eq(passengers: u64) {
    let c1 = Car { passengers, four_doors: true };
    let c2 = Car { passengers, four_doors: false };
    let c3 = Car { passengers, four_doors: true };
    assert(c1 == c3);
    assert(c1 != c2);
    let t = Vehicle::Train(true);
    let ca = Vehicle::Car(c1);
    assert(t != ca);
}

#[derive(Structural, PartialEq, Eq)]
enum Vehicle2<T> {
    Car(Car<T>),
    Train(bool),
}

fn test_is_variant_1(v: Vehicle2<u64>) {
    match v {
        Vehicle2::Car(_) => assert(v is Car),
        Vehicle2::Train(_) => assert(v is Train),
    };
}

fn test_is_variant_2(v: Vehicle2<u64>)
    requires v matches Vehicle2::Train(true)
{
}

fn test_option(o: Option<u64>) -> (res: u64)
    ensures
        res == if o is Some {
            o->0
        } else {
            0
        },
{
    match o {
        Option::Some(v) => v,
        Option::None => 0,
    }
}

fn test_result<E>(r: Result<u64, E>) -> (res: u64)
    ensures
        res == if r is Ok {
            r->Ok_0
        } else {
            0
        },
{
    match r {
        Result::Ok(v) => v,
        Result::Err(_) => 0,
    }
}

fn main() {
}

} // verus!
"," use vstd::prelude::*;
                verus! {
              fn test_option(o: Option<u64>) -> (res: u64)     ensures         {
                match o {
                  Some(v) => v,         OptionNone => 0}
            }
              fn test_result<E>(r: Result<u64, E>) -> (res: u64)     ensures         {
                match r {
                  Ok(v) => v,         Err(_) => 0}
            }
              fn main() ;
              }
","['use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use vstd::prelude::*;\n                verus! {\n              fn test_option(o: Option<u64>) -> (res: u64)     ensures         {\n                match o {\n                  Some(v) => v,         OptionNone => 0}\n            }\n              fn test_result<E>(r: Result<u64, E>) -> (res: u64)     ensures         {\n                match r {\n                  Ok(v) => v,         Err(_) => 0}\n            }\n              fn main() ;\n              }\n', ' use vstd::prelude::*;\n                 verus! {               fn a(b: Option<u64>) ->  u64              {                 match b {                   Some(c) => c,         d => 0}             }               fn e<f>(r: Result<u64, f>) ->  u64              {                 match r {                   Ok(c) => c,         g => 0}             }               fn main() ;               }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/assert_by_compute.rs,453,453,1.0,187.436,True,0.85,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::prelude::']",True,,,,,,"// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests
#![recursion_limit = ""512""]
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::prelude::*;

verus! {

fn main() {
}

/// Different components of this file can be enabled/disabled quickly and easily using
/// `#[cfg(any())]` which simply turns off a module.
/// Any module with its `#[cfg(any())]` line commented out is valid to run.
//#[cfg(any())]
mod fib {
    use super::*;

    #[verifier::memoize]
    spec fn fib(x: nat) -> nat
        decreases x,
    {
        if x == 0 {
            0
        } else if x == 1 {
            1
        } else {
            fib((x - 1) as nat) + fib((x - 2) as nat)
        }
    }

    fn test() {
        //assert(fib(10) == 55);  // Fails without more fuel
        assert(fib(10) == 55) by (compute_only);
        assert(fib(100) == 354224848179261915075) by (compute_only);
        assert(fib(101) == 573147844013817084101) by (compute_only);
        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above
    }

}

//#[cfg(any())]
mod verititan_example {
    use super::*;

    // Naive definition of exponentiation
    spec fn pow(base: nat, exp: nat) -> nat
        decreases exp,
    {
        if exp == 0 {
            1
        } else {
            base * pow(base, (exp - 1) as nat)
        }
    }

    spec const Q: nat = 12289;

    spec const L: nat = 11;

    spec const G: nat = 7;

    fn compute_verititan() {
        // Fails, since Z3 doesn't have nearly enough fuel to calculate this
        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);
        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);
    }

}

//#[cfg(any())]
mod recursive_data_structures {
    use super::*;

    enum List<T> {
        Nil,
        Cons(T, Box<List<T>>),
    }

    spec fn len<T>(l: List<T>) -> nat
        decreases l,
    {
        match l {
            List::Nil => 0,
            List::Cons(_, tl) => 1 + len(*tl),
        }
    }

    spec fn append<T>(l: List<T>, x: T) -> List<T>
        decreases l,
    {
        match l {
            List::Nil => List::Cons(x, Box::new(List::Nil)),
            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),
        }
    }

    spec fn reverse<T>(l: List<T>) -> List<T>
        decreases l,
    {
        match l {
            List::Nil => List::Nil,
            List::Cons(hd, tl) => append(reverse(*tl), hd),
        }
    }

    spec fn ex1() -> List<nat> {
        List::Cons(
            1,
            Box::new(
                List::Cons(
                    2,
                    Box::new(
                        List::Cons(
                            3,
                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),
                        ),
                    ),
                ),
            ),
        )
    }

    spec fn ex1_rev() -> List<nat> {
        List::Cons(
            5,
            Box::new(
                List::Cons(
                    4,
                    Box::new(
                        List::Cons(
                            3,
                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),
                        ),
                    ),
                ),
            ),
        )
    }

    proof fn compute_list() {
        assert(len(ex1()) == 5) by (compute_only);
        assert(len(append(ex1(), 6)) == 6) by (compute_only);
        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);
    }

}

//#[cfg(any())]
mod sequences {
    use super::*;

    spec fn reverse<T>(s: Seq<T>) -> Seq<T>
        decreases s.len(),
    {
        if s.len() == 0 {
            Seq::empty()
        } else {
            reverse(s.subrange(1, s.len() as int)).push(s.index(0))
        }
    }

    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {
        assert(seq![a, b, c, d].len() == 4) by (compute_only);
        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);
        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);
        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);
        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);
    }

}

//#[cfg(any())]
mod veribetrkv_example_original {
    use super::*;

    // VeriBetrKV example original:
    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy
    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>
        decreases len,
    {
        if len == 0 {
            Seq::empty()
        } else {
            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))
        }
    }

    spec fn zeroes(l: nat) -> Seq<bool>
        decreases l,
    {
        if l == 0 {
            Seq::empty()
        } else {
            zeroes((l - 1) as nat).push(false)
        }
    }

    proof fn zeroes_len(l: nat)
        ensures
            zeroes(l).len() == l,
        decreases l,
    {
        if l == 0 {
        } else {
            zeroes_len((l - 1) as nat);
        }
    }

    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {
        zeroes(t).add(p)
    }

    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>
        recommends
            p.len() == q.len(),
        decreases p.len(),
    {
        if p.len() == 0 {
            Seq::empty()
        } else {
            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())
        }
    }

    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)
        requires
            p.len() == q.len(),
        ensures
            xor(p, q).len() == p.len(),
        decreases p.len(),
    {
        if p.len() == 0 {
            assert(xor(p, q).len() == p.len());
        } else {
            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));
        }
    }

    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>
        recommends
            q.len() > 0,
        decreases p.len(),
    {
        recommends_by(mod_F2_X_rec);
        if p.len() <= (q.len() - 1) as nat {
            p.add(zeroes((q.len() - 1 - p.len()) as nat))
        } else {
            if p.last() {
                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)
            } else {
                mod_F2_X(p.subrange(0, p.len() - 1), q)
            }
        }
    }

    #[verifier::recommends_by]
    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {
        if p.len() > (q.len() - 1) as nat {
            zeroes_len((p.len() - q.len()) as nat);
            xor_len(p, shift(q, (p.len() - q.len()) as nat));
        }
    }

    spec fn reverse(s: Seq<bool>) -> Seq<bool>
        decreases s.len(),
    {
        if s.len() == 0 {
            Seq::empty()
        } else {
            reverse(s.subrange(1, s.len() as int)).push(s.index(0))
        }
    }

    spec fn pow_mod_crc(n: nat) -> Seq<bool> {
        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))
    }

    // TODO: pops the stack if we use the full lut definition
    spec const lut: Seq<u64> =
        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];

    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,
    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,
    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,
    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,
    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,
    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,
    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,
    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,
    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,
    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,
    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,
    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,
    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,
    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,
    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,
    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,
    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,
    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,
    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,
    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,
    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,
    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,
    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,
    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,
    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,
    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,
    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,
    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,
    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,
    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,
    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,
    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,
    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,
    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,
    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,
    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,
    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,
    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,
    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,
    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,
    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,
    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,
    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,
    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,
    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,
    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,
    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,
    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,
    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,
    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,
    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,
    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,
    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,
    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,
    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,
    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,
    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,
    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,
    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,
    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,
    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,
    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,
    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,
    //    0x0];
    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))
    //    by(computation);
    spec const v: int = 1;

    fn crc_compute() {
        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(
            pow_mod_crc(64 * v as nat),
        )) by (compute);
    }

}

//#[cfg(any())]
mod veribetrkv_example_list_comprehension {
    use super::*;

    // VeriBetrKV example using sequence comprehension:
    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy
    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>
        decreases len,
    {
        if len == 0 {
            Seq::empty()
        } else {
            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))
        }
    }

    spec fn zeroes(l: nat) -> Seq<bool> {
        Seq::new(l, |i| false)
    }

    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {
        zeroes(t).add(p)
    }

    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {
        recommends(p.len() == q.len());
        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))
    }

    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>
        recommends
            q.len() > 0,
        decreases p.len(),
    {
        //recommends_by(mod_F2_X_rec);
        if p.len() <= (q.len() - 1) as nat {
            p.add(zeroes((q.len() - 1 - p.len()) as nat))
        } else {
            if p.last() {
                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)
            } else {
                mod_F2_X(p.subrange(0, p.len() - 1), q)
            }
        }
    }

    spec fn reverse(s: Seq<bool>) -> Seq<bool>
        decreases s.len(),
    {
        if s.len() == 0 {
            Seq::empty()
        } else {
            reverse(s.subrange(1, s.len() as int)).push(s.index(0))
        }
    }

    spec fn pow_mod_crc(n: nat) -> Seq<bool> {
        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))
    }

    // TODO: pops the stack if we use the full lut definition
    spec const lut: Seq<u64> =
        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];

    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))
    //    by(computation);
    spec const v: int = 1;

    fn crc_compute() {
        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(
            pow_mod_crc(64 * v as nat),
        )) by (compute_only);
    }

}

//#[cfg(any())]
mod arch_specific {
    use verus_builtin::SpecShl;

    proof fn test_shift() {
        assert((1usize << 20usize) != 0usize) by (compute_only);
        assert((1usize << 100usize) == 0usize) by (compute_only);
        // But this next assert should not work (at least without size_of usize set), because usize
        // could be either 32-bit or 64-bit.
        //
        // assert((1usize << 40usize) == 0usize) by (compute_only);
    }

}

} // verus!
","// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests
#![recursion_limit = ""512""]
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::prelude::*;

verus! {

fn main() {
}

/// Different components of this file can be enabled/disabled quickly and easily using
/// `#[cfg(any())]` which simply turns off a module.
/// Any module with its `#[cfg(any())]` line commented out is valid to run.
//#[cfg(any())]
mod fib {
    use super::*;

    #[verifier::memoize]
    spec fn fib(x: nat) -> nat
        decreases x,
    {
        if x == 0 {
            0
        } else if x == 1 {
            1
        } else {
            fib((x - 1) as nat) + fib((x - 2) as nat)
        }
    }

    fn test() {
        //assert(fib(10) == 55);  // Fails without more fuel
        assert(fib(10) == 55) by (compute_only);
        assert(fib(100) == 354224848179261915075) by (compute_only);
        assert(fib(101) == 573147844013817084101) by (compute_only);
        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above
    }

}

//#[cfg(any())]
mod verititan_example {
    use super::*;

    // Naive definition of exponentiation
    spec fn pow(base: nat, exp: nat) -> nat
        decreases exp,
    {
        if exp == 0 {
            1
        } else {
            base * pow(base, (exp - 1) as nat)
        }
    }

    spec const Q: nat = 12289;

    spec const L: nat = 11;

    spec const G: nat = 7;

    fn compute_verititan() {
        // Fails, since Z3 doesn't have nearly enough fuel to calculate this
        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);
        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);
    }

}

//#[cfg(any())]
mod recursive_data_structures {
    use super::*;

    enum List<T> {
        Nil,
        Cons(T, Box<List<T>>),
    }

    spec fn len<T>(l: List<T>) -> nat
        decreases l,
    {
        match l {
            List::Nil => 0,
            List::Cons(_, tl) => 1 + len(*tl),
        }
    }

    spec fn append<T>(l: List<T>, x: T) -> List<T>
        decreases l,
    {
        match l {
            List::Nil => List::Cons(x, Box::new(List::Nil)),
            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),
        }
    }

    spec fn reverse<T>(l: List<T>) -> List<T>
        decreases l,
    {
        match l {
            List::Nil => List::Nil,
            List::Cons(hd, tl) => append(reverse(*tl), hd),
        }
    }

    spec fn ex1() -> List<nat> {
        List::Cons(
            1,
            Box::new(
                List::Cons(
                    2,
                    Box::new(
                        List::Cons(
                            3,
                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),
                        ),
                    ),
                ),
            ),
        )
    }

    spec fn ex1_rev() -> List<nat> {
        List::Cons(
            5,
            Box::new(
                List::Cons(
                    4,
                    Box::new(
                        List::Cons(
                            3,
                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),
                        ),
                    ),
                ),
            ),
        )
    }

    proof fn compute_list() {
        assert(len(ex1()) == 5) by (compute_only);
        assert(len(append(ex1(), 6)) == 6) by (compute_only);
        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);
    }

}

//#[cfg(any())]
mod sequences {
    use super::*;

    spec fn reverse<T>(s: Seq<T>) -> Seq<T>
        decreases s.len(),
    {
        if s.len() == 0 {
            Seq::empty()
        } else {
            reverse(s.subrange(1, s.len() as int)).push(s.index(0))
        }
    }

    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {
        assert(seq![a, b, c, d].len() == 4) by (compute_only);
        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);
        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);
        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);
        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);
    }

}

//#[cfg(any())]
mod veribetrkv_example_original {
    use super::*;

    // VeriBetrKV example original:
    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy
    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>
        decreases len,
    {
        if len == 0 {
            Seq::empty()
        } else {
            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))
        }
    }

    spec fn zeroes(l: nat) -> Seq<bool>
        decreases l,
    {
        if l == 0 {
            Seq::empty()
        } else {
            zeroes((l - 1) as nat).push(false)
        }
    }

    proof fn zeroes_len(l: nat)
        ensures
            zeroes(l).len() == l,
        decreases l,
    {
        if l == 0 {
        } else {
            zeroes_len((l - 1) as nat);
        }
    }

    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {
        zeroes(t).add(p)
    }

    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>
        recommends
            p.len() == q.len(),
        decreases p.len(),
    {
        if p.len() == 0 {
            Seq::empty()
        } else {
            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())
        }
    }

    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)
        requires
            p.len() == q.len(),
        ensures
            xor(p, q).len() == p.len(),
        decreases p.len(),
    {
        if p.len() == 0 {
            assert(xor(p, q).len() == p.len());
        } else {
            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));
        }
    }

    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>
        recommends
            q.len() > 0,
        decreases p.len(),
    {
        recommends_by(mod_F2_X_rec);
        if p.len() <= (q.len() - 1) as nat {
            p.add(zeroes((q.len() - 1 - p.len()) as nat))
        } else {
            if p.last() {
                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)
            } else {
                mod_F2_X(p.subrange(0, p.len() - 1), q)
            }
        }
    }

    #[verifier::recommends_by]
    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {
        if p.len() > (q.len() - 1) as nat {
            zeroes_len((p.len() - q.len()) as nat);
            xor_len(p, shift(q, (p.len() - q.len()) as nat));
        }
    }

    spec fn reverse(s: Seq<bool>) -> Seq<bool>
        decreases s.len(),
    {
        if s.len() == 0 {
            Seq::empty()
        } else {
            reverse(s.subrange(1, s.len() as int)).push(s.index(0))
        }
    }

    spec fn pow_mod_crc(n: nat) -> Seq<bool> {
        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))
    }

    // TODO: pops the stack if we use the full lut definition
    spec const lut: Seq<u64> =
        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];

    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,
    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,
    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,
    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,
    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,
    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,
    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,
    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,
    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,
    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,
    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,
    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,
    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,
    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,
    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,
    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,
    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,
    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,
    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,
    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,
    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,
    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,
    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,
    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,
    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,
    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,
    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,
    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,
    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,
    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,
    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,
    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,
    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,
    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,
    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,
    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,
    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,
    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,
    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,
    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,
    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,
    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,
    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,
    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,
    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,
    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,
    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,
    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,
    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,
    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,
    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,
    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,
    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,
    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,
    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,
    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,
    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,
    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,
    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,
    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,
    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,
    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,
    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,
    //    0x0];
    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))
    //    by(computation);
    spec const v: int = 1;

    fn crc_compute() {
        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(
            pow_mod_crc(64 * v as nat),
        )) by (compute);
    }

}

//#[cfg(any())]
mod veribetrkv_example_list_comprehension {
    use super::*;

    // VeriBetrKV example using sequence comprehension:
    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy
    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>
        decreases len,
    {
        if len == 0 {
            Seq::empty()
        } else {
            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))
        }
    }

    spec fn zeroes(l: nat) -> Seq<bool> {
        Seq::new(l, |i| false)
    }

    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {
        zeroes(t).add(p)
    }

    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {
        recommends(p.len() == q.len());
        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))
    }

    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>
        recommends
            q.len() > 0,
        decreases p.len(),
    {
        //recommends_by(mod_F2_X_rec);
        if p.len() <= (q.len() - 1) as nat {
            p.add(zeroes((q.len() - 1 - p.len()) as nat))
        } else {
            if p.last() {
                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)
            } else {
                mod_F2_X(p.subrange(0, p.len() - 1), q)
            }
        }
    }

    spec fn reverse(s: Seq<bool>) -> Seq<bool>
        decreases s.len(),
    {
        if s.len() == 0 {
            Seq::empty()
        } else {
            reverse(s.subrange(1, s.len() as int)).push(s.index(0))
        }
    }

    spec fn pow_mod_crc(n: nat) -> Seq<bool> {
        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))
    }

    // TODO: pops the stack if we use the full lut definition
    spec const lut: Seq<u64> =
        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];

    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))
    //    by(computation);
    spec const v: int = 1;

    fn crc_compute() {
        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(
            pow_mod_crc(64 * v as nat),
        )) by (compute_only);
    }

}

//#[cfg(any())]
mod arch_specific {
    use verus_builtin::SpecShl;

    proof fn test_shift() {
        assert((1usize << 20usize) != 0usize) by (compute_only);
        assert((1usize << 100usize) == 0usize) by (compute_only);
        // But this next assert should not work (at least without size_of usize set), because usize
        // could be either 32-bit or 64-bit.
        //
        // assert((1usize << 40usize) == 0usize) by (compute_only);
    }

}

} // verus!
","['// rust_verify/tests/example.rs no-report-long-running --- Don\'t report long-running tests\n#![recursion_limit = ""512""]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn\'t have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use vstd::prelude::*;\n        verus! {\n       fn main() ;\n       }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/assorted_demo.rs,68,19,0.27941176470588236,641.701,True,0.7999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::*;

verus! {

fn main() {
    let x = 3;
    let y = 4;
    assert(x != y);
}

#[derive(Eq, PartialEq, Structural)]
struct Train {
    cars: u64,
}

fn main2() {
    let t = Train { cars: 10 };
    let q = Train { cars: 10 };
    assert(t == q);
}

spec fn mul(a: u64, b: u64) -> u64 {
    verus_builtin::mul(a, b)
}

spec fn divides(v: u64, d: u64) -> bool {
    exists|k: u64| mul(d, k) == v
}

#[verifier::external]
fn gcd_external(a: u64, b: u64) -> u64 {
    let mut i = a;
    while i >= 1 {
        if a % i == 0 && b % i == 0 {
            break ;
        }
        i -= 1;
    }
    i
}

#[verifier::external_body]
fn gcd(a: u64, b: u64) -> (result: u64)
    requires
        a >= 0,
        b >= 0,
    ensures
        divides(a, result),
        divides(b, result),
{
    gcd_external(a, b)
}

fn main3() {
    let x = 42;
    let y = 182;
    let z = gcd(x, y);
    assert(divides(x, z));
    assert(divides(y, z));
    // TODO assert(x % z == 0);
}

} // verus!
","use verus_builtin::*;
use verus_builtin_macros::*;
verus !{
  fn main();
  spec fn divides(v : u64, d : u64)->bool;
  fn gcd_external(a : u64, b : u64) -> u64 {
    let i = a;
    i
  }
#[verifier::external_body]
  fn gcd(a
         : u64, b
         : u64) -> (result
                    : u64)
    requires a >= 0,
  b >= 0, ensures divides(a, result), divides(b, result){
    gcd_external(a, b)
  }
}
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nfn main() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n#[derive(Eq, PartialEq, Structural)]\nstruct Train {\n    cars: u64,\n}\n\nfn main2() {\n    let t = Train { cars: 10 };\n    let q = Train { cars: 10 };\n    assert(t == q);\n}\n\nspec fn mul(a: u64, b: u64) -> u64 {\n    verus_builtin::mul(a, b)\n}\n\nspec fn divides(v: u64, d: u64) -> bool {\n    exists|k: u64| mul(d, k) == v\n}\n\n#[verifier::external]\nfn gcd_external(a: u64, b: u64) -> u64 {\n    let mut i = a;\n    while i >= 1 {\n        if a % i == 0 && b % i == 0 {\n            break ;\n        }\n        i -= 1;\n    }\n    i\n}\n\n#[verifier::external_body]\nfn gcd(a: u64, b: u64) -> (result: u64)\n    requires\n        a >= 0,\n        b >= 0,\n    ensures\n        divides(a, result),\n        divides(b, result),\n{\n    gcd_external(a, b)\n}\n\nfn main3() {\n    let x = 42;\n    let y = 182;\n    let z = gcd(x, y);\n    assert(divides(x, z));\n    assert(divides(y, z));\n    // TODO assert(x % z == 0);\n}\n\n} // verus!\n', 'use verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn c(e : u64, d : u64)->bool;\n#[verifier::external_body]\n  fn f(a : u64, b : u64) -> (g : u64)ensures c(a, g) { b }\n}\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn divides(v : u64, d : u64)->bool;\n  fn gcd_external(a : u64, b : u64) -> u64 {\n    let i = a;\n    i\n  }\n#[verifier::external_body]\n  fn gcd(a\n         : u64, b\n         : u64) -> (result\n                    : u64)\n    requires a >= 0,\n  b >= 0, ensures divides(a, result), divides(b, result){\n    gcd_external(a, b)\n  }\n}\n', 'use verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn divides(v : u64, d : u64)->bool;\n  fn gcd_external(a : u64, b : u64) -> u64 {\n    let i = a;\n    i\n  }\n#[verifier::external_body]\n  fn gcd(a\n         : u64, b\n         : u64) -> (result\n                    : u64)\n    requires ensures divides(a, result), {\n    gcd_external(a, b)\n  }\n}\n', 'use verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn c(e : u64, d : u64)->bool;\n  fn f(a : u64, b : u64) -> u64 {\n    let g = a;\n    g\n  }\n#[verifier::external_body]\n  fn gcd(a\n         : u64, b\n         : u64) -> (h\n                    : u64)\n     ensures c(a, h) {\n     b\n  }\n}\n', 'use verus_builtin_macros::*;\n     verus !{\n      fn main();\n      spec fn c(e : u64, d : u64)->bool;\n#[verifier::external_body]\n  fn gcd(a          : u64, b          : u64) -> (h                     : u64)      ensures c(a, h) {\n        b   }\n    }\n', 'use verus_builtin_macros::*;\nverus !{\n  fn main();\n  spec fn c(e : u64, d : u64)->bool;\n#[verifier::external_body]\n  fn gcd(a : u64, b : u64) -> (h : u64)ensures c(a, h) { b }\n}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/atomics.rs,139,139,1.0,153.158,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::atomic_ghost::', 'vstd::prelude::', 'vstd::']",True,,,,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::atomic_ghost::*;
use vstd::prelude::*;
use vstd::{pervasive::*, *};

verus! {

struct_with_invariants!{
    struct Lock<T> {
        field: AtomicBool<_, Option<T>, _>,
    }

    spec fn well_formed(&self) -> bool {
        invariant on field with () is (b: bool, t: Option<T>) {
            b === t is Some
        }
    }
}

fn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)
    requires
        lock.well_formed(),
{
    loop
        invariant
            lock.well_formed(),
    {
        let tracked ghost_value: Option<T>;
        let result =
            atomic_with_ghost!(
            &lock.field => compare_exchange(true, false);
            update prev -> next;
            ghost g => {
                if prev == true {
                    ghost_value = g;
                    g = Option::None;
                } else {
                    ghost_value = Option::None;
                }
            }
        );
        if let Result::Ok(_) = result {
            return Tracked(
                match ghost_value {
                    Option::Some(s) => s,
                    _ => { proof_from_false() },
                },
            );
        }
    }
}

struct VEqualG {}

impl AtomicInvariantPredicate<(), u64, u64> for VEqualG {
    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {
        v == g
    }
}

proof fn proof_int(x: u64) -> (tracked y: u64)
    ensures
        x == y,
{
    assume(false);
    proof_from_false()
}

pub fn main() {
    // TODO Tracked of int-literal is currently unsupported.
    // Should support it, or rewrite this example
    /*
    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));

    // illustration of atomic_with_ghost!

    atomic_with_ghost!(ato => fetch_or(19); ghost g => {
        g = proof_int(g | 19);
    });

    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {
        assert(new_val == old_val | 23);
        assert(g == old_val);

        g = proof_int(g | 23);

        assert(g == new_val);
    });

    let res = atomic_with_ghost!(
        ato => compare_exchange(20, 25);
        update old_val -> new_val;
        returning ret;
        ghost g
    => {
        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));
        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val
            && ret.get_Err_0() == old_val));

        g = if g == 20 { proof_int(25) } else { g };
    });

    let res = atomic_with_ghost!( ato => load();
        returning ret;
        ghost g
    => {
        assert(ret == g);
    });

    atomic_with_ghost!( ato => store(36);
        update old_val -> new_val;
        ghost g
    => {
        assert(old_val == g);
        assert(new_val == 36);
        g = proof_int(36);
    });

    atomic_with_ghost!( ato => store(36);
        update old_val -> new_val;
        ghost g
    => {
        assert(old_val == g);
        assert(new_val == 36);
        g = proof_int(36);
    });

    atomic_with_ghost!( ato => store(36);
        ghost g
    => {
        g = proof_int(36);
    });
    */
}

} // verus!
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::atomic_ghost::*;
use vstd::prelude::*;
use vstd::{pervasive::*, *};

verus! {

struct_with_invariants!{
    struct Lock<T> {
        field: AtomicBool<_, Option<T>, _>,
    }

    spec fn well_formed(&self) -> bool {
        invariant on field with () is (b: bool, t: Option<T>) {
            b === t is Some
        }
    }
}

fn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)
    requires
        lock.well_formed(),
{
    loop
        invariant
            lock.well_formed(),
    {
        let tracked ghost_value: Option<T>;
        let result =
            atomic_with_ghost!(
            &lock.field => compare_exchange(true, false);
            update prev -> next;
            ghost g => {
                if prev == true {
                    ghost_value = g;
                    g = Option::None;
                } else {
                    ghost_value = Option::None;
                }
            }
        );
        if let Result::Ok(_) = result {
            return Tracked(
                match ghost_value {
                    Option::Some(s) => s,
                    _ => { proof_from_false() },
                },
            );
        }
    }
}

struct VEqualG {}

impl AtomicInvariantPredicate<(), u64, u64> for VEqualG {
    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {
        v == g
    }
}

proof fn proof_int(x: u64) -> (tracked y: u64)
    ensures
        x == y,
{
    assume(false);
    proof_from_false()
}

pub fn main() {
    // TODO Tracked of int-literal is currently unsupported.
    // Should support it, or rewrite this example
    /*
    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));

    // illustration of atomic_with_ghost!

    atomic_with_ghost!(ato => fetch_or(19); ghost g => {
        g = proof_int(g | 19);
    });

    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {
        assert(new_val == old_val | 23);
        assert(g == old_val);

        g = proof_int(g | 23);

        assert(g == new_val);
    });

    let res = atomic_with_ghost!(
        ato => compare_exchange(20, 25);
        update old_val -> new_val;
        returning ret;
        ghost g
    => {
        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));
        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val
            && ret.get_Err_0() == old_val));

        g = if g == 20 { proof_int(25) } else { g };
    });

    let res = atomic_with_ghost!( ato => load();
        returning ret;
        ghost g
    => {
        assert(ret == g);
    });

    atomic_with_ghost!( ato => store(36);
        update old_val -> new_val;
        ghost g
    => {
        assert(old_val == g);
        assert(new_val == 36);
        g = proof_int(36);
    });

    atomic_with_ghost!( ato => store(36);
        update old_val -> new_val;
        ghost g
    => {
        assert(old_val == g);
        assert(new_val == 36);
        g = proof_int(36);
    });

    atomic_with_ghost!( ato => store(36);
        ghost g
    => {
        g = proof_int(36);
    });
    */
}

} // verus!
","['#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n        invariant on field with () is (b: bool, t: Option<T>) {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n    requires\n        lock.well_formed(),\n{\n    loop\n        invariant\n            lock.well_formed(),\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n        assert(new_val == old_val | 23);\n        assert(g == old_val);\n\n        g = proof_int(g | 23);\n\n        assert(g == new_val);\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));\n        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val\n            && ret.get_Err_0() == old_val));\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n        assert(ret == g);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/basic_lock1.rs,101,101,1.0,122.305,True,0.9,True,"['vstd::prelude::', 'vstd::atomic::', 'vstd::invariant::', 'vstd::cell', 'vstd::cell::', 'vstd::atomic', 'vstd::modes::']",True,,,True,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;
use vstd::atomic::*;
use vstd::invariant::*;
use vstd::cell;
use vstd::cell::*;
use vstd::atomic;
use vstd::modes::*;

verus!{

struct LockInv { }
impl<T> InvariantPredicate<(AtomicCellId, CellId), (atomic::PermissionBool, Option<cell::PointsTo<T>>)> for LockInv {
    open spec fn inv(
        cell_ids: (AtomicCellId, CellId),
        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),
    ) -> bool {
        ghost_stuff.0.id() == cell_ids.0
        && match ghost_stuff.1 {
            None => {
                // When there's no PointsTo, the lock must be taken, thus
                // the boolean value is 'true'.
                ghost_stuff.0.value() == true
            }
            Some(points_to) => {
                points_to.id() == cell_ids.1
                  && points_to.is_init()
                  && ghost_stuff.0.value() == false
            }
        }
    }
}

struct Lock<T> {
    pub atomic: PAtomicBool,
    pub cell: PCell<T>,
    pub inv: Tracked<AtomicInvariant<
        (AtomicCellId, CellId),
        (atomic::PermissionBool, Option<cell::PointsTo<T>>),
        LockInv
    >>,
}

impl<T> Lock<T> {
    spec fn wf(self) -> bool {
        self.inv@.constant() == (self.atomic.id(), self.cell.id())
    }

    fn new(t: T) -> (lock: Self)
        ensures lock.wf()
    {
        let (atomic, Tracked(atomic_perm)) = PAtomicBool::new(false);
        let (cell, Tracked(cell_perm)) = PCell::new(t);
        let tracked inv = AtomicInvariant::new(
            (atomic.id(), cell.id()),
            (atomic_perm, Some(cell_perm)),
            1337);
        Lock { atomic, cell, inv: Tracked(inv) }
    }

    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)
        requires self.wf(),
        ensures points_to@.id() == self.cell.id(), points_to@.is_init()
    {
        loop
            invariant self.wf(),
        {
            let tracked points_to_opt = None;
            let res;
            open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {
                let tracked (mut atomic_permission, mut points_to_inv) = ghost_stuff;
                res = self.atomic.compare_exchange(Tracked(&mut atomic_permission), false, true);
                proof {
                    tracked_swap(&mut points_to_opt, &mut points_to_inv);
                    ghost_stuff = (atomic_permission, points_to_inv);
                }
            });
            if res.is_ok() {
                return Tracked(points_to_opt.tracked_unwrap());
            }
        }
    }

    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)
        requires
            self.wf(),
            points_to@.id() == self.cell.id(), points_to@.is_init()
    {
        open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {
            let tracked (mut atomic_permission, _) = ghost_stuff;
            self.atomic.store(Tracked(&mut atomic_permission), false);
            proof {
                ghost_stuff = (atomic_permission, Some(points_to.get()));
            }
        });
    }
}

}

fn main() { }
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;
use vstd::atomic::*;
use vstd::invariant::*;
use vstd::cell;
use vstd::cell::*;
use vstd::atomic;
use vstd::modes::*;

verus!{

struct LockInv { }
impl<T> InvariantPredicate<(AtomicCellId, CellId), (atomic::PermissionBool, Option<cell::PointsTo<T>>)> for LockInv {
    open spec fn inv(
        cell_ids: (AtomicCellId, CellId),
        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),
    ) -> bool {
        ghost_stuff.0.id() == cell_ids.0
        && match ghost_stuff.1 {
            None => {
                // When there's no PointsTo, the lock must be taken, thus
                // the boolean value is 'true'.
                ghost_stuff.0.value() == true
            }
            Some(points_to) => {
                points_to.id() == cell_ids.1
                  && points_to.is_init()
                  && ghost_stuff.0.value() == false
            }
        }
    }
}

struct Lock<T> {
    pub atomic: PAtomicBool,
    pub cell: PCell<T>,
    pub inv: Tracked<AtomicInvariant<
        (AtomicCellId, CellId),
        (atomic::PermissionBool, Option<cell::PointsTo<T>>),
        LockInv
    >>,
}

impl<T> Lock<T> {
    spec fn wf(self) -> bool {
        self.inv@.constant() == (self.atomic.id(), self.cell.id())
    }

    fn new(t: T) -> (lock: Self)
        ensures lock.wf()
    {
        let (atomic, Tracked(atomic_perm)) = PAtomicBool::new(false);
        let (cell, Tracked(cell_perm)) = PCell::new(t);
        let tracked inv = AtomicInvariant::new(
            (atomic.id(), cell.id()),
            (atomic_perm, Some(cell_perm)),
            1337);
        Lock { atomic, cell, inv: Tracked(inv) }
    }

    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)
        requires self.wf(),
        ensures points_to@.id() == self.cell.id(), points_to@.is_init()
    {
        loop
            invariant self.wf(),
        {
            let tracked points_to_opt = None;
            let res;
            open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {
                let tracked (mut atomic_permission, mut points_to_inv) = ghost_stuff;
                res = self.atomic.compare_exchange(Tracked(&mut atomic_permission), false, true);
                proof {
                    tracked_swap(&mut points_to_opt, &mut points_to_inv);
                    ghost_stuff = (atomic_permission, points_to_inv);
                }
            });
            if res.is_ok() {
                return Tracked(points_to_opt.tracked_unwrap());
            }
        }
    }

    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)
        requires
            self.wf(),
            points_to@.id() == self.cell.id(), points_to@.is_init()
    {
        open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {
            let tracked (mut atomic_permission, _) = ghost_stuff;
            self.atomic.store(Tracked(&mut atomic_permission), false);
            proof {
                ghost_stuff = (atomic_permission, Some(points_to.get()));
            }
        });
    }
}

}

fn main() { }
","[""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic::*;\nuse vstd::invariant::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::atomic;\nuse vstd::modes::*;\n\nverus!{\n\nstruct LockInv { }\nimpl<T> InvariantPredicate<(AtomicCellId, CellId), (atomic::PermissionBool, Option<cell::PointsTo<T>>)> for LockInv {\n    open spec fn inv(\n        cell_ids: (AtomicCellId, CellId),\n        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n    ) -> bool {\n        ghost_stuff.0.id() == cell_ids.0\n        && match ghost_stuff.1 {\n            None => {\n                // When there's no PointsTo, the lock must be taken, thus\n                // the boolean value is 'true'.\n                ghost_stuff.0.value() == true\n            }\n            Some(points_to) => {\n                points_to.id() == cell_ids.1\n                  && points_to.is_init()\n                  && ghost_stuff.0.value() == false\n            }\n        }\n    }\n}\n\nstruct Lock<T> {\n    pub atomic: PAtomicBool,\n    pub cell: PCell<T>,\n    pub inv: Tracked<AtomicInvariant<\n        (AtomicCellId, CellId),\n        (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n        LockInv\n    >>,\n}\n\nimpl<T> Lock<T> {\n    spec fn wf(self) -> bool {\n        self.inv@.constant() == (self.atomic.id(), self.cell.id())\n    }\n\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (atomic, Tracked(atomic_perm)) = PAtomicBool::new(false);\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let tracked inv = AtomicInvariant::new(\n            (atomic.id(), cell.id()),\n            (atomic_perm, Some(cell_perm)),\n            1337);\n        Lock { atomic, cell, inv: Tracked(inv) }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked points_to_opt = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n                let tracked (mut atomic_permission, mut points_to_inv) = ghost_stuff;\n                res = self.atomic.compare_exchange(Tracked(&mut atomic_permission), false, true);\n                proof {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                    ghost_stuff = (atomic_permission, points_to_inv);\n                }\n            });\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n            let tracked (mut atomic_permission, _) = ghost_stuff;\n            self.atomic.store(Tracked(&mut atomic_permission), false);\n            proof {\n                ghost_stuff = (atomic_permission, Some(points_to.get()));\n            }\n        });\n    }\n}\n\n}\n\nfn main() { }\n"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/basic_lock2.rs,77,77,1.0,122.442,True,0.7999999999999999,True,"['vstd::prelude::', 'vstd::atomic_ghost::', 'vstd::cell', 'vstd::cell::', 'vstd::modes::']",True,,,,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;
use vstd::atomic_ghost::*;
use vstd::cell;
use vstd::cell::*;
use vstd::modes::*;

verus!{

struct_with_invariants!{
    struct Lock<T> {
        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,
        pub cell: PCell<T>,
    }

    spec fn wf(self) -> bool {
        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {
            match g {
                None => {
                    // When there's no PointsTo, the lock must be taken, thus
                    // the boolean value is 'true'.
                    v == true
                }
                Some(points_to) => {
                    points_to.id() == cell.id()
                      && points_to.is_init()
                      && v == false
                }
            }
        }
    }
}

impl<T> Lock<T> {
    fn new(t: T) -> (lock: Self)
        ensures lock.wf()
    {
        let (cell, Tracked(cell_perm)) = PCell::new(t);
        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));
        Lock { atomic, cell }
    }

    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)
        requires self.wf(),
        ensures points_to@.id() == self.cell.id(), points_to@.is_init()
    {
        loop
            invariant self.wf(),
        {
            let tracked mut points_to_opt = None;
            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);
                ghost points_to_inv => {
                    tracked_swap(&mut points_to_opt, &mut points_to_inv);
                }
            );
            if res.is_ok() {
                return Tracked(points_to_opt.tracked_unwrap());
            }
        }
    }

    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)
        requires
            self.wf(),
            points_to@.id() == self.cell.id(), points_to@.is_init()
    {
        atomic_with_ghost!(&self.atomic => store(false);
            ghost points_to_inv => {
                points_to_inv = Some(points_to.get());
            }
        );
    }
}

}

fn main() { }
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use vstd::prelude::*;
use vstd::atomic_ghost::*;
use vstd::cell;
use vstd::cell::*;
use vstd::modes::*;

verus!{

struct_with_invariants!{
    struct Lock<T> {
        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,
        pub cell: PCell<T>,
    }

    spec fn wf(self) -> bool {
        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {
            match g {
                None => {
                    // When there's no PointsTo, the lock must be taken, thus
                    // the boolean value is 'true'.
                    v == true
                }
                Some(points_to) => {
                    points_to.id() == cell.id()
                      && points_to.is_init()
                      && v == false
                }
            }
        }
    }
}

impl<T> Lock<T> {
    fn new(t: T) -> (lock: Self)
        ensures lock.wf()
    {
        let (cell, Tracked(cell_perm)) = PCell::new(t);
        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));
        Lock { atomic, cell }
    }

    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)
        requires self.wf(),
        ensures points_to@.id() == self.cell.id(), points_to@.is_init()
    {
        loop
            invariant self.wf(),
        {
            let tracked mut points_to_opt = None;
            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);
                ghost points_to_inv => {
                    tracked_swap(&mut points_to_opt, &mut points_to_inv);
                }
            );
            if res.is_ok() {
                return Tracked(points_to_opt.tracked_unwrap());
            }
        }
    }

    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)
        requires
            self.wf(),
            points_to@.id() == self.cell.id(), points_to@.is_init()
    {
        atomic_with_ghost!(&self.atomic => store(false);
            ghost points_to_inv => {
                points_to_inv = Some(points_to.get());
            }
        );
    }
}

}

fn main() { }
","[""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/bitmap.rs,175,175,1.0,123.642,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,True,,,"// rust_verify/tests/example.rs
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]

#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{prelude::*, seq_lib::*};

macro_rules! get_bit64_macro {
    ($a:expr, $b:expr) => {{
        (0x1u64 & ($a >> $b)) == 1
    }};
}

// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.
#[allow(unused_macros)]
macro_rules! get_bit64 {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))
    }
}

macro_rules! set_bit64_macro {
    ($a:expr,$b:expr, $c:expr) => {{
        if $c {
            $a | 1u64 << $b
        } else {
            $a & (!(1u64 << $b))
        }
    }};
}

// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.
#[allow(unused_macros)]
macro_rules! set_bit64 {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))
    }
}

verus! {

spec fn u64_view(u: u64) -> Seq<bool> {
    Seq::new(64, |i: int| get_bit64!(u, i as u64))
}

#[verifier::bit_vector]
proof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)
    requires
        bv_new == set_bit64!(bv_old, index, bit),
        index < 64,
    ensures
        get_bit64!(bv_new, index) == bit,
        forall|loc2: u64|
            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),
{
}

#[verifier::bit_vector]
proof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)
    requires
        bv_new == bv1 | bv2,
    ensures
        forall|i: u64|
            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),
{
}

proof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)
    requires
        bv_new == u1 | u2,
    ensures
        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),
{
    bit_or_64_proof(u1, u2, bv_new);
}

spec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {
    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))
}

pub struct BitMap {
    bits: Vec<u64>,
}

impl BitMap {
    spec fn view(&self) -> Seq<bool> {
        let width = self.bits@.len() * 64;
        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])
    }

    fn from(v: Vec<u64>) -> BitMap {
        BitMap { bits: v }
    }

    fn get_bit(&self, index: u32) -> (bit: bool)
        requires
            index < self@.len(),
        ensures
            bit == self@[index as int],
    {
        // REVIEW: at this moment, usize is assumed to be 32 or 64.
        // Therefore, if `index` is u64, verification fails due to the possibility of truncation
        // when we begin to consider `usize` smaller than 32, this might fail again.
        let seq_index: usize = (index / 64) as usize;
        let bit_index: u32 = index % 64;
        let bucket: u64 = self.bits[seq_index];
        get_bit64_macro!(bucket, bit_index as u64)
    }

    fn set_bit(&mut self, index: u32, bit: bool)
        requires
            index < old(self)@.len(),
        ensures
            self@ == old(self)@.update(index as int, bit),
    {
        // REVEIW: Same problem here with above regarding `usize`.
        let seq_index: usize = (index / 64) as usize;
        let bit_index: u32 = index % 64;
        let bv_old: u64 = self.bits[seq_index];
        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);
        proof {
            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);
        }
        ;
        self.bits.set(seq_index, bv_new);
        proof {
            assert_seqs_equal!(
                self.view(),
                old(self).view().update(index as int, bit)
            );
        }
        ;
    }

    // bitwise-OR for bitmap
    fn or(&self, bm: &BitMap) -> (ret: BitMap)
        requires
            self@.len() == bm@.len(),
        ensures
            self@.len() == ret@.len(),
            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),
    {
        let n: usize = self.bits.len();
        let mut i: usize = 0;
        let mut res_bits: Vec<u64> = Vec::new();
        let mut result = BitMap { bits: res_bits };
        while i < n
            invariant
                i <= n,
                n == self.bits@.len(),
                n == bm.bits@.len(),
                i == result.bits.len(),
                forall|k: int|
                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),
                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),
        {
            res_bits = result.bits;
            let u1: u64 = self.bits[i];
            let u2: u64 = bm.bits[i];
            let or_int: u64 = u1 | u2;
            proof {
                bit_or_64_view_proof(u1, u2, or_int);
            }
            res_bits.push(or_int);
            result = BitMap { bits: res_bits };
            i = i + 1;
        }
        result
    }
}

} // verus!
#[verifier::external]
fn main() {}
","// rust_verify/tests/example.rs
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]

#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{prelude::*, seq_lib::*};

macro_rules! get_bit64_macro {
    ($a:expr, $b:expr) => {{
        (0x1u64 & ($a >> $b)) == 1
    }};
}

// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.
#[allow(unused_macros)]
macro_rules! get_bit64 {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))
    }
}

macro_rules! set_bit64_macro {
    ($a:expr,$b:expr, $c:expr) => {{
        if $c {
            $a | 1u64 << $b
        } else {
            $a & (!(1u64 << $b))
        }
    }};
}

// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.
#[allow(unused_macros)]
macro_rules! set_bit64 {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))
    }
}

verus! {

spec fn u64_view(u: u64) -> Seq<bool> {
    Seq::new(64, |i: int| get_bit64!(u, i as u64))
}

#[verifier::bit_vector]
proof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)
    requires
        bv_new == set_bit64!(bv_old, index, bit),
        index < 64,
    ensures
        get_bit64!(bv_new, index) == bit,
        forall|loc2: u64|
            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),
{
}

#[verifier::bit_vector]
proof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)
    requires
        bv_new == bv1 | bv2,
    ensures
        forall|i: u64|
            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),
{
}

proof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)
    requires
        bv_new == u1 | u2,
    ensures
        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),
{
    bit_or_64_proof(u1, u2, bv_new);
}

spec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {
    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))
}

pub struct BitMap {
    bits: Vec<u64>,
}

impl BitMap {
    spec fn view(&self) -> Seq<bool> {
        let width = self.bits@.len() * 64;
        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])
    }

    fn from(v: Vec<u64>) -> BitMap {
        BitMap { bits: v }
    }

    fn get_bit(&self, index: u32) -> (bit: bool)
        requires
            index < self@.len(),
        ensures
            bit == self@[index as int],
    {
        // REVIEW: at this moment, usize is assumed to be 32 or 64.
        // Therefore, if `index` is u64, verification fails due to the possibility of truncation
        // when we begin to consider `usize` smaller than 32, this might fail again.
        let seq_index: usize = (index / 64) as usize;
        let bit_index: u32 = index % 64;
        let bucket: u64 = self.bits[seq_index];
        get_bit64_macro!(bucket, bit_index as u64)
    }

    fn set_bit(&mut self, index: u32, bit: bool)
        requires
            index < old(self)@.len(),
        ensures
            self@ == old(self)@.update(index as int, bit),
    {
        // REVEIW: Same problem here with above regarding `usize`.
        let seq_index: usize = (index / 64) as usize;
        let bit_index: u32 = index % 64;
        let bv_old: u64 = self.bits[seq_index];
        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);
        proof {
            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);
        }
        ;
        self.bits.set(seq_index, bv_new);
        proof {
            assert_seqs_equal!(
                self.view(),
                old(self).view().update(index as int, bit)
            );
        }
        ;
    }

    // bitwise-OR for bitmap
    fn or(&self, bm: &BitMap) -> (ret: BitMap)
        requires
            self@.len() == bm@.len(),
        ensures
            self@.len() == ret@.len(),
            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),
    {
        let n: usize = self.bits.len();
        let mut i: usize = 0;
        let mut res_bits: Vec<u64> = Vec::new();
        let mut result = BitMap { bits: res_bits };
        while i < n
            invariant
                i <= n,
                n == self.bits@.len(),
                n == bm.bits@.len(),
                i == result.bits.len(),
                forall|k: int|
                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),
                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),
        {
            res_bits = result.bits;
            let u1: u64 = self.bits[i];
            let u2: u64 = bm.bits[i];
            let or_int: u64 = u1 | u2;
            proof {
                bit_or_64_view_proof(u1, u2, or_int);
            }
            res_bits.push(or_int);
            result = BitMap { bits: res_bits };
            i = i + 1;
        }
        result
    }
}

} // verus!
#[verifier::external]
fn main() {}
","['// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n    requires\n        bv_new == set_bit64!(bv_old, index, bit),\n        index < 64,\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n    requires\n        bv_new == bv1 | bv2,\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n    requires\n        bv_new == u1 | u2,\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n        requires\n            index < self@.len(),\n        ensures\n            bit == self@[index as int],\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n        requires\n            index < old(self)@.len(),\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n        proof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n        ;\n        self.bits.set(seq_index, bv_new);\n        proof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n        requires\n            self@.len() == bm@.len(),\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n            invariant\n                i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n            proof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n', 'use vstd;\nfn main() {}\n', ' use vstd::{\n };\n          fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/bitvector_basic.rs,126,18,0.14285714285714285,187.107,True,0.9999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

// TODO: change this to a macro so that it can support u8, u16, u64, etc.
//
// Since &, |, ^, (bitwise)!, >>, << are uninterpreted functions for integers,
// we need basic properties(communtativity, associativity, etc) for these operators.
// We need to choose one of the below
// 1) Make exactly the same formula using bit-vector reasoning, OR
// 2) Make ""similar"" formula using bit-vector reasoning, and let the lemmas below do the rest.

verus! {

#[verifier::bit_vector]
proof fn bit_and32_auto()
    ensures
        forall|a: u32, b: u32| #[trigger] (a & b) == b & a,
        forall|a: u32, b: u32, c: u32| #[trigger] ((a & b) & c) == a & (b & c),
        forall|a: u32| #[trigger] (a & a) == a,
        forall|a: u32| #[trigger] (a & 0) == 0,
        forall|a: u32| #[trigger] (a & 0xffffffffu32) == a,
{
}

#[verifier::bit_vector]
proof fn bit_or32_auto()
    ensures
        forall|a: u32, b: u32| #[trigger] (a | b) == b | a,
        forall|a: u32, b: u32, c: u32| #[trigger] ((a | b) | c) == a | (b | c),
        forall|a: u32| #[trigger] (a | a) == a,
        forall|a: u32| #[trigger] (a | 0) == a,
        forall|a: u32| #[trigger] (a | 0xffff_ffffu32) == 0xffff_ffffu32,
{
}

#[verifier::bit_vector]
proof fn bit_xor32_auto()
    ensures
        forall|a: u32, b: u32| #[trigger] (a ^ b) == b ^ a,
        forall|a: u32, b: u32, c: u32| #[trigger] ((a ^ b) ^ c) == a ^ (b ^ c),
        forall|a: u32| #[trigger] (a ^ a) == 0,
        forall|a: u32| #[trigger] (a ^ 0) == a,
        forall|a: u32| #[trigger] (a ^ 0xffff_ffffu32) == !a,
{
}

#[verifier::bit_vector]
proof fn bit_not32_auto()
    ensures
        forall|a: u32| #[trigger] !(!a) == a,
        !0u32 == 0xffff_ffffu32,
{
}

#[verifier::bit_vector]
proof fn bit_lshr32_auto()
    ensures
        forall|a: u32| #[trigger] (a >> 0u32) == a,
{
}

#[verifier::bit_vector]
proof fn bit_shl32_auto()
    ensures
        forall|a: u32| #[trigger] (a << 0u32) == a,
{
}

#[verifier::bit_vector]
proof fn bit_property32_auto()
    ensures
// absorb

        forall|a: u32, b: u32| #[trigger] (a & (a | b)) == a,
        forall|a: u32, b: u32| #[trigger] (a | (a & b)) == a,
        // distributive
        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b | c)) == (a & b) | (a & c),
        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b ^ c)) == (a & b) ^ (a & c),
        forall|a: u32, b: u32, c: u32| #[trigger] (a | (b & c)) == (a | b) & (a | c),
        // De Morgan
        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,
        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,
{
}

proof fn test9(b1: u32, b2: u32, b3: u32) {
    bit_and32_auto();
    assert(b1 & 0xff < 0x100) by (bit_vector);
    assert(0xff & b1 < 0x100);
    let zero = 0u32;
    assert(zero & b3 == 0u32);
}

proof fn test10(a: u8, b: u8) {
    // We can write conditions about overflow in bit_vector assertion
    assert((a & b) == 0 ==> (a | b) == (a + b) && (a + b) < 256) by(bit_vector);
}

proof fn test11(x: u32, y: u32) {
    // XOR operation is independent of bitwidth so we don't need bit_vector solver to do this:
    assert((x as u64) ^ (y as u64) == (x ^ y) as u64);
}

proof fn test_usize(x: usize, y: usize, z: usize) {
    assert(((x & y) & z) == (x & (y & z))) by(bit_vector);
}

proof fn test_signed(x: i8, y: i8, z: i8, u: u8) {
    assert(!(x & y) == (!x | !y)) by(bit_vector);
    assert((!z) == (!(z as i32))) by(bit_vector);
    assert((z & (128u8 as i8)) != 0 <==> z < 0) by(bit_vector);

    // Compare signed vs unsigned
    assert(u > -1) by(bit_vector);
    assert(u > 128 ==> u > x) by(bit_vector);
}

proof fn prove_associativity(a: u8, b: i8, c: u8) {
    assert((a + b) + c == a + (b + c)) by(bit_vector);
}

} // verus!
#[verifier::external_body]
fn main() {}
","use verus_builtin::*;
  use verus_builtin_macros::*;
   verus! {
#[verifier::bit_vector]
proof fn bit_and32_auto()     ensures         forall|a: u32, b: u32|   
#[trigger] (a & b) == b & a,
        forall|a: u32|   
#[trigger] (a & 0) == 0,
{
 }
#[verifier::bit_vector]
proof fn bit_xor32_auto()     ensures         forall|a: u32, b: u32|   
#[trigger] (a ^ b) == b ^ a,
{
 }
  }
  fn main() {
 }
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n// TODO: change this to a macro so that it can support u8, u16, u64, etc.\n//\n// Since &, |, ^, (bitwise)!, >>, << are uninterpreted functions for integers,\n// we need basic properties(communtativity, associativity, etc) for these operators.\n// We need to choose one of the below\n// 1) Make exactly the same formula using bit-vector reasoning, OR\n// 2) Make ""similar"" formula using bit-vector reasoning, and let the lemmas below do the rest.\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn bit_and32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a & b) == b & a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a & b) & c) == a & (b & c),\n        forall|a: u32| #[trigger] (a & a) == a,\n        forall|a: u32| #[trigger] (a & 0) == 0,\n        forall|a: u32| #[trigger] (a & 0xffffffffu32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a | b) == b | a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a | b) | c) == a | (b | c),\n        forall|a: u32| #[trigger] (a | a) == a,\n        forall|a: u32| #[trigger] (a | 0) == a,\n        forall|a: u32| #[trigger] (a | 0xffff_ffffu32) == 0xffff_ffffu32,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_xor32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a ^ b) == b ^ a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a ^ b) ^ c) == a ^ (b ^ c),\n        forall|a: u32| #[trigger] (a ^ a) == 0,\n        forall|a: u32| #[trigger] (a ^ 0) == a,\n        forall|a: u32| #[trigger] (a ^ 0xffff_ffffu32) == !a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_not32_auto()\n    ensures\n        forall|a: u32| #[trigger] !(!a) == a,\n        !0u32 == 0xffff_ffffu32,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_lshr32_auto()\n    ensures\n        forall|a: u32| #[trigger] (a >> 0u32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_shl32_auto()\n    ensures\n        forall|a: u32| #[trigger] (a << 0u32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_property32_auto()\n    ensures\n// absorb\n\n        forall|a: u32, b: u32| #[trigger] (a & (a | b)) == a,\n        forall|a: u32, b: u32| #[trigger] (a | (a & b)) == a,\n        // distributive\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b | c)) == (a & b) | (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b ^ c)) == (a & b) ^ (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a | (b & c)) == (a | b) & (a | c),\n        // De Morgan\n        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,\n        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,\n{\n}\n\nproof fn test9(b1: u32, b2: u32, b3: u32) {\n    bit_and32_auto();\n    assert(b1 & 0xff < 0x100) by (bit_vector);\n    assert(0xff & b1 < 0x100);\n    let zero = 0u32;\n    assert(zero & b3 == 0u32);\n}\n\nproof fn test10(a: u8, b: u8) {\n    // We can write conditions about overflow in bit_vector assertion\n    assert((a & b) == 0 ==> (a | b) == (a + b) && (a + b) < 256) by(bit_vector);\n}\n\nproof fn test11(x: u32, y: u32) {\n    // XOR operation is independent of bitwidth so we don\'t need bit_vector solver to do this:\n    assert((x as u64) ^ (y as u64) == (x ^ y) as u64);\n}\n\nproof fn test_usize(x: usize, y: usize, z: usize) {\n    assert(((x & y) & z) == (x & (y & z))) by(bit_vector);\n}\n\nproof fn test_signed(x: i8, y: i8, z: i8, u: u8) {\n    assert(!(x & y) == (!x | !y)) by(bit_vector);\n    assert((!z) == (!(z as i32))) by(bit_vector);\n    assert((z & (128u8 as i8)) != 0 <==> z < 0) by(bit_vector);\n\n    // Compare signed vs unsigned\n    assert(u > -1) by(bit_vector);\n    assert(u > 128 ==> u > x) by(bit_vector);\n}\n\nproof fn prove_associativity(a: u8, b: i8, c: u8) {\n    assert((a + b) + c == a + (b + c)) by(bit_vector);\n}\n\n} // verus!\n#[verifier::external_body]\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n  use verus_builtin_macros::*;\n   verus! {\n#[verifier::bit_vector]\nproof fn bit_and32_auto()     ensures         forall|a: u32, b: u32|   \n#[trigger] (a & b) == b & a,\n        forall|a: u32|   \n#[trigger] (a & 0) == 0,\n{\n }\n#[verifier::bit_vector]\nproof fn bit_xor32_auto()     ensures         forall|a: u32, b: u32|   \n#[trigger] (a ^ b) == b ^ a,\n{\n }\n  }\n  fn main() {\n }\n', 'use verus_builtin::*;\n       use verus_builtin_macros::*;\n        verus! {}\n       fn main() {}\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/bitvector_equivalence.rs,173,173,1.0,154.999,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;

#[allow(unused_macros)]
macro_rules! get_bit_macro {
    ($a:expr, $b:expr) => {{
        (0x1u32 & ($a >> $b)) == 1
    }};
}

#[allow(unused_macros)]
macro_rules! get_bit {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(get_bit_macro!($($a)*))
    }
}
fn main() {}

// example from https://stackoverflow.com/questions/73145883/showing-equivalence-of-two-bitvectors

verus! {

// for the lower `n` bits, are `a` and `b` the same?
spec fn equal_lower_n_bits(a: u32, b: u32, n: u32) -> bool
    recommends
        n <= 32,
{
    a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1)  // a & (1<<n -1) == b & (1<<n -1)

}

// bitvector translation for `equivalence_proof_increment`
// in bit-vector mode, all spec functions should be unwrapped to definition (or use macro)
#[verifier::bit_vector]
proof fn equivalence_proof_increment_bv(a: u32, b: u32, n: u32)
    requires
        n < 32,
        a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1),  // equal_lower_n_bits(a,b,n)
        get_bit!(a, n) == get_bit!(b, n),
    ensures
        a & sub(1u32 << add(n, 1), 1) == b & sub(
            1u32 << add(n, 1),
            1,
        ),  // equal_lower_n_bits(a,b,n+1)
{
}

// when we know `a` and `b` have same lowewr `n` bits, and a[n] == b[n],
// we ensure that `a` and `b` have same lowewr `n+1` bits
// wrapper of `equivalence_proof_increment_bv` for the inductive proof below(`equivalence_proof_lower_n`)
proof fn equivalence_proof_increment(a: u32, b: u32, n: u32)
    requires
        n < 32,
        equal_lower_n_bits(a, b, n),
        get_bit!(a, n) == get_bit!(b, n),
    ensures
        equal_lower_n_bits(a, b, add(n, 1)),
{
    equivalence_proof_increment_bv(a, b, n);
}

// for the lower `n` bits, if each bit is the same,
// we ensure that `a` and `b` have same lower `n` bits
proof fn equivalence_proof_lower_n(a: u32, b: u32, n: u32)
    requires
        n <= 32,
        forall|i: u32| #![auto] (i < n ==> (get_bit!(a, i) == get_bit!(b, i))),
    ensures
        equal_lower_n_bits(a, b, n),
    decreases n,
{
    if n == 0 {
        assert(a & sub(1u32 << 0, 1) == b & sub(1u32 << 0, 1)) by (bit_vector);
        // assert(equal_lower_n_bits(a,b,0));
    } else {
        equivalence_proof_lower_n(a, b, sub(n, 1));  // lower `n-1` bits
        equivalence_proof_increment(a, b, sub(n, 1));  // the `n`-th bit
    }
}

proof fn equivalence_proof(a: u32, b: u32)
    requires
        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),
    ensures
        a == b,
{
    equivalence_proof_lower_n(a, b, 32);
    // at this point, we have `equal_lower_n_bits(a,b,32)`
    // now it is trivial to get `a==b`, however, we need additional call to conclude that a==b
    // this is because Verus does not reason about bitvectors unless it is explicitly specified.
    assert(a == b) by (bit_vector)
        requires
            a & sub(1u32 << 32, 1) == b & sub(1u32 << 32, 1),
    ;
}

// This fails because of trigger not being instantiated
// #[verifier::bit_vector]
// proof fn equivalence_proof_bv(a:u32, b:u32)
//     requires
//         forall|i: u32| #![auto]
//             i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),
//     ensures
//         a == b,
// {}
#[verifier::bit_vector]
proof fn equivalence_proof_bv(a: u32, b: u32)
    requires
        get_bit!(a, 0u32) == get_bit!(b, 0u32),
        get_bit!(a, 1u32) == get_bit!(b, 1u32),
        get_bit!(a, 2u32) == get_bit!(b, 2u32),
        get_bit!(a, 3u32) == get_bit!(b, 3u32),
        get_bit!(a, 4u32) == get_bit!(b, 4u32),
        get_bit!(a, 5u32) == get_bit!(b, 5u32),
        get_bit!(a, 6u32) == get_bit!(b, 6u32),
        get_bit!(a, 7u32) == get_bit!(b, 7u32),
        get_bit!(a, 8u32) == get_bit!(b, 8u32),
        get_bit!(a, 9u32) == get_bit!(b, 9u32),
        get_bit!(a, 10u32) == get_bit!(b, 10u32),
        get_bit!(a, 11u32) == get_bit!(b, 11u32),
        get_bit!(a, 12u32) == get_bit!(b, 12u32),
        get_bit!(a, 13u32) == get_bit!(b, 13u32),
        get_bit!(a, 14u32) == get_bit!(b, 14u32),
        get_bit!(a, 15u32) == get_bit!(b, 15u32),
        get_bit!(a, 16u32) == get_bit!(b, 16u32),
        get_bit!(a, 17u32) == get_bit!(b, 17u32),
        get_bit!(a, 18u32) == get_bit!(b, 18u32),
        get_bit!(a, 19u32) == get_bit!(b, 19u32),
        get_bit!(a, 20u32) == get_bit!(b, 20u32),
        get_bit!(a, 21u32) == get_bit!(b, 21u32),
        get_bit!(a, 22u32) == get_bit!(b, 22u32),
        get_bit!(a, 23u32) == get_bit!(b, 23u32),
        get_bit!(a, 24u32) == get_bit!(b, 24u32),
        get_bit!(a, 25u32) == get_bit!(b, 25u32),
        get_bit!(a, 26u32) == get_bit!(b, 26u32),
        get_bit!(a, 27u32) == get_bit!(b, 27u32),
        get_bit!(a, 28u32) == get_bit!(b, 28u32),
        get_bit!(a, 29u32) == get_bit!(b, 29u32),
        get_bit!(a, 30u32) == get_bit!(b, 30u32),
        get_bit!(a, 31u32) == get_bit!(b, 31u32),
    ensures
        a == b,
{
}

proof fn equivalence_proof_2(a: u32, b: u32)
    requires
        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),
    ensures
        a == b,
{
    equivalence_proof_bv(a, b);
}

// #[verifier::spec]
// fn u32_view(u: u32) -> Seq<bool> {
//     Seq::new(32, |i: int| get_bit!(u, i as u32))
// }
// proof fn equivalence_proof_3(a:u32, b:u32)
//     requires
//         u32_view(a) == u32_view(b),
//     ensures
//         a == b,
// {
//     assert(u32_view(a).index(0) == u32_view(b).index(0));
//     // assert(get_bit!(a, 0u32) == get_bit!(b, 0u32));
//     // assert(get_bit!(a, 1u32) == get_bit!(b, 1u32));
//     equivalence_proof_bv(a,b);
// }

} // verus!
","// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;

#[allow(unused_macros)]
macro_rules! get_bit_macro {
    ($a:expr, $b:expr) => {{
        (0x1u32 & ($a >> $b)) == 1
    }};
}

#[allow(unused_macros)]
macro_rules! get_bit {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(get_bit_macro!($($a)*))
    }
}
fn main() {}

// example from https://stackoverflow.com/questions/73145883/showing-equivalence-of-two-bitvectors

verus! {

// for the lower `n` bits, are `a` and `b` the same?
spec fn equal_lower_n_bits(a: u32, b: u32, n: u32) -> bool
    recommends
        n <= 32,
{
    a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1)  // a & (1<<n -1) == b & (1<<n -1)

}

// bitvector translation for `equivalence_proof_increment`
// in bit-vector mode, all spec functions should be unwrapped to definition (or use macro)
#[verifier::bit_vector]
proof fn equivalence_proof_increment_bv(a: u32, b: u32, n: u32)
    requires
        n < 32,
        a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1),  // equal_lower_n_bits(a,b,n)
        get_bit!(a, n) == get_bit!(b, n),
    ensures
        a & sub(1u32 << add(n, 1), 1) == b & sub(
            1u32 << add(n, 1),
            1,
        ),  // equal_lower_n_bits(a,b,n+1)
{
}

// when we know `a` and `b` have same lowewr `n` bits, and a[n] == b[n],
// we ensure that `a` and `b` have same lowewr `n+1` bits
// wrapper of `equivalence_proof_increment_bv` for the inductive proof below(`equivalence_proof_lower_n`)
proof fn equivalence_proof_increment(a: u32, b: u32, n: u32)
    requires
        n < 32,
        equal_lower_n_bits(a, b, n),
        get_bit!(a, n) == get_bit!(b, n),
    ensures
        equal_lower_n_bits(a, b, add(n, 1)),
{
    equivalence_proof_increment_bv(a, b, n);
}

// for the lower `n` bits, if each bit is the same,
// we ensure that `a` and `b` have same lower `n` bits
proof fn equivalence_proof_lower_n(a: u32, b: u32, n: u32)
    requires
        n <= 32,
        forall|i: u32| #![auto] (i < n ==> (get_bit!(a, i) == get_bit!(b, i))),
    ensures
        equal_lower_n_bits(a, b, n),
    decreases n,
{
    if n == 0 {
        assert(a & sub(1u32 << 0, 1) == b & sub(1u32 << 0, 1)) by (bit_vector);
        // assert(equal_lower_n_bits(a,b,0));
    } else {
        equivalence_proof_lower_n(a, b, sub(n, 1));  // lower `n-1` bits
        equivalence_proof_increment(a, b, sub(n, 1));  // the `n`-th bit
    }
}

proof fn equivalence_proof(a: u32, b: u32)
    requires
        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),
    ensures
        a == b,
{
    equivalence_proof_lower_n(a, b, 32);
    // at this point, we have `equal_lower_n_bits(a,b,32)`
    // now it is trivial to get `a==b`, however, we need additional call to conclude that a==b
    // this is because Verus does not reason about bitvectors unless it is explicitly specified.
    assert(a == b) by (bit_vector)
        requires
            a & sub(1u32 << 32, 1) == b & sub(1u32 << 32, 1),
    ;
}

// This fails because of trigger not being instantiated
// #[verifier::bit_vector]
// proof fn equivalence_proof_bv(a:u32, b:u32)
//     requires
//         forall|i: u32| #![auto]
//             i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),
//     ensures
//         a == b,
// {}
#[verifier::bit_vector]
proof fn equivalence_proof_bv(a: u32, b: u32)
    requires
        get_bit!(a, 0u32) == get_bit!(b, 0u32),
        get_bit!(a, 1u32) == get_bit!(b, 1u32),
        get_bit!(a, 2u32) == get_bit!(b, 2u32),
        get_bit!(a, 3u32) == get_bit!(b, 3u32),
        get_bit!(a, 4u32) == get_bit!(b, 4u32),
        get_bit!(a, 5u32) == get_bit!(b, 5u32),
        get_bit!(a, 6u32) == get_bit!(b, 6u32),
        get_bit!(a, 7u32) == get_bit!(b, 7u32),
        get_bit!(a, 8u32) == get_bit!(b, 8u32),
        get_bit!(a, 9u32) == get_bit!(b, 9u32),
        get_bit!(a, 10u32) == get_bit!(b, 10u32),
        get_bit!(a, 11u32) == get_bit!(b, 11u32),
        get_bit!(a, 12u32) == get_bit!(b, 12u32),
        get_bit!(a, 13u32) == get_bit!(b, 13u32),
        get_bit!(a, 14u32) == get_bit!(b, 14u32),
        get_bit!(a, 15u32) == get_bit!(b, 15u32),
        get_bit!(a, 16u32) == get_bit!(b, 16u32),
        get_bit!(a, 17u32) == get_bit!(b, 17u32),
        get_bit!(a, 18u32) == get_bit!(b, 18u32),
        get_bit!(a, 19u32) == get_bit!(b, 19u32),
        get_bit!(a, 20u32) == get_bit!(b, 20u32),
        get_bit!(a, 21u32) == get_bit!(b, 21u32),
        get_bit!(a, 22u32) == get_bit!(b, 22u32),
        get_bit!(a, 23u32) == get_bit!(b, 23u32),
        get_bit!(a, 24u32) == get_bit!(b, 24u32),
        get_bit!(a, 25u32) == get_bit!(b, 25u32),
        get_bit!(a, 26u32) == get_bit!(b, 26u32),
        get_bit!(a, 27u32) == get_bit!(b, 27u32),
        get_bit!(a, 28u32) == get_bit!(b, 28u32),
        get_bit!(a, 29u32) == get_bit!(b, 29u32),
        get_bit!(a, 30u32) == get_bit!(b, 30u32),
        get_bit!(a, 31u32) == get_bit!(b, 31u32),
    ensures
        a == b,
{
}

proof fn equivalence_proof_2(a: u32, b: u32)
    requires
        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),
    ensures
        a == b,
{
    equivalence_proof_bv(a, b);
}

// #[verifier::spec]
// fn u32_view(u: u32) -> Seq<bool> {
//     Seq::new(32, |i: int| get_bit!(u, i as u32))
// }
// proof fn equivalence_proof_3(a:u32, b:u32)
//     requires
//         u32_view(a) == u32_view(b),
//     ensures
//         a == b,
// {
//     assert(u32_view(a).index(0) == u32_view(b).index(0));
//     // assert(get_bit!(a, 0u32) == get_bit!(b, 0u32));
//     // assert(get_bit!(a, 1u32) == get_bit!(b, 1u32));
//     equivalence_proof_bv(a,b);
// }

} // verus!
","['// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\n// example from https://stackoverflow.com/questions/73145883/showing-equivalence-of-two-bitvectors\n\nverus! {\n\n// for the lower `n` bits, are `a` and `b` the same?\nspec fn equal_lower_n_bits(a: u32, b: u32, n: u32) -> bool\n    recommends\n        n <= 32,\n{\n    a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1)  // a & (1<<n -1) == b & (1<<n -1)\n\n}\n\n// bitvector translation for `equivalence_proof_increment`\n// in bit-vector mode, all spec functions should be unwrapped to definition (or use macro)\n#[verifier::bit_vector]\nproof fn equivalence_proof_increment_bv(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        a & sub(1u32 << n, 1) == b & sub(1u32 << n, 1),  // equal_lower_n_bits(a,b,n)\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        a & sub(1u32 << add(n, 1), 1) == b & sub(\n            1u32 << add(n, 1),\n            1,\n        ),  // equal_lower_n_bits(a,b,n+1)\n{\n}\n\n// when we know `a` and `b` have same lowewr `n` bits, and a[n] == b[n],\n// we ensure that `a` and `b` have same lowewr `n+1` bits\n// wrapper of `equivalence_proof_increment_bv` for the inductive proof below(`equivalence_proof_lower_n`)\nproof fn equivalence_proof_increment(a: u32, b: u32, n: u32)\n    requires\n        n < 32,\n        equal_lower_n_bits(a, b, n),\n        get_bit!(a, n) == get_bit!(b, n),\n    ensures\n        equal_lower_n_bits(a, b, add(n, 1)),\n{\n    equivalence_proof_increment_bv(a, b, n);\n}\n\n// for the lower `n` bits, if each bit is the same,\n// we ensure that `a` and `b` have same lower `n` bits\nproof fn equivalence_proof_lower_n(a: u32, b: u32, n: u32)\n    requires\n        n <= 32,\n        forall|i: u32| #![auto] (i < n ==> (get_bit!(a, i) == get_bit!(b, i))),\n    ensures\n        equal_lower_n_bits(a, b, n),\n    decreases n,\n{\n    if n == 0 {\n        assert(a & sub(1u32 << 0, 1) == b & sub(1u32 << 0, 1)) by (bit_vector);\n        // assert(equal_lower_n_bits(a,b,0));\n    } else {\n        equivalence_proof_lower_n(a, b, sub(n, 1));  // lower `n-1` bits\n        equivalence_proof_increment(a, b, sub(n, 1));  // the `n`-th bit\n    }\n}\n\nproof fn equivalence_proof(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n    equivalence_proof_lower_n(a, b, 32);\n    // at this point, we have `equal_lower_n_bits(a,b,32)`\n    // now it is trivial to get `a==b`, however, we need additional call to conclude that a==b\n    // this is because Verus does not reason about bitvectors unless it is explicitly specified.\n    assert(a == b) by (bit_vector)\n        requires\n            a & sub(1u32 << 32, 1) == b & sub(1u32 << 32, 1),\n    ;\n}\n\n// This fails because of trigger not being instantiated\n// #[verifier::bit_vector]\n// proof fn equivalence_proof_bv(a:u32, b:u32)\n//     requires\n//         forall|i: u32| #![auto]\n//             i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n//     ensures\n//         a == b,\n// {}\n#[verifier::bit_vector]\nproof fn equivalence_proof_bv(a: u32, b: u32)\n    requires\n        get_bit!(a, 0u32) == get_bit!(b, 0u32),\n        get_bit!(a, 1u32) == get_bit!(b, 1u32),\n        get_bit!(a, 2u32) == get_bit!(b, 2u32),\n        get_bit!(a, 3u32) == get_bit!(b, 3u32),\n        get_bit!(a, 4u32) == get_bit!(b, 4u32),\n        get_bit!(a, 5u32) == get_bit!(b, 5u32),\n        get_bit!(a, 6u32) == get_bit!(b, 6u32),\n        get_bit!(a, 7u32) == get_bit!(b, 7u32),\n        get_bit!(a, 8u32) == get_bit!(b, 8u32),\n        get_bit!(a, 9u32) == get_bit!(b, 9u32),\n        get_bit!(a, 10u32) == get_bit!(b, 10u32),\n        get_bit!(a, 11u32) == get_bit!(b, 11u32),\n        get_bit!(a, 12u32) == get_bit!(b, 12u32),\n        get_bit!(a, 13u32) == get_bit!(b, 13u32),\n        get_bit!(a, 14u32) == get_bit!(b, 14u32),\n        get_bit!(a, 15u32) == get_bit!(b, 15u32),\n        get_bit!(a, 16u32) == get_bit!(b, 16u32),\n        get_bit!(a, 17u32) == get_bit!(b, 17u32),\n        get_bit!(a, 18u32) == get_bit!(b, 18u32),\n        get_bit!(a, 19u32) == get_bit!(b, 19u32),\n        get_bit!(a, 20u32) == get_bit!(b, 20u32),\n        get_bit!(a, 21u32) == get_bit!(b, 21u32),\n        get_bit!(a, 22u32) == get_bit!(b, 22u32),\n        get_bit!(a, 23u32) == get_bit!(b, 23u32),\n        get_bit!(a, 24u32) == get_bit!(b, 24u32),\n        get_bit!(a, 25u32) == get_bit!(b, 25u32),\n        get_bit!(a, 26u32) == get_bit!(b, 26u32),\n        get_bit!(a, 27u32) == get_bit!(b, 27u32),\n        get_bit!(a, 28u32) == get_bit!(b, 28u32),\n        get_bit!(a, 29u32) == get_bit!(b, 29u32),\n        get_bit!(a, 30u32) == get_bit!(b, 30u32),\n        get_bit!(a, 31u32) == get_bit!(b, 31u32),\n    ensures\n        a == b,\n{\n}\n\nproof fn equivalence_proof_2(a: u32, b: u32)\n    requires\n        forall|i: u32| #![auto] i < 32 ==> (get_bit!(a, i) == get_bit!(b, i)),\n    ensures\n        a == b,\n{\n    equivalence_proof_bv(a, b);\n}\n\n// #[verifier::spec]\n// fn u32_view(u: u32) -> Seq<bool> {\n//     Seq::new(32, |i: int| get_bit!(u, i as u32))\n// }\n// proof fn equivalence_proof_3(a:u32, b:u32)\n//     requires\n//         u32_view(a) == u32_view(b),\n//     ensures\n//         a == b,\n// {\n//     assert(u32_view(a).index(0) == u32_view(b).index(0));\n//     // assert(get_bit!(a, 0u32) == get_bit!(b, 0u32));\n//     // assert(get_bit!(a, 1u32) == get_bit!(b, 1u32));\n//     equivalence_proof_bv(a,b);\n// }\n\n} // verus!\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n            fn main() {\n  }\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/bitvector_garbage_collection.rs,177,13,0.07344632768361582,185.083,True,0.6,True,['vstd::prelude::'],True,,,,,,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use vstd::prelude::*;

#[allow(unused_macros)]
macro_rules! get_bit_macro {
    ($a:expr, $b:expr) => {{
        (0x1u32 & ($a >> $b)) == 1
    }};
}

#[allow(unused_macros)]
macro_rules! get_bit {
    ($($a:tt)*) => {
        verus_proof_macro_exprs!(get_bit_macro!($($a)*))
    }
}
fn main() {}

verus! {

#[derive(Structural, PartialEq, Eq)]
enum Color {
    White,  // 11
    Gray,  // 10
    Black,  // 01
    Undefined,  // 00
}

spec fn color_view(high: bool, low: bool) -> Color {
    if high {
        if low {
            Color::White
        } else {
            Color::Gray
        }
    } else {
        if low {
            Color::Black
        } else {
            Color::Undefined
        }
    }
}

spec fn bucket_view(bucket: u32) -> Seq<Color> {
    Seq::new(
        16,
        |i: int|
            color_view(
                get_bit!(bucket, add(mul(i as u32, 2), 1)),
                get_bit!(bucket, mul(i as u32, 2)),
            ),
    )
}

#[verifier::bit_vector]
proof fn set_two_bit_proof(
    bv: u32,
    target: u32,
    mask: u32,
    result: u32,
    low_loc: u32,
    high: bool,
    low: bool,
)
    requires
        low_loc < 31,
        target == (if high {
            if low {
                3u32
            } else {
                2u32
            }
        } else {
            if low {
                1u32
            } else {
                0u32
            }
        }) << low_loc,
        mask == !(3u32 << low_loc),
        result == (bv & mask) | target,
    ensures
        get_bit!(result, low_loc) == low,
        get_bit!(result, add(low_loc, 1)) == high,
        forall|loc2: u32|
            #![auto]
            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(result, loc2)
                == get_bit!(bv, loc2),
{
}

fn set_two_bit_exec(bv: u32, low_loc: u32, high: bool, low: bool) -> (ret: u32)
    requires
        low_loc < 31,
    ensures
        get_bit!(ret, low_loc) == low,
        get_bit!(ret, add(low_loc, 1)) == high,
        forall|loc2: u32|
            #![auto]
            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(ret, loc2)
                == get_bit!(bv, loc2),
{
    let target: u32 = (if high {
        if low {
            3u32
        } else {
            2u32
        }
    } else {
        if low {
            1u32
        } else {
            0u32
        }
    }) << low_loc;
    let mask: u32 = !(3u32 << low_loc);
    let result: u32 = (bv & mask) | target;
    proof {
        set_two_bit_proof(bv, target, mask, result, low_loc, high, low);
    }
    result
}

fn set_color(bucket: u32, high: bool, low: bool, i: u32, ghost_bucket: Seq<Color>) -> (new_bucket:
    u32)
    requires
        i < 16,
        bucket_view(bucket) =~= ghost_bucket,
    ensures
        bucket_view(new_bucket) =~= ghost_bucket.update(i as int, color_view(high, low)),
{
    let new_bucket = set_two_bit_exec(bucket, 2 * i, high, low);
    assert(color_view(high, low) == color_view(
        get_bit!(new_bucket, add(mul(2, i), 1)),
        get_bit!(new_bucket, mul(2, i)),
    ));
    new_bucket
}

#[verifier::bit_vector]
proof fn get_color_proof(bv: u32, index: u32, v: u32)
    requires
        v == 3u32 & (bv >> mul(index, 2)),
    ensures
        v < 4u32,
        v == 3 ==> get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),
        v == 2 ==> !get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),
        v == 1 ==> get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),
        v == 0 ==> !get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),
{
}

fn get_color(bv: u32, index: u32) -> (c: Color)
    requires
        index < 15,
    ensures
        c == color_view(get_bit!(bv, add(mul(2, index), 1)), get_bit!(bv, mul(2, index))),
{
    let v: u32 = 3u32 & (bv >> index * 2);
    proof {
        get_color_proof(bv, index, v);
    }
    let c = if v == 0 {
        Color::Undefined
    } else if v == 1 {
        Color::Black
    } else if v == 2 {
        Color::Gray
    } else {
        Color::White
    };
    c
}

} // verus!
","use vstd::prelude::*;
       macro_rules! get_bit_macro {
           () => 
     {
             () == 1     }
     ;
       }
       macro_rules! get_bit {
           () => {
              verus_proof_macro_exprs!()     }
       }
        fn main() {}
        verus! {}
","['// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nenum Color {\n    White,  // 11\n    Gray,  // 10\n    Black,  // 01\n    Undefined,  // 00\n}\n\nspec fn color_view(high: bool, low: bool) -> Color {\n    if high {\n        if low {\n            Color::White\n        } else {\n            Color::Gray\n        }\n    } else {\n        if low {\n            Color::Black\n        } else {\n            Color::Undefined\n        }\n    }\n}\n\nspec fn bucket_view(bucket: u32) -> Seq<Color> {\n    Seq::new(\n        16,\n        |i: int|\n            color_view(\n                get_bit!(bucket, add(mul(i as u32, 2), 1)),\n                get_bit!(bucket, mul(i as u32, 2)),\n            ),\n    )\n}\n\n#[verifier::bit_vector]\nproof fn set_two_bit_proof(\n    bv: u32,\n    target: u32,\n    mask: u32,\n    result: u32,\n    low_loc: u32,\n    high: bool,\n    low: bool,\n)\n    requires\n        low_loc < 31,\n        target == (if high {\n            if low {\n                3u32\n            } else {\n                2u32\n            }\n        } else {\n            if low {\n                1u32\n            } else {\n                0u32\n            }\n        }) << low_loc,\n        mask == !(3u32 << low_loc),\n        result == (bv & mask) | target,\n    ensures\n        get_bit!(result, low_loc) == low,\n        get_bit!(result, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(result, loc2)\n                == get_bit!(bv, loc2),\n{\n}\n\nfn set_two_bit_exec(bv: u32, low_loc: u32, high: bool, low: bool) -> (ret: u32)\n    requires\n        low_loc < 31,\n    ensures\n        get_bit!(ret, low_loc) == low,\n        get_bit!(ret, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(ret, loc2)\n                == get_bit!(bv, loc2),\n{\n    let target: u32 = (if high {\n        if low {\n            3u32\n        } else {\n            2u32\n        }\n    } else {\n        if low {\n            1u32\n        } else {\n            0u32\n        }\n    }) << low_loc;\n    let mask: u32 = !(3u32 << low_loc);\n    let result: u32 = (bv & mask) | target;\n    proof {\n        set_two_bit_proof(bv, target, mask, result, low_loc, high, low);\n    }\n    result\n}\n\nfn set_color(bucket: u32, high: bool, low: bool, i: u32, ghost_bucket: Seq<Color>) -> (new_bucket:\n    u32)\n    requires\n        i < 16,\n        bucket_view(bucket) =~= ghost_bucket,\n    ensures\n        bucket_view(new_bucket) =~= ghost_bucket.update(i as int, color_view(high, low)),\n{\n    let new_bucket = set_two_bit_exec(bucket, 2 * i, high, low);\n    assert(color_view(high, low) == color_view(\n        get_bit!(new_bucket, add(mul(2, i), 1)),\n        get_bit!(new_bucket, mul(2, i)),\n    ));\n    new_bucket\n}\n\n#[verifier::bit_vector]\nproof fn get_color_proof(bv: u32, index: u32, v: u32)\n    requires\n        v == 3u32 & (bv >> mul(index, 2)),\n    ensures\n        v < 4u32,\n        v == 3 ==> get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 2 ==> !get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 1 ==> get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n        v == 0 ==> !get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n{\n}\n\nfn get_color(bv: u32, index: u32) -> (c: Color)\n    requires\n        index < 15,\n    ensures\n        c == color_view(get_bit!(bv, add(mul(2, index), 1)), get_bit!(bv, mul(2, index))),\n{\n    let v: u32 = 3u32 & (bv >> index * 2);\n    proof {\n        get_color_proof(bv, index, v);\n    }\n    let c = if v == 0 {\n        Color::Undefined\n    } else if v == 1 {\n        Color::Black\n    } else if v == 2 {\n        Color::Gray\n    } else {\n        Color::White\n    };\n    c\n}\n\n} // verus!\n', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n       macro_rules! get_bit_macro {\n           () => \n     {\n             () == 1     }\n     ;\n       }\n       macro_rules! get_bit {\n           () => {\n              verus_proof_macro_exprs!()     }\n       }\n        fn main() {}\n        verus! {}\n', 'use vstd::*;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/broadcast_proof.rs,190,190,1.0,0.656,False,0.9,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,3.0,"#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
#[allow(unused_imports)] use vstd::prelude::*;

verus! {
  mod lib {
    #[allow(unused_imports)] use super::*;

    pub proof fn mod_add_zero(a: int, b: int, c: int)
        // by (integer_ring)
        requires
            a % c == 0,
            b % c == 0,
        ensures
            (a + b) % c == 0,
    {
      admit();
    }
    
    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {
      if a1 == a2 {
        a1
      } else {
        arbitrary()
      }
    }
  }

  mod multiple_open {
    #[allow(unused_imports)] use super::*;

    pub struct Multiple {
      pub i: nat,
      pub modulo: nat,
    }
    
    impl Multiple {
      pub open spec fn aligned(&self) -> bool {
        &&& self.i % self.modulo == 0
      }
    
      pub open spec fn add(&self, v: nat) -> Self {
        Multiple { i: self.i + v, ..*self }
      }
    }
  }
  
  mod m1 {
    #[allow(unused_imports)] use super::*;

    use super::multiple_open::Multiple;
  
    proof fn lemma_increase_by_twice(
        p1: Multiple, v: nat, p2: Multiple)
      requires
        p1.modulo != 0, p1.aligned(),
        v % p1.modulo == 0,
        p1.modulo == p2.modulo,
        p2 == p1.add(v).add(v),
      ensures
        p2.aligned()
    {
      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)
      //   requires
      //     p1.i % p2.modulo == 0,
      //     v % p2.modulo == 0,
      //     p2.modulo != 0,
      // { }
      assert((p1.i + v + v) % p2.modulo == 0) by {
        super::lib::mod_add_zero(
          p1.i as int, v as int, p2.modulo as int);
        super::lib::mod_add_zero(
          p1.i as int + v as int, v as int, p2.modulo as int);
      }
    }
  }
  
  
  mod multiple_broadcast_proof {
    #[allow(unused_imports)] use super::*;

    pub struct Multiple {
      pub i: nat,
      pub modulo: nat,
    }
    
    impl Multiple {
      pub closed spec fn aligned(&self) -> bool {
        &&& self.modulo != 0
        &&& self.i % self.modulo == 0
      }

      pub closed spec fn add(&self, v: Self) -> Self {
        Multiple {
            i: self.i + v.i,
            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)
        }
      }

      pub closed spec fn mul(&self, v: Self) -> Self {
        Multiple {
            i: self.i * v.i,
            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)
        }
      }
      
      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)
        requires
          p.aligned(), v.aligned(), p.modulo == v.modulo,
        ensures
          (#[trigger] p.add(v)).aligned(),
          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),
      {
        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);
      }

      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)
        requires
          p.aligned(), v.aligned(), p.modulo == v.modulo,
        ensures
          (#[trigger] p.mul(v)).aligned(),
          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),
      {
        // TODO
        admit();
      }

      pub broadcast group group_properties {
        Multiple::lemma_add_aligned,
        Multiple::lemma_mul_aligned,
      }
    }
  }

  mod m2 {
    #[allow(unused_imports)] use super::*;
      
    use super::multiple_broadcast_proof::Multiple;
    
    broadcast use Multiple::lemma_add_aligned;

    proof fn increase_twice(
        p1: Multiple, v: Multiple, p2: Multiple)
      requires
        p1.aligned(), v.aligned(), p1.modulo == v.modulo,
        p2 == p1.add(v).add(v),
      ensures
        p2.aligned()
    {
    }

  }

  mod m3 {
    #[allow(unused_imports)] use super::*;
      
    use super::multiple_broadcast_proof::Multiple;
    

    proof fn increase_twice(
        p1: Multiple, v: Multiple, p2: Multiple)
      requires
        p1.aligned(), v.aligned(), p1.modulo == v.modulo,
        p2 == p1.add(v).add(v),
      ensures
        p2.aligned()
    {
    broadcast use Multiple::group_properties;
    }
    
    proof fn multiply_add(
        p1: Multiple, v: Multiple, p2: Multiple)
      requires
        p1.aligned(), v.aligned(), p1.modulo == v.modulo,
        p2 == p1.mul(v).add(v),
      ensures
        p2.aligned()
    {
    broadcast use Multiple::group_properties;
    }
    
    proof fn some_vstd_lemma()
    {
      let a = seq![1nat, 2, 3];
      assert(a[2] == 3);
    }
  }
  
} // verus!","#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
#[allow(unused_imports)] use vstd::prelude::*;

verus! {
  mod lib {
    #[allow(unused_imports)] use super::*;

    pub proof fn mod_add_zero(a: int, b: int, c: int)
        // by (integer_ring)
        requires
            a % c == 0,
            b % c == 0,
        ensures
            (a + b) % c == 0,
    {
      admit();
    }
    
    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {
      if a1 == a2 {
        a1
      } else {
        arbitrary()
      }
    }
  }

  mod multiple_open {
    #[allow(unused_imports)] use super::*;

    pub struct Multiple {
      pub i: nat,
      pub modulo: nat,
    }
    
    impl Multiple {
      pub open spec fn aligned(&self) -> bool {
        &&& self.i % self.modulo == 0
      }
    
      pub open spec fn add(&self, v: nat) -> Self {
        Multiple { i: self.i + v, ..*self }
      }
    }
  }
  
  mod m1 {
    #[allow(unused_imports)] use super::*;

    use super::multiple_open::Multiple;
  
    proof fn lemma_increase_by_twice(
        p1: Multiple, v: nat, p2: Multiple)
      requires
        p1.modulo != 0, p1.aligned(),
        v % p1.modulo == 0,
        p1.modulo == p2.modulo,
        p2 == p1.add(v).add(v),
      ensures
        p2.aligned()
    {
      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)
      //   requires
      //     p1.i % p2.modulo == 0,
      //     v % p2.modulo == 0,
      //     p2.modulo != 0,
      // { }
      assert((p1.i + v + v) % p2.modulo == 0) by {
        super::lib::mod_add_zero(
          p1.i as int, v as int, p2.modulo as int);
        super::lib::mod_add_zero(
          p1.i as int + v as int, v as int, p2.modulo as int);
      }
    }
  }
  
  
  mod multiple_broadcast_proof {
    #[allow(unused_imports)] use super::*;

    pub struct Multiple {
      pub i: nat,
      pub modulo: nat,
    }
    
    impl Multiple {
      pub closed spec fn aligned(&self) -> bool {
        &&& self.modulo != 0
        &&& self.i % self.modulo == 0
      }

      pub closed spec fn add(&self, v: Self) -> Self {
        Multiple {
            i: self.i + v.i,
            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)
        }
      }

      pub closed spec fn mul(&self, v: Self) -> Self {
        Multiple {
            i: self.i * v.i,
            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)
        }
      }
      
      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)
        requires
          p.aligned(), v.aligned(), p.modulo == v.modulo,
        ensures
          (#[trigger] p.add(v)).aligned(),
          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),
      {
        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);
      }

      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)
        requires
          p.aligned(), v.aligned(), p.modulo == v.modulo,
        ensures
          (#[trigger] p.mul(v)).aligned(),
          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),
      {
        // TODO
        admit();
      }

      pub broadcast group group_properties {
        Multiple::lemma_add_aligned,
        Multiple::lemma_mul_aligned,
      }
    }
  }

  mod m2 {
    #[allow(unused_imports)] use super::*;
      
    use super::multiple_broadcast_proof::Multiple;
    
    broadcast use Multiple::lemma_add_aligned;

    proof fn increase_twice(
        p1: Multiple, v: Multiple, p2: Multiple)
      requires
        p1.aligned(), v.aligned(), p1.modulo == v.modulo,
        p2 == p1.add(v).add(v),
      ensures
        p2.aligned()
    {
    }

  }

  mod m3 {
    #[allow(unused_imports)] use super::*;
      
    use super::multiple_broadcast_proof::Multiple;
    

    proof fn increase_twice(
        p1: Multiple, v: Multiple, p2: Multiple)
      requires
        p1.aligned(), v.aligned(), p1.modulo == v.modulo,
        p2 == p1.add(v).add(v),
      ensures
        p2.aligned()
    {
    broadcast use Multiple::group_properties;
    }
    
    proof fn multiply_add(
        p1: Multiple, v: Multiple, p2: Multiple)
      requires
        p1.aligned(), v.aligned(), p1.modulo == v.modulo,
        p2 == p1.mul(v).add(v),
      ensures
        p2.aligned()
    {
    broadcast use Multiple::group_properties;
    }
    
    proof fn some_vstd_lemma()
    {
      let a = seq![1nat, 2, 3];
      assert(a[2] == 3);
    }
  }
  
} // verus!",[]
/Users/ameliakuang/Repos/dep_verus/examples/calc.rs,50,50,1.0,153.154,True,0.8999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

#[allow(unused_imports)]
use vstd::{calc_macro::*, prelude, seq::*, seq_lib::*};

verus! {

fn main() {
}

proof fn calc_example_usage() {
    let a: Seq<u8> = seq![1u8, 2u8];
    let b: Seq<u8> = seq![1u8];
    let c: Seq<u8> = seq![2u8];
    let d: Seq<u8> = seq![1u8, 2u8];
    calc! {
        (==)
        a; (==) {
            assert_seqs_equal!(a == b + c);
        }
        b + c; {
            assert_seqs_equal!(b + c == d);
        }
        d;
    };
    calc! {
        (<=)
        (2 as int); (==) {}
        3 - 1; {}
        5;
    };
    calc! {
        (==>)
        (5 > 4); (==) {}
        (4 >= 4); (<==>) {}
        (2 > 1); (==>) {}
        (1 > 0); {}
        true;
    };
    calc! {
        (==>)
        false; {}
        true;
    };
}

} // verus!
","#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

#[allow(unused_imports)]
use vstd::{calc_macro::*, prelude, seq::*, seq_lib::*};

verus! {

fn main() {
}

proof fn calc_example_usage() {
    let a: Seq<u8> = seq![1u8, 2u8];
    let b: Seq<u8> = seq![1u8];
    let c: Seq<u8> = seq![2u8];
    let d: Seq<u8> = seq![1u8, 2u8];
    calc! {
        (==)
        a; (==) {
            assert_seqs_equal!(a == b + c);
        }
        b + c; {
            assert_seqs_equal!(b + c == d);
        }
        d;
    };
    calc! {
        (<=)
        (2 as int); (==) {}
        3 - 1; {}
        5;
    };
    calc! {
        (==>)
        (5 > 4); (==) {}
        (4 >= 4); (<==>) {}
        (2 > 1); (==>) {}
        (1 > 0); {}
        true;
    };
    calc! {
        (==>)
        false; {}
        true;
    };
}

} // verus!
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n#[allow(unused_imports)]\nuse vstd::{calc_macro::*, prelude, seq::*, seq_lib::*};\n\nverus! {\n\nfn main() {\n}\n\nproof fn calc_example_usage() {\n    let a: Seq<u8> = seq![1u8, 2u8];\n    let b: Seq<u8> = seq![1u8];\n    let c: Seq<u8> = seq![2u8];\n    let d: Seq<u8> = seq![1u8, 2u8];\n    calc! {\n        (==)\n        a; (==) {\n            assert_seqs_equal!(a == b + c);\n        }\n        b + c; {\n            assert_seqs_equal!(b + c == d);\n        }\n        d;\n    };\n    calc! {\n        (<=)\n        (2 as int); (==) {}\n        3 - 1; {}\n        5;\n    };\n    calc! {\n        (==>)\n        (5 > 4); (==) {}\n        (4 >= 4); (<==>) {}\n        (2 > 1); (==>) {}\n        (1 > 0); {}\n        true;\n    };\n    calc! {\n        (==>)\n        false; {}\n        true;\n    };\n}\n\n} // verus!\n', 'use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n', 'use verus_builtin_macros::*;\nuse vstd::{};\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/datatypes.rs,102,102,1.0,245.485,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,True,,,"#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{modes::*, prelude::*, seq::*, *};

verus! {

enum List<A> {
    Nil,
    Cons(A, Box<List<A>>),
}

spec fn len<A>(list: &List<A>) -> nat
    decreases list,
{
    match list {
        List::Nil => 0,
        List::Cons(_, tl) => 1 + len(tl),
    }
}

fn get_len<A>(list: &List<A>) -> (r: u64)
    requires
        len(list) <= 0xffffffffffffffff,
    ensures
        r == len(list),
{
    let mut n: u64 = 0;
    let mut iter = list;
    loop
        invariant
            len(list) <= 0xffffffffffffffff,
            n + len(iter) == len(list),
        ensures
            n == len(list),
        decreases len(iter),
    {
        match iter {
            List::Nil => {
                break;
            },
            List::Cons(_, tl) => {
                iter = tl;
                proof {
                    reveal_with_fuel(len, 2);
                }
                n = n + 1;
            },
        }
    }
    n
}

fn mk_range(start: u32, length: u32) -> (r: List<u32>)
    requires
        start + length <= 0xffff_ffff,
    ensures
        len::<u32>(&r) == length,
    decreases length,
{
    if length == 0 {
        List::Nil
    } else {
        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))
    }
}

fn main() {
    let x = List::Cons(100u64, Box::new(List::Nil));
    let i = match x {
        List::Nil => 1,
        List::Cons(n, _) if n < 10 => n + 2,
        List::Cons(n, _) if n < 100 => n + 3,
        List::Cons(n, _) if n < 200 => n + 4,
        List::Cons(n, _) => n + 5,
    };
    assert(i == 104);
    let mut j: u64 = 0;
    match x {
        List::Nil => {
            j = 1;
        },
        List::Cons(n, _) => {
            j = n;
        },
    }
    assert(j == 100);
    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {
        List::Nil => {
            j = 11;
            6
        },
        List::Cons(n, _) => {
            j = n + 1;
            7
        },
    };
    assert(j == 101);
    assert(k == 7);
}

} // verus!
","#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{modes::*, prelude::*, seq::*, *};

verus! {

enum List<A> {
    Nil,
    Cons(A, Box<List<A>>),
}

spec fn len<A>(list: &List<A>) -> nat
    decreases list,
{
    match list {
        List::Nil => 0,
        List::Cons(_, tl) => 1 + len(tl),
    }
}

fn get_len<A>(list: &List<A>) -> (r: u64)
    requires
        len(list) <= 0xffffffffffffffff,
    ensures
        r == len(list),
{
    let mut n: u64 = 0;
    let mut iter = list;
    loop
        invariant
            len(list) <= 0xffffffffffffffff,
            n + len(iter) == len(list),
        ensures
            n == len(list),
        decreases len(iter),
    {
        match iter {
            List::Nil => {
                break;
            },
            List::Cons(_, tl) => {
                iter = tl;
                proof {
                    reveal_with_fuel(len, 2);
                }
                n = n + 1;
            },
        }
    }
    n
}

fn mk_range(start: u32, length: u32) -> (r: List<u32>)
    requires
        start + length <= 0xffff_ffff,
    ensures
        len::<u32>(&r) == length,
    decreases length,
{
    if length == 0 {
        List::Nil
    } else {
        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))
    }
}

fn main() {
    let x = List::Cons(100u64, Box::new(List::Nil));
    let i = match x {
        List::Nil => 1,
        List::Cons(n, _) if n < 10 => n + 2,
        List::Cons(n, _) if n < 100 => n + 3,
        List::Cons(n, _) if n < 200 => n + 4,
        List::Cons(n, _) => n + 5,
    };
    assert(i == 104);
    let mut j: u64 = 0;
    match x {
        List::Nil => {
            j = 1;
        },
        List::Cons(n, _) => {
            j = n;
        },
    }
    assert(j == 100);
    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {
        List::Nil => {
            j = 11;
            6
        },
        List::Cons(n, _) => {
            j = n + 1;
            7
        },
    };
    assert(j == 101);
    assert(k == 7);
}

} // verus!
","['#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n        invariant\n            len(list) <= 0xffffffffffffffff,\n            n + len(iter) == len(list),\n        ensures\n            n == len(list),\n        decreases len(iter),\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n                proof {\n                    reveal_with_fuel(len, 2);\n                }\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n    assert(i == 104);\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n    assert(j == 100);\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n    assert(j == 101);\n    assert(k == 7);\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use vstd::{\n          modes::*, prelude::*, seq::*, *};\n             verus! {\n           fn main() ;\n           }\n', 'use vstd::{*, prelude::*, *, };\nverus !{ fn main(); }\n', 'use vstd:: prelude:: * ;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/debug.rs,80,80,1.0,,,0.9999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::']",False,other,True,,,,"// rust_verify/tests/example.rs expect-failures
use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

fn main() {
}

/*
fn test_params(i: int, n: nat, u: u8) {
    assert(n >= 5);
}

fn test_mutation(i: int, n: nat, u: u8) {
    let mut x = 5;
    x = x + i;
    x = x + n;
    x = x + u;
    assert(x >= 5);
}
*/

spec fn add_one(i: int) -> int {
    i + 1
}

fn very_simple(z: int) {
    let mut x = z;  // 1_mutation
    assert(add_one(x) < 3);
}

// fn test_if_else(b:bool, z:int) {
//     let mut x : int;
//     let mut y : int = z; // 0_entry
//     let mut f : int;
//     x = x + y;      // 1_mutation
//     if b {
//         x = 2*x;    // 2_mutation
//         y = x + 1;  // 3_mutation
//     } else {
//         let mut dd : int;
//         if b {
//             let mut ddd : int;
//             assert(true);
//             x = 2*x;    // 4_mutation
//             y = x + 1;  // 5_mutation
//         } // 6_join
//         x = y + 1;  // 7_mutation
//         y = 7;      // 8_mutation
//         f = 34;    // 9_mutation
//     } // 10_join
//     assert(x + y > 5);
// }
/*
fn test_loop() {
    let mut i: u64 = 10;
    let mut b1: u8 = 20;
    let mut b2: u8 = 200;
    let mut b3: u8 = 30;  // 0_entry
    i = i + 1;           // 1_mutation
    i = i - 1;           // 2_mutation

    while i < 100 {
        invariant([
            10 <= i,
            i <= 100,
            b1 as u64 == i * 2,
        ]);
                      // 3_while_begin
        assert(b1 == 5);
        i = i + 1;    // 4_mutation
        b1 = b1 + 2;  // 5_mutation
        b2 = b2 + 1;  // 6_mutation
    } // 5_while_end

    assert(true);   // 7_while_end
}
*/
} // verus!
","// rust_verify/tests/example.rs expect-failures
use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

fn main() {
}

/*
fn test_params(i: int, n: nat, u: u8) {
    assert(n >= 5);
}

fn test_mutation(i: int, n: nat, u: u8) {
    let mut x = 5;
    x = x + i;
    x = x + n;
    x = x + u;
    assert(x >= 5);
}
*/

spec fn add_one(i: int) -> int {
    i + 1
}

fn very_simple(z: int) {
    let mut x = z;  // 1_mutation
    assert(add_one(x) < 3);
}

// fn test_if_else(b:bool, z:int) {
//     let mut x : int;
//     let mut y : int = z; // 0_entry
//     let mut f : int;
//     x = x + y;      // 1_mutation
//     if b {
//         x = 2*x;    // 2_mutation
//         y = x + 1;  // 3_mutation
//     } else {
//         let mut dd : int;
//         if b {
//             let mut ddd : int;
//             assert(true);
//             x = 2*x;    // 4_mutation
//             y = x + 1;  // 5_mutation
//         } // 6_join
//         x = y + 1;  // 7_mutation
//         y = 7;      // 8_mutation
//         f = 34;    // 9_mutation
//     } // 10_join
//     assert(x + y > 5);
// }
/*
fn test_loop() {
    let mut i: u64 = 10;
    let mut b1: u8 = 20;
    let mut b2: u8 = 200;
    let mut b3: u8 = 30;  // 0_entry
    i = i + 1;           // 1_mutation
    i = i - 1;           // 2_mutation

    while i < 100 {
        invariant([
            10 <= i,
            i <= 100,
            b1 as u64 == i * 2,
        ]);
                      // 3_while_begin
        assert(b1 == 5);
        i = i + 1;    // 4_mutation
        b1 = b1 + 2;  // 5_mutation
        b2 = b2 + 1;  // 6_mutation
    } // 5_while_end

    assert(true);   // 7_while_end
}
*/
} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/debug_expand.rs,318,318,1.0,,,0.85,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::prelude::']",False,precondition,,,,,"// rust_verify/tests/example.rs expect-failures
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
use vstd::prelude::*;

verus! {

#[verifier::external]
fn main() {
}

//example: simple conjunt
proof fn test_expansion_very_easy() {
    let x: int = 5;
    assert((x >= 0) && (x != 5));
    //                  ^^^^^^^
}

//example: simple function inline
spec fn is_good_integer(z: int) -> bool {
    z >= 0 && z != 5
    //        ^^^^^^

}

proof fn test_expansion_easy() {
    let x = 5;
    assert(is_good_integer(x));
}

//example: simple `match` inline
spec fn is_good_opt(opt: Option<int>) -> bool {
    match opt {
        Option::Some(k) => k > 10,
        Option::None => true,
    }
}

proof fn test_expansion_match() {
    let x: Option<int> = Option::Some(5);
    let y: Option<int> = Option::Some(4);
    assert(is_good_opt(x));
}

//example: 3-level failure
#[derive(PartialEq, Eq)]
pub enum Message {
    Quit(bool),
    Move { x: i32, y: i32 },
    Write(bool),
}

#[verusfmt::skip]
spec fn is_good_integer_3(x: int) -> bool {
    x >= 0 && x != 5
//  ^^^^^^

}

spec fn is_good_message(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_3((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

spec fn is_good(msg: Message) -> bool {
    is_good_message(msg)
    //^^^^^^^^^^^^^^^^^^

}

proof fn test_expansion_multiple_call() {
    let x = Message::Move { x: 5, y: 6 };
    assert(is_good(x));
    //^^^^^^ ^^^^^^^^^
}

// example: boolean OR, negation
spec fn is_good_integer_5(x: int) -> bool {
    !(x < 0 || !(x != 5))
    //           ^^^^^^

}

proof fn test_expansion_negate() {
    assert(is_good_integer_5(5));
    //^^^^^^ ^^^^^^^^^^^^^^^^^^
}

//example: requires
#[verusfmt::skip]
spec fn is_good_integer_7(x: int) -> bool {
    x >= 0 && x != 5
//  ^^^^^^
}

spec fn is_good_message_7(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_7((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

proof fn test_require_failure(m: Message, b: bool) -> (good_int: int)
    requires
        b,
        is_good_message_7(m),
//      ^^^^^^^^^^^^^^^^^^^^

    ensures
        is_good_integer_7(good_int),
{
    return 0;
}

proof fn test_7(x: int) {
    let x = Message::Move { x: 0, y: 5 };
    test_require_failure(x, true);
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^
    assert(false);
}

//example: ensures
spec fn is_good_integer_8(x: int) -> bool {
    x >= 0 && x != 5
    //        ^^^^^^

}

spec fn is_good_message_8(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_8((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

proof fn test_ensures_failure(b: bool) -> (good_msg: Message)
    ensures
        is_good_message_8(good_msg),
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^

{
    let mut ret = Message::Write(true);
    if !b {
        ret = Message::Move { x: 10, y: 5 };
    }
    ret
}

// example: opaque/reveal
#[verifier::opaque]
spec fn is_good_integer_9(
    x: int,
) -> bool
//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque
 {
    x >= 0 && x != 5
}

#[verifier::opaque]
spec fn is_good_message_9(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_9((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

proof fn test_opaque(b: bool) {
    let good_msg = Message::Move { x: 0, y: 0 };
    reveal(is_good_message_9);
    assert(is_good_message_9(good_msg));
    //^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

// example: `reveal` does not flow
#[verifier::opaque]
spec fn is_good_message_10(msg: Message) -> bool {
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_9((x as int) - (y as int)),
        Message::Write(b) => b,
    }
}

proof fn test_reveal(b: bool) {
    let good_msg = Message::Move { x: 0, y: 0 };
    if b {
        reveal(is_good_message_10);
    } else {
        assert_by(
            true,
            {
                reveal(is_good_message_10);
            },
        );
        assert(is_good_message_10(good_msg));
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    }
}

//example:`hide`
spec fn is_good_integer_11(
    x: int,
) -> bool
//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque
 {
    x >= 0 && x != 5
}

proof fn test_hide(b: bool) {
    hide(is_good_integer_11);
    let i = 0;
    assert(is_good_integer_11(i));
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

//example: publish
mod M3 {
    use verus_builtin::*;

    pub closed spec fn is_good_integer(
        x: int,
    ) -> bool
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is closed at the module boundary
     {
        x >= 0 && x != 5
    }

}

mod M4 {
    #[allow(unused_imports)]


    use crate::M3;

    proof fn test_publish(b: bool) {
        let i = 0;
        assert(M3::is_good_integer(i));
        //^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^
    }

}

// example: reveal at ensures
#[verifier::opaque]
spec fn is_good_integer_13(
    x: int,
) -> bool
//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque
 {
    x >= 0 && x != 5
}

#[verifier::opaque]
spec fn is_good_message_13(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_13((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

proof fn test_reveal_at_ensures(b: bool) -> (good_msg: Message)
    ensures
        is_good_message_13(good_msg),
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

{
    let good_msg = Message::Move { x: 0, y: 0 };
    reveal(is_good_message_13);
    good_msg
}

// example: recursive function
spec fn is_even(
    p: nat,
) -> bool
//   ------------------------- Note: this function is recursive with fuel 10
 {
    decreases(p);
    if p == 0 {
        true
    } else {
        !is_even((p - 1) as nat)
    }
}

proof fn test_rec() {
    reveal_with_fuel(is_even, 10);
    assert(is_even(1));
    //^^^^^^ ^^^^^^^^^^
}

spec fn are_equal(x: int, y: int, z: int, w: int) -> bool {
    #[verifier(custom_err(""integers fail to be equal""))]
    (x == y) && #[verifier(custom_err(""this ain't right. probably.""))]
    (z <= w)
}

proof fn proof_test_are_equal(x: int, y: int, z: int, w: int) {
    assert(are_equal(x, y, z, w));
}

} // verus!
","// rust_verify/tests/example.rs expect-failures
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
use vstd::prelude::*;

verus! {

#[verifier::external]
fn main() {
}

//example: simple conjunt
proof fn test_expansion_very_easy() {
    let x: int = 5;
    assert((x >= 0) && (x != 5));
    //                  ^^^^^^^
}

//example: simple function inline
spec fn is_good_integer(z: int) -> bool {
    z >= 0 && z != 5
    //        ^^^^^^

}

proof fn test_expansion_easy() {
    let x = 5;
    assert(is_good_integer(x));
}

//example: simple `match` inline
spec fn is_good_opt(opt: Option<int>) -> bool {
    match opt {
        Option::Some(k) => k > 10,
        Option::None => true,
    }
}

proof fn test_expansion_match() {
    let x: Option<int> = Option::Some(5);
    let y: Option<int> = Option::Some(4);
    assert(is_good_opt(x));
}

//example: 3-level failure
#[derive(PartialEq, Eq)]
pub enum Message {
    Quit(bool),
    Move { x: i32, y: i32 },
    Write(bool),
}

#[verusfmt::skip]
spec fn is_good_integer_3(x: int) -> bool {
    x >= 0 && x != 5
//  ^^^^^^

}

spec fn is_good_message(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_3((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

spec fn is_good(msg: Message) -> bool {
    is_good_message(msg)
    //^^^^^^^^^^^^^^^^^^

}

proof fn test_expansion_multiple_call() {
    let x = Message::Move { x: 5, y: 6 };
    assert(is_good(x));
    //^^^^^^ ^^^^^^^^^
}

// example: boolean OR, negation
spec fn is_good_integer_5(x: int) -> bool {
    !(x < 0 || !(x != 5))
    //           ^^^^^^

}

proof fn test_expansion_negate() {
    assert(is_good_integer_5(5));
    //^^^^^^ ^^^^^^^^^^^^^^^^^^
}

//example: requires
#[verusfmt::skip]
spec fn is_good_integer_7(x: int) -> bool {
    x >= 0 && x != 5
//  ^^^^^^
}

spec fn is_good_message_7(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_7((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

proof fn test_require_failure(m: Message, b: bool) -> (good_int: int)
    requires
        b,
        is_good_message_7(m),
//      ^^^^^^^^^^^^^^^^^^^^

    ensures
        is_good_integer_7(good_int),
{
    return 0;
}

proof fn test_7(x: int) {
    let x = Message::Move { x: 0, y: 5 };
    test_require_failure(x, true);
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^
    assert(false);
}

//example: ensures
spec fn is_good_integer_8(x: int) -> bool {
    x >= 0 && x != 5
    //        ^^^^^^

}

spec fn is_good_message_8(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_8((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

proof fn test_ensures_failure(b: bool) -> (good_msg: Message)
    ensures
        is_good_message_8(good_msg),
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^

{
    let mut ret = Message::Write(true);
    if !b {
        ret = Message::Move { x: 10, y: 5 };
    }
    ret
}

// example: opaque/reveal
#[verifier::opaque]
spec fn is_good_integer_9(
    x: int,
) -> bool
//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque
 {
    x >= 0 && x != 5
}

#[verifier::opaque]
spec fn is_good_message_9(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_9((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

proof fn test_opaque(b: bool) {
    let good_msg = Message::Move { x: 0, y: 0 };
    reveal(is_good_message_9);
    assert(is_good_message_9(good_msg));
    //^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

// example: `reveal` does not flow
#[verifier::opaque]
spec fn is_good_message_10(msg: Message) -> bool {
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_9((x as int) - (y as int)),
        Message::Write(b) => b,
    }
}

proof fn test_reveal(b: bool) {
    let good_msg = Message::Move { x: 0, y: 0 };
    if b {
        reveal(is_good_message_10);
    } else {
        assert_by(
            true,
            {
                reveal(is_good_message_10);
            },
        );
        assert(is_good_message_10(good_msg));
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    }
}

//example:`hide`
spec fn is_good_integer_11(
    x: int,
) -> bool
//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque
 {
    x >= 0 && x != 5
}

proof fn test_hide(b: bool) {
    hide(is_good_integer_11);
    let i = 0;
    assert(is_good_integer_11(i));
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^
}

//example: publish
mod M3 {
    use verus_builtin::*;

    pub closed spec fn is_good_integer(
        x: int,
    ) -> bool
    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is closed at the module boundary
     {
        x >= 0 && x != 5
    }

}

mod M4 {
    #[allow(unused_imports)]


    use crate::M3;

    proof fn test_publish(b: bool) {
        let i = 0;
        assert(M3::is_good_integer(i));
        //^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^
    }

}

// example: reveal at ensures
#[verifier::opaque]
spec fn is_good_integer_13(
    x: int,
) -> bool
//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Note: this function is opaque
 {
    x >= 0 && x != 5
}

#[verifier::opaque]
spec fn is_good_message_13(msg: Message) -> bool {
    match msg {
        Message::Quit(b) => b,
        Message::Move { x, y } => is_good_integer_13((x as int) - (y as int)),
        //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        Message::Write(b) => b,
    }
}

proof fn test_reveal_at_ensures(b: bool) -> (good_msg: Message)
    ensures
        is_good_message_13(good_msg),
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

{
    let good_msg = Message::Move { x: 0, y: 0 };
    reveal(is_good_message_13);
    good_msg
}

// example: recursive function
spec fn is_even(
    p: nat,
) -> bool
//   ------------------------- Note: this function is recursive with fuel 10
 {
    decreases(p);
    if p == 0 {
        true
    } else {
        !is_even((p - 1) as nat)
    }
}

proof fn test_rec() {
    reveal_with_fuel(is_even, 10);
    assert(is_even(1));
    //^^^^^^ ^^^^^^^^^^
}

spec fn are_equal(x: int, y: int, z: int, w: int) -> bool {
    #[verifier(custom_err(""integers fail to be equal""))]
    (x == y) && #[verifier(custom_err(""this ain't right. probably.""))]
    (z <= w)
}

proof fn proof_test_are_equal(x: int, y: int, z: int, w: int) {
    assert(are_equal(x, y, z, w));
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/even_cell.rs,52,11,0.21153846153846154,216.183,True,0.7999999999999999,True,"['vstd::prelude::', 'vstd::invariant::', 'vstd::cell::']",True,,,,,,"use vstd::prelude::*;
use vstd::invariant::*;
use vstd::cell::*;

verus!{

ghost struct EvenCell { }

impl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {
    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {
        points_to.id() == cell_id
          && (match points_to.mem_contents() {
              MemContents::Uninit => false,
              MemContents::Init(x) => x % 2 == 0,
          })
    }
}

fn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)
    requires inv.constant() == cell.id(),
{
    open_local_invariant!(inv => points_to => {
        assert(points_to.is_init());
        assert(points_to.value() % 2 == 0);

        let x = cell.take(Tracked(&mut points_to));
        assert(x % 2 == 0);

        // Add 2 (wrap around if necessary)
        let x_plus_2 = if x == 254 { 0 } else { x + 2 };

        cell.put(Tracked(&mut points_to), x_plus_2);

        assert(points_to.is_init());
        assert(points_to.value() % 2 == 0);
    });
}

fn main() {
    let (cell, Tracked(points_to)) = PCell::new(4);

    let tracked inv = LocalInvariant::new(
        cell.id(),
        points_to,
        1337 /* arbitrary namespace */);

    add_2(&cell, Tracked(&inv));
    add_2(&cell, Tracked(&inv));
    add_2(&cell, Tracked(&inv));
}

}
","use vstd::prelude::*;
        use vstd::invariant::*;
        use vstd::cell::*;
        verus!{
       ghost struct EvenCell ;
       impl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {
          open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool ;
      }
       fn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)     requires inv.constant() == cell.id(), ;
       fn main() ;
       }
","['use vstd::prelude::*;\nuse vstd::invariant::*;\nuse vstd::cell::*;\n\nverus!{\n\nghost struct EvenCell { }\n\nimpl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {\n        points_to.id() == cell_id\n          && (match points_to.mem_contents() {\n              MemContents::Uninit => false,\n              MemContents::Init(x) => x % 2 == 0,\n          })\n    }\n}\n\nfn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)\n    requires inv.constant() == cell.id(),\n{\n    open_local_invariant!(inv => points_to => {\n        assert(points_to.is_init());\n        assert(points_to.value() % 2 == 0);\n\n        let x = cell.take(Tracked(&mut points_to));\n        assert(x % 2 == 0);\n\n        // Add 2 (wrap around if necessary)\n        let x_plus_2 = if x == 254 { 0 } else { x + 2 };\n\n        cell.put(Tracked(&mut points_to), x_plus_2);\n\n        assert(points_to.is_init());\n        assert(points_to.value() % 2 == 0);\n    });\n}\n\nfn main() {\n    let (cell, Tracked(points_to)) = PCell::new(4);\n\n    let tracked inv = LocalInvariant::new(\n        cell.id(),\n        points_to,\n        1337 /* arbitrary namespace */);\n\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n}\n\n}\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\n        use vstd::invariant::*;\n        use vstd::cell::*;\n        verus!{\n       ghost struct EvenCell ;\n       impl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n          open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool ;\n      }\n       fn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)     requires inv.constant() == cell.id(), ;\n       fn main() ;\n       }\n', 'use vstd::prelude::*;\n               verus!{\n             fn main() ;\n             }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/exec_termination_example.rs,114,114,1.0,0.559,False,0.7,True,['vstd::prelude::'],True,,,,,,"use vstd::prelude::*;

verus! {
    // basic recursive expression
    fn exec_basic_recursive_expr(i: u64) -> (r: u64)
        ensures r == i
        decreases i
    {
        if i == 0 { 0 } else { 1 + exec_basic_recursive_expr(i - 1) }
    }

    // basic recursive statement
    fn exec_basic_recursive_stmt(i: u64)
        decreases i 
    {
        if i != 0 {
            exec_basic_recursive_stmt(i - 1);
        }
    }

    // basic while loop
    fn exec_basic_while_loop() {
        let mut i = 0;
        while i < 10
            invariant i <= 10
            decreases 10 - i
        {
            i = i + 1;
        }
        assert(i == 10);
    }

    // nested while 
    fn exec_nested_while_loop() {
        let mut i = 0;
        let mut j = 0;
        while i < 10 
            invariant 
                i <= 10,
                j <= 5
            decreases 10 - i
            {
                i = i + 1;
                while j < 5
                    invariant j <= 5
                    decreases 5 - j
                    {
                        j = j + 1;
                    }
            }
    }

    // infinite loop with break
    fn exec_basic_loop_break() {
        let mut i: i8 = 0;
        loop
            invariant_except_break i <= 9
            invariant 0 <= i <= 10
            ensures 1 <= i
            decreases 10 - i
        {
            i = i + 1;
            if i == 10 {
                break;
            }
        }
    }

    // for loop 
    fn exec_for_loop() {
        let mut n: u64 = 0;
        for x in iter: 0..10
            invariant n == iter.cur * 3,
            // You can write a `decreases` if you want, but it's not needed
            // because Verus inserts a decreases automatically for `for` loops:
            //   decreases 10 - iter.cur,
        {
            n += 3;
        }
    }

    fn exec_for_loop_2() {
        let mut n: u64 = 0;
        let mut end = 10;
        for x in iter: 0..end 
            invariant 
                n == iter.cur * 3,
                end == 10,
            // You can write a `decreases` if you want, but it's not needed
            // because Verus inserts a decreases automatically for `for` loops:
            //   decreases end - iter.cur,
        {
            n += 3;
        }
    }

    // basic recursive expression + basic while loop
    #[verifier::loop_isolation(false)]
    fn exec_basic_recursive_stmt_basic_while_loop(mut i: u64)
        requires i <= 10,
        decreases i,
    {
        let ghost initial_i = i;
        while 0 < i && i <= 10
            invariant
                0 <= i <= 10,
                i <= initial_i,
            decreases i,
        {
            exec_basic_recursive_stmt_basic_while_loop(i - 1);
            i -= 1;
        }
    }
}","use vstd::prelude::*;

verus! {
    // basic recursive expression
    fn exec_basic_recursive_expr(i: u64) -> (r: u64)
        ensures r == i
        decreases i
    {
        if i == 0 { 0 } else { 1 + exec_basic_recursive_expr(i - 1) }
    }

    // basic recursive statement
    fn exec_basic_recursive_stmt(i: u64)
        decreases i 
    {
        if i != 0 {
            exec_basic_recursive_stmt(i - 1);
        }
    }

    // basic while loop
    fn exec_basic_while_loop() {
        let mut i = 0;
        while i < 10
            invariant i <= 10
            decreases 10 - i
        {
            i = i + 1;
        }
        assert(i == 10);
    }

    // nested while 
    fn exec_nested_while_loop() {
        let mut i = 0;
        let mut j = 0;
        while i < 10 
            invariant 
                i <= 10,
                j <= 5
            decreases 10 - i
            {
                i = i + 1;
                while j < 5
                    invariant j <= 5
                    decreases 5 - j
                    {
                        j = j + 1;
                    }
            }
    }

    // infinite loop with break
    fn exec_basic_loop_break() {
        let mut i: i8 = 0;
        loop
            invariant_except_break i <= 9
            invariant 0 <= i <= 10
            ensures 1 <= i
            decreases 10 - i
        {
            i = i + 1;
            if i == 10 {
                break;
            }
        }
    }

    // for loop 
    fn exec_for_loop() {
        let mut n: u64 = 0;
        for x in iter: 0..10
            invariant n == iter.cur * 3,
            // You can write a `decreases` if you want, but it's not needed
            // because Verus inserts a decreases automatically for `for` loops:
            //   decreases 10 - iter.cur,
        {
            n += 3;
        }
    }

    fn exec_for_loop_2() {
        let mut n: u64 = 0;
        let mut end = 10;
        for x in iter: 0..end 
            invariant 
                n == iter.cur * 3,
                end == 10,
            // You can write a `decreases` if you want, but it's not needed
            // because Verus inserts a decreases automatically for `for` loops:
            //   decreases end - iter.cur,
        {
            n += 3;
        }
    }

    // basic recursive expression + basic while loop
    #[verifier::loop_isolation(false)]
    fn exec_basic_recursive_stmt_basic_while_loop(mut i: u64)
        requires i <= 10,
        decreases i,
    {
        let ghost initial_i = i;
        while 0 < i && i <= 10
            invariant
                0 <= i <= 10,
                i <= initial_i,
            decreases i,
        {
            exec_basic_recursive_stmt_basic_while_loop(i - 1);
            i -= 1;
        }
    }
}",[]
/Users/ameliakuang/Repos/dep_verus/examples/experimental_new_mut_ref/hash_table_entry.rs,173,173,1.0,,,0.9,True,"['vstd::prelude::', 'vstd::std_specs::hash::', 'core::borrow::Borrow', 'std::collections::hash_map::', 'std::hash::']",False,other,,,,,"use vstd::prelude::*;
use vstd::std_specs::hash::*;

use core::borrow::Borrow;
use std::collections::hash_map::*;
use std::hash::*;

// Examples of using the HashMap::entry function
// https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry

verus!{

// Specs for OccupiedEntry, VacantEntry, and the Entry enum

#[verifier::reject_recursive_types_in_ground_variants(K)]
#[verifier::reject_recursive_types_in_ground_variants(V)]
#[verifier::external_body]
#[verifier::external_type_specification]
pub struct ExOccupiedEntry<'a, K: 'a, V: 'a>(OccupiedEntry<'a, K, V>);

#[verifier::reject_recursive_types_in_ground_variants(K)]
#[verifier::accept_recursive_types(V)]
#[verifier::external_body]
#[verifier::external_type_specification]
pub struct ExVacantEntry<'a, K: 'a, V: 'a>(VacantEntry<'a, K, V>);

#[verifier::external_type_specification]
pub struct ExEntry<'a, K: 'a, V: 'a>(Entry<'a, K, V>);

pub trait OccupiedEntrySpecFns<K, V> : Sized {
    spec fn key(self) -> K;
    spec fn value(self) -> V;
    #[verifier::prophetic]
    spec fn future_value(self) -> Option<V>;
}

impl<'a, K, V> OccupiedEntrySpecFns<K, V> for OccupiedEntry<'a, K, V> {
    uninterp spec fn key(self) -> K;
    uninterp spec fn value(self) -> V;
    #[verifier::prophetic]
    uninterp spec fn future_value(self) -> Option<V>;
}

pub trait VacantEntrySpecFns<K, V> : Sized {
    spec fn key(self) -> K;
    #[verifier::prophetic]
    spec fn future_value(self) -> Option<V>;
}

impl<'a, K, V> VacantEntrySpecFns<K, V> for VacantEntry<'a, K, V> {
    uninterp spec fn key(self) -> K;
    #[verifier::prophetic]
    uninterp spec fn future_value(self) -> Option<V>;
}

pub trait EntrySpecFns<K, V> : Sized {
    spec fn key(self) -> K;
    spec fn value(self) -> Option<V>;

    #[verifier::prophetic]
    spec fn future_value(self) -> Option<V>;
}

impl<'a, K, V> EntrySpecFns<K, V> for Entry<'a, K, V> {
    open spec fn key(self) -> K {
        match self {
            Entry::Occupied(occupied_entry) => occupied_entry.key(),
            Entry::Vacant(vacant_entry) => vacant_entry.key(),
        }
    }

    open spec fn value(self) -> Option<V> {
        match self {
            Entry::Occupied(occupied_entry) => Some(occupied_entry.value()),
            Entry::Vacant(vacant_entry) => None,
        }
    }

    #[verifier::prophetic]
    open spec fn future_value(self) -> Option<V> {
        match self {
            Entry::Occupied(occupied_entry) => occupied_entry.future_value(),
            Entry::Vacant(vacant_entry) => vacant_entry.future_value(),
        }
    }
}

pub broadcast axiom fn occupied_entry_has_resolved<K, V>(entry: OccupiedEntry<K, V>)
    ensures
        #[trigger] has_resolved(entry) ==> entry.future_value() == Some(entry.value());

pub broadcast axiom fn vacant_entry_has_resolved<K, V>(entry: VacantEntry<K, V>)
    ensures
        #[trigger] has_resolved(entry) ==> entry.future_value() == None::<V>;

pub broadcast proof fn entry_has_resolved<K, V>(entry: Entry<K, V>)
    ensures
        #[trigger] has_resolved(entry) ==> entry.future_value() == entry.value()
{
    broadcast use occupied_entry_has_resolved;
    broadcast use vacant_entry_has_resolved;
}

pub assume_specification<
    'a,
    Key: Hash + Eq,
    Value,
    S: BuildHasher,
>[ HashMap::<Key, Value, S>::entry ](m: &'a mut HashMap<Key, Value, S>, key: Key)
  -> (entry: Entry<'a, Key, Value>)
ensures
    obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> (
            entry.key() == key
         && entry.value() == mut_ref_current(m)@.get(key)
         && mut_ref_future(m)@ == (match entry.future_value() {
            Some(value) => mut_ref_current(m)@.insert(key, value),
            None => mut_ref_current(m)@.remove(key),
         })
    );

pub assume_specification<'a, K, V> [ Entry::or_insert ]
    (entry: Entry::<'a, K, V>, default: V) -> (value: &'a mut V)
ensures
    mut_ref_current(value) == (match entry.value() {
        Some(v) => v,
        None => default
    }),
    entry.future_value() == Some(mut_ref_future(value));

pub assume_specification<'a, K, V> [ OccupiedEntry::remove_entry ]
    (entry: OccupiedEntry::<'a, K, V>) -> (kv: (Key, Value))
ensures
    entry.future_value() == None,
returns
    (entry.key(), entry.value())


fn main() {
    broadcast use entry_has_resolved;

    let mut m = HashMap::<u64, u64>::new();

    // Use entry API to insert to the matp

    let entry = m.entry(5);
    assert(entry.key() == 5 && entry.value() === None);

    let value_ref = entry.or_insert(20);
    assert(*value_ref == 20);

    *value_ref = 40;

    assert(m@.dom().contains(5) && m@[5] == 40);

    // Use entry API to remove from the map

    let entry = m.entry(5);
    match entry {
        Entry::OccupiedEntry(occupied_entry) => {
            let (k, v) == occupied_entry.remove_entry();
            assert(k == 5);
            assert(v == 40);
        }
        Entry::VacantEntry(_) => {
            assert(false);
        }
    }

    assert(!m@.dom().contains(5));
}

}

","use vstd::prelude::*;
use vstd::std_specs::hash::*;

use core::borrow::Borrow;
use std::collections::hash_map::*;
use std::hash::*;

// Examples of using the HashMap::entry function
// https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry

verus!{

// Specs for OccupiedEntry, VacantEntry, and the Entry enum

#[verifier::reject_recursive_types_in_ground_variants(K)]
#[verifier::reject_recursive_types_in_ground_variants(V)]
#[verifier::external_body]
#[verifier::external_type_specification]
pub struct ExOccupiedEntry<'a, K: 'a, V: 'a>(OccupiedEntry<'a, K, V>);

#[verifier::reject_recursive_types_in_ground_variants(K)]
#[verifier::accept_recursive_types(V)]
#[verifier::external_body]
#[verifier::external_type_specification]
pub struct ExVacantEntry<'a, K: 'a, V: 'a>(VacantEntry<'a, K, V>);

#[verifier::external_type_specification]
pub struct ExEntry<'a, K: 'a, V: 'a>(Entry<'a, K, V>);

pub trait OccupiedEntrySpecFns<K, V> : Sized {
    spec fn key(self) -> K;
    spec fn value(self) -> V;
    #[verifier::prophetic]
    spec fn future_value(self) -> Option<V>;
}

impl<'a, K, V> OccupiedEntrySpecFns<K, V> for OccupiedEntry<'a, K, V> {
    uninterp spec fn key(self) -> K;
    uninterp spec fn value(self) -> V;
    #[verifier::prophetic]
    uninterp spec fn future_value(self) -> Option<V>;
}

pub trait VacantEntrySpecFns<K, V> : Sized {
    spec fn key(self) -> K;
    #[verifier::prophetic]
    spec fn future_value(self) -> Option<V>;
}

impl<'a, K, V> VacantEntrySpecFns<K, V> for VacantEntry<'a, K, V> {
    uninterp spec fn key(self) -> K;
    #[verifier::prophetic]
    uninterp spec fn future_value(self) -> Option<V>;
}

pub trait EntrySpecFns<K, V> : Sized {
    spec fn key(self) -> K;
    spec fn value(self) -> Option<V>;

    #[verifier::prophetic]
    spec fn future_value(self) -> Option<V>;
}

impl<'a, K, V> EntrySpecFns<K, V> for Entry<'a, K, V> {
    open spec fn key(self) -> K {
        match self {
            Entry::Occupied(occupied_entry) => occupied_entry.key(),
            Entry::Vacant(vacant_entry) => vacant_entry.key(),
        }
    }

    open spec fn value(self) -> Option<V> {
        match self {
            Entry::Occupied(occupied_entry) => Some(occupied_entry.value()),
            Entry::Vacant(vacant_entry) => None,
        }
    }

    #[verifier::prophetic]
    open spec fn future_value(self) -> Option<V> {
        match self {
            Entry::Occupied(occupied_entry) => occupied_entry.future_value(),
            Entry::Vacant(vacant_entry) => vacant_entry.future_value(),
        }
    }
}

pub broadcast axiom fn occupied_entry_has_resolved<K, V>(entry: OccupiedEntry<K, V>)
    ensures
        #[trigger] has_resolved(entry) ==> entry.future_value() == Some(entry.value());

pub broadcast axiom fn vacant_entry_has_resolved<K, V>(entry: VacantEntry<K, V>)
    ensures
        #[trigger] has_resolved(entry) ==> entry.future_value() == None::<V>;

pub broadcast proof fn entry_has_resolved<K, V>(entry: Entry<K, V>)
    ensures
        #[trigger] has_resolved(entry) ==> entry.future_value() == entry.value()
{
    broadcast use occupied_entry_has_resolved;
    broadcast use vacant_entry_has_resolved;
}

pub assume_specification<
    'a,
    Key: Hash + Eq,
    Value,
    S: BuildHasher,
>[ HashMap::<Key, Value, S>::entry ](m: &'a mut HashMap<Key, Value, S>, key: Key)
  -> (entry: Entry<'a, Key, Value>)
ensures
    obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> (
            entry.key() == key
         && entry.value() == mut_ref_current(m)@.get(key)
         && mut_ref_future(m)@ == (match entry.future_value() {
            Some(value) => mut_ref_current(m)@.insert(key, value),
            None => mut_ref_current(m)@.remove(key),
         })
    );

pub assume_specification<'a, K, V> [ Entry::or_insert ]
    (entry: Entry::<'a, K, V>, default: V) -> (value: &'a mut V)
ensures
    mut_ref_current(value) == (match entry.value() {
        Some(v) => v,
        None => default
    }),
    entry.future_value() == Some(mut_ref_future(value));

pub assume_specification<'a, K, V> [ OccupiedEntry::remove_entry ]
    (entry: OccupiedEntry::<'a, K, V>) -> (kv: (Key, Value))
ensures
    entry.future_value() == None,
returns
    (entry.key(), entry.value())


fn main() {
    broadcast use entry_has_resolved;

    let mut m = HashMap::<u64, u64>::new();

    // Use entry API to insert to the matp

    let entry = m.entry(5);
    assert(entry.key() == 5 && entry.value() === None);

    let value_ref = entry.or_insert(20);
    assert(*value_ref == 20);

    *value_ref = 40;

    assert(m@.dom().contains(5) && m@[5] == 40);

    // Use entry API to remove from the map

    let entry = m.entry(5);
    match entry {
        Entry::OccupiedEntry(occupied_entry) => {
            let (k, v) == occupied_entry.remove_entry();
            assert(k == 5);
            assert(v == 40);
        }
        Entry::VacantEntry(_) => {
            assert(false);
        }
    }

    assert(!m@.dom().contains(5));
}

}

",[]
/Users/ameliakuang/Repos/dep_verus/examples/extensionality.rs,120,6,0.05,154.056,True,0.6,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,,,,"#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{map::*, seq::*, seq_lib::*, set::*, set_lib::*};

verus! {

// Sequence extensionality
proof fn test_seqs(s1: Seq<u64>, s2: Seq<u64>)
    requires
        s1.len() == 3,
        s1[0] == 0,
        s1[1] == 4,
        s1[2] == 8,
        s2.len() == 3,
        s2[0] == 0,
        s2[1] == 4,
        s2[2] == 8,
{
    assert_seqs_equal!(s1, s2);
    assert(s1 == s2);
}

proof fn pop_and_push(s: Seq<u64>)
    requires
        s.len() >= 1,
{
    let t = s.subrange(0, s.len() as int - 1).push(s[s.len() as int - 1]);
    assert_seqs_equal!(s, t);
    assert(s == t);
}

proof fn subrange_concat(s: Seq<u64>, i: int)
    requires
        0 <= i <= s.len(),
{
    let t1 = s.subrange(0, i);
    let t2 = s.subrange(i, s.len() as int);
    let t = t1.add(t2);
    assert_seqs_equal!(s, t);
    assert(s == t);
}

spec fn are_equal(s: Seq<u64>, t: Seq<u64>, i: int) -> bool {
    s[i] == t[i]
}

proof fn assert_seqs_equal_with_proof(s: Seq<u64>, t: Seq<u64>)
    requires
        s.len() == t.len(),
        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i),
{
    assert_seqs_equal!(s, t, i => {
        assert(are_equal(s, t, i)); // trigger
    });
    assert(s == t);
}

// Map extensionality
proof fn test_map(m: Map<int, int>)
    requires
        m.contains_pair(5, 17),
{
    let q = m.remove(5).insert(5, 17);
    assert_maps_equal!(m, q);
    assert(m == q);
}

spec fn maps_are_equal_on(m: Map<int, int>, q: Map<int, int>, i: int) -> bool {
    &&& m.dom().contains(i)
    &&& q.dom().contains(i)
    &&& m[i] == q[i]
}

proof fn assert_maps_equal_with_proof(m: Map<int, int>, q: Map<int, int>)
    requires
        forall|i| maps_are_equal_on(m, q, i),
{
    assert_maps_equal!(m, q, i => {
        assert(maps_are_equal_on(m, q, i)); // trigger
    });
    assert(m == q);
}

proof fn assert_maps_equal_with_proof2() {
    let m = Map::<u64, u64>::total(|t: u64| t & 184);
    let q = Map::<u64, u64>::new(|t: u64| t ^ t == 0, |t: u64| 184 & t);
    assert_maps_equal!(m, q, t => {
        // show that the `q` map is total:
        assert_bit_vector(t ^ t == 0);

        // show that the values are equal:
        assert_bit_vector(t & 184 == 184 & t);
    });
    assert(m == q);
}

// Set extensionality
proof fn test_set(s: Set<int>, t: Set<int>) {
    assert_sets_equal!(
        s.union(t),
        t.union(s),
    );
    assert(s.union(t) == t.union(s));
}

proof fn assert_sets_equal_with_proof() {
    let s = Set::<u64>::new(|i: u64| i ^ 25 < 100);
    let t = Set::<u64>::new(|i: u64| 25 ^ i < 100);
    assert_sets_equal!(s, t, i => {
        assert_bit_vector(i ^ 25 == 25 ^ i);
    });
    assert(s == t);
}

fn main() {
}

} // verus!
","  use verus_builtin_macros::*;
                use vstd::{
      };
                verus! {
              fn main() ;
              }
","['#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{map::*, seq::*, seq_lib::*, set::*, set_lib::*};\n\nverus! {\n\n// Sequence extensionality\nproof fn test_seqs(s1: Seq<u64>, s2: Seq<u64>)\n    requires\n        s1.len() == 3,\n        s1[0] == 0,\n        s1[1] == 4,\n        s1[2] == 8,\n        s2.len() == 3,\n        s2[0] == 0,\n        s2[1] == 4,\n        s2[2] == 8,\n{\n    assert_seqs_equal!(s1, s2);\n    assert(s1 == s2);\n}\n\nproof fn pop_and_push(s: Seq<u64>)\n    requires\n        s.len() >= 1,\n{\n    let t = s.subrange(0, s.len() as int - 1).push(s[s.len() as int - 1]);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nproof fn subrange_concat(s: Seq<u64>, i: int)\n    requires\n        0 <= i <= s.len(),\n{\n    let t1 = s.subrange(0, i);\n    let t2 = s.subrange(i, s.len() as int);\n    let t = t1.add(t2);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nspec fn are_equal(s: Seq<u64>, t: Seq<u64>, i: int) -> bool {\n    s[i] == t[i]\n}\n\nproof fn assert_seqs_equal_with_proof(s: Seq<u64>, t: Seq<u64>)\n    requires\n        s.len() == t.len(),\n        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i),\n{\n    assert_seqs_equal!(s, t, i => {\n        assert(are_equal(s, t, i)); // trigger\n    });\n    assert(s == t);\n}\n\n// Map extensionality\nproof fn test_map(m: Map<int, int>)\n    requires\n        m.contains_pair(5, 17),\n{\n    let q = m.remove(5).insert(5, 17);\n    assert_maps_equal!(m, q);\n    assert(m == q);\n}\n\nspec fn maps_are_equal_on(m: Map<int, int>, q: Map<int, int>, i: int) -> bool {\n    &&& m.dom().contains(i)\n    &&& q.dom().contains(i)\n    &&& m[i] == q[i]\n}\n\nproof fn assert_maps_equal_with_proof(m: Map<int, int>, q: Map<int, int>)\n    requires\n        forall|i| maps_are_equal_on(m, q, i),\n{\n    assert_maps_equal!(m, q, i => {\n        assert(maps_are_equal_on(m, q, i)); // trigger\n    });\n    assert(m == q);\n}\n\nproof fn assert_maps_equal_with_proof2() {\n    let m = Map::<u64, u64>::total(|t: u64| t & 184);\n    let q = Map::<u64, u64>::new(|t: u64| t ^ t == 0, |t: u64| 184 & t);\n    assert_maps_equal!(m, q, t => {\n        // show that the `q` map is total:\n        assert_bit_vector(t ^ t == 0);\n\n        // show that the values are equal:\n        assert_bit_vector(t & 184 == 184 & t);\n    });\n    assert(m == q);\n}\n\n// Set extensionality\nproof fn test_set(s: Set<int>, t: Set<int>) {\n    assert_sets_equal!(\n        s.union(t),\n        t.union(s),\n    );\n    assert(s.union(t) == t.union(s));\n}\n\nproof fn assert_sets_equal_with_proof() {\n    let s = Set::<u64>::new(|i: u64| i ^ 25 < 100);\n    let t = Set::<u64>::new(|i: u64| 25 ^ i < 100);\n    assert_sets_equal!(s, t, i => {\n        assert_bit_vector(i ^ 25 == 25 ^ i);\n    });\n    assert(s == t);\n}\n\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n', '  use verus_builtin_macros::*;\n                use vstd::{\n      };\n                verus! {\n              fn main() ;\n              }\n', 'use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/float.rs,91,5,0.054945054945054944,215.378,True,0.5,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::', 'vstd::std_specs::ops::AddSpec', 'vstd::float::FloatBitsProperties', 'vstd::std_specs::ops::add_ensures']",True,,,,,,"use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::*;

verus! {

use vstd::std_specs::ops::AddSpec;
use vstd::float::FloatBitsProperties;

/*
Verus deliberately omits axioms about floating point from vstd,
because the desired set of useful and sound axioms may vary by project and platform.
(See https://github.com/rust-lang/rfcs/blob/master/text/3514-float-semantics.md for details
about why Rust floating point semantics are complex, may be non-deterministic, and may fall short
of desired behavior on some platforms.)
Therefore, projects that want to prove properties of about floating-point numbers may want
to define their own axioms, or even define different groups of axioms for different situations.

For example, one useful axiom is that it is always safe to add any two floats
(this assumes that the platform is correctly configured not to trap on a NaN result,
which should usually be true):
*/

pub broadcast axiom fn f64_can_add_anything(a: f64, b: f64)
    ensures
        #[trigger] a.add_req(b);

/*
The axiom above doesn't guarantee non-NaN results -- it's possible to add large positive numbers to
construct positive infinity, to add large negative numbers to construct negative infinity,
and then add negative infinity to positive infinity to construct a NaN.
As an example of verifying something slightly nontrivial,
the axioms below only permit addition of positive numbers,
and guarantee non-NaN results.
*/

pub broadcast axiom fn f64_add_positive_spec(a: f64, b: f64)
    requires
        !a.is_nan_spec(),
        !b.is_nan_spec(),
        !a.is_sign_negative_spec(),
        !b.is_sign_negative_spec(),
    ensures
        #![trigger a.add_spec(b)]
        !a.add_spec(b).is_nan_spec(),
        !a.add_spec(b).is_sign_negative_spec();

pub broadcast axiom fn f64_add_positive_exec(a: f64, b: f64)
    requires
        !a.is_nan_spec(),
        !b.is_nan_spec(),
        !a.is_sign_negative_spec(),
        !b.is_sign_negative_spec(),
    ensures
        #[trigger] a.add_req(b);

use vstd::std_specs::ops::add_ensures;

pub broadcast axiom fn f64_add_positive_ensures(a: f64, b: f64, o: f64)
    requires
        !a.is_nan_spec(),
        !b.is_nan_spec(),
        !a.is_sign_negative_spec(),
        !b.is_sign_negative_spec(),
    ensures
        #[trigger] add_ensures::<f64>(a, b, o) ==> o == a.add_spec(b);

pub broadcast group f64_add_positive {
    f64_add_positive_spec,
    f64_add_positive_exec,
    f64_add_positive_ensures,
}

fn main() {
    broadcast use f64_add_positive;
    let a: f64 = 3.1;
    let b: f64 = 2.8;
    let c = a + b;
    let d = b + c;
    let e = c + d;

    // This would fail the !b.is_sign_negative_spec() precondition:
    // let f = e + (-0.7);

    // But if we use the more permissive axiom, then we can add a negative number
    // (albeit with no guarantee about the result):
    broadcast use f64_can_add_anything;
    let f = e + (-0.7);
}

} // verus!
","use verus_builtin_macros::*;
verus !{
  use vstd;
  fn main();
}
","[""use verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nuse vstd::std_specs::ops::AddSpec;\nuse vstd::float::FloatBitsProperties;\n\n/*\nVerus deliberately omits axioms about floating point from vstd,\nbecause the desired set of useful and sound axioms may vary by project and platform.\n(See https://github.com/rust-lang/rfcs/blob/master/text/3514-float-semantics.md for details\nabout why Rust floating point semantics are complex, may be non-deterministic, and may fall short\nof desired behavior on some platforms.)\nTherefore, projects that want to prove properties of about floating-point numbers may want\nto define their own axioms, or even define different groups of axioms for different situations.\n\nFor example, one useful axiom is that it is always safe to add any two floats\n(this assumes that the platform is correctly configured not to trap on a NaN result,\nwhich should usually be true):\n*/\n\npub broadcast axiom fn f64_can_add_anything(a: f64, b: f64)\n    ensures\n        #[trigger] a.add_req(b);\n\n/*\nThe axiom above doesn't guarantee non-NaN results -- it's possible to add large positive numbers to\nconstruct positive infinity, to add large negative numbers to construct negative infinity,\nand then add negative infinity to positive infinity to construct a NaN.\nAs an example of verifying something slightly nontrivial,\nthe axioms below only permit addition of positive numbers,\nand guarantee non-NaN results.\n*/\n\npub broadcast axiom fn f64_add_positive_spec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #![trigger a.add_spec(b)]\n        !a.add_spec(b).is_nan_spec(),\n        !a.add_spec(b).is_sign_negative_spec();\n\npub broadcast axiom fn f64_add_positive_exec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] a.add_req(b);\n\nuse vstd::std_specs::ops::add_ensures;\n\npub broadcast axiom fn f64_add_positive_ensures(a: f64, b: f64, o: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] add_ensures::<f64>(a, b, o) ==> o == a.add_spec(b);\n\npub broadcast group f64_add_positive {\n    f64_add_positive_spec,\n    f64_add_positive_exec,\n    f64_add_positive_ensures,\n}\n\nfn main() {\n    broadcast use f64_add_positive;\n    let a: f64 = 3.1;\n    let b: f64 = 2.8;\n    let c = a + b;\n    let d = b + c;\n    let e = c + d;\n\n    // This would fail the !b.is_sign_negative_spec() precondition:\n    // let f = e + (-0.7);\n\n    // But if we use the more permissive axiom, then we can add a negative number\n    // (albeit with no guarantee about the result):\n    broadcast use f64_can_add_anything;\n    let f = e + (-0.7);\n}\n\n} // verus!\n"", 'use verus_builtin_macros::*;\nverus !{\n  use vstd;\n  fn main();\n}\n', ' use verus_builtin_macros::*;\n            verus! {\n          use vstd::std_specs::ops::AddSpec;\n          fn main() ;\n          }\n', 'use verus_builtin_macros::*;\nverus !{\n  use vstd;\n  fn main();\n}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/generics.rs,75,75,1.0,152.612,True,0.8999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

fn main() {
}

spec fn f<A>(a1: A, a2: A) -> bool {
    true
}

spec fn id<A, B>(a: A, b: B, c: A) -> A {
    a
}

fn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)
    requires
        f(a, c),
    ensures
        f(r, a),
{
    a
}

spec fn id_int(i: int) -> int {
    id(i, true, 10)
}

spec fn id_u64(i: u64) -> u64 {
    id(i, true, 10)
}

fn id_u64_exec(i: u64) -> (r: u64)
    ensures
        f(r, id_u64(i)),
{
    id_exec(i, true, 10)
}

struct S<A> {
    n: A,
}

spec fn s_property<B>(s: S<B>) -> int {
    7
}

spec fn id_s(s: S<int>) -> S<int> {
    id(s, true, s)
}

proof fn s_prop1(x: S<int>, y: S<int>) {
    assert(s_property(x) == s_property(y));
}

proof fn s_prop2<C>(x: S<C>, y: S<C>) {
    assert(s_property(x) == s_property(y));
}

#[verifier::opaque]
spec fn g<A>(a: A) -> A {
    a
}

proof fn test_g1(u: u8) {
    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?
    assert(g(u) == u);
}

proof fn test_g2(u: u8) {
    assert(g(u) < 256 as int);
}

} // verus!
","use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

fn main() {
}

spec fn f<A>(a1: A, a2: A) -> bool {
    true
}

spec fn id<A, B>(a: A, b: B, c: A) -> A {
    a
}

fn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)
    requires
        f(a, c),
    ensures
        f(r, a),
{
    a
}

spec fn id_int(i: int) -> int {
    id(i, true, 10)
}

spec fn id_u64(i: u64) -> u64 {
    id(i, true, 10)
}

fn id_u64_exec(i: u64) -> (r: u64)
    ensures
        f(r, id_u64(i)),
{
    id_exec(i, true, 10)
}

struct S<A> {
    n: A,
}

spec fn s_property<B>(s: S<B>) -> int {
    7
}

spec fn id_s(s: S<int>) -> S<int> {
    id(s, true, s)
}

proof fn s_prop1(x: S<int>, y: S<int>) {
    assert(s_property(x) == s_property(y));
}

proof fn s_prop2<C>(x: S<C>, y: S<C>) {
    assert(s_property(x) == s_property(y));
}

#[verifier::opaque]
spec fn g<A>(a: A) -> A {
    a
}

proof fn test_g1(u: u8) {
    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?
    assert(g(u) == u);
}

proof fn test_g2(u: u8) {
    assert(g(u) < 256 as int);
}

} // verus!
","['use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n    requires\n        f(a, c),\n    ensures\n        f(r, a),\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n    ensures\n        f(r, id_u64(i)),\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n    assert(s_property(x) == s_property(y));\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n    assert(s_property(x) == s_property(y));\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n    assert(g(u) == u);\n}\n\nproof fn test_g2(u: u8) {\n    assert(g(u) < 256 as int);\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/assert_by_compute.rs,89,6,0.06741573033707865,155.649,True,0.5,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::seq::', 'vstd::compute::RangeAll']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::seq::*;

fn main() {}

verus! {

// ANCHOR: pow_concrete
// Naive definition of exponentiation
spec fn pow(base: nat, exp: nat) -> nat
    decreases exp,
{
    if exp == 0 {
        1
    } else {
        base * pow(base, (exp - 1) as nat)
    }
}

proof fn concrete_pow() {
    assert(pow(2, 8) == 256) by (compute);  // Assertion 1
    assert(pow(2, 9) == 512);  // Assertion 2
    assert(pow(2, 8) == 256) by (compute_only);  // Assertion 3
}
// ANCHOR_END: pow_concrete

/*
// ANCHOR: let_fails
let x = 2;
assert(pow(2, x) == 4) by (compute_only);
// ANCHOR_END: let_fails
*/

// ANCHOR: let_passes
proof fn let_passes() {
    assert({
        let x = 2;
        pow(2, x) == 4
    }) by (compute_only);
}
// ANCHOR_END: let_passes

// ANCHOR: seq_example
proof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {
    assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);
}
// ANCHOR_END: seq_example

// ANCHOR: fibonacci_memoize
#[verifier::memoize]
spec fn fibonacci(n: nat) -> nat
    decreases n
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)
    }
}

proof fn test_fibonacci() {
    assert(fibonacci(63) == 6557470319842) by(compute_only);
}
// ANCHOR_END: fibonacci_memoize

// ANCHOR: all_spec
use vstd::compute::RangeAll;

spec fn p(u: usize) -> bool {
    u >> 8 == 0
}

proof fn range_property(u: usize)
    requires 25 <= u < 100,
    ensures p(u),
{
    assert((25..100int).all_spec(|x| p(x as usize))) by (compute_only);
    let prop = |x| p(x as usize);
    assert(prop(u));
}
// ANCHOR_END: all_spec

} // verus!
","use verus_builtin::*;
     use verus_builtin_macros::*;
      fn main() {
    }
      verus! {
     }
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::seq::*;\n\nfn main() {}\n\nverus! {\n\n// ANCHOR: pow_concrete\n// Naive definition of exponentiation\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp,\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nproof fn concrete_pow() {\n    assert(pow(2, 8) == 256) by (compute);  // Assertion 1\n    assert(pow(2, 9) == 512);  // Assertion 2\n    assert(pow(2, 8) == 256) by (compute_only);  // Assertion 3\n}\n// ANCHOR_END: pow_concrete\n\n/*\n// ANCHOR: let_fails\nlet x = 2;\nassert(pow(2, x) == 4) by (compute_only);\n// ANCHOR_END: let_fails\n*/\n\n// ANCHOR: let_passes\nproof fn let_passes() {\n    assert({\n        let x = 2;\n        pow(2, x) == 4\n    }) by (compute_only);\n}\n// ANCHOR_END: let_passes\n\n// ANCHOR: seq_example\nproof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {\n    assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n}\n// ANCHOR_END: seq_example\n\n// ANCHOR: fibonacci_memoize\n#[verifier::memoize]\nspec fn fibonacci(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)\n    }\n}\n\nproof fn test_fibonacci() {\n    assert(fibonacci(63) == 6557470319842) by(compute_only);\n}\n// ANCHOR_END: fibonacci_memoize\n\n// ANCHOR: all_spec\nuse vstd::compute::RangeAll;\n\nspec fn p(u: usize) -> bool {\n    u >> 8 == 0\n}\n\nproof fn range_property(u: usize)\n    requires 25 <= u < 100,\n    ensures p(u),\n{\n    assert((25..100int).all_spec(|x| p(x as usize))) by (compute_only);\n    let prop = |x| p(x as usize);\n    assert(prop(u));\n}\n// ANCHOR_END: all_spec\n\n} // verus!\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n     use verus_builtin_macros::*;\n      fn main() {\n    }\n      verus! {\n     }\n', 'use verus_builtin::*;\n             fn main() {\n   }\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/bst_map.rs,341,341,1.0,123.37,True,0.85,True,['vstd::prelude::'],True,,,True,,,"// ANCHOR: all
use vstd::prelude::*;

verus!{

// ANCHOR: StructsDef
struct Node<V> {
    key: u64,
    value: V,
    left: Option<Box<Node<V>>>,
    right: Option<Box<Node<V>>>,
}

pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,
}
// ANCHOR_END: StructsDef

// ANCHOR: AsMapDef
impl<V> Node<V> {
    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }

    spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
        Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }
}

impl<V> TreeMap<V> {
    pub closed spec fn as_map(self) -> Map<u64, V> {
        Node::<V>::optional_as_map(self.root)
    }
}
// ANCHOR_END: AsMapDef

// ANCHOR: ViewDef
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    open spec fn view(&self) -> Map<u64, V> {
        self.as_map()
    }
}
// ANCHOR_END: ViewDef

// ANCHOR: WellFormedDef
impl<V> Node<V> {
    spec fn well_formed(self) -> bool
        decreases self,
    {
        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
        &&& (match self.left {
            Some(left_node) => left_node.well_formed(),
            None => true,
        })
        &&& (match self.right {
            Some(right_node) => right_node.well_formed(),
            None => true,
        })
    }
}

impl<V> TreeMap<V> {
    pub closed spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true, // empty tree always well-formed
        }
    }
}
// ANCHOR_END: WellFormedDef

// ANCHOR: new
impl<V> TreeMap<V> {
// ANCHOR: new_signature
    pub fn new() -> (tree_map: Self)
        ensures
            tree_map.well_formed(),
            tree_map@ == Map::<u64, V>::empty(),
// ANCHOR_END: new_signature
    {
        TreeMap::<V> { root: None }
    }
}
// ANCHOR_END: new

// ANCHOR: insert
impl<V> Node<V> {
    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),
        decreases *old(node),
    {
        match node.take() {
            None => {
                *node = Some(Box::new(Node::<V> {
                    key: key,
                    value: value,
                    left: None,
                    right: None,
                }));
            }
            Some(mut boxed_node) => {
                (&mut *boxed_node).insert(key, value);
                *node = Some(boxed_node);
            }
        }
    }

    fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.as_map() =~= old(self).as_map().insert(key, value),
        decreases *old(self),
    {
        if key == self.key {
            self.value = value;

            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            Self::insert_into_optional(&mut self.left, key, value);

            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            Self::insert_into_optional(&mut self.right, key, value);

            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }
}

impl<V> TreeMap<V> {
// ANCHOR: insert_signature
    pub fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self@ == old(self)@.insert(key, value),
// ANCHOR_END: insert_signature
    {
        Node::<V>::insert_into_optional(&mut self.root, key, value);
    }
}
// ANCHOR_END: insert

// ANCHOR: delete
impl<V> Node<V> {
    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),
        decreases *old(node),
    {
        if let Some(mut boxed_node) = node.take() {

            if key == boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        *node = boxed_node.left;
                    } else {
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
        requires
            old(node).is_some(),
            old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,
        decreases *old(node),
    {
        let mut boxed_node = node.take().unwrap();

        if boxed_node.right.is_none() {
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            return (boxed_node.key, boxed_node.value);
        } else {
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            *node = Some(boxed_node);
            return (popped_key, popped_value);
        }
    }
}

impl<V> TreeMap<V> {
// ANCHOR: delete_signature
    pub fn delete(&mut self, key: u64)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self@ == old(self)@.remove(key),
// ANCHOR_END: delete_signature
    {
        Node::<V>::delete_from_optional(&mut self.root, key);
    }
}
// ANCHOR_END: delete

// ANCHOR: get
impl<V> Node<V> {
    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>
        requires
            node.is_some() ==> node.unwrap().well_formed(),
        returns
            (match node {
                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),
                None => None,
            }),
        decreases node,
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    fn get(&self, key: u64) -> Option<&V>
        requires
            self.well_formed(),
        returns
            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),
        decreases self,
    {
        if key == self.key {
            Some(&self.value)
        } else if key < self.key {
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

impl<V> TreeMap<V> {
// ANCHOR: get_signature
    pub fn get(&self, key: u64) -> Option<&V>
        requires
            self.well_formed(),
        returns
            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),
// ANCHOR_END: get_signature
    {
        Node::<V>::get_from_optional(&self.root, key)
    }
}
// ANCHOR_END: get

// ANCHOR: test
fn test() {
    let mut tree_map = TreeMap::<bool>::new();
    tree_map.insert(17, false);
    tree_map.insert(18, false);
    tree_map.insert(17, true);

    assert(tree_map@ == map![17u64 => true, 18u64 => false]);

    tree_map.delete(17);

    assert(tree_map@ == map![18u64 => false]);

    let elem17 = tree_map.get(17);
    let elem18 = tree_map.get(18);
    assert(elem17.is_none());
    assert(elem18 == Some(&false));
}
// ANCHOR_END: test

// ANCHOR: test_callee
fn test2() {
    let mut tree_map = TreeMap::<bool>::new();
    test_callee(tree_map);
}

fn test_callee(tree_map: TreeMap<bool>)
    requires
        tree_map.well_formed(),
{
    let mut tree_map = tree_map;
    tree_map.insert(25, true);
    tree_map.insert(100, true);
}
// ANCHOR_END: test_callee


}
// ANCHOR_END: all

fn main() { }

","// ANCHOR: all
use vstd::prelude::*;

verus!{

// ANCHOR: StructsDef
struct Node<V> {
    key: u64,
    value: V,
    left: Option<Box<Node<V>>>,
    right: Option<Box<Node<V>>>,
}

pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,
}
// ANCHOR_END: StructsDef

// ANCHOR: AsMapDef
impl<V> Node<V> {
    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }

    spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
        Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }
}

impl<V> TreeMap<V> {
    pub closed spec fn as_map(self) -> Map<u64, V> {
        Node::<V>::optional_as_map(self.root)
    }
}
// ANCHOR_END: AsMapDef

// ANCHOR: ViewDef
impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    open spec fn view(&self) -> Map<u64, V> {
        self.as_map()
    }
}
// ANCHOR_END: ViewDef

// ANCHOR: WellFormedDef
impl<V> Node<V> {
    spec fn well_formed(self) -> bool
        decreases self,
    {
        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
        &&& (match self.left {
            Some(left_node) => left_node.well_formed(),
            None => true,
        })
        &&& (match self.right {
            Some(right_node) => right_node.well_formed(),
            None => true,
        })
    }
}

impl<V> TreeMap<V> {
    pub closed spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true, // empty tree always well-formed
        }
    }
}
// ANCHOR_END: WellFormedDef

// ANCHOR: new
impl<V> TreeMap<V> {
// ANCHOR: new_signature
    pub fn new() -> (tree_map: Self)
        ensures
            tree_map.well_formed(),
            tree_map@ == Map::<u64, V>::empty(),
// ANCHOR_END: new_signature
    {
        TreeMap::<V> { root: None }
    }
}
// ANCHOR_END: new

// ANCHOR: insert
impl<V> Node<V> {
    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),
        decreases *old(node),
    {
        match node.take() {
            None => {
                *node = Some(Box::new(Node::<V> {
                    key: key,
                    value: value,
                    left: None,
                    right: None,
                }));
            }
            Some(mut boxed_node) => {
                (&mut *boxed_node).insert(key, value);
                *node = Some(boxed_node);
            }
        }
    }

    fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.as_map() =~= old(self).as_map().insert(key, value),
        decreases *old(self),
    {
        if key == self.key {
            self.value = value;

            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            Self::insert_into_optional(&mut self.left, key, value);

            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            Self::insert_into_optional(&mut self.right, key, value);

            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }
}

impl<V> TreeMap<V> {
// ANCHOR: insert_signature
    pub fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self@ == old(self)@.insert(key, value),
// ANCHOR_END: insert_signature
    {
        Node::<V>::insert_into_optional(&mut self.root, key, value);
    }
}
// ANCHOR_END: insert

// ANCHOR: delete
impl<V> Node<V> {
    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),
        decreases *old(node),
    {
        if let Some(mut boxed_node) = node.take() {

            if key == boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        *node = boxed_node.left;
                    } else {
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
        requires
            old(node).is_some(),
            old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,
        decreases *old(node),
    {
        let mut boxed_node = node.take().unwrap();

        if boxed_node.right.is_none() {
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            return (boxed_node.key, boxed_node.value);
        } else {
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            *node = Some(boxed_node);
            return (popped_key, popped_value);
        }
    }
}

impl<V> TreeMap<V> {
// ANCHOR: delete_signature
    pub fn delete(&mut self, key: u64)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self@ == old(self)@.remove(key),
// ANCHOR_END: delete_signature
    {
        Node::<V>::delete_from_optional(&mut self.root, key);
    }
}
// ANCHOR_END: delete

// ANCHOR: get
impl<V> Node<V> {
    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>
        requires
            node.is_some() ==> node.unwrap().well_formed(),
        returns
            (match node {
                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),
                None => None,
            }),
        decreases node,
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    fn get(&self, key: u64) -> Option<&V>
        requires
            self.well_formed(),
        returns
            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),
        decreases self,
    {
        if key == self.key {
            Some(&self.value)
        } else if key < self.key {
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

impl<V> TreeMap<V> {
// ANCHOR: get_signature
    pub fn get(&self, key: u64) -> Option<&V>
        requires
            self.well_formed(),
        returns
            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),
// ANCHOR_END: get_signature
    {
        Node::<V>::get_from_optional(&self.root, key)
    }
}
// ANCHOR_END: get

// ANCHOR: test
fn test() {
    let mut tree_map = TreeMap::<bool>::new();
    tree_map.insert(17, false);
    tree_map.insert(18, false);
    tree_map.insert(17, true);

    assert(tree_map@ == map![17u64 => true, 18u64 => false]);

    tree_map.delete(17);

    assert(tree_map@ == map![18u64 => false]);

    let elem17 = tree_map.get(17);
    let elem18 = tree_map.get(18);
    assert(elem17.is_none());
    assert(elem18 == Some(&false));
}
// ANCHOR_END: test

// ANCHOR: test_callee
fn test2() {
    let mut tree_map = TreeMap::<bool>::new();
    test_callee(tree_map);
}

fn test_callee(tree_map: TreeMap<bool>)
    requires
        tree_map.well_formed(),
{
    let mut tree_map = tree_map;
    tree_map.insert(25, true);
    tree_map.insert(100, true);
}
// ANCHOR_END: test_callee


}
// ANCHOR_END: all

fn main() { }

","['// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self,\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/bst_map_type_invariant.rs,335,335,1.0,154.541,True,0.85,True,['vstd::prelude::'],True,,,True,,,"// ANCHOR: all
use vstd::prelude::*;

verus!{

struct Node<V> {
    key: u64,
    value: V,
    left: Option<Box<Node<V>>>,
    right: Option<Box<Node<V>>>,
}

pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,
}

impl<V> Node<V> {
    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }

    spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
        Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }
}

impl<V> TreeMap<V> {
    pub closed spec fn as_map(self) -> Map<u64, V> {
        Node::<V>::optional_as_map(self.root)
    }
}

impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    open spec fn view(&self) -> Map<u64, V> {
        self.as_map()
    }
}

impl<V> Node<V> {
    spec fn well_formed(self) -> bool
        decreases self
    {
        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
        &&& (match self.left {
            Some(left_node) => left_node.well_formed(),
            None => true,
        })
        &&& (match self.right {
            Some(right_node) => right_node.well_formed(),
            None => true,
        })
    }
}

// ANCHOR: well_formed_with_attr
impl<V> TreeMap<V> {
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true, // empty tree always well-formed
        }
    }
}
// ANCHOR_END: well_formed_with_attr

// ANCHOR: new
impl<V> TreeMap<V> {
// ANCHOR: new_signature
    pub fn new() -> (s: Self)
        ensures
            s@ == Map::<u64, V>::empty()
// ANCHOR_END: new_signature
    {
        TreeMap::<V> { root: None }
    }
}
// ANCHOR_END: new

impl<V> Node<V> {
    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),
        decreases *old(node),
    {
        if node.is_none() {
            *node = Some(Box::new(Node::<V> {
                key: key,
                value: value,
                left: None,
                right: None,
            }));
        } else {
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            (&mut *boxed_node).insert(key, value);

            *node = Some(boxed_node);
        }
    }

    fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.as_map() =~= old(self).as_map().insert(key, value),
        decreases *old(self),
    {
        if key == self.key {
            self.value = value;

            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            Self::insert_into_optional(&mut self.left, key, value);

            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            Self::insert_into_optional(&mut self.right, key, value);

            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }
}

// ANCHOR: insert
impl<V> TreeMap<V> {
// ANCHOR: insert_signature
    pub fn insert(&mut self, key: u64, value: V)
        ensures
            self@ == old(self)@.insert(key, value),
// ANCHOR_END: insert_signature
    {
        proof { use_type_invariant(&*self); }
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }
}
// ANCHOR_END: insert

impl<V> Node<V> {
    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),
        decreases *old(node),
    {
        if node.is_some() {
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if key == boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        *node = boxed_node.left;
                    } else {
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
        requires
            old(node).is_some(),
            old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,
        decreases *old(node),
    {
        let mut tmp = None;
        std::mem::swap(&mut tmp, node);
        let mut boxed_node = tmp.unwrap();

        if boxed_node.right.is_none() {
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            return (boxed_node.key, boxed_node.value);
        } else {
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            *node = Some(boxed_node);
            return (popped_key, popped_value);
        }
    }
}

// ANCHOR: delete
impl<V> TreeMap<V> {
// ANCHOR: delete_signature
    pub fn delete(&mut self, key: u64)
        ensures
            self@ == old(self)@.remove(key),
// ANCHOR_END: delete_signature
    {
        proof { use_type_invariant(&*self); }
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }
}
// ANCHOR_END: delete

impl<V> Node<V> {
    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>
        requires
            node.is_some() ==> node.unwrap().well_formed(),
        returns
            (match node {
                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),
                None => None,
            }),
        decreases node,
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    fn get(&self, key: u64) -> Option<&V>
        requires
            self.well_formed(),
        returns
            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),
        decreases self,
    {
        if key == self.key {
            Some(&self.value)
        } else if key < self.key {
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

// ANCHOR: get
impl<V> TreeMap<V> {
// ANCHOR: get_signature
    pub fn get(&self, key: u64) -> Option<&V>
        returns
            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),
// ANCHOR_END: get_signature
    {
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}
// ANCHOR_END: get

// ANCHOR: example_use
fn test() {
    let mut tree_map = TreeMap::<bool>::new();
    tree_map.insert(17, false);
    tree_map.insert(18, false);
    tree_map.insert(17, true);

    assert(tree_map@ == map![17u64 => true, 18u64 => false]);

    tree_map.delete(17);

    assert(tree_map@ == map![18u64 => false]);

    let elem17 = tree_map.get(17);
    let elem18 = tree_map.get(18);
    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    test2(tree_map);
}

fn test2(tree_map: TreeMap<bool>) {
    let mut tree_map = tree_map;
    tree_map.insert(25, true);
    tree_map.insert(100, true);
}
// ANCHOR_END: example_use


}
// ANCHOR_END: all

fn main() { }

","// ANCHOR: all
use vstd::prelude::*;

verus!{

struct Node<V> {
    key: u64,
    value: V,
    left: Option<Box<Node<V>>>,
    right: Option<Box<Node<V>>>,
}

pub struct TreeMap<V> {
    root: Option<Box<Node<V>>>,
}

impl<V> Node<V> {
    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>
        decreases node_opt,
    {
        match node_opt {
            None => Map::empty(),
            Some(node) => node.as_map(),
        }
    }

    spec fn as_map(self) -> Map<u64, V>
        decreases self,
    {
        Node::<V>::optional_as_map(self.left)
          .union_prefer_right(Node::<V>::optional_as_map(self.right))
          .insert(self.key, self.value)
    }
}

impl<V> TreeMap<V> {
    pub closed spec fn as_map(self) -> Map<u64, V> {
        Node::<V>::optional_as_map(self.root)
    }
}

impl<V> View for TreeMap<V> {
    type V = Map<u64, V>;

    open spec fn view(&self) -> Map<u64, V> {
        self.as_map()
    }
}

impl<V> Node<V> {
    spec fn well_formed(self) -> bool
        decreases self
    {
        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)
        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)
        &&& (match self.left {
            Some(left_node) => left_node.well_formed(),
            None => true,
        })
        &&& (match self.right {
            Some(right_node) => right_node.well_formed(),
            None => true,
        })
    }
}

// ANCHOR: well_formed_with_attr
impl<V> TreeMap<V> {
    #[verifier::type_invariant]
    spec fn well_formed(self) -> bool {
        match self.root {
            Some(node) => node.well_formed(),
            None => true, // empty tree always well-formed
        }
    }
}
// ANCHOR_END: well_formed_with_attr

// ANCHOR: new
impl<V> TreeMap<V> {
// ANCHOR: new_signature
    pub fn new() -> (s: Self)
        ensures
            s@ == Map::<u64, V>::empty()
// ANCHOR_END: new_signature
    {
        TreeMap::<V> { root: None }
    }
}
// ANCHOR_END: new

impl<V> Node<V> {
    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),
        decreases *old(node),
    {
        if node.is_none() {
            *node = Some(Box::new(Node::<V> {
                key: key,
                value: value,
                left: None,
                right: None,
            }));
        } else {
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            (&mut *boxed_node).insert(key, value);

            *node = Some(boxed_node);
        }
    }

    fn insert(&mut self, key: u64, value: V)
        requires
            old(self).well_formed(),
        ensures
            self.well_formed(),
            self.as_map() =~= old(self).as_map().insert(key, value),
        decreases *old(self),
    {
        if key == self.key {
            self.value = value;

            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else if key < self.key {
            Self::insert_into_optional(&mut self.left, key, value);

            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));
        } else {
            Self::insert_into_optional(&mut self.right, key, value);

            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));
        }
    }
}

// ANCHOR: insert
impl<V> TreeMap<V> {
// ANCHOR: insert_signature
    pub fn insert(&mut self, key: u64, value: V)
        ensures
            self@ == old(self)@.insert(key, value),
// ANCHOR_END: insert_signature
    {
        proof { use_type_invariant(&*self); }
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::insert_into_optional(&mut root, key, value);
        self.root = root;
    }
}
// ANCHOR_END: insert

impl<V> Node<V> {
    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)
        requires
            old(node).is_some() ==> old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),
        decreases *old(node),
    {
        if node.is_some() {
            let mut tmp = None;
            std::mem::swap(&mut tmp, node);
            let mut boxed_node = tmp.unwrap();

            if key == boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));

                if boxed_node.left.is_none() {
                    *node = boxed_node.right;
                } else {
                    if boxed_node.right.is_none() {
                        *node = boxed_node.left;
                    } else {
                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);
                        boxed_node.key = popped_key;
                        boxed_node.value = popped_value;
                        *node = Some(boxed_node);
                    }
                }
            } else if key < boxed_node.key {
                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.left, key);
                *node = Some(boxed_node);
            } else {
                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));
                Node::<V>::delete_from_optional(&mut boxed_node.right, key);
                *node = Some(boxed_node);
            }
        }
    }

    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))
        requires
            old(node).is_some(),
            old(node).unwrap().well_formed(),
        ensures
            node.is_some() ==> node.unwrap().well_formed(),
            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),
            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),
            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,
            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,
        decreases *old(node),
    {
        let mut tmp = None;
        std::mem::swap(&mut tmp, node);
        let mut boxed_node = tmp.unwrap();

        if boxed_node.right.is_none() {
            *node = boxed_node.left;
            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));
            return (boxed_node.key, boxed_node.value);
        } else {
            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);
            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));
            *node = Some(boxed_node);
            return (popped_key, popped_value);
        }
    }
}

// ANCHOR: delete
impl<V> TreeMap<V> {
// ANCHOR: delete_signature
    pub fn delete(&mut self, key: u64)
        ensures
            self@ == old(self)@.remove(key),
// ANCHOR_END: delete_signature
    {
        proof { use_type_invariant(&*self); }
        let mut root = None;
        std::mem::swap(&mut root, &mut self.root);
        Node::<V>::delete_from_optional(&mut root, key);
        self.root = root;
    }
}
// ANCHOR_END: delete

impl<V> Node<V> {
    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>
        requires
            node.is_some() ==> node.unwrap().well_formed(),
        returns
            (match node {
                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),
                None => None,
            }),
        decreases node,
    {
        match node {
            None => None,
            Some(node) => {
                node.get(key)
            }
        }
    }

    fn get(&self, key: u64) -> Option<&V>
        requires
            self.well_formed(),
        returns
            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),
        decreases self,
    {
        if key == self.key {
            Some(&self.value)
        } else if key < self.key {
            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }
            Self::get_from_optional(&self.left, key)
        } else {
            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }
            Self::get_from_optional(&self.right, key)
        }
    }
}

// ANCHOR: get
impl<V> TreeMap<V> {
// ANCHOR: get_signature
    pub fn get(&self, key: u64) -> Option<&V>
        returns
            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),
// ANCHOR_END: get_signature
    {
        proof { use_type_invariant(&*self); }
        Node::<V>::get_from_optional(&self.root, key)
    }
}
// ANCHOR_END: get

// ANCHOR: example_use
fn test() {
    let mut tree_map = TreeMap::<bool>::new();
    tree_map.insert(17, false);
    tree_map.insert(18, false);
    tree_map.insert(17, true);

    assert(tree_map@ == map![17u64 => true, 18u64 => false]);

    tree_map.delete(17);

    assert(tree_map@ == map![18u64 => false]);

    let elem17 = tree_map.get(17);
    let elem18 = tree_map.get(18);
    assert(elem17.is_none());
    assert(elem18 == Some(&false));

    test2(tree_map);
}

fn test2(tree_map: TreeMap<bool>) {
    let mut tree_map = tree_map;
    tree_map.insert(25, true);
    tree_map.insert(100, true);
}
// ANCHOR_END: example_use


}
// ANCHOR_END: all

fn main() { }

","['// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        ensures\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n        verus!{}\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/const.rs,91,91,1.0,183.433,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::layout']",True,,,,,,"// rust_verify/tests/example.rs expect-success
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: spec_const
spec const SPEC_ONE: int = 1;

spec fn spec_add_one(x: int) -> int {
    x + SPEC_ONE
}

// ANCHOR_END: spec_const
// ANCHOR: exec_const_syntax
exec const C: u64
    ensures
        C == 7,
{
    7
}

// ANCHOR_END: exec_const_syntax
// ANCHOR: exec_const_complicated
spec fn f() -> int {
    1
}

const fn e() -> (u: u64)
    ensures
        u == f(),
{
    1
}

exec const E: u64
    ensures
        E == 2,
{
    assert(f() == 1);
    1 + e()
}

// ANCHOR_END: exec_const_complicated
// ANCHOR: spec_exec_const
const ONE: u8 = 1;

fn add_one(x: u8) -> (ret: u8)
    requires
        x < 0xff,
    ensures
        ret == x + ONE,  // use ""ONE"" in spec code
{
    x + ONE  // use ""ONE"" in exec code

}

// ANCHOR_END: spec_exec_const
// ANCHOR: when_used_as_spec
use vstd::layout;

global layout usize is size == 8;

spec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();

#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]
exec const USIZE_BYTES: usize
    ensures
        USIZE_BYTES as nat == layout::size_of::<usize>(),
{
    8
}

// ANCHOR_END: when_used_as_spec
// ANCHOR: nonlinear
pub const FOO: u8 = 4;

pub const BAR: u8 = FOO;

pub const BAR_PLUS_ONE: u8 = BAR + 1;

#[verifier::nonlinear]
pub const G: u8 = BAR_PLUS_ONE * BAR;

// ANCHOR_END: nonlinear
fn main() {
}

} // verus!
","// rust_verify/tests/example.rs expect-success
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: spec_const
spec const SPEC_ONE: int = 1;

spec fn spec_add_one(x: int) -> int {
    x + SPEC_ONE
}

// ANCHOR_END: spec_const
// ANCHOR: exec_const_syntax
exec const C: u64
    ensures
        C == 7,
{
    7
}

// ANCHOR_END: exec_const_syntax
// ANCHOR: exec_const_complicated
spec fn f() -> int {
    1
}

const fn e() -> (u: u64)
    ensures
        u == f(),
{
    1
}

exec const E: u64
    ensures
        E == 2,
{
    assert(f() == 1);
    1 + e()
}

// ANCHOR_END: exec_const_complicated
// ANCHOR: spec_exec_const
const ONE: u8 = 1;

fn add_one(x: u8) -> (ret: u8)
    requires
        x < 0xff,
    ensures
        ret == x + ONE,  // use ""ONE"" in spec code
{
    x + ONE  // use ""ONE"" in exec code

}

// ANCHOR_END: spec_exec_const
// ANCHOR: when_used_as_spec
use vstd::layout;

global layout usize is size == 8;

spec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();

#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]
exec const USIZE_BYTES: usize
    ensures
        USIZE_BYTES as nat == layout::size_of::<usize>(),
{
    8
}

// ANCHOR_END: when_used_as_spec
// ANCHOR: nonlinear
pub const FOO: u8 = 4;

pub const BAR: u8 = FOO;

pub const BAR_PLUS_ONE: u8 = BAR + 1;

#[verifier::nonlinear]
pub const G: u8 = BAR_PLUS_ONE * BAR;

// ANCHOR_END: nonlinear
fn main() {
}

} // verus!
","['// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use ""ONE"" in spec code\n{\n    x + ONE  // use ""ONE"" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/datatypes.rs,130,130,1.0,153.169,True,0.9,False,"['verus_builtin::', 'verus_builtin_macros::', 'Life::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: point
struct Point {
    x: int,
    y: int,
}
// ANCHOR_END: point

// ANCHOR: point-impl
impl Point {
    spec fn len2(&self) -> int {
        self.x * self.x + self.y * self.y
    }
}

fn rotate_90(p: Point) -> (o: Point)
    ensures o.len2() == p.len2()
{
    let o = Point { x: -p.y, y: p.x };
    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);
    o
}
// ANCHOR_END: point-impl

// ANCHOR: beverage
enum Beverage {
    Coffee { creamers: nat, sugar: bool },
    Soda { flavor: Syrup },
    Water { ice: bool },
}
// ANCHOR_END: beverage

// ANCHOR: syrup
enum Syrup {
    Cola,
    RootBeer,
    Orange,
    LemonLime,
}
// ANCHOR_END: syrup

struct Dessert {}
impl Dessert {
    fn new() -> Dessert {
        Dessert {}
    }
}

// ANCHOR: make_float
fn make_float(bev: Beverage) -> Dessert
    requires bev is Soda
{
    assert(bev !is Coffee);
    Dessert::new(/*...*/)
}
// ANCHOR_END: make_float

// ANCHOR: count_creamers
proof fn sufficiently_creamy(bev: Beverage) -> bool
    requires bev is Coffee
{
   bev->creamers >= 2
}
// ANCHOR_END: count_creamers

// ANCHOR: life
enum Life {
    Mammal { legs: int, has_pocket: bool },
    Arthropod { legs: int, wings: int },
    Plant { leaves: int },
}

spec fn is_insect(l: Life) -> bool
{
    l is Arthropod && l->Arthropod_legs == 6
}
// ANCHOR_END: life

// ANCHOR: shape
enum Shape {
    Circle(int),
    Rect(int, int),
}

spec fn area_2(s: Shape) -> int {
    match s {
        Shape::Circle(radius) => { radius * radius * 3 },
        Shape::Rect(width, height) => { width * height }
    }
}
// ANCHOR_END: shape

// ANCHOR: rect_height
spec fn rect_height(s: Shape) -> int
    recommends s is Rect
{
    s->1
}
// ANCHOR_END: rect_height

// ANCHOR: cuddly
use Life::*;
spec fn cuddly(l: Life) -> bool {
    ||| l matches Mammal { legs, .. } && legs == 4
    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0
}
// ANCHOR_END: cuddly

// ANCHOR: kangaroo
spec fn is_kangaroo(l: Life) -> bool {
    &&& l matches Life::Mammal { legs, has_pocket }
    &&& legs == 2
    &&& has_pocket
}

spec fn walks_upright(l: Life) -> bool {
    l matches Life::Mammal { legs, .. } ==> legs == 2
}
// ANCHOR_END: kangaroo

fn main() {
}

} // verus!
","#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: point
struct Point {
    x: int,
    y: int,
}
// ANCHOR_END: point

// ANCHOR: point-impl
impl Point {
    spec fn len2(&self) -> int {
        self.x * self.x + self.y * self.y
    }
}

fn rotate_90(p: Point) -> (o: Point)
    ensures o.len2() == p.len2()
{
    let o = Point { x: -p.y, y: p.x };
    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);
    o
}
// ANCHOR_END: point-impl

// ANCHOR: beverage
enum Beverage {
    Coffee { creamers: nat, sugar: bool },
    Soda { flavor: Syrup },
    Water { ice: bool },
}
// ANCHOR_END: beverage

// ANCHOR: syrup
enum Syrup {
    Cola,
    RootBeer,
    Orange,
    LemonLime,
}
// ANCHOR_END: syrup

struct Dessert {}
impl Dessert {
    fn new() -> Dessert {
        Dessert {}
    }
}

// ANCHOR: make_float
fn make_float(bev: Beverage) -> Dessert
    requires bev is Soda
{
    assert(bev !is Coffee);
    Dessert::new(/*...*/)
}
// ANCHOR_END: make_float

// ANCHOR: count_creamers
proof fn sufficiently_creamy(bev: Beverage) -> bool
    requires bev is Coffee
{
   bev->creamers >= 2
}
// ANCHOR_END: count_creamers

// ANCHOR: life
enum Life {
    Mammal { legs: int, has_pocket: bool },
    Arthropod { legs: int, wings: int },
    Plant { leaves: int },
}

spec fn is_insect(l: Life) -> bool
{
    l is Arthropod && l->Arthropod_legs == 6
}
// ANCHOR_END: life

// ANCHOR: shape
enum Shape {
    Circle(int),
    Rect(int, int),
}

spec fn area_2(s: Shape) -> int {
    match s {
        Shape::Circle(radius) => { radius * radius * 3 },
        Shape::Rect(width, height) => { width * height }
    }
}
// ANCHOR_END: shape

// ANCHOR: rect_height
spec fn rect_height(s: Shape) -> int
    recommends s is Rect
{
    s->1
}
// ANCHOR_END: rect_height

// ANCHOR: cuddly
use Life::*;
spec fn cuddly(l: Life) -> bool {
    ||| l matches Mammal { legs, .. } && legs == 4
    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0
}
// ANCHOR_END: cuddly

// ANCHOR: kangaroo
spec fn is_kangaroo(l: Life) -> bool {
    &&& l matches Life::Mammal { legs, has_pocket }
    &&& legs == 2
    &&& has_pocket
}

spec fn walks_upright(l: Life) -> bool {
    l matches Life::Mammal { legs, .. } ==> legs == 2
}
// ANCHOR_END: kangaroo

fn main() {
}

} // verus!
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/exec_attr.rs,123,123,1.0,0.628,False,0.6,True,['vstd::prelude::'],True,,,,,,"#![feature(proc_macro_hygiene)]

use vstd::prelude::*;

// ANCHOR: verus_spec
#[verus_spec(sum => 
     requires 
         x < 100, 
         y < 100, 
     ensures 
         sum < 200, 
)]
fn my_exec_fun(x: u32, y: u32) -> u32 
{ 
    x + y 
}
// ANCHOR_END: verus_spec

// ANCHOR: loop
#[verus_spec(v => ensures true)]
fn test_for_loop(n: u32) -> Vec<u32> {
    let mut v: Vec<u32> = Vec::new();

    #[verus_spec(
       invariant
           v@ =~= Seq::new(i as nat, |k| k as u32),
    )]
    for i in 0..n {
        v.push(i);
    }
    v
}
// ANCHOR_END: loop

// ANCHOR: proof
#[verus_spec]
fn exec_with_proof() {
   proof_decl!{
     let ghost mut i = 0int;
     assert(true);
   }
   test_for_loop(10);
   proof!{
     assert(i == 0);
   }
}
// ANCHOR_END: proof

// ANCHOR: proof_with
#[verus_spec(ret =>
with
  Tracked(y): Tracked<&mut u32>,
  Ghost(w): Ghost<u32> 
     -> z: Ghost<u32>
requires
  x < 100,
  *old(y) < 100,
ensures
  *y == x,
  ret == x + 1,
  z@ == x,
)]
fn exec_tracked(x: u32) -> u32 {
  proof! {
    *y = x;
  }
  proof_with!(|= Ghost(x));
  (x + 1)
}


#[verus_spec]
fn exec_tracked_test(x: u32) {
  proof_decl!{
    let ghost mut z = 0u32;
    let tracked mut y = 0u32;
  }

  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}
  let x = exec_tracked(1);

  proof!{
    assert(y == 1);
    assert(z == 1);
    assert(x == 2);
  }
}

fn exec_external_test(x: u32) -> u32 {
   exec_tracked(1)
}

// ANCHOR_END: proof_with

// ANCHOR: dual_spec
#[verus_verify(dual_spec)]
#[verus_spec(
    requires
        x < 100,
        y < 100,
    returns f(x, y)
)]
fn f(x: u32, y: u32) -> u32 {
    proof!{
        assert(true);
    }
    {
        proof!{assert(true);}
        x + y
    }
}

#[verus_verify(dual_spec)]
#[verus_spec(
    requires
        x < 100,
    returns
        f2(x),
)]
pub fn f2(x: u32) -> u32 {
    f(x, 1)
}
// ANCHOR_END: dual_spec
","#![feature(proc_macro_hygiene)]

use vstd::prelude::*;

// ANCHOR: verus_spec
#[verus_spec(sum => 
     requires 
         x < 100, 
         y < 100, 
     ensures 
         sum < 200, 
)]
fn my_exec_fun(x: u32, y: u32) -> u32 
{ 
    x + y 
}
// ANCHOR_END: verus_spec

// ANCHOR: loop
#[verus_spec(v => ensures true)]
fn test_for_loop(n: u32) -> Vec<u32> {
    let mut v: Vec<u32> = Vec::new();

    #[verus_spec(
       invariant
           v@ =~= Seq::new(i as nat, |k| k as u32),
    )]
    for i in 0..n {
        v.push(i);
    }
    v
}
// ANCHOR_END: loop

// ANCHOR: proof
#[verus_spec]
fn exec_with_proof() {
   proof_decl!{
     let ghost mut i = 0int;
     assert(true);
   }
   test_for_loop(10);
   proof!{
     assert(i == 0);
   }
}
// ANCHOR_END: proof

// ANCHOR: proof_with
#[verus_spec(ret =>
with
  Tracked(y): Tracked<&mut u32>,
  Ghost(w): Ghost<u32> 
     -> z: Ghost<u32>
requires
  x < 100,
  *old(y) < 100,
ensures
  *y == x,
  ret == x + 1,
  z@ == x,
)]
fn exec_tracked(x: u32) -> u32 {
  proof! {
    *y = x;
  }
  proof_with!(|= Ghost(x));
  (x + 1)
}


#[verus_spec]
fn exec_tracked_test(x: u32) {
  proof_decl!{
    let ghost mut z = 0u32;
    let tracked mut y = 0u32;
  }

  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}
  let x = exec_tracked(1);

  proof!{
    assert(y == 1);
    assert(z == 1);
    assert(x == 2);
  }
}

fn exec_external_test(x: u32) -> u32 {
   exec_tracked(1)
}

// ANCHOR_END: proof_with

// ANCHOR: dual_spec
#[verus_verify(dual_spec)]
#[verus_spec(
    requires
        x < 100,
        y < 100,
    returns f(x, y)
)]
fn f(x: u32, y: u32) -> u32 {
    proof!{
        assert(true);
    }
    {
        proof!{assert(true);}
        x + y
    }
}

#[verus_verify(dual_spec)]
#[verus_spec(
    requires
        x < 100,
    returns
        f2(x),
)]
pub fn f2(x: u32) -> u32 {
    f(x, 1)
}
// ANCHOR_END: dual_spec
",[]
/Users/ameliakuang/Repos/dep_verus/examples/guide/ext_equal.rs,86,86,1.0,246.677,True,0.9999999999999999,True,['vstd::'],True,,,,,,"#[allow(unused_imports)]
use vstd::{map::*, prelude::*, seq::*, set::*};

verus! {

mod m1 {
    #[allow(unused_imports)]


    use vstd::{seq::*, set::*, map::*, prelude::*};

    // ANCHOR: ext_eq_struct_fields
    struct Foo {
        a: Seq<int>,
        b: Set<int>,
    }

    proof fn ext_equal_struct() {
        let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };
        let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };
        // assert(f1 == f2);    // FAILS -- need to use =~= first
        assert(f1.a =~= f2.a);  // succeeds
        assert(f1.b =~= f2.b);  // succeeds
        assert(f1 == f2);  // succeeds, now that we've used =~= on .a and .b
    }
    // ANCHOR_END: ext_eq_struct_fields

}

// ANCHOR: ext_eq_struct
#[verifier::ext_equal]  // necessary for invoking =~= on the struct
struct Foo {
    a: Seq<int>,
    b: Set<int>,
}

proof fn ext_equal_struct() {
    let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };
    let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };
    assert(f1 =~= f2);  // succeeds
}
// ANCHOR_END: ext_eq_struct

// ANCHOR: ext_eq_nested
proof fn ext_equal_nested() {
    let inner: Set<int> = set!{1, 2, 3};
    let s1: Seq<Set<int>> = seq![inner];
    let s2 = s1.update(0, s1[0].insert(1));
    let s3 = s1.update(0, s1[0].insert(2).insert(3));
    // assert(s2 =~= s3); // FAILS
    assert(s2 =~~= s3);  // succeeds
    let s4: Seq<Seq<Set<int>>> = seq![s1];
    let s5: Seq<Seq<Set<int>>> = seq![s2];
    assert(s4 =~~= s5);  // succeeds
}
// ANCHOR_END: ext_eq_nested

// ANCHOR: ext_eq_fnspec
#[verifier::ext_equal]  // necessary for invoking =~= on the struct
struct Bar {
    a: spec_fn(int) -> int,
}

proof fn ext_equal_fnspec(n: int) {
    // basic case
    let f1 = (|i: int| i + 1);
    let f2 = (|i: int| 1 + i);
    assert(f1 =~= f2);  // succeeds
    // struct case
    let b1 = Bar { a: |i: int| if i == 1 { i } else { 1 } };
    let b2 = Bar { a: |i: int| 1int };
    assert(b1 =~= b2);  // succeeds
    // nested case
    let i1 = (|i: int| i + 2);
    let i2 = (|i: int| 2 + i);
    let n1: Seq<spec_fn(int) -> int> = seq![i1];
    let n2: Seq<spec_fn(int) -> int> = seq![i2];
    // assert(n1 =~= n2); // FAILS
    assert(n1 =~~= n2);  // succeeds
}
// ANCHOR_END: ext_eq_fnspec

fn main() {
}

} // verus!
","#[allow(unused_imports)]
use vstd::{map::*, prelude::*, seq::*, set::*};

verus! {

mod m1 {
    #[allow(unused_imports)]


    use vstd::{seq::*, set::*, map::*, prelude::*};

    // ANCHOR: ext_eq_struct_fields
    struct Foo {
        a: Seq<int>,
        b: Set<int>,
    }

    proof fn ext_equal_struct() {
        let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };
        let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };
        // assert(f1 == f2);    // FAILS -- need to use =~= first
        assert(f1.a =~= f2.a);  // succeeds
        assert(f1.b =~= f2.b);  // succeeds
        assert(f1 == f2);  // succeeds, now that we've used =~= on .a and .b
    }
    // ANCHOR_END: ext_eq_struct_fields

}

// ANCHOR: ext_eq_struct
#[verifier::ext_equal]  // necessary for invoking =~= on the struct
struct Foo {
    a: Seq<int>,
    b: Set<int>,
}

proof fn ext_equal_struct() {
    let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };
    let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };
    assert(f1 =~= f2);  // succeeds
}
// ANCHOR_END: ext_eq_struct

// ANCHOR: ext_eq_nested
proof fn ext_equal_nested() {
    let inner: Set<int> = set!{1, 2, 3};
    let s1: Seq<Set<int>> = seq![inner];
    let s2 = s1.update(0, s1[0].insert(1));
    let s3 = s1.update(0, s1[0].insert(2).insert(3));
    // assert(s2 =~= s3); // FAILS
    assert(s2 =~~= s3);  // succeeds
    let s4: Seq<Seq<Set<int>>> = seq![s1];
    let s5: Seq<Seq<Set<int>>> = seq![s2];
    assert(s4 =~~= s5);  // succeeds
}
// ANCHOR_END: ext_eq_nested

// ANCHOR: ext_eq_fnspec
#[verifier::ext_equal]  // necessary for invoking =~= on the struct
struct Bar {
    a: spec_fn(int) -> int,
}

proof fn ext_equal_fnspec(n: int) {
    // basic case
    let f1 = (|i: int| i + 1);
    let f2 = (|i: int| 1 + i);
    assert(f1 =~= f2);  // succeeds
    // struct case
    let b1 = Bar { a: |i: int| if i == 1 { i } else { 1 } };
    let b2 = Bar { a: |i: int| 1int };
    assert(b1 =~= b2);  // succeeds
    // nested case
    let i1 = (|i: int| i + 2);
    let i2 = (|i: int| 2 + i);
    let n1: Seq<spec_fn(int) -> int> = seq![i1];
    let n2: Seq<spec_fn(int) -> int> = seq![i2];
    // assert(n1 =~= n2); // FAILS
    assert(n1 =~~= n2);  // succeeds
}
// ANCHOR_END: ext_eq_fnspec

fn main() {
}

} // verus!
","[""#[allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\nmod m1 {\n    #[allow(unused_imports)]\n\n\n    use vstd::{seq::*, set::*, map::*, prelude::*};\n\n    // ANCHOR: ext_eq_struct_fields\n    struct Foo {\n        a: Seq<int>,\n        b: Set<int>,\n    }\n\n    proof fn ext_equal_struct() {\n        let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };\n        let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };\n        // assert(f1 == f2);    // FAILS -- need to use =~= first\n        assert(f1.a =~= f2.a);  // succeeds\n        assert(f1.b =~= f2.b);  // succeeds\n        assert(f1 == f2);  // succeeds, now that we've used =~= on .a and .b\n    }\n    // ANCHOR_END: ext_eq_struct_fields\n\n}\n\n// ANCHOR: ext_eq_struct\n#[verifier::ext_equal]  // necessary for invoking =~= on the struct\nstruct Foo {\n    a: Seq<int>,\n    b: Set<int>,\n}\n\nproof fn ext_equal_struct() {\n    let f1 = Foo { a: seq![1, 2, 3], b: set!{4, 5, 6} };\n    let f2 = Foo { a: seq![1, 2].push(3), b: set!{5, 6}.insert(4) };\n    assert(f1 =~= f2);  // succeeds\n}\n// ANCHOR_END: ext_eq_struct\n\n// ANCHOR: ext_eq_nested\nproof fn ext_equal_nested() {\n    let inner: Set<int> = set!{1, 2, 3};\n    let s1: Seq<Set<int>> = seq![inner];\n    let s2 = s1.update(0, s1[0].insert(1));\n    let s3 = s1.update(0, s1[0].insert(2).insert(3));\n    // assert(s2 =~= s3); // FAILS\n    assert(s2 =~~= s3);  // succeeds\n    let s4: Seq<Seq<Set<int>>> = seq![s1];\n    let s5: Seq<Seq<Set<int>>> = seq![s2];\n    assert(s4 =~~= s5);  // succeeds\n}\n// ANCHOR_END: ext_eq_nested\n\n// ANCHOR: ext_eq_fnspec\n#[verifier::ext_equal]  // necessary for invoking =~= on the struct\nstruct Bar {\n    a: spec_fn(int) -> int,\n}\n\nproof fn ext_equal_fnspec(n: int) {\n    // basic case\n    let f1 = (|i: int| i + 1);\n    let f2 = (|i: int| 1 + i);\n    assert(f1 =~= f2);  // succeeds\n    // struct case\n    let b1 = Bar { a: |i: int| if i == 1 { i } else { 1 } };\n    let b2 = Bar { a: |i: int| 1int };\n    assert(b1 =~= b2);  // succeeds\n    // nested case\n    let i1 = (|i: int| i + 2);\n    let i2 = (|i: int| 2 + i);\n    let n1: Seq<spec_fn(int) -> int> = seq![i1];\n    let n2: Seq<spec_fn(int) -> int> = seq![i2];\n    // assert(n1 =~= n2); // FAILS\n    assert(n1 =~~= n2);  // succeeds\n}\n// ANCHOR_END: ext_eq_fnspec\n\nfn main() {\n}\n\n} // verus!\n"", 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::{*, prelude::*};\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/higher_order_fns.rs,194,194,1.0,,,0.7,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::map::', 'vstd::modes::', 'vstd::prelude::', 'vstd::seq::', 'vstd::']",False,other,,,,,"// rust_verify/tests/example.rs expect-failures
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]

#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::map::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::seq::*;
use vstd::*;

verus! {

mod X {
    use super::*;

    // ANCHOR: example1
    fn double(x: u8) -> (res: u8)
        requires
            0 <= x < 128,
        ensures
            res == 2 * x,
    {
        2 * x
    }

    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8) {
        f(50)
    }

    fn test() {
        higher_order_fn(double);
    }
    // ANCHOR_END: example1
}

mod Y {
    use super::*;

    // ANCHOR: example2
    fn double(x: u8) -> (res: u8)
        requires
            0 <= x < 128,
        ensures
            res == 2 * x,
    {
        2 * x
    }

    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)
        requires
            call_requires(f, (50,)),
    {
        f(50)
    }

    fn test() {
        higher_order_fn(double);
    }
    // ANCHOR_END: example2
}

mod Z {
    use super::*;

    // ANCHOR: example3
    fn double(x: u8) -> (res: u8)
        requires
            0 <= x < 128,
        ensures
            res == 2 * x,
    {
        2 * x
    }

    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)
        requires
            call_requires(f, (50,)),
            forall|x, y| call_ensures(f, x, y) ==> y % 2 == 0,
        ensures
            res % 2 == 0,
    {
        let ret = f(50);
        return ret;
    }

    fn test() {
        higher_order_fn(double);
    }
    // ANCHOR_END: example3
}

// ANCHOR: vec_map
// ANCHOR: vec_map_signature
fn vec_map<T, U>(v: &Vec<T>, f: impl Fn(T) -> U) -> (result: Vec<U>) where
    T: Copy,
    // ANCHOR_END: vec_map_signature

    // ANCHOR: vec_map_requires
    requires
        forall|i|
            0 <= i < v.len() ==> call_requires(
                f,
                (v[i],),
            ),
// ANCHOR_END: vec_map_requires
// ANCHOR: vec_map_ensures
    ensures
        result.len() == v.len(),
        forall|i|
            0 <= i < v.len() ==> call_ensures(
                f,
                (v[i],),
                #[trigger] result[i],
            )
        ,
        // ANCHOR_END: vec_map_ensures
{
    let mut result = Vec::new();
    let mut j = 0;
    while j < v.len()
        invariant
            forall|i| 0 <= i < v.len() ==> call_requires(f, (v[i],)),
            0 <= j <= v.len(),
            j == result.len(),
            forall|i| 0 <= i < j ==> call_ensures(f, (v[i],), #[trigger] result[i]),
    {
        result.push(f(v[j]));
        j += 1;
    }
    result
}
// ANCHOR_END: vec_map

// ANCHOR: vec_map_example
fn double(x: u8) -> (res: u8)
    requires
        0 <= x < 128,
    ensures
        res == 2 * x,
{
    2 * x
}

fn test_vec_map() {
    let mut v = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    let w = vec_map(&v, double);
    assert(w[2] == 40);
}
// ANCHOR_END: vec_map_example

// ANCHOR: vec_map_example_with_closure
fn test_vec_map_with_closure() {
    let double = |x: u8| -> (res: u8)
        requires 0 <= x < 128
        ensures res == 2 * x
    {
        2 * x
    };

    assert(forall |x| 0 <= x < 128 ==> call_requires(double, (x,)));
    assert(forall |x, y| call_ensures(double, (x,), y) ==> y == 2 * x);

    let mut v = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    let w = vec_map(&v, double);
    assert(w[2] == 40);
}
// ANCHOR_END: vec_map_example_with_closure

// ANCHOR: closure_capture
fn example_closure_capture() {
    let x: u8 = 20;

    let f = || {
        // Inside the closure, we have seamless access to
        // variables defined outside the closure.
        assert(x == 20);
        x
    };
}
// ANCHOR_END: closure_capture

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs expect-failures
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]

#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::map::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::seq::*;
use vstd::*;

verus! {

mod X {
    use super::*;

    // ANCHOR: example1
    fn double(x: u8) -> (res: u8)
        requires
            0 <= x < 128,
        ensures
            res == 2 * x,
    {
        2 * x
    }

    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8) {
        f(50)
    }

    fn test() {
        higher_order_fn(double);
    }
    // ANCHOR_END: example1
}

mod Y {
    use super::*;

    // ANCHOR: example2
    fn double(x: u8) -> (res: u8)
        requires
            0 <= x < 128,
        ensures
            res == 2 * x,
    {
        2 * x
    }

    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)
        requires
            call_requires(f, (50,)),
    {
        f(50)
    }

    fn test() {
        higher_order_fn(double);
    }
    // ANCHOR_END: example2
}

mod Z {
    use super::*;

    // ANCHOR: example3
    fn double(x: u8) -> (res: u8)
        requires
            0 <= x < 128,
        ensures
            res == 2 * x,
    {
        2 * x
    }

    fn higher_order_fn(f: impl Fn(u8) -> u8) -> (res: u8)
        requires
            call_requires(f, (50,)),
            forall|x, y| call_ensures(f, x, y) ==> y % 2 == 0,
        ensures
            res % 2 == 0,
    {
        let ret = f(50);
        return ret;
    }

    fn test() {
        higher_order_fn(double);
    }
    // ANCHOR_END: example3
}

// ANCHOR: vec_map
// ANCHOR: vec_map_signature
fn vec_map<T, U>(v: &Vec<T>, f: impl Fn(T) -> U) -> (result: Vec<U>) where
    T: Copy,
    // ANCHOR_END: vec_map_signature

    // ANCHOR: vec_map_requires
    requires
        forall|i|
            0 <= i < v.len() ==> call_requires(
                f,
                (v[i],),
            ),
// ANCHOR_END: vec_map_requires
// ANCHOR: vec_map_ensures
    ensures
        result.len() == v.len(),
        forall|i|
            0 <= i < v.len() ==> call_ensures(
                f,
                (v[i],),
                #[trigger] result[i],
            )
        ,
        // ANCHOR_END: vec_map_ensures
{
    let mut result = Vec::new();
    let mut j = 0;
    while j < v.len()
        invariant
            forall|i| 0 <= i < v.len() ==> call_requires(f, (v[i],)),
            0 <= j <= v.len(),
            j == result.len(),
            forall|i| 0 <= i < j ==> call_ensures(f, (v[i],), #[trigger] result[i]),
    {
        result.push(f(v[j]));
        j += 1;
    }
    result
}
// ANCHOR_END: vec_map

// ANCHOR: vec_map_example
fn double(x: u8) -> (res: u8)
    requires
        0 <= x < 128,
    ensures
        res == 2 * x,
{
    2 * x
}

fn test_vec_map() {
    let mut v = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    let w = vec_map(&v, double);
    assert(w[2] == 40);
}
// ANCHOR_END: vec_map_example

// ANCHOR: vec_map_example_with_closure
fn test_vec_map_with_closure() {
    let double = |x: u8| -> (res: u8)
        requires 0 <= x < 128
        ensures res == 2 * x
    {
        2 * x
    };

    assert(forall |x| 0 <= x < 128 ==> call_requires(double, (x,)));
    assert(forall |x, y| call_ensures(double, (x,), y) ==> y == 2 * x);

    let mut v = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    let w = vec_map(&v, double);
    assert(w[2] == 40);
}
// ANCHOR_END: vec_map_example_with_closure

// ANCHOR: closure_capture
fn example_closure_capture() {
    let x: u8 = 20;

    let f = || {
        // Inside the closure, we have seamless access to
        // variables defined outside the closure.
        assert(x == 20);
        x
    };
}
// ANCHOR_END: closure_capture

fn main() {
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/guide/integers.rs,112,112,1.0,152.681,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: test_u8
fn test_u8(u: u8) {
    assert(0 <= u < 256);
}
// ANCHOR_END: test_u8

// ANCHOR: test_consts
fn test_consts() {
    let u: u8 = 1u8;
    assert({
        let i: int = 2int;
        let n: nat = 3nat;
        0int <= u < i < n < 4int
    });
}
// ANCHOR_END: test_consts

// ANCHOR: test_consts_infer
fn test_consts_infer() {
    let u: u8 = 1;
    assert({
        let i: int = 2;
        let n: nat = 3;
        0 <= u < i < n < 4
    });
}
// ANCHOR_END: test_consts_infer

// ANCHOR: test_consts_large
fn test_consts_large() {
    assert({
        let i: int = 0x10000000000000000000000000000000000000000000000000000000000000000int;
        let j: int = i + i;
        j == 2 * i
    });
}
// ANCHOR_END: test_consts_large

// ANCHOR: test_coerce
fn test_coerce() {
    let u: u8 = 1;
    assert({
        let i: int = u as int;
        let n: nat = u as nat;
        u == i && u == n
    });
}
// ANCHOR_END: test_coerce

/*
// ANCHOR: test_coerce_fail
fn test_coerce_fail() {
    let v: u16 = 257;
    let u: u8 = v as u8;
    assert(u == v); // FAILS, because u has type u8 and therefore cannot be equal to 257
}
// ANCHOR_END: test_coerce_fail
*/

/*
// ANCHOR: test_sum
fn test_sum(x: u8, y: u8) {
    let sum1: u8 = x + y; // FAILS: possible overflow
}
// ANCHOR_END: test_sum
*/

// ANCHOR: test_sum2
fn test_sum2(x: u8, y: u8) {
    assert({
        let sum2: int = x + y;  // in ghost code, + returns int and does not overflow
        0 <= sum2 < 511
    });
}
// ANCHOR_END: test_sum2

// ANCHOR: test_sum3
fn test_sum3(x: u8, y: u8)
    requires
        x + y < 256,  // make sure ""let sum1: u8 = x + y"" can't overflow
{
    let sum1: u8 = x + y;  // succeeds
}
// ANCHOR_END: test_sum3

// ANCHOR: test_sum_mixed
fn test_sum_mixed(x: u8, y: u16) {
    assert(x + y >= y);  // x + y has type int, so the assertion succeeds
    assert(x - y <= x);  // x - y has type int, so the assertion succeeds
}
// ANCHOR_END: test_sum_mixed

/*
// ANCHOR: test_sum_add_sub
fn test_sum_add_sub(x: u8, y: u8) {
    assert(add(x, y) >= y); // FAILS: add(x, y) has type u8, so addition might overflow
    assert(sub(x, y) <= x); // FAILS: sub(x, y) has type u8, so subtraction might underflow
}
// ANCHOR_END: test_sum_add_sub
*/

fn main() {
}

} // verus!
","#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: test_u8
fn test_u8(u: u8) {
    assert(0 <= u < 256);
}
// ANCHOR_END: test_u8

// ANCHOR: test_consts
fn test_consts() {
    let u: u8 = 1u8;
    assert({
        let i: int = 2int;
        let n: nat = 3nat;
        0int <= u < i < n < 4int
    });
}
// ANCHOR_END: test_consts

// ANCHOR: test_consts_infer
fn test_consts_infer() {
    let u: u8 = 1;
    assert({
        let i: int = 2;
        let n: nat = 3;
        0 <= u < i < n < 4
    });
}
// ANCHOR_END: test_consts_infer

// ANCHOR: test_consts_large
fn test_consts_large() {
    assert({
        let i: int = 0x10000000000000000000000000000000000000000000000000000000000000000int;
        let j: int = i + i;
        j == 2 * i
    });
}
// ANCHOR_END: test_consts_large

// ANCHOR: test_coerce
fn test_coerce() {
    let u: u8 = 1;
    assert({
        let i: int = u as int;
        let n: nat = u as nat;
        u == i && u == n
    });
}
// ANCHOR_END: test_coerce

/*
// ANCHOR: test_coerce_fail
fn test_coerce_fail() {
    let v: u16 = 257;
    let u: u8 = v as u8;
    assert(u == v); // FAILS, because u has type u8 and therefore cannot be equal to 257
}
// ANCHOR_END: test_coerce_fail
*/

/*
// ANCHOR: test_sum
fn test_sum(x: u8, y: u8) {
    let sum1: u8 = x + y; // FAILS: possible overflow
}
// ANCHOR_END: test_sum
*/

// ANCHOR: test_sum2
fn test_sum2(x: u8, y: u8) {
    assert({
        let sum2: int = x + y;  // in ghost code, + returns int and does not overflow
        0 <= sum2 < 511
    });
}
// ANCHOR_END: test_sum2

// ANCHOR: test_sum3
fn test_sum3(x: u8, y: u8)
    requires
        x + y < 256,  // make sure ""let sum1: u8 = x + y"" can't overflow
{
    let sum1: u8 = x + y;  // succeeds
}
// ANCHOR_END: test_sum3

// ANCHOR: test_sum_mixed
fn test_sum_mixed(x: u8, y: u16) {
    assert(x + y >= y);  // x + y has type int, so the assertion succeeds
    assert(x - y <= x);  // x - y has type int, so the assertion succeeds
}
// ANCHOR_END: test_sum_mixed

/*
// ANCHOR: test_sum_add_sub
fn test_sum_add_sub(x: u8, y: u8) {
    assert(add(x, y) >= y); // FAILS: add(x, y) has type u8, so addition might overflow
    assert(sub(x, y) <= x); // FAILS: sub(x, y) has type u8, so subtraction might underflow
}
// ANCHOR_END: test_sum_add_sub
*/

fn main() {
}

} // verus!
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: test_u8\nfn test_u8(u: u8) {\n    assert(0 <= u < 256);\n}\n// ANCHOR_END: test_u8\n\n// ANCHOR: test_consts\nfn test_consts() {\n    let u: u8 = 1u8;\n    assert({\n        let i: int = 2int;\n        let n: nat = 3nat;\n        0int <= u < i < n < 4int\n    });\n}\n// ANCHOR_END: test_consts\n\n// ANCHOR: test_consts_infer\nfn test_consts_infer() {\n    let u: u8 = 1;\n    assert({\n        let i: int = 2;\n        let n: nat = 3;\n        0 <= u < i < n < 4\n    });\n}\n// ANCHOR_END: test_consts_infer\n\n// ANCHOR: test_consts_large\nfn test_consts_large() {\n    assert({\n        let i: int = 0x10000000000000000000000000000000000000000000000000000000000000000int;\n        let j: int = i + i;\n        j == 2 * i\n    });\n}\n// ANCHOR_END: test_consts_large\n\n// ANCHOR: test_coerce\nfn test_coerce() {\n    let u: u8 = 1;\n    assert({\n        let i: int = u as int;\n        let n: nat = u as nat;\n        u == i && u == n\n    });\n}\n// ANCHOR_END: test_coerce\n\n/*\n// ANCHOR: test_coerce_fail\nfn test_coerce_fail() {\n    let v: u16 = 257;\n    let u: u8 = v as u8;\n    assert(u == v); // FAILS, because u has type u8 and therefore cannot be equal to 257\n}\n// ANCHOR_END: test_coerce_fail\n*/\n\n/*\n// ANCHOR: test_sum\nfn test_sum(x: u8, y: u8) {\n    let sum1: u8 = x + y; // FAILS: possible overflow\n}\n// ANCHOR_END: test_sum\n*/\n\n// ANCHOR: test_sum2\nfn test_sum2(x: u8, y: u8) {\n    assert({\n        let sum2: int = x + y;  // in ghost code, + returns int and does not overflow\n        0 <= sum2 < 511\n    });\n}\n// ANCHOR_END: test_sum2\n\n// ANCHOR: test_sum3\nfn test_sum3(x: u8, y: u8)\n    requires\n        x + y < 256,  // make sure ""let sum1: u8 = x + y"" can\'t overflow\n{\n    let sum1: u8 = x + y;  // succeeds\n}\n// ANCHOR_END: test_sum3\n\n// ANCHOR: test_sum_mixed\nfn test_sum_mixed(x: u8, y: u16) {\n    assert(x + y >= y);  // x + y has type int, so the assertion succeeds\n    assert(x - y <= x);  // x - y has type int, so the assertion succeeds\n}\n// ANCHOR_END: test_sum_mixed\n\n/*\n// ANCHOR: test_sum_add_sub\nfn test_sum_add_sub(x: u8, y: u8) {\n    assert(add(x, y) >= y); // FAILS: add(x, y) has type u8, so addition might overflow\n    assert(sub(x, y) <= x); // FAILS: sub(x, y) has type u8, so subtraction might underflow\n}\n// ANCHOR_END: test_sum_add_sub\n*/\n\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/interior_mutability.rs,64,64,1.0,122.672,True,0.7999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,,,,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{cell::*, prelude::*};

//// InvCell

verus! {

// ANCHOR: inv_cell_example
spec fn result_of_computation() -> u64 {
    2
}

fn expensive_computation() -> (res: u64)
    ensures
        res == result_of_computation(),
{
    1 + 1
}

spec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {
    forall|v|
        (cell.inv(v) <==> match v {
            Option::Some(i) => i == result_of_computation(),
            Option::None => true,
        })
}

// Memoize the call to `expensive_computation()`.
// The argument here is an InvCell wrapping an Option<u64>,
// which is initially None, but then it is set to the correct
// answer once it's computed.
//
// The precondition here, given in the definition of `cell_is_valid` above,
// says that the InvCell has an invariant that the interior contents is either
// `None` or `Some(i)` where `i` is the desired value.
fn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)
    requires
        cell_is_valid(cell),
    ensures
        res == result_of_computation(),
{
    let c = cell.get();
    match c {
        Option::Some(i) => {
            // The value has already been computed; return the cached value
            i
        },
        Option::None => {
            // The value hasn't been computed yet. Compute it here
            let i = expensive_computation();
            // Store it for later
            cell.replace(Option::Some(i));
            // And return it now
            i
        },
    }
}
// ANCHOR_END: inv_cell_example

} // verus!
fn main() {}
","// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{cell::*, prelude::*};

//// InvCell

verus! {

// ANCHOR: inv_cell_example
spec fn result_of_computation() -> u64 {
    2
}

fn expensive_computation() -> (res: u64)
    ensures
        res == result_of_computation(),
{
    1 + 1
}

spec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {
    forall|v|
        (cell.inv(v) <==> match v {
            Option::Some(i) => i == result_of_computation(),
            Option::None => true,
        })
}

// Memoize the call to `expensive_computation()`.
// The argument here is an InvCell wrapping an Option<u64>,
// which is initially None, but then it is set to the correct
// answer once it's computed.
//
// The precondition here, given in the definition of `cell_is_valid` above,
// says that the InvCell has an invariant that the interior contents is either
// `None` or `Some(i)` where `i` is the desired value.
fn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)
    requires
        cell_is_valid(cell),
    ensures
        res == result_of_computation(),
{
    let c = cell.get();
    match c {
        Option::Some(i) => {
            // The value has already been computed; return the cached value
            i
        },
        Option::None => {
            // The value hasn't been computed yet. Compute it here
            let i = expensive_computation();
            // Store it for later
            cell.replace(Option::Some(i));
            // And return it now
            i
        },
    }
}
// ANCHOR_END: inv_cell_example

} // verus!
fn main() {}
","[""// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n    ensures\n        res == result_of_computation(),\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an invariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation(),\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n"", 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/invariants.rs,257,18,0.07003891050583658,789.915,True,0.7999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::prelude::', 'vstd::arithmetic::overflow::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
use vstd::prelude::*;
use vstd::arithmetic::overflow::*;

verus! {

// ANCHOR: fib_spec
spec fn fib(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fib((n - 2) as nat) + fib((n - 1) as nat)
    }
}
// ANCHOR_END: fib_spec

// ANCHOR: fib_is_mono
proof fn lemma_fib_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fib(i) <= fib(j),
    decreases j - i,
{
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fib_is_monotonic(i, (j - 1) as nat);
        lemma_fib_is_monotonic(i, (j - 2) as nat);
    }
}
// ANCHOR_END: fib_is_mono

/*
// ANCHOR: fib_impl_no_proof
fn fib_impl(n: u64) -> (result: u64)
    requires
        fib(n as nat) <= u64::MAX
    ensures
        result == fib(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
    {
        i = i + 1;
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}
// ANCHOR_END: fib_impl_no_proof
*/

/*
// ANCHOR: fib_mono_no_proof
proof fn lemma_fib_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fib(i) <= fib(j),
{
}
// ANCHOR_END: fib_mono_no_proof
*/

/*
// ANCHOR: fib_mono_skeleton
proof fn lemma_fib_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fib(i) <= fib(j),
{
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        assume(false);
    }

}
// ANCHOR_END: fib_mono_skeleton
*/

// ANCHOR: fib_final
fn fib_impl(n: u64) -> (result: u64)
    requires
        fib(n as nat) <= u64::MAX
    ensures
        result == fib(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fib(n as nat) <= u64::MAX,
            cur == fib(i as nat),
            prev == fib((i - 1) as nat),
        decreases n - i,
    {
        i = i + 1;
        proof {
            lemma_fib_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}
// ANCHOR_END: fib_final

// ANCHOR: fib_checked
fn fib_checked(n: u64) -> (result: u64)
    requires
        fib(n as nat) <= u64::MAX
    ensures
        result == fib(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: CheckedU64 = CheckedU64::new(0);
    let mut cur: CheckedU64 = CheckedU64::new(1);
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fib(n as nat) <= u64::MAX,
            cur@ == fib(i as nat),
            prev@ == fib((i - 1) as nat),
        decreases n - i,
    {
        i = i + 1;
        let new_cur = cur.add_checked(&prev);
        prev = cur;
        cur = new_cur;
    }
    cur.unwrap()
}
// ANCHOR_END: fib_checked

// ANCHOR: fib_checked_no_precondition
fn fib_checked_no_precondition(n: u64) -> (result: Option<u64>)
    ensures
        match result {
            Some(x) => x == fib(n as nat),
            None => fib(n as nat) > u64::MAX,
        },
{
    if n == 0 {
        return Some(0);
    }
    let mut prev: CheckedU64 = CheckedU64::new(0);
    let mut cur: CheckedU64 = CheckedU64::new(1);
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            cur@ == fib(i as nat),
            prev@ == fib((i - 1) as nat),
        decreases n - i,
    {
        i = i + 1;
        let new_cur = cur.add_checked(&prev);
        prev = cur;
        cur = new_cur;
    }
    cur.to_option()
}
// ANCHOR_END: fib_checked_no_precondition

// ANCHOR: bank_spec
spec fn always_non_negative(s: Seq<i64>) -> bool
{
    forall|i: int| 0 <= i <= s.len() ==> sum(#[trigger] s.take(i)) >= 0    
}

spec fn sum(s: Seq<i64>) -> int
    decreases s.len(),
{
    if s.len() == 0 {
        0
    } else {
        sum(s.drop_last()) + s.last()
    }
}
// ANCHOR_END: bank_spec

/*
// ANCHOR: bank_no_proof
fn non_negative(operations: &[i64]) -> (r: bool)
    ensures
        r == always_non_negative(operations@),
{
    let mut s = 0i128;
    for i in 0usize..operations.len()
    {
        s = s + operations[i] as i128;
        if s < 0 {
            return false;
        }
    }
    true
}
// ANCHOR_END: bank_no_proof
*/

// ANCHOR: bank_final
fn non_negative(operations: &[i64]) -> (r: bool)
    ensures
        r == always_non_negative(operations@),
{
    let mut s = 0i128;
    for i in 0usize..operations.len()
        invariant
            s == sum(operations@.take(i as int)),
            forall|j: int| 0 <= j <= i ==> sum(#[trigger] operations@.take(j)) >= 0,
            i64::MIN <= s <= i64::MAX * i,
    {
        assert(operations@.take(i as int) =~= operations@.take(
            (i + 1) as int,
        ).drop_last());
        s = s + operations[i] as i128;
        if s < 0 {
            return false;
        }
    }
    true
}
// ANCHOR_END: bank_final


fn main() {
}

} // verus!

"," use vstd::prelude::*;
           verus! {
         spec fn always_non_negative(s: Seq<i64>) -> bool {
           forall|i: int| 0 <= i <= s.len() ==> sum(          
#[trigger] s.take(i)) >= 0    
}
         spec fn sum(s: Seq<i64>) -> int     decreases s.len(), {
           if s.len() == 0 {              0     }
       else {              sum(s.drop_last()) + s.last()     }
       }
         fn non_negative(operations: &[i64]) -> (r: bool)     ensures         r == always_non_negative(operations@), {
           let mut s = 0i128;
           for i in 0usize..operations.len()         invariant             s == sum(operations@.take(i as int)),             forall|j: int| 0 <= j <= i ==> sum(          
#[trigger] operations@.take(j)) >= 0,
            i64::MIN <= s <= i64::MAX * i,     {              assert(operations@.take(i as int) =~= operations@.take(             (i + 1) as int,         ).drop_last());              s = s + operations[i] as i128;              if s < 0 {                 return false;             }          }
           true }
         fn main() ;
         }
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\n// ANCHOR: fib_spec\nspec fn fib(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fib((n - 2) as nat) + fib((n - 1) as nat)\n    }\n}\n// ANCHOR_END: fib_spec\n\n// ANCHOR: fib_is_mono\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fib_is_monotonic(i, (j - 1) as nat);\n        lemma_fib_is_monotonic(i, (j - 2) as nat);\n    }\n}\n// ANCHOR_END: fib_is_mono\n\n/*\n// ANCHOR: fib_impl_no_proof\nfn fib_impl(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n    {\n        i = i + 1;\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_impl_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_no_proof\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n{\n}\n// ANCHOR_END: fib_mono_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_skeleton\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        assume(false);\n    }\n\n}\n// ANCHOR_END: fib_mono_skeleton\n*/\n\n// ANCHOR: fib_final\nfn fib_impl(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur == fib(i as nat),\n            prev == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        proof {\n            lemma_fib_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_final\n\n// ANCHOR: fib_checked\nfn fib_checked(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.unwrap()\n}\n// ANCHOR_END: fib_checked\n\n// ANCHOR: fib_checked_no_precondition\nfn fib_checked_no_precondition(n: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(x) => x == fib(n as nat),\n            None => fib(n as nat) > u64::MAX,\n        },\n{\n    if n == 0 {\n        return Some(0);\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.to_option()\n}\n// ANCHOR_END: fib_checked_no_precondition\n\n// ANCHOR: bank_spec\nspec fn always_non_negative(s: Seq<i64>) -> bool\n{\n    forall|i: int| 0 <= i <= s.len() ==> sum(#[trigger] s.take(i)) >= 0    \n}\n\nspec fn sum(s: Seq<i64>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        sum(s.drop_last()) + s.last()\n    }\n}\n// ANCHOR_END: bank_spec\n\n/*\n// ANCHOR: bank_no_proof\nfn non_negative(operations: &[i64]) -> (r: bool)\n    ensures\n        r == always_non_negative(operations@),\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n    {\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_no_proof\n*/\n\n// ANCHOR: bank_final\nfn non_negative(operations: &[i64]) -> (r: bool)\n    ensures\n        r == always_non_negative(operations@),\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n        invariant\n            s == sum(operations@.take(i as int)),\n            forall|j: int| 0 <= j <= i ==> sum(#[trigger] operations@.take(j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i,\n    {\n        assert(operations@.take(i as int) =~= operations@.take(\n            (i + 1) as int,\n        ).drop_last());\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_final\n\n\nfn main() {\n}\n\n} // verus!\n\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use vstd::prelude::*;\n           verus! {\n         spec fn always_non_negative(s: Seq<i64>) -> bool {\n           forall|i: int| 0 <= i <= s.len() ==> sum(          \n#[trigger] s.take(i)) >= 0    \n}\n         spec fn sum(s: Seq<i64>) -> int     decreases s.len(), {\n           if s.len() == 0 {              0     }\n       else {              sum(s.drop_last()) + s.last()     }\n       }\n         fn non_negative(operations: &[i64]) -> (r: bool)     ensures         r == always_non_negative(operations@), {\n           let mut s = 0i128;\n           for i in 0usize..operations.len()         invariant             s == sum(operations@.take(i as int)),             forall|j: int| 0 <= j <= i ==> sum(          \n#[trigger] operations@.take(j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i,     {              assert(operations@.take(i as int) =~= operations@.take(             (i + 1) as int,         ).drop_last());              s = s + operations[i] as i128;              if s < 0 {                 return false;             }          }\n           true }\n         fn main() ;\n         }\n', ' use vstd::prelude::*;\n                verus! {\n              spec fn always_non_negative(s: Seq<i64>) -> bool {\n                forall|i| sum(               \ns.take(i)) >= 0    \n}\n              spec fn sum(s: Seq<i64>) -> int     decreases s{\n                if s.len() == 0 {\n                  0     }\n            else {\n                  sum(s.drop_last()) + s.last()     }\n            }\n              fn non_negative(operations: &[i64]) -> (r: bool)     ensures         {\n                let mut s = 0;\n                for i in 0usize..operations.len()         invariant             forall|j| 0 <= j <= i ==> sum(               \noperations@.take(j)) >= 0,\n            s <= i64::MAX * i{\n                  assert(operations@.take(i as int) == operations@.take(             (i + 1) ).drop_last());\n                  s = {\n                    return false}\n              }\n                true }\n              fn main() ;\n              }\n', ' use vstd::prelude::*;\n                verus! {\n              spec fn a() -> bool ;\n              spec fn d(b: Seq<i64>) -> int     decreases b{\n                if b.len() == 0 {\n                  0     }\n            else {\n                  d(b.drop_last()) + b.last()     }\n            }\n              fn e(f: &[i64]) ->  bool              {\n                let mut b = 0;\n                for c in 0usize..f.len()         invariant             forall|g| 0 <= g <= c ==> d(               \nf@.take(g))  \n             <= i64::MAX  {\n                  assert(f@.take(c as int) == f@.take             (c + 1) .drop_last());\n                    \n                    return false\n              }\n                true }\n              fn main() ;\n              }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/lib_examples.rs,287,287,1.0,214.376,True,0.85,True,"['vstd::', 'vstd::']",True,,,,,,"#![allow(unused_imports)]
use vstd::{map::*, prelude::*, seq::*, set::*};

verus! {

// ANCHOR: macro
proof fn test_seq1() {
    let s: Seq<int> = seq![0, 10, 20, 30, 40];
    assert(s.len() == 5);
    assert(s[2] == 20);
    assert(s[3] == 30);
}

proof fn test_set1() {
    let s: Set<int> = set![0, 10, 20, 30, 40];
    assert(s.finite());
    assert(s.contains(20));
    assert(s.contains(30));
    assert(!s.contains(60));
}

proof fn test_map1() {
    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];
    assert(m.dom().contains(20));
    assert(m.dom().contains(30));
    assert(!m.dom().contains(60));
    assert(m[20] == 200);
    assert(m[30] == 300);
}

// ANCHOR_END: macro
#[verusfmt::skip]
mod m0 {
use vstd::{seq::*, prelude::*};

// ANCHOR: new0
proof fn test_seq2() {
    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);
    assert(s.len() == 5);
    assert(s[2] == 20);
    assert(s[3] == 30);
}
// ANCHOR_END: new0
}

// ANCHOR: new
proof fn test_seq2() {
    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);
    assert(s.len() == 5);
    assert(s[2] == 20);
    assert(s[3] == 30);
}

proof fn test_set2() {
    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);
    assert(s.contains(20));
    assert(s.contains(30));
    assert(!s.contains(60));

    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);
    assert(s_infinite.contains(20));
    assert(s_infinite.contains(30));
    assert(!s_infinite.contains(35));
}

proof fn test_map2() {
    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);
    assert(m[20] == 200);
    assert(m[30] == 300);

    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);
    assert(m_infinite[20] == 200);
    assert(m_infinite[30] == 300);
    assert(m_infinite[90] == 900);
}
// ANCHOR_END: new

/*
// ANCHOR: test_eq_fail
proof fn check_eq(x: Seq<int>, y: Seq<int>)
    requires
        x == y,
{
}

proof fn test_eq_fail() {
    let s1: Seq<int> = seq![0, 10, 20, 30, 40];
    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];
    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);
    check_eq(s1, s2); // FAILS, even though s1 equals s2
    check_eq(s1, s3); // FAILS, even though s1 equals s3
}
// ANCHOR_END: test_eq_fail
*/

// ANCHOR: test_eq
proof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)
    requires
        x =~= y,
{
}

proof fn test_eq() {
    let s1: Seq<int> = seq![0, 10, 20, 30, 40];
    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];
    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);
    check_eq_extensionally(s1, s2); // succeeds
    check_eq_extensionally(s1, s3); // succeeds
}
// ANCHOR_END: test_eq

// ANCHOR: test_eq2
proof fn check_eq(x: Seq<int>, y: Seq<int>)
    requires
        x == y,
{
}

proof fn test_eq2() {
    let s1: Seq<int> = seq![0, 10, 20, 30, 40];
    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];
    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);
    assert(s1 =~= s2);
    assert(s1 =~= s3);
    check_eq(s1, s2); // succeeds
    check_eq(s1, s3); // succeeds
}
// ANCHOR_END: test_eq2

/*
// ANCHOR: lemma_len_intersect_fail
pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)
    requires
        s1.finite(),
    ensures
        s1.intersect(s2).len() <= s1.len(),
    decreases
        s1.len(),
{
    if s1.is_empty() {

    } else {
        let a = s1.choose();

        lemma_len_intersect(s1.remove(a), s2);
    }
}
// ANCHOR_END: lemma_len_intersect_fail

// ANCHOR: lemma_len_intersect_sketch
pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)
    requires
        s1.finite(),
    ensures
        s1.intersect(s2).len() <= s1.len(),
    decreases
        s1.len(),
{
    if s1.is_empty() {
        // s1 is the empty set.
        // Therefore, s1.intersect(s2) is also empty.
        // So both s1.len() and s1.intersect(s2).len() are 0,
        // and 0 <= 0.
    } else {
        // s1 is not empty, so it has at least one element.
        // Let a be an element from s1.
        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).
        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.
        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:
        //   (s1 - {a}).intersect(s2).len() <= s1'.len()
        //   (s1.intersect(s2) - {a}).len() <= s1'.len()
        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1
        // case a in s1.intersect(s2):
        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1
        // case a not in s1.intersect(s2):
        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()
        // In either case:
        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1
        // Putting all the inequalities together:
        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1
        // So:
        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1
        //   s1.intersect(s2).len() <= s1.len()
    }
}
// ANCHOR_END: lemma_len_intersect_sketch

// ANCHOR: lemma_len_intersect
pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)
    requires
        s1.finite(),
    ensures
        s1.intersect(s2).len() <= s1.len(),
    decreases
        s1.len(),
{
    if s1.is_empty() {
        assert(s1.intersect(s2) =~= s1);
    } else {
        let a = s1.choose();
        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));
        lemma_len_intersect(s1.remove(a), s2);
    }
}
// ANCHOR_END: lemma_len_intersect
*/

// ANCHOR: lemma_len_intersect_commented
pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)
    requires
        s1.finite(),
    ensures
        s1.intersect(s2).len() <= s1.len(),
    decreases s1.len(),
{
    if s1.is_empty() {
        assert(s1.intersect(s2).len() == 0) by {
            assert(s1.intersect(s2) =~= s1);
        }
    } else {
        let a = s1.choose();
        lemma_len_intersect(s1.remove(a), s2);
        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()
        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {
            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));
        }
        // simplifying "".remove(a).len()"" yields s1.intersect(s2).len() <= s1.len())

    }
}
// ANCHOR_END: lemma_len_intersect_commented

// ANCHOR: test_vec1
fn test_vec1() {
    let mut v: Vec<u32> = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    v.push(30);
    v.push(40);
    assert(v.len() == 5);
    assert(v[2] == 20);
    assert(v[3] == 30);
    v.set(2, 21);
    assert(v[2] == 21);
    assert(v[3] == 30);
}
// ANCHOR_END: test_vec1

// ANCHOR: test_vec2
spec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {
    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]
}

fn test_vec2() {
    let mut v: Vec<u32> = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    v.push(30);
    v.push(40);
    v.set(2, 21);
    assert(v@ =~= seq![0, 10, 21, 30, 40]);
    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);
    assert(v@[2] == 21);
    assert(v@[3] == 30);
    assert(v@.subrange(2, 4) =~= seq![21, 30]);
    assert(has_five_sorted_numbers(v@));
}
// ANCHOR_END: test_vec2

// ANCHOR: ret_spec_fn
spec fn adder(x: int) -> spec_fn(int) -> int {
    |y: int| x + y
}

proof fn test_adder() {
    let f = adder(10);
    assert(f(20) == 30);
    assert(f(60) == 70);
}
// ANCHOR_END: ret_spec_fn

fn main() {
}

} // verus!
","#![allow(unused_imports)]
use vstd::{map::*, prelude::*, seq::*, set::*};

verus! {

// ANCHOR: macro
proof fn test_seq1() {
    let s: Seq<int> = seq![0, 10, 20, 30, 40];
    assert(s.len() == 5);
    assert(s[2] == 20);
    assert(s[3] == 30);
}

proof fn test_set1() {
    let s: Set<int> = set![0, 10, 20, 30, 40];
    assert(s.finite());
    assert(s.contains(20));
    assert(s.contains(30));
    assert(!s.contains(60));
}

proof fn test_map1() {
    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];
    assert(m.dom().contains(20));
    assert(m.dom().contains(30));
    assert(!m.dom().contains(60));
    assert(m[20] == 200);
    assert(m[30] == 300);
}

// ANCHOR_END: macro
#[verusfmt::skip]
mod m0 {
use vstd::{seq::*, prelude::*};

// ANCHOR: new0
proof fn test_seq2() {
    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);
    assert(s.len() == 5);
    assert(s[2] == 20);
    assert(s[3] == 30);
}
// ANCHOR_END: new0
}

// ANCHOR: new
proof fn test_seq2() {
    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);
    assert(s.len() == 5);
    assert(s[2] == 20);
    assert(s[3] == 30);
}

proof fn test_set2() {
    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);
    assert(s.contains(20));
    assert(s.contains(30));
    assert(!s.contains(60));

    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);
    assert(s_infinite.contains(20));
    assert(s_infinite.contains(30));
    assert(!s_infinite.contains(35));
}

proof fn test_map2() {
    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);
    assert(m[20] == 200);
    assert(m[30] == 300);

    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);
    assert(m_infinite[20] == 200);
    assert(m_infinite[30] == 300);
    assert(m_infinite[90] == 900);
}
// ANCHOR_END: new

/*
// ANCHOR: test_eq_fail
proof fn check_eq(x: Seq<int>, y: Seq<int>)
    requires
        x == y,
{
}

proof fn test_eq_fail() {
    let s1: Seq<int> = seq![0, 10, 20, 30, 40];
    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];
    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);
    check_eq(s1, s2); // FAILS, even though s1 equals s2
    check_eq(s1, s3); // FAILS, even though s1 equals s3
}
// ANCHOR_END: test_eq_fail
*/

// ANCHOR: test_eq
proof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)
    requires
        x =~= y,
{
}

proof fn test_eq() {
    let s1: Seq<int> = seq![0, 10, 20, 30, 40];
    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];
    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);
    check_eq_extensionally(s1, s2); // succeeds
    check_eq_extensionally(s1, s3); // succeeds
}
// ANCHOR_END: test_eq

// ANCHOR: test_eq2
proof fn check_eq(x: Seq<int>, y: Seq<int>)
    requires
        x == y,
{
}

proof fn test_eq2() {
    let s1: Seq<int> = seq![0, 10, 20, 30, 40];
    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];
    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);
    assert(s1 =~= s2);
    assert(s1 =~= s3);
    check_eq(s1, s2); // succeeds
    check_eq(s1, s3); // succeeds
}
// ANCHOR_END: test_eq2

/*
// ANCHOR: lemma_len_intersect_fail
pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)
    requires
        s1.finite(),
    ensures
        s1.intersect(s2).len() <= s1.len(),
    decreases
        s1.len(),
{
    if s1.is_empty() {

    } else {
        let a = s1.choose();

        lemma_len_intersect(s1.remove(a), s2);
    }
}
// ANCHOR_END: lemma_len_intersect_fail

// ANCHOR: lemma_len_intersect_sketch
pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)
    requires
        s1.finite(),
    ensures
        s1.intersect(s2).len() <= s1.len(),
    decreases
        s1.len(),
{
    if s1.is_empty() {
        // s1 is the empty set.
        // Therefore, s1.intersect(s2) is also empty.
        // So both s1.len() and s1.intersect(s2).len() are 0,
        // and 0 <= 0.
    } else {
        // s1 is not empty, so it has at least one element.
        // Let a be an element from s1.
        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).
        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.
        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:
        //   (s1 - {a}).intersect(s2).len() <= s1'.len()
        //   (s1.intersect(s2) - {a}).len() <= s1'.len()
        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1
        // case a in s1.intersect(s2):
        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1
        // case a not in s1.intersect(s2):
        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()
        // In either case:
        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1
        // Putting all the inequalities together:
        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1
        // So:
        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1
        //   s1.intersect(s2).len() <= s1.len()
    }
}
// ANCHOR_END: lemma_len_intersect_sketch

// ANCHOR: lemma_len_intersect
pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)
    requires
        s1.finite(),
    ensures
        s1.intersect(s2).len() <= s1.len(),
    decreases
        s1.len(),
{
    if s1.is_empty() {
        assert(s1.intersect(s2) =~= s1);
    } else {
        let a = s1.choose();
        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));
        lemma_len_intersect(s1.remove(a), s2);
    }
}
// ANCHOR_END: lemma_len_intersect
*/

// ANCHOR: lemma_len_intersect_commented
pub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)
    requires
        s1.finite(),
    ensures
        s1.intersect(s2).len() <= s1.len(),
    decreases s1.len(),
{
    if s1.is_empty() {
        assert(s1.intersect(s2).len() == 0) by {
            assert(s1.intersect(s2) =~= s1);
        }
    } else {
        let a = s1.choose();
        lemma_len_intersect(s1.remove(a), s2);
        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()
        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {
            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));
        }
        // simplifying "".remove(a).len()"" yields s1.intersect(s2).len() <= s1.len())

    }
}
// ANCHOR_END: lemma_len_intersect_commented

// ANCHOR: test_vec1
fn test_vec1() {
    let mut v: Vec<u32> = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    v.push(30);
    v.push(40);
    assert(v.len() == 5);
    assert(v[2] == 20);
    assert(v[3] == 30);
    v.set(2, 21);
    assert(v[2] == 21);
    assert(v[3] == 30);
}
// ANCHOR_END: test_vec1

// ANCHOR: test_vec2
spec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {
    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]
}

fn test_vec2() {
    let mut v: Vec<u32> = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    v.push(30);
    v.push(40);
    v.set(2, 21);
    assert(v@ =~= seq![0, 10, 21, 30, 40]);
    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);
    assert(v@[2] == 21);
    assert(v@[3] == 30);
    assert(v@.subrange(2, 4) =~= seq![21, 30]);
    assert(has_five_sorted_numbers(v@));
}
// ANCHOR_END: test_vec2

// ANCHOR: ret_spec_fn
spec fn adder(x: int) -> spec_fn(int) -> int {
    |y: int| x + y
}

proof fn test_adder() {
    let f = adder(10);
    assert(f(20) == 30);
    assert(f(60) == 70);
}
// ANCHOR_END: ret_spec_fn

fn main() {
}

} // verus!
","['#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1\' be the set s1 with the element a removed (i.e. s1\' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1\'.len() == s1.len() - 1.\n        // By induction, s1\'.intersect(s2).len() <= s1\'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1\'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1\'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying "".remove(a).len()"" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::{*, prelude::*};\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/modes.rs,372,372,1.0,152.779,True,0.75,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,True,,,"// rust_verify/tests/example.rs expect-warnings
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: fun_modes
spec fn f1(x: int) -> int {
    x / 2
}

proof fn f2(x: int) -> int {
    x / 2
}

// ""exec"" is optional, and is usually omitted
exec fn f3(x: u64) -> u64 {
    x / 2
}

// ANCHOR_END: fun_modes
/*
// ANCHOR: fun_modes2
fn f3(x: u64) -> u64 { x / 2 } // exec function
// ANCHOR_END: fun_modes2
*/

/*
// ANCHOR: spec_fun1
spec fn min(x: int, y: int) -> int {
    if x <= y {
        x
    } else {
        y
    }
}

fn test() {
    assert(min(10, 20) == 10); // succeeds
    assert(min(100, 200) == 100); // succeeds
}
// ANCHOR_END: spec_fun1
*/

// ANCHOR: spec_fun3
spec fn min(x: int, y: int) -> int {
    if x <= y {
        x
    } else {
        y
    }
}

spec fn min3(x: int, y: int, z: int) -> int {
    min(x, min(y, z))
}

fn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)
    ensures
        m == min3(x as int, y as int, z as int),
{
    let mut m = x;
    if y < m {
        m = y;
    }
    if z < m {
        m = z;
    }
    m
}

fn test() {
    let m = compute_min3(10, 20, 30);
    assert(m == 10);
}

// ANCHOR_END: spec_fun3
/*
// ANCHOR: spec_fun_mod1
mod M1 {
    use verus_builtin::*;

    pub open spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    fn test() {
        assert(min(10, 20) == 10); // succeeds
    }
}
// ANCHOR_END: spec_fun_mod1

// ANCHOR: spec_fun_mod2
mod M1 {
    use verus_builtin::*;

    pub closed spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }

    pub proof fn lemma_min(x: int, y: int)
        ensures
            min(x,y) <= x && min(x,y) <= y,
    {}
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    fn test() {
        assert(min(10, 20) == min(10, 20)); // succeeds
        assert(min(10, 20) == 10); // FAILS
        proof {
            lemma_min(10,20);
        }
        assert(min(10, 20) <= 10); // succeeds
    }
}
// ANCHOR_END: spec_fun_mod2
*/

/*
// ANCHOR: spec_fun_proof
mod M1 {
    use verus_builtin::*;

    pub closed spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }

    pub proof fn lemma_min(x: int, y: int)
        ensures
            min(x, y) <= x,
            min(x, y) <= y,
            min(x, y) == x || min(x, y) == y,
    {
    }
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    proof fn test() {
        lemma_min(10, 20);
        assert(min(10, 20) == 10); // succeeds
        assert(min(100, 200) == 100); // FAILS
    }
}
// ANCHOR_END: spec_fun_proof
*/

// ANCHOR: spec_fun_proof_block1
fn test_consts_infer() {
    let u: u8 = 1;
    proof {
        let i: int = 2;
        let n: nat = 3;
        assert(0 <= u < i < n < 4);
    }
}

// ANCHOR_END: spec_fun_proof_block1
// ANCHOR: spec_fun_proof_block2
mod M1 {
    use verus_builtin::*;

    pub closed spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }

    pub proof fn lemma_min(x: int, y: int)
        ensures
            min(x, y) <= x,
            min(x, y) <= y,
            min(x, y) == x || min(x, y) == y,
    {
    }

}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    fn test() {
        proof {
            lemma_min(10, 20);
            lemma_min(100, 200);
        }
        assert(min(10, 20) == 10);  // succeeds
        assert(min(100, 200) == 100);  // succeeds
    }

}

// ANCHOR_END: spec_fun_proof_block2
/*
// ANCHOR: assert_by
mod M1 {
    use verus_builtin::*;

    pub closed spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }

    pub proof fn lemma_min(x: int, y: int)
        ensures
            min(x, y) <= x,
            min(x, y) <= y,
            min(x, y) == x || min(x, y) == y,
    {
    }
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    fn test() {
        assert(min(10, 20) == 10) by {
            lemma_min(10, 20);
            lemma_min(100, 200);
        }
        assert(min(10, 20) == 10); // succeeds
        assert(min(100, 200) == 100); // FAILS
    }
}
// ANCHOR_END: assert_by
*/

/*
// ANCHOR: determinism
mod M1 {
    use verus_builtin::*;

    pub closed spec fn s(i: int) -> int {
        i + 1
    }

    pub proof fn p(i: int) -> int {
        i + 1
    }
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    proof fn test_determinism() {
        let s1 = s(10);
        let s2 = s(10);
        assert(s1 == s2); // succeeds

        let p1 = p(10);
        let p2 = p(10);
        assert(p1 == p2); // FAILS
    }
}
// ANCHOR_END: determinism
*/

// ANCHOR: recommends1
spec fn f(i: nat) -> nat
    recommends
        i > 0,
{
    (i - 1) as nat
}

proof fn test1() {
    assert(f(0) == f(0));  // succeeds
}

// ANCHOR_END: recommends1
/*
// ANCHOR: recommends2
proof fn test2() {
    assert(f(0) <= f(1)); // FAILS
}
// ANCHOR_END: recommends2
*/

// ANCHOR: recommends3
spec fn caller1() -> nat {
    f(0)  // no note, warning, or error generated

}

// ANCHOR_END: recommends3
// ANCHOR: recommends4
spec(checked) fn caller2() -> nat {
    f(0)  // generates a warning because of ""(checked)""

}

// ANCHOR_END: recommends4
/*
// ANCHOR: ghost_abilities0
fn divide_by_zero() {
    let x: u8 = 1;
    assert(x / 0 == x / 0); // succeeds in ghost code
    let y = x / 0; // FAILS in exec code
}
// ANCHOR_END: ghost_abilities0
*/

// ANCHOR: ghost_abilities1
mod MA {
    // does not implement Copy
    // does not allow construction by other modules
    pub struct S {
        private_field: u8,
    }

}

mod MB {
    use verus_builtin::*;
    use crate::MA::*;

    // construct a ghost S
    spec fn make_S() -> S;

    // duplicate an S
    spec fn duplicate_S(s: S) -> (S, S) {
        (s, s)
    }

}

// ANCHOR_END: ghost_abilities1
/*
// ANCHOR: ghost_abilities2
fn test(s: S) {
    let pair = duplicate_S(s); // FAILS
}
// ANCHOR_END: ghost_abilities2
*/

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs expect-warnings
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: fun_modes
spec fn f1(x: int) -> int {
    x / 2
}

proof fn f2(x: int) -> int {
    x / 2
}

// ""exec"" is optional, and is usually omitted
exec fn f3(x: u64) -> u64 {
    x / 2
}

// ANCHOR_END: fun_modes
/*
// ANCHOR: fun_modes2
fn f3(x: u64) -> u64 { x / 2 } // exec function
// ANCHOR_END: fun_modes2
*/

/*
// ANCHOR: spec_fun1
spec fn min(x: int, y: int) -> int {
    if x <= y {
        x
    } else {
        y
    }
}

fn test() {
    assert(min(10, 20) == 10); // succeeds
    assert(min(100, 200) == 100); // succeeds
}
// ANCHOR_END: spec_fun1
*/

// ANCHOR: spec_fun3
spec fn min(x: int, y: int) -> int {
    if x <= y {
        x
    } else {
        y
    }
}

spec fn min3(x: int, y: int, z: int) -> int {
    min(x, min(y, z))
}

fn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)
    ensures
        m == min3(x as int, y as int, z as int),
{
    let mut m = x;
    if y < m {
        m = y;
    }
    if z < m {
        m = z;
    }
    m
}

fn test() {
    let m = compute_min3(10, 20, 30);
    assert(m == 10);
}

// ANCHOR_END: spec_fun3
/*
// ANCHOR: spec_fun_mod1
mod M1 {
    use verus_builtin::*;

    pub open spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    fn test() {
        assert(min(10, 20) == 10); // succeeds
    }
}
// ANCHOR_END: spec_fun_mod1

// ANCHOR: spec_fun_mod2
mod M1 {
    use verus_builtin::*;

    pub closed spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }

    pub proof fn lemma_min(x: int, y: int)
        ensures
            min(x,y) <= x && min(x,y) <= y,
    {}
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    fn test() {
        assert(min(10, 20) == min(10, 20)); // succeeds
        assert(min(10, 20) == 10); // FAILS
        proof {
            lemma_min(10,20);
        }
        assert(min(10, 20) <= 10); // succeeds
    }
}
// ANCHOR_END: spec_fun_mod2
*/

/*
// ANCHOR: spec_fun_proof
mod M1 {
    use verus_builtin::*;

    pub closed spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }

    pub proof fn lemma_min(x: int, y: int)
        ensures
            min(x, y) <= x,
            min(x, y) <= y,
            min(x, y) == x || min(x, y) == y,
    {
    }
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    proof fn test() {
        lemma_min(10, 20);
        assert(min(10, 20) == 10); // succeeds
        assert(min(100, 200) == 100); // FAILS
    }
}
// ANCHOR_END: spec_fun_proof
*/

// ANCHOR: spec_fun_proof_block1
fn test_consts_infer() {
    let u: u8 = 1;
    proof {
        let i: int = 2;
        let n: nat = 3;
        assert(0 <= u < i < n < 4);
    }
}

// ANCHOR_END: spec_fun_proof_block1
// ANCHOR: spec_fun_proof_block2
mod M1 {
    use verus_builtin::*;

    pub closed spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }

    pub proof fn lemma_min(x: int, y: int)
        ensures
            min(x, y) <= x,
            min(x, y) <= y,
            min(x, y) == x || min(x, y) == y,
    {
    }

}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    fn test() {
        proof {
            lemma_min(10, 20);
            lemma_min(100, 200);
        }
        assert(min(10, 20) == 10);  // succeeds
        assert(min(100, 200) == 100);  // succeeds
    }

}

// ANCHOR_END: spec_fun_proof_block2
/*
// ANCHOR: assert_by
mod M1 {
    use verus_builtin::*;

    pub closed spec fn min(x: int, y: int) -> int {
        if x <= y {
            x
        } else {
            y
        }
    }

    pub proof fn lemma_min(x: int, y: int)
        ensures
            min(x, y) <= x,
            min(x, y) <= y,
            min(x, y) == x || min(x, y) == y,
    {
    }
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    fn test() {
        assert(min(10, 20) == 10) by {
            lemma_min(10, 20);
            lemma_min(100, 200);
        }
        assert(min(10, 20) == 10); // succeeds
        assert(min(100, 200) == 100); // FAILS
    }
}
// ANCHOR_END: assert_by
*/

/*
// ANCHOR: determinism
mod M1 {
    use verus_builtin::*;

    pub closed spec fn s(i: int) -> int {
        i + 1
    }

    pub proof fn p(i: int) -> int {
        i + 1
    }
}

mod M2 {
    use verus_builtin::*;
    use crate::M1::*;

    proof fn test_determinism() {
        let s1 = s(10);
        let s2 = s(10);
        assert(s1 == s2); // succeeds

        let p1 = p(10);
        let p2 = p(10);
        assert(p1 == p2); // FAILS
    }
}
// ANCHOR_END: determinism
*/

// ANCHOR: recommends1
spec fn f(i: nat) -> nat
    recommends
        i > 0,
{
    (i - 1) as nat
}

proof fn test1() {
    assert(f(0) == f(0));  // succeeds
}

// ANCHOR_END: recommends1
/*
// ANCHOR: recommends2
proof fn test2() {
    assert(f(0) <= f(1)); // FAILS
}
// ANCHOR_END: recommends2
*/

// ANCHOR: recommends3
spec fn caller1() -> nat {
    f(0)  // no note, warning, or error generated

}

// ANCHOR_END: recommends3
// ANCHOR: recommends4
spec(checked) fn caller2() -> nat {
    f(0)  // generates a warning because of ""(checked)""

}

// ANCHOR_END: recommends4
/*
// ANCHOR: ghost_abilities0
fn divide_by_zero() {
    let x: u8 = 1;
    assert(x / 0 == x / 0); // succeeds in ghost code
    let y = x / 0; // FAILS in exec code
}
// ANCHOR_END: ghost_abilities0
*/

// ANCHOR: ghost_abilities1
mod MA {
    // does not implement Copy
    // does not allow construction by other modules
    pub struct S {
        private_field: u8,
    }

}

mod MB {
    use verus_builtin::*;
    use crate::MA::*;

    // construct a ghost S
    spec fn make_S() -> S;

    // duplicate an S
    spec fn duplicate_S(s: S) -> (S, S) {
        (s, s)
    }

}

// ANCHOR_END: ghost_abilities1
/*
// ANCHOR: ghost_abilities2
fn test(s: S) {
    let pair = duplicate_S(s); // FAILS
}
// ANCHOR_END: ghost_abilities2
*/

fn main() {
}

} // verus!
","['// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: fun_modes\nspec fn f1(x: int) -> int {\n    x / 2\n}\n\nproof fn f2(x: int) -> int {\n    x / 2\n}\n\n// ""exec"" is optional, and is usually omitted\nexec fn f3(x: u64) -> u64 {\n    x / 2\n}\n\n// ANCHOR_END: fun_modes\n/*\n// ANCHOR: fun_modes2\nfn f3(x: u64) -> u64 { x / 2 } // exec function\n// ANCHOR_END: fun_modes2\n*/\n\n/*\n// ANCHOR: spec_fun1\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn test() {\n    assert(min(10, 20) == 10); // succeeds\n    assert(min(100, 200) == 100); // succeeds\n}\n// ANCHOR_END: spec_fun1\n*/\n\n// ANCHOR: spec_fun3\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nspec fn min3(x: int, y: int, z: int) -> int {\n    min(x, min(y, z))\n}\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n    ensures\n        m == min3(x as int, y as int, z as int),\n{\n    let mut m = x;\n    if y < m {\n        m = y;\n    }\n    if z < m {\n        m = z;\n    }\n    m\n}\n\nfn test() {\n    let m = compute_min3(10, 20, 30);\n    assert(m == 10);\n}\n\n// ANCHOR_END: spec_fun3\n/*\n// ANCHOR: spec_fun_mod1\nmod M1 {\n    use verus_builtin::*;\n\n    pub open spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod1\n\n// ANCHOR: spec_fun_mod2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x,y) <= x && min(x,y) <= y,\n    {}\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == min(10, 20)); // succeeds\n        assert(min(10, 20) == 10); // FAILS\n        proof {\n            lemma_min(10,20);\n        }\n        assert(min(10, 20) <= 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod2\n*/\n\n/*\n// ANCHOR: spec_fun_proof\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test() {\n        lemma_min(10, 20);\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: spec_fun_proof\n*/\n\n// ANCHOR: spec_fun_proof_block1\nfn test_consts_infer() {\n    let u: u8 = 1;\n    proof {\n        let i: int = 2;\n        let n: nat = 3;\n        assert(0 <= u < i < n < 4);\n    }\n}\n\n// ANCHOR_END: spec_fun_proof_block1\n// ANCHOR: spec_fun_proof_block2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        proof {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10);  // succeeds\n        assert(min(100, 200) == 100);  // succeeds\n    }\n\n}\n\n// ANCHOR_END: spec_fun_proof_block2\n/*\n// ANCHOR: assert_by\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10) by {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: assert_by\n*/\n\n/*\n// ANCHOR: determinism\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn s(i: int) -> int {\n        i + 1\n    }\n\n    pub proof fn p(i: int) -> int {\n        i + 1\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test_determinism() {\n        let s1 = s(10);\n        let s2 = s(10);\n        assert(s1 == s2); // succeeds\n\n        let p1 = p(10);\n        let p2 = p(10);\n        assert(p1 == p2); // FAILS\n    }\n}\n// ANCHOR_END: determinism\n*/\n\n// ANCHOR: recommends1\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n    (i - 1) as nat\n}\n\nproof fn test1() {\n    assert(f(0) == f(0));  // succeeds\n}\n\n// ANCHOR_END: recommends1\n/*\n// ANCHOR: recommends2\nproof fn test2() {\n    assert(f(0) <= f(1)); // FAILS\n}\n// ANCHOR_END: recommends2\n*/\n\n// ANCHOR: recommends3\nspec fn caller1() -> nat {\n    f(0)  // no note, warning, or error generated\n\n}\n\n// ANCHOR_END: recommends3\n// ANCHOR: recommends4\nspec(checked) fn caller2() -> nat {\n    f(0)  // generates a warning because of ""(checked)""\n\n}\n\n// ANCHOR_END: recommends4\n/*\n// ANCHOR: ghost_abilities0\nfn divide_by_zero() {\n    let x: u8 = 1;\n    assert(x / 0 == x / 0); // succeeds in ghost code\n    let y = x / 0; // FAILS in exec code\n}\n// ANCHOR_END: ghost_abilities0\n*/\n\n// ANCHOR: ghost_abilities1\nmod MA {\n    // does not implement Copy\n    // does not allow construction by other modules\n    pub struct S {\n        private_field: u8,\n    }\n\n}\n\nmod MB {\n    use verus_builtin::*;\n    use crate::MA::*;\n\n    // construct a ghost S\n    spec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n        (s, s)\n    }\n\n}\n\n// ANCHOR_END: ghost_abilities1\n/*\n// ANCHOR: ghost_abilities2\nfn test(s: S) {\n    let pair = duplicate_S(s); // FAILS\n}\n// ANCHOR_END: ghost_abilities2\n*/\n\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/nonlinear_bitvec.rs,86,8,0.09302325581395349,370.923,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

// ANCHOR: bound_checking
proof fn bound_check(x: u32, y: u32, z: u32)
    requires
        x <= 8,
        y <= 8,
{
    assert(x * y <= 100) by (nonlinear_arith)
        requires
            x <= 10,
            y <= 10;

    assert(x * y <= 1000);
}
// ANCHOR_END: bound_checking

// ANCHOR: bound_checking_func
proof fn bound_check2(x: u32, y: u32, z: u32) by (nonlinear_arith)
    requires
        x <= 8,
        y <= 8,
    ensures
        x * y <= 64
{ }
// ANCHOR_END: bound_checking_func

// ANCHOR: de_morgan
proof fn de_morgan_auto()
    by (bit_vector)
    ensures
        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,
        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,
{
}
// ANCHOR_END: de_morgan

// ANCHOR: bitvector_easy
fn test_passes(b: u32) {
    assert(b & 7 == b % 8) by (bit_vector);
    assert(b & 0xff < 0x100) by (bit_vector);
}
// ANCHOR_END: bitvector_easy

/*
// ANCHOR: bitvector_fail
fn test_fails(x: u32, y: u32)
  requires x == y
{
  assert(x & 3 == y & 3) by(bit_vector);  // Fails
}
// ANCHOR_END: bitvector_fail
*/

// ANCHOR: bitvector_success
fn test_success(x: u32, y: u32)
    requires
        x == y,
{
    assert(x & 3 == y & 3) by (bit_vector)
        requires
            x == y,
    ;  // now x == y is available for the bit_vector proof
}
// ANCHOR_END: bitvector_success


// ANCHOR: bitvector_spec_fn
spec fn get_bit(val: u32, index: u32) -> bool {
    0x1u32 & (val >> index) == 1
}

fn test_get_bit() {
    assert(get_bit(128u32, 7)) by (bit_vector);
}
// ANCHOR_END: bitvector_spec_fn

fn main() {
}

} // verus!
","use verus_builtin::*;
use verus_builtin_macros::*;
verus !{
  proof fn de_morgan_auto() by(bit_vector) ensures forall | a : u32, b : u32 |
#[trigger](!(a | b)) == !a & !b{
  }
  fn main();
}
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: bound_checking\nproof fn bound_check(x: u32, y: u32, z: u32)\n    requires\n        x <= 8,\n        y <= 8,\n{\n    assert(x * y <= 100) by (nonlinear_arith)\n        requires\n            x <= 10,\n            y <= 10;\n\n    assert(x * y <= 1000);\n}\n// ANCHOR_END: bound_checking\n\n// ANCHOR: bound_checking_func\nproof fn bound_check2(x: u32, y: u32, z: u32) by (nonlinear_arith)\n    requires\n        x <= 8,\n        y <= 8,\n    ensures\n        x * y <= 64\n{ }\n// ANCHOR_END: bound_checking_func\n\n// ANCHOR: de_morgan\nproof fn de_morgan_auto()\n    by (bit_vector)\n    ensures\n        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,\n        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,\n{\n}\n// ANCHOR_END: de_morgan\n\n// ANCHOR: bitvector_easy\nfn test_passes(b: u32) {\n    assert(b & 7 == b % 8) by (bit_vector);\n    assert(b & 0xff < 0x100) by (bit_vector);\n}\n// ANCHOR_END: bitvector_easy\n\n/*\n// ANCHOR: bitvector_fail\nfn test_fails(x: u32, y: u32)\n  requires x == y\n{\n  assert(x & 3 == y & 3) by(bit_vector);  // Fails\n}\n// ANCHOR_END: bitvector_fail\n*/\n\n// ANCHOR: bitvector_success\nfn test_success(x: u32, y: u32)\n    requires\n        x == y,\n{\n    assert(x & 3 == y & 3) by (bit_vector)\n        requires\n            x == y,\n    ;  // now x == y is available for the bit_vector proof\n}\n// ANCHOR_END: bitvector_success\n\n\n// ANCHOR: bitvector_spec_fn\nspec fn get_bit(val: u32, index: u32) -> bool {\n    0x1u32 & (val >> index) == 1\n}\n\nfn test_get_bit() {\n    assert(get_bit(128u32, 7)) by (bit_vector);\n}\n// ANCHOR_END: bitvector_spec_fn\n\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  proof fn de_morgan_auto() by(bit_vector) ensures forall | a : u32, b : u32 |\n#[trigger](!(a | b)) == !a & !b{\n  }\n  fn main();\n}\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  proof fn de_morgan_auto() by(bit_vector) ensures forall | a : u32, b |\n(!(a | b)) == !a & !b{\n  }\n  fn main();\n}\n', 'use verus_builtin::*;\n      use verus_builtin_macros::*;\n      verus !{\n       fn main();\n     }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/quants.rs,497,25,0.05030181086519115,337.333,True,0.9999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::', 'verus_builtin::']",True,,,,,,"// rust_verify/tests/example.rs expect-warnings

#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{prelude::*, seq::*};

verus! {

// ANCHOR: quants_finite
spec fn is_even(i: int) -> bool {
    i % 2 == 0
}

proof fn test_seq_5_is_evens(s: Seq<int>)
    requires
        s.len() == 5,
        is_even(s[0]),
        is_even(s[1]),
        is_even(s[3]),
        is_even(s[3]),
        is_even(s[4]),
{
    assert(is_even(s[3]));
}
// ANCHOR_END: quants_finite

spec fn is_odd(i: int) -> bool {
    i % 2 == 1
}

// ANCHOR: quants_recursion
spec fn all_evens(s: Seq<int>) -> bool
    decreases s.len(),
{
    if s.len() == 0 {
        true
    } else {
        is_even(s.last()) && all_evens(s.drop_last())
    }
}

proof fn test_seq_recursive(s: Seq<int>)
    requires
        s.len() == 5,
        all_evens(s),
{
    assert(is_even(s[3])) by {
        reveal_with_fuel(all_evens, 2);
    }
}
// ANCHOR_END: quants_recursion

// ANCHOR: quants_use_forall
proof fn test_use_forall(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),
{
    assert(is_even(s[3]));
}
// ANCHOR_END: quants_use_forall

/*
// ANCHOR: trigger_fails
spec fn is_even(i: int) -> bool {
    i % 2 == 0
}

proof fn test_use_forall_fail(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),
{
    assert(s[3] % 2 == 0); // FAILS: doesn't trigger is_even(s[i])
}
// ANCHOR_END: trigger_fails
*/

// ANCHOR: test_use_forall_succeeds1
proof fn test_use_forall_succeeds1(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),
{
    assert(is_even(s[3]));  // triggers is_even(s[3])
    assert(s[3] % 2 == 0);  // succeeds, because previous line already instantiated the forall
}
// ANCHOR_END: test_use_forall_succeeds1

// ANCHOR: test_use_forall_succeeds2
proof fn test_use_forall_succeeds2(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]),
{
    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]
}
// ANCHOR_END: test_use_forall_succeeds2

/*
// ANCHOR: test_use_forall_succeeds3
proof fn test_use_forall_succeeds3(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note
{
    assert(s[3] % 2 == 0); // succeeds by triggering s[3]
}
// ANCHOR_END: test_use_forall_succeeds3
*/

// ANCHOR: test_use_forall_succeeds4
proof fn test_use_forall_succeeds4(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int|
            #![auto]
            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger
{
    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]
}
// ANCHOR_END: test_use_forall_succeeds4

/*
// ANCHOR: test_use_forall_bad1
proof fn test_use_forall_bad1(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]),
{
    assert(s[3] % 2 == 0);
}
// ANCHOR_END: test_use_forall_bad1
*/

/*
// ANCHOR: test_use_forall_bad2
spec fn nonnegative(i: int) -> bool {
    0 <= i
}

proof fn test_use_forall_bad2(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]),
{
    assert(is_even(s[3])); // FAILS: doesn't trigger nonnegative(i)
}
// ANCHOR_END: test_use_forall_bad2
*/

// ANCHOR: test_distinct1
spec fn is_distinct(x: int, y: int) -> bool {
    x != y
}

proof fn test_distinct1(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]),
{
    assert(is_distinct(s[2], s[4]));
}
// ANCHOR_END: test_distinct1

// ANCHOR: test_distinct2
proof fn test_distinct2(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j],
{
    assert(s[4] != s[2]);
}
// ANCHOR_END: test_distinct2

// ANCHOR: test_distinct3
proof fn test_distinct3(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j],
{
    assert(s[4] != s[2]);
}
// ANCHOR_END: test_distinct3

/*
// ANCHOR: test_distinct_fail1
proof fn test_distinct_fail1(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int, j: int|
            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i
{
    assert(s[4] != s[2]);
}
// ANCHOR_END: test_distinct_fail1
*/

/*
// ANCHOR: test_distinct_fail2
proof fn test_distinct_fail2(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]
            0 <= i < j < s.len() ==> s[i] != s[j],
{
    assert(s[4] != s[2]); // FAILS, because nothing matches is_even(i)
}
// ANCHOR_END: test_distinct_fail2
*/

// ANCHOR: test_distinct4
proof fn test_distinct4(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int, j: int|
            #![trigger s[i], s[j]]
            #![trigger is_even(i), is_even(j)]
            0 <= i < j < s.len() ==> s[i] != s[j],
{
    assert(s[4] != s[2]);
}
// ANCHOR_END: test_distinct4

// ANCHOR: test_multitriggers
proof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)
    requires
        5 <= a.len(),
        a.len() == b.len(),
        a.len() == c.len(),
        forall|i: int, j: int|
            #![trigger a[i], b[j]]
            #![trigger a[i], c[j]]
            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j],
{
    assert(a[2] != c[4]);  // succeeds, matches a[i], c[j]
}
// ANCHOR_END: test_multitriggers

// ANCHOR: seq_update_different
proof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {
    assert(forall|i: int, j: int|
        0 <= i < s.len() && 0 <= j < s.len() && i != j ==> s.update(j, a)[i] == s[i]);
}
// ANCHOR_END: seq_update_different

// ANCHOR: test_sorted_good
proof fn test_sorted_good(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j],
{
    assert(s[2] <= s[4]);
}
// ANCHOR_END: test_sorted_good

/*
// ANCHOR: test_sorted_bad1
proof fn test_sorted_bad(s: Seq<int>)
    requires
        5 <= s.len(),
        forall|i: int|
            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],
{
    assert(s[2] <= s[4]);
}
// ANCHOR_END: test_sorted_bad1
*/

// ANCHOR: test_exists_succeeds
proof fn test_exists_succeeds() {
    assert(is_even(4));
    assert(!is_even(5));
    assert(is_even(6));
    assert(exists|i: int| #[trigger] is_even(i));  // succeeds with witness i = 4 or i = 6
}
// ANCHOR_END: test_exists_succeeds

/*
// ANCHOR: test_exists_fails
proof fn test_exists_fails() {
    assert(exists|i: int| #[trigger] is_even(i)); // FAILS, no match for trigger
}
// ANCHOR_END: test_exists_fails
*/

// ANCHOR: test_choose_succeeds
spec fn f(i: int) -> bool;

proof fn test_choose_succeeds()
    requires
        exists|i: int| f(i),
{
    let i_witness = choose|i: int| f(i);
    assert(f(i_witness));
}
// ANCHOR_END: test_choose_succeeds

/*
// ANCHOR: test_choose_fails
proof fn test_choose_fails() {
    let i_witness = choose|i: int| f(i);
    assert(i_witness < 0 || i_witness >= 0); // i_witness is some integer
    assert(f(i_witness)); // FAILS because we don't know exists|i: int| f(i)
}
// ANCHOR_END: test_choose_fails
*/

// ANCHOR: test_choose_same
proof fn test_choose_same() {
    let x = choose|i: int| f(i);
    let y = choose|i: int| f(i);
    assert(x == y);
}
// ANCHOR_END: test_choose_same

// ANCHOR: test_choose_succeeds2
spec fn less_than(x: int, y: int) -> bool {
    x < y
}

proof fn test_choose_succeeds2() {
    assert(less_than(3, 7));  // promote i = 3, i = 7 as a witness
    let (x, y) = choose|i: int, j: int| less_than(i, j);
    assert(x < y);
}
// ANCHOR_END: test_choose_succeeds2

#[verusfmt::skip]
mod M {
#[allow(unused_imports)]

use verus_builtin::*;

// ANCHOR: just_works
spec fn is_distinct(x: int, y: int) -> bool {
    x != y
}

spec fn dummy(i: int) -> bool;

proof fn prove_forall()
    ensures
        forall|i: int, j: int|
            #![trigger dummy(i), dummy(j)]
            is_distinct(i, j) ==> is_distinct(j, i),
{
    // proving the forall just works; the trigger is irrelevant
}

proof fn use_exists(x: int)
    requires
        exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5),
{
    // using the exists just works; the trigger is irrelevant
    assert(x != 6);
}
// ANCHOR_END: just_works
}

// ANCHOR: hoist
proof fn hoisted_forall(i: int, j: int)
    ensures
        is_distinct(i, j) ==> is_distinct(j, i),
{
}

proof fn hoisted_exists(x: int, i: int)
    requires
        x == i + 1 && is_distinct(i, 5),
{
    assert(x != 6);
}
// ANCHOR_END: hoist

#[verifier::external_body]
proof fn lemma_even_f(i: int)
    requires
        is_even(i),
    ensures
        f(i),
{
}

/*
// ANCHOR: test_even_f_fail1
proof fn test_even_f()
    ensures
        forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma
{
}
// ANCHOR_END: test_even_f_fail1
*/

/*
// ANCHOR: test_even_f_fail2
proof fn test_even_f()
    ensures
        forall|i: int| is_even(i) ==> f(i),
{
    lemma_even_f(i); // ERROR: i is not in scope here
}
// ANCHOR_END: test_even_f_fail2
*/

// ANCHOR: test_even_f
proof fn test_even_f()
    ensures
        forall|i: int| is_even(i) ==> f(i),
{
    assert forall|i: int| is_even(i) implies f(i) by {
        // First, i is in scope here
        // Second, we assume is_even(i) here
        lemma_even_f(i);
        // Finally, we have to prove f(i) here
    }
}
// ANCHOR_END: test_even_f

spec fn g(i: int, j: int) -> bool;

#[verifier::external_body]
proof fn lemma_g_proves_f(i: int, j: int)
    requires
        g(i, j),
    ensures
        f(i),
{
}

/*
// ANCHOR: test_g_proves_f_fails
proof fn test_g_proves_f(i: int)
    requires
        exists|j: int| g(i, j),
    ensures
        f(i),
{
    lemma_g_proves_f(i, j); // ERROR: j is not in scope here
}
// ANCHOR_END: test_g_proves_f_fails
*/

// ANCHOR: test_g_proves_f
proof fn test_g_proves_f(i: int)
    requires
        exists|j: int| g(i, j),
    ensures
        f(i),
{
    lemma_g_proves_f(i, choose|j: int| g(i, j));
}
// ANCHOR_END: test_g_proves_f

// ANCHOR: binary_search
fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|i: int| 0 <= i < v.len() && k == v[i],
    ensures
        r < v.len(),
        k == v[r as int],
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            i2 < v.len(),
            exists|i: int| i1 <= i <= i2 && k == v[i],
            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        decreases i2 - i1,
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}

fn main() {
    let mut v: Vec<u64> = Vec::new();
    v.push(0);
    v.push(10);
    v.push(20);
    v.push(30);
    v.push(40);
    assert(v[3] == 30);  // needed to trigger exists|i: int| ... k == v[i]
    let r = binary_search(&v, 30);
    assert(r == 3);
}
// ANCHOR_END: binary_search

} // verus!
"," use vstd::{
 prelude::*, seq::*};
   verus! {
  spec fn is_even(i: int) -> bool {
     i % 2 == 0 }
  proof fn test_use_forall(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==>   
#[trigger] is_even(s[i]),
{
     assert(is_even(s[3]));
       assert(s[3] % 2 == 0);
   }
  proof fn test_use_forall_succeeds2(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==> is_even(  
#[trigger] s[i]),
{
     assert(s[3] % 2 == 0);
   }
  fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)     requires         forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         exists|i: int| 0 <= i < v.len() && k == v[i],     ensures         r < v.len(),         k == v[r as int], {
     let mut i1: usize = 0;
     let mut i2: usize = v.len() - 1;
     while i1 != i2         invariant             i2 < v.len(),             exists|i: int| i1 <= i <= i2 && k == v[i],             forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         decreases i2 - i1,     {         let ix = i1 + (i2 - i1) / 2;         if v[ix] < k {             i1 = ix + 1;         } else {             i2 = ix;         }     }
     i1 }
  fn main() {
     let mut v: Vec<u64> = Vec::new();
 }
  }
","[""// rust_verify/tests/example.rs expect-warnings\n\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq::*};\n\nverus! {\n\n// ANCHOR: quants_finite\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_seq_5_is_evens(s: Seq<int>)\n    requires\n        s.len() == 5,\n        is_even(s[0]),\n        is_even(s[1]),\n        is_even(s[3]),\n        is_even(s[3]),\n        is_even(s[4]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_finite\n\nspec fn is_odd(i: int) -> bool {\n    i % 2 == 1\n}\n\n// ANCHOR: quants_recursion\nspec fn all_evens(s: Seq<int>) -> bool\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_even(s.last()) && all_evens(s.drop_last())\n    }\n}\n\nproof fn test_seq_recursive(s: Seq<int>)\n    requires\n        s.len() == 5,\n        all_evens(s),\n{\n    assert(is_even(s[3])) by {\n        reveal_with_fuel(all_evens, 2);\n    }\n}\n// ANCHOR_END: quants_recursion\n\n// ANCHOR: quants_use_forall\nproof fn test_use_forall(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_use_forall\n\n/*\n// ANCHOR: trigger_fails\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_use_forall_fail(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(s[3] % 2 == 0); // FAILS: doesn't trigger is_even(s[i])\n}\n// ANCHOR_END: trigger_fails\n*/\n\n// ANCHOR: test_use_forall_succeeds1\nproof fn test_use_forall_succeeds1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));  // triggers is_even(s[3])\n    assert(s[3] % 2 == 0);  // succeeds, because previous line already instantiated the forall\n}\n// ANCHOR_END: test_use_forall_succeeds1\n\n// ANCHOR: test_use_forall_succeeds2\nproof fn test_use_forall_succeeds2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]),\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds2\n\n/*\n// ANCHOR: test_use_forall_succeeds3\nproof fn test_use_forall_succeeds3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note\n{\n    assert(s[3] % 2 == 0); // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds3\n*/\n\n// ANCHOR: test_use_forall_succeeds4\nproof fn test_use_forall_succeeds4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            #![auto]\n            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds4\n\n/*\n// ANCHOR: test_use_forall_bad1\nproof fn test_use_forall_bad1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]),\n{\n    assert(s[3] % 2 == 0);\n}\n// ANCHOR_END: test_use_forall_bad1\n*/\n\n/*\n// ANCHOR: test_use_forall_bad2\nspec fn nonnegative(i: int) -> bool {\n    0 <= i\n}\n\nproof fn test_use_forall_bad2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]),\n{\n    assert(is_even(s[3])); // FAILS: doesn't trigger nonnegative(i)\n}\n// ANCHOR_END: test_use_forall_bad2\n*/\n\n// ANCHOR: test_distinct1\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nproof fn test_distinct1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]),\n{\n    assert(is_distinct(s[2], s[4]));\n}\n// ANCHOR_END: test_distinct1\n\n// ANCHOR: test_distinct2\nproof fn test_distinct2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct2\n\n// ANCHOR: test_distinct3\nproof fn test_distinct3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct3\n\n/*\n// ANCHOR: test_distinct_fail1\nproof fn test_distinct_fail1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct_fail1\n*/\n\n/*\n// ANCHOR: test_distinct_fail2\nproof fn test_distinct_fail2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]); // FAILS, because nothing matches is_even(i)\n}\n// ANCHOR_END: test_distinct_fail2\n*/\n\n// ANCHOR: test_distinct4\nproof fn test_distinct4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            #![trigger s[i], s[j]]\n            #![trigger is_even(i), is_even(j)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct4\n\n// ANCHOR: test_multitriggers\nproof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)\n    requires\n        5 <= a.len(),\n        a.len() == b.len(),\n        a.len() == c.len(),\n        forall|i: int, j: int|\n            #![trigger a[i], b[j]]\n            #![trigger a[i], c[j]]\n            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j],\n{\n    assert(a[2] != c[4]);  // succeeds, matches a[i], c[j]\n}\n// ANCHOR_END: test_multitriggers\n\n// ANCHOR: seq_update_different\nproof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {\n    assert(forall|i: int, j: int|\n        0 <= i < s.len() && 0 <= j < s.len() && i != j ==> s.update(j, a)[i] == s[i]);\n}\n// ANCHOR_END: seq_update_different\n\n// ANCHOR: test_sorted_good\nproof fn test_sorted_good(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_good\n\n/*\n// ANCHOR: test_sorted_bad1\nproof fn test_sorted_bad(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_bad1\n*/\n\n// ANCHOR: test_exists_succeeds\nproof fn test_exists_succeeds() {\n    assert(is_even(4));\n    assert(!is_even(5));\n    assert(is_even(6));\n    assert(exists|i: int| #[trigger] is_even(i));  // succeeds with witness i = 4 or i = 6\n}\n// ANCHOR_END: test_exists_succeeds\n\n/*\n// ANCHOR: test_exists_fails\nproof fn test_exists_fails() {\n    assert(exists|i: int| #[trigger] is_even(i)); // FAILS, no match for trigger\n}\n// ANCHOR_END: test_exists_fails\n*/\n\n// ANCHOR: test_choose_succeeds\nspec fn f(i: int) -> bool;\n\nproof fn test_choose_succeeds()\n    requires\n        exists|i: int| f(i),\n{\n    let i_witness = choose|i: int| f(i);\n    assert(f(i_witness));\n}\n// ANCHOR_END: test_choose_succeeds\n\n/*\n// ANCHOR: test_choose_fails\nproof fn test_choose_fails() {\n    let i_witness = choose|i: int| f(i);\n    assert(i_witness < 0 || i_witness >= 0); // i_witness is some integer\n    assert(f(i_witness)); // FAILS because we don't know exists|i: int| f(i)\n}\n// ANCHOR_END: test_choose_fails\n*/\n\n// ANCHOR: test_choose_same\nproof fn test_choose_same() {\n    let x = choose|i: int| f(i);\n    let y = choose|i: int| f(i);\n    assert(x == y);\n}\n// ANCHOR_END: test_choose_same\n\n// ANCHOR: test_choose_succeeds2\nspec fn less_than(x: int, y: int) -> bool {\n    x < y\n}\n\nproof fn test_choose_succeeds2() {\n    assert(less_than(3, 7));  // promote i = 3, i = 7 as a witness\n    let (x, y) = choose|i: int, j: int| less_than(i, j);\n    assert(x < y);\n}\n// ANCHOR_END: test_choose_succeeds2\n\n#[verusfmt::skip]\nmod M {\n#[allow(unused_imports)]\n\nuse verus_builtin::*;\n\n// ANCHOR: just_works\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nspec fn dummy(i: int) -> bool;\n\nproof fn prove_forall()\n    ensures\n        forall|i: int, j: int|\n            #![trigger dummy(i), dummy(j)]\n            is_distinct(i, j) ==> is_distinct(j, i),\n{\n    // proving the forall just works; the trigger is irrelevant\n}\n\nproof fn use_exists(x: int)\n    requires\n        exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5),\n{\n    // using the exists just works; the trigger is irrelevant\n    assert(x != 6);\n}\n// ANCHOR_END: just_works\n}\n\n// ANCHOR: hoist\nproof fn hoisted_forall(i: int, j: int)\n    ensures\n        is_distinct(i, j) ==> is_distinct(j, i),\n{\n}\n\nproof fn hoisted_exists(x: int, i: int)\n    requires\n        x == i + 1 && is_distinct(i, 5),\n{\n    assert(x != 6);\n}\n// ANCHOR_END: hoist\n\n#[verifier::external_body]\nproof fn lemma_even_f(i: int)\n    requires\n        is_even(i),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_even_f_fail1\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma\n{\n}\n// ANCHOR_END: test_even_f_fail1\n*/\n\n/*\n// ANCHOR: test_even_f_fail2\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    lemma_even_f(i); // ERROR: i is not in scope here\n}\n// ANCHOR_END: test_even_f_fail2\n*/\n\n// ANCHOR: test_even_f\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    assert forall|i: int| is_even(i) implies f(i) by {\n        // First, i is in scope here\n        // Second, we assume is_even(i) here\n        lemma_even_f(i);\n        // Finally, we have to prove f(i) here\n    }\n}\n// ANCHOR_END: test_even_f\n\nspec fn g(i: int, j: int) -> bool;\n\n#[verifier::external_body]\nproof fn lemma_g_proves_f(i: int, j: int)\n    requires\n        g(i, j),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_g_proves_f_fails\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, j); // ERROR: j is not in scope here\n}\n// ANCHOR_END: test_g_proves_f_fails\n*/\n\n// ANCHOR: test_g_proves_f\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, choose|j: int| g(i, j));\n}\n// ANCHOR_END: test_g_proves_f\n\n// ANCHOR: binary_search\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn main() {\n    let mut v: Vec<u64> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v[3] == 30);  // needed to trigger exists|i: int| ... k == v[i]\n    let r = binary_search(&v, 30);\n    assert(r == 3);\n}\n// ANCHOR_END: binary_search\n\n} // verus!\n"", 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use vstd::{\n prelude::*, seq::*};\n   verus! {\n  spec fn is_even(i: int) -> bool {\n     i % 2 == 0 }\n  proof fn test_use_forall(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==>   \n#[trigger] is_even(s[i]),\n{\n     assert(is_even(s[3]));\n       assert(s[3] % 2 == 0);\n   }\n  proof fn test_use_forall_succeeds2(s: Seq<int>)     requires         5 <= s.len(),         forall|i: int| 0 <= i < s.len() ==> is_even(  \n#[trigger] s[i]),\n{\n     assert(s[3] % 2 == 0);\n   }\n  fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)     requires         forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         exists|i: int| 0 <= i < v.len() && k == v[i],     ensures         r < v.len(),         k == v[r as int], {\n     let mut i1: usize = 0;\n     let mut i2: usize = v.len() - 1;\n     while i1 != i2         invariant             i2 < v.len(),             exists|i: int| i1 <= i <= i2 && k == v[i],             forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],         decreases i2 - i1,     {         let ix = i1 + (i2 - i1) / 2;         if v[ix] < k {             i1 = ix + 1;         } else {             i2 = ix;         }     }\n     i1 }\n  fn main() {\n     let mut v: Vec<u64> = Vec::new();\n }\n  }\n', ' use vstd::{\n       prelude::*, seq::*};\n          verus! {\n        fn main() ;\n        }\n', 'use vstd::{prelude::*, *};\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/references.rs,111,111,1.0,154.025,True,0.6,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::prelude::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::prelude::*;

verus! {


// ANCHOR: immut
fn immutable_references_example() {
    let x: u32 = 0;
    let y: u32 = 0;

    let immut_ref_x = &x;
    let immut_ref_y = &y;

    assert(x == 0);
    assert(*immut_ref_x == 0);

    // These point to different stack variables, but they compare equal.
    assert(immut_ref_x == immut_ref_y);
}
// ANCHOR_END: immut

// ANCHOR: mut
fn modify_y(a: &mut u32)
    ensures *a == 2
{
    *a = 2;
}

fn mutable_example()
{
    let mut y: u32 = 1;
    assert(y == 1);
    modify_y(&mut y);
    assert(y == 2);
}
// ANCHOR_END: mut

// ANCHOR: requires
fn increment(a: &mut u32)
    requires *old(a) < u32::MAX,
    ensures *a == *old(a) + 1,
{
    *a = *a + 1;
}

fn caller()
{
    let mut z: u32 = 0;
    increment(&mut z);
    assert(z == 1);
}
// ANCHOR_END: requires

// ANCHOR: asserts
fn check_and_assert(a: &mut u32)
    requires *old(a) == 0
{
    assert(*old(a) == 0);
    *a = *a + 1;
    assert(*a == 1);
    *a = *a + 1;
    assert(*a == 2);
    assert(*old(a) == 0);
}

fn asserts() 
{
    let mut x: u32 = 0;
    check_and_assert(&mut x);
}
// ANCHOR_END: asserts

// ANCHOR: complex
fn decrease(b: &mut u32)
    requires
        *old(b) == 10,
    ensures
        *b == 0,
{
    let mut i: u32 = 0;
    while (*b > 0) 
        invariant
            *b == (10 - i),
        decreases *b,
    {
        *b = *b - 1;
        i = i + 1;
        assert(*b == (10 - i));
    }
    assert(*b == 0);
    assert(*old(b) == 10);
}

fn complex_example()
{
    let mut d: u32 = 10;
    decrease(&mut d);
    assert(d == 0);
}
// ANCHOR_END: complex


fn main() {
}

} // verus!
","#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::prelude::*;

verus! {


// ANCHOR: immut
fn immutable_references_example() {
    let x: u32 = 0;
    let y: u32 = 0;

    let immut_ref_x = &x;
    let immut_ref_y = &y;

    assert(x == 0);
    assert(*immut_ref_x == 0);

    // These point to different stack variables, but they compare equal.
    assert(immut_ref_x == immut_ref_y);
}
// ANCHOR_END: immut

// ANCHOR: mut
fn modify_y(a: &mut u32)
    ensures *a == 2
{
    *a = 2;
}

fn mutable_example()
{
    let mut y: u32 = 1;
    assert(y == 1);
    modify_y(&mut y);
    assert(y == 2);
}
// ANCHOR_END: mut

// ANCHOR: requires
fn increment(a: &mut u32)
    requires *old(a) < u32::MAX,
    ensures *a == *old(a) + 1,
{
    *a = *a + 1;
}

fn caller()
{
    let mut z: u32 = 0;
    increment(&mut z);
    assert(z == 1);
}
// ANCHOR_END: requires

// ANCHOR: asserts
fn check_and_assert(a: &mut u32)
    requires *old(a) == 0
{
    assert(*old(a) == 0);
    *a = *a + 1;
    assert(*a == 1);
    *a = *a + 1;
    assert(*a == 2);
    assert(*old(a) == 0);
}

fn asserts() 
{
    let mut x: u32 = 0;
    check_and_assert(&mut x);
}
// ANCHOR_END: asserts

// ANCHOR: complex
fn decrease(b: &mut u32)
    requires
        *old(b) == 10,
    ensures
        *b == 0,
{
    let mut i: u32 = 0;
    while (*b > 0) 
        invariant
            *b == (10 - i),
        decreases *b,
    {
        *b = *b - 1;
        i = i + 1;
        assert(*b == (10 - i));
    }
    assert(*b == 0);
    assert(*old(b) == 10);
}

fn complex_example()
{
    let mut d: u32 = 10;
    decrease(&mut d);
    assert(d == 0);
}
// ANCHOR_END: complex


fn main() {
}

} // verus!
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    assert(x == 0);\n    assert(*immut_ref_x == 0);\n\n    // These point to different stack variables, but they compare equal.\n    assert(immut_ref_x == immut_ref_y);\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n    assert(y == 1);\n    modify_y(&mut y);\n    assert(y == 2);\n}\n// ANCHOR_END: mut\n\n// ANCHOR: requires\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n    assert(z == 1);\n}\n// ANCHOR_END: requires\n\n// ANCHOR: asserts\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n    assert(*old(a) == 0);\n    *a = *a + 1;\n    assert(*a == 1);\n    *a = *a + 1;\n    assert(*a == 2);\n    assert(*old(a) == 0);\n}\n\nfn asserts() \n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n    let mut i: u32 = 0;\n    while (*b > 0) \n        invariant\n            *b == (10 - i),\n        decreases *b,\n    {\n        *b = *b - 1;\n        i = i + 1;\n        assert(*b == (10 - i));\n    }\n    assert(*b == 0);\n    assert(*old(b) == 10);\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n    assert(d == 0);\n}\n// ANCHOR_END: complex\n\n\nfn main() {\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/requires_ensures_edit.rs,84,84,1.0,152.494,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

/*
// ANCHOR: init
fn octuple(x1: i8) -> i8 {
    let x2 = x1 + x1;
    let x4 = x2 + x2;
    x4 + x4
}
// ANCHOR_END: init

fn main() {
}

// ANCHOR: pre1
fn octuple(x1: i8) -> i8
    requires
        -64 <= x1,
        x1 < 64,
{
    let x2 = x1 + x1;
    let x4 = x2 + x2;
    x4 + x4
}
// ANCHOR_END: pre1

fn main() {
}

// ANCHOR: pre2
fn octuple(x1: i8) -> i8
    requires
        -16 <= x1,
        x1 < 16,
{
    let x2 = x1 + x1;
    let x4 = x2 + x2;
    x4 + x4
}
// ANCHOR_END: pre2

fn main() {
}

// ANCHOR: pre3
fn main() {
    let n = octuple(20);
}
// ANCHOR_END: pre3

// ANCHOR: pre4
fn main() {
    let n = octuple(10);
}
// ANCHOR_END: pre4
*/

// ANCHOR: post1
fn main() {
    let n = octuple(10);
    assert(n == 80);
}
// ANCHOR_END: post1

// ANCHOR: post2
fn octuple(x1: i8) -> (x8: i8)
    requires
        -16 <= x1,
        x1 < 16,
    ensures
        x8 == 8 * x1,
{
    let x2 = x1 + x1;
    let x4 = x2 + x2;
    x4 + x4
}
// ANCHOR_END: post2

} // verus!
","#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

/*
// ANCHOR: init
fn octuple(x1: i8) -> i8 {
    let x2 = x1 + x1;
    let x4 = x2 + x2;
    x4 + x4
}
// ANCHOR_END: init

fn main() {
}

// ANCHOR: pre1
fn octuple(x1: i8) -> i8
    requires
        -64 <= x1,
        x1 < 64,
{
    let x2 = x1 + x1;
    let x4 = x2 + x2;
    x4 + x4
}
// ANCHOR_END: pre1

fn main() {
}

// ANCHOR: pre2
fn octuple(x1: i8) -> i8
    requires
        -16 <= x1,
        x1 < 16,
{
    let x2 = x1 + x1;
    let x4 = x2 + x2;
    x4 + x4
}
// ANCHOR_END: pre2

fn main() {
}

// ANCHOR: pre3
fn main() {
    let n = octuple(20);
}
// ANCHOR_END: pre3

// ANCHOR: pre4
fn main() {
    let n = octuple(10);
}
// ANCHOR_END: pre4
*/

// ANCHOR: post1
fn main() {
    let n = octuple(10);
    assert(n == 80);
}
// ANCHOR_END: post1

// ANCHOR: post2
fn octuple(x1: i8) -> (x8: i8)
    requires
        -16 <= x1,
        x1 < 16,
    ensures
        x8 == 8 * x1,
{
    let x2 = x1 + x1;
    let x4 = x2 + x2;
    x4 + x4
}
// ANCHOR_END: post2

} // verus!
","['#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n/*\n// ANCHOR: init\nfn octuple(x1: i8) -> i8 {\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: init\n\nfn main() {\n}\n\n// ANCHOR: pre1\nfn octuple(x1: i8) -> i8\n    requires\n        -64 <= x1,\n        x1 < 64,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre1\n\nfn main() {\n}\n\n// ANCHOR: pre2\nfn octuple(x1: i8) -> i8\n    requires\n        -16 <= x1,\n        x1 < 16,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre2\n\nfn main() {\n}\n\n// ANCHOR: pre3\nfn main() {\n    let n = octuple(20);\n}\n// ANCHOR_END: pre3\n\n// ANCHOR: pre4\nfn main() {\n    let n = octuple(10);\n}\n// ANCHOR_END: pre4\n*/\n\n// ANCHOR: post1\nfn main() {\n    let n = octuple(10);\n    assert(n == 80);\n}\n// ANCHOR_END: post1\n\n// ANCHOR: post2\nfn octuple(x1: i8) -> (x8: i8)\n    requires\n        -16 <= x1,\n        x1 < 16,\n    ensures\n        x8 == 8 * x1,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: post2\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/guide/strings.rs,60,60,1.0,0.663,False,0.8999999999999999,True,['vstd::prelude::'],True,,,True,,,"// rust_verify/tests/example.rs
use vstd::prelude::*;

verus! {

// ANCHOR: initial
fn get_char() {
    let x = ""hello world"";
    proof {
        reveal_strlit(""hello world"");
    }
    assert(x@.len() == 11);
    let val = x.get_char(0);
    assert('h' === val);
}
// ANCHOR_END: initial

// ANCHOR: literal_eq
fn literal_eq() {
    let x = ""hello world"";
    let y = ""hello world"";
    assert(x@ == y@);
}
// ANCHOR_END: literal_eq
//
// ANCHOR: literal_view
fn str_view() {
    let x = ""hello world"";
    let ghost y: Seq<char> = x@;
}
// ANCHOR_END: literal_view

// ANCHOR: pre_substring
fn subrange<'a>(s: &str)
    requires s@ =~= ""Hello""@,
{
    proof {
        reveal_strlit(""Hello"");
        reveal_strlit(""H"");
    }
    assert(s@.subrange(0, 1) =~= ""H""@);
}
// ANCHOR_END: pre_substring

// ANCHOR: substring_ascii
fn test() {
    let a = String::from_str((""ABC""));
    proof {
        reveal_strlit(""ABC"");
    }
    assert(a.is_ascii());
    let b = a.as_str().substring_ascii(2, 3);
    proof {
        reveal_strlit(""C"");
    }
    assert(b@ =~= (""C"")@);
}
// ANCHOR_END: substring_ascii

} // verus!","// rust_verify/tests/example.rs
use vstd::prelude::*;

verus! {

// ANCHOR: initial
fn get_char() {
    let x = ""hello world"";
    proof {
        reveal_strlit(""hello world"");
    }
    assert(x@.len() == 11);
    let val = x.get_char(0);
    assert('h' === val);
}
// ANCHOR_END: initial

// ANCHOR: literal_eq
fn literal_eq() {
    let x = ""hello world"";
    let y = ""hello world"";
    assert(x@ == y@);
}
// ANCHOR_END: literal_eq
//
// ANCHOR: literal_view
fn str_view() {
    let x = ""hello world"";
    let ghost y: Seq<char> = x@;
}
// ANCHOR_END: literal_view

// ANCHOR: pre_substring
fn subrange<'a>(s: &str)
    requires s@ =~= ""Hello""@,
{
    proof {
        reveal_strlit(""Hello"");
        reveal_strlit(""H"");
    }
    assert(s@.subrange(0, 1) =~= ""H""@);
}
// ANCHOR_END: pre_substring

// ANCHOR: substring_ascii
fn test() {
    let a = String::from_str((""ABC""));
    proof {
        reveal_strlit(""ABC"");
    }
    assert(a.is_ascii());
    let b = a.as_str().substring_ascii(2, 3);
    proof {
        reveal_strlit(""C"");
    }
    assert(b@ =~= (""C"")@);
}
// ANCHOR_END: substring_ascii

} // verus!",[]
/Users/ameliakuang/Repos/dep_verus/examples/imo_1988_6.rs,127,13,0.10236220472440945,245.154,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;

// IMO 1988, #6.
// Let a and b be positive integers such that (a^2 + b^2) / (ab + 1) is an integer.
// Prove that it is a perfect square.
//
// This is a classic example of ""vieta jumping"". It makes a decent exercise
// utilizing nonlinear arithmetic in Verus.
// Closely following the solution given here:
//    https://en.wikipedia.org/wiki/Vieta_jumping#Geometric_interpretation

verus! {

proof fn vieta_jump(b: int, c: int, x: int)
    by (nonlinear_arith)
    requires
        x * x - b * x + c == 0,
    ensures
        ({
            let y = b - x;
            y * y - b * y + c == 0 && y * x == c
        }),
{
}

proof fn sqrt2_contradiction(a: int)
    requires
        a * a == 2,
    ensures
        false,
{
    assert(a * a == 2 ==> false) by (nonlinear_arith);
}

proof fn is_perfect_square_wlog(a: int, b: int, q: int) -> (sqrt: int)
    requires
        a >= 0,
        b >= 0,
        a * a + b * b == (a * b + 1) * q,
        q > 2,
        a < b,
    ensures
        sqrt * sqrt == q,
    decreases a + b, 0int,
{
    if a == 0 {
        assert(a * a == 0);
        assert(a * b == 0);
        return b;
    } else {
        assert(b * b - (q * a) * b + (a * a - q) == 0) by {
            assert((a * b + 1) * q == (a * b) * q + q) by (nonlinear_arith);
            assert((a * b) * q == (q * a) * b) by (nonlinear_arith);
        }
        vieta_jump(q * a, a * a - q, b);
        let b1 = q * a - b;
        assert(b1 * b1 - (q * a) * b1 + (a * a - q) == 0);
        assert(a * a + b1 * b1 == (a * b1 + 1) * q) by {
            assert((a * b1 + 1) * q == (a * b1) * q + q) by (nonlinear_arith);
            assert((a * b1) * q == (q * a) * b1) by (nonlinear_arith);
        }
        assert(b1 < b) by {
            assert(a > 0);
            assert(b1 * b == a * a - q);
            assert(b1 <= a) by {
                assert(a >= 0 && b >= 0 && b1 > a && b > a ==> b1 * b >= a * a)
                    by (nonlinear_arith);
            }
        }
        assert(b1 >= 0) by {
            assert(a * a + b1 * b1 == (a * b1 + 1) * q && a >= 1 && q > 2 ==> a * b1 + 1 > 0)
                by (nonlinear_arith);
            assert(a * b1 + 1 > 0 && a > 0 ==> b1 >= 0) by (nonlinear_arith);
        }
        return is_perfect_square(a, b1, q);
    }
}

// Main result
proof fn is_perfect_square(a: int, b: int, q: int) -> (sqrt: int)
    requires
        a >= 0,
        b >= 0,
        a * a + b * b == (a * b + 1) * q,
    ensures
        sqrt * sqrt == q,
    decreases a + b, 1int,
{
    if q < 0 {
        assert(a >= 0 && b >= 0 && a * a + b * b == (a * b + 1) * q ==> q >= 0)
            by (nonlinear_arith);
        assert(false);
        return 0;
    } else if q == 0 {
        return 0;
    } else if q == 1 {
        return 1;
    } else if q == 2 {
        assert((a - b) * (a - b) == 2) by (nonlinear_arith)
            requires
                a * a + b * b == (a * b + 1) * 2,
        ;
        sqrt2_contradiction(a - b);
        return 0;
    } else {
        assert(q > 2);
        if a == b {
            assert(2 * a * a == a * a + a * a) by (nonlinear_arith);
            assert(q > 2 ==> (a * a + 1) * q >= (a * a + 1) * 2) by (nonlinear_arith);
            assert(false);
            return 0;
        } else if a < b {
            return is_perfect_square_wlog(a, b, q);
        } else {
            assert(a > b);
            return is_perfect_square_wlog(b, a, q);
        }
    }
}

fn main() {
}

} // verus!
","use verus_builtin::*;
use verus_builtin_macros::*;
verus !{
  fn vieta_jump(b
                      : int, c
                      : int, x
                      : int) by(nonlinear_arith)
    requires c == 0, ({
    let y = x;
    x == c
  }){}
  fn main();
}
","['#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n// IMO 1988, #6.\n// Let a and b be positive integers such that (a^2 + b^2) / (ab + 1) is an integer.\n// Prove that it is a perfect square.\n//\n// This is a classic example of ""vieta jumping"". It makes a decent exercise\n// utilizing nonlinear arithmetic in Verus.\n// Closely following the solution given here:\n//    https://en.wikipedia.org/wiki/Vieta_jumping#Geometric_interpretation\n\nverus! {\n\nproof fn vieta_jump(b: int, c: int, x: int)\n    by (nonlinear_arith)\n    requires\n        x * x - b * x + c == 0,\n    ensures\n        ({\n            let y = b - x;\n            y * y - b * y + c == 0 && y * x == c\n        }),\n{\n}\n\nproof fn sqrt2_contradiction(a: int)\n    requires\n        a * a == 2,\n    ensures\n        false,\n{\n    assert(a * a == 2 ==> false) by (nonlinear_arith);\n}\n\nproof fn is_perfect_square_wlog(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n        q > 2,\n        a < b,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 0int,\n{\n    if a == 0 {\n        assert(a * a == 0);\n        assert(a * b == 0);\n        return b;\n    } else {\n        assert(b * b - (q * a) * b + (a * a - q) == 0) by {\n            assert((a * b + 1) * q == (a * b) * q + q) by (nonlinear_arith);\n            assert((a * b) * q == (q * a) * b) by (nonlinear_arith);\n        }\n        vieta_jump(q * a, a * a - q, b);\n        let b1 = q * a - b;\n        assert(b1 * b1 - (q * a) * b1 + (a * a - q) == 0);\n        assert(a * a + b1 * b1 == (a * b1 + 1) * q) by {\n            assert((a * b1 + 1) * q == (a * b1) * q + q) by (nonlinear_arith);\n            assert((a * b1) * q == (q * a) * b1) by (nonlinear_arith);\n        }\n        assert(b1 < b) by {\n            assert(a > 0);\n            assert(b1 * b == a * a - q);\n            assert(b1 <= a) by {\n                assert(a >= 0 && b >= 0 && b1 > a && b > a ==> b1 * b >= a * a)\n                    by (nonlinear_arith);\n            }\n        }\n        assert(b1 >= 0) by {\n            assert(a * a + b1 * b1 == (a * b1 + 1) * q && a >= 1 && q > 2 ==> a * b1 + 1 > 0)\n                by (nonlinear_arith);\n            assert(a * b1 + 1 > 0 && a > 0 ==> b1 >= 0) by (nonlinear_arith);\n        }\n        return is_perfect_square(a, b1, q);\n    }\n}\n\n// Main result\nproof fn is_perfect_square(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 1int,\n{\n    if q < 0 {\n        assert(a >= 0 && b >= 0 && a * a + b * b == (a * b + 1) * q ==> q >= 0)\n            by (nonlinear_arith);\n        assert(false);\n        return 0;\n    } else if q == 0 {\n        return 0;\n    } else if q == 1 {\n        return 1;\n    } else if q == 2 {\n        assert((a - b) * (a - b) == 2) by (nonlinear_arith)\n            requires\n                a * a + b * b == (a * b + 1) * 2,\n        ;\n        sqrt2_contradiction(a - b);\n        return 0;\n    } else {\n        assert(q > 2);\n        if a == b {\n            assert(2 * a * a == a * a + a * a) by (nonlinear_arith);\n            assert(q > 2 ==> (a * a + 1) * q >= (a * a + 1) * 2) by (nonlinear_arith);\n            assert(false);\n            return 0;\n        } else if a < b {\n            return is_perfect_square_wlog(a, b, q);\n        } else {\n            assert(a > b);\n            return is_perfect_square_wlog(b, a, q);\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  fn vieta_jump(b\n                      : int, c\n                      : int, x\n                      : int) by(nonlinear_arith)\n    requires c == 0, ({\n    let y = x;\n    x == c\n  }){}\n  fn main();\n}\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{\n  fn vieta_jump(c\n                      : int, x\n                      : int)\n    requires {}\n  fn main();\n}\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{\n  fn main();\n}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/impl_basic.rs,68,68,1.0,153.572,True,0.9999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,2.0,"use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

#[derive(PartialEq, Eq)]
struct Car {
    four_doors: bool,
    passengers: u64,
}

impl Car {
    fn new() -> Car {
        ensures(|result: Car| equal(result.passengers, 201));
        Car { four_doors: false, passengers: 201 }
    }

    fn get_passengers(&self) -> u64 {
        ensures(|result: u64| result == self.passengers);
        self.passengers
    }
}

#[derive(PartialEq, Eq)]
struct TemplateCar<V> {
    four_doors: bool,
    passengers: u64,
    the_v: V,
}

impl<V> TemplateCar<V> {
    fn template_new(v: V) -> (result: TemplateCar<V>)
        ensures
            result.passengers == 205 && result.the_v == v,
    {
        TemplateCar::<V> { four_doors: false, passengers: 205, the_v: v }
    }

    fn template_get_passengers(&self) -> (result: u64)
        ensures
            result == self.passengers,
    {
        self.passengers
    }

    fn template_get_v(self) -> (result: V)
        ensures
            result == self.the_v,
    {
        self.the_v
    }
}

fn main() {
    let c = Car { four_doors: true, passengers: 3 };
    let p = c.get_passengers();
    assert(p < 4);
    let c2 = Car::new();
    let p2 = c2.get_passengers();
    assert(p2 == 201);
    let c3 = TemplateCar::<u64>::template_new(5);
    let p3 = c3.template_get_passengers();
    assert(p3 == 205);
    let v = c3.template_get_v();
    assert(v == 5);
}

} // verus!
","use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

#[derive(PartialEq, Eq)]
struct Car {
    four_doors: bool,
    passengers: u64,
}

impl Car {
    fn new() -> Car {
        ensures(|result: Car| equal(result.passengers, 201));
        Car { four_doors: false, passengers: 201 }
    }

    fn get_passengers(&self) -> u64 {
        ensures(|result: u64| result == self.passengers);
        self.passengers
    }
}

#[derive(PartialEq, Eq)]
struct TemplateCar<V> {
    four_doors: bool,
    passengers: u64,
    the_v: V,
}

impl<V> TemplateCar<V> {
    fn template_new(v: V) -> (result: TemplateCar<V>)
        ensures
            result.passengers == 205 && result.the_v == v,
    {
        TemplateCar::<V> { four_doors: false, passengers: 205, the_v: v }
    }

    fn template_get_passengers(&self) -> (result: u64)
        ensures
            result == self.passengers,
    {
        self.passengers
    }

    fn template_get_v(self) -> (result: V)
        ensures
            result == self.the_v,
    {
        self.the_v
    }
}

fn main() {
    let c = Car { four_doors: true, passengers: 3 };
    let p = c.get_passengers();
    assert(p < 4);
    let c2 = Car::new();
    let p2 = c2.get_passengers();
    assert(p2 == 201);
    let c3 = TemplateCar::<u64>::template_new(5);
    let p3 = c3.template_get_passengers();
    assert(p3 == 205);
    let v = c3.template_get_v();
    assert(v == 5);
}

} // verus!
","['use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Car {\n    four_doors: bool,\n    passengers: u64,\n}\n\nimpl Car {\n    fn new() -> Car {\n        ensures(|result: Car| equal(result.passengers, 201));\n        Car { four_doors: false, passengers: 201 }\n    }\n\n    fn get_passengers(&self) -> u64 {\n        ensures(|result: u64| result == self.passengers);\n        self.passengers\n    }\n}\n\n#[derive(PartialEq, Eq)]\nstruct TemplateCar<V> {\n    four_doors: bool,\n    passengers: u64,\n    the_v: V,\n}\n\nimpl<V> TemplateCar<V> {\n    fn template_new(v: V) -> (result: TemplateCar<V>)\n        ensures\n            result.passengers == 205 && result.the_v == v,\n    {\n        TemplateCar::<V> { four_doors: false, passengers: 205, the_v: v }\n    }\n\n    fn template_get_passengers(&self) -> (result: u64)\n        ensures\n            result == self.passengers,\n    {\n        self.passengers\n    }\n\n    fn template_get_v(self) -> (result: V)\n        ensures\n            result == self.the_v,\n    {\n        self.the_v\n    }\n}\n\nfn main() {\n    let c = Car { four_doors: true, passengers: 3 };\n    let p = c.get_passengers();\n    assert(p < 4);\n    let c2 = Car::new();\n    let p2 = c2.get_passengers();\n    assert(p2 == 201);\n    let c3 = TemplateCar::<u64>::template_new(5);\n    let p3 = c3.template_get_passengers();\n    assert(p3 == 205);\n    let v = c3.template_get_v();\n    assert(v == 5);\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\n         use verus_builtin_macros::*;\n         verus! {        struct Car ;        impl Car {}        struct TemplateCar<V> {           four_doors: bool,     passengers: u64,     the_v: V, }        impl<V> TemplateCar<V> {}        fn main() ;        }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/integer_ring/circular_by_d.rs,165,165,1.0,,,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",False,other,,,,5.0,"// rust_verify/tests/example.rs ignore --- currently times out

// lemma originally from @hayley-leblanc
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::*;

verus! {

pub proof fn lemma_mod_subtract_helper(
    x: int,
    y: int,
    d: int,
    small_x: int,
    small_y: int,
    tmp1: int,
)
    by (integer_ring)
    requires
        d != 0,
        small_x == x % d,
        small_y == y % d,
        tmp1 == (x + y) % d,
    ensures
        (small_x + y - tmp1) % d == 0,
{
}

pub proof fn lemma_mod_subtract(x: int, y: int, d: int)
    by (nonlinear_arith)
    requires
        d > 0,
        (x % d) + y >= d,
        0 <= y < d,
    ensures
        (x % d) + y - d == (x + y) % d,
{
    let small_x = x % d;
    let small_y = y % d;
    let tmp1 = (x + y) % d;
    lemma_mod_subtract_helper(x, y, d, small_x, small_y, tmp1);
}

pub proof fn lemma_mod_difference_equal_helper(
    x: int,
    y: int,
    d: int,
    small_x: int,
    small_y: int,
    tmp1: int,
    tmp2: int,
)
    by (integer_ring)
    requires
        d != 0,
        small_x == x % d,
        small_y == y % d,
        tmp1 == (small_y - small_x) % d,
        tmp2 == (y - x) % d,
    ensures
        (tmp1 - tmp2) % d == 0,
{
}

pub proof fn lemma_mod_difference_equal(x: int, y: int, d: int)
    by (nonlinear_arith)
    requires
        d > 0,
        x <= y,
        x % d <= y % d,
        y - x < d,
    ensures
        y % d - x % d == y - x,
{
    let small_x = x % d;
    let small_y = y % d;
    let tmp1 = (small_y - small_x) % d;
    let tmp2 = (y - x) % d;
    lemma_mod_difference_equal_helper(x, y, d, small_x, small_y, tmp1, tmp2);
}

pub proof fn lemma_mod_wrapped_len_helper(
    x: int,
    y: int,
    d: int,
    small_x: int,
    small_y: int,
    tmp1: int,
)
    by (integer_ring)
    requires
        d != 0,
        small_x == x % d,
        small_y == y % d,
        tmp1 == (d - small_x + small_y) % d,
    ensures
        (y - x - tmp1) % d == 0,
{
}

pub proof fn lemma_mod_wrapped_len(x: int, y: int, d: int)
    by (nonlinear_arith)
    requires
        d > 0,
        x <= y,
        x % d > y % d,
        y - x < d,
    ensures
        d - (x % d) + (y % d) == y - x,
{
    let small_x = x % d;
    let small_y = y % d;
    let tmp1 = (d - small_x + small_y) % d;
    lemma_mod_wrapped_len_helper(x, y, d, small_x, small_y, tmp1);
}

pub proof fn lemma_mod_between_helper(x: int, y: int, d: int)
    by (integer_ring)
    requires
        d != 0,
    ensures
        (x % d - y % d) % d == (x - y) % d,
{
}

// note that below two facts are from the helper function, and the rest are done by this following function.
// x % d - y % d == x - y  mod d
// y % d - z % d == y - z  mod d
pub proof fn lemma_mod_between(d: int, x: int, y: int, z: int)
    by (nonlinear_arith)
    requires
        d > 0,
        x % d < y % d,
        y - x <= d,
        x <= z < y,
    ensures
        x % d <= z % d < y % d,
{
    lemma_mod_between_helper(x, z, d);
    lemma_mod_between_helper(y, z, d);
}

// TODO: with the new, stable approach to AIR variable naming, this lemma now times out
//       it is likely it was already unstable, and the new naming triggered the instability
// note that below two facts are from the helper function, and the rest are done by this following function.
// x % d - y % d == x - y  mod d
// y % d - z % d == y - z  mod d
pub proof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)
    by (nonlinear_arith)
    requires
        d > 0,
        y % d < x % d,
        y - x <= d,
        x <= z < y,
    ensures
        z % d < y % d || z % d >= x % d,
{
    lemma_mod_between_helper(x, z, d);
    lemma_mod_between_helper(z, y, d);
}

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs ignore --- currently times out

// lemma originally from @hayley-leblanc
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::*;

verus! {

pub proof fn lemma_mod_subtract_helper(
    x: int,
    y: int,
    d: int,
    small_x: int,
    small_y: int,
    tmp1: int,
)
    by (integer_ring)
    requires
        d != 0,
        small_x == x % d,
        small_y == y % d,
        tmp1 == (x + y) % d,
    ensures
        (small_x + y - tmp1) % d == 0,
{
}

pub proof fn lemma_mod_subtract(x: int, y: int, d: int)
    by (nonlinear_arith)
    requires
        d > 0,
        (x % d) + y >= d,
        0 <= y < d,
    ensures
        (x % d) + y - d == (x + y) % d,
{
    let small_x = x % d;
    let small_y = y % d;
    let tmp1 = (x + y) % d;
    lemma_mod_subtract_helper(x, y, d, small_x, small_y, tmp1);
}

pub proof fn lemma_mod_difference_equal_helper(
    x: int,
    y: int,
    d: int,
    small_x: int,
    small_y: int,
    tmp1: int,
    tmp2: int,
)
    by (integer_ring)
    requires
        d != 0,
        small_x == x % d,
        small_y == y % d,
        tmp1 == (small_y - small_x) % d,
        tmp2 == (y - x) % d,
    ensures
        (tmp1 - tmp2) % d == 0,
{
}

pub proof fn lemma_mod_difference_equal(x: int, y: int, d: int)
    by (nonlinear_arith)
    requires
        d > 0,
        x <= y,
        x % d <= y % d,
        y - x < d,
    ensures
        y % d - x % d == y - x,
{
    let small_x = x % d;
    let small_y = y % d;
    let tmp1 = (small_y - small_x) % d;
    let tmp2 = (y - x) % d;
    lemma_mod_difference_equal_helper(x, y, d, small_x, small_y, tmp1, tmp2);
}

pub proof fn lemma_mod_wrapped_len_helper(
    x: int,
    y: int,
    d: int,
    small_x: int,
    small_y: int,
    tmp1: int,
)
    by (integer_ring)
    requires
        d != 0,
        small_x == x % d,
        small_y == y % d,
        tmp1 == (d - small_x + small_y) % d,
    ensures
        (y - x - tmp1) % d == 0,
{
}

pub proof fn lemma_mod_wrapped_len(x: int, y: int, d: int)
    by (nonlinear_arith)
    requires
        d > 0,
        x <= y,
        x % d > y % d,
        y - x < d,
    ensures
        d - (x % d) + (y % d) == y - x,
{
    let small_x = x % d;
    let small_y = y % d;
    let tmp1 = (d - small_x + small_y) % d;
    lemma_mod_wrapped_len_helper(x, y, d, small_x, small_y, tmp1);
}

pub proof fn lemma_mod_between_helper(x: int, y: int, d: int)
    by (integer_ring)
    requires
        d != 0,
    ensures
        (x % d - y % d) % d == (x - y) % d,
{
}

// note that below two facts are from the helper function, and the rest are done by this following function.
// x % d - y % d == x - y  mod d
// y % d - z % d == y - z  mod d
pub proof fn lemma_mod_between(d: int, x: int, y: int, z: int)
    by (nonlinear_arith)
    requires
        d > 0,
        x % d < y % d,
        y - x <= d,
        x <= z < y,
    ensures
        x % d <= z % d < y % d,
{
    lemma_mod_between_helper(x, z, d);
    lemma_mod_between_helper(y, z, d);
}

// TODO: with the new, stable approach to AIR variable naming, this lemma now times out
//       it is likely it was already unstable, and the new naming triggered the instability
// note that below two facts are from the helper function, and the rest are done by this following function.
// x % d - y % d == x - y  mod d
// y % d - z % d == y - z  mod d
pub proof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)
    by (nonlinear_arith)
    requires
        d > 0,
        y % d < x % d,
        y - x <= d,
        x <= z < y,
    ensures
        z % d < y % d || z % d >= x % d,
{
    lemma_mod_between_helper(x, z, d);
    lemma_mod_between_helper(z, y, d);
}

fn main() {
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/integer_ring/integer_ring.rs,311,311,1.0,,,0.85,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",False,other,,,,16.0,"// most of the codes are copied from: https://github.com/utaal/verified-nrkernel/blob/main/page-table/lib.rs
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::{pervasive::*, *};

verus! {

proof fn mod_of_mul_int(a: int, b: int)
    by (integer_ring)
    requires b != 0,
    ensures (a * b) % b == 0,
{
}

proof fn mod_of_mul(a: nat, b: nat)
    by (nonlinear_arith)
    requires
        b > 0,
    ensures
        (a * b) % b == 0,
{
    mod_of_mul_int(a as int, b as int);
    // if a == 0 {}
    // else {
    //     assert(a > 0);
    //     assert(b > 0);
    //     assert(a*b > 0);
    //     assert( (a*b) % b >= 0);
    // }
}

pub proof fn mod_add_zero_int(a: int, b: int, c: int)
    by (integer_ring)
    requires
        c != 0,
        a % c == 0,
        b % c == 0,
    ensures
        (a + b) % c == 0,
{
}

pub proof fn mod_add_zero(a: nat, b: nat, c: nat)
    by (nonlinear_arith)
    requires
        a % c == 0,
        b % c == 0,
        c > 0,
    ensures
        (a + b) % c == 0,
{
    mod_add_zero_int(a as int, b as int, c as int);
}

pub proof fn subtract_mod_aligned_int(a: int, b: int)
    by (integer_ring)
    requires
        b != 0,
    ensures
        (a - (a % b)) % b == 0,
{
}

pub proof fn subtract_mod_aligned(a: nat, b: nat)
    by (nonlinear_arith)
    requires
        0 < b,
    ensures
        (a - (a % b)) % (b as int) == 0,
{
    subtract_mod_aligned_int(a as int, b as int);
}

pub proof fn mod_mult_zero_implies_mod_zero_int(a: int, b: int, c: int)
    by (integer_ring)
    requires
        b != 0,
        b * c != 0,
        a % (b * c) == 0,
    ensures
        a % b == 0,
{
}

pub proof fn mod_mult_zero_implies_mod_zero(a: nat, b: nat, c: nat)
    by (nonlinear_arith)
    requires
        a % (b * c) == 0,
        b > 0,
        c > 0,
    ensures
        a % b == 0,
{
    mod_mult_zero_implies_mod_zero_int(a as int, b as int, c as int);
}

pub proof fn subtract_mod_eq_zero_int(a: int, b: int, c: int)
    by (integer_ring)
    requires
        c != 0,
        a % c == 0,
        b % c == 0,
    ensures
        (b - a) % c == 0,
{
}

pub proof fn subtract_mod_eq_zero(a: nat, b: nat, c: nat)
    by (nonlinear_arith)
    requires
        a % c == 0,
        b % c == 0,
        a <= b,
        c > 0,
    ensures
        (b - a) % (c as int) == 0,
{
    subtract_mod_eq_zero_int(a as int, b as int, c as int);
}

pub proof fn multiple_offsed_mod_gt_0_int(a: int, b: int, c: int, ac: int, bc: int, abc: int)
    by (integer_ring)
    requires
        c != 0,
        ac == a % c,
        bc == b % c,
        abc == (a - b) % c,
    ensures
        (ac - bc - abc) % c == 0,
{
}

pub proof fn multiple_offsed_mod_gt_0(a: nat, b: nat, c: nat)
    by (nonlinear_arith)
    requires
        a > b,
        c > 0,
        b % c == 0,
        a % c > 0,
    ensures
        (a - b) % (c as int) > 0,
{
    multiple_offsed_mod_gt_0_int(
        a as int,
        b as int,
        c as int,
        (a % c) as int,
        (b % c) as int,
        ((a - b) % (c as int)) as int,
    );
}

// currently can't use Singular for this proof
// however, I think we can extend the encoding for div
pub proof fn FundamentalDivMod(x: int, d: int)
    by (nonlinear_arith)
    requires
        d > 0,
    ensures
        x == d * (x / d) + (x % d),
{
}

// can't use Singular for this proof because of bound
// however, there might be a way to encode this as an ""axiom"" in Singular
// add an equality to the ring whenever we can prove a bound from Z3
pub proof fn LemmaSmallMod(x: int, m: int)
    by (nonlinear_arith)
    requires
        x >= 0,
        m > 0,
        x < m,
    ensures
        x % m == x,
{
}

// can't use Singular for this proof because of bound
pub proof fn LemmaModBasics(x: int, m: int)
    by (nonlinear_arith)
    requires
        m > 0,
    ensures
        m % m == 0,
        (x % m) % m == x % m,
        0 <= x % m,
        x % m < m,
{
}

// can't use Singular for this proof because of bound
pub proof fn LemmaModDecreases(x: int, m: int)
    by (nonlinear_arith)
    requires
        m > 0,
        x >= 0,
    ensures
        x % m <= x,
{
}

// can't use Singular for this proof because of bound
pub proof fn LemmaModIsZero(x: int, m: int)
    by (nonlinear_arith)
    requires
        m > 0,
        x > 0,
        x % m == 0,
    ensures
        m <= x,
{
}

pub proof fn LemmaModMultiplesBasic(x: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        (x * m) % m == 0,
{
}

pub proof fn LemmaModMultipleVanish(b: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        (b + m) % m == b % m,
        (b - m) % m == b % m,
{
}

pub proof fn LemmaModMultiplesVanish(a: int, b: int, m: int)
    by (integer_ring)
    requires m != 0,
    ensures
        (b + a * m) % m == b % m,
        (b + m * a) % m == b % m,
        (b - a * m) % m == b % m,
        (b - m * a) % m == b % m,
{
}

pub proof fn LemmaAddModNoopLeft(x: int, y: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        ((x % m) + y) % m == (x + y) % m,
{
}

pub proof fn LemmaSubModNoopRight(x: int, y: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        (x - (y % m)) % m == (x - y) % m,
{
}

pub proof fn LemmaModNegNeg(x: int, d: int)
    by (integer_ring)
    requires
        d != 0,
    ensures
        x % d == (x * (1 - d)) % d,
{
}

pub proof fn LemmaMulModNoopRight(x: int, y: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        x * (y % m) % m == (x * y) % m,
{
}

pub proof fn LemmaMulModNoopGeneral(x: int, y: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        ((x % m) * y) % m == (x * y) % m,
        (x * (y % m)) % m == (x * y) % m,
        ((x % m) * (y % m)) % m == (x * y) % m,
{
}

pub proof fn LemmaMulIsDistributive(x: int, y: int, z: int)
    by (integer_ring)
    ensures
        x * (y + z) == x * y + x * z,
        x * (y - z) == x * y - x * z,
        (y + z) * x == y * x + z * x,
        (y - z) * x == y * x - z * x,
        x * (y + z) == (y + z) * x,
        x * (y - z) == (y - z) * x,
        x * y == y * x,
        x * z == z * x,
{
}

fn main() {
}

} // verus!
","// most of the codes are copied from: https://github.com/utaal/verified-nrkernel/blob/main/page-table/lib.rs
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::{pervasive::*, *};

verus! {

proof fn mod_of_mul_int(a: int, b: int)
    by (integer_ring)
    requires b != 0,
    ensures (a * b) % b == 0,
{
}

proof fn mod_of_mul(a: nat, b: nat)
    by (nonlinear_arith)
    requires
        b > 0,
    ensures
        (a * b) % b == 0,
{
    mod_of_mul_int(a as int, b as int);
    // if a == 0 {}
    // else {
    //     assert(a > 0);
    //     assert(b > 0);
    //     assert(a*b > 0);
    //     assert( (a*b) % b >= 0);
    // }
}

pub proof fn mod_add_zero_int(a: int, b: int, c: int)
    by (integer_ring)
    requires
        c != 0,
        a % c == 0,
        b % c == 0,
    ensures
        (a + b) % c == 0,
{
}

pub proof fn mod_add_zero(a: nat, b: nat, c: nat)
    by (nonlinear_arith)
    requires
        a % c == 0,
        b % c == 0,
        c > 0,
    ensures
        (a + b) % c == 0,
{
    mod_add_zero_int(a as int, b as int, c as int);
}

pub proof fn subtract_mod_aligned_int(a: int, b: int)
    by (integer_ring)
    requires
        b != 0,
    ensures
        (a - (a % b)) % b == 0,
{
}

pub proof fn subtract_mod_aligned(a: nat, b: nat)
    by (nonlinear_arith)
    requires
        0 < b,
    ensures
        (a - (a % b)) % (b as int) == 0,
{
    subtract_mod_aligned_int(a as int, b as int);
}

pub proof fn mod_mult_zero_implies_mod_zero_int(a: int, b: int, c: int)
    by (integer_ring)
    requires
        b != 0,
        b * c != 0,
        a % (b * c) == 0,
    ensures
        a % b == 0,
{
}

pub proof fn mod_mult_zero_implies_mod_zero(a: nat, b: nat, c: nat)
    by (nonlinear_arith)
    requires
        a % (b * c) == 0,
        b > 0,
        c > 0,
    ensures
        a % b == 0,
{
    mod_mult_zero_implies_mod_zero_int(a as int, b as int, c as int);
}

pub proof fn subtract_mod_eq_zero_int(a: int, b: int, c: int)
    by (integer_ring)
    requires
        c != 0,
        a % c == 0,
        b % c == 0,
    ensures
        (b - a) % c == 0,
{
}

pub proof fn subtract_mod_eq_zero(a: nat, b: nat, c: nat)
    by (nonlinear_arith)
    requires
        a % c == 0,
        b % c == 0,
        a <= b,
        c > 0,
    ensures
        (b - a) % (c as int) == 0,
{
    subtract_mod_eq_zero_int(a as int, b as int, c as int);
}

pub proof fn multiple_offsed_mod_gt_0_int(a: int, b: int, c: int, ac: int, bc: int, abc: int)
    by (integer_ring)
    requires
        c != 0,
        ac == a % c,
        bc == b % c,
        abc == (a - b) % c,
    ensures
        (ac - bc - abc) % c == 0,
{
}

pub proof fn multiple_offsed_mod_gt_0(a: nat, b: nat, c: nat)
    by (nonlinear_arith)
    requires
        a > b,
        c > 0,
        b % c == 0,
        a % c > 0,
    ensures
        (a - b) % (c as int) > 0,
{
    multiple_offsed_mod_gt_0_int(
        a as int,
        b as int,
        c as int,
        (a % c) as int,
        (b % c) as int,
        ((a - b) % (c as int)) as int,
    );
}

// currently can't use Singular for this proof
// however, I think we can extend the encoding for div
pub proof fn FundamentalDivMod(x: int, d: int)
    by (nonlinear_arith)
    requires
        d > 0,
    ensures
        x == d * (x / d) + (x % d),
{
}

// can't use Singular for this proof because of bound
// however, there might be a way to encode this as an ""axiom"" in Singular
// add an equality to the ring whenever we can prove a bound from Z3
pub proof fn LemmaSmallMod(x: int, m: int)
    by (nonlinear_arith)
    requires
        x >= 0,
        m > 0,
        x < m,
    ensures
        x % m == x,
{
}

// can't use Singular for this proof because of bound
pub proof fn LemmaModBasics(x: int, m: int)
    by (nonlinear_arith)
    requires
        m > 0,
    ensures
        m % m == 0,
        (x % m) % m == x % m,
        0 <= x % m,
        x % m < m,
{
}

// can't use Singular for this proof because of bound
pub proof fn LemmaModDecreases(x: int, m: int)
    by (nonlinear_arith)
    requires
        m > 0,
        x >= 0,
    ensures
        x % m <= x,
{
}

// can't use Singular for this proof because of bound
pub proof fn LemmaModIsZero(x: int, m: int)
    by (nonlinear_arith)
    requires
        m > 0,
        x > 0,
        x % m == 0,
    ensures
        m <= x,
{
}

pub proof fn LemmaModMultiplesBasic(x: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        (x * m) % m == 0,
{
}

pub proof fn LemmaModMultipleVanish(b: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        (b + m) % m == b % m,
        (b - m) % m == b % m,
{
}

pub proof fn LemmaModMultiplesVanish(a: int, b: int, m: int)
    by (integer_ring)
    requires m != 0,
    ensures
        (b + a * m) % m == b % m,
        (b + m * a) % m == b % m,
        (b - a * m) % m == b % m,
        (b - m * a) % m == b % m,
{
}

pub proof fn LemmaAddModNoopLeft(x: int, y: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        ((x % m) + y) % m == (x + y) % m,
{
}

pub proof fn LemmaSubModNoopRight(x: int, y: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        (x - (y % m)) % m == (x - y) % m,
{
}

pub proof fn LemmaModNegNeg(x: int, d: int)
    by (integer_ring)
    requires
        d != 0,
    ensures
        x % d == (x * (1 - d)) % d,
{
}

pub proof fn LemmaMulModNoopRight(x: int, y: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        x * (y % m) % m == (x * y) % m,
{
}

pub proof fn LemmaMulModNoopGeneral(x: int, y: int, m: int)
    by (integer_ring)
    requires
        m != 0,
    ensures
        ((x % m) * y) % m == (x * y) % m,
        (x * (y % m)) % m == (x * y) % m,
        ((x % m) * (y % m)) % m == (x * y) % m,
{
}

pub proof fn LemmaMulIsDistributive(x: int, y: int, z: int)
    by (integer_ring)
    ensures
        x * (y + z) == x * y + x * z,
        x * (y - z) == x * y - x * z,
        (y + z) * x == y * x + z * x,
        (y - z) * x == y * x - z * x,
        x * (y + z) == (y + z) * x,
        x * (y - z) == (y - z) * x,
        x * y == y * x,
        x * z == z * x,
{
}

fn main() {
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/integer_ring/integer_ring_bound_check.rs,130,130,1.0,,,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",False,other,,,4.0,7.0,"// testcases and examples are ported from below two files
// 1. https://github.com/secure-foundations/dafny/blob/b402d2aeb6129603277e35fcef33bf1024f4b217/Test/gb_test.dfy
// 2. https://github.com/secure-foundations/veri-titan/blob/master/lib/generic_mm_lemmas.dfy
//
// With references from:
// https://github.com/secure-foundations/libraries/blob/master/src/NonlinearArithmetic/Mul.dfy
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::{pervasive::*, *};

verus! {

proof fn ModAfterMul(x: int, y: int, z: int, m: int)
    by (integer_ring)
    requires
        m != 0,
        (x - y) % m == 0,
    ensures
        (x * z - y * z) % m == 0,
{
}

// bound check lemmas
#[verifier::external_body]
proof fn LemmaMulUpperBound(x: int, XBound: int, y: int, YBound: int)
    by (nonlinear_arith) {
    requires([x <= XBound, y <= YBound, 0 <= x, 0 <= y]);
    ensures(x * y <= XBound * YBound);
}

proof fn LemmaMulStayPositive(x: int, y: int)
    by (nonlinear_arith)
    requires
        0 <= x,
        0 <= y,
    ensures
        0 <= x * y,
{
}

proof fn LemmaInequalityAfterMul(x: int, y: int, z: int)
    by (nonlinear_arith)
    requires
        x <= y,
        0 <= z,
    ensures
        x * z <= y * z,
{
}

proof fn ModAfterMul_u32(x: u32, y: u32, z: u32, m: u32)
    requires
        m > 0,
        (x - y) % (m as int) == 0,
        x >= y,
        x <= 0xffff,
        y <= 0xffff,
        z <= 0xffff,
        m <= 0xffff,
    ensures
        (x * z - y * z) % (m as int) == 0,
{
    ModAfterMul(x as int, y as int, z as int, m as int);
    // below are for bound checks
    // every single operation is in bound: x*z, y*z, (x*z - y*z)
    LemmaMulUpperBound(x as int, 0xffff as int, z as int, 0xffff as int);
    LemmaMulStayPositive(x as int, z as int);
    // assert( (x as int) * (z as int) == ( (x*z) as int));
    LemmaMulUpperBound(y as int, 0xffff as int, z as int, 0xffff as int);
    LemmaMulStayPositive(y as int, z as int);
    // assert( (y as int) * (z as int) == ( (y*z) as int));
    LemmaInequalityAfterMul(y as int, x as int, z as int);
    // assert( (((x*z - y*z) as int) % (m as int)) ==  (((x*z) as int) - ((y*z) as int)) % (m as int));
}

proof fn ModAfterMul_u32_with_assert_by_nonlinear(x: u32, y: u32, z: u32, m: u32)
    requires
        m > 0,
        (x - y) % (m as int) == 0,
        x >= y,
        x <= 0xffff,
        y <= 0xffff,
        z <= 0xffff,
        m <= 0xffff,
    ensures
        (x * z - y * z) % (m as int) == 0,
{
    ModAfterMul(x as int, y as int, z as int, m as int);
    assert_nonlinear_by(
        {
            requires([x <= 0xffff, z <= 0xffff]);
            ensures((x as int) * (z as int) == ((x * z) as int));
            assert(0 <= (x as int) * (z as int));
            assert((x as int) * (z as int) <= 0xffff * 0xffff);
        },
    );
    assert((x as int) * (z as int) == ((x * z) as int));
    assert_nonlinear_by(
        {
            requires([y <= 0xffff, z <= 0xffff]);
            ensures((y as int) * (z as int) == ((y * z) as int));
            assert(0 <= (y as int) * (z as int));
            assert((y as int) * (z as int) <= 0xffff * 0xffff);
        },
    );
    assert((y as int) * (z as int) == ((y * z) as int));
    // below `assert_nonlinear_by` timeouts now in newer z3
    // assert_nonlinear_by({
    //     requires([
    //         x <= 0xffff,
    //         y <= 0xffff,
    //         z <= 0xffff,
    //         ((x as int) * (z as int) == ( (x*z) as int)),
    //         ((y as int) * (z as int) == ( (y*z) as int)),
    //         (y <= x),
    //         (0 <= z),
    //     ]);
    //     ensures(y*z <= x*z);
    // });
    LemmaInequalityAfterMul(y as int, x as int, z as int);
    assert(y * z <= x * z);
}

fn main() {
}

} // verus!
","// testcases and examples are ported from below two files
// 1. https://github.com/secure-foundations/dafny/blob/b402d2aeb6129603277e35fcef33bf1024f4b217/Test/gb_test.dfy
// 2. https://github.com/secure-foundations/veri-titan/blob/master/lib/generic_mm_lemmas.dfy
//
// With references from:
// https://github.com/secure-foundations/libraries/blob/master/src/NonlinearArithmetic/Mul.dfy
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::{pervasive::*, *};

verus! {

proof fn ModAfterMul(x: int, y: int, z: int, m: int)
    by (integer_ring)
    requires
        m != 0,
        (x - y) % m == 0,
    ensures
        (x * z - y * z) % m == 0,
{
}

// bound check lemmas
#[verifier::external_body]
proof fn LemmaMulUpperBound(x: int, XBound: int, y: int, YBound: int)
    by (nonlinear_arith) {
    requires([x <= XBound, y <= YBound, 0 <= x, 0 <= y]);
    ensures(x * y <= XBound * YBound);
}

proof fn LemmaMulStayPositive(x: int, y: int)
    by (nonlinear_arith)
    requires
        0 <= x,
        0 <= y,
    ensures
        0 <= x * y,
{
}

proof fn LemmaInequalityAfterMul(x: int, y: int, z: int)
    by (nonlinear_arith)
    requires
        x <= y,
        0 <= z,
    ensures
        x * z <= y * z,
{
}

proof fn ModAfterMul_u32(x: u32, y: u32, z: u32, m: u32)
    requires
        m > 0,
        (x - y) % (m as int) == 0,
        x >= y,
        x <= 0xffff,
        y <= 0xffff,
        z <= 0xffff,
        m <= 0xffff,
    ensures
        (x * z - y * z) % (m as int) == 0,
{
    ModAfterMul(x as int, y as int, z as int, m as int);
    // below are for bound checks
    // every single operation is in bound: x*z, y*z, (x*z - y*z)
    LemmaMulUpperBound(x as int, 0xffff as int, z as int, 0xffff as int);
    LemmaMulStayPositive(x as int, z as int);
    // assert( (x as int) * (z as int) == ( (x*z) as int));
    LemmaMulUpperBound(y as int, 0xffff as int, z as int, 0xffff as int);
    LemmaMulStayPositive(y as int, z as int);
    // assert( (y as int) * (z as int) == ( (y*z) as int));
    LemmaInequalityAfterMul(y as int, x as int, z as int);
    // assert( (((x*z - y*z) as int) % (m as int)) ==  (((x*z) as int) - ((y*z) as int)) % (m as int));
}

proof fn ModAfterMul_u32_with_assert_by_nonlinear(x: u32, y: u32, z: u32, m: u32)
    requires
        m > 0,
        (x - y) % (m as int) == 0,
        x >= y,
        x <= 0xffff,
        y <= 0xffff,
        z <= 0xffff,
        m <= 0xffff,
    ensures
        (x * z - y * z) % (m as int) == 0,
{
    ModAfterMul(x as int, y as int, z as int, m as int);
    assert_nonlinear_by(
        {
            requires([x <= 0xffff, z <= 0xffff]);
            ensures((x as int) * (z as int) == ((x * z) as int));
            assert(0 <= (x as int) * (z as int));
            assert((x as int) * (z as int) <= 0xffff * 0xffff);
        },
    );
    assert((x as int) * (z as int) == ((x * z) as int));
    assert_nonlinear_by(
        {
            requires([y <= 0xffff, z <= 0xffff]);
            ensures((y as int) * (z as int) == ((y * z) as int));
            assert(0 <= (y as int) * (z as int));
            assert((y as int) * (z as int) <= 0xffff * 0xffff);
        },
    );
    assert((y as int) * (z as int) == ((y * z) as int));
    // below `assert_nonlinear_by` timeouts now in newer z3
    // assert_nonlinear_by({
    //     requires([
    //         x <= 0xffff,
    //         y <= 0xffff,
    //         z <= 0xffff,
    //         ((x as int) * (z as int) == ( (x*z) as int)),
    //         ((y as int) * (z as int) == ( (y*z) as int)),
    //         (y <= x),
    //         (0 <= z),
    //     ]);
    //     ensures(y*z <= x*z);
    // });
    LemmaInequalityAfterMul(y as int, x as int, z as int);
    assert(y * z <= x * z);
}

fn main() {
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/integers.rs,65,65,1.0,152.647,True,0.9999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

fn main() {
}

spec fn add1_int(i: int) -> int {
    i + 1
}

spec fn add1_nat(i: nat) -> nat {
    i + 1
}

#[verifier::opaque]
spec fn add1_nat_opaque(i: nat) -> nat {
    i + 1
}

proof fn test0() -> (n: nat)
    ensures
        true,
{
    100
}

proof fn test1(i: int, n: nat, u: u8) {
    assert(n >= 0);
    assert(u >= 0);
    assert(n + n >= 0);
    assert((add(u, u) as int) < 256);
    assert(u < 100 ==> (add(u, u) as int) < 250);
    assert(add1_int(u as int) == u as int + 1);
    // assert(add1_int(u) == (u + 1) as int); // FAILS
    assert(add1_nat(u as nat) == u as nat + 1);
    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256
    let n0 = test0();
    assert(n0 >= 0);
    assert(add1_nat_opaque(5) >= 0);
    // assert(i / 2 <= n); // FAILS
    assert(n / 2 <= n);
    assert(u / 2 <= u);
    assert(u % 10 < 10);
}

} // verus!
/*
fn typing(u: u64, i: int, n: nat) -> int {
    let u2 = i as u64;
    let i2 = u as int;
    let i3: int = u; // implicit coercion ok
    //let i4: int = u + 1; // implicit coercion disallowed
    //let u3: u64 = i; // implicit coercion disallowed
    let i5: int = n; // implicit coercion ok
    //let n2: nat = i; // implicit coercion disallowed
    let n3: nat = 10;
    let i6: int = -10;
    let u3: u8 = 300;
    assert(u3 > 100); // should fail
    let x = 2 + 2;
    x
}
*/
","use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

fn main() {
}

spec fn add1_int(i: int) -> int {
    i + 1
}

spec fn add1_nat(i: nat) -> nat {
    i + 1
}

#[verifier::opaque]
spec fn add1_nat_opaque(i: nat) -> nat {
    i + 1
}

proof fn test0() -> (n: nat)
    ensures
        true,
{
    100
}

proof fn test1(i: int, n: nat, u: u8) {
    assert(n >= 0);
    assert(u >= 0);
    assert(n + n >= 0);
    assert((add(u, u) as int) < 256);
    assert(u < 100 ==> (add(u, u) as int) < 250);
    assert(add1_int(u as int) == u as int + 1);
    // assert(add1_int(u) == (u + 1) as int); // FAILS
    assert(add1_nat(u as nat) == u as nat + 1);
    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256
    let n0 = test0();
    assert(n0 >= 0);
    assert(add1_nat_opaque(5) >= 0);
    // assert(i / 2 <= n); // FAILS
    assert(n / 2 <= n);
    assert(u / 2 <= u);
    assert(u % 10 < 10);
}

} // verus!
/*
fn typing(u: u64, i: int, n: nat) -> int {
    let u2 = i as u64;
    let i2 = u as int;
    let i3: int = u; // implicit coercion ok
    //let i4: int = u + 1; // implicit coercion disallowed
    //let u3: u64 = i; // implicit coercion disallowed
    let i5: int = n; // implicit coercion ok
    //let n2: nat = i; // implicit coercion disallowed
    let n3: nat = 10;
    let i6: int = -10;
    let u3: u8 = 300;
    assert(u3 > 100); // should fail
    let x = 2 + 2;
    x
}
*/
","['use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n    assert(n >= 0);\n    assert(u >= 0);\n    assert(n + n >= 0);\n    assert((add(u, u) as int) < 256);\n    assert(u < 100 ==> (add(u, u) as int) < 250);\n    assert(add1_int(u as int) == u as int + 1);\n    // assert(add1_int(u) == (u + 1) as int); // FAILS\n    assert(add1_nat(u as nat) == u as nat + 1);\n    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n    assert(n0 >= 0);\n    assert(add1_nat_opaque(5) >= 0);\n    // assert(i / 2 <= n); // FAILS\n    assert(n / 2 <= n);\n    assert(u / 2 <= u);\n    assert(u % 10 < 10);\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n    assert(u3 > 100); // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/mergesort.rs,188,15,0.0797872340425532,1000.654,True,0.9999999999999999,True,"['vstd::multiset::', 'vstd::prelude::', 'vstd::seq_lib::group_seq_properties']",True,,,,,,"use vstd::multiset::*;
use vstd::prelude::*;
use vstd::seq_lib::group_seq_properties;

verus! {

pub open spec fn is_sorted(v: &Vec<u64>) -> bool {
    forall|i: int, j: int| 0 <= i < j < v.len() ==> #[trigger] v[i] <= #[trigger] v[j]
}

fn extend_from_idx(r: &mut Vec<u64>, v: &Vec<u64>, start: usize)
    requires
        start < v.len(),
    ensures
        r@ == old(r)@ + v@.subrange(start as int, v.len() as int),
{
    for i in start..v.len()
        invariant
            r@ =~= old(r)@ + v@.subrange(start as int, i as int),
    {
        r.push(v[i]);
    }
}

pub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)
    ensures
        #[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),
    decreases s2.len(),
{
    s2.to_multiset_ensures();
    if s2.len() == 0 {
        assert((s1 + s2).to_multiset() =~= s1.to_multiset());
        assert(s2.to_multiset() =~= Multiset::<u64>::empty());
    } else {
        lemma_to_multiset_distributes_over_add(s1, s2.drop_last());
        vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);
        assert(s2.drop_last() =~= s2.remove(s2.len() - 1));
        assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));
        assert((s1 + s2).to_multiset() =~= ((s1 + s2).drop_last().push(
            s2[(s2.len() - 1) as int],
        )).to_multiset());
        (s1 + s2).drop_last().to_multiset_ensures();
    }
}

proof fn lemma_subrange_push(s1: Seq<u64>, start: int, end: int)
    requires
        0 <= start <= end < s1.len(),
    ensures
        s1.subrange(start, end).push(s1[end]) =~= s1.subrange(start, end + 1),
{
}

proof fn lemma_subrange_add(s1: Seq<u64>, start: int, mid: int, end: int)
    requires
        0 <= start <= mid <= end <= s1.len(),
    ensures
        s1.subrange(start, mid) + s1.subrange(mid, end) =~= s1.subrange(start, end),
{
}

fn merge(v1: &Vec<u64>, v2: &Vec<u64>) -> (r: Vec<u64>)
    requires
        is_sorted(v1),
        is_sorted(v2),
    ensures
        r@.to_multiset() == (v1@ + v2@).to_multiset(),
        is_sorted(&r),
{
    broadcast use lemma_to_multiset_distributes_over_add;

    let mut r: Vec<u64> = Vec::new();
    let mut i1: usize = 0;
    let mut i2: usize = 0;
    assert(v1@.subrange(0 as int, i1 as int) == Seq::<u64>::empty());

    while i1 < v1.len() && i2 < v2.len()
        invariant
            0 <= i1 <= v1.len(),
            0 <= i2 <= v2.len(),
            is_sorted(v1),
            is_sorted(v2),
            forall|i: int| i1 < v1.len() ==> 0 <= i < r.len() ==> r[i] <= v1[i1 as int],
            forall|i: int| i2 < v2.len() ==> 0 <= i < r.len() ==> r[i] <= v2[i2 as int],
            r@.to_multiset() =~= (v1@.subrange(0 as int, i1 as int) + v2@.subrange(
                0 as int,
                i2 as int,
            )).to_multiset(),
            is_sorted(&r),
        decreases v1.len() + v2.len() - i1 - i2,
    {
        proof {
            r@.to_multiset_ensures();
        }
        if v1[i1] < v2[i2] {
            r.push(v1[i1]);
            proof {
                lemma_to_multiset_distributes_over_add(
                    v1@.subrange(0 as int, i1 as int),
                    v2@.subrange(0 as int, i2 as int),
                );
                v1@.subrange(0 as int, i1 as int).to_multiset_ensures();
                lemma_subrange_push(v1@, 0 as int, i1 as int);
                lemma_to_multiset_distributes_over_add(
                    v1@.subrange(0 as int, (i1 + 1) as int),
                    v2@.subrange(0 as int, i2 as int),
                );
            }
            i1 += 1;
        } else {
            r.push(v2[i2]);
            proof {
                lemma_to_multiset_distributes_over_add(
                    v1@.subrange(0 as int, i1 as int),
                    v2@.subrange(0 as int, i2 as int),
                );
                v2@.subrange(0 as int, i2 as int).to_multiset_ensures();
                lemma_subrange_push(v2@, 0 as int, i2 as int);
                lemma_to_multiset_distributes_over_add(
                    v1@.subrange(0 as int, i1 as int),
                    v2@.subrange(0 as int, (i2 + 1) as int),
                );
            }
            i2 += 1;
        }

    }
    assert(v1@.subrange(0 as int, v1.len() as int) =~= v1@);
    assert(v2@.subrange(0 as int, v2.len() as int) =~= v2@);

    if i1 < v1.len() {
        extend_from_idx(&mut r, v1, i1);
        proof {
            lemma_subrange_add(v1@, 0 as int, i1 as int, v1.len() as int);
            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());
        }
    } else if i2 < v2.len() {
        extend_from_idx(&mut r, v2, i2);
        proof {
            lemma_subrange_add(v2@, 0 as int, i2 as int, v2.len() as int);
            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());
        }
    }
    r
}

fn merge_sort(v: &Vec<u64>) -> (r: Vec<u64>)
    ensures
        r@.to_multiset() == (*v)@.to_multiset(),
        is_sorted(&r),
    decreases v.len(),
{
    let n = v.len();
    let mut v1 = v.clone();
    if (n <= 1) {
        v1
    } else {
        let mut v2 = v1.split_off(n / 2);
        assert(v1@ + v2@ == v@);
        proof {
            lemma_to_multiset_distributes_over_add(v1@, v2@);
        }
        let r1 = merge_sort(&mut v1);
        let r2 = merge_sort(&mut v2);
        proof {
            lemma_to_multiset_distributes_over_add(r1@, r2@);
        }
        let r = merge(&r1, &r2);
        r
    }
}

fn main() {
    let v = vec![9, 10, 4, 5, 1, 3];
    let v_sorted = merge_sort(&v);
    let ghost expected_res: Seq<u64> = seq![1, 3, 4, 5, 9, 10];
    proof {
        broadcast use group_seq_properties; 
        assert(v@ =~= seq![9].push(10).push(4).push(5).push(1).push(3));
        assert(expected_res =~= seq![1].push(3).push(4).push(5).push(9).push(10));

        assert(expected_res.to_multiset() =~= v@.to_multiset());
        vstd::seq_lib::lemma_sorted_unique(expected_res, v_sorted@, |a: u64, b: u64| a <= b);
        assert(v_sorted@ =~= expected_res);
    }
}

} // verus!
","    use vstd::prelude::*;
           verus! {
         pub open spec fn is_sorted(v: &Vec<u64>) -> bool {
           forall|i: int, j: int| 0 <= i < j < v.len() ==>           
#[trigger] v[i] <= #[trigger] v[j]
}
         pub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)     ensures                   
#[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),
    decreases s2.len(), {
           s2.to_multiset_ensures();
           if s2.len() == 0 {}
       else {              lemma_to_multiset_distributes_over_add(s1, s2.drop_last());              vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);              assert(s2.drop_last() =~= s2.remove(s2.len() - 1));              assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));              (s1 + s2).drop_last().to_multiset_ensures();          }
       }
         fn main() ;
         }
","['use vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq_lib::group_seq_properties;\n\nverus! {\n\npub open spec fn is_sorted(v: &Vec<u64>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> #[trigger] v[i] <= #[trigger] v[j]\n}\n\nfn extend_from_idx(r: &mut Vec<u64>, v: &Vec<u64>, start: usize)\n    requires\n        start < v.len(),\n    ensures\n        r@ == old(r)@ + v@.subrange(start as int, v.len() as int),\n{\n    for i in start..v.len()\n        invariant\n            r@ =~= old(r)@ + v@.subrange(start as int, i as int),\n    {\n        r.push(v[i]);\n    }\n}\n\npub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)\n    ensures\n        #[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(),\n{\n    s2.to_multiset_ensures();\n    if s2.len() == 0 {\n        assert((s1 + s2).to_multiset() =~= s1.to_multiset());\n        assert(s2.to_multiset() =~= Multiset::<u64>::empty());\n    } else {\n        lemma_to_multiset_distributes_over_add(s1, s2.drop_last());\n        vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);\n        assert(s2.drop_last() =~= s2.remove(s2.len() - 1));\n        assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));\n        assert((s1 + s2).to_multiset() =~= ((s1 + s2).drop_last().push(\n            s2[(s2.len() - 1) as int],\n        )).to_multiset());\n        (s1 + s2).drop_last().to_multiset_ensures();\n    }\n}\n\nproof fn lemma_subrange_push(s1: Seq<u64>, start: int, end: int)\n    requires\n        0 <= start <= end < s1.len(),\n    ensures\n        s1.subrange(start, end).push(s1[end]) =~= s1.subrange(start, end + 1),\n{\n}\n\nproof fn lemma_subrange_add(s1: Seq<u64>, start: int, mid: int, end: int)\n    requires\n        0 <= start <= mid <= end <= s1.len(),\n    ensures\n        s1.subrange(start, mid) + s1.subrange(mid, end) =~= s1.subrange(start, end),\n{\n}\n\nfn merge(v1: &Vec<u64>, v2: &Vec<u64>) -> (r: Vec<u64>)\n    requires\n        is_sorted(v1),\n        is_sorted(v2),\n    ensures\n        r@.to_multiset() == (v1@ + v2@).to_multiset(),\n        is_sorted(&r),\n{\n    broadcast use lemma_to_multiset_distributes_over_add;\n\n    let mut r: Vec<u64> = Vec::new();\n    let mut i1: usize = 0;\n    let mut i2: usize = 0;\n    assert(v1@.subrange(0 as int, i1 as int) == Seq::<u64>::empty());\n\n    while i1 < v1.len() && i2 < v2.len()\n        invariant\n            0 <= i1 <= v1.len(),\n            0 <= i2 <= v2.len(),\n            is_sorted(v1),\n            is_sorted(v2),\n            forall|i: int| i1 < v1.len() ==> 0 <= i < r.len() ==> r[i] <= v1[i1 as int],\n            forall|i: int| i2 < v2.len() ==> 0 <= i < r.len() ==> r[i] <= v2[i2 as int],\n            r@.to_multiset() =~= (v1@.subrange(0 as int, i1 as int) + v2@.subrange(\n                0 as int,\n                i2 as int,\n            )).to_multiset(),\n            is_sorted(&r),\n        decreases v1.len() + v2.len() - i1 - i2,\n    {\n        proof {\n            r@.to_multiset_ensures();\n        }\n        if v1[i1] < v2[i2] {\n            r.push(v1[i1]);\n            proof {\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n                v1@.subrange(0 as int, i1 as int).to_multiset_ensures();\n                lemma_subrange_push(v1@, 0 as int, i1 as int);\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, (i1 + 1) as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n            }\n            i1 += 1;\n        } else {\n            r.push(v2[i2]);\n            proof {\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n                v2@.subrange(0 as int, i2 as int).to_multiset_ensures();\n                lemma_subrange_push(v2@, 0 as int, i2 as int);\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, (i2 + 1) as int),\n                );\n            }\n            i2 += 1;\n        }\n\n    }\n    assert(v1@.subrange(0 as int, v1.len() as int) =~= v1@);\n    assert(v2@.subrange(0 as int, v2.len() as int) =~= v2@);\n\n    if i1 < v1.len() {\n        extend_from_idx(&mut r, v1, i1);\n        proof {\n            lemma_subrange_add(v1@, 0 as int, i1 as int, v1.len() as int);\n            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());\n        }\n    } else if i2 < v2.len() {\n        extend_from_idx(&mut r, v2, i2);\n        proof {\n            lemma_subrange_add(v2@, 0 as int, i2 as int, v2.len() as int);\n            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());\n        }\n    }\n    r\n}\n\nfn merge_sort(v: &Vec<u64>) -> (r: Vec<u64>)\n    ensures\n        r@.to_multiset() == (*v)@.to_multiset(),\n        is_sorted(&r),\n    decreases v.len(),\n{\n    let n = v.len();\n    let mut v1 = v.clone();\n    if (n <= 1) {\n        v1\n    } else {\n        let mut v2 = v1.split_off(n / 2);\n        assert(v1@ + v2@ == v@);\n        proof {\n            lemma_to_multiset_distributes_over_add(v1@, v2@);\n        }\n        let r1 = merge_sort(&mut v1);\n        let r2 = merge_sort(&mut v2);\n        proof {\n            lemma_to_multiset_distributes_over_add(r1@, r2@);\n        }\n        let r = merge(&r1, &r2);\n        r\n    }\n}\n\nfn main() {\n    let v = vec![9, 10, 4, 5, 1, 3];\n    let v_sorted = merge_sort(&v);\n    let ghost expected_res: Seq<u64> = seq![1, 3, 4, 5, 9, 10];\n    proof {\n        broadcast use group_seq_properties; \n        assert(v@ =~= seq![9].push(10).push(4).push(5).push(1).push(3));\n        assert(expected_res =~= seq![1].push(3).push(4).push(5).push(9).push(10));\n\n        assert(expected_res.to_multiset() =~= v@.to_multiset());\n        vstd::seq_lib::lemma_sorted_unique(expected_res, v_sorted@, |a: u64, b: u64| a <= b);\n        assert(v_sorted@ =~= expected_res);\n    }\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', '    use vstd::prelude::*;\n           verus! {\n         pub open spec fn is_sorted(v: &Vec<u64>) -> bool {\n           forall|i: int, j: int| 0 <= i < j < v.len() ==>           \n#[trigger] v[i] <= #[trigger] v[j]\n}\n         pub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)     ensures                   \n#[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(), {\n           s2.to_multiset_ensures();\n           if s2.len() == 0 {}\n       else {              lemma_to_multiset_distributes_over_add(s1, s2.drop_last());              vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);              assert(s2.drop_last() =~= s2.remove(s2.len() - 1));              assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));              (s1 + s2).drop_last().to_multiset_ensures();          }\n       }\n         fn main() ;\n         }\n', '    use vstd::prelude::*;\n                verus! {\n              spec fn a() -> bool ;\n              proof fn e(f: Seq<u64>, s2: Seq<u64>)     ensures                        \n(f + s2).to_multiset() == f.to_multiset().add(s2.to_multiset())decreases s2{\n                s2.to_multiset_ensures();\n                if s2.len() == 0 {}\n            else {\n                  e(f, s2.drop_last());\n                  Seq::drop_last_distributes_over_add(f, s2);\n                  assert(s2.drop_last() == s2.remove(s2.len() - 1));\n                  assert(f + s2 == (f + s2).drop_last().push(s2[s2.len() - 1 ]));\n                  (f + s2).drop_last().to_multiset_ensures()}\n            }\n              fn main() ;\n              }\n', '    use vstd::prelude::*;\n                      verus! {\n                   fn main() ;\n                   }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/nevd_script.rs,213,213,1.0,215.673,True,0.85,True,,True,,True,True,,1.0,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
fn main() {}

// ## 11 -- 10-program.rs

#[allow(unused_imports)]
use {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};

verus! {

// ## A -- A-program.rs
fn max(a: u64, b: u64) -> (ret: u64)
    ensures
        ret == a || ret == b,
        ret >= a && ret >= b,
{
    //-   if a >= b { b } else { a }
    /*+*/
    if a >= b {
        a
    } else {
        b
    }
}

// ;; Function-Def crate::max
// (push)
//  (declare-const ret~10@ Int)
//  (declare-const a~2@ Int)
//  (declare-const b~4@ Int)
//  (assert fuel_defaults)
//  (assert (uInv 64 a~2@))
//  (assert (uInv 64 b~4@))
//  ;; postcondition not satisfied
//  (declare-const %%location_label%%0 Bool)
//  ;; postcondition not satisfied
//  (declare-const %%location_label%%1 Bool)
//  (declare-const %%query%% Bool)
//  (assert
//   (=>
//    %%query%%
//    (not (=>
//      (= ret~10@ (ite
//        (>= a~2@ b~4@)
//        a~2@
//        b~4@
//      ))
//      (and
//       (=>
//        %%location_label%%0
//        (or
//         (= ret~10@ a~2@)
//         (= ret~10@ b~4@)
//       ))
//       (=>
//        %%location_label%%1
//        (and
//         (>= ret~10@ a~2@)
//         (>= ret~10@ b~4@)
//  )))))))
//  (assert %%query%%)
//  (set-option :rlimit 30000000)
//  (check-sat)
//  (set-option :rlimit 0)
// (pop)
// ## B -- B-fibo.rs
spec fn fibo(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibo((n - 2) as nat) + fibo((n - 1) as nat)
    }
}

proof fn lemma_fibo_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fibo(i) <= fibo(j),
    decreases j - i,
{
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fibo_is_monotonic(i, (j - 1) as nat);
        lemma_fibo_is_monotonic(i, (j - 2) as nat);
    }
}

spec fn fibo_fits_u64(n: nat) -> bool {
    fibo(n) <= 0xffff_ffff_ffff_ffff
}

exec fn fibo_impl(n: u64) -> (result: u64)
    requires
        fibo_fits_u64(n as nat),
    ensures
        result == fibo(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fibo_fits_u64(n as nat),
            fibo_fits_u64(i as nat),
            cur == fibo(i as nat),
            prev == fibo((i - 1) as nat),
    {
        i = i + 1;
        proof {
            lemma_fibo_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}

// ## C -- C-linearity.rs
//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {
//-      let v1 = v;
//-      let v2 = v;
//-      (v1, v2)
//-  }
/*+*/

exec fn f(v: Vec<u64>) {
    /*+*/
    let v1: Ghost<Vec<u64>> = Ghost(v);
    /*+*/
    let v2: Ghost<Vec<u64>> = Ghost(v);
    /*+*/
    assert(v1@.len() == v2@.len());
    /*+*/
}

exec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)
    requires
        old(v1)@.len() == 2,
        old(v2)@.len() == 3,
    ensures
        v1@.len() == v2@.len(),
{
    v1.push(42);
    v1.push(43);
    v2.push(52);
}

// exec fn g_(v1: Vec<u64>, v2: Vec<u64>) -> (out: (Vec<u64>, Vec<u64>))
//     requires
//         v1@.len() == 2,
//         v2@.len() == 3,
//     ensures
//         out.0@.len() == out.1@.len()
// {
//     let v1a = v1.push(42);
//     let v1b = v1.push(43);
//     let v2a.push(52);
//     (v1b, v2a)
// }
// ## E -- E-reverse.rs -- spec variables
/* See vectors.rs
fn reverse(v: &mut Vec<u64>) {
    ensures([
        v.len() == old(v).len(),
        forall(|i: int| 0 <= i && i < old(v).len()
               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),
    ]);

    let length = v.len();
    #[spec] let v1 = *v;
    let mut n: usize = 0;
    while n < length / 2 {
        invariant([
            length == v.len(),
            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),
            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),
            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),
        ]);

        let x = *v.index(n);
        let y = *v.index(length - 1 - n);
        v.set(n, y);
        v.set(length - 1 - n, x);

        n = n + 1;
    }
}
*/

// F -- F-linear-proof
// cell::RefCell::Cell<X>
// G -- G-bitvector.rs
fn mod8_bw(x: u32) -> (ret: u32)
    ensures
        ret == x % 8,
{
    assert(x & 7 == x % 8) by (bit_vector);
    x & 7
}

} // verus!
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
fn main() {}

// ## 11 -- 10-program.rs

#[allow(unused_imports)]
use {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};

verus! {

// ## A -- A-program.rs
fn max(a: u64, b: u64) -> (ret: u64)
    ensures
        ret == a || ret == b,
        ret >= a && ret >= b,
{
    //-   if a >= b { b } else { a }
    /*+*/
    if a >= b {
        a
    } else {
        b
    }
}

// ;; Function-Def crate::max
// (push)
//  (declare-const ret~10@ Int)
//  (declare-const a~2@ Int)
//  (declare-const b~4@ Int)
//  (assert fuel_defaults)
//  (assert (uInv 64 a~2@))
//  (assert (uInv 64 b~4@))
//  ;; postcondition not satisfied
//  (declare-const %%location_label%%0 Bool)
//  ;; postcondition not satisfied
//  (declare-const %%location_label%%1 Bool)
//  (declare-const %%query%% Bool)
//  (assert
//   (=>
//    %%query%%
//    (not (=>
//      (= ret~10@ (ite
//        (>= a~2@ b~4@)
//        a~2@
//        b~4@
//      ))
//      (and
//       (=>
//        %%location_label%%0
//        (or
//         (= ret~10@ a~2@)
//         (= ret~10@ b~4@)
//       ))
//       (=>
//        %%location_label%%1
//        (and
//         (>= ret~10@ a~2@)
//         (>= ret~10@ b~4@)
//  )))))))
//  (assert %%query%%)
//  (set-option :rlimit 30000000)
//  (check-sat)
//  (set-option :rlimit 0)
// (pop)
// ## B -- B-fibo.rs
spec fn fibo(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibo((n - 2) as nat) + fibo((n - 1) as nat)
    }
}

proof fn lemma_fibo_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fibo(i) <= fibo(j),
    decreases j - i,
{
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fibo_is_monotonic(i, (j - 1) as nat);
        lemma_fibo_is_monotonic(i, (j - 2) as nat);
    }
}

spec fn fibo_fits_u64(n: nat) -> bool {
    fibo(n) <= 0xffff_ffff_ffff_ffff
}

exec fn fibo_impl(n: u64) -> (result: u64)
    requires
        fibo_fits_u64(n as nat),
    ensures
        result == fibo(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fibo_fits_u64(n as nat),
            fibo_fits_u64(i as nat),
            cur == fibo(i as nat),
            prev == fibo((i - 1) as nat),
    {
        i = i + 1;
        proof {
            lemma_fibo_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}

// ## C -- C-linearity.rs
//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {
//-      let v1 = v;
//-      let v2 = v;
//-      (v1, v2)
//-  }
/*+*/

exec fn f(v: Vec<u64>) {
    /*+*/
    let v1: Ghost<Vec<u64>> = Ghost(v);
    /*+*/
    let v2: Ghost<Vec<u64>> = Ghost(v);
    /*+*/
    assert(v1@.len() == v2@.len());
    /*+*/
}

exec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)
    requires
        old(v1)@.len() == 2,
        old(v2)@.len() == 3,
    ensures
        v1@.len() == v2@.len(),
{
    v1.push(42);
    v1.push(43);
    v2.push(52);
}

// exec fn g_(v1: Vec<u64>, v2: Vec<u64>) -> (out: (Vec<u64>, Vec<u64>))
//     requires
//         v1@.len() == 2,
//         v2@.len() == 3,
//     ensures
//         out.0@.len() == out.1@.len()
// {
//     let v1a = v1.push(42);
//     let v1b = v1.push(43);
//     let v2a.push(52);
//     (v1b, v2a)
// }
// ## E -- E-reverse.rs -- spec variables
/* See vectors.rs
fn reverse(v: &mut Vec<u64>) {
    ensures([
        v.len() == old(v).len(),
        forall(|i: int| 0 <= i && i < old(v).len()
               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),
    ]);

    let length = v.len();
    #[spec] let v1 = *v;
    let mut n: usize = 0;
    while n < length / 2 {
        invariant([
            length == v.len(),
            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),
            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),
            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),
        ]);

        let x = *v.index(n);
        let y = *v.index(length - 1 - n);
        v.set(n, y);
        v.set(length - 1 - n, x);

        n = n + 1;
    }
}
*/

// F -- F-linear-proof
// cell::RefCell::Cell<X>
// G -- G-bitvector.rs
fn mod8_bw(x: u32) -> (ret: u32)
    ensures
        ret == x % 8,
{
    assert(x & 7 == x % 8) by (bit_vector);
    x & 7
}

} // verus!
","['#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ;; Function-Def crate::max\n// (push)\n//  (declare-const ret~10@ Int)\n//  (declare-const a~2@ Int)\n//  (declare-const b~4@ Int)\n//  (assert fuel_defaults)\n//  (assert (uInv 64 a~2@))\n//  (assert (uInv 64 b~4@))\n//  ;; postcondition not satisfied\n//  (declare-const %%location_label%%0 Bool)\n//  ;; postcondition not satisfied\n//  (declare-const %%location_label%%1 Bool)\n//  (declare-const %%query%% Bool)\n//  (assert\n//   (=>\n//    %%query%%\n//    (not (=>\n//      (= ret~10@ (ite\n//        (>= a~2@ b~4@)\n//        a~2@\n//        b~4@\n//      ))\n//      (and\n//       (=>\n//        %%location_label%%0\n//        (or\n//         (= ret~10@ a~2@)\n//         (= ret~10@ b~4@)\n//       ))\n//       (=>\n//        %%location_label%%1\n//        (and\n//         (>= ret~10@ a~2@)\n//         (>= ret~10@ b~4@)\n//  )))))))\n//  (assert %%query%%)\n//  (set-option :rlimit 30000000)\n//  (check-sat)\n//  (set-option :rlimit 0)\n// (pop)\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// exec fn g_(v1: Vec<u64>, v2: Vec<u64>) -> (out: (Vec<u64>, Vec<u64>))\n//     requires\n//         v1@.len() == 2,\n//         v2@.len() == 3,\n//     ensures\n//         out.0@.len() == out.1@.len()\n// {\n//     let v1a = v1.push(42);\n//     let v1b = v1.push(43);\n//     let v2a.push(52);\n//     (v1b, v2a)\n// }\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n', 'fn main() {}\nuse{vstd};\n', 'fn main() {}\nuse{verus_builtin, verus_builtin_macros, prelude::*, seq::*, vstd::*};\n', 'fn main() {}\nuse{vstd::*};\n', 'fn main() {}\nuse{vstd};\n']"
/Users/ameliakuang/Repos/dep_verus/examples/overflow.rs,69,69,1.0,123.082,True,0.7999999999999999,True,"['vstd::prelude::', 'vstd::arithmetic::overflow::']",True,,,,,,"// examples of using `CheckedU32` and `CheckedU64`
use vstd::prelude::*;
use vstd::arithmetic::overflow::*;

verus! {

fn checked_u64_constants()
{
    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);
    let x = w.add_value(1);
    assert(x.is_overflowed());
    assert(x.view() == 0x10000000000000000);

    let y = CheckedU64::new(0x8000000000000000);
    let z = y.mul_value(2);
    assert(z.is_overflowed());
    assert(z.view() == 0x10000000000000000);
}

fn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)
    ensures
        match result {
            Some(v) => v == a * b + c * d,
            None => a * b + c * d > u64::MAX,
        }
{
    let a_times_b = CheckedU64::new(a).mul_value(b);
    let c_times_d = CheckedU64::new(c).mul_value(d);
    let sum_of_products = a_times_b.add_checked(&c_times_d);
    if sum_of_products.is_overflowed() {
        assert(a * b + c * d > u64::MAX);
        None
    }
    else {
        let i: u64 = sum_of_products.unwrap();
        assert(i == a * b + c * d);
        Some(i)
    }
}

fn checked_u32_constants()
{
    let w = CheckedU32::new(0xFFFFFFFF);
    let x = w.add_value(9);
    assert(x.is_overflowed());
    assert(x.view() == 0x100000008);

    let y = CheckedU32::new(0x40000000);
    let z = y.mul_value(8);
    assert(z.is_overflowed());
    assert(z.view() == 0x200000000);
}

fn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)
    ensures
        match result {
            Some(v) => v == a * b + c * d + e,
            None => a * b + c * d + e > u32::MAX,
        }
{
    let a_times_b = CheckedU32::new(a).mul_value(b);
    let c_times_d = CheckedU32::new(c).mul_value(d);
    let sum_of_products = a_times_b.add_checked(&c_times_d);
    let f = sum_of_products.add_value(e);
    f.to_option()
}

} // verus!
fn main() {}
","// examples of using `CheckedU32` and `CheckedU64`
use vstd::prelude::*;
use vstd::arithmetic::overflow::*;

verus! {

fn checked_u64_constants()
{
    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);
    let x = w.add_value(1);
    assert(x.is_overflowed());
    assert(x.view() == 0x10000000000000000);

    let y = CheckedU64::new(0x8000000000000000);
    let z = y.mul_value(2);
    assert(z.is_overflowed());
    assert(z.view() == 0x10000000000000000);
}

fn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)
    ensures
        match result {
            Some(v) => v == a * b + c * d,
            None => a * b + c * d > u64::MAX,
        }
{
    let a_times_b = CheckedU64::new(a).mul_value(b);
    let c_times_d = CheckedU64::new(c).mul_value(d);
    let sum_of_products = a_times_b.add_checked(&c_times_d);
    if sum_of_products.is_overflowed() {
        assert(a * b + c * d > u64::MAX);
        None
    }
    else {
        let i: u64 = sum_of_products.unwrap();
        assert(i == a * b + c * d);
        Some(i)
    }
}

fn checked_u32_constants()
{
    let w = CheckedU32::new(0xFFFFFFFF);
    let x = w.add_value(9);
    assert(x.is_overflowed());
    assert(x.view() == 0x100000008);

    let y = CheckedU32::new(0x40000000);
    let z = y.mul_value(8);
    assert(z.is_overflowed());
    assert(z.view() == 0x200000000);
}

fn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)
    ensures
        match result {
            Some(v) => v == a * b + c * d + e,
            None => a * b + c * d + e > u32::MAX,
        }
{
    let a_times_b = CheckedU32::new(a).mul_value(b);
    let c_times_d = CheckedU32::new(c).mul_value(d);
    let sum_of_products = a_times_b.add_checked(&c_times_d);
    let f = sum_of_products.add_value(e);
    f.to_option()
}

} // verus!
fn main() {}
","['// examples of using `CheckedU32` and `CheckedU64`\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\nfn checked_u64_constants()\n{\n    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);\n    let x = w.add_value(1);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x10000000000000000);\n\n    let y = CheckedU64::new(0x8000000000000000);\n    let z = y.mul_value(2);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x10000000000000000);\n}\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d,\n            None => a * b + c * d > u64::MAX,\n        }\n{\n    let a_times_b = CheckedU64::new(a).mul_value(b);\n    let c_times_d = CheckedU64::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    if sum_of_products.is_overflowed() {\n        assert(a * b + c * d > u64::MAX);\n        None\n    }\n    else {\n        let i: u64 = sum_of_products.unwrap();\n        assert(i == a * b + c * d);\n        Some(i)\n    }\n}\n\nfn checked_u32_constants()\n{\n    let w = CheckedU32::new(0xFFFFFFFF);\n    let x = w.add_value(9);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x100000008);\n\n    let y = CheckedU32::new(0x40000000);\n    let z = y.mul_value(8);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x200000000);\n}\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d + e,\n            None => a * b + c * d + e > u32::MAX,\n        }\n{\n    let a_times_b = CheckedU32::new(a).mul_value(b);\n    let c_times_d = CheckedU32::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    let f = sum_of_products.add_value(e);\n    f.to_option()\n}\n\n} // verus!\nfn main() {}\n', 'use vstd;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/pcm/agreement.rs,168,168,1.0,275.657,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'std::result::', 'vstd::pcm::', 'vstd::pcm_lib::', 'vstd::prelude::']",True,,,True,,,"//! This file implements agreement on a constant value using a custom
//! resource algebra.
//!
//! An agreement resource constitutes knowledge of a constant value.
//! To create an instance of a constant value of type `T`, use
//! `AgreementResource::<T>::alloc()` as in the following example:
//!
//! ```
//! let tracked r1 = AgreementResource::<int>::alloc(72);
//! assert(r1@ == 72);
//! ```
//!
//! Knowledge of a constant value can be duplicated with `duplicate`,
//! which creates another agreement resource with the same constant
//! value and the same ID. Here's an example:
//!
//! ```
//! let tracked r2 = r1.duplicate();
//! assert(r2.id() == r1.id());
//! assert(r2@ == r1@);
//! ```
//!
//! Any two agreement resources with the same `id()` are guaranteed to
//! have equal values. You can establish this by calling
//! `lemma_agreement`, as in the following example:
//!
//! ```
//! assert(r2.id() == r1.id());
//! proof { r1.lemma_agreement(&mut r2); }
//! assert(r2@ == r1@);
//! ```
#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use std::result::*;
use vstd::pcm::*;
use vstd::pcm_lib::*;
use vstd::prelude::*;

verus! {

pub enum AgreementResourceValue<T> {
    Empty,
    Chosen { c: T },
    Invalid,
}

impl<T> AgreementResourceValue<T> {
    pub open spec fn new(c: T) -> Self {
        AgreementResourceValue::<T>::Chosen { c }
    }
}

impl<T> PCM for AgreementResourceValue<T> {
    open spec fn valid(self) -> bool {
        !(self is Invalid)
    }

    open spec fn op(self, other: Self) -> Self {
        match (self, other) {
            (AgreementResourceValue::<T>::Empty, _) => other,
            (_, AgreementResourceValue::<T>::Empty) => self,
            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },
            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },
            (
                AgreementResourceValue::<T>::Chosen { c: c1 },
                AgreementResourceValue::<T>::Chosen { c: c2 },
            ) => if c1 == c2 {
                self
            } else {
                AgreementResourceValue::<T>::Invalid {  }
            },
        }
    }

    open spec fn unit() -> Self {
        AgreementResourceValue::<T>::Empty {  }
    }

    proof fn closed_under_incl(a: Self, b: Self) {
    }

    proof fn commutative(a: Self, b: Self) {
    }

    proof fn associative(a: Self, b: Self, c: Self) {
    }

    proof fn op_unit(a: Self) {
    }

    proof fn unit_valid() {
    }
}

pub struct AgreementResource<T> {
    r: Resource<AgreementResourceValue<T>>,
}

impl<T> AgreementResource<T> {
    pub closed spec fn inv(self) -> bool {
        self.r.value() is Chosen
    }

    pub closed spec fn id(self) -> Loc {
        self.r.loc()
    }

    pub closed spec fn view(self) -> T
        recommends
            self.inv(),
    {
        self.r.value()->c
    }

    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)
        ensures
            result.inv(),
            result@ == c,
    {
        let r_value = AgreementResourceValue::<T>::new(c);
        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);
        AgreementResource::<T> { r }
    }

    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:
        AgreementResource<T>)
        requires
            old(self).inv(),
        ensures
            self.inv(),
            result.inv(),
            self.id() == result.id() == old(self).id(),
            self@ == result@,
            self@ == old(self)@,
    {
        let tracked r = duplicate(&self.r);
        AgreementResource::<T> { r }
    }

    pub proof fn lemma_agreement(
        tracked self: &mut AgreementResource<T>,
        tracked other: &AgreementResource<T>,
    )
        requires
            old(self).inv(),
            other.inv(),
            old(self).id() == other.id(),
        ensures
            self.id() == old(self).id(),
            self@ == old(self)@,
            self@ == other@,
    {
        self.r.validate_2(&other.r);
    }
}

pub fn main() {
    let tracked r1 = AgreementResource::<int>::alloc(72);
    assert(r1@ == 72);
    let tracked r2 = r1.duplicate();
    assert(r2@ == r1@);
    proof {
        r1.lemma_agreement(&mut r2);
    }
}

} // verus!
","//! This file implements agreement on a constant value using a custom
//! resource algebra.
//!
//! An agreement resource constitutes knowledge of a constant value.
//! To create an instance of a constant value of type `T`, use
//! `AgreementResource::<T>::alloc()` as in the following example:
//!
//! ```
//! let tracked r1 = AgreementResource::<int>::alloc(72);
//! assert(r1@ == 72);
//! ```
//!
//! Knowledge of a constant value can be duplicated with `duplicate`,
//! which creates another agreement resource with the same constant
//! value and the same ID. Here's an example:
//!
//! ```
//! let tracked r2 = r1.duplicate();
//! assert(r2.id() == r1.id());
//! assert(r2@ == r1@);
//! ```
//!
//! Any two agreement resources with the same `id()` are guaranteed to
//! have equal values. You can establish this by calling
//! `lemma_agreement`, as in the following example:
//!
//! ```
//! assert(r2.id() == r1.id());
//! proof { r1.lemma_agreement(&mut r2); }
//! assert(r2@ == r1@);
//! ```
#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use std::result::*;
use vstd::pcm::*;
use vstd::pcm_lib::*;
use vstd::prelude::*;

verus! {

pub enum AgreementResourceValue<T> {
    Empty,
    Chosen { c: T },
    Invalid,
}

impl<T> AgreementResourceValue<T> {
    pub open spec fn new(c: T) -> Self {
        AgreementResourceValue::<T>::Chosen { c }
    }
}

impl<T> PCM for AgreementResourceValue<T> {
    open spec fn valid(self) -> bool {
        !(self is Invalid)
    }

    open spec fn op(self, other: Self) -> Self {
        match (self, other) {
            (AgreementResourceValue::<T>::Empty, _) => other,
            (_, AgreementResourceValue::<T>::Empty) => self,
            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },
            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },
            (
                AgreementResourceValue::<T>::Chosen { c: c1 },
                AgreementResourceValue::<T>::Chosen { c: c2 },
            ) => if c1 == c2 {
                self
            } else {
                AgreementResourceValue::<T>::Invalid {  }
            },
        }
    }

    open spec fn unit() -> Self {
        AgreementResourceValue::<T>::Empty {  }
    }

    proof fn closed_under_incl(a: Self, b: Self) {
    }

    proof fn commutative(a: Self, b: Self) {
    }

    proof fn associative(a: Self, b: Self, c: Self) {
    }

    proof fn op_unit(a: Self) {
    }

    proof fn unit_valid() {
    }
}

pub struct AgreementResource<T> {
    r: Resource<AgreementResourceValue<T>>,
}

impl<T> AgreementResource<T> {
    pub closed spec fn inv(self) -> bool {
        self.r.value() is Chosen
    }

    pub closed spec fn id(self) -> Loc {
        self.r.loc()
    }

    pub closed spec fn view(self) -> T
        recommends
            self.inv(),
    {
        self.r.value()->c
    }

    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)
        ensures
            result.inv(),
            result@ == c,
    {
        let r_value = AgreementResourceValue::<T>::new(c);
        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);
        AgreementResource::<T> { r }
    }

    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:
        AgreementResource<T>)
        requires
            old(self).inv(),
        ensures
            self.inv(),
            result.inv(),
            self.id() == result.id() == old(self).id(),
            self@ == result@,
            self@ == old(self)@,
    {
        let tracked r = duplicate(&self.r);
        AgreementResource::<T> { r }
    }

    pub proof fn lemma_agreement(
        tracked self: &mut AgreementResource<T>,
        tracked other: &AgreementResource<T>,
    )
        requires
            old(self).inv(),
            other.inv(),
            old(self).id() == other.id(),
        ensures
            self.id() == old(self).id(),
            self@ == old(self)@,
            self@ == other@,
    {
        self.r.validate_2(&other.r);
    }
}

pub fn main() {
    let tracked r1 = AgreementResource::<int>::alloc(72);
    assert(r1@ == 72);
    let tracked r2 = r1.duplicate();
    assert(r2@ == r1@);
    proof {
        r1.lemma_agreement(&mut r2);
    }
}

} // verus!
","[""//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//! assert(r1@ == 72);\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//! assert(r2.id() == r1.id());\n//! assert(r2@ == r1@);\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//! assert(r2.id() == r1.id());\n//! proof { r1.lemma_agreement(&mut r2); }\n//! assert(r2@ == r1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n    assert(r1@ == 72);\n    let tracked r2 = r1.duplicate();\n    assert(r2@ == r1@);\n    proof {\n        r1.lemma_agreement(&mut r2);\n    }\n}\n\n} // verus!\n"", 'use vstd::prelude::*;\nverus !{ fn main(); }\n', '          use vstd::prelude::*;\n            verus! {\n          pub fn main() ;\n          }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/pcm/count_to_two.rs,329,329,1.0,,,0.85,False,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::prelude::', 'crate::oneshot::', 'std::sync::Arc', 'vstd::atomic::', 'vstd::atomic_ghost::', 'vstd::invariant::']",False,other,,True,,,"#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::prelude::*;

pub mod oneshot;

use crate::oneshot::*;
use std::sync::Arc;
use vstd::atomic::*;
use vstd::atomic_ghost::*;
use vstd::invariant::*;

verus! {

// This struct holds all the ghost tracked state that the counter
// will keep in an invariant.
//
// `x_perm` -- permission to write to the shared atomic variable `x`
//
// `oneshot0_inv_half` -- the invariant's resource for thread 0's
// one-shot, which contains either half the authority to complete that
// one-shot or knowledge that that one-shot has been performed
//
// `oneshot1_inv_half` -- as above, but for thread 1's one-shot
pub struct CounterTrackedState {
    pub x_perm: PermissionU32,
    pub oneshot0_inv_half: OneShotResource,
    pub oneshot1_inv_half: OneShotResource,
}

// This struct describes what's constant in the counter invariant.
//
// `x_id` -- the identity of the shared atomic variable `x`, which
// links the permission to write it with the actual atomic
// variable.
//
// `oneshot0_id` -- the ID of thread 0's one-shot
//
// `oneshot1_id` -- the ID of thread 1's one-shot
pub struct CounterInvariantConstants {
    pub x_id: int,
    pub oneshot0_id: int,
    pub oneshot1_id: int,
}

// This is the invariant predicate that will be maintained for the
// `CounterTrackedState`.
pub struct CounterInvariantPredicate {}

impl InvariantPredicate<
    CounterInvariantConstants,
    CounterTrackedState,
> for CounterInvariantPredicate {
    open spec fn inv(c: CounterInvariantConstants, cts: CounterTrackedState) -> bool {
        // The IDs of the resources held match those in the constants
        &&& cts.x_perm@.patomic == c.x_id
        &&& cts.oneshot0_inv_half.id() == c.oneshot0_id
        &&& cts.oneshot1_inv_half.id()
            == c.oneshot1_id
        // For each thread's one-shot, the invariant holds a resource that's either
        // (1) half authority to complete that one-shot or (2) knowledge that that
        // one-shot is complete.

        &&& cts.oneshot0_inv_half@ is HalfRightToComplete || cts.oneshot0_inv_half@ is Complete
        &&& cts.oneshot1_inv_half@ is HalfRightToComplete
            || cts.oneshot1_inv_half@ is Complete
        // The key invariant is that the value of `x` is the count
        // of how many threads' one-shots have completed.

        &&& cts.x_perm@.value == (if cts.oneshot0_inv_half@ is Complete {
            1int
        } else {
            0int
        }) + (if cts.oneshot1_inv_half@ is Complete {
            1int
        } else {
            0int
        })
    }
}

// This `CounterSharedState` struct is shared among the threads, using
// an atomic reference counter (Arc).
//
// `x` -- the actual counter implemented as an atomic u32
// `inv` -- the invariant holding the shared counter tracked state
pub struct CounterSharedState {
    pub x: PAtomicU32,
    pub inv: Tracked<
        AtomicInvariant<CounterInvariantConstants, CounterTrackedState, CounterInvariantPredicate>,
    >,
}

impl CounterSharedState {
    // This is the well-formedness predicate for a `CounterSharedState`.
    pub open spec fn wf(self) -> bool {
        &&& self.x.id() == self.inv@.constant().x_id
        &&& self.inv@.namespace() == 888
    }

    // This function gets, from the shared state's constants, the ID
    // of the one-shot associated with the given thread.
    pub open spec fn get_oneshot_id(self, which_thread: int) -> int
        recommends
            which_thread == 0 || which_thread == 1,
    {
        let c = self.inv@.constant();
        if which_thread == 0 {
            c.oneshot0_id
        } else {
            c.oneshot1_id
        }
    }

    // This function creates a new `CounterSharedState`.
    pub fn new(
        Tracked(oneshot0_inv_half): Tracked<OneShotResource>,
        Tracked(oneshot1_inv_half): Tracked<OneShotResource>,
    ) -> (result: Arc<Self>)
        requires
            oneshot0_inv_half@ is HalfRightToComplete,
            oneshot1_inv_half@ is HalfRightToComplete,
        ensures
            result.wf(),
            result.get_oneshot_id(0) == oneshot0_inv_half.id(),
            result.get_oneshot_id(1) == oneshot1_inv_half.id(),
    {
        // Create the atomic variable to be shared among threads.
        let (x, Tracked(x_perm)): (PAtomicU32, Tracked<PermissionU32>) = PAtomicU32::new(0);
        // Create the `CounterTrackedState`.
        let tracked cts = CounterTrackedState { x_perm, oneshot0_inv_half, oneshot1_inv_half };
        // Create the invariant.
        let ghost c = CounterInvariantConstants {
            x_id: x.id(),
            oneshot0_id: oneshot0_inv_half.id(),
            oneshot1_id: oneshot1_inv_half.id(),
        };
        assert(CounterInvariantPredicate::inv(c, cts));  // This is obvious, so no proof is needed.
        let inv = Tracked(AtomicInvariant::new(c, cts, 888));
        // Create the shared state to be shared among the threads
        // using Arcs.
        Arc::new(CounterSharedState { x, inv })
    }

    // This function reads the value of `x` from the `PAtomicU32`
    // that's part of this `CounterSharedState`. It requires, as
    // input, two `OneShotResource`s, one showing that thread 0's
    // one-shot is complete and the other showing that thread 1's
    // one-shot is complete. Because of these, it can ensure that the
    // value it reads is 2.
    pub fn read_x(
        self: &Arc<Self>,
        Tracked(oneshot0_complete): Tracked<OneShotResource>,
        Tracked(oneshot1_complete): Tracked<OneShotResource>,
    ) -> (x: u32)
        requires
            self.wf(),
            oneshot0_complete.id() == self.get_oneshot_id(0),
            oneshot1_complete.id() == self.get_oneshot_id(1),
            oneshot0_complete@ is Complete,
            oneshot1_complete@ is Complete,
        ensures
            x == 2,
    {
        let x_value: u32;
        open_atomic_invariant!(self.inv.borrow() => inner => {
            proof {
                // Since `oneshot0_complete` reflects thread 0's
                // one-shot having completed, we can conclude that the
                // invariant's `oneshot0_inv_half` is also
                // `Completed`. After all, it's not possible for a
                // `HalfRightToComplete` and `Completed` resource to
                // co-exist for the same one-shot ID. We use
                // `lemma_is_complete_if_other_is` to show this.

                inner.oneshot0_inv_half.lemma_is_complete_if_other_is(&oneshot0_complete);

                // Similarly for `oneshot1_complete` and thread 1's
                // one-shot.

                inner.oneshot1_inv_half.lemma_is_complete_if_other_is(&oneshot1_complete);

                // The invariant says that the value of `x` is equal to
                //
                // ```
                // (if cts.oneshot0_inv_half@ is Complete { 1int } else { 0int }) +
                // (if cts.oneshot1_inv_half@ is Complete { 1int } else { 0int })
                // ```
                //
                // Since we know both have completed, we know `x == 2`. So,
                // when we load its value, that's what we'll get.
            }
            x_value = self.x.load(Tracked(&inner.x_perm));
            assert(x_value == 2); // This is the key assertion we needed to prove.
        });
        x_value
    }
}

// This is the routine that each thread will execute when forked. It
// increments the counter atomically with performing the one-shot.
//
// `shared_state` -- an Arc pointing to the state shared between
// threads
//
// `oneshot_thread_half` -- permission granting half of the
// authority to this thread's one-shot resource
//
// `which_thread` -- which thread this is, 0 or 1
pub fn thread_routine(
    shared_state: Arc<CounterSharedState>,
    Tracked(oneshot_thread_half): Tracked<OneShotResource>,
    Ghost(which_thread): Ghost<int>,
) -> (return_permission: Tracked<OneShotResource>)
    requires
        which_thread == 0 || which_thread == 1,
        oneshot_thread_half@ is HalfRightToComplete,
        shared_state.wf(),
        oneshot_thread_half.id() == shared_state.get_oneshot_id(which_thread),
    ensures
        return_permission@.id() == shared_state.get_oneshot_id(which_thread),
        return_permission@@ is Complete,
{
    let tracked mut oneshot_thread_half = oneshot_thread_half;
    open_atomic_invariant!(shared_state.inv.borrow() => inner => {
        // Increment the shared `x` by 1.
        shared_state.x.fetch_add_wrapping(Tracked(&mut inner.x_perm), 1);
        proof {
            // Atomically with that increment, perform the one-shot.
            // This requires providing two half authorities. One was
            // passed to this function as `oneshot_thread_half` and
            // the other is in this invariant.
            //
            // Technically, the invariant just tells us that either
            // the one-shot is complete *or* we have half authority to
            // it. Fortunately, `perform_using_two_halves` only
            // requires that one of the resources be known to be a
            // half authority. (It can deduce that the other one must
            // be, since a `HalfRightToComplete` resource can't
            // co-exist with a `Completed` resource of the same ID.)
            if which_thread == 0 {
                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot0_inv_half);
            }
            else {
                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot1_inv_half);
            }
            assert(oneshot_thread_half@ is Complete);
        }
    });
    // Return the updated permission. It's been updated from (a)
    // half the authority to complete the one-shot to (b)
    // knowledge that the one-shot is complete.
    Tracked(oneshot_thread_half)
}

// This function counts to two by forking two threads, each tasked
// with incrementing `x` and then returning knowledge that that
// thread has performed its increment. In this way, it's able to
// guarantee that when it reads `x` after joining those two
// threads, the result is 2.
pub fn count_to_two() -> (result: Result<u32, ()>)
    ensures
        result is Ok ==> result.unwrap() == 2,
{
    // Create two one-shots, one for each thread we're going to
    // fork. Calling `create_oneshot` provides two permissions to
    // the one-shot resource, each granting half authority to
    // perform the one-shot. We'll stash one half in our invariant
    // and pass the other half to the appropriate thread. It's
    // necessary to have both halves to perform any one-shot, so
    // each thread will have to combine its half with the
    // corresponding one in the invariant.
    let tracked (mut oneshot0_inv_half, mut oneshot0_thread_half) =
        OneShotResource::alloc().split();
    let tracked (mut oneshot1_inv_half, mut oneshot1_thread_half) =
        OneShotResource::alloc().split();
    // Create the shared state that includes a new `PAtomicU32` and
    // an invariant that starts out holding `oneshot0_inv_half` and
    // `oneshot1_inv_half1.
    let shared_state = CounterSharedState::new(
        Tracked(oneshot0_inv_half),
        Tracked(oneshot1_inv_half),
    );
    // For each thread, clone the shared-state Arc and use this to
    // fork the thread. Also pass each thread a tracked permission
    // providing half the authority to update its one-shot.
    let shared_state_clone = shared_state.clone();
    let join_handle0 = vstd::thread::spawn(
        move || -> (return_value: Tracked<OneShotResource>)
            ensures
                return_value@.id() == shared_state.get_oneshot_id(0),
                return_value@@ is Complete,
            {
                thread_routine(shared_state_clone, Tracked(oneshot0_thread_half), Ghost(0))
            }
    );
    let shared_state_clone = shared_state.clone();
    let join_handle1 = vstd::thread::spawn(
        move || -> (return_value: Tracked<OneShotResource>)
            ensures
                return_value@.id() == shared_state.get_oneshot_id(1),
                return_value@@ is Complete,
            {
                thread_routine(shared_state_clone, Tracked(oneshot1_thread_half), Ghost(1))
            }
    );
    // Let the threads run in parallel, then join them both when
    // they're done.
    if let (Ok(oneshot0_complete), Ok(oneshot1_complete)) = (
        join_handle0.join(),
        join_handle1.join(),
    ) {
        // If both joins succeeded, we can now read the shared
        // `PAtomicU32`'s value `x` by opening the invariant.
        Ok(shared_state.read_x(oneshot0_complete, oneshot1_complete))
    } else {
        // If either of the joins failed, we can't proceed.
        Err(())
    }
}

pub fn main() {
    if let Ok(x) = count_to_two() {
        assert(x == 2);
    }
}

} // verus!
","#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::prelude::*;

pub mod oneshot;

use crate::oneshot::*;
use std::sync::Arc;
use vstd::atomic::*;
use vstd::atomic_ghost::*;
use vstd::invariant::*;

verus! {

// This struct holds all the ghost tracked state that the counter
// will keep in an invariant.
//
// `x_perm` -- permission to write to the shared atomic variable `x`
//
// `oneshot0_inv_half` -- the invariant's resource for thread 0's
// one-shot, which contains either half the authority to complete that
// one-shot or knowledge that that one-shot has been performed
//
// `oneshot1_inv_half` -- as above, but for thread 1's one-shot
pub struct CounterTrackedState {
    pub x_perm: PermissionU32,
    pub oneshot0_inv_half: OneShotResource,
    pub oneshot1_inv_half: OneShotResource,
}

// This struct describes what's constant in the counter invariant.
//
// `x_id` -- the identity of the shared atomic variable `x`, which
// links the permission to write it with the actual atomic
// variable.
//
// `oneshot0_id` -- the ID of thread 0's one-shot
//
// `oneshot1_id` -- the ID of thread 1's one-shot
pub struct CounterInvariantConstants {
    pub x_id: int,
    pub oneshot0_id: int,
    pub oneshot1_id: int,
}

// This is the invariant predicate that will be maintained for the
// `CounterTrackedState`.
pub struct CounterInvariantPredicate {}

impl InvariantPredicate<
    CounterInvariantConstants,
    CounterTrackedState,
> for CounterInvariantPredicate {
    open spec fn inv(c: CounterInvariantConstants, cts: CounterTrackedState) -> bool {
        // The IDs of the resources held match those in the constants
        &&& cts.x_perm@.patomic == c.x_id
        &&& cts.oneshot0_inv_half.id() == c.oneshot0_id
        &&& cts.oneshot1_inv_half.id()
            == c.oneshot1_id
        // For each thread's one-shot, the invariant holds a resource that's either
        // (1) half authority to complete that one-shot or (2) knowledge that that
        // one-shot is complete.

        &&& cts.oneshot0_inv_half@ is HalfRightToComplete || cts.oneshot0_inv_half@ is Complete
        &&& cts.oneshot1_inv_half@ is HalfRightToComplete
            || cts.oneshot1_inv_half@ is Complete
        // The key invariant is that the value of `x` is the count
        // of how many threads' one-shots have completed.

        &&& cts.x_perm@.value == (if cts.oneshot0_inv_half@ is Complete {
            1int
        } else {
            0int
        }) + (if cts.oneshot1_inv_half@ is Complete {
            1int
        } else {
            0int
        })
    }
}

// This `CounterSharedState` struct is shared among the threads, using
// an atomic reference counter (Arc).
//
// `x` -- the actual counter implemented as an atomic u32
// `inv` -- the invariant holding the shared counter tracked state
pub struct CounterSharedState {
    pub x: PAtomicU32,
    pub inv: Tracked<
        AtomicInvariant<CounterInvariantConstants, CounterTrackedState, CounterInvariantPredicate>,
    >,
}

impl CounterSharedState {
    // This is the well-formedness predicate for a `CounterSharedState`.
    pub open spec fn wf(self) -> bool {
        &&& self.x.id() == self.inv@.constant().x_id
        &&& self.inv@.namespace() == 888
    }

    // This function gets, from the shared state's constants, the ID
    // of the one-shot associated with the given thread.
    pub open spec fn get_oneshot_id(self, which_thread: int) -> int
        recommends
            which_thread == 0 || which_thread == 1,
    {
        let c = self.inv@.constant();
        if which_thread == 0 {
            c.oneshot0_id
        } else {
            c.oneshot1_id
        }
    }

    // This function creates a new `CounterSharedState`.
    pub fn new(
        Tracked(oneshot0_inv_half): Tracked<OneShotResource>,
        Tracked(oneshot1_inv_half): Tracked<OneShotResource>,
    ) -> (result: Arc<Self>)
        requires
            oneshot0_inv_half@ is HalfRightToComplete,
            oneshot1_inv_half@ is HalfRightToComplete,
        ensures
            result.wf(),
            result.get_oneshot_id(0) == oneshot0_inv_half.id(),
            result.get_oneshot_id(1) == oneshot1_inv_half.id(),
    {
        // Create the atomic variable to be shared among threads.
        let (x, Tracked(x_perm)): (PAtomicU32, Tracked<PermissionU32>) = PAtomicU32::new(0);
        // Create the `CounterTrackedState`.
        let tracked cts = CounterTrackedState { x_perm, oneshot0_inv_half, oneshot1_inv_half };
        // Create the invariant.
        let ghost c = CounterInvariantConstants {
            x_id: x.id(),
            oneshot0_id: oneshot0_inv_half.id(),
            oneshot1_id: oneshot1_inv_half.id(),
        };
        assert(CounterInvariantPredicate::inv(c, cts));  // This is obvious, so no proof is needed.
        let inv = Tracked(AtomicInvariant::new(c, cts, 888));
        // Create the shared state to be shared among the threads
        // using Arcs.
        Arc::new(CounterSharedState { x, inv })
    }

    // This function reads the value of `x` from the `PAtomicU32`
    // that's part of this `CounterSharedState`. It requires, as
    // input, two `OneShotResource`s, one showing that thread 0's
    // one-shot is complete and the other showing that thread 1's
    // one-shot is complete. Because of these, it can ensure that the
    // value it reads is 2.
    pub fn read_x(
        self: &Arc<Self>,
        Tracked(oneshot0_complete): Tracked<OneShotResource>,
        Tracked(oneshot1_complete): Tracked<OneShotResource>,
    ) -> (x: u32)
        requires
            self.wf(),
            oneshot0_complete.id() == self.get_oneshot_id(0),
            oneshot1_complete.id() == self.get_oneshot_id(1),
            oneshot0_complete@ is Complete,
            oneshot1_complete@ is Complete,
        ensures
            x == 2,
    {
        let x_value: u32;
        open_atomic_invariant!(self.inv.borrow() => inner => {
            proof {
                // Since `oneshot0_complete` reflects thread 0's
                // one-shot having completed, we can conclude that the
                // invariant's `oneshot0_inv_half` is also
                // `Completed`. After all, it's not possible for a
                // `HalfRightToComplete` and `Completed` resource to
                // co-exist for the same one-shot ID. We use
                // `lemma_is_complete_if_other_is` to show this.

                inner.oneshot0_inv_half.lemma_is_complete_if_other_is(&oneshot0_complete);

                // Similarly for `oneshot1_complete` and thread 1's
                // one-shot.

                inner.oneshot1_inv_half.lemma_is_complete_if_other_is(&oneshot1_complete);

                // The invariant says that the value of `x` is equal to
                //
                // ```
                // (if cts.oneshot0_inv_half@ is Complete { 1int } else { 0int }) +
                // (if cts.oneshot1_inv_half@ is Complete { 1int } else { 0int })
                // ```
                //
                // Since we know both have completed, we know `x == 2`. So,
                // when we load its value, that's what we'll get.
            }
            x_value = self.x.load(Tracked(&inner.x_perm));
            assert(x_value == 2); // This is the key assertion we needed to prove.
        });
        x_value
    }
}

// This is the routine that each thread will execute when forked. It
// increments the counter atomically with performing the one-shot.
//
// `shared_state` -- an Arc pointing to the state shared between
// threads
//
// `oneshot_thread_half` -- permission granting half of the
// authority to this thread's one-shot resource
//
// `which_thread` -- which thread this is, 0 or 1
pub fn thread_routine(
    shared_state: Arc<CounterSharedState>,
    Tracked(oneshot_thread_half): Tracked<OneShotResource>,
    Ghost(which_thread): Ghost<int>,
) -> (return_permission: Tracked<OneShotResource>)
    requires
        which_thread == 0 || which_thread == 1,
        oneshot_thread_half@ is HalfRightToComplete,
        shared_state.wf(),
        oneshot_thread_half.id() == shared_state.get_oneshot_id(which_thread),
    ensures
        return_permission@.id() == shared_state.get_oneshot_id(which_thread),
        return_permission@@ is Complete,
{
    let tracked mut oneshot_thread_half = oneshot_thread_half;
    open_atomic_invariant!(shared_state.inv.borrow() => inner => {
        // Increment the shared `x` by 1.
        shared_state.x.fetch_add_wrapping(Tracked(&mut inner.x_perm), 1);
        proof {
            // Atomically with that increment, perform the one-shot.
            // This requires providing two half authorities. One was
            // passed to this function as `oneshot_thread_half` and
            // the other is in this invariant.
            //
            // Technically, the invariant just tells us that either
            // the one-shot is complete *or* we have half authority to
            // it. Fortunately, `perform_using_two_halves` only
            // requires that one of the resources be known to be a
            // half authority. (It can deduce that the other one must
            // be, since a `HalfRightToComplete` resource can't
            // co-exist with a `Completed` resource of the same ID.)
            if which_thread == 0 {
                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot0_inv_half);
            }
            else {
                oneshot_thread_half.perform_using_two_halves(&mut inner.oneshot1_inv_half);
            }
            assert(oneshot_thread_half@ is Complete);
        }
    });
    // Return the updated permission. It's been updated from (a)
    // half the authority to complete the one-shot to (b)
    // knowledge that the one-shot is complete.
    Tracked(oneshot_thread_half)
}

// This function counts to two by forking two threads, each tasked
// with incrementing `x` and then returning knowledge that that
// thread has performed its increment. In this way, it's able to
// guarantee that when it reads `x` after joining those two
// threads, the result is 2.
pub fn count_to_two() -> (result: Result<u32, ()>)
    ensures
        result is Ok ==> result.unwrap() == 2,
{
    // Create two one-shots, one for each thread we're going to
    // fork. Calling `create_oneshot` provides two permissions to
    // the one-shot resource, each granting half authority to
    // perform the one-shot. We'll stash one half in our invariant
    // and pass the other half to the appropriate thread. It's
    // necessary to have both halves to perform any one-shot, so
    // each thread will have to combine its half with the
    // corresponding one in the invariant.
    let tracked (mut oneshot0_inv_half, mut oneshot0_thread_half) =
        OneShotResource::alloc().split();
    let tracked (mut oneshot1_inv_half, mut oneshot1_thread_half) =
        OneShotResource::alloc().split();
    // Create the shared state that includes a new `PAtomicU32` and
    // an invariant that starts out holding `oneshot0_inv_half` and
    // `oneshot1_inv_half1.
    let shared_state = CounterSharedState::new(
        Tracked(oneshot0_inv_half),
        Tracked(oneshot1_inv_half),
    );
    // For each thread, clone the shared-state Arc and use this to
    // fork the thread. Also pass each thread a tracked permission
    // providing half the authority to update its one-shot.
    let shared_state_clone = shared_state.clone();
    let join_handle0 = vstd::thread::spawn(
        move || -> (return_value: Tracked<OneShotResource>)
            ensures
                return_value@.id() == shared_state.get_oneshot_id(0),
                return_value@@ is Complete,
            {
                thread_routine(shared_state_clone, Tracked(oneshot0_thread_half), Ghost(0))
            }
    );
    let shared_state_clone = shared_state.clone();
    let join_handle1 = vstd::thread::spawn(
        move || -> (return_value: Tracked<OneShotResource>)
            ensures
                return_value@.id() == shared_state.get_oneshot_id(1),
                return_value@@ is Complete,
            {
                thread_routine(shared_state_clone, Tracked(oneshot1_thread_half), Ghost(1))
            }
    );
    // Let the threads run in parallel, then join them both when
    // they're done.
    if let (Ok(oneshot0_complete), Ok(oneshot1_complete)) = (
        join_handle0.join(),
        join_handle1.join(),
    ) {
        // If both joins succeeded, we can now read the shared
        // `PAtomicU32`'s value `x` by opening the invariant.
        Ok(shared_state.read_x(oneshot0_complete, oneshot1_complete))
    } else {
        // If either of the joins failed, we can't proceed.
        Err(())
    }
}

pub fn main() {
    if let Ok(x) = count_to_two() {
        assert(x == 2);
    }
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/pcm/log.rs,293,105,0.3583617747440273,338.472,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'std::result::', 'vstd::pcm::', 'vstd::pcm_lib::', 'vstd::prelude::']",True,,,,,,"//! This file implements logs with entries of type `T` using a custom
//! resource algebra.
//!
//! To use it, use LogResource::<T>::alloc(), which will create a
//! fresh log and return a `LogResource<T>` representing full
//! authority to append to the log. Here's example code for this:
//!
//! ```
//! let tracked full_auth = LogResource::<int>::alloc();
//! assert(full_auth@ is FullAuthority);
//! assert(full_auth@.log().len() == 0);
//! ```
//!
//! You can use the full authority you obtain via `alloc()` to append
//! to the log, as in the following example:
//!
//! ```
//! proof { full_auth.append(42); }
//! proof { full_auth.append(86); }
//! assert(full_auth@.log().len() == 2);
//! assert(full_auth@.log()[0] == 42);
//! assert(full_auth@.log()[1] == 86);
//! ```
//!
//! If desired, you can split a `LogResource` representing full
//! authority into two half authorities using `split`. You may want to
//! do this if you're stashing half the authority in an invariant.
//! Here's an example use of `LogResource::split()`; note that it
//! consumes the resource.
//!
//! ```
//! let tracked (half_auth1, half_auth2) = full_auth.split();
//! assert(half_auth1@ == half_auth2@);
//! assert(half_auth1@ is HalfAuthority);
//! ```
//!
//! You can use two half authorities to append to the log using
//! `append_using_two_halves` as in the following example:
//!
//! ```
//! proof { half_auth1.append_using_two_halves(&mut half_auth2, 17); }
//! assert(half_auth1@.log().len() == 3);
//! assert(half_auth1@.log()[2] == 17);
//! assert(half_auth2@ == half_auth1@);
//! ```
#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use std::result::*;
use vstd::pcm::*;
use vstd::pcm_lib::*;
use vstd::prelude::*;

verus! {

pub enum LogResourceValue<T> {
    PrefixKnowledge { prefix: Seq<T> },
    HalfAuthority { log: Seq<T> },
    FullAuthority { log: Seq<T> },
    Invalid,
}

pub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {
    &&& s1.len() <= s2.len()
    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]
}

impl<T> PCM for LogResourceValue<T> {
    open spec fn valid(self) -> bool {
        &&& !(self is Invalid)
    }

    open spec fn op(self, other: Self) -> Self {
        match (self, other) {
            (
                Self::PrefixKnowledge { prefix: prefix1 },
                Self::PrefixKnowledge { prefix: prefix2 },
            ) => if is_prefix(prefix1, prefix2) {
                other
            } else {
                if is_prefix(prefix2, prefix1) {
                    self
                } else {
                    Self::Invalid
                }
            },
            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(
                prefix,
                log,
            ) {
                other
            } else {
                Self::Invalid
            },
            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(
                prefix,
                log,
            ) {
                self
            } else {
                Self::Invalid
            },
            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(
                prefix,
                log,
            ) {
                other
            } else {
                Self::Invalid
            },
            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(
                prefix,
                log,
            ) {
                self
            } else {
                Self::Invalid
            },
            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1
                == log2 {
                Self::FullAuthority { log: log1 }
            } else {
                Self::Invalid
            },
            (_, _) => Self::Invalid,
        }
    }

    open spec fn unit() -> Self {
        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }
    }

    proof fn closed_under_incl(a: Self, b: Self) {
    }

    proof fn commutative(a: Self, b: Self) {
        assert(forall|log1: Seq<T>, log2: Seq<T>|
            is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);
    }

    proof fn associative(a: Self, b: Self, c: Self) {
        assert(forall|log1: Seq<T>, log2: Seq<T>|
            is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);
        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());
    }

    proof fn op_unit(a: Self) {
        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());
    }

    proof fn unit_valid() {
    }
}

impl<T> LogResourceValue<T> {
    pub open spec fn log(self) -> Seq<T> {
        match self {
            LogResourceValue::PrefixKnowledge { prefix } => prefix,
            LogResourceValue::HalfAuthority { log } => log,
            LogResourceValue::FullAuthority { log } => log,
            LogResourceValue::Invalid => Seq::<T>::empty(),
        }
    }

    proof fn op_unit(a: Self) {
        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());
    }

    proof fn unit_valid() {
    }
}

pub struct LogResource<T> {
    r: Resource<LogResourceValue<T>>,
}

impl<T> LogResource<T> {
    pub closed spec fn id(self) -> Loc {
        self.r.loc()
    }

    pub closed spec fn view(self) -> LogResourceValue<T> {
        self.r.value()
    }

    pub proof fn alloc() -> (tracked result: LogResource<T>)
        ensures
            result@ is FullAuthority,
            result@.log() == Seq::<T>::empty(),
    {
        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };
        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);
        Self { r }
    }

    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))
        requires
            self@ is FullAuthority,
        ensures
            ({
                let (half1, half2) = halves;
                &&& half1@ is HalfAuthority
                &&& half2@ is HalfAuthority
                &&& half1.id() == half2.id() == self.id()
                &&& half1@.log() == self@.log()
                &&& half2@ == half1@
            }),
    {
        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };
        let tracked (half1, half2) = self.r.split(half_value, half_value);
        (Self { r: half1 }, Self { r: half2 })
    }

    pub proof fn append(tracked &mut self, v: T)
        requires
            old(self)@ is FullAuthority,
        ensures
            self@ is FullAuthority,
            self.id() == old(self).id(),
            self@.log() == old(self)@.log() + seq![v],
    {
        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };
        update_mut(&mut self.r, value);
    }

    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)
        requires
            old(self)@ is HalfAuthority,
            old(other)@ is HalfAuthority,
            old(self).id() == old(other).id(),
        ensures
            self@ is HalfAuthority,
            self.id() == other.id() == old(self).id(),
            self@.log() == old(self)@.log() + seq![v],
            other@ == self@,
    {
        self.r.validate_2(&other.r);
        let new_log = self@.log() + seq![v];
        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };
        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);
    }

    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)
        ensures
            out@ is PrefixKnowledge,
            out.id() == self.id(),
            out@.log() == self@.log(),
    {
        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };
        let tracked r = copy_duplicable_part(&self.r, v);
        Self { r }
    }

    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)
        requires
            old(self).id() == other.id(),
        ensures
            self@ == old(self)@,
            is_prefix(self@.log(), other@.log()) || is_prefix(other@.log(), self@.log()),
            self@ is HalfAuthority ==> is_prefix(other@.log(), self@.log()),
            self@ is FullAuthority ==> is_prefix(other@.log(), self@.log()),
            other@ is HalfAuthority ==> is_prefix(self@.log(), other@.log()),
            other@ is FullAuthority ==> is_prefix(self@.log(), other@.log()),
    {
        self.r.validate_2(&other.r)
    }
}

pub fn main() {
    let tracked full_auth = LogResource::<int>::alloc();
    assert(full_auth@ is FullAuthority);
    assert(full_auth@.log().len() == 0);
    proof {
        full_auth.append(42);
    }
    proof {
        full_auth.append(86);
    }
    assert(full_auth@.log().len() == 2);
    assert(full_auth@.log()[0] == 42);
    assert(full_auth@.log()[1] == 86);
    let tracked (half_auth1, half_auth2) = full_auth.split();
    assert(half_auth1@ == half_auth2@);
    assert(half_auth1@ is HalfAuthority);
    proof {
        half_auth1.append_using_two_halves(&mut half_auth2, 17);
    }
    assert(half_auth1@.log().len() == 3);
    assert(half_auth1@.log()[2] == 17);
    assert(half_auth2@ == half_auth1@);
}

} // verus!
"," use vstd::pcm::*;
        use vstd::prelude::*;
        verus! {
       pub enum LogResourceValue<T> {
          PrefixKnowledge {
     prefix: Seq<T> }
     ,     HalfAuthority {
     log: Seq<T> }
     ,     FullAuthority {
     log: Seq<T> }
     ,     Invalid, }
       pub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {
          &&& s1.len() <= s2.len()     &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i] }
       impl<T> PCM for LogResourceValue<T> {
          open spec fn valid(self) -> bool {
             &&& !(self is Invalid)     }
          open spec fn op(self, other: Self) -> Self {
             match (self, other) {
                (                 Self::PrefixKnowledge {
   prefix: prefix1 }
   ,                 Self::PrefixKnowledge {
   prefix: prefix2 }
   ,             ) => if is_prefix(prefix1, prefix2) {
                   other             }
    else {
                   if is_prefix(prefix2, prefix1) {
                       self                 }
   else {
                       Self::Invalid                 }
               }
   ,             (Self::PrefixKnowledge {
   prefix }
   , Self::HalfAuthority {
   log }
   ) => if is_prefix(                 prefix,                 log,             ) {
                   other             }
    else {
                   Self::Invalid             }
   ,             (Self::HalfAuthority {
   log }
   , Self::PrefixKnowledge {
   prefix }
   ) => if is_prefix(                 prefix,                 log,             ) {
                   self             }
    else {
                   Self::Invalid             }
   ,             (Self::PrefixKnowledge {
   prefix }
   , Self::FullAuthority {
   log }
   ) => if is_prefix(                 prefix,                 log,             ) {
                   other             }
    else {
                   Self::Invalid             }
   ,             (Self::FullAuthority {
   log }
   , Self::PrefixKnowledge {
   prefix }
   ) => if is_prefix(                 prefix,                 log,             ) {
                   self             }
    else {
                   Self::Invalid             }
   ,             (Self::HalfAuthority {
   log: log1 }
   , Self::HalfAuthority {
   log: log2 }
   ) => if log1                 == log2 {
                   Self::FullAuthority {
   log: log1 }
               }
    else {
                   Self::Invalid             }
   ,             (_, _) => Self::Invalid,         }
         }
          open spec fn unit() -> Self {
             Self::PrefixKnowledge {
    prefix: Seq::<>::empty() }
         }
          proof fn closed_under_incl(a: Self, b: Self) {}
          proof fn commutative(a: Self, b: Self) {
             assert(forall|log1: Seq<T>, log2: Seq<T>|             is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);
         }
          proof fn associative(a: Self, b: Self, c: Self) {}
          proof fn op_unit(a: Self) {
             assert(forall|log| is_prefix(log, Seq::<>::empty()) ==> log =~= Seq::<T>::empty());
         }
          proof fn unit_valid() {}
      }
       impl<T> LogResourceValue<T> {
          pub open spec fn log(self) -> Seq<T> {
             match self {
                LogResourceValue::PrefixKnowledge {
   prefix }
    => prefix,             LogResourceValue::HalfAuthority {
   log }
    => log,             LogResourceValue::FullAuthority {
   log }
    => log,             LogResourceValue::Invalid => Seq::<>::empty(),         }
         }
      }
       pub struct LogResource<T> {
          r: Resource<LogResourceValue<T>>, }
       impl<T> LogResource<T> {}
       pub fn main() ;
       }
","[""//! This file implements logs with entries of type `T` using a custom\n//! resource algebra.\n//!\n//! To use it, use LogResource::<T>::alloc(), which will create a\n//! fresh log and return a `LogResource<T>` representing full\n//! authority to append to the log. Here's example code for this:\n//!\n//! ```\n//! let tracked full_auth = LogResource::<int>::alloc();\n//! assert(full_auth@ is FullAuthority);\n//! assert(full_auth@.log().len() == 0);\n//! ```\n//!\n//! You can use the full authority you obtain via `alloc()` to append\n//! to the log, as in the following example:\n//!\n//! ```\n//! proof { full_auth.append(42); }\n//! proof { full_auth.append(86); }\n//! assert(full_auth@.log().len() == 2);\n//! assert(full_auth@.log()[0] == 42);\n//! assert(full_auth@.log()[1] == 86);\n//! ```\n//!\n//! If desired, you can split a `LogResource` representing full\n//! authority into two half authorities using `split`. You may want to\n//! do this if you're stashing half the authority in an invariant.\n//! Here's an example use of `LogResource::split()`; note that it\n//! consumes the resource.\n//!\n//! ```\n//! let tracked (half_auth1, half_auth2) = full_auth.split();\n//! assert(half_auth1@ == half_auth2@);\n//! assert(half_auth1@ is HalfAuthority);\n//! ```\n//!\n//! You can use two half authorities to append to the log using\n//! `append_using_two_halves` as in the following example:\n//!\n//! ```\n//! proof { half_auth1.append_using_two_halves(&mut half_auth2, 17); }\n//! assert(half_auth1@.log().len() == 3);\n//! assert(half_auth1@.log()[2] == 17);\n//! assert(half_auth2@ == half_auth1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum LogResourceValue<T> {\n    PrefixKnowledge { prefix: Seq<T> },\n    HalfAuthority { log: Seq<T> },\n    FullAuthority { log: Seq<T> },\n    Invalid,\n}\n\npub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    &&& s1.len() <= s2.len()\n    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]\n}\n\nimpl<T> PCM for LogResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        &&& !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (\n                Self::PrefixKnowledge { prefix: prefix1 },\n                Self::PrefixKnowledge { prefix: prefix2 },\n            ) => if is_prefix(prefix1, prefix2) {\n                other\n            } else {\n                if is_prefix(prefix2, prefix1) {\n                    self\n                } else {\n                    Self::Invalid\n                }\n            },\n            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1\n                == log2 {\n                Self::FullAuthority { log: log1 }\n            } else {\n                Self::Invalid\n            },\n            (_, _) => Self::Invalid,\n        }\n    }\n\n    open spec fn unit() -> Self {\n        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl<T> LogResourceValue<T> {\n    pub open spec fn log(self) -> Seq<T> {\n        match self {\n            LogResourceValue::PrefixKnowledge { prefix } => prefix,\n            LogResourceValue::HalfAuthority { log } => log,\n            LogResourceValue::FullAuthority { log } => log,\n            LogResourceValue::Invalid => Seq::<T>::empty(),\n        }\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct LogResource<T> {\n    r: Resource<LogResourceValue<T>>,\n}\n\nimpl<T> LogResource<T> {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> LogResourceValue<T> {\n        self.r.value()\n    }\n\n    pub proof fn alloc() -> (tracked result: LogResource<T>)\n        ensures\n            result@ is FullAuthority,\n            result@.log() == Seq::<T>::empty(),\n    {\n        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };\n        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);\n        Self { r }\n    }\n\n    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))\n        requires\n            self@ is FullAuthority,\n        ensures\n            ({\n                let (half1, half2) = halves;\n                &&& half1@ is HalfAuthority\n                &&& half2@ is HalfAuthority\n                &&& half1.id() == half2.id() == self.id()\n                &&& half1@.log() == self@.log()\n                &&& half2@ == half1@\n            }),\n    {\n        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n        let tracked (half1, half2) = self.r.split(half_value, half_value);\n        (Self { r: half1 }, Self { r: half2 })\n    }\n\n    pub proof fn append(tracked &mut self, v: T)\n        requires\n            old(self)@ is FullAuthority,\n        ensures\n            self@ is FullAuthority,\n            self.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n    {\n        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };\n        update_mut(&mut self.r, value);\n    }\n\n    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)\n        requires\n            old(self)@ is HalfAuthority,\n            old(other)@ is HalfAuthority,\n            old(self).id() == old(other).id(),\n        ensures\n            self@ is HalfAuthority,\n            self.id() == other.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n            other@ == self@,\n    {\n        self.r.validate_2(&other.r);\n        let new_log = self@.log() + seq![v];\n        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };\n        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);\n    }\n\n    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is PrefixKnowledge,\n            out.id() == self.id(),\n            out@.log() == self@.log(),\n    {\n        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            is_prefix(self@.log(), other@.log()) || is_prefix(other@.log(), self@.log()),\n            self@ is HalfAuthority ==> is_prefix(other@.log(), self@.log()),\n            self@ is FullAuthority ==> is_prefix(other@.log(), self@.log()),\n            other@ is HalfAuthority ==> is_prefix(self@.log(), other@.log()),\n            other@ is FullAuthority ==> is_prefix(self@.log(), other@.log()),\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\npub fn main() {\n    let tracked full_auth = LogResource::<int>::alloc();\n    assert(full_auth@ is FullAuthority);\n    assert(full_auth@.log().len() == 0);\n    proof {\n        full_auth.append(42);\n    }\n    proof {\n        full_auth.append(86);\n    }\n    assert(full_auth@.log().len() == 2);\n    assert(full_auth@.log()[0] == 42);\n    assert(full_auth@.log()[1] == 86);\n    let tracked (half_auth1, half_auth2) = full_auth.split();\n    assert(half_auth1@ == half_auth2@);\n    assert(half_auth1@ is HalfAuthority);\n    proof {\n        half_auth1.append_using_two_halves(&mut half_auth2, 17);\n    }\n    assert(half_auth1@.log().len() == 3);\n    assert(half_auth1@.log()[2] == 17);\n    assert(half_auth2@ == half_auth1@);\n}\n\n} // verus!\n"", 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use vstd::pcm::*;\n    use vstd::prelude::*;\n    verus! {\n   pub enum LogResourceValue<T> {\n      PrefixKnowledge {\n prefix: Seq<T> }\n ,     HalfAuthority {\n log: Seq<T> }\n ,     FullAuthority {\n log: Seq<T> }\n ,     Invalid, }\n   pub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n      &&& s1.len() <= s2.len()     &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i] }\n   impl<T> PCM for LogResourceValue<T> {\n      open spec fn valid(self) -> bool {\n         &&& !(self is Invalid)     }\n      open spec fn op(self, other: Self) -> Self {\n         match (self, other) {             (                 Self::PrefixKnowledge { prefix: prefix1 },                 Self::PrefixKnowledge { prefix: prefix2 },             ) => if is_prefix(prefix1, prefix2) {                 other             } else {                 if is_prefix(prefix2, prefix1) {                     self                 } else {                     Self::Invalid                 }             },             (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(                 prefix,                 log,             ) {                 other             } else {                 Self::Invalid             },             (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(                 prefix,                 log,             ) {                 self             } else {                 Self::Invalid             },             (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(                 prefix,                 log,             ) {                 other             } else {                 Self::Invalid             },             (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(                 prefix,                 log,             ) {                 self             } else {                 Self::Invalid             },             (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1                 == log2 {                 Self::FullAuthority { log: log1 }             } else {                 Self::Invalid             },             (_, _) => Self::Invalid,         }\n     }\n      open spec fn unit() -> Self {\n         Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n     }\n      proof fn closed_under_incl(a: Self, b: Self) {\n     }\n      proof fn commutative(a: Self, b: Self) {\n         assert(forall|log1: Seq<T>, log2: Seq<T>|             is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n     }\n      proof fn associative(a: Self, b: Self, c: Self) {\n         assert(forall|log1: Seq<T>, log2: Seq<T>|             is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n         assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n     }\n      proof fn op_unit(a: Self) {\n         assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n     }\n      proof fn unit_valid() {\n     }\n  }\n   impl<T> LogResourceValue<T> {\n      pub open spec fn log(self) -> Seq<T> {\n         match self {             LogResourceValue::PrefixKnowledge { prefix } => prefix,             LogResourceValue::HalfAuthority { log } => log,             LogResourceValue::FullAuthority { log } => log,             LogResourceValue::Invalid => Seq::<T>::empty(),         }\n     }\n  }\n   pub struct LogResource<T> {\n      r: Resource<LogResourceValue<T>>, }\n   impl<T> LogResource<T> {\n      pub closed spec fn id(self) -> Loc {\n         self.r.loc()     }\n      pub closed spec fn view(self) -> LogResourceValue<T> {\n         self.r.value()     }\n      pub proof fn split(tracked self) -> (tracked halves: (Self, Self))         requires             self@ is FullAuthority,         ensures             ({\n                 let (half1, half2) = halves;\n                 &&& half1@ is HalfAuthority                 &&& half2@ is HalfAuthority                 &&& half1.id() == half2.id() == self.id()                 &&& half1@.log() == self@.log()                 &&& half2@ == half1@             }\n ),     {\n         let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n         let tracked (half1, half2) = self.r.split(half_value, half_value);\n         (Self { r: half1 }\n, Self { r: half2 }\n)     }\n  }\n   pub fn main() {\n  }\n   }\n', ' use vstd::pcm::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum LogResourceValue<T> {\n          PrefixKnowledge {\n     prefix: Seq<T> }\n     ,     HalfAuthority {\n     log: Seq<T> }\n     ,     FullAuthority {\n     log: Seq<T> }\n     ,     Invalid, }\n       pub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n          &&& s1.len() <= s2.len()     &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i] }\n       impl<T> PCM for LogResourceValue<T> {\n          open spec fn valid(self) -> bool {\n             &&& !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (                 Self::PrefixKnowledge {\n   prefix: prefix1 }\n   ,                 Self::PrefixKnowledge {\n   prefix: prefix2 }\n   ,             ) => if is_prefix(prefix1, prefix2) {\n                   other             }\n    else {\n                   if is_prefix(prefix2, prefix1) {\n                       self                 }\n   else {\n                       Self::Invalid                 }\n               }\n   ,             (Self::PrefixKnowledge {\n   prefix }\n   , Self::HalfAuthority {\n   log }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   other             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::HalfAuthority {\n   log }\n   , Self::PrefixKnowledge {\n   prefix }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   self             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::PrefixKnowledge {\n   prefix }\n   , Self::FullAuthority {\n   log }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   other             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::FullAuthority {\n   log }\n   , Self::PrefixKnowledge {\n   prefix }\n   ) => if is_prefix(                 prefix,                 log,             ) {\n                   self             }\n    else {\n                   Self::Invalid             }\n   ,             (Self::HalfAuthority {\n   log: log1 }\n   , Self::HalfAuthority {\n   log: log2 }\n   ) => if log1                 == log2 {\n                   Self::FullAuthority {\n   log: log1 }\n               }\n    else {\n                   Self::Invalid             }\n   ,             (_, _) => Self::Invalid,         }\n         }\n          open spec fn unit() -> Self {\n             Self::PrefixKnowledge {\n    prefix: Seq::<>::empty() }\n         }\n          proof fn closed_under_incl(a: Self, b: Self) {}\n          proof fn commutative(a: Self, b: Self) {\n             assert(forall|log1: Seq<T>, log2: Seq<T>|             is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n         }\n          proof fn associative(a: Self, b: Self, c: Self) {}\n          proof fn op_unit(a: Self) {\n             assert(forall|log| is_prefix(log, Seq::<>::empty()) ==> log =~= Seq::<T>::empty());\n         }\n          proof fn unit_valid() {}\n      }\n       impl<T> LogResourceValue<T> {\n          pub open spec fn log(self) -> Seq<T> {\n             match self {\n                LogResourceValue::PrefixKnowledge {\n   prefix }\n    => prefix,             LogResourceValue::HalfAuthority {\n   log }\n    => log,             LogResourceValue::FullAuthority {\n   log }\n    => log,             LogResourceValue::Invalid => Seq::<>::empty(),         }\n         }\n      }\n       pub struct LogResource<T> {\n          r: Resource<LogResourceValue<T>>, }\n       impl<T> LogResource<T> {}\n       pub fn main() ;\n       }\n', '          use vstd::prelude::*;\n            verus! {\n          pub fn main() ;\n          }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/pcm/monotonic_counter.rs,356,120,0.33707865168539325,368.067,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'std::result::', 'vstd::pcm::', 'vstd::pcm_lib::', 'vstd::prelude::']",True,,,,,1.0,"//! This file implements monotonic counters using a custom resource
//! algebra.
//!
//! To use it, use MonotonicCounterResource::alloc(), which will
//! create a fresh monotonic counter and return a resource granting
//! full access to it. You can increment it the counter by calling
//! `increment` on a resource. For example:
//!
//! ```
//! let tracked full = MonotonicCounterResource::alloc();
//! proof { full.increment(); }
//! assert(full@.n() == 1);
//! ```
//!
//! To split a full right to advance into two half rights to advance,
//! use `split`. This is useful, for instance, to stash half inside an
//! invariant and pass the other half to the thread having the right
//! to advance. Both halves will have the same `id()` value,
//! indicating they correspond to the same monotonic counter. For
//! example:
//!
//! ```
//! let tracked full = MonotonicCounterResource::alloc();
//! let tracked (mut half1, mut half2) = full.split();
//! assert(half1.id() == half2.id());
//! assert(half1@.n() == 0);
//! assert(half2@.n() == 0);
//! ```
//!
//! You can use two half authorities together to increment the
//! associated counter, as in this example:
//!
//! ```
//! let ghost v1 == half1@.n();
//! proof { half1.increment_using_two_halves(&mut half2); }
//! assert(half1.id() == half2.id());
//! assert(half1@ == half2@);
//! assert(half1@.n() == half2@.n() == v1 + 1);
//! ```
//!
//! From any `MonotonicCounterResource`, one can use
//! `extract_lower_bound()` to extract a `MonotonicCounterResource`
//! that represents knowledge of a lower bound on the current value of
//! the monotonic counter. You can also duplicate a
//! `MonotonicCounterResource` using this function. Here are examples:
//!
//! ```
//! let tracked mut lower_bound = half1.extract_lower_bound();
//! assert(lower_bound@.n() == 1);
//! let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();
//! assert(lower_bound_duplicate@.n() == 1);
//! ```
#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use std::result::*;
use vstd::pcm::*;
use vstd::pcm_lib::*;
use vstd::prelude::*;

verus! {

// A monotonic counter permission represents a resource with one of
// the following three values:
//
// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter
// is at least `lower_bound`
//
// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is
// exactly `value` and the authority to advance it past that value
//
// `HalfRightToAdvance{ value }` -- knowledge that the monotonic
// counter is exactly `value` and half the authority to advance it
// past that value. Can be combined with another half authority to
// make a full authority.
pub enum MonotonicCounterResourceValue {
    LowerBound { lower_bound: nat },
    HalfRightToAdvance { value: nat },
    FullRightToAdvance { value: nat },
    Invalid,
}

// To use `MonotonicCounterResourceValue` as a resource, we have to implement
// `PCM`, showing how to use it in a resource algebra.
impl PCM for MonotonicCounterResourceValue {
    open spec fn valid(self) -> bool {
        !(self is Invalid)
    }

    open spec fn op(self, other: Self) -> Self {
        match (self, other) {
            // Two lower bounds can be combined into a lower bound
            // that's the maximum of the two lower bounds.
            (
                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },
                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },
            ) => {
                let max_lower_bound = if lower_bound1 > lower_bound2 {
                    lower_bound1
                } else {
                    lower_bound2
                };
                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }
            },
            // A lower bound can be combined with a right to
            // advance as long as the lower bound doesn't exceed
            // the value in the right to advance.
            (
                MonotonicCounterResourceValue::LowerBound { lower_bound },
                MonotonicCounterResourceValue::FullRightToAdvance { value },
            ) => if lower_bound <= value {
                MonotonicCounterResourceValue::FullRightToAdvance { value }
            } else {
                MonotonicCounterResourceValue::Invalid {  }
            },
            (
                MonotonicCounterResourceValue::FullRightToAdvance { value },
                MonotonicCounterResourceValue::LowerBound { lower_bound },
            ) => if lower_bound <= value {
                MonotonicCounterResourceValue::FullRightToAdvance { value }
            } else {
                MonotonicCounterResourceValue::Invalid {  }
            },
            // A lower bound can be combined with a half right to
            // advance as long as the lower bound doesn't exceed
            // the value in the half right to advance.
            (
                MonotonicCounterResourceValue::LowerBound { lower_bound },
                MonotonicCounterResourceValue::HalfRightToAdvance { value },
            ) => if lower_bound <= value {
                MonotonicCounterResourceValue::HalfRightToAdvance { value }
            } else {
                MonotonicCounterResourceValue::Invalid {  }
            },
            (
                MonotonicCounterResourceValue::HalfRightToAdvance { value },
                MonotonicCounterResourceValue::LowerBound { lower_bound },
            ) => if lower_bound <= value {
                MonotonicCounterResourceValue::HalfRightToAdvance { value }
            } else {
                MonotonicCounterResourceValue::Invalid {  }
            },
            // Two half rights to advance can be combined to make
            // a whole right to advance, as long as the two values
            // agree with each other.
            (
                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },
                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },
            ) => if value1 == value2 {
                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }
            } else {
                MonotonicCounterResourceValue::Invalid {  }
            },
            // Any other combination is invalid
            (_, _) => MonotonicCounterResourceValue::Invalid {  },
        }
    }

    open spec fn unit() -> Self {
        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }
    }

    proof fn closed_under_incl(a: Self, b: Self) {
    }

    proof fn commutative(a: Self, b: Self) {
    }

    proof fn associative(a: Self, b: Self, c: Self) {
    }

    proof fn op_unit(a: Self) {
    }

    proof fn unit_valid() {
    }
}

impl MonotonicCounterResourceValue {
    pub open spec fn n(self) -> nat {
        match self {
            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,
            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,
            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,
            MonotonicCounterResourceValue::Invalid => 0,
        }
    }
}

pub struct MonotonicCounterResource {
    r: Resource<MonotonicCounterResourceValue>,
}

impl MonotonicCounterResource {
    pub closed spec fn id(self) -> Loc {
        self.r.loc()
    }

    pub closed spec fn view(self) -> MonotonicCounterResourceValue {
        self.r.value()
    }

    // This function creates a monotonic counter and returns a
    // resource granting full authority to advance it and giving
    // knowledge that the current value is 0.
    pub proof fn alloc() -> (tracked result: Self)
        ensures
            result@ == (MonotonicCounterResourceValue::FullRightToAdvance { value: 0 }),
    {
        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };
        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);
        Self { r }
    }


    // Join two resources
    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)
        requires
            self.id() == other.id(),
            self@.n() == other@.n()
        ensures
            r.id() == self.id(),
            r@.n() == self@.op(other@).n(),
    {
        let tracked mut r = self.r.join(other.r);
        Self { r }
    }

    // This function splits a resource granting full authority to
    // advance a monotonic counter into two resources each granting
    // half authority to advance it. They both have the same `id()`,
    // meaning they correspond to the same monotonic counter.
    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))
        requires
            self@ is FullRightToAdvance,
        ensures
            ({
                let (r1, r2) = return_value;
                let value = self@->FullRightToAdvance_value;
                &&& r1.id() == r2.id() == self.id()
                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })
                &&& r2@ == r1@
            }),
    {
        let value = self@->FullRightToAdvance_value;
        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };
        let tracked (r1, r2) = self.r.split(v_half, v_half);
        (Self { r: r1 }, Self { r: r2 })
    }

    // This function uses a resource granting full authority to
    // advance a monotonic counter to increment the counter.
    pub proof fn increment(tracked &mut self)
        requires
            old(self)@ is FullRightToAdvance,
        ensures
            self.id() == old(self).id(),
            self@ == (MonotonicCounterResourceValue::FullRightToAdvance {
                value: old(self)@->FullRightToAdvance_value + 1,
            }),
    {
        let v = self@->FullRightToAdvance_value;
        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };
        update_mut(&mut self.r, r);
    }

    // This function uses two tracked resources, each granting half
    // authority to advance a monotonic counter, to increment the
    // counter. The two permissions must have the same `id()` values.
    //
    // It's not a requirement that the two halves match in value; this
    // function can figure out that they match just from the fact that
    // they co-exist.
    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)
        requires
            old(self).id() == old(other).id(),
            old(self)@ is HalfRightToAdvance,
            old(other)@ is HalfRightToAdvance,
        ensures
            old(self)@ == old(other)@,
            self.id() == other.id() == old(self).id(),
            other@ == self@,
            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {
                value: old(self)@->HalfRightToAdvance_value + 1,
            }),
    {
        self.r.validate_2(&other.r);
        let v = self@->HalfRightToAdvance_value;
        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };
        update_and_redistribute(&mut self.r, &mut other.r, r, r);
    }

    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)
        ensures
            out@ is LowerBound,
            out.id() == self.id(),
            out@ == (MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() }),
    {
        self.r.validate();
        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };
        let tracked r = copy_duplicable_part(&self.r, v);
        Self { r }
    }

    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)
        requires
            old(self).id() == other.id(),
        ensures
            self@ == old(self)@,
            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),
            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),
            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),
            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n(),

    {
        self.r.validate_2(&other.r)
    }
}

// This example illustrates some uses of the monotonic counter.
fn main() {
    let tracked full = MonotonicCounterResource::alloc();
    proof {
        full.increment();
    }
    assert(full@.n() == 1);
    let tracked full = MonotonicCounterResource::alloc();
    let tracked zero_lower_bound = full.extract_lower_bound();
    let tracked (mut half1, mut half2) = full.split();
    assert(half1.id() == half2.id());
    assert(half1@.n() == 0);
    assert(half2@.n() == 0);
    let ghost id = half1.id();
    let ghost v1 = half1@.n();
    let ghost v2 = half2@.n();
    assert(v1 == v2);
    proof {
        half1.increment_using_two_halves(&mut half2);
    }
    assert(half1.id() == half2.id() == id);
    assert(half1@.n() == half2@.n() == v1 + 1);
    assert(half1@.n() == 1);
    let tracked mut lower_bound = half1.extract_lower_bound();
    assert(lower_bound@.n() == 1);
    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();
    assert(lower_bound_duplicate@.n() == 1);


    proof {
        let tracked reconstructed_full = half1.join(half2);
        zero_lower_bound.lemma_lower_bound(&reconstructed_full);
        assert(zero_lower_bound@.n() <= reconstructed_full@.n());
    }
}

} // verus!
"," use vstd::pcm::*;
     use vstd::pcm_lib::*;
     use vstd::prelude::*;
     verus! {
    pub enum MonotonicCounterResourceValue {
       LowerBound {
  lower_bound: nat }
  ,     HalfRightToAdvance {
  value: nat }
  ,     FullRightToAdvance {
  value: nat }
  ,     Invalid, }
    impl PCM for MonotonicCounterResourceValue {
       open spec fn valid(self) -> bool {
          !(self is Invalid)     }
       open spec fn op(self, other: Self) -> Self {
          match (self, other) {
             (                 MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 }
,                 MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 }
,             ) => {                 let max_lower_bound = if lower_bound1 > lower_bound2 {                     lower_bound1                 } else {                     lower_bound2                 };                 MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }             }
,             (                 MonotonicCounterResourceValue::LowerBound { lower_bound }
,                 MonotonicCounterResourceValue::FullRightToAdvance { value }
,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::FullRightToAdvance { value }             }
 else {                 MonotonicCounterResourceValue::Invalid {  }             }
,             (                 MonotonicCounterResourceValue::FullRightToAdvance { value }
,                 MonotonicCounterResourceValue::LowerBound { lower_bound }
,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::FullRightToAdvance { value }             }
 else {                 MonotonicCounterResourceValue::Invalid {  }             }
,             (                 MonotonicCounterResourceValue::LowerBound { lower_bound }
,                 MonotonicCounterResourceValue::HalfRightToAdvance { value }
,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::HalfRightToAdvance { value }             }
 else {                 MonotonicCounterResourceValue::Invalid {  }             }
,             (                 MonotonicCounterResourceValue::HalfRightToAdvance { value }
,                 MonotonicCounterResourceValue::LowerBound { lower_bound }
,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::HalfRightToAdvance { value }             }
 else {                 MonotonicCounterResourceValue::Invalid {  }             }
,             (                 MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 }
,                 MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 }
,             ) => if value1 == value2 {                 MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }             }
 else {                 MonotonicCounterResourceValue::Invalid {  }             }
,             (_, _) => MonotonicCounterResourceValue::Invalid {  }
,         }
      }
       open spec fn unit() -> Self {
          MonotonicCounterResourceValue::LowerBound {
 lower_bound: 0 }
      }
       proof fn closed_under_incl(a: Self, b: Self) {
      }
       proof fn commutative(a: Self, b: Self) {
      }
       proof fn associative(a: Self, b: Self, c: Self) {
      }
       proof fn op_unit(a: Self) {
      }
       proof fn unit_valid() {
      }
   }
    impl MonotonicCounterResourceValue {
       pub open spec fn n(self) -> nat {
          match self {
             MonotonicCounterResourceValue::LowerBound { lower_bound }
 => lower_bound,             MonotonicCounterResourceValue::HalfRightToAdvance { value }
 => value,             MonotonicCounterResourceValue::FullRightToAdvance { value }
 => value,             MonotonicCounterResourceValue::Invalid => 0,         }
      }
   }
    pub struct MonotonicCounterResource {
       r: Resource<MonotonicCounterResourceValue>, }
    impl MonotonicCounterResource {
       pub closed spec fn id(self) -> Loc {
          self.r.loc()     }
       pub closed spec fn view(self) -> MonotonicCounterResourceValue {
          self.r.value()     }
       pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToAdvance,         ensures             ({
                  let (r1, r2) = return_value;
                  let value = self@->FullRightToAdvance_value;
                  &&& r1.id() == r2.id() == self.id()                 &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance {
 value }
 )                 &&& r2@ == r1@             }
  ),     {
          let value = self@->FullRightToAdvance_value;
          let v_half = MonotonicCounterResourceValue::HalfRightToAdvance {
 value };
          let tracked (r1, r2) = self.r.split(v_half, v_half);
          (Self {
 r: r1 }
 , Self {
 r: r2 }
 )     }
       pub proof fn increment(tracked &mut self)         requires             old(self)@ is FullRightToAdvance,         ensures             self.id() == old(self).id(),             self@ == (MonotonicCounterResourceValue::FullRightToAdvance {
                  value: old(self)@->FullRightToAdvance_value + 1,             }
  ),     {
          let v = self@->FullRightToAdvance_value;
          let r = MonotonicCounterResourceValue::FullRightToAdvance {
 value: v + 1 };
          update_mut(&mut self.r, r);
      }
       pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)         requires             old(self).id() == old(other).id(),             old(self)@ is HalfRightToAdvance,             old(other)@ is HalfRightToAdvance,         ensures             old(self)@ == old(other)@,             self.id() == other.id() == old(self).id(),             other@ == self@,             self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {
                  value: old(self)@->HalfRightToAdvance_value + 1,             }
  ),     {
          self.r.validate_2(&other.r);
          let v = self@->HalfRightToAdvance_value;
          let r = MonotonicCounterResourceValue::HalfRightToAdvance {
 value: v + 1 };
          update_and_redistribute(&mut self.r, &mut other.r, r, r);
      }
       pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)         ensures             out@ is LowerBound,             out.id() == self.id(),             out@ == (MonotonicCounterResourceValue::LowerBound {
  lower_bound: self@.n() }
  ),     {
          let v = MonotonicCounterResourceValue::LowerBound {
 lower_bound: self@.n() };
          let tracked r = copy_duplicable_part(&self.r, v);
          Self {
 r }
      }
   }
    fn main() {
   }
    }
","[""//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! proof { full.increment(); }\n//! assert(full@.n() == 1);\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//! invariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof { half1.increment_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id());\n//! assert(half1@ == half2@);\n//! assert(half1@.n() == half2@.n() == v1 + 1);\n//! ```\n//!\n//! From any `MonotonicCounterResource`, one can use\n//! `extract_lower_bound()` to extract a `MonotonicCounterResource`\n//! that represents knowledge of a lower bound on the current value of\n//! the monotonic counter. You can also duplicate a\n//! `MonotonicCounterResource` using this function. Here are examples:\n//!\n//! ```\n//! let tracked mut lower_bound = half1.extract_lower_bound();\n//! assert(lower_bound@.n() == 1);\n//! let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n//! assert(lower_bound_duplicate@.n() == 1);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n        ensures\n            result@ == (MonotonicCounterResourceValue::FullRightToAdvance { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n        requires\n            self.id() == other.id(),\n            self@.n() == other@.n()\n        ensures\n            r.id() == self.id(),\n            r@.n() == self@.op(other@).n(),\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToAdvance,\n        ensures\n            ({\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n        requires\n            old(self)@ is FullRightToAdvance,\n        ensures\n            self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance,\n        ensures\n            old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n(),\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n    proof {\n        full.increment();\n    }\n    assert(full@.n() == 1);\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n    assert(half1.id() == half2.id());\n    assert(half1@.n() == 0);\n    assert(half2@.n() == 0);\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n    assert(v1 == v2);\n    proof {\n        half1.increment_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@.n() == half2@.n() == v1 + 1);\n    assert(half1@.n() == 1);\n    let tracked mut lower_bound = half1.extract_lower_bound();\n    assert(lower_bound@.n() == 1);\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n    assert(lower_bound_duplicate@.n() == 1);\n\n\n    proof {\n        let tracked reconstructed_full = half1.join(half2);\n        zero_lower_bound.lemma_lower_bound(&reconstructed_full);\n        assert(zero_lower_bound@.n() <= reconstructed_full@.n());\n    }\n}\n\n} // verus!\n"", 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use vstd::pcm::*;\n     use vstd::pcm_lib::*;\n     use vstd::prelude::*;\n     verus! {\n    pub enum MonotonicCounterResourceValue {\n       LowerBound {\n  lower_bound: nat }\n  ,     HalfRightToAdvance {\n  value: nat }\n  ,     FullRightToAdvance {\n  value: nat }\n  ,     Invalid, }\n    impl PCM for MonotonicCounterResourceValue {\n       open spec fn valid(self) -> bool {\n          !(self is Invalid)     }\n       open spec fn op(self, other: Self) -> Self {\n          match (self, other) {\n             (                 MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 }\n,             ) => {                 let max_lower_bound = if lower_bound1 > lower_bound2 {                     lower_bound1                 } else {                     lower_bound2                 };                 MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }             }\n,             (                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,                 MonotonicCounterResourceValue::FullRightToAdvance { value }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::FullRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::FullRightToAdvance { value }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::FullRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,                 MonotonicCounterResourceValue::HalfRightToAdvance { value }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::HalfRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::HalfRightToAdvance { value }\n,                 MonotonicCounterResourceValue::LowerBound { lower_bound }\n,             ) => if lower_bound <= value {                 MonotonicCounterResourceValue::HalfRightToAdvance { value }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (                 MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 }\n,                 MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 }\n,             ) => if value1 == value2 {                 MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }             }\n else {                 MonotonicCounterResourceValue::Invalid {  }             }\n,             (_, _) => MonotonicCounterResourceValue::Invalid {  }\n,         }\n      }\n       open spec fn unit() -> Self {\n          MonotonicCounterResourceValue::LowerBound {\n lower_bound: 0 }\n      }\n       proof fn closed_under_incl(a: Self, b: Self) {\n      }\n       proof fn commutative(a: Self, b: Self) {\n      }\n       proof fn associative(a: Self, b: Self, c: Self) {\n      }\n       proof fn op_unit(a: Self) {\n      }\n       proof fn unit_valid() {\n      }\n   }\n    impl MonotonicCounterResourceValue {\n       pub open spec fn n(self) -> nat {\n          match self {\n             MonotonicCounterResourceValue::LowerBound { lower_bound }\n => lower_bound,             MonotonicCounterResourceValue::HalfRightToAdvance { value }\n => value,             MonotonicCounterResourceValue::FullRightToAdvance { value }\n => value,             MonotonicCounterResourceValue::Invalid => 0,         }\n      }\n   }\n    pub struct MonotonicCounterResource {\n       r: Resource<MonotonicCounterResourceValue>, }\n    impl MonotonicCounterResource {\n       pub closed spec fn id(self) -> Loc {\n          self.r.loc()     }\n       pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n          self.r.value()     }\n       pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToAdvance,         ensures             ({\n                  let (r1, r2) = return_value;\n                  let value = self@->FullRightToAdvance_value;\n                  &&& r1.id() == r2.id() == self.id()                 &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n value }\n )                 &&& r2@ == r1@             }\n  ),     {\n          let value = self@->FullRightToAdvance_value;\n          let v_half = MonotonicCounterResourceValue::HalfRightToAdvance {\n value };\n          let tracked (r1, r2) = self.r.split(v_half, v_half);\n          (Self {\n r: r1 }\n , Self {\n r: r2 }\n )     }\n       pub proof fn increment(tracked &mut self)         requires             old(self)@ is FullRightToAdvance,         ensures             self.id() == old(self).id(),             self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                  value: old(self)@->FullRightToAdvance_value + 1,             }\n  ),     {\n          let v = self@->FullRightToAdvance_value;\n          let r = MonotonicCounterResourceValue::FullRightToAdvance {\n value: v + 1 };\n          update_mut(&mut self.r, r);\n      }\n       pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)         requires             old(self).id() == old(other).id(),             old(self)@ is HalfRightToAdvance,             old(other)@ is HalfRightToAdvance,         ensures             old(self)@ == old(other)@,             self.id() == other.id() == old(self).id(),             other@ == self@,             self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                  value: old(self)@->HalfRightToAdvance_value + 1,             }\n  ),     {\n          self.r.validate_2(&other.r);\n          let v = self@->HalfRightToAdvance_value;\n          let r = MonotonicCounterResourceValue::HalfRightToAdvance {\n value: v + 1 };\n          update_and_redistribute(&mut self.r, &mut other.r, r, r);\n      }\n       pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)         ensures             out@ is LowerBound,             out.id() == self.id(),             out@ == (MonotonicCounterResourceValue::LowerBound {\n  lower_bound: self@.n() }\n  ),     {\n          let v = MonotonicCounterResourceValue::LowerBound {\n lower_bound: self@.n() };\n          let tracked r = copy_duplicable_part(&self.r, v);\n          Self {\n r }\n      }\n   }\n    fn main() {\n   }\n    }\n', ' use vstd::pcm::*;\n        use vstd::pcm_lib::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum MonotonicCounterResourceValue {\n          LowerBound {\n     lower_bound: nat }\n     ,     HalfRightToAdvance {\n     value: nat }\n     ,     FullRightToAdvance {\n     value: nat }\n     ,     Invalid, }\n       impl PCM for MonotonicCounterResourceValue {\n          open spec fn valid(self) -> bool {\n             !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound: lower_bound1 }\n   ,                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound: lower_bound2 }\n   ,             ) => {\n                   let max_lower_bound = if lower_bound1 > lower_bound2 {\n                       lower_bound1                 }\n   else {\n                       lower_bound2                 };\n                   MonotonicCounterResourceValue::LowerBound {\n   lower_bound: max_lower_bound }\n               }\n   ,             (                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n   ,                 MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n   ,             ) => if lower_bound <= value {\n                   MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (                 MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n   ,                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n   ,             ) => if lower_bound <= value {\n                   MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n   ,                 MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n   ,             ) => if lower_bound <= value {\n                   MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (                 MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n   ,                 MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n   ,             ) => if lower_bound <= value {\n                   MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (                 MonotonicCounterResourceValue::HalfRightToAdvance {\n   value: value1 }\n   ,                 MonotonicCounterResourceValue::HalfRightToAdvance {\n   value: value2 }\n   ,             ) => if value1 == value2 {\n                   MonotonicCounterResourceValue::FullRightToAdvance {\n   value: value1 }\n               }\n    else {\n                   MonotonicCounterResourceValue::Invalid \n               }\n   ,             (_, _) => MonotonicCounterResourceValue::Invalid \n   ,         }\n         }\n          open spec fn unit() -> Self {\n             MonotonicCounterResourceValue::LowerBound {\n    lower_bound: 0 }\n         }\n          proof fn closed_under_incl(a: Self, b: Self) {}\n          proof fn commutative(a: Self, b: Self) {}\n          proof fn associative(a: Self, b: Self, c: Self) {}\n          proof fn op_unit(a: Self) {}\n          proof fn unit_valid() {}\n      }\n       impl MonotonicCounterResourceValue {\n          pub open spec fn n(self) -> nat {\n             match self {\n                MonotonicCounterResourceValue::LowerBound {\n   lower_bound }\n    => lower_bound,             MonotonicCounterResourceValue::HalfRightToAdvance {\n   value }\n    => value,             MonotonicCounterResourceValue::FullRightToAdvance {\n   value }\n    => value,             MonotonicCounterResourceValue::Invalid => 0,         }\n         }\n      }\n       pub struct MonotonicCounterResource {\n          r: Resource<MonotonicCounterResourceValue>, }\n       impl MonotonicCounterResource {}\n       fn main() ;\n       }\n', '          use vstd::prelude::*;\n           verus! {\n         fn main() ;\n         }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/pcm/oneshot.rs,284,54,0.19014084507042253,246.83,True,0.9999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'std::result::', 'vstd::pcm::', 'vstd::pcm_lib::', 'vstd::prelude::']",True,,,,,1.0,"//! This file implements one-shot permissions using a custom resource
//! algebra.
//!
//! A one-shot allows an operation to be performed exactly once. If
//! you have two resources each granting half authority to perform it,
//! you can combine them and perform the one-shot. Performing it
//! grants duplicable knowledge that it has been performed.
//!
//! To create a one-shot, call `OneShotResource::alloc()`. This will
//! return a resource granting full authority to perform the created
//! one-shot. You can then call `perform` to perform that one-shot.
//! Here's an example:
//!
//! ```
//! let tracked full = OneShotResource::alloc();
//! proof { full.perform(); }
//! assert(full@ is Complete);
//! ```
//!
//! Often, you will first split the full authority into two halves,
//! each granting half the authority to perform the created one-shot.
//! This way, you can stash one in an invariant. Both halves will have
//! the same `id()`, meaning they belong to the same one-shot
//! instance. For example:
//!
//! ```
//! let tracked full = OneShotResource::alloc();
//! let tracked (mut half1, mut half2) = full.split();
//! assert(half1.id() == half2.id());
//! assert(half1@ is HalfRightToComplete);
//! assert(half2@ is HalfRightToComplete);
//! ```
//!
//! To perform a one-shot using two halves, use
//! `perform_using_two_halves`. This function takes two resources, the
//! first of which must provide half authority to perform the
//! one-shot. On return, the passed-in resources will have both been
//! changed to `Complete`, i.e., knowledge that the one-shot has
//! complete.
//!
//! ```
//! let ghost id = half1.id();
//! proof { half1.perform_using_two_halves(&mut half2); }
//! assert(half1.id() == half2.id() == id);
//! assert(half1@ is Complete);
//! assert(half2@ is Complete);
//! ```
//!
//! Note that only *one* of the two parameters to `perform` has to be
//! `HalfRightToComplete`. This is useful so you can stash half the
//! authority in an invariant and call `perform` even if the invariant
//! predicate allows the stashed permission to change later.
//!
//! Knowledge that the one-shot has completed is freely duplicable
//! because that's the nature of one-shots. If you want to duplicate
//! it, you can call `duplicate`, but you can only call this if you
//! know the permission passed in is `Complete`. Here's an example of
//! its usage:
//!
//! ```
//! let tracked knowledge = half1.duplicate();
//! assert(knowledge.id() == half1.id());
//! assert(knowledge@ is Complete);
//! ```
#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use std::result::*;
use vstd::pcm::*;
use vstd::pcm_lib::*;
use vstd::prelude::*;

verus! {

// A one-shot resource represents one of the following four resources:
//
// `FullRightToComplete` -- the authority to complete the one-shot;
//
// `HalfRightToComplete` -- half of the authority to complete the
// one-shot, which can be combined with another half to make a full
// authority; or
//
// `Complete` -- knowledge that the one-shot has completed.
//
// `Empty` - no permission at all.
pub enum OneShotResourceValue {
    FullRightToComplete,
    HalfRightToComplete,
    Complete,
    Empty,
    Invalid,
}

// To use `OneShotResourceValue` as a resource, we have to implement
// `PCM`, showing how to use it in a resource algebra.
impl PCM for OneShotResourceValue {
    open spec fn valid(self) -> bool {
        !(self is Invalid)
    }

    open spec fn op(self, other: Self) -> Self {
        match (self, other) {
            (OneShotResourceValue::Empty, _) => other,
            (_, OneShotResourceValue::Empty) => self,
            (
                OneShotResourceValue::HalfRightToComplete,
                OneShotResourceValue::HalfRightToComplete,
            ) => OneShotResourceValue::FullRightToComplete {  },
            (
                OneShotResourceValue::Complete,
                OneShotResourceValue::Complete,
            ) => OneShotResourceValue::Complete {  },
            (_, _) => OneShotResourceValue::Invalid {  },
        }
    }

    open spec fn unit() -> Self {
        OneShotResourceValue::Empty {  }
    }

    proof fn closed_under_incl(a: Self, b: Self) {
    }

    proof fn commutative(a: Self, b: Self) {
    }

    proof fn associative(a: Self, b: Self, c: Self) {
    }

    proof fn op_unit(a: Self) {
    }

    proof fn unit_valid() {
    }
}

pub struct OneShotResource {
    r: Resource<OneShotResourceValue>,
}

impl OneShotResource {
    pub closed spec fn id(self) -> Loc {
        self.r.loc()
    }

    pub closed spec fn view(self) -> OneShotResourceValue {
        self.r.value()
    }

    // This function creates a one-shot and returns a resource
    // granting the full authority to perform the created
    // one-shot.
    pub proof fn alloc() -> (tracked resource: Self)
        ensures
            resource@ is FullRightToComplete,
    {
        let v = OneShotResourceValue::FullRightToComplete {  };
        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);
        OneShotResource { r }
    }

    // This function splits full authority to perform a one-shot
    // into two half authorities to perform it.
    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))
        requires
            self@ is FullRightToComplete,
        ensures
            ({
                let (half1, half2) = return_value;
                &&& half1@ is HalfRightToComplete
                &&& half2@ is HalfRightToComplete
                &&& half2.id() == half1.id() == self.id()
            }),
    {
        let half = OneShotResourceValue::HalfRightToComplete {  };
        let tracked (r1, r2) = self.r.split(half, half);
        (OneShotResource { r: r1 }, OneShotResource { r: r2 })
    }

    // This function performs a one-shot given a resource representing
    // full authority to complete the one-shot.
    //
    // Upon return, the passed-in resource will have been transformed
    // into knowledge that the one-shot has been performed.
    pub proof fn perform(tracked &mut self)
        requires
            old(self)@ is FullRightToComplete,
        ensures
            self@ is Complete,
    {
        let v = OneShotResourceValue::Complete {  };
        update_mut(&mut self.r, v);
    }

    // This function performs a one-shot given two resources, the
    // first of which represents an incomplete one-shot (and half the
    // authority needed to perform it). The resources must have the
    // same `id()`, meaning they're talking about the same one-shot.
    //
    // Upon return, the passed-in resources will have both been
    // transformed into knowledge that the one-shot has been
    // performed.
    //
    // The caller of this function only needs to know that `self`
    // provides half authority and that `other` isn't `Empty`. Upon
    // return the caller will learn that *both* the resources had
    // provided half authority at call time. However, those resources
    // were transformed so they don't provide that authority anymore.
    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)
        requires
            old(other).id() == old(self).id(),
            old(self)@ is HalfRightToComplete,
            !(old(other)@ is Empty),
        ensures
            old(other)@ is HalfRightToComplete,
            self@ is Complete,
            other@ is Complete,
            other.id() == self.id() == old(self).id(),
    {
        self.r.validate();
        other.r.validate();
        // A `HalfRightToComplete` doesn't combine validly with a
        // `Complete`, so validating them together proves that
        // `other.r.value()` is `HalfRightToComplete`.
        self.r.validate_2(&other.r);
        assert(other@ is HalfRightToComplete);
        // Knowing they're both `HalfRightToComplete` allows them to
        // be combined and transformed into `Complete` resources.
        let v = OneShotResourceValue::Complete {  };
        update_and_redistribute(&mut self.r, &mut other.r, v, v);
    }

    // This function duplicates a one-shot resource representing
    // knowledge of completion.
    pub proof fn duplicate(tracked &self) -> (tracked other: Self)
        requires
            self@ is Complete,
        ensures
            other.id() == self.id(),
            other@ is Complete,
    {
        let tracked r = duplicate(&self.r);
        Self { r }
    }

    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)
        requires
            other.id() == old(self).id(),
            other@ is Complete,
            !(old(self)@ is Empty),
        ensures
            self.id() == old(self).id(),
            self@ == old(self)@,
            self@ is Complete,
    {
        self.r.validate_2(&other.r);
    }
}

// This example illustrates some uses of the one-shot functions.
fn main() {
    let tracked full = OneShotResource::alloc();
    proof {
        full.perform();
    }
    assert(full@ is Complete);
    let tracked different_oneshot = OneShotResource::alloc();
    let tracked (mut half1, mut half2) = different_oneshot.split();
    let ghost id = half1.id();
    assert(half1.id() == half2.id());
    assert(half1@ is HalfRightToComplete);
    assert(half2@ is HalfRightToComplete);
    proof {
        half1.perform_using_two_halves(&mut half2);
    }
    assert(half1.id() == half2.id() == id);
    assert(half1@ is Complete);
    assert(half2@ is Complete);
    let tracked knowledge = half1.duplicate();
    assert(knowledge.id() == half1.id() == id);
    assert(knowledge@ is Complete);
}

} // verus!
"," use vstd::pcm::*;
      use vstd::prelude::*;
      verus! {
     pub enum OneShotResourceValue {
        FullRightToComplete,     HalfRightToComplete,     Complete,     Empty,     Invalid, }
     impl PCM for OneShotResourceValue {
        open spec fn valid(self) -> bool {
           !(self is Invalid)     }
        open spec fn op(self, other: Self) -> Self {
           match (self, other) {
              (OneShotResourceValue::Empty, _) => other,             (_, OneShotResourceValue::Empty) => self,             (                 OneShotResourceValue::HalfRightToComplete,                 OneShotResourceValue::HalfRightToComplete,             ) => OneShotResourceValue::FullRightToComplete {
  }
 ,             (_, _) => OneShotResourceValue::Invalid {
  }
 ,         }
       }
        open spec fn unit() -> Self {
           OneShotResourceValue::Empty {
   }
       }
        proof fn closed_under_incl(a: Self, b: Self) {
       }
        proof fn commutative(a: Self, b: Self) {
       }
        proof fn associative(a: Self, b: Self, c: Self) {
       }
        proof fn op_unit(a: Self) {
       }
        proof fn unit_valid() {
       }
    }
     pub struct OneShotResource {
        r: Resource<OneShotResourceValue>, }
     impl OneShotResource {
        pub closed spec fn id(self) -> Loc {
           self.r.loc()     }
        pub closed spec fn view(self) -> OneShotResourceValue {
           self.r.value()     }
        pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToComplete,         ensures             ({
                   let (half1, half2) = return_value;
                   &&& half1@ is HalfRightToComplete                 &&& half2@ is HalfRightToComplete                 &&& half2.id() == half1.id() == self.id()             }
   ),     {
           let half = OneShotResourceValue::HalfRightToComplete {
   };
           let tracked (r1, r2) = self.r.split(half, half);
           (OneShotResource {
  r: r1 }
  , OneShotResource {
  r: r2 }
  )     }
    }
     fn main() {
    }
     }
","[""//! This file implements one-shot permissions using a custom resource\n//! algebra.\n//!\n//! A one-shot allows an operation to be performed exactly once. If\n//! you have two resources each granting half authority to perform it,\n//! you can combine them and perform the one-shot. Performing it\n//! grants duplicable knowledge that it has been performed.\n//!\n//! To create a one-shot, call `OneShotResource::alloc()`. This will\n//! return a resource granting full authority to perform the created\n//! one-shot. You can then call `perform` to perform that one-shot.\n//! Here's an example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! proof { full.perform(); }\n//! assert(full@ is Complete);\n//! ```\n//!\n//! Often, you will first split the full authority into two halves,\n//! each granting half the authority to perform the created one-shot.\n//! This way, you can stash one in an invariant. Both halves will have\n//! the same `id()`, meaning they belong to the same one-shot\n//! instance. For example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@ is HalfRightToComplete);\n//! assert(half2@ is HalfRightToComplete);\n//! ```\n//!\n//! To perform a one-shot using two halves, use\n//! `perform_using_two_halves`. This function takes two resources, the\n//! first of which must provide half authority to perform the\n//! one-shot. On return, the passed-in resources will have both been\n//! changed to `Complete`, i.e., knowledge that the one-shot has\n//! complete.\n//!\n//! ```\n//! let ghost id = half1.id();\n//! proof { half1.perform_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id() == id);\n//! assert(half1@ is Complete);\n//! assert(half2@ is Complete);\n//! ```\n//!\n//! Note that only *one* of the two parameters to `perform` has to be\n//! `HalfRightToComplete`. This is useful so you can stash half the\n//! authority in an invariant and call `perform` even if the invariant\n//! predicate allows the stashed permission to change later.\n//!\n//! Knowledge that the one-shot has completed is freely duplicable\n//! because that's the nature of one-shots. If you want to duplicate\n//! it, you can call `duplicate`, but you can only call this if you\n//! know the permission passed in is `Complete`. Here's an example of\n//! its usage:\n//!\n//! ```\n//! let tracked knowledge = half1.duplicate();\n//! assert(knowledge.id() == half1.id());\n//! assert(knowledge@ is Complete);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A one-shot resource represents one of the following four resources:\n//\n// `FullRightToComplete` -- the authority to complete the one-shot;\n//\n// `HalfRightToComplete` -- half of the authority to complete the\n// one-shot, which can be combined with another half to make a full\n// authority; or\n//\n// `Complete` -- knowledge that the one-shot has completed.\n//\n// `Empty` - no permission at all.\npub enum OneShotResourceValue {\n    FullRightToComplete,\n    HalfRightToComplete,\n    Complete,\n    Empty,\n    Invalid,\n}\n\n// To use `OneShotResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for OneShotResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (OneShotResourceValue::Empty, _) => other,\n            (_, OneShotResourceValue::Empty) => self,\n            (\n                OneShotResourceValue::HalfRightToComplete,\n                OneShotResourceValue::HalfRightToComplete,\n            ) => OneShotResourceValue::FullRightToComplete {  },\n            (\n                OneShotResourceValue::Complete,\n                OneShotResourceValue::Complete,\n            ) => OneShotResourceValue::Complete {  },\n            (_, _) => OneShotResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        OneShotResourceValue::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct OneShotResource {\n    r: Resource<OneShotResourceValue>,\n}\n\nimpl OneShotResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> OneShotResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a one-shot and returns a resource\n    // granting the full authority to perform the created\n    // one-shot.\n    pub proof fn alloc() -> (tracked resource: Self)\n        ensures\n            resource@ is FullRightToComplete,\n    {\n        let v = OneShotResourceValue::FullRightToComplete {  };\n        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);\n        OneShotResource { r }\n    }\n\n    // This function splits full authority to perform a one-shot\n    // into two half authorities to perform it.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToComplete,\n        ensures\n            ({\n                let (half1, half2) = return_value;\n                &&& half1@ is HalfRightToComplete\n                &&& half2@ is HalfRightToComplete\n                &&& half2.id() == half1.id() == self.id()\n            }),\n    {\n        let half = OneShotResourceValue::HalfRightToComplete {  };\n        let tracked (r1, r2) = self.r.split(half, half);\n        (OneShotResource { r: r1 }, OneShotResource { r: r2 })\n    }\n\n    // This function performs a one-shot given a resource representing\n    // full authority to complete the one-shot.\n    //\n    // Upon return, the passed-in resource will have been transformed\n    // into knowledge that the one-shot has been performed.\n    pub proof fn perform(tracked &mut self)\n        requires\n            old(self)@ is FullRightToComplete,\n        ensures\n            self@ is Complete,\n    {\n        let v = OneShotResourceValue::Complete {  };\n        update_mut(&mut self.r, v);\n    }\n\n    // This function performs a one-shot given two resources, the\n    // first of which represents an incomplete one-shot (and half the\n    // authority needed to perform it). The resources must have the\n    // same `id()`, meaning they're talking about the same one-shot.\n    //\n    // Upon return, the passed-in resources will have both been\n    // transformed into knowledge that the one-shot has been\n    // performed.\n    //\n    // The caller of this function only needs to know that `self`\n    // provides half authority and that `other` isn't `Empty`. Upon\n    // return the caller will learn that *both* the resources had\n    // provided half authority at call time. However, those resources\n    // were transformed so they don't provide that authority anymore.\n    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(other).id() == old(self).id(),\n            old(self)@ is HalfRightToComplete,\n            !(old(other)@ is Empty),\n        ensures\n            old(other)@ is HalfRightToComplete,\n            self@ is Complete,\n            other@ is Complete,\n            other.id() == self.id() == old(self).id(),\n    {\n        self.r.validate();\n        other.r.validate();\n        // A `HalfRightToComplete` doesn't combine validly with a\n        // `Complete`, so validating them together proves that\n        // `other.r.value()` is `HalfRightToComplete`.\n        self.r.validate_2(&other.r);\n        assert(other@ is HalfRightToComplete);\n        // Knowing they're both `HalfRightToComplete` allows them to\n        // be combined and transformed into `Complete` resources.\n        let v = OneShotResourceValue::Complete {  };\n        update_and_redistribute(&mut self.r, &mut other.r, v, v);\n    }\n\n    // This function duplicates a one-shot resource representing\n    // knowledge of completion.\n    pub proof fn duplicate(tracked &self) -> (tracked other: Self)\n        requires\n            self@ is Complete,\n        ensures\n            other.id() == self.id(),\n            other@ is Complete,\n    {\n        let tracked r = duplicate(&self.r);\n        Self { r }\n    }\n\n    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)\n        requires\n            other.id() == old(self).id(),\n            other@ is Complete,\n            !(old(self)@ is Empty),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ is Complete,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\n// This example illustrates some uses of the one-shot functions.\nfn main() {\n    let tracked full = OneShotResource::alloc();\n    proof {\n        full.perform();\n    }\n    assert(full@ is Complete);\n    let tracked different_oneshot = OneShotResource::alloc();\n    let tracked (mut half1, mut half2) = different_oneshot.split();\n    let ghost id = half1.id();\n    assert(half1.id() == half2.id());\n    assert(half1@ is HalfRightToComplete);\n    assert(half2@ is HalfRightToComplete);\n    proof {\n        half1.perform_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@ is Complete);\n    assert(half2@ is Complete);\n    let tracked knowledge = half1.duplicate();\n    assert(knowledge.id() == half1.id() == id);\n    assert(knowledge@ is Complete);\n}\n\n} // verus!\n"", 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use vstd::pcm::*;\n      use vstd::prelude::*;\n      verus! {\n     pub enum OneShotResourceValue {\n        FullRightToComplete,     HalfRightToComplete,     Complete,     Empty,     Invalid, }\n     impl PCM for OneShotResourceValue {\n        open spec fn valid(self) -> bool {\n           !(self is Invalid)     }\n        open spec fn op(self, other: Self) -> Self {\n           match (self, other) {\n              (OneShotResourceValue::Empty, _) => other,             (_, OneShotResourceValue::Empty) => self,             (                 OneShotResourceValue::HalfRightToComplete,                 OneShotResourceValue::HalfRightToComplete,             ) => OneShotResourceValue::FullRightToComplete {\n  }\n ,             (_, _) => OneShotResourceValue::Invalid {\n  }\n ,         }\n       }\n        open spec fn unit() -> Self {\n           OneShotResourceValue::Empty {\n   }\n       }\n        proof fn closed_under_incl(a: Self, b: Self) {\n       }\n        proof fn commutative(a: Self, b: Self) {\n       }\n        proof fn associative(a: Self, b: Self, c: Self) {\n       }\n        proof fn op_unit(a: Self) {\n       }\n        proof fn unit_valid() {\n       }\n    }\n     pub struct OneShotResource {\n        r: Resource<OneShotResourceValue>, }\n     impl OneShotResource {\n        pub closed spec fn id(self) -> Loc {\n           self.r.loc()     }\n        pub closed spec fn view(self) -> OneShotResourceValue {\n           self.r.value()     }\n        pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToComplete,         ensures             ({\n                   let (half1, half2) = return_value;\n                   &&& half1@ is HalfRightToComplete                 &&& half2@ is HalfRightToComplete                 &&& half2.id() == half1.id() == self.id()             }\n   ),     {\n           let half = OneShotResourceValue::HalfRightToComplete {\n   };\n           let tracked (r1, r2) = self.r.split(half, half);\n           (OneShotResource {\n  r: r1 }\n  , OneShotResource {\n  r: r2 }\n  )     }\n    }\n     fn main() {\n    }\n     }\n', ' use vstd::pcm::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum OneShotResourceValue {\n          FullRightToComplete,     HalfRightToComplete,     Complete,     Empty,     Invalid, }\n       impl PCM for OneShotResourceValue {\n          open spec fn valid(self) -> bool {\n             !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (OneShotResourceValue::Empty, _) => other,             (_, OneShotResourceValue::Empty) => self,             (                 OneShotResourceValue::HalfRightToComplete,                 OneShotResourceValue::HalfRightToComplete,             ) => OneShotResourceValue::FullRightToComplete \n   ,             (_, _) => OneShotResourceValue::Invalid \n   ,         }\n         }\n          open spec fn unit() -> Self {\n             OneShotResourceValue::Empty \n         }\n          proof fn closed_under_incl(a: Self, b: Self) {\n         }\n          proof fn commutative(a: Self, b: Self) {\n         }\n          proof fn associative(a: Self, b: Self, c: Self) {\n         }\n          proof fn op_unit(a: Self) {\n         }\n          proof fn unit_valid() {\n         }\n      }\n       pub struct OneShotResource {\n          r: Resource<OneShotResourceValue>, }\n       impl OneShotResource {\n          pub closed spec fn id(self) -> Loc {\n             self.r.loc()     }\n          pub closed spec fn view(self) -> OneShotResourceValue {\n             self.r.value()     }\n          pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))         requires             self@ is FullRightToComplete,         ensures             ({\n                     let (half1, half2) = return_value;\n                     &&& half1@ is HalfRightToComplete                 &&& half2@ is HalfRightToComplete                 &&& half2.id() == half1.id() == self.id()             }\n     ),     {\n             let half = OneShotResourceValue::HalfRightToComplete ;\n             let tracked (r1, r2) = self.r.split(half, half);\n             (OneShotResource {\n    r: r1 }\n    , OneShotResource {\n    r: r2 }\n    )     }\n      }\n       fn main() ;\n       }\n', ' use vstd::pcm::*;\n        use vstd::prelude::*;\n        verus! {\n       pub enum OneShotResourceValue {\n          FullRightToComplete,     HalfRightToComplete,     Complete,     Empty,     Invalid, }\n       impl PCM for OneShotResourceValue {\n          open spec fn valid(self) -> bool {\n             !(self is Invalid)     }\n          open spec fn op(self, other: Self) -> Self {\n             match (self, other) {\n                (OneShotResourceValue::Empty, _) => other,             (_, OneShotResourceValue::Empty) => self,             (                 OneShotResourceValue::HalfRightToComplete,                 OneShotResourceValue::HalfRightToComplete,             ) => OneShotResourceValue::FullRightToComplete \n   ,             (_, _) => OneShotResourceValue::Invalid \n   ,         }\n         }\n          open spec fn unit() -> Self {\n             OneShotResourceValue::Empty \n         }\n          proof fn closed_under_incl(a: Self, b: Self) {}\n          proof fn commutative(a: Self, b: Self) {}\n          proof fn associative(a: Self, b: Self, c: Self) {}\n          proof fn op_unit(a: Self) {}\n          proof fn unit_valid() {}\n      }\n       pub struct OneShotResource {\n          r: Resource<OneShotResourceValue>, }\n       impl OneShotResource {}\n       fn main() ;\n       }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/power_of_2.rs,212,212,1.0,156.526,True,0.85,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,2.0,4.0,"// Some of the lemmas are ported from the following:
// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power2.dfy
// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power.dfy
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

#[verifier::bit_vector]
proof fn left_shift_by_one(bv: u32, e: u32)
    requires
        e > 0,
        e <= 32,
    ensures
        bv << e == (bv << sub(e, 1)) << 1u32,
    decreases e,
{
    // REVIEW:                 ^^^^^^^^^^ expected `u32`, found struct `verus_builtin::int`
    // get this error when updated to new syntax. Type casting (i.e. `(e - 1u32) as u32`) does not make this error disappear
}

#[verifier::bit_vector]
proof fn left_shift_by_one_is_mul2(bv: u32, e: u32)
    requires
        e > 0,
        e <= 32,
        bv << e == (bv << sub(e, 1)) << 1,
    ensures
        (bv << e) == mul(2, bv << sub(e, 1)),
{
}

spec fn pow2(e: nat) -> nat
    decreases (e),
{
    if e == 0 {
        1
    } else {
        2 * pow2((e - 1) as nat)
    }
}

proof fn lemma_pow2_0()
    ensures
        pow2(0) == 1,
{
}

proof fn lemma_pow2_unfold3(e: nat)
    requires
        e > 3,
    ensures
        pow2(e) == pow2((e - 3) as nat) * 8,
{
    reveal_with_fuel(pow2, 3);
}

// (2^e - 1) / 2 = 2^(e - 1) - 1
proof fn lemma_pow2_make_div(e: nat)
    requires
        e > 0,
    ensures
        (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,
    decreases e,
{
    if e == 1 {
    } else {
        lemma_pow2_make_div((e - 1) as nat)
    }
}

proof fn lemma_pow2_2e(e: nat)
    requires
        e > 0,
    ensures
        (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),
    decreases e,
{
    reveal_with_fuel(pow2, 3);
    if e == 1 {
        assert(pow2(2) == 4);
    } else {
        lemma_pow2_2e((e - 1) as nat)
    }
}

#[verifier::nonlinear]
proof fn lemma_pow2_two_e(e: nat)
    requires
        e >= 0,
    ensures
        pow2(e) * pow2(e) == pow2(2 * e),
    decreases e,
{
    if e != 0 {
        lemma_pow2_two_e((e - 1) as nat);
        lemma_pow2_2e(e);
    }
}

proof fn lemma_pow2_increase(e: nat)
    requires
        e > 0,
    ensures
        pow2(e) > pow2((e - 1) as nat),
    decreases e,
{
    if e == 1 {
    } else {
        lemma_pow2_increase((e - 1) as nat);
    }
}

#[verifier::nonlinear]
proof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)
    requires
        x < y,
    ensures
        z * x <= z * y,
{
}

proof fn left_shift_is_pow2(bv: u32, e: u32)
    requires
        e <= 32,
        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),
    ensures
        (bv << e) as nat == (bv as nat) * pow2(e as nat),
    decreases e,
{
    if e == 0 {
        // assert(bv << 0 == bv * 1u32) by(bit_vector);
        // REVIEW:           ^^^^^^^^^
        //        error: cannot use bit-vector arithmetic on type Int(Int)
        assume(bv << 0 == bv * 1);
        assert((bv << 0) as nat == (bv as nat) * pow2(0)) by (nonlinear_arith)
            requires
                pow2(0) == 1,
                bv << 0 == bv * 1,
        {}
    } else {
        lemma_pow2_increase(e as nat);
        // assert(pow2((e-1) as nat) < pow2(e as nat));
        lemma_mul_upper_bound(pow2((e - 1) as nat), pow2(e as nat), bv as nat);
        // assert((bv as nat) * pow2( (e-1) as nat) <= (bv as nat) * pow2(e as nat));
        // assert((bv as nat) * pow2( (e-1) as nat) < (0x1_0000_0000 as nat));
        left_shift_is_pow2(bv, (e - 1) as u32);
        // assert( (bv << (e-1) as u32) as nat == (bv as nat) * pow2((e-1) as nat));        // we get this from above recursive call
        // assert(bv == bv as nat);
        assert((bv as nat) * pow2((e - 1) as nat) == bv * pow2((e - 1) as nat)) by (nonlinear_arith)
            requires
                (bv == bv as nat),
        {}// assert((bv << (e-1) as u32) as nat == bv* pow2((e-1) as nat));
        // need the above nonlinear fact to make this pass

        assert(pow2(e as nat) == 2 * pow2((e - 1) as nat)) by {
            reveal_with_fuel(pow2, 1);
        }
        assert((bv as nat) * pow2(e as nat) == (bv as nat) * 2 * pow2((e - 1) as nat))
            by (nonlinear_arith)
            requires
                e > 0,
                pow2(e as nat) == 2 * pow2((e - 1) as nat),
                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),
                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),
        {}
        assert((2 * (bv << ((e - 1) as u32))) as nat == 2 * ((bv << ((e - 1) as u32)) as nat))
            by (nonlinear_arith)
            requires
                e > 0,
        {}
        left_shift_by_one(bv, e);
        // assert( (bv << e) == (bv << ((e-1) as u32)) << 1);
        left_shift_by_one_is_mul2(bv, e);
        // cannot get the `ensures` clause from this lemma directly
        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't
        assert(bv << ((e - 1) as u32) < 0x8000_0000) by (nonlinear_arith)
            requires
                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),
                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),
                pow2(e as nat) == 2 * pow2((e - 1) as nat),
        {
            // assert( (bv as nat) * pow2((e-1) as nat) * 2 == (bv as nat) * pow2(e as nat));
            // assert( (bv as nat) * pow2((e-1) as nat) < 0x8000_0000);
            // assert(bv * pow2((e-1) as nat) < 0x8000_0000);
        }
        assert(2 * (bv << ((e - 1) as u32)) < 0x1_0000_0000) by (nonlinear_arith)
            requires
                bv << ((e - 1) as u32) < 0x8000_0000,
        {}
        // assert( (bv << e)  == 2 * (bv << ((e-1) as u32)));

        assert((bv << e) as nat == (bv as nat) * pow2(e as nat)) by (nonlinear_arith)
            requires
                e > 0,
                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),
                (bv << e) as nat == 2 * (bv << ((e - 1) as u32)) as nat,
                pow2(e as nat) == 2 * pow2((e - 1) as nat),
        {
            assert((bv << e) as nat == 2 * ((bv << ((e - 1) as u32)) as nat));
            assert(2 * ((bv << ((e - 1) as u32)) as nat) == (bv as nat) * 2 * pow2((e - 1) as nat));
            assert((bv as nat) * 2 * pow2((e - 1) as nat) == (bv as nat) * pow2(e as nat));
        }
        // assert((bv << e) as nat == (bv as nat) * pow2(e as nat));

    }
}

} // verus!
fn main() {}
","// Some of the lemmas are ported from the following:
// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power2.dfy
// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power.dfy
#[allow(unused_imports)]
use verus_builtin::*;
#[allow(unused_imports)]
use verus_builtin_macros::*;

verus! {

#[verifier::bit_vector]
proof fn left_shift_by_one(bv: u32, e: u32)
    requires
        e > 0,
        e <= 32,
    ensures
        bv << e == (bv << sub(e, 1)) << 1u32,
    decreases e,
{
    // REVIEW:                 ^^^^^^^^^^ expected `u32`, found struct `verus_builtin::int`
    // get this error when updated to new syntax. Type casting (i.e. `(e - 1u32) as u32`) does not make this error disappear
}

#[verifier::bit_vector]
proof fn left_shift_by_one_is_mul2(bv: u32, e: u32)
    requires
        e > 0,
        e <= 32,
        bv << e == (bv << sub(e, 1)) << 1,
    ensures
        (bv << e) == mul(2, bv << sub(e, 1)),
{
}

spec fn pow2(e: nat) -> nat
    decreases (e),
{
    if e == 0 {
        1
    } else {
        2 * pow2((e - 1) as nat)
    }
}

proof fn lemma_pow2_0()
    ensures
        pow2(0) == 1,
{
}

proof fn lemma_pow2_unfold3(e: nat)
    requires
        e > 3,
    ensures
        pow2(e) == pow2((e - 3) as nat) * 8,
{
    reveal_with_fuel(pow2, 3);
}

// (2^e - 1) / 2 = 2^(e - 1) - 1
proof fn lemma_pow2_make_div(e: nat)
    requires
        e > 0,
    ensures
        (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,
    decreases e,
{
    if e == 1 {
    } else {
        lemma_pow2_make_div((e - 1) as nat)
    }
}

proof fn lemma_pow2_2e(e: nat)
    requires
        e > 0,
    ensures
        (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),
    decreases e,
{
    reveal_with_fuel(pow2, 3);
    if e == 1 {
        assert(pow2(2) == 4);
    } else {
        lemma_pow2_2e((e - 1) as nat)
    }
}

#[verifier::nonlinear]
proof fn lemma_pow2_two_e(e: nat)
    requires
        e >= 0,
    ensures
        pow2(e) * pow2(e) == pow2(2 * e),
    decreases e,
{
    if e != 0 {
        lemma_pow2_two_e((e - 1) as nat);
        lemma_pow2_2e(e);
    }
}

proof fn lemma_pow2_increase(e: nat)
    requires
        e > 0,
    ensures
        pow2(e) > pow2((e - 1) as nat),
    decreases e,
{
    if e == 1 {
    } else {
        lemma_pow2_increase((e - 1) as nat);
    }
}

#[verifier::nonlinear]
proof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)
    requires
        x < y,
    ensures
        z * x <= z * y,
{
}

proof fn left_shift_is_pow2(bv: u32, e: u32)
    requires
        e <= 32,
        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),
    ensures
        (bv << e) as nat == (bv as nat) * pow2(e as nat),
    decreases e,
{
    if e == 0 {
        // assert(bv << 0 == bv * 1u32) by(bit_vector);
        // REVIEW:           ^^^^^^^^^
        //        error: cannot use bit-vector arithmetic on type Int(Int)
        assume(bv << 0 == bv * 1);
        assert((bv << 0) as nat == (bv as nat) * pow2(0)) by (nonlinear_arith)
            requires
                pow2(0) == 1,
                bv << 0 == bv * 1,
        {}
    } else {
        lemma_pow2_increase(e as nat);
        // assert(pow2((e-1) as nat) < pow2(e as nat));
        lemma_mul_upper_bound(pow2((e - 1) as nat), pow2(e as nat), bv as nat);
        // assert((bv as nat) * pow2( (e-1) as nat) <= (bv as nat) * pow2(e as nat));
        // assert((bv as nat) * pow2( (e-1) as nat) < (0x1_0000_0000 as nat));
        left_shift_is_pow2(bv, (e - 1) as u32);
        // assert( (bv << (e-1) as u32) as nat == (bv as nat) * pow2((e-1) as nat));        // we get this from above recursive call
        // assert(bv == bv as nat);
        assert((bv as nat) * pow2((e - 1) as nat) == bv * pow2((e - 1) as nat)) by (nonlinear_arith)
            requires
                (bv == bv as nat),
        {}// assert((bv << (e-1) as u32) as nat == bv* pow2((e-1) as nat));
        // need the above nonlinear fact to make this pass

        assert(pow2(e as nat) == 2 * pow2((e - 1) as nat)) by {
            reveal_with_fuel(pow2, 1);
        }
        assert((bv as nat) * pow2(e as nat) == (bv as nat) * 2 * pow2((e - 1) as nat))
            by (nonlinear_arith)
            requires
                e > 0,
                pow2(e as nat) == 2 * pow2((e - 1) as nat),
                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),
                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),
        {}
        assert((2 * (bv << ((e - 1) as u32))) as nat == 2 * ((bv << ((e - 1) as u32)) as nat))
            by (nonlinear_arith)
            requires
                e > 0,
        {}
        left_shift_by_one(bv, e);
        // assert( (bv << e) == (bv << ((e-1) as u32)) << 1);
        left_shift_by_one_is_mul2(bv, e);
        // cannot get the `ensures` clause from this lemma directly
        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't
        assert(bv << ((e - 1) as u32) < 0x8000_0000) by (nonlinear_arith)
            requires
                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),
                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),
                pow2(e as nat) == 2 * pow2((e - 1) as nat),
        {
            // assert( (bv as nat) * pow2((e-1) as nat) * 2 == (bv as nat) * pow2(e as nat));
            // assert( (bv as nat) * pow2((e-1) as nat) < 0x8000_0000);
            // assert(bv * pow2((e-1) as nat) < 0x8000_0000);
        }
        assert(2 * (bv << ((e - 1) as u32)) < 0x1_0000_0000) by (nonlinear_arith)
            requires
                bv << ((e - 1) as u32) < 0x8000_0000,
        {}
        // assert( (bv << e)  == 2 * (bv << ((e-1) as u32)));

        assert((bv << e) as nat == (bv as nat) * pow2(e as nat)) by (nonlinear_arith)
            requires
                e > 0,
                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),
                (bv << e) as nat == 2 * (bv << ((e - 1) as u32)) as nat,
                pow2(e as nat) == 2 * pow2((e - 1) as nat),
        {
            assert((bv << e) as nat == 2 * ((bv << ((e - 1) as u32)) as nat));
            assert(2 * ((bv << ((e - 1) as u32)) as nat) == (bv as nat) * 2 * pow2((e - 1) as nat));
            assert((bv as nat) * 2 * pow2((e - 1) as nat) == (bv as nat) * pow2(e as nat));
        }
        // assert((bv << e) as nat == (bv as nat) * pow2(e as nat));

    }
}

} // verus!
fn main() {}
","[""// Some of the lemmas are ported from the following:\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power2.dfy\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power.dfy\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n    ensures\n        bv << e == (bv << sub(e, 1)) << 1u32,\n    decreases e,\n{\n    // REVIEW:                 ^^^^^^^^^^ expected `u32`, found struct `verus_builtin::int`\n    // get this error when updated to new syntax. Type casting (i.e. `(e - 1u32) as u32`) does not make this error disappear\n}\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one_is_mul2(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n        bv << e == (bv << sub(e, 1)) << 1,\n    ensures\n        (bv << e) == mul(2, bv << sub(e, 1)),\n{\n}\n\nspec fn pow2(e: nat) -> nat\n    decreases (e),\n{\n    if e == 0 {\n        1\n    } else {\n        2 * pow2((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_0()\n    ensures\n        pow2(0) == 1,\n{\n}\n\nproof fn lemma_pow2_unfold3(e: nat)\n    requires\n        e > 3,\n    ensures\n        pow2(e) == pow2((e - 3) as nat) * 8,\n{\n    reveal_with_fuel(pow2, 3);\n}\n\n// (2^e - 1) / 2 = 2^(e - 1) - 1\nproof fn lemma_pow2_make_div(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_make_div((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_2e(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),\n    decreases e,\n{\n    reveal_with_fuel(pow2, 3);\n    if e == 1 {\n        assert(pow2(2) == 4);\n    } else {\n        lemma_pow2_2e((e - 1) as nat)\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_pow2_two_e(e: nat)\n    requires\n        e >= 0,\n    ensures\n        pow2(e) * pow2(e) == pow2(2 * e),\n    decreases e,\n{\n    if e != 0 {\n        lemma_pow2_two_e((e - 1) as nat);\n        lemma_pow2_2e(e);\n    }\n}\n\nproof fn lemma_pow2_increase(e: nat)\n    requires\n        e > 0,\n    ensures\n        pow2(e) > pow2((e - 1) as nat),\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_increase((e - 1) as nat);\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)\n    requires\n        x < y,\n    ensures\n        z * x <= z * y,\n{\n}\n\nproof fn left_shift_is_pow2(bv: u32, e: u32)\n    requires\n        e <= 32,\n        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n    ensures\n        (bv << e) as nat == (bv as nat) * pow2(e as nat),\n    decreases e,\n{\n    if e == 0 {\n        // assert(bv << 0 == bv * 1u32) by(bit_vector);\n        // REVIEW:           ^^^^^^^^^\n        //        error: cannot use bit-vector arithmetic on type Int(Int)\n        assume(bv << 0 == bv * 1);\n        assert((bv << 0) as nat == (bv as nat) * pow2(0)) by (nonlinear_arith)\n            requires\n                pow2(0) == 1,\n                bv << 0 == bv * 1,\n        {}\n    } else {\n        lemma_pow2_increase(e as nat);\n        // assert(pow2((e-1) as nat) < pow2(e as nat));\n        lemma_mul_upper_bound(pow2((e - 1) as nat), pow2(e as nat), bv as nat);\n        // assert((bv as nat) * pow2( (e-1) as nat) <= (bv as nat) * pow2(e as nat));\n        // assert((bv as nat) * pow2( (e-1) as nat) < (0x1_0000_0000 as nat));\n        left_shift_is_pow2(bv, (e - 1) as u32);\n        // assert( (bv << (e-1) as u32) as nat == (bv as nat) * pow2((e-1) as nat));        // we get this from above recursive call\n        // assert(bv == bv as nat);\n        assert((bv as nat) * pow2((e - 1) as nat) == bv * pow2((e - 1) as nat)) by (nonlinear_arith)\n            requires\n                (bv == bv as nat),\n        {}// assert((bv << (e-1) as u32) as nat == bv* pow2((e-1) as nat));\n        // need the above nonlinear fact to make this pass\n\n        assert(pow2(e as nat) == 2 * pow2((e - 1) as nat)) by {\n            reveal_with_fuel(pow2, 1);\n        }\n        assert((bv as nat) * pow2(e as nat) == (bv as nat) * 2 * pow2((e - 1) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n        {}\n        assert((2 * (bv << ((e - 1) as u32))) as nat == 2 * ((bv << ((e - 1) as u32)) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n        {}\n        left_shift_by_one(bv, e);\n        // assert( (bv << e) == (bv << ((e-1) as u32)) << 1);\n        left_shift_by_one_is_mul2(bv, e);\n        // cannot get the `ensures` clause from this lemma directly\n        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't\n        assert(bv << ((e - 1) as u32) < 0x8000_0000) by (nonlinear_arith)\n            requires\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            // assert( (bv as nat) * pow2((e-1) as nat) * 2 == (bv as nat) * pow2(e as nat));\n            // assert( (bv as nat) * pow2((e-1) as nat) < 0x8000_0000);\n            // assert(bv * pow2((e-1) as nat) < 0x8000_0000);\n        }\n        assert(2 * (bv << ((e - 1) as u32)) < 0x1_0000_0000) by (nonlinear_arith)\n            requires\n                bv << ((e - 1) as u32) < 0x8000_0000,\n        {}\n        // assert( (bv << e)  == 2 * (bv << ((e-1) as u32)));\n\n        assert((bv << e) as nat == (bv as nat) * pow2(e as nat)) by (nonlinear_arith)\n            requires\n                e > 0,\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv << e) as nat == 2 * (bv << ((e - 1) as u32)) as nat,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            assert((bv << e) as nat == 2 * ((bv << ((e - 1) as u32)) as nat));\n            assert(2 * ((bv << ((e - 1) as u32)) as nat) == (bv as nat) * 2 * pow2((e - 1) as nat));\n            assert((bv as nat) * 2 * pow2((e - 1) as nat) == (bv as nat) * pow2(e as nat));\n        }\n        // assert((bv << e) as nat == (bv as nat) * pow2(e as nat));\n\n    }\n}\n\n} // verus!\nfn main() {}\n"", 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n       use verus_builtin_macros::*;\n        verus! {}\n         fn main() {}\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/proposal-rw2022.rs,75,75,1.0,152.552,True,0.9999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,True,,,"// rust_verify/tests/example.rs
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::*;

verus! {

spec fn fibo(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibo((n - 2) as nat) + fibo((n - 1) as nat)
    }
}

proof fn lemma_fibo_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fibo(i) <= fibo(j),
    decreases j - i,
{
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fibo_is_monotonic(i, (j - 1) as nat);
        lemma_fibo_is_monotonic(i, (j - 2) as nat);
    }
}

spec fn fibo_fits_u64(n: nat) -> bool {
    fibo(n) <= 0xffff_ffff_ffff_ffff
}

exec fn fibo_impl(n: u64) -> (result: u64)
    requires
        fibo_fits_u64(n as nat),
    ensures
        result == fibo(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fibo_fits_u64(n as nat),
            fibo_fits_u64(i as nat),
            cur == fibo(i as nat),
            prev == fibo((i - 1) as nat),
    {
        i = i + 1;
        proof {
            lemma_fibo_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::*;

verus! {

spec fn fibo(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibo((n - 2) as nat) + fibo((n - 1) as nat)
    }
}

proof fn lemma_fibo_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fibo(i) <= fibo(j),
    decreases j - i,
{
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fibo_is_monotonic(i, (j - 1) as nat);
        lemma_fibo_is_monotonic(i, (j - 2) as nat);
    }
}

spec fn fibo_fits_u64(n: nat) -> bool {
    fibo(n) <= 0xffff_ffff_ffff_ffff
}

exec fn fibo_impl(n: u64) -> (result: u64)
    requires
        fibo_fits_u64(n as nat),
    ensures
        result == fibo(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fibo_fits_u64(n as nat),
            fibo_fits_u64(i as nat),
            cur == fibo(i as nat),
            prev == fibo((i - 1) as nat),
    {
        i = i + 1;
        proof {
            lemma_fibo_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}

fn main() {
}

} // verus!
","['// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/quantifiers.rs,100,12,0.12,185.856,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;

fn main() {}

verus! {

spec fn f1(i: int, j: int) -> bool {
    i <= j
}

spec fn f2(i: int, j: int) -> bool {
    i >= j
}

spec fn g1(i: int) -> int {
    i + 1
}

spec fn g2(i: int) -> int {
    i + 2
}

spec fn g3(i: int) -> int {
    i + 3
}

// Automatically chosen triggers
fn test_auto() {
    // :pattern ((f1. i@ j@))
    assert(forall|i: int, j: int| i == j ==> f1(i, j));
    // :pattern ((f1. i@ j@))
    assert(forall|i: int, j: int| i == j ==> f1(i, j) && f1(i, j));
    // :pattern ((f1. j@ i@))
    // :pattern ((f1. i@ j@))
    assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, i));
    // :pattern ((f1. i@ j@))
    // note: f1(i, j) is preferred over splitting i, j among g1(i), g2(j)
    assert(forall|i: int, j: int| f1(i, j) ==> g1(i) <= g2(j));
    // :pattern ((g1. i@))
    // note: g1(i) is preferred over the more deeply nested g3(i)
    assert(forall|i: int| #![auto] g1(i) >= i || g2(g3(i)) >= i);
    // :pattern ((f1. i@ j@))
    // note: f1(i, j) is preferred over the larger f2(j, g1(i))
    assert(forall|i: int, j: int| #![auto] i == j ==> f1(i, j) || f2(j, g1(i)));
    // :pattern ((f1. j@ (g1. i@)))
    // note: f1(i, j) is excluded due to a potential matching loop
    assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, g1(i)));
    // matching loop, no trigger
    // assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, i + 1));
    // :pattern ((f2. j@ i@))
    // :pattern ((f1. i@ j@))
    assert(forall|i: int, j: int| f2(j, i) ==> f1(i, j));
    // :pattern ((g1. j@) (g1. i@))
    assert(forall|i: int, j: int| g1(i) >= i && g1(j) >= j);
    // :pattern ((g1. i@) (g2. j@))
    assert(g1(3) == g2(2));
    assert(exists|i: int, j: int| g1(i) == g2(j));
}

// Manually chosen triggers
fn test_manual() {
    //
    // For single triggers, use #[trigger]
    //
    // :pattern ((f1. i@ j@))
    assert(forall|i: int, j: int| f2(j, i) ==> #[trigger] f1(i, j));
    // :pattern ((g1. i@) (g2. j@))
    assert(forall|i: int, j: int| f1(i, j) ==> f1(#[trigger] g1(i), #[trigger] g2(j)));
    //
    // For multiple triggers, use
    //   with_triggers!([...trigger 1 terms...], ..., [...trigger n terms...] => body)
    //
    // :pattern ((g1. i@) (g2. j@))
    // :pattern ((f1. i@ j@))
    assert(forall|i: int, j: int|
        #![trigger g1(i), g2(j)]
        #![trigger f1(i, j)]
        f1(i, j) ==> f1(g1(i), g2(j)));
    // :pattern ((g1. i@) (g2. j@))
    // :pattern ((f1. i@ j@) (g1. i@))
    assert(forall|i: int, j: int|
        #![trigger g1(i), g2(j)]
        #![trigger f1(i, j), g1(i)]
        f1(i, j) ==> f1(g1(i), g2(j)));
}

spec fn tr(i: int) -> bool {
    true
}

fn test_nat() {
    assert(forall|i: nat| i >= 0 && tr(i as int));
    assert(tr(300));
    assert(exists|i: nat| i >= 0 && tr(i as int));
    assert(exists|i: u16| i >= 300 && tr(i as int));
}

} // verus!
","use verus_builtin::*;
       use verus_builtin_macros::*;
       fn main() {
     }
       verus! {
      spec fn f1(i: int, j: int) -> bool {
         i >= j }
      spec fn g1(i: int) -> int {
         i + 2 }
      fn test_auto() {
    }
      }
","['#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\nfn main() {}\n\nverus! {\n\nspec fn f1(i: int, j: int) -> bool {\n    i <= j\n}\n\nspec fn f2(i: int, j: int) -> bool {\n    i >= j\n}\n\nspec fn g1(i: int) -> int {\n    i + 1\n}\n\nspec fn g2(i: int) -> int {\n    i + 2\n}\n\nspec fn g3(i: int) -> int {\n    i + 3\n}\n\n// Automatically chosen triggers\nfn test_auto() {\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j));\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) && f1(i, j));\n    // :pattern ((f1. j@ i@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, i));\n    // :pattern ((f1. i@ j@))\n    // note: f1(i, j) is preferred over splitting i, j among g1(i), g2(j)\n    assert(forall|i: int, j: int| f1(i, j) ==> g1(i) <= g2(j));\n    // :pattern ((g1. i@))\n    // note: g1(i) is preferred over the more deeply nested g3(i)\n    assert(forall|i: int| #![auto] g1(i) >= i || g2(g3(i)) >= i);\n    // :pattern ((f1. i@ j@))\n    // note: f1(i, j) is preferred over the larger f2(j, g1(i))\n    assert(forall|i: int, j: int| #![auto] i == j ==> f1(i, j) || f2(j, g1(i)));\n    // :pattern ((f1. j@ (g1. i@)))\n    // note: f1(i, j) is excluded due to a potential matching loop\n    assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, g1(i)));\n    // matching loop, no trigger\n    // assert(forall|i: int, j: int| i == j ==> f1(i, j) || f1(j, i + 1));\n    // :pattern ((f2. j@ i@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| f2(j, i) ==> f1(i, j));\n    // :pattern ((g1. j@) (g1. i@))\n    assert(forall|i: int, j: int| g1(i) >= i && g1(j) >= j);\n    // :pattern ((g1. i@) (g2. j@))\n    assert(g1(3) == g2(2));\n    assert(exists|i: int, j: int| g1(i) == g2(j));\n}\n\n// Manually chosen triggers\nfn test_manual() {\n    //\n    // For single triggers, use #[trigger]\n    //\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int| f2(j, i) ==> #[trigger] f1(i, j));\n    // :pattern ((g1. i@) (g2. j@))\n    assert(forall|i: int, j: int| f1(i, j) ==> f1(#[trigger] g1(i), #[trigger] g2(j)));\n    //\n    // For multiple triggers, use\n    //   with_triggers!([...trigger 1 terms...], ..., [...trigger n terms...] => body)\n    //\n    // :pattern ((g1. i@) (g2. j@))\n    // :pattern ((f1. i@ j@))\n    assert(forall|i: int, j: int|\n        #![trigger g1(i), g2(j)]\n        #![trigger f1(i, j)]\n        f1(i, j) ==> f1(g1(i), g2(j)));\n    // :pattern ((g1. i@) (g2. j@))\n    // :pattern ((f1. i@ j@) (g1. i@))\n    assert(forall|i: int, j: int|\n        #![trigger g1(i), g2(j)]\n        #![trigger f1(i, j), g1(i)]\n        f1(i, j) ==> f1(g1(i), g2(j)));\n}\n\nspec fn tr(i: int) -> bool {\n    true\n}\n\nfn test_nat() {\n    assert(forall|i: nat| i >= 0 && tr(i as int));\n    assert(tr(300));\n    assert(exists|i: nat| i >= 0 && tr(i as int));\n    assert(exists|i: u16| i >= 300 && tr(i as int));\n}\n\n} // verus!\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n       use verus_builtin_macros::*;\n       fn main() {\n     }\n       verus! {\n      spec fn f1(i: int, j: int) -> bool {\n         i >= j }\n      spec fn g1(i: int) -> int {\n         i + 2 }\n      fn test_auto() {\n    }\n      }\n', 'use verus_builtin::*;\n         use verus_builtin_macros::*;\n         fn main() {}\n         verus! {}\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/recommends.rs,63,9,0.14285714285714285,216.09,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,,,,"#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::{pervasive::*, seq::*, seq_lib::*};

verus! {

spec fn max_int(x: int, y: int) -> int {
    if x > y {
        x
    } else {
        y
    }
}

// To enable recommends checking, use: spec(checked) instead of spec
spec fn seq_max_int(s: Seq<int>) -> int
    recommends
        s.len()
            > 0,  // without this, spec(checked) generates a recommends warning below

    decreases s.len(),
{
    let m = s[s.len() - 1];
    if s.len() <= 1 {
        m
    } else {
        max_int(m, seq_max_int(s.drop_last()))
    }
}

proof fn test(s: Seq<int>)
    requires
        seq_max_int(s)
            >= 0,  // without this, the assertion fails and there's a recommends note
{
    assert(seq_max_int(s) >= 0);
}

fn main() {
    proof {
        let s = seq![10, 20, 30, 25];
        reveal_with_fuel(seq_max_int, 4);
        assert(seq_max_int(s) == 30);
    }
}

// Usage of `spec_affirm`
spec fn some_predicate(a: nat) -> bool
    recommends
        a < 100,
{
    if (a >= 50) {
        let _ = spec_affirm(50 <= a && a < 100);
        a >= 75
    } else {
        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here
        a < 25
    }
}

} // verus!
","use verus_builtin::*;
        use verus_builtin_macros::*;
        use vstd::{
      pervasive::*, seq::*, seq_lib::*};
        verus! {
       spec fn max_int() -> int ;
       spec fn seq_max_int(s: Seq<int>) -> int     recommends         s.len()             > 0,       decreases s.len(), ;
       fn main() ;
       }
","[""#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, seq::*, seq_lib::*};\n\nverus! {\n\nspec fn max_int(x: int, y: int) -> int {\n    if x > y {\n        x\n    } else {\n        y\n    }\n}\n\n// To enable recommends checking, use: spec(checked) instead of spec\nspec fn seq_max_int(s: Seq<int>) -> int\n    recommends\n        s.len()\n            > 0,  // without this, spec(checked) generates a recommends warning below\n\n    decreases s.len(),\n{\n    let m = s[s.len() - 1];\n    if s.len() <= 1 {\n        m\n    } else {\n        max_int(m, seq_max_int(s.drop_last()))\n    }\n}\n\nproof fn test(s: Seq<int>)\n    requires\n        seq_max_int(s)\n            >= 0,  // without this, the assertion fails and there's a recommends note\n{\n    assert(seq_max_int(s) >= 0);\n}\n\nfn main() {\n    proof {\n        let s = seq![10, 20, 30, 25];\n        reveal_with_fuel(seq_max_int, 4);\n        assert(seq_max_int(s) == 30);\n    }\n}\n\n// Usage of `spec_affirm`\nspec fn some_predicate(a: nat) -> bool\n    recommends\n        a < 100,\n{\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here\n        a < 25\n    }\n}\n\n} // verus!\n"", 'use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::{\n      pervasive::*, seq::*, seq_lib::*};\n        verus! {\n       spec fn max_int() -> int ;\n       spec fn seq_max_int(s: Seq<int>) -> int     recommends         s.len()             > 0,       decreases s.len(), ;\n       fn main() ;\n       }\n', '          use verus_builtin_macros::*;\n               use vstd::{\n            pervasive::*, seq::*, seq_lib::*};\n               verus! {\n             fn main() ;\n             }\n', 'use verus_builtin_macros::*;\nuse vstd;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/recursion.rs,116,116,1.0,156.085,True,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,,,,"use verus_builtin::*;
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::{modes::*, prelude::*, seq::*, *};

verus! {

spec fn arith_sum_int(i: int) -> int
    decreases i,
{
    if i <= 0 {
        0
    } else {
        i + arith_sum_int(i - 1)
    }
}

#[verifier::opaque]
spec fn arith_sum_u64(i: u64) -> u64
    decreases i,
{
    if i == 0 {
        0
    } else {
        (i + arith_sum_u64((i - 1) as u64)) as u64
    }
}

proof fn arith_sum_int_nonneg(i: nat)
    ensures
        arith_sum_int(i as int) >= 0,
    decreases i,
{
    if i > 0 {
        arith_sum_int_nonneg((i - 1) as nat);
    }
}

proof fn arith_sum_test1() {
    assert(arith_sum_int(0) == 0);
    // Recursive functions default to 1 fuel, so without the assert above,
    // the following assert will fail
    assert(arith_sum_int(1) == 1);
    assert(arith_sum_int(2) == 3);
    assert(arith_sum_int(3) == 6);
}

proof fn arith_sum_test2() {
    // Instead of writing out intermediate assertions,
    // we can instead boost the fuel setting
    reveal_with_fuel(arith_sum_int, 4);
    assert(arith_sum_int(3) == 6);
}

proof fn arith_sum_test3() {
    reveal_with_fuel(arith_sum_u64, 4);
    assert(arith_sum_u64(3) == 6);
}

proof fn arith_sum_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        arith_sum_int(i as int) <= arith_sum_int(j as int),
    decreases j,
{
    if i < j {
        arith_sum_monotonic(i, (j - 1) as nat);
    }
}

fn compute_arith_sum(n: u64) -> (sum: u64)
    requires
        n < 100,
    ensures
        arith_sum_int(n as int) == sum,
{
    let mut sum: u64 = 0;
    for i in 0..n
        invariant
            n < 100,
            arith_sum_int(i as int) == sum,
            sum <= 100 * i,
    {
        sum = sum + (i + 1);
    }
    sum
}

fn run_arith_sum(n: u64) -> u64 {
    let mut result: u64 = 0;
    if n < 100 {
        result = compute_arith_sum(n);
    }
    result
}

fn exec_with_decreases(n: u64) -> u64
    decreases 100 - n,
{
    if n < 100 {
        exec_with_decreases(n + 1)
    } else {
        n
    }
}

} // verus!
fn main() {
    let args = std::env::args();
    for arg in args {
        if let Ok(n) = arg.parse::<u64>() {
            println!(""{}"", run_arith_sum(n));
        }
    }
}
","use verus_builtin::*;
use verus_builtin_macros::*;
#[allow(unused_imports)]
use vstd::{modes::*, prelude::*, seq::*, *};

verus! {

spec fn arith_sum_int(i: int) -> int
    decreases i,
{
    if i <= 0 {
        0
    } else {
        i + arith_sum_int(i - 1)
    }
}

#[verifier::opaque]
spec fn arith_sum_u64(i: u64) -> u64
    decreases i,
{
    if i == 0 {
        0
    } else {
        (i + arith_sum_u64((i - 1) as u64)) as u64
    }
}

proof fn arith_sum_int_nonneg(i: nat)
    ensures
        arith_sum_int(i as int) >= 0,
    decreases i,
{
    if i > 0 {
        arith_sum_int_nonneg((i - 1) as nat);
    }
}

proof fn arith_sum_test1() {
    assert(arith_sum_int(0) == 0);
    // Recursive functions default to 1 fuel, so without the assert above,
    // the following assert will fail
    assert(arith_sum_int(1) == 1);
    assert(arith_sum_int(2) == 3);
    assert(arith_sum_int(3) == 6);
}

proof fn arith_sum_test2() {
    // Instead of writing out intermediate assertions,
    // we can instead boost the fuel setting
    reveal_with_fuel(arith_sum_int, 4);
    assert(arith_sum_int(3) == 6);
}

proof fn arith_sum_test3() {
    reveal_with_fuel(arith_sum_u64, 4);
    assert(arith_sum_u64(3) == 6);
}

proof fn arith_sum_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        arith_sum_int(i as int) <= arith_sum_int(j as int),
    decreases j,
{
    if i < j {
        arith_sum_monotonic(i, (j - 1) as nat);
    }
}

fn compute_arith_sum(n: u64) -> (sum: u64)
    requires
        n < 100,
    ensures
        arith_sum_int(n as int) == sum,
{
    let mut sum: u64 = 0;
    for i in 0..n
        invariant
            n < 100,
            arith_sum_int(i as int) == sum,
            sum <= 100 * i,
    {
        sum = sum + (i + 1);
    }
    sum
}

fn run_arith_sum(n: u64) -> u64 {
    let mut result: u64 = 0;
    if n < 100 {
        result = compute_arith_sum(n);
    }
    result
}

fn exec_with_decreases(n: u64) -> u64
    decreases 100 - n,
{
    if n < 100 {
        exec_with_decreases(n + 1)
    } else {
        n
    }
}

} // verus!
fn main() {
    let args = std::env::args();
    for arg in args {
        if let Ok(n) = arg.parse::<u64>() {
            println!(""{}"", run_arith_sum(n));
        }
    }
}
","['use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(""{}"", run_arith_sum(n));\n        }\n    }\n}\n', 'use vstd;\nfn main() {}\n', ' use vstd::{\n        modes::*, prelude::*, seq::*, *};\n            fn main() {\n }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/recursive_types.rs,133,133,1.0,184.249,True,0.9,True,['vstd::prelude::'],True,,,,,,"use vstd::prelude::*;

// TODO: add some of these explanations to the guide

verus! {

// If treated naively, recursive types can lead to nonterminating proofs:
/*
struct R { f: spec_fn(R) -> int }
proof fn bad()
    ensures false
{
    let f1 = |r: R| -> int {
        (r.f)(r) + 1
    };
    let r = R { f: f1 };
    // from r == R { f: f1 }:
    assert( r.f     == f1   );
    assert((r.f)(r) == f1(r));
    // from the definition of f1:
    assert(f1(r) == (r.f)(r) + 1);
    // taken together:
    assert(f1(r) == f1(r) + 1);
}
*/// To prevent this, Verus prohibits recursion in ""negative positions"" in a recursive type.
// Roughly, a negative position is anything on the left-hand side of a function type ->.
// For example, the ""R"" in spec_fn(R) -> int is in a negative position.
// Therefore, Verus rejects the definition ""struct R { f: spec_fn(R) -> int }"" with an error.
// If generics are treated naively, they could encode recursion in negative positions.
// For example, we could try to wrap the function type in a new type to hide the negative
// use of R:
/*
struct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position
struct R { f: FnWrapper<R, int> }
*/// To prevent this, Verus requires that type parameters used in negative positions (like A)
// be annotated with #[verifier::reject_recursive_types]:
/*
#[verifier::reject_recursive_types(A)]
struct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok
struct R { f: FnWrapper<R, int> } // error: R not allowed in negative position
*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should
// be rejected, and it reports an error in the definition of R.
// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:
enum List<A> {
    Nil,
    Cons(A, Box<List<A>>),
}

spec fn len<A>(list: &List<A>) -> nat
    decreases list  // decreases can be used on values of type List<A> ,
{
    match list {
        List::Nil => 0,
        List::Cons(_, tl) => 1 + len(tl),
    }
}

// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).
// For this, Verus requires that struct and enum datatypes have a non-recursive
// ""ground"" variant that can be used as a base case for defining the height.
// For example, the Nil variant in List can be used to construct List values of height 0,
// and then the Cons variant can be repeatedly applied to construct bigger and bigger values
// with height > 0.
// Attempting to declare a datatype with no ground variant will cause an error:
/*
enum UngroundedList<A> {
    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList
    Cons(A, Box<UngroundedList<A>>),
}
*/

// If generics are treated naively, they could encode datatypes with no ground variant:
/*
struct DataWrapper<A> { a: A }
enum UngroundedList<A> {
    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList
    Cons(A, Box<DataWrapper<UngroundedList<A>>>),
}
*/

// To prevent this, Verus rejects a recursive type definition's ground variant
// from instantiating a type parameter A with the recursive type (UngroundedList)
// unless the type parameter A is marked #[verifier::accept_recursive_types].
// However, if DataWrapper marks A accept_recursive_types,
// then DataWrapper must have a ground variant that is not built from A.
// Because of this, Verus rejects the following:
/*
#[verifier::accept_recursive_types(A)]
struct DataWrapper<A> { a: A } // error: no ground variant without A
*/

// However, by adding a ground variant, we can provide a correct wrapper,
// making both DataOption and GroundedList properly grounded:
#[verifier::accept_recursive_types(A)]
enum DataOption<A> {
    None,
    Some(A),
}
  // ok
enum GroundedList<A> {
    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok
}

// Overall, Verus parameters have one of three levels of acceptance of recursive types:
// - #[verifier::reject_recursive_types]
// - #[verifier::reject_recursive_types_in_ground_variants]
// - #[verifier::accept_recursive_types]
// reject_recursive_types is added to types that use the type parameter negatively,
// and accept_recursive_types may (optionally) be added to types that have a ground variant
// that doesn't use the type parameter.
// Typical example of reject_recursive_types:
#[verifier::reject_recursive_types(A)]
struct Set<A> {
    f: spec_fn(A) -> bool,
}

// Typical example of reject_recursive_types_in_ground_variants (which is the default):
struct Pair<A, B> {
    first: A,
    second: B,
}

// Typical example of accept_recursive_types:
#[verifier::accept_recursive_types(A)]
enum Option<A> {
    None,
    Some(A),
}

fn main() {
}

} // verus!
","use vstd::prelude::*;

// TODO: add some of these explanations to the guide

verus! {

// If treated naively, recursive types can lead to nonterminating proofs:
/*
struct R { f: spec_fn(R) -> int }
proof fn bad()
    ensures false
{
    let f1 = |r: R| -> int {
        (r.f)(r) + 1
    };
    let r = R { f: f1 };
    // from r == R { f: f1 }:
    assert( r.f     == f1   );
    assert((r.f)(r) == f1(r));
    // from the definition of f1:
    assert(f1(r) == (r.f)(r) + 1);
    // taken together:
    assert(f1(r) == f1(r) + 1);
}
*/// To prevent this, Verus prohibits recursion in ""negative positions"" in a recursive type.
// Roughly, a negative position is anything on the left-hand side of a function type ->.
// For example, the ""R"" in spec_fn(R) -> int is in a negative position.
// Therefore, Verus rejects the definition ""struct R { f: spec_fn(R) -> int }"" with an error.
// If generics are treated naively, they could encode recursion in negative positions.
// For example, we could try to wrap the function type in a new type to hide the negative
// use of R:
/*
struct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position
struct R { f: FnWrapper<R, int> }
*/// To prevent this, Verus requires that type parameters used in negative positions (like A)
// be annotated with #[verifier::reject_recursive_types]:
/*
#[verifier::reject_recursive_types(A)]
struct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok
struct R { f: FnWrapper<R, int> } // error: R not allowed in negative position
*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should
// be rejected, and it reports an error in the definition of R.
// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:
enum List<A> {
    Nil,
    Cons(A, Box<List<A>>),
}

spec fn len<A>(list: &List<A>) -> nat
    decreases list  // decreases can be used on values of type List<A> ,
{
    match list {
        List::Nil => 0,
        List::Cons(_, tl) => 1 + len(tl),
    }
}

// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).
// For this, Verus requires that struct and enum datatypes have a non-recursive
// ""ground"" variant that can be used as a base case for defining the height.
// For example, the Nil variant in List can be used to construct List values of height 0,
// and then the Cons variant can be repeatedly applied to construct bigger and bigger values
// with height > 0.
// Attempting to declare a datatype with no ground variant will cause an error:
/*
enum UngroundedList<A> {
    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList
    Cons(A, Box<UngroundedList<A>>),
}
*/

// If generics are treated naively, they could encode datatypes with no ground variant:
/*
struct DataWrapper<A> { a: A }
enum UngroundedList<A> {
    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList
    Cons(A, Box<DataWrapper<UngroundedList<A>>>),
}
*/

// To prevent this, Verus rejects a recursive type definition's ground variant
// from instantiating a type parameter A with the recursive type (UngroundedList)
// unless the type parameter A is marked #[verifier::accept_recursive_types].
// However, if DataWrapper marks A accept_recursive_types,
// then DataWrapper must have a ground variant that is not built from A.
// Because of this, Verus rejects the following:
/*
#[verifier::accept_recursive_types(A)]
struct DataWrapper<A> { a: A } // error: no ground variant without A
*/

// However, by adding a ground variant, we can provide a correct wrapper,
// making both DataOption and GroundedList properly grounded:
#[verifier::accept_recursive_types(A)]
enum DataOption<A> {
    None,
    Some(A),
}
  // ok
enum GroundedList<A> {
    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok
}

// Overall, Verus parameters have one of three levels of acceptance of recursive types:
// - #[verifier::reject_recursive_types]
// - #[verifier::reject_recursive_types_in_ground_variants]
// - #[verifier::accept_recursive_types]
// reject_recursive_types is added to types that use the type parameter negatively,
// and accept_recursive_types may (optionally) be added to types that have a ground variant
// that doesn't use the type parameter.
// Typical example of reject_recursive_types:
#[verifier::reject_recursive_types(A)]
struct Set<A> {
    f: spec_fn(A) -> bool,
}

// Typical example of reject_recursive_types_in_ground_variants (which is the default):
struct Pair<A, B> {
    first: A,
    second: B,
}

// Typical example of accept_recursive_types:
#[verifier::accept_recursive_types(A)]
enum Option<A> {
    None,
    Some(A),
}

fn main() {
}

} // verus!
","['use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in ""negative positions"" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the ""R"" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition ""struct R { f: spec_fn(R) -> int }"" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// ""ground"" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition\'s ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn\'t use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/rfmig_script.rs,255,255,1.0,185.03,True,0.85,True,"['vstd::prelude::verus', 'vstd::prelude::']",True,,,True,,,"// rust_verify/tests/example.rs
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
// #![allow(unused_imports, unused_macros, non_camel_case_types)] #![feature(fmt_internals)]
use vstd::prelude::verus;

fn main() {}

verus! {

// ## A -- A-program.rs
fn max(a: u64, b: u64) -> (ret: u64)
    ensures
        ret == a || ret == b,
        ret >= a && ret >= b,
{
    //-   if a >= b { b } else { a }
    /*+*/
    if a >= b {
        a
    } else {
        b
    }
}

// ## B -- B-fibo.rs
spec fn fibo(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibo((n - 2) as nat) + fibo((n - 1) as nat)
    }
}

proof fn lemma_fibo_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fibo(i) <= fibo(j),
    decreases j - i,
{
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fibo_is_monotonic(i, (j - 1) as nat);
        lemma_fibo_is_monotonic(i, (j - 2) as nat);
    }
}

spec fn fibo_fits_u64(n: nat) -> bool {
    fibo(n) <= 0xffff_ffff_ffff_ffff
}

exec fn fibo_impl(n: u64) -> (result: u64)
    requires
        fibo_fits_u64(n as nat),
    ensures
        result == fibo(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fibo_fits_u64(n as nat),
            fibo_fits_u64(i as nat),
            cur == fibo(i as nat),
            prev == fibo((i - 1) as nat),
    {
        i = i + 1;
        proof {
            lemma_fibo_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}

// ## C -- C-linearity.rs
pub struct Account {
    pub balance: u64,
}

pub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)
    requires
        old(orig).balance >= amount,
        old(dest).balance + amount < u64::MAX,
    ensures
        dest.balance == old(dest).balance + amount,
        orig.balance == old(orig).balance - amount,
{
    /*+*/
    let accounts_pre: Ghost<(Account, Account)> = Ghost((*orig, *dest));
    orig.balance = orig.balance - amount;
    dest.balance = dest.balance + amount;
    /*+*/
    assert(orig.balance + dest.balance == accounts_pre@.0.balance + accounts_pre@.1.balance);
}

//- fn cmain(account: Account)
//-     requires account.balance >= 100
//- {
//-     let mut account = account;
//-     transfer(&mut account, &mut account, 100);
//- }
// ## C2(e) -- C2-linearity.rs
use vstd::prelude::*;

//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {
//-      let v1 = v;
//-      let v2 = v;
//-      (v1, v2)
//-  }
/*+*/

exec fn f(v: Vec<u64>) {
    /*+*/
    let v1: Ghost<Vec<u64>> = Ghost(v);
    /*+*/
    let v2: Ghost<Vec<u64>> = Ghost(v);
    /*+*/
    assert(v1@.len() == v2@.len());
    /*+*/
}

exec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)
    requires
        old(v1)@.len() == 2,
        old(v2)@.len() == 3,
    ensures
        v1@.len() == v2@.len(),
{
    v1.push(42);
    v1.push(43);
    v2.push(52);
}

// ## D -- D-recommends.rs
spec fn divide(x: nat, y: nat) -> nat
    recommends
        y != 0,
{
    x / y
}

// E -- E-solvers.rs
proof fn div_is_smaller(x: nat, y: nat)/*+*/

    by (nonlinear_arith)
    requires
        y != 0,
    ensures
        divide(x, y) <= x,
{
}

fn mod8_bw(x: u32) -> (ret: u32)
    ensures
        ret == x % 8,
{
    assert(x & 7 == x % 8) by (bit_vector);
    x & 7
}

// F0 -- F-linear-ghost
struct State1 {
    s: nat,
}

struct State2 {
    s: nat,
}

#[verifier::external_body]
proof fn exchange(tracked s1: State1) -> (tracked s2: State2)
    ensures
        s1.s == s2.s,
{
    todo!()
}

#[verifier::external_body]
proof fn exercise1(tracked s1: &State1) -> (result: bool) {
    todo!()
}

#[verifier::external_body]
proof fn exercise2(tracked s1: &State1) -> (result: bool) {
    todo!()
}

proof fn p(tracked s1: State1) {
    //+ let tracked s2 = exchange(s1);
    exercise1(&s1);
    //+ exercise(&s2);
}

// F1 -- F-linear-proof
mod F1 {
    use vstd::{prelude::*, simple_pptr::*};

    #[verifier::external_body]
    fn send_pointer(ptr: PPtr<u64>) {
        todo!()
    }

    #[verifier::external_body]
    proof fn transfer_permission(tracked perm: PointsTo<u64>) {
        todo!()
    }

    fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)
        requires
            counter == old(perm).pptr(),
            old(perm).is_init() && old(perm).value() < 100,
        ensures
            perm.pptr() == old(perm).pptr(),
            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64),
    {
        // pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)
        let cur_i: u64 = *counter.borrow(Tracked(&*perm));
        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)
        counter.replace(Tracked(perm), cur_i + 1);
    }

    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)
        requires
            counter == perm.pptr(),
            perm.opt_value() === MemContents::Uninit,
    {
        send_pointer(counter);
        let tracked mut perm: PointsTo<u64> = perm;
        // pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)
        counter.put(Tracked(&mut perm), 5);
        assert(perm.opt_value() === MemContents::Init(5));
        //+ proof { transfer_permission(perm) };
        increment(counter, Tracked(&mut perm));
        assert(perm.opt_value() === MemContents::Init(6));
    }

}

// F1

} // verus!
","// rust_verify/tests/example.rs
#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
// #![allow(unused_imports, unused_macros, non_camel_case_types)] #![feature(fmt_internals)]
use vstd::prelude::verus;

fn main() {}

verus! {

// ## A -- A-program.rs
fn max(a: u64, b: u64) -> (ret: u64)
    ensures
        ret == a || ret == b,
        ret >= a && ret >= b,
{
    //-   if a >= b { b } else { a }
    /*+*/
    if a >= b {
        a
    } else {
        b
    }
}

// ## B -- B-fibo.rs
spec fn fibo(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibo((n - 2) as nat) + fibo((n - 1) as nat)
    }
}

proof fn lemma_fibo_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fibo(i) <= fibo(j),
    decreases j - i,
{
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fibo_is_monotonic(i, (j - 1) as nat);
        lemma_fibo_is_monotonic(i, (j - 2) as nat);
    }
}

spec fn fibo_fits_u64(n: nat) -> bool {
    fibo(n) <= 0xffff_ffff_ffff_ffff
}

exec fn fibo_impl(n: u64) -> (result: u64)
    requires
        fibo_fits_u64(n as nat),
    ensures
        result == fibo(n as nat),
{
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fibo_fits_u64(n as nat),
            fibo_fits_u64(i as nat),
            cur == fibo(i as nat),
            prev == fibo((i - 1) as nat),
    {
        i = i + 1;
        proof {
            lemma_fibo_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}

// ## C -- C-linearity.rs
pub struct Account {
    pub balance: u64,
}

pub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)
    requires
        old(orig).balance >= amount,
        old(dest).balance + amount < u64::MAX,
    ensures
        dest.balance == old(dest).balance + amount,
        orig.balance == old(orig).balance - amount,
{
    /*+*/
    let accounts_pre: Ghost<(Account, Account)> = Ghost((*orig, *dest));
    orig.balance = orig.balance - amount;
    dest.balance = dest.balance + amount;
    /*+*/
    assert(orig.balance + dest.balance == accounts_pre@.0.balance + accounts_pre@.1.balance);
}

//- fn cmain(account: Account)
//-     requires account.balance >= 100
//- {
//-     let mut account = account;
//-     transfer(&mut account, &mut account, 100);
//- }
// ## C2(e) -- C2-linearity.rs
use vstd::prelude::*;

//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {
//-      let v1 = v;
//-      let v2 = v;
//-      (v1, v2)
//-  }
/*+*/

exec fn f(v: Vec<u64>) {
    /*+*/
    let v1: Ghost<Vec<u64>> = Ghost(v);
    /*+*/
    let v2: Ghost<Vec<u64>> = Ghost(v);
    /*+*/
    assert(v1@.len() == v2@.len());
    /*+*/
}

exec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)
    requires
        old(v1)@.len() == 2,
        old(v2)@.len() == 3,
    ensures
        v1@.len() == v2@.len(),
{
    v1.push(42);
    v1.push(43);
    v2.push(52);
}

// ## D -- D-recommends.rs
spec fn divide(x: nat, y: nat) -> nat
    recommends
        y != 0,
{
    x / y
}

// E -- E-solvers.rs
proof fn div_is_smaller(x: nat, y: nat)/*+*/

    by (nonlinear_arith)
    requires
        y != 0,
    ensures
        divide(x, y) <= x,
{
}

fn mod8_bw(x: u32) -> (ret: u32)
    ensures
        ret == x % 8,
{
    assert(x & 7 == x % 8) by (bit_vector);
    x & 7
}

// F0 -- F-linear-ghost
struct State1 {
    s: nat,
}

struct State2 {
    s: nat,
}

#[verifier::external_body]
proof fn exchange(tracked s1: State1) -> (tracked s2: State2)
    ensures
        s1.s == s2.s,
{
    todo!()
}

#[verifier::external_body]
proof fn exercise1(tracked s1: &State1) -> (result: bool) {
    todo!()
}

#[verifier::external_body]
proof fn exercise2(tracked s1: &State1) -> (result: bool) {
    todo!()
}

proof fn p(tracked s1: State1) {
    //+ let tracked s2 = exchange(s1);
    exercise1(&s1);
    //+ exercise(&s2);
}

// F1 -- F-linear-proof
mod F1 {
    use vstd::{prelude::*, simple_pptr::*};

    #[verifier::external_body]
    fn send_pointer(ptr: PPtr<u64>) {
        todo!()
    }

    #[verifier::external_body]
    proof fn transfer_permission(tracked perm: PointsTo<u64>) {
        todo!()
    }

    fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)
        requires
            counter == old(perm).pptr(),
            old(perm).is_init() && old(perm).value() < 100,
        ensures
            perm.pptr() == old(perm).pptr(),
            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64),
    {
        // pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)
        let cur_i: u64 = *counter.borrow(Tracked(&*perm));
        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)
        counter.replace(Tracked(perm), cur_i + 1);
    }

    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)
        requires
            counter == perm.pptr(),
            perm.opt_value() === MemContents::Uninit,
    {
        send_pointer(counter);
        let tracked mut perm: PointsTo<u64> = perm;
        // pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)
        counter.put(Tracked(&mut perm), 5);
        assert(perm.opt_value() === MemContents::Init(5));
        //+ proof { transfer_permission(perm) };
        increment(counter, Tracked(&mut perm));
        assert(perm.opt_value() === MemContents::Init(6));
    }

}

// F1

} // verus!
","[""// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n// #![allow(unused_imports, unused_macros, non_camel_case_types)] #![feature(fmt_internals)]\nuse vstd::prelude::verus;\n\nfn main() {}\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\npub struct Account {\n    pub balance: u64,\n}\n\npub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)\n    requires\n        old(orig).balance >= amount,\n        old(dest).balance + amount < u64::MAX,\n    ensures\n        dest.balance == old(dest).balance + amount,\n        orig.balance == old(orig).balance - amount,\n{\n    /*+*/\n    let accounts_pre: Ghost<(Account, Account)> = Ghost((*orig, *dest));\n    orig.balance = orig.balance - amount;\n    dest.balance = dest.balance + amount;\n    /*+*/\n    assert(orig.balance + dest.balance == accounts_pre@.0.balance + accounts_pre@.1.balance);\n}\n\n//- fn cmain(account: Account)\n//-     requires account.balance >= 100\n//- {\n//-     let mut account = account;\n//-     transfer(&mut account, &mut account, 100);\n//- }\n// ## C2(e) -- C2-linearity.rs\nuse vstd::prelude::*;\n\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// ## D -- D-recommends.rs\nspec fn divide(x: nat, y: nat) -> nat\n    recommends\n        y != 0,\n{\n    x / y\n}\n\n// E -- E-solvers.rs\nproof fn div_is_smaller(x: nat, y: nat)/*+*/\n\n    by (nonlinear_arith)\n    requires\n        y != 0,\n    ensures\n        divide(x, y) <= x,\n{\n}\n\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n// F0 -- F-linear-ghost\nstruct State1 {\n    s: nat,\n}\n\nstruct State2 {\n    s: nat,\n}\n\n#[verifier::external_body]\nproof fn exchange(tracked s1: State1) -> (tracked s2: State2)\n    ensures\n        s1.s == s2.s,\n{\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise1(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise2(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\nproof fn p(tracked s1: State1) {\n    //+ let tracked s2 = exchange(s1);\n    exercise1(&s1);\n    //+ exercise(&s2);\n}\n\n// F1 -- F-linear-proof\nmod F1 {\n    use vstd::{prelude::*, simple_pptr::*};\n\n    #[verifier::external_body]\n    fn send_pointer(ptr: PPtr<u64>) {\n        todo!()\n    }\n\n    #[verifier::external_body]\n    proof fn transfer_permission(tracked perm: PointsTo<u64>) {\n        todo!()\n    }\n\n    fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)\n        requires\n            counter == old(perm).pptr(),\n            old(perm).is_init() && old(perm).value() < 100,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64),\n    {\n        // pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)\n        let cur_i: u64 = *counter.borrow(Tracked(&*perm));\n        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)\n        counter.replace(Tracked(perm), cur_i + 1);\n    }\n\n    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n        requires\n            counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit,\n    {\n        send_pointer(counter);\n        let tracked mut perm: PointsTo<u64> = perm;\n        // pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)\n        counter.put(Tracked(&mut perm), 5);\n        assert(perm.opt_value() === MemContents::Init(5));\n        //+ proof { transfer_permission(perm) };\n        increment(counter, Tracked(&mut perm));\n        assert(perm.opt_value() === MemContents::Init(6));\n    }\n\n}\n\n// F1\n\n} // verus!\n"", 'use vstd;\nfn main() {}\n', 'use vstd::prelude::verus;\n        fn main() {}\n        verus! {}\n', 'use vstd::prelude::verus;\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/rw2022_script.rs,189,189,1.0,183.715,True,0.9,True,,True,,True,True,,1.0,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
fn main() {}

// ## 11 -- 10-program.rs

#[allow(unused_imports)]
use {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};

verus! {

// ## A -- A-program.rs
fn max(a: u64, b: u64) -> (ret: u64)
    ensures
        ret == a || ret == b,
        ret >= a && ret >= b,
{
    if a >= b {
        a
    } else {
        b
    }
}

fn max_test2() {
    let x = 3;
    let y = 4;
    let ret = max(x, y);
    assert(ret == 4);
}

// ## B -- B-program.rs
fn main_1() {
    let x = 3;
    let y = 4;
    assert(x != y);
}

// ## B -- B-program.rs.smt sat
// ## C -- C-prime.rs
spec fn divides(factor: nat, candidate: nat) -> bool {
    candidate % factor == 0
}

spec fn is_prime(candidate: nat) -> bool {
    &&& 1 < candidate
    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)
}

fn test_prime(candidate: u64) -> (result: bool)
    requires
        1 < candidate,
    ensures
        result == is_prime(candidate as nat),
{
    let mut factor: u64 = 2;
    while factor < candidate
        invariant
            1 < factor <= candidate,
            forall|smallerfactor: nat|
                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),
    {
        if candidate % factor == 0 {
            assert(divides(factor as nat, candidate as nat));
            assert(!is_prime(candidate as nat));
            return false;
        }
        factor = factor + 1;
    }
    true
}

fn assertions() {
    assert(divides(3, 6));
    assert(divides(12, 24));
    assert(is_prime(2));
    assert(is_prime(3));
    assert(!divides(4, 5));
    assert(is_prime(5));
}

// ## D -- D-fibo.rs
spec fn fibo(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibo((n - 2) as nat) + fibo((n - 1) as nat)
    }
}

proof fn lemma_fibo_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fibo(i) <= fibo(j),
    decreases j - i,
{
    // ----
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fibo_is_monotonic(i, (j - 1) as nat);
        lemma_fibo_is_monotonic(i, (j - 2) as nat);
    }
}

// ## D/2 -- D-fibo.rs
spec fn fibo_fits_u64(n: nat) -> bool {
    fibo(n) <= 0xffff_ffff_ffff_ffff
}

exec fn fibo_impl(n: u64) -> (result: u64)
    requires
        fibo_fits_u64(n as nat),
    ensures
        result == fibo(n as nat),
{
    // ----
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fibo_fits_u64(n as nat),
            fibo_fits_u64(i as nat),
            cur == fibo(i as nat),
            prev == fibo((i - 1) as nat),
    {
        i = i + 1;
        proof {
            lemma_fibo_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}

// ## E -- E-reverse.rs -- spec variables
/* See vectors.rs
fn reverse(v: &mut Vec<u64>) {
    ensures([
        v.len() == old(v).len(),
        forall(|i: int| 0 <= i && i < old(v).len()
               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),
    ]);

    let length = v.len();
    #[verifier::spec] let v1 = *v;
    let mut n: usize = 0;
    while n < length / 2 {
        invariant([
            length == v.len(),
            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),
            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),
            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),
        ]);

        let x = *v.index(n);
        let y = *v.index(length - 1 - n);
        v.set(n, y);
        v.set(length - 1 - n, x);

        n = n + 1;
    }
}
*/

// F -- F-linear-proof
// cell::RefCell::Cell<X>
// G -- G-bitvector.rs
fn mod8_bw(x: u32) -> (ret: u32)
    ensures
        ret == x % 8,
{
    assert(x & 7 == x % 8) by (bit_vector);
    x & 7
}

} // verus!
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
fn main() {}

// ## 11 -- 10-program.rs

#[allow(unused_imports)]
use {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};

verus! {

// ## A -- A-program.rs
fn max(a: u64, b: u64) -> (ret: u64)
    ensures
        ret == a || ret == b,
        ret >= a && ret >= b,
{
    if a >= b {
        a
    } else {
        b
    }
}

fn max_test2() {
    let x = 3;
    let y = 4;
    let ret = max(x, y);
    assert(ret == 4);
}

// ## B -- B-program.rs
fn main_1() {
    let x = 3;
    let y = 4;
    assert(x != y);
}

// ## B -- B-program.rs.smt sat
// ## C -- C-prime.rs
spec fn divides(factor: nat, candidate: nat) -> bool {
    candidate % factor == 0
}

spec fn is_prime(candidate: nat) -> bool {
    &&& 1 < candidate
    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)
}

fn test_prime(candidate: u64) -> (result: bool)
    requires
        1 < candidate,
    ensures
        result == is_prime(candidate as nat),
{
    let mut factor: u64 = 2;
    while factor < candidate
        invariant
            1 < factor <= candidate,
            forall|smallerfactor: nat|
                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),
    {
        if candidate % factor == 0 {
            assert(divides(factor as nat, candidate as nat));
            assert(!is_prime(candidate as nat));
            return false;
        }
        factor = factor + 1;
    }
    true
}

fn assertions() {
    assert(divides(3, 6));
    assert(divides(12, 24));
    assert(is_prime(2));
    assert(is_prime(3));
    assert(!divides(4, 5));
    assert(is_prime(5));
}

// ## D -- D-fibo.rs
spec fn fibo(n: nat) -> nat
    decreases n,
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibo((n - 2) as nat) + fibo((n - 1) as nat)
    }
}

proof fn lemma_fibo_is_monotonic(i: nat, j: nat)
    requires
        i <= j,
    ensures
        fibo(i) <= fibo(j),
    decreases j - i,
{
    // ----
    if j < 2 {
    } else if i == j {
    } else if i == j - 1 {
    } else {
        lemma_fibo_is_monotonic(i, (j - 1) as nat);
        lemma_fibo_is_monotonic(i, (j - 2) as nat);
    }
}

// ## D/2 -- D-fibo.rs
spec fn fibo_fits_u64(n: nat) -> bool {
    fibo(n) <= 0xffff_ffff_ffff_ffff
}

exec fn fibo_impl(n: u64) -> (result: u64)
    requires
        fibo_fits_u64(n as nat),
    ensures
        result == fibo(n as nat),
{
    // ----
    if n == 0 {
        return 0;
    }
    let mut prev: u64 = 0;
    let mut cur: u64 = 1;
    let mut i: u64 = 1;
    while i < n
        invariant
            0 < i <= n,
            fibo_fits_u64(n as nat),
            fibo_fits_u64(i as nat),
            cur == fibo(i as nat),
            prev == fibo((i - 1) as nat),
    {
        i = i + 1;
        proof {
            lemma_fibo_is_monotonic(i as nat, n as nat);
        }
        let new_cur = cur + prev;
        prev = cur;
        cur = new_cur;
    }
    cur
}

// ## E -- E-reverse.rs -- spec variables
/* See vectors.rs
fn reverse(v: &mut Vec<u64>) {
    ensures([
        v.len() == old(v).len(),
        forall(|i: int| 0 <= i && i < old(v).len()
               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),
    ]);

    let length = v.len();
    #[verifier::spec] let v1 = *v;
    let mut n: usize = 0;
    while n < length / 2 {
        invariant([
            length == v.len(),
            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),
            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),
            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),
        ]);

        let x = *v.index(n);
        let y = *v.index(length - 1 - n);
        v.set(n, y);
        v.set(length - 1 - n, x);

        n = n + 1;
    }
}
*/

// F -- F-linear-proof
// cell::RefCell::Cell<X>
// G -- G-bitvector.rs
fn mod8_bw(x: u32) -> (ret: u32)
    ensures
        ret == x % 8,
{
    assert(x & 7 == x % 8) by (bit_vector);
    x & 7
}

} // verus!
","['#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\nfn max_test2() {\n    let x = 3;\n    let y = 4;\n    let ret = max(x, y);\n    assert(ret == 4);\n}\n\n// ## B -- B-program.rs\nfn main_1() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n// ## B -- B-program.rs.smt sat\n// ## C -- C-prime.rs\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor <= candidate,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            assert(!is_prime(candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn assertions() {\n    assert(divides(3, 6));\n    assert(divides(12, 24));\n    assert(is_prime(2));\n    assert(is_prime(3));\n    assert(!divides(4, 5));\n    assert(is_prime(5));\n}\n\n// ## D -- D-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    // ----\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\n// ## D/2 -- D-fibo.rs\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    // ----\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[verifier::spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n', 'fn main() {}\nuse{vstd};\n', 'fn main() {}\nuse{verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n', 'fn main() {}\nuse{vstd};\n']"
/Users/ameliakuang/Repos/dep_verus/examples/rwlock_vstd.rs,65,10,0.15384615384615385,185.071,True,0.7999999999999999,True,"['vstd::prelude::', 'vstd::rwlock::']",True,,,,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#![allow(unused_imports)]

use vstd::prelude::*;
use vstd::rwlock::*;

verus!{

fn example1() {
    // We can create a lock with an invariant: `v == 5 || v == 13`.
    // Thus only 5 or 13 can be stored in the lock.
    let lock = RwLock::<u64, spec_fn(u64) -> bool>::new(5, Ghost(|v| v == 5 || v == 13));

    let (val, write_handle) = lock.acquire_write();
    assert(val == 5 || val == 13);
    write_handle.release_write(13);

    let read_handle1 = lock.acquire_read();
    let read_handle2 = lock.acquire_read();

    // We can take multiple read handles at the same time:

    let val1 = read_handle1.borrow();
    let val2 = read_handle2.borrow();

    // RwLock has a lemma that both read handles have the same value:

    proof { ReadHandle::lemma_readers_match(&read_handle1, &read_handle2); }
    assert(*val1 == *val2);

    read_handle1.release_read();
    read_handle2.release_read();
}

// Using higher-order functions is often cumbersome, we can use traits instead.

pub struct FixedParity {
    pub parity: int,
}

impl RwLockPredicate<u64> for FixedParity {
    open spec fn inv(self, v: u64) -> bool {
        v % 2 == self.parity
    }
}

fn example2() {
    let lock_even = RwLock::<u64, FixedParity>::new(20, Ghost(FixedParity { parity: 0 }));
    let lock_odd = RwLock::<u64, FixedParity>::new(23, Ghost(FixedParity { parity: 1 }));

    let read_handle_even = lock_even.acquire_read();
    let val_even = *read_handle_even.borrow();
    assert(val_even % 2 == 0);

    let read_handle_odd = lock_odd.acquire_read();
    let val_odd = *read_handle_odd.borrow();
    assert(val_odd % 2 == 1);
}

pub fn main() {
    example1();
    example2();
}

}
","use vstd::prelude::*;
        use vstd::rwlock::*;
        verus!{
       fn example1() ;
       pub struct FixedParity ;
       impl RwLockPredicate<u64> for FixedParity {
          open spec fn inv(self, v: u64) -> bool ;
      }
       pub fn main() ;
       }
","['#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::prelude::*;\nuse vstd::rwlock::*;\n\nverus!{\n\nfn example1() {\n    // We can create a lock with an invariant: `v == 5 || v == 13`.\n    // Thus only 5 or 13 can be stored in the lock.\n    let lock = RwLock::<u64, spec_fn(u64) -> bool>::new(5, Ghost(|v| v == 5 || v == 13));\n\n    let (val, write_handle) = lock.acquire_write();\n    assert(val == 5 || val == 13);\n    write_handle.release_write(13);\n\n    let read_handle1 = lock.acquire_read();\n    let read_handle2 = lock.acquire_read();\n\n    // We can take multiple read handles at the same time:\n\n    let val1 = read_handle1.borrow();\n    let val2 = read_handle2.borrow();\n\n    // RwLock has a lemma that both read handles have the same value:\n\n    proof { ReadHandle::lemma_readers_match(&read_handle1, &read_handle2); }\n    assert(*val1 == *val2);\n\n    read_handle1.release_read();\n    read_handle2.release_read();\n}\n\n// Using higher-order functions is often cumbersome, we can use traits instead.\n\npub struct FixedParity {\n    pub parity: int,\n}\n\nimpl RwLockPredicate<u64> for FixedParity {\n    open spec fn inv(self, v: u64) -> bool {\n        v % 2 == self.parity\n    }\n}\n\nfn example2() {\n    let lock_even = RwLock::<u64, FixedParity>::new(20, Ghost(FixedParity { parity: 0 }));\n    let lock_odd = RwLock::<u64, FixedParity>::new(23, Ghost(FixedParity { parity: 1 }));\n\n    let read_handle_even = lock_even.acquire_read();\n    let val_even = *read_handle_even.borrow();\n    assert(val_even % 2 == 0);\n\n    let read_handle_odd = lock_odd.acquire_read();\n    let val_odd = *read_handle_odd.borrow();\n    assert(val_odd % 2 == 1);\n}\n\npub fn main() {\n    example1();\n    example2();\n}\n\n}\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\n        use vstd::rwlock::*;\n        verus!{\n       fn example1() ;\n       pub struct FixedParity ;\n       impl RwLockPredicate<u64> for FixedParity {\n          open spec fn inv(self, v: u64) -> bool ;\n      }\n       pub fn main() ;\n       }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/set_from_vec.rs,58,58,1.0,153.024,True,0.9999999999999999,True,['vstd::prelude::'],True,,,True,,,"use vstd::prelude::*;

verus! {

struct VecSet {
    vt: Vec<u64>,
}

impl VecSet {
    pub closed spec fn view(&self) -> Set<u64> {
        self.vt@.to_set()
    }

    pub fn new() -> (s: Self)
        ensures
            s@ =~= Set::<u64>::empty(),
    {
        VecSet { vt: Vec::new() }
    }

    pub fn insert(&mut self, v: u64)
        ensures
            self@ =~= old(self)@.insert(v),
    {
        self.vt.push(v);
        proof {
            broadcast use vstd::seq_lib::group_seq_properties;
        }
        assert(self.vt@ =~= old(self).vt@ + seq![v]);
    }

    pub fn contains(&self, v: u64) -> (contained: bool)
        ensures
            contained == self@.contains(v),
    {
        for i in iter: 0..self.vt.len()
            invariant
                forall|j: nat| j < i ==> self.vt[j as int] != v,
        {
            if self.vt[i] == v {
                return true;
            }
        }
        false
    }
}

fn main() {
    let mut vs: VecSet = VecSet::new();
    assert(vs@ =~= set![]);
    vs.insert(3);
    vs.insert(5);
    let contains2 = vs.contains(2);
    assert(!contains2);
    assert(vs@ =~= set![3, 5]);
}

} // verus!
","use vstd::prelude::*;

verus! {

struct VecSet {
    vt: Vec<u64>,
}

impl VecSet {
    pub closed spec fn view(&self) -> Set<u64> {
        self.vt@.to_set()
    }

    pub fn new() -> (s: Self)
        ensures
            s@ =~= Set::<u64>::empty(),
    {
        VecSet { vt: Vec::new() }
    }

    pub fn insert(&mut self, v: u64)
        ensures
            self@ =~= old(self)@.insert(v),
    {
        self.vt.push(v);
        proof {
            broadcast use vstd::seq_lib::group_seq_properties;
        }
        assert(self.vt@ =~= old(self).vt@ + seq![v]);
    }

    pub fn contains(&self, v: u64) -> (contained: bool)
        ensures
            contained == self@.contains(v),
    {
        for i in iter: 0..self.vt.len()
            invariant
                forall|j: nat| j < i ==> self.vt[j as int] != v,
        {
            if self.vt[i] == v {
                return true;
            }
        }
        false
    }
}

fn main() {
    let mut vs: VecSet = VecSet::new();
    assert(vs@ =~= set![]);
    vs.insert(3);
    vs.insert(5);
    let contains2 = vs.contains(2);
    assert(!contains2);
    assert(vs@ =~= set![3, 5]);
}

} // verus!
","['use vstd::prelude::*;\n\nverus! {\n\nstruct VecSet {\n    vt: Vec<u64>,\n}\n\nimpl VecSet {\n    pub closed spec fn view(&self) -> Set<u64> {\n        self.vt@.to_set()\n    }\n\n    pub fn new() -> (s: Self)\n        ensures\n            s@ =~= Set::<u64>::empty(),\n    {\n        VecSet { vt: Vec::new() }\n    }\n\n    pub fn insert(&mut self, v: u64)\n        ensures\n            self@ =~= old(self)@.insert(v),\n    {\n        self.vt.push(v);\n        proof {\n            broadcast use vstd::seq_lib::group_seq_properties;\n        }\n        assert(self.vt@ =~= old(self).vt@ + seq![v]);\n    }\n\n    pub fn contains(&self, v: u64) -> (contained: bool)\n        ensures\n            contained == self@.contains(v),\n    {\n        for i in iter: 0..self.vt.len()\n            invariant\n                forall|j: nat| j < i ==> self.vt[j as int] != v,\n        {\n            if self.vt[i] == v {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn main() {\n    let mut vs: VecSet = VecSet::new();\n    assert(vs@ =~= set![]);\n    vs.insert(3);\n    vs.insert(5);\n    let contains2 = vs.contains(2);\n    assert(!contains2);\n    assert(vs@ =~= set![3, 5]);\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/adder_with_max.rs,68,68,1.0,153.392,True,0.7999999999999999,False,"['verus_builtin::', 'vstd::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,,,,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::tokenized_state_machine;

tokenized_state_machine! {
    AdderWithMax {
        fields {
            #[sharding(constant)]
            pub maximum: int,

            #[sharding(variable)]
            pub number: int,

            #[sharding(not_tokenized)]
            pub minimum: int,
        }

        init!{
            initialize(m: int) {
                require(m >= 0);
                init number = 0;
                init minimum = 0;
                init maximum = m;
            }
        }

        transition!{
            add(n: int) {
                require(n >= 0);
                require(pre.number + n <= pre.maximum);
                update number = pre.number + n;
            }
        }

        transition!{
            change_to_minimum() {
                birds_eye let min = pre.minimum;
                update number = min;
            }
        }

        #[invariant]
        pub fn is_bounded_below(&self) -> bool {
            self.number >= self.minimum
        }

        #[invariant]
        pub fn is_bounded_above(&self) -> bool {
            self.number <= self.maximum
        }

        #[inductive(initialize)]
        fn init_preserves(post: Self, m: int) {
        }

        #[inductive(add)]
        fn add_preserves(pre: Self, post: Self, n: int) {
        }

        #[inductive(change_to_minimum)]
        fn change_to_minimum_inductive(pre: Self, post: Self) { }
    }
}

fn main() {}
","// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::tokenized_state_machine;

tokenized_state_machine! {
    AdderWithMax {
        fields {
            #[sharding(constant)]
            pub maximum: int,

            #[sharding(variable)]
            pub number: int,

            #[sharding(not_tokenized)]
            pub minimum: int,
        }

        init!{
            initialize(m: int) {
                require(m >= 0);
                init number = 0;
                init minimum = 0;
                init maximum = m;
            }
        }

        transition!{
            add(n: int) {
                require(n >= 0);
                require(pre.number + n <= pre.maximum);
                update number = pre.number + n;
            }
        }

        transition!{
            change_to_minimum() {
                birds_eye let min = pre.minimum;
                update number = min;
            }
        }

        #[invariant]
        pub fn is_bounded_below(&self) -> bool {
            self.number >= self.minimum
        }

        #[invariant]
        pub fn is_bounded_above(&self) -> bool {
            self.number <= self.maximum
        }

        #[inductive(initialize)]
        fn init_preserves(post: Self, m: int) {
        }

        #[inductive(add)]
        fn add_preserves(pre: Self, post: Self, n: int) {
        }

        #[inductive(change_to_minimum)]
        fn change_to_minimum_inductive(pre: Self, post: Self) { }
    }
}

fn main() {}
","['// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {\n    AdderWithMax {\n        fields {\n            #[sharding(constant)]\n            pub maximum: int,\n\n            #[sharding(variable)]\n            pub number: int,\n\n            #[sharding(not_tokenized)]\n            pub minimum: int,\n        }\n\n        init!{\n            initialize(m: int) {\n                require(m >= 0);\n                init number = 0;\n                init minimum = 0;\n                init maximum = m;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                require(n >= 0);\n                require(pre.number + n <= pre.maximum);\n                update number = pre.number + n;\n            }\n        }\n\n        transition!{\n            change_to_minimum() {\n                birds_eye let min = pre.minimum;\n                update number = min;\n            }\n        }\n\n        #[invariant]\n        pub fn is_bounded_below(&self) -> bool {\n            self.number >= self.minimum\n        }\n\n        #[invariant]\n        pub fn is_bounded_above(&self) -> bool {\n            self.number <= self.maximum\n        }\n\n        #[inductive(initialize)]\n        fn init_preserves(post: Self, m: int) {\n        }\n\n        #[inductive(add)]\n        fn add_preserves(pre: Self, post: Self, n: int) {\n        }\n\n        #[inductive(change_to_minimum)]\n        fn change_to_minimum_inductive(pre: Self, post: Self) { }\n    }\n}\n\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n           fn main() {\n }\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/arc.rs,331,104,0.31419939577039274,1017.35,True,0.9,False,"['verus_builtin::', 'verus_builtin_macros::', 'verus_state_machines_macros::tokenized_state_machine', 'vstd::cell::', 'vstd::invariant::', 'vstd::modes::', 'vstd::multiset::', 'vstd::prelude::', 'vstd::simple_pptr::', 'vstd::', 'vstd::shared::']",True,,,True,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#![allow(unused_imports)]

// ANCHOR: full
use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::tokenized_state_machine;
use vstd::cell::*;
use vstd::invariant::*;
use vstd::modes::*;
use vstd::multiset::*;
use vstd::prelude::*;
use vstd::simple_pptr::*;
use vstd::{atomic::*, pervasive::*, *};
use vstd::shared::*;

verus! {

// ANCHOR: fields
tokenized_state_machine!(RefCounter<Perm> {
    fields {
        #[sharding(variable)]
        pub counter: nat,

        #[sharding(storage_option)]
        pub storage: Option<Perm>,

        #[sharding(multiset)]
        pub reader: Multiset<Perm>,
    }
// ANCHOR_END: fields

    #[invariant]
    pub fn reader_agrees_storage(&self) -> bool {
        forall |t: Perm| self.reader.count(t) > 0 ==>
            self.storage == Option::Some(t)
    }

    #[invariant]
    pub fn counter_agrees_storage(&self) -> bool {
        self.counter == 0 ==> self.storage is None
    }

    #[invariant]
    pub fn counter_agrees_storage_rev(&self) -> bool {
        self.storage is None ==> self.counter == 0
    }

    #[invariant]
    pub fn counter_agrees_reader_count(&self) -> bool {
        self.storage is Some ==>
            self.reader.count(self.storage->0) == self.counter
    }

    init!{
        initialize_empty() {
            init counter = 0;
            init storage = Option::None;
            init reader = Multiset::empty();
        }
    }

    #[inductive(initialize_empty)]
    fn initialize_empty_inductive(post: Self) { }

    transition!{
        do_deposit(x: Perm) {
            require(pre.counter == 0);
            update counter = 1;
            deposit storage += Some(x);
            add reader += {x};
        }
    }

    #[inductive(do_deposit)]
    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }

    property!{
        reader_guard(x: Perm) {
            have reader >= {x};
            guard storage >= Some(x);
        }
    }

    transition!{
        do_clone(x: Perm) {
            have reader >= {x};
            add reader += {x};
            update counter = pre.counter + 1;
        }
    }

    #[inductive(do_clone)]
    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {
        assert(pre.reader.count(x) > 0);
        assert(pre.storage == Option::Some(x));
        assert(pre.storage is Some);
        assert(pre.counter > 0);
    }

    transition!{
        dec_basic(x: Perm) {
            require(pre.counter >= 2);
            remove reader -= {x};
            update counter = (pre.counter - 1) as nat;
        }
    }

    transition!{
        dec_to_zero(x: Perm) {
            remove reader -= {x};
            require(pre.counter < 2);
            assert(pre.counter == 1);
            update counter = 0;
            withdraw storage -= Some(x);
        }
    }

    #[inductive(dec_basic)]
    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {
        assert(pre.reader.count(x) > 0);
        assert(pre.storage == Option::Some(x));
    }

    #[inductive(dec_to_zero)]
    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }
});

pub struct InnerArc<S> {
    pub rc_cell: PAtomicU64,
    pub s: S,
}

pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;

pub tracked struct GhostStuff<S> {
    pub tracked rc_perm: PermissionU64,
    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,
}

impl<S> GhostStuff<S> {
    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {
        &&& self.rc_perm@.patomic == cell.id()
        &&& self.rc_token.instance_id() == inst.id()
        &&& self.rc_perm@.value as nat == self.rc_token.value()
    }
}

impl<S> InnerArc<S> {
    spec fn wf(self, cell: PAtomicU64) -> bool {
        self.rc_cell == cell
    }
}

struct_with_invariants!{
    struct MyArc<S> {
        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,
        pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,
        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,

        pub ptr: PPtr<InnerArc<S>>,

        pub rc_cell: Ghost< PAtomicU64 >,
    }

    spec fn wf(self) -> bool {
        predicate {
            &&& self.reader@.element().pptr() == self.ptr
            &&& self.reader@.element().pptr() == self.ptr

            &&& self.reader@.instance_id() == self.inst@.id()
            &&& self.reader@.element().is_init()
            &&& self.reader@.element().value().rc_cell == self.rc_cell
        }

        invariant on inv with (inst, rc_cell)
            specifically (self.inv@@)
            is (v: GhostStuff<S>)
        {
            v.wf(inst@, rc_cell@)
        }
    }
}

impl<S> MyArc<S> {
    spec fn view(self) -> S {
        self.reader@.element().value().s
    }

    fn new(s: S) -> (rc: Self)
        ensures
            rc.wf(),
            rc@ == s,
    {
        let (rc_cell, Tracked(rc_perm)) = PAtomicU64::new(1);
        let inner_rc = InnerArc::<S> { rc_cell, s };
        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);
        let tracked (Tracked(inst), Tracked(mut rc_token), _) =
            RefCounter::Instance::initialize_empty(Option::None);
        let tracked reader = inst.do_deposit(
            ptr_perm,
            &mut rc_token,
            ptr_perm,
        );
        let tracked g = GhostStuff::<S> { rc_perm, rc_token };
        let tr_inst = Tracked(inst);
        let gh_cell = Ghost(rc_cell);
        let tracked inv = AtomicInvariant::new((tr_inst, gh_cell), g, 0);
        let tracked inv = Shared::new(inv);
        MyArc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }
    }

    fn borrow<'b>(&'b self) -> (s: &'b S)
        requires
            self.wf(),
        ensures
            *s == self@,
    {
        let tracked inst = self.inst.borrow();
        let tracked reader = self.reader.borrow();
        let tracked perm = inst.reader_guard(reader.element(), &reader);
        &self.ptr.borrow(Tracked(perm)).s
    }

    fn clone(&self) -> (s: Self)
        requires
            self.wf(),
        ensures
            s.wf() && s@ == self@,
    {
        loop
            invariant
                self.wf(),
        {
            let tracked inst = self.inst.borrow();
            let tracked reader = self.reader.borrow();
            let tracked perm = inst.reader_guard(reader.element(), &reader);
            let inner_rc_ref = self.ptr.borrow(Tracked(perm));
            let count: u64;
            open_atomic_invariant!(self.inv.borrow().borrow() => g => {
                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;

                count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));

                proof { g = GhostStuff { rc_perm, rc_token }; }
            });
            assume(count < 100000000);
            let tracked mut new_reader = None;
            let res;
            open_atomic_invariant!(self.inv.borrow().borrow() => g => {
                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;

                res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);

                proof {
                    if res.is_ok() {
                        new_reader = Some(self.inst.borrow().do_clone(
                            reader.element(),
                            &mut rc_token,
                            &reader));
                    }
                }

                proof { g = GhostStuff { rc_perm, rc_token }; }
            });
            if res.is_ok() {
                return MyArc {
                    inst: Tracked(self.inst.borrow().clone()),
                    inv: Tracked(self.inv.borrow().clone()),
                    reader: Tracked(new_reader.tracked_unwrap()),
                    ptr: self.ptr,
                    rc_cell: Ghost(self.rc_cell@),
                };
            }
        }
    }

    fn dispose(self)
        requires
            self.wf(),
    {
        let MyArc {
            inst: Tracked(inst),
            inv: Tracked(inv),
            reader: Tracked(reader),
            ptr,
            rc_cell: _,
        } = self;
        let tracked perm = inst.reader_guard(reader.element(), &reader);
        let inner_rc_ref = &ptr.borrow(Tracked(perm));
        let count;
        let tracked mut inner_rc_perm_opt = None;
        open_atomic_invariant!(inv.borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;

            count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);

            proof {
                if rc_token.value() < 2 {
                    let tracked inner_rc_perm = inst.dec_to_zero(
                        reader.element(), &mut rc_token, reader);
                    inner_rc_perm_opt = Some(inner_rc_perm);
                } else {
                    inst.dec_basic(reader.element(), &mut rc_token, reader);
                }

                g = GhostStuff { rc_perm, rc_token };
            }
        });
        if count == 1 {
            let tracked mut inner_rc_perm = inner_rc_perm_opt.tracked_unwrap();
            let _inner_rc = ptr.take(Tracked(&mut inner_rc_perm));
            ptr.free(Tracked(inner_rc_perm));
        }
    }
}

enum Sequence<V> {
    Nil,
    Cons(V, MyArc<Sequence<V>>),
}

fn main() {
    let nil = MyArc::new(Sequence::Nil);
    let a5 = MyArc::new(Sequence::Cons(5, nil.clone()));
    let a7 = MyArc::new(Sequence::Cons(7, nil.clone()));
    let a67 = MyArc::new(Sequence::Cons(6, a7.clone()));
}

} // verus!
// ANCHOR_END: full
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
 use verus_state_machines_macros::tokenized_state_machine;
    use vstd::invariant::*;
    use vstd::multiset::*;
    use vstd::prelude::*;
    use vstd::simple_pptr::*;
    use vstd::{
  atomic::*, pervasive::*, *};
    use vstd::shared::*;
    verus! {
   tokenized_state_machine!(RefCounter<Perm> {
      fields {
#[sharding(variable)]
        pub counter: nat,            
#[sharding(storage_option)]
        pub storage: Option<Perm>,            
#[sharding(multiset)]
        pub reader: Multiset<Perm>,     }
#[invariant]
    pub fn reader_agrees_storage(&self) -> bool {
         forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }
#[invariant]
    pub fn counter_agrees_storage(&self) -> bool {
         self.counter == 0 ==> self.storage is None     }
#[invariant]
    pub fn counter_agrees_reader_count(&self) -> bool {
         self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }
      init!{
         initialize_empty() {             init counter = 0;             init storage = Option::None;             init reader = Multiset::empty();         }
     }
#[inductive(initialize_empty)]
    fn initialize_empty_inductive(post: Self) {
 }
      transition!{
         do_deposit(x: Perm) {             require(pre.counter == 0);             update counter = 1;             deposit storage += Some(x);             add reader += {x};         }
     }
#[inductive(do_deposit)]
    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) {
 }
      property!{
         reader_guard(x: Perm) {             have reader >= {x};             guard storage >= Some(x);         }
     }
      transition!{
         do_clone(x: Perm) {             have reader >= {x};             add reader += {x};             update counter = pre.counter + 1;         }
     }
#[inductive(do_clone)]
    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {
         assert(pre.reader.count(x) > 0);
         assert(pre.storage == Option::Some(x));
         assert(pre.storage is Some);
         assert(pre.counter > 0);
     }
      transition!{
         dec_basic(x: Perm) {             require(pre.counter >= 2);             remove reader -= {x};             update counter = (pre.counter - 1) as nat;         }
     }
      transition!{
         dec_to_zero(x: Perm) {             remove reader -= {x};             require(pre.counter < 2);             assert(pre.counter == 1);             update counter = 0;             withdraw storage -= Some(x);         }
     }
#[inductive(dec_basic)]
    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {
         assert(pre.reader.count(x) > 0);
         assert(pre.storage == Option::Some(x));
     }
#[inductive(dec_to_zero)]
    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {
 }
  }
  );
   pub struct InnerArc<S> {
      pub rc_cell: PAtomicU64,     pub s: S, }
   pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;
   pub tracked struct GhostStuff<S> {
      pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }
   impl<S> GhostStuff<S> {
      pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {
         &&& self.rc_perm@.patomic == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm@.value as nat == self.rc_token.value()     }
  }
   struct_with_invariants!{
      struct MyArc<S> {
         pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }
      spec fn wf(self) -> bool {
         predicate {             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }
         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }
     }
  }
   impl<S> MyArc<S> {
     fn clone(&self) -> (s: Self)         requires             self.wf(),     {
         loop             invariant                 self.wf(),         {             let tracked inst = self.inst.borrow();             let tracked reader = self.reader.borrow();             let tracked perm = inst.reader_guard(reader.element(), &reader);             let inner_rc_ref = self.ptr.borrow(Tracked(perm));             let count: u64;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             assume(count < 100000000);             let tracked mut new_reader = None;             let res;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);                 proof {                     if res.is_ok() {                         new_reader = Some(self.inst.borrow().do_clone(                             reader.element(),                             &mut rc_token,                             &reader));                     }                 }                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             if res.is_ok() {                 return MyArc {                     inst: Tracked(self.inst.borrow().clone()),                     inv: Tracked(self.inv.borrow().clone()),                     reader: Tracked(new_reader.tracked_unwrap()),                     ptr: self.ptr,                     rc_cell: Ghost(self.rc_cell@),                 };             }         }
     }
     fn dispose(self)         requires             self.wf(),     {
         let MyArc {             inst: Tracked(inst),             inv: Tracked(inv),             reader: Tracked(reader),             ptr,             rc_cell: _,         }
 = self;
         let tracked perm = inst.reader_guard(reader.element(), &reader);
         let inner_rc_ref = &ptr.borrow(Tracked(perm));
         let count;
         let tracked mut inner_rc_perm_opt = None;
         open_atomic_invariant!(inv.borrow() => g => {             let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;             count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);             proof {                 if rc_token.value() < 2 {                     let tracked inner_rc_perm = inst.dec_to_zero(                         reader.element(), &mut rc_token, reader);                     inner_rc_perm_opt = Some(inner_rc_perm);                 } else {                     inst.dec_basic(reader.element(), &mut rc_token, reader);                 }                 g = GhostStuff { rc_perm, rc_token };             }         }
);
         if count == 1 {         }
     }
 }
 fn main() {
 }
 }
","[""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{atomic::*, pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n        assert(pre.counter > 0);\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n            assert(pre.counter == 1);\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerArc<S> {\n    pub rc_cell: PAtomicU64,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: PermissionU64,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n        &&& self.rc_perm@.patomic == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm@.value as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerArc<S> {\n    spec fn wf(self, cell: PAtomicU64) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyArc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerArc<S>>,\n\n        pub rc_cell: Ghost< PAtomicU64 >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyArc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n        ensures\n            rc.wf(),\n            rc@ == s,\n    {\n        let (rc_cell, Tracked(rc_perm)) = PAtomicU64::new(1);\n        let inner_rc = InnerArc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = AtomicInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyArc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n        ensures\n            s.wf() && s@ == self@,\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked inst = self.inst.borrow();\n            let tracked reader = self.reader.borrow();\n            let tracked perm = inst.reader_guard(reader.element(), &reader);\n            let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n            let count: u64;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));\n\n                proof { g = GhostStuff { rc_perm, rc_token }; }\n            });\n            assume(count < 100000000);\n            let tracked mut new_reader = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);\n\n                proof {\n                    if res.is_ok() {\n                        new_reader = Some(self.inst.borrow().do_clone(\n                            reader.element(),\n                            &mut rc_token,\n                            &reader));\n                    }\n                }\n\n                proof { g = GhostStuff { rc_perm, rc_token }; }\n            });\n            if res.is_ok() {\n                return MyArc {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    inv: Tracked(self.inv.borrow().clone()),\n                    reader: Tracked(new_reader.tracked_unwrap()),\n                    ptr: self.ptr,\n                    rc_cell: Ghost(self.rc_cell@),\n                };\n            }\n        }\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyArc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_atomic_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);\n\n            proof {\n                if rc_token.value() < 2 {\n                    let tracked inner_rc_perm = inst.dec_to_zero(\n                        reader.element(), &mut rc_token, reader);\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                } else {\n                    inst.dec_basic(reader.element(), &mut rc_token, reader);\n                }\n\n                g = GhostStuff { rc_perm, rc_token };\n            }\n        });\n        if count == 1 {\n            let tracked mut inner_rc_perm = inner_rc_perm_opt.tracked_unwrap();\n            let _inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n            ptr.free(Tracked(inner_rc_perm));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyArc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyArc::new(Sequence::Nil);\n    let a5 = MyArc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyArc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyArc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n"", 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a<b>{fields{\n#[sharding(storage_option)]\n    pub c : Option<b>\n  }});\n  fn main();\n}\n', '#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use verus_state_machines_macros::tokenized_state_machine;\n    use vstd::invariant::*;\n    use vstd::multiset::*;\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::{\n  atomic::*, pervasive::*, *};\n    use vstd::shared::*;\n    verus! {\n   tokenized_state_machine!(RefCounter<Perm> {\n      fields {\n#[sharding(variable)]\n        pub counter: nat,            \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,            \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n         forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n         self.counter == 0 ==> self.storage is None     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n         self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n      init!{\n         initialize_empty() {             init counter = 0;             init storage = Option::None;             init reader = Multiset::empty();         }\n     }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n }\n      transition!{\n         do_deposit(x: Perm) {             require(pre.counter == 0);             update counter = 1;             deposit storage += Some(x);             add reader += {x};         }\n     }\n#[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) {\n }\n      property!{\n         reader_guard(x: Perm) {             have reader >= {x};             guard storage >= Some(x);         }\n     }\n      transition!{\n         do_clone(x: Perm) {             have reader >= {x};             add reader += {x};             update counter = pre.counter + 1;         }\n     }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n         assert(pre.storage is Some);\n         assert(pre.counter > 0);\n     }\n      transition!{\n         dec_basic(x: Perm) {             require(pre.counter >= 2);             remove reader -= {x};             update counter = (pre.counter - 1) as nat;         }\n     }\n      transition!{\n         dec_to_zero(x: Perm) {             remove reader -= {x};             require(pre.counter < 2);             assert(pre.counter == 1);             update counter = 0;             withdraw storage -= Some(x);         }\n     }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n     }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n }\n  }\n  );\n   pub struct InnerArc<S> {\n      pub rc_cell: PAtomicU64,     pub s: S, }\n   pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n   pub tracked struct GhostStuff<S> {\n      pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n   impl<S> GhostStuff<S> {\n      pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n         &&& self.rc_perm@.patomic == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm@.value as nat == self.rc_token.value()     }\n  }\n   struct_with_invariants!{\n      struct MyArc<S> {\n         pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n      spec fn wf(self) -> bool {\n         predicate {             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }\n     }\n  }\n   impl<S> MyArc<S> {\n     fn clone(&self) -> (s: Self)         requires             self.wf(),     {\n         loop             invariant                 self.wf(),         {             let tracked inst = self.inst.borrow();             let tracked reader = self.reader.borrow();             let tracked perm = inst.reader_guard(reader.element(), &reader);             let inner_rc_ref = self.ptr.borrow(Tracked(perm));             let count: u64;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             assume(count < 100000000);             let tracked mut new_reader = None;             let res;             open_atomic_invariant!(self.inv.borrow().borrow() => g => {                 let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;                 res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);                 proof {                     if res.is_ok() {                         new_reader = Some(self.inst.borrow().do_clone(                             reader.element(),                             &mut rc_token,                             &reader));                     }                 }                 proof { g = GhostStuff { rc_perm, rc_token }; }             });             if res.is_ok() {                 return MyArc {                     inst: Tracked(self.inst.borrow().clone()),                     inv: Tracked(self.inv.borrow().clone()),                     reader: Tracked(new_reader.tracked_unwrap()),                     ptr: self.ptr,                     rc_cell: Ghost(self.rc_cell@),                 };             }         }\n     }\n     fn dispose(self)         requires             self.wf(),     {\n         let MyArc {             inst: Tracked(inst),             inv: Tracked(inv),             reader: Tracked(reader),             ptr,             rc_cell: _,         }\n = self;\n         let tracked perm = inst.reader_guard(reader.element(), &reader);\n         let inner_rc_ref = &ptr.borrow(Tracked(perm));\n         let count;\n         let tracked mut inner_rc_perm_opt = None;\n         open_atomic_invariant!(inv.borrow() => g => {             let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;             count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);             proof {                 if rc_token.value() < 2 {                     let tracked inner_rc_perm = inst.dec_to_zero(                         reader.element(), &mut rc_token, reader);                     inner_rc_perm_opt = Some(inner_rc_perm);                 } else {                     inst.dec_basic(reader.element(), &mut rc_token, reader);                 }                 g = GhostStuff { rc_perm, rc_token };             }         }\n);\n         if count == 1 {         }\n     }\n }\n fn main() {\n }\n }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n     use vstd::invariant::*;\n     use vstd::multiset::*;\n     use vstd::prelude::*;\n     use vstd::simple_pptr::*;\n     use vstd::{\n   atomic::*, pervasive::*, *};\n     use vstd::shared::*;\n     verus! {\n    tokenized_state_machine!(RefCounter<Perm> {\n       fields {\n#[sharding(variable)]\n        pub counter: nat,             \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,             \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n          forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n          self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n       init!{\n          initialize_empty() {\n             init counter = 0;\n             init storage = Option::None;\n             init reader = Multiset::empty();\n         }\n      }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n  }\n       property!{\n          reader_guard(x: Perm) {\n             have reader >= {x};\n             guard storage >= Some(x);\n         }\n      }\n       transition!{\n          do_clone(x: Perm) {\n         }\n      }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n      }\n       transition!{\n          dec_basic(x: Perm) {\n             require(pre.counter >= 2);\n             remove reader -= {x};\n             update counter = (pre.counter - 1) as nat;\n         }\n      }\n       transition!{\n          dec_to_zero(x: Perm) {\n             remove reader -= {x};\n             require(pre.counter < 2);\n             assert(pre.counter == 1);\n             update counter = 0;\n             withdraw storage -= Some(x);\n         }\n      }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n      }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n  }\n   }\n   );\n    pub struct InnerArc<S> {\n       pub rc_cell: PAtomicU64,     pub s: S, }\n    pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n    pub tracked struct GhostStuff<S> {\n       pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n    impl<S> GhostStuff<S> {\n       pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n          &&& self.rc_perm@.patomic == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm@.value as nat == self.rc_token.value()     }\n   }\n    struct_with_invariants!{\n       struct MyArc<S> {\n          pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n       spec fn wf(self) -> bool {\n          predicate {\n             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n          invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n             v.wf(inst@, rc_cell@)         }\n      }\n   }\n    impl<S> MyArc<S> {\n      fn dispose(self)         requires             self.wf(),     {\n          let MyArc {\n             inst: Tracked(inst),             inv: Tracked(inv),             reader: Tracked(reader),             ptr,             rc_cell: _,         }\n  = self;\n          let tracked perm = inst.reader_guard(reader.element(), &reader);\n          let inner_rc_ref = &ptr.borrow(Tracked(perm));\n          let count;\n          let tracked mut inner_rc_perm_opt = None;\n          open_atomic_invariant!(inv.borrow() => g => {\n             let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token }\n = g;\n             count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);\n             proof {                 if rc_token.value() < 2 {                     let tracked inner_rc_perm = inst.dec_to_zero(                         reader.element(), &mut rc_token, reader);                     inner_rc_perm_opt = Some(inner_rc_perm);                 } else {                     inst.dec_basic(reader.element(), &mut rc_token, reader);                 }                 g = GhostStuff { rc_perm, rc_token };             }\n         }\n );\n      }\n  }\n  fn main() {\n  }\n  }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      atomic::*, pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n     }\n          property!{\n             reader_guard(x: Perm) {\n                have reader >= {\n  x};\n                guard storage >= Some(x);\n            }\n         }\n          transition!{\n             do_clone(x: Perm) {\n            }\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         }\n          transition!{\n             dec_basic(x: Perm) {\n                remove reader -= {\n  x};\n                update counter = (pre.counter - 1) as nat;\n            }\n         }\n          transition!{\n             dec_to_zero(x: Perm) {\n                remove reader -= {\n  x};\n                require(pre.counter < 2);\n                assert(pre.counter == 1);\n                update counter = 0;\n            }\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n     }\n      }\n      );\n       pub struct InnerArc<S> {\n          pub rc_cell: PAtomicU64,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n             &&& self.rc_perm@.patomic == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm@.value as nat == self.rc_token.value()     }\n      }\n       struct_with_invariants!{\n          struct MyArc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyArc<S> {\n         fn dispose(self)         requires             self.wf(),     ;\n     }\n     fn main() ;\n     }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      atomic::*, pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n          property!{\n             reader_guard(x: Perm) {}\n         }\n          transition!{\n             do_clone(x: Perm) {}\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n          transition!{\n             dec_basic(x: Perm) {}\n         }\n          transition!{\n             dec_to_zero(x: Perm) {\n                remove reader -= {\n  x};\n                require(pre.counter < 2);\n                assert(pre.counter == 1);\n                update counter = 0;\n            }\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n     }\n      }\n      );\n       pub struct InnerArc<S> {\n          pub rc_cell: PAtomicU64,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool ;\n      }\n       struct_with_invariants!{\n          struct MyArc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyArc<S> {\n         fn dispose(self)         requires             self.wf(),     ;\n     }\n     fn main() ;\n     }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      atomic::*, pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n          property!{\n             reader_guard() {}\n         }\n          transition!{\n             do_clone(x: Perm) {}\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n          transition!{\n             dec_basic(x: Perm) {}\n         }\n          transition!{\n             dec_to_zero(x: Perm) {}\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}\n      }\n      );\n       pub struct InnerArc<S> {\n          pub rc_cell: PAtomicU64,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: PermissionU64,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool ;\n      }\n       struct_with_invariants!{\n          struct MyArc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerArc<S>>,         pub rc_cell: Ghost< PAtomicU64 >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyArc<S> {}\n     fn main() ;\n     }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n           use vstd::multiset::*;\n           use vstd::prelude::*;\n           verus! {\n         tokenized_state_machine!(RefCounter<Perm> {\n           fields {   \n#[sharding(variable)]\n        pub counter: nat,                   \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                   \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n           init!{              initialize_empty() {                 init counter = 0;                 init storage = Option::None;                 init reader = Multiset::empty();             }          }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n           transition!{              do_clone(x: Perm) {}          }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n           transition!{              dec_basic(x: Perm) {}          }\n           transition!{              dec_to_zero(x: Perm) {}          }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}\n       }\n        );\n       fn main() ;\n       }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n              use vstd::multiset::*;\n              use vstd::prelude::*;\n              verus! {\n            tokenized_state_machine!(RefCounter<Perm> {\n              fields {\n#[sharding(variable)]\n        pub counter: nat,                      \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                      \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n              init!{\n                initialize_empty() {\n                  init counter = 0;\n                  init storage = Option::None;\n                  init reader = Multiset::empty();\n              }\n            }\n          }\n           );\n          fn main() ;\n          }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(RefCounter<Perm> {\n                fields {\n#[sharding(variable)]\n        pub counter: nat,\n#[sharding(storage_option)]\n        pub storage: Option<Perm>,\n#[sharding(multiset)]\n        pub reader: Multiset<Perm>}\n                init!{\n                  initialize_empty() {\n                    init counter = 0;\n                    init storage = Option::None;\n                    init reader = Multiset::empty();\n}\n}\n}\n             );\n             fn main();\n             }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(a<b> {\n                fields {\n#[sharding(variable)]\n        pub c: nat,\n#[sharding(storage_option)]\n        pub d: Option<b>,\n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                init!{\n                  f() {\n                    init c = 0;\n                    init d = None;\n                    init e = Multiset::empty();\n}\n}\n}\n             );\n             fn main();\n             }\n', 'use verus_state_machines_macros::tokenized_state_machine;\n     use vstd::prelude::*;\n     verus !{\n                  tokenized_state_machine!(a<b> {\n                   fields {\n#[sharding(variable)]\n        pub c: nat,     \n#[sharding(storage_option)]\n        pub d: Option<b>,     \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n   }\n                 );\n                 fn main();\n                 }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(variable)]\n    pub c : nat,\n#[sharding(storage_option)]\n    pub d : Option< b >,\n#[sharding(multiset)]\n    pub e : Multiset< b >\n  }});\n  fn main();\n}\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(storage_option)]\n    pub d : Option< b >,\n#[sharding(multiset)]\n    pub e : Multiset< b >\n  }});\n  fn main();\n}\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(storage_option)]\n    pub d : Option< b >,\n}});\n  fn main();\n}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/conditional.rs,114,6,0.05263157894736842,186.132,True,0.7,False,"['verus_builtin::', 'vstd::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,,,,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::tokenized_state_machine;

#[verifier::spec]
pub enum Foo {
    Bar(int),
    Qax(int),
    Duck(int),
}

tokenized_state_machine!(
    X {
        fields {
            #[sharding(variable)]
            pub a: int,

            #[sharding(variable)]
            pub b: int,

            #[sharding(variable)]
            pub c: int,
        }

        init!{
            initialize(cond: bool) {
                init a = 0;
                init b = 1;
                if cond {
                    init c = 2;
                } else if cond {
                    init c = 3;
                } else {
                    init c = 4;
                }
            }
        }

        init!{
            initialize2(foo: Foo) {
                init a = 0;
                init b = 1;
                match foo {
                    Foo::Bar(x) => {
                        init c = 2;
                    }
                    Foo::Qax(y) => {
                        init c = 3;
                    }
                    Foo::Duck(z) => {
                        init c = 4;
                    }
                }
            }
        }

        transition!{
            add(n: int) {
                update a = 0;
                if n >= 0 {
                    update b = pre.b + n;
                } else {
                    update b = pre.b - n;
                    update c = 15;
                }
            }
        }

        transition!{
            add2(n: int) {
                update a = 0;
                if n >= 0 {
                    update c = 15;
                    update b = pre.b + n;
                } else {
                    update b = pre.b - n;
                }
            }
        }

        transition!{
            foo(n: int) {
                require(n >= 1);
                assert(n >= 1);
                let x: int = n + 2;
                if n >= 5 {
                    require(n < 10);
                    assert(x != 4);
                } else {
                    update c = 12;
                }
                require(n != 1001);
            }
        }

        #[inductive(foo)]
        fn foo_inductive(pre: Self, post: Self, n: int) { }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, cond: bool) { }

        #[inductive(add)]
        fn add_inductive(pre: Self, post: Self, n: int) { }

        #[inductive(add2)]
        fn add2_inductive(pre: Self, post: Self, n: int) { }

    }
);

fn main() {}
","use verus_builtin::*;
         use verus_state_machines_macros::tokenized_state_machine;
       pub enum Foo {}
         tokenized_state_machine!(     X {                fields {}            }
         );
         fn main() {}
","['// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n#[verifier::spec]\npub enum Foo {\n    Bar(int),\n    Qax(int),\n    Duck(int),\n}\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub a: int,\n\n            #[sharding(variable)]\n            pub b: int,\n\n            #[sharding(variable)]\n            pub c: int,\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init a = 0;\n                init b = 1;\n                if cond {\n                    init c = 2;\n                } else if cond {\n                    init c = 3;\n                } else {\n                    init c = 4;\n                }\n            }\n        }\n\n        init!{\n            initialize2(foo: Foo) {\n                init a = 0;\n                init b = 1;\n                match foo {\n                    Foo::Bar(x) => {\n                        init c = 2;\n                    }\n                    Foo::Qax(y) => {\n                        init c = 3;\n                    }\n                    Foo::Duck(z) => {\n                        init c = 4;\n                    }\n                }\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                update a = 0;\n                if n >= 0 {\n                    update b = pre.b + n;\n                } else {\n                    update b = pre.b - n;\n                    update c = 15;\n                }\n            }\n        }\n\n        transition!{\n            add2(n: int) {\n                update a = 0;\n                if n >= 0 {\n                    update c = 15;\n                    update b = pre.b + n;\n                } else {\n                    update b = pre.b - n;\n                }\n            }\n        }\n\n        transition!{\n            foo(n: int) {\n                require(n >= 1);\n                assert(n >= 1);\n                let x: int = n + 2;\n                if n >= 5 {\n                    require(n < 10);\n                    assert(x != 4);\n                } else {\n                    update c = 12;\n                }\n                require(n != 1001);\n            }\n        }\n\n        #[inductive(foo)]\n        fn foo_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(add2)]\n        fn add2_inductive(pre: Self, post: Self, n: int) { }\n\n    }\n);\n\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n         use verus_state_machines_macros::tokenized_state_machine;\n       pub enum Foo {}\n         tokenized_state_machine!(     X {                fields {}            }\n         );\n         fn main() {}\n', 'use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(X{fields{}});\nfn main() {}\n', 'use verus_builtin;\nuse verus_state_machines_macros;\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/counting.rs,267,127,0.4756554307116105,1308.465,True,0.9,False,"['verus_builtin::', 'vstd::prelude::', 'vstd::multiset::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,,,,"#![allow(unused_imports)]

use verus_builtin::*;
use vstd::prelude::*;
use vstd::multiset::*;
use verus_state_machines_macros::tokenized_state_machine;

tokenized_state_machine!{ CountingPermissions<T> {
    fields {
        #[sharding(storage_option)]
        pub stored: Option<T>,

        #[sharding(variable)]
        pub main_counter: Option<(nat, T)>,

        #[sharding(multiset)]
        pub read_ref: Multiset<T>,
    }

    init!{
        new() {
            init stored = None;
            init main_counter = None;
            init read_ref = Multiset::empty();
        }
    }

    transition!{
        writeable_to_readable(t: T) {
            require pre.main_counter.is_none();
            update main_counter = Some((0, t));
            deposit stored += Some(t);
        }
    }

    transition!{
        readable_to_writeable() {
            require let Some((count, t)) = pre.main_counter;
            require count == 0;
            update main_counter = None;
            withdraw stored -= Some(t);
        }
    }

    transition!{
        new_ref() {
            require let Some((count, t)) = pre.main_counter;
            update main_counter = Some((count + 1, t));
            add read_ref += { t };
        }
    }

    transition!{
        delete_ref(t1: T) {
            remove read_ref -= { t1 };
            require let Some((count, t2)) = pre.main_counter;
            assert count >= 1;
            assert t1 == t2;
            update main_counter = Some(((count - 1) as nat, t1));
        }
    }

    property!{
        compare_refs(t1: T, t2: T) {
            have read_ref >= { t1 };
            have read_ref >= { t2 };
            assert t1 == t2;
        }
    }

    property!{
        compare_ref_and_counter(t1: T) {
            have read_ref >= { t1 };
            require let Some((count, t2)) = pre.main_counter;
            assert count >= 1;
            assert t1 == t2;
        }
    }

    property!{
        read_ref_guards(t: T) {
            have read_ref >= { t };
            guard stored >= Some(t);
        }
    }

    property!{
        counter_guards() {
            require let Some((count, t)) = pre.main_counter;
            guard stored >= Some(t);
        }
    }

    #[invariant]
    pub spec fn main_inv(&self) -> bool {
        match self.stored {
            None => {
                &&& self.main_counter.is_none()
                &&& self.read_ref =~= Multiset::empty()
            }
            Some(t) => {
                match self.main_counter {
                    Some((count, t1)) => {
                        &&& t == t1
                        &&& self.read_ref.count(t) == count
                        &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)
                    }
                    None => false,
                }
            }
        }
    }

    #[inductive(new)]
    fn new_inductive(post: Self) { }
   
    #[inductive(writeable_to_readable)]
    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) { }
   
    #[inductive(readable_to_writeable)]
    fn readable_to_writeable_inductive(pre: Self, post: Self) { }
   
    #[inductive(new_ref)]
    fn new_ref_inductive(pre: Self, post: Self) { }
   
    #[inductive(delete_ref)]
    fn delete_ref_inductive(pre: Self, post: Self, t1: T) { }
}}

verus!{

tracked struct Instance<T> {
    tracked instance: CountingPermissions::Instance<T>,
}

tracked struct MainCounter<T> {
    tracked token: CountingPermissions::main_counter<T>,
}

tracked struct ReadRef<T> {
    tracked token: CountingPermissions::read_ref<T>
}

impl<T> MainCounter<T> {
    pub closed spec fn instance_id(self) -> InstanceId {
        self.token.instance_id()
    }

    pub closed spec fn value(self) -> Option<(nat, T)> {
        self.token.value()
    }
}

impl<T> ReadRef<T> {
    pub closed spec fn instance_id(self) -> InstanceId {
        self.token.instance_id()
    }

    pub closed spec fn value(self) -> T {
        self.token.element()
    }
}

impl<T> Instance<T> {
    pub closed spec fn id(self) -> InstanceId {
      self.instance.id()
    }

    proof fn new() -> (tracked res: (Instance<T>, MainCounter<T>))
        ensures
            res.1.instance_id() == res.0.id(),
            res.1.value() === None
    {
        let tracked (Tracked(inst), Tracked(c), Tracked(_r)) =
            CountingPermissions::Instance::new(None);
        (Instance { instance: inst }, MainCounter { token: c })
    }

    proof fn writeable_to_readable(
        tracked &self,
        tracked counter: &mut MainCounter<T>,
        tracked t: T
    )
        requires
            old(counter).instance_id() == self.id(),
            old(counter).value() === None,
        ensures
            counter.instance_id() == self.id(),
            counter.value() === Some((0, t)),
    {
        self.instance.writeable_to_readable(t, t, &mut counter.token);
    }

    proof fn readable_to_writeable(
        tracked &self,
        tracked counter: &mut MainCounter<T>,
    ) -> (tracked t: T)
        requires
            old(counter).instance_id() == self.id(),
            match old(counter).value() {
                None => false,
                Some((count, _)) => count == 0,
            }
        ensures
            counter.instance_id() == self.id(),
            counter.value() === None,
            t == old(counter).value().unwrap().1,
    {
        self.instance.readable_to_writeable(&mut counter.token)
    }

    proof fn new_ref(
        tracked &self,
        tracked counter: &mut MainCounter<T>,
    ) -> (tracked read_ref: ReadRef<T>)
        requires
            old(counter).instance_id() == self.id(),
            old(counter).value().is_some()
        ensures
            counter.instance_id() == self.id(),
            match old(counter).value() {
                None => false,
                Some((count, t)) =>
                    counter.value() == Some((count + 1, t))
                      && read_ref.value() == t
            },
    {
        ReadRef { token: self.instance.new_ref(&mut counter.token) }
    }

    proof fn delete_ref(
        tracked &self,
        tracked counter: &mut MainCounter<T>,
        tracked read_ref: ReadRef<T>,
    )
        requires
            old(counter).instance_id() == self.id(),
            old(counter).value().is_some(),
            read_ref.instance_id() == self.id(),
        ensures
            counter.instance_id() == self.id(),
            match old(counter).value() {
                None => false,
                Some((count, t)) =>
                    count >= 1
                      && counter.value() == Some(((count - 1) as nat, t))
            },
    {
        self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)
    }

    proof fn read_ref_guards<'a>(
        tracked &self,
        tracked read_ref: &'a ReadRef<T>,
    ) -> (tracked borrowed_t: &'a T)
        requires
            read_ref.instance_id() == self.id(),
        ensures
            borrowed_t == read_ref.value()
    {
        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)
    }
}

}

fn main() { }
"," use vstd::prelude::*;
     use vstd::multiset::*;
     use verus_state_machines_macros::tokenized_state_machine;
     tokenized_state_machine!{
    CountingPermissions<T> {
       fields {
#[sharding(storage_option)]
        pub stored: Option<T>,             
#[sharding(variable)]
        pub main_counter: Option<(nat, T)>,             
#[sharding(multiset)]
        pub read_ref: Multiset<T>,     }
       init!{
          new() {
             init stored = None;
             init main_counter = None;
             init read_ref = Multiset::empty();
         }
      }
       transition!{
          writeable_to_readable(t: T) {
             require pre.main_counter.is_none();
             update main_counter = Some((0, t));
             deposit stored += Some(t);
         }
      }
       transition!{
          readable_to_writeable() {
             require let Some((count, t)) = pre.main_counter;
             require count == 0;
             update main_counter = None;
             withdraw stored -= Some(t);
         }
      }
       transition!{
          new_ref() {
             require let Some((count, t)) = pre.main_counter;
             update main_counter = Some((count + 1, t));
             add read_ref += { t };
         }
      }
       transition!{
          delete_ref(t1: T) {
             remove read_ref -= { t1 };
             require let Some((count, t2)) = pre.main_counter;
             assert count >= 1;
             assert t1 == t2;
             update main_counter = Some(((count - 1) as nat, t1));
         }
      }
       property!{
          read_ref_guards(t: T) {
             have read_ref >= { t };
             guard stored >= Some(t);
         }
      }
#[invariant]
    pub spec fn main_inv(&self) -> bool {
          match self.stored {
             None => {                 &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }
             Some(t) => {                 match self.main_counter {                     Some((count, t1)) => {                         &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }                     None => false,                 }             }
         }
      }
#[inductive(new)]
    fn new_inductive(post: Self) {
  }
#[inductive(writeable_to_readable)]
    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {
  }
#[inductive(readable_to_writeable)]
    fn readable_to_writeable_inductive(pre: Self, post: Self) {
  }
#[inductive(new_ref)]
    fn new_ref_inductive(pre: Self, post: Self) {
  }
#[inductive(delete_ref)]
    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {
  }
   }
   }
     verus!{
    tracked struct Instance<T> {
       tracked instance: CountingPermissions::Instance<T>, }
    tracked struct MainCounter<T> {
       tracked token: CountingPermissions::main_counter<T>, }
    tracked struct ReadRef<T> {
       tracked token: CountingPermissions::read_ref<T> }
    impl<T> MainCounter<T> {
       pub closed spec fn instance_id(self) -> InstanceId {
          self.token.instance_id()     }
       pub closed spec fn value(self) -> Option<(nat, T)> {
          self.token.value()     }
   }
    impl<T> ReadRef<T> {
       pub closed spec fn instance_id(self) -> InstanceId {
          self.token.instance_id()     }
       pub closed spec fn value(self) -> T {
          self.token.element()     }
   }
    impl<T> Instance<T> {
       pub closed spec fn id(self) -> InstanceId {
        self.instance.id()     }
       proof fn readable_to_writeable(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked t: T)         requires             old(counter).instance_id() == self.id(),             match old(counter).value() {
                  None => false,                 Some((count, _)) => count == 0,             }
           ensures             counter.instance_id() == self.id(),             counter.value() === None,             t == old(counter).value().unwrap().1,     {
          self.instance.readable_to_writeable(&mut counter.token)     }
       proof fn new_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked read_ref: ReadRef<T>)         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some()         ensures             counter.instance_id() == self.id(),             match old(counter).value() {
                  None => false,                 Some((count, t)) =>                     counter.value() == Some((count + 1, t))                       && read_ref.value() == t             }
  ,     {
          ReadRef {
 token: self.instance.new_ref(&mut counter.token) }
      }
       proof fn delete_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,         tracked read_ref: ReadRef<T>,     )         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some(),             read_ref.instance_id() == self.id(),         ensures             counter.instance_id() == self.id(),             match old(counter).value() {
                  None => false,                 Some((count, t)) =>                     count >= 1                       && counter.value() == Some(((count - 1) as nat, t))             }
  ,     {
          self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)     }
       proof fn read_ref_guards<'a>(
        tracked &self,
        tracked read_ref: &'a ReadRef<T>,     ) -> (tracked borrowed_t: &'a T)
        requires
            read_ref.instance_id() == self.id(),
    {
        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)
    }
}
}
fn main() { }
","[""#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine!{ CountingPermissions<T> {\n    fields {\n        #[sharding(storage_option)]\n        pub stored: Option<T>,\n\n        #[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,\n\n        #[sharding(multiset)]\n        pub read_ref: Multiset<T>,\n    }\n\n    init!{\n        new() {\n            init stored = None;\n            init main_counter = None;\n            init read_ref = Multiset::empty();\n        }\n    }\n\n    transition!{\n        writeable_to_readable(t: T) {\n            require pre.main_counter.is_none();\n            update main_counter = Some((0, t));\n            deposit stored += Some(t);\n        }\n    }\n\n    transition!{\n        readable_to_writeable() {\n            require let Some((count, t)) = pre.main_counter;\n            require count == 0;\n            update main_counter = None;\n            withdraw stored -= Some(t);\n        }\n    }\n\n    transition!{\n        new_ref() {\n            require let Some((count, t)) = pre.main_counter;\n            update main_counter = Some((count + 1, t));\n            add read_ref += { t };\n        }\n    }\n\n    transition!{\n        delete_ref(t1: T) {\n            remove read_ref -= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n            update main_counter = Some(((count - 1) as nat, t1));\n        }\n    }\n\n    property!{\n        compare_refs(t1: T, t2: T) {\n            have read_ref >= { t1 };\n            have read_ref >= { t2 };\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        compare_ref_and_counter(t1: T) {\n            have read_ref >= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        read_ref_guards(t: T) {\n            have read_ref >= { t };\n            guard stored >= Some(t);\n        }\n    }\n\n    property!{\n        counter_guards() {\n            require let Some((count, t)) = pre.main_counter;\n            guard stored >= Some(t);\n        }\n    }\n\n    #[invariant]\n    pub spec fn main_inv(&self) -> bool {\n        match self.stored {\n            None => {\n                &&& self.main_counter.is_none()\n                &&& self.read_ref =~= Multiset::empty()\n            }\n            Some(t) => {\n                match self.main_counter {\n                    Some((count, t1)) => {\n                        &&& t == t1\n                        &&& self.read_ref.count(t) == count\n                        &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)\n                    }\n                    None => false,\n                }\n            }\n        }\n    }\n\n    #[inductive(new)]\n    fn new_inductive(post: Self) { }\n   \n    #[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) { }\n   \n    #[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) { }\n   \n    #[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) { }\n   \n    #[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) { }\n}}\n\nverus!{\n\ntracked struct Instance<T> {\n    tracked instance: CountingPermissions::Instance<T>,\n}\n\ntracked struct MainCounter<T> {\n    tracked token: CountingPermissions::main_counter<T>,\n}\n\ntracked struct ReadRef<T> {\n    tracked token: CountingPermissions::read_ref<T>\n}\n\nimpl<T> MainCounter<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> Option<(nat, T)> {\n        self.token.value()\n    }\n}\n\nimpl<T> ReadRef<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> T {\n        self.token.element()\n    }\n}\n\nimpl<T> Instance<T> {\n    pub closed spec fn id(self) -> InstanceId {\n      self.instance.id()\n    }\n\n    proof fn new() -> (tracked res: (Instance<T>, MainCounter<T>))\n        ensures\n            res.1.instance_id() == res.0.id(),\n            res.1.value() === None\n    {\n        let tracked (Tracked(inst), Tracked(c), Tracked(_r)) =\n            CountingPermissions::Instance::new(None);\n        (Instance { instance: inst }, MainCounter { token: c })\n    }\n\n    proof fn writeable_to_readable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked t: T\n    )\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value() === None,\n        ensures\n            counter.instance_id() == self.id(),\n            counter.value() === Some((0, t)),\n    {\n        self.instance.writeable_to_readable(t, t, &mut counter.token);\n    }\n\n    proof fn readable_to_writeable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked t: T)\n        requires\n            old(counter).instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, _)) => count == 0,\n            }\n        ensures\n            counter.instance_id() == self.id(),\n            counter.value() === None,\n            t == old(counter).value().unwrap().1,\n    {\n        self.instance.readable_to_writeable(&mut counter.token)\n    }\n\n    proof fn new_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked read_ref: ReadRef<T>)\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value().is_some()\n        ensures\n            counter.instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, t)) =>\n                    counter.value() == Some((count + 1, t))\n                      && read_ref.value() == t\n            },\n    {\n        ReadRef { token: self.instance.new_ref(&mut counter.token) }\n    }\n\n    proof fn delete_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked read_ref: ReadRef<T>,\n    )\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value().is_some(),\n            read_ref.instance_id() == self.id(),\n        ensures\n            counter.instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, t)) =>\n                    count >= 1\n                      && counter.value() == Some(((count - 1) as nat, t))\n            },\n    {\n        self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)\n    }\n\n    proof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,\n    ) -> (tracked borrowed_t: &'a T)\n        requires\n            read_ref.instance_id() == self.id(),\n        ensures\n            borrowed_t == read_ref.value()\n    {\n        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)\n    }\n}\n\n}\n\nfn main() { }\n"", 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a<b> {\n    fields {\n#[sharding(storage_option)]\n      pub c : Option<b>\n    }\n  }\n}\nfn main() {}\n', "" use vstd::prelude::*;\n     use vstd::multiset::*;\n     use verus_state_machines_macros::tokenized_state_machine;\n     tokenized_state_machine!{\n    CountingPermissions<T> {\n       fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,             \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,             \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n       init!{\n          new() {\n             init stored = None;\n             init main_counter = None;\n             init read_ref = Multiset::empty();\n         }\n      }\n       transition!{\n          writeable_to_readable(t: T) {\n             require pre.main_counter.is_none();\n             update main_counter = Some((0, t));\n             deposit stored += Some(t);\n         }\n      }\n       transition!{\n          readable_to_writeable() {\n             require let Some((count, t)) = pre.main_counter;\n             require count == 0;\n             update main_counter = None;\n             withdraw stored -= Some(t);\n         }\n      }\n       transition!{\n          new_ref() {\n             require let Some((count, t)) = pre.main_counter;\n             update main_counter = Some((count + 1, t));\n             add read_ref += { t };\n         }\n      }\n       transition!{\n          delete_ref(t1: T) {\n             remove read_ref -= { t1 };\n             require let Some((count, t2)) = pre.main_counter;\n             assert count >= 1;\n             assert t1 == t2;\n             update main_counter = Some(((count - 1) as nat, t1));\n         }\n      }\n       property!{\n          read_ref_guards(t: T) {\n             have read_ref >= { t };\n             guard stored >= Some(t);\n         }\n      }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n          match self.stored {\n             None => {                 &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }\n             Some(t) => {                 match self.main_counter {                     Some((count, t1)) => {                         &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }                     None => false,                 }             }\n         }\n      }\n#[inductive(new)]\n    fn new_inductive(post: Self) {\n  }\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {\n  }\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n  }\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n  }\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {\n  }\n   }\n   }\n     verus!{\n    tracked struct Instance<T> {\n       tracked instance: CountingPermissions::Instance<T>, }\n    tracked struct MainCounter<T> {\n       tracked token: CountingPermissions::main_counter<T>, }\n    tracked struct ReadRef<T> {\n       tracked token: CountingPermissions::read_ref<T> }\n    impl<T> MainCounter<T> {\n       pub closed spec fn instance_id(self) -> InstanceId {\n          self.token.instance_id()     }\n       pub closed spec fn value(self) -> Option<(nat, T)> {\n          self.token.value()     }\n   }\n    impl<T> ReadRef<T> {\n       pub closed spec fn instance_id(self) -> InstanceId {\n          self.token.instance_id()     }\n       pub closed spec fn value(self) -> T {\n          self.token.element()     }\n   }\n    impl<T> Instance<T> {\n       pub closed spec fn id(self) -> InstanceId {\n        self.instance.id()     }\n       proof fn readable_to_writeable(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked t: T)         requires             old(counter).instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, _)) => count == 0,             }\n           ensures             counter.instance_id() == self.id(),             counter.value() === None,             t == old(counter).value().unwrap().1,     {\n          self.instance.readable_to_writeable(&mut counter.token)     }\n       proof fn new_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,     ) -> (tracked read_ref: ReadRef<T>)         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some()         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, t)) =>                     counter.value() == Some((count + 1, t))                       && read_ref.value() == t             }\n  ,     {\n          ReadRef {\n token: self.instance.new_ref(&mut counter.token) }\n      }\n       proof fn delete_ref(         tracked &self,         tracked counter: &mut MainCounter<T>,         tracked read_ref: ReadRef<T>,     )         requires             old(counter).instance_id() == self.id(),             old(counter).value().is_some(),             read_ref.instance_id() == self.id(),         ensures             counter.instance_id() == self.id(),             match old(counter).value() {\n                  None => false,                 Some((count, t)) =>                     count >= 1                       && counter.value() == Some(((count - 1) as nat, t))             }\n  ,     {\n          self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)     }\n       proof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,     ) -> (tracked borrowed_t: &'a T)\n        requires\n            read_ref.instance_id() == self.id(),\n    {\n        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)\n    }\n}\n}\nfn main() { }\n"", ' use vstd::prelude::*;\n        use vstd::multiset::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n        tokenized_state_machine!{\n       CountingPermissions<T> {\n          fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,                \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,                \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n          init!{\n             new() {\n                init stored = None;\n                init main_counter = None;\n                init read_ref = Multiset::empty();\n            }\n         }\n          transition!{\n             writeable_to_readable(t: T) {}\n         }\n          transition!{\n             readable_to_writeable() {\n                require let Some((count, t)) = pre.main_counter;\n                require count == 0;\n                update main_counter = None;\n                withdraw stored -= Some(t);\n            }\n         }\n          transition!{\n             new_ref() {\n                require let Some((count, t)) = pre.main_counter;\n                update main_counter = Some((count + 1, t));\n                add read_ref += {\n   t };\n            }\n         }\n          transition!{\n             delete_ref(t1: T) {\n                remove read_ref -= {\n   t1 };\n                require let Some((count, t2)) = pre.main_counter;\n                assert count >= 1;\n                assert t1 == t2;\n                update main_counter = Some(((count - 1) as nat, t1));\n            }\n         }\n          property!{\n             read_ref_guards(t: T) {\n                have read_ref >= {\n   t };\n                guard stored >= Some(t);\n            }\n         }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n             match self.stored {\n                None => {\n                   &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }\n                Some(t) => \n                   match self.main_counter {\n                       Some((count, t1)) => {\n                          &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }\n                       None => false,                 }\n               \n            }\n         }\n#[inductive(new)]\n    fn new_inductive(post: Self) {}\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {}\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {}\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {}\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {}\n      }\n      }\n        verus!{}\nfn main() {}\n', ' use vstd::prelude::*;\n            use vstd::multiset::*;\n            use verus_state_machines_macros::tokenized_state_machine;\n            tokenized_state_machine!{\n          CountingPermissions<T> {\n            fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,                    \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,                    \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n            init!{\n              new() {                 init stored = None;                 init main_counter = None;                 init read_ref = Multiset::empty();             }\n          }\n            transition!{\n              writeable_to_readable(t: T) {}\n          }\n            transition!{\n              readable_to_writeable() {                 require let Some((count, t)) = pre.main_counter;                 require count == 0;                 update main_counter = None;                 withdraw stored -= Some(t);             }\n          }\n            transition!{\n              new_ref() {                 require let Some((count, t)) = pre.main_counter;                 update main_counter = Some((count + 1, t));                 add read_ref += {    t };             }\n          }\n            transition!{\n              delete_ref(t1: T) {                 remove read_ref -= {    t1 };                 require let Some((count, t2)) = pre.main_counter;                 assert count >= 1;                 assert t1 == t2;                 update main_counter = Some(((count - 1) as nat, t1));             }\n          }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n              match self.stored {                 None => {                    &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }                 Some(t) =>                     match self.main_counter {                        Some((count, t1)) => {                           &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }                        None => false,                 }                             }\n          }\n#[inductive(new)]\n    fn new_inductive(post: Self) {\n}\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {\n}\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n}\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n}\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {\n}\n        }\n         }\n    fn main() {\n  }\n', ' use vstd::prelude::*;\n              use vstd::multiset::*;\n              use verus_state_machines_macros::tokenized_state_machine;\n              tokenized_state_machine!{\n            CountingPermissions<T> {\n              fields {\n#[sharding(storage_option)]\n        pub stored: Option<T>,                      \n#[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,                      \n#[sharding(multiset)]\n        pub read_ref: Multiset<T>,     }\n              init!{\n                new() {\n                  init stored = None;\n                  init main_counter = None;\n                  init read_ref = Multiset::empty();\n              }\n            }\n              transition!{\n                writeable_to_readable(t: T) {\n }\n            }\n              transition!{\n                readable_to_writeable() {\n              }\n            }\n              transition!{\n                new_ref() {\n              }\n            }\n              transition!{\n                delete_ref(t1: T) {\n              }\n            }\n#[invariant]\n    pub spec fn main_inv(&self) -> bool {\n                match self.stored {\n                  None => {\n                    &&& self.main_counter.is_none()                 &&& self.read_ref =~= Multiset::empty()             }\n                  Some(t) =>                     match self.main_counter {\n                        Some((count, t1)) => {\n                           &&& t == t1                         &&& self.read_ref.count(t) == count                         &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)                     }\n                        None => false,                 }\n                              }\n            }\n#[inductive(new)]\n    fn new_inductive(post: Self) {\n  }\n#[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) {\n  }\n#[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n  }\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n  }\n#[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) {\n  }\n          }\n           }\n      fn main() {\n    }\n', ' use vstd::prelude::*;\n                use vstd::multiset::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                tokenized_state_machine!{\n              a<b> {\n                fields {\n#[sharding(storage_option)]\n        pub c: Option<b>,                        \n#[sharding(variable)]\n        pub d: Option<(nat, b)>,                        \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                init!{\n                  f() {\n                    init c = None;\n                    init d = None;\n                    init e = Multiset::empty();\n                }\n              }\n                transition!{\n                  g(h: b) {\n   }\n              }\n                transition!{\n                  i() {\n                }\n              }\n                transition!{\n                  new_ref() {\n                }\n              }\n                transition!{\n                  j(k: b) {\n                }\n              }\n#[invariant]\n    pub fn main_inv(self) -> bool {\n                  match self.c {\n                    None => {\n                      self.e =~= Multiset::empty()             }\n                    h =>                     match self.d {\n                          Some( k) => {\n                             forall |t0| self.e.count(t0) == 0                     }\n                          None => false}\n                                }\n              }\n#[inductive(f)]\n    fn new_inductive(post: Self) {\n    }\n#[inductive(g)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, h: b) {\n    }\n#[inductive(i)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) {\n    }\n#[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) {\n    }\n#[inductive(j)]\n    fn delete_ref_inductive(pre: Self, post: Self, k: b) {\n    }\n            }\n             }\n        fn main() {\n      }\n', ' use vstd::prelude::*;\n                use vstd::multiset::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                tokenized_state_machine!{\n              a<b> {\n                fields {\n#[sharding(storage_option)]\n        pub c: Option<b>,                        \n#[sharding(variable)]\n        pub d: Option<()>,                        \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                init!{\n                  f() {\n                    init c = None;\n                    init d = None;\n                    init e = Multiset::empty();\n                }\n              }\n                transition!{\n                  g(h: b) {}\n              }\n                transition!{\n                  i() {}\n              }\n                transition!{\n                  new_ref() {}\n              }\n                transition!{\n                  j(k: b) {}\n              }\n#[invariant]\n    pub fn l(self) -> bool {\n                  match self.c {\n                    None => {\n                      self.e =~= Multiset::empty()             }\n                    h =>                     match self.d {\n                          Some( k) => {\n                             forall |m| self.e.count(m) == 0                     }\n                          None => false}\n                                }\n              }\n#[inductive(f)]\n    fn new_inductive(post: Self) {}\n#[inductive(g)]\n    fn n(pre: Self, post: Self, h: b) {}\n#[inductive(i)]\n    fn o(pre: Self, post: Self) {}\n#[inductive(new_ref)]\n    fn p(pre: Self, post: Self) {}\n#[inductive(j)]\n    fn delete_ref_inductive(pre: Self, post: Self, k: b) {}\n            }\n             }\n        fn main() {}\n', ' use vstd::prelude::*;\n                   use vstd::multiset::*;\n                   use verus_state_machines_macros::tokenized_state_machine;\n                   tokenized_state_machine!{\n                a<b> {\n                 fields {   \n#[sharding(storage_option)]\n        pub c: Option<b>,                           \n#[sharding(variable)]\n        pub d: Option<()>,                           \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                 init!{                   f() {                     init c = None;                     init d = None;                     init e = Multiset::empty();                 }               }\n                 transition!{                   g(h: b) {}               }\n                 transition!{                   i() {}               }\n                 transition!{                   new_ref() {}               }\n                 transition!{                   j(k: b) {}               }\n       fn delete_ref_inductive(pre: Self, post: Self, k: b) {}\n             }\n               }\n           fn main() {\n }\n', 'use vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a< b > {\n    fields {\n#[sharding(storage_option)]\n      pub c : Option< b >,\n#[sharding(variable)]\n              pub e : Multiset< b >\n    }\n  }\n}\nfn main() {}\n', 'use vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a< b > {\n    fields {\n#[sharding(storage_option)]\n      pub c : Option< b >,\n}\n  }\n}\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/disk_example.rs,294,294,1.0,,,0.85,False,"['verus_builtin::', 'verus_builtin_macros::', 'verus_state_machines_macros::', 'vstd::map::', 'vstd::modes::', 'vstd::multiset::', 'vstd::option::', 'vstd::pervasive::']",False,other,,,1.0,1.0,"// rust_verify/tests/example.rs ignore --- old experimental example
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::*;
use vstd::map::*;
use vstd::modes::*;
use vstd::multiset::*;
use vstd::option::*;
use vstd::pervasive::*;

verus! {

// Create the ""authoritative-fragmentary"" API for manipulating heap-like things
// (In this case, a disk.)
tokenized_state_machine!{ AuthFrag<#[verifier::reject_recursive_types] K, V> {
    fields {
        #[sharding(variable)]
        pub auth: Map<K, V>,

        #[sharding(map)]
        pub fragments: Map<K, V>,
    }

    #[invariant]
    pub fn the_inv(&self) -> bool {
        self.fragments === self.auth
    }

    init!{
        initialize(m: Map<K, V>) {
            init auth = m;
            init fragments = m;
        }
    }

    transition!{
        update_key(key: K, new_value: V) {
            update auth = pre.auth.insert(key, new_value);

            remove fragments -= [ key => let _ ];
            add fragments += [ key => new_value ];
        }
    }

    property!{
        values_agree(key: K) {
            have fragments >= [ key => let frag_value ];
            assert(pre.auth.dom().contains(key)
                && frag_value === pre.auth.index(key));
        }
    }


    #[inductive(initialize)]
    fn init_inductive(post: Self, m: Map<K, V>) { }

    #[inductive(update_key)]
    fn update_key_inductive(pre: Self, post: Self, key: K, new_value: V) {
        assert_maps_equal!(post.fragments, post.auth);
    }
}}
// We want to show refinement between 2 systems.
// First system: a disk represented by a map from indices to blocks


#[is_variant]
pub enum Block {
    Leaf(u64),
    Node(nat, nat),
}

state_machine!{ DiskSM {
    fields {
        pub disk: Map<nat, Block>,      // root is 0
    }

    // update one of the children of the root

    transition!{
        update_child(left: bool, new_val: u64) {
            // Require that the root block is a node with 2 children.

            require(pre.disk.dom().contains(0));
            require let Block::Node(left_child, right_child) = pre.disk.index(0);

            // Get the address of the left or right child.
            let child = if left { left_child } else { right_child };

            // Require the child to be a leaf.
            require(pre.disk.dom().contains(child));
            require let Block::Leaf(val) = pre.disk.index(child);

            // Update the value at the leaf to a new value.
            update disk[child] = Block::Leaf(new_val);
        }
    }
}}
// state machine 2: tree


#[is_variant]
pub enum Tree {
    Leaf(u64),
    Node(Box<Tree>, Box<Tree>),
}

state_machine!{ TreeSM {
    fields {
        pub tree: Tree,
    }

    // update one of the children of the root

    transition!{
        update_child(left: bool, new_val: u64) {
            require let Tree::Node(left_child, right_child) = pre.tree;
            if left {
                require let Tree::Leaf(old_val_l) = *left_child;
                update tree = Tree::Node(Box::new(Tree::Leaf(new_val), right_child));
            } else {
                require let Tree::Leaf(old_val_r) = *right_child;
                update tree = Tree::Node(left_child, Box::new(Tree::Leaf(new_val)));
            }
        }
    }
}}
// We create the relationship with some intermediary ghost state:
//
// DiskSM::State   -->   DiskInterp   -->   LinearTree   -->   TreeSM::State
//   (spec)                (tracked)          (tracked)           (spec)
// We will devise an explicit function DiskSM::State -> DiskInterp
// and an explicit relation LinearTree -> TreeSM::State
//
// However, the relationship between DiskInterp and LinearTree will be implicit
// via ghost rules.
// First define an ""interpretation"" of the disk state as a linear (tracked) object DiskInterp
// This object uses the ""auth"" token


type DiskInterp = AuthFrag::auth<nat, Block>;

spec fn state_interp_fn(inst: AuthFrag::Instance<nat, Block>, state: DiskSM::State) -> DiskInterp {
    AuthFrag![ inst => auth => state.disk ]
}

// Define the LinearTree type
// This object uses the ""fragment"" tokens. This forces it to be related to the Disk.
pub enum LinearTree {
    Leaf(tracked AuthFrag::fragments<nat, Block>),
    Node(tracked AuthFrag::fragments<nat, Block>, Box<LinearTree>, Box<LinearTree>),
}

// Define the relation between LinearTree and TreeSM::State
spec fn tree_relation_rec(
    inst: AuthFrag::Instance<nat, Block>,
    lt: LinearTree,
    tree: Tree,
    addr: nat,
) -> bool
    decreases lt,
{
    match lt {
        LinearTree::Leaf(frag) => {
            match tree {
                Tree::Leaf(val) => {
                    frag === AuthFrag![ inst => fragments => addr => Block::Leaf(val) ]
                },
                Tree::Node(_, _) => false,
            }
        },
        LinearTree::Node(frag, lt_left, lt_right) => {
            match tree {
                Tree::Leaf(val) => false,
                Tree::Node(tree_left, tree_right) => {
                    &&& frag.instance === inst
                    &&& frag.key === addr
                    &&& frag.value.is_Node()
                    &&& tree_relation_rec(inst, *lt_left, *tree_left, frag.value.get_Node_0())
                    &&& tree_relation_rec(inst, *lt_right, *tree_right, frag.value.get_Node_1())
                },
            }
        },
    }
}

spec fn tree_relation(
    inst: AuthFrag::Instance<nat, Block>,
    lt: LinearTree,
    tree: TreeSM::State,
) -> bool {
    tree_relation_rec(inst, lt, tree.tree, 0)  // root is at 0

}

} // verus!
// refinement proof
// TODO this should return proof, but having trouble with mode-checking
#[verifier::proof]
fn take_step(
    state1: DiskSM::State,
    state2: DiskSM::State,
    is_left: bool,
    new_val: u64,
    #[verifier::proof] inst: AuthFrag::Instance<nat, Block>,
    #[verifier::proof] interp1: AuthFrag::auth<nat, Block>,
    #[verifier::proof] lt1: LinearTree,
    tree1_state: TreeSM::State,
) -> (Tracked<AuthFrag::auth<nat, Block>>, Tracked<LinearTree>, Gho<TreeSM::State>) {
    requires([
        DiskSM::State::update_child(state1, state2, is_left, new_val),
        equal(interp1, state_interp_fn(inst, state1)),
        tree_relation(inst, lt1, tree1_state),
    ]);
    ensures(
        |ret: (Tracked<AuthFrag::auth<nat, Block>>, Tracked<LinearTree>, Gho<TreeSM::State>)| {
            let (Tracked(interp2), Tracked(lt2), Gho(tree2)) = ret;
            equal(interp2, state_interp_fn(inst, state2))
                && TreeSM::State::update_child(tree1_state, tree2, is_left, new_val)
                && tree_relation(inst, lt2, tree2)
        },
    );
    #[verifier::proof]
    let mut interp = interp1;

    let tree1 = tree1_state.tree;

    match lt1 {
        LinearTree::Node(lt_root_fragment, lt_left, lt_right) => {
            inst.values_agree(0, &interp, &lt_root_fragment);

            if is_left {
                let left_address = lt_root_fragment.value.get_Node_0();
                assert(tree_relation_rec(inst, *lt_left, *tree1.get_Node_0(), left_address));

                match *lt_left {
                    LinearTree::Leaf(lt_leaf_fragment) => {
                        inst.values_agree(left_address, &interp, &lt_leaf_fragment);

                        let lt_leaf_fragment_new = inst.update_key(
                            lt_leaf_fragment.key,
                            Block::Leaf(new_val),
                            &mut interp,
                            lt_leaf_fragment,
                        );
                        let lt2 = LinearTree::Node(
                            lt_root_fragment,
                            Box::new(LinearTree::Leaf(lt_leaf_fragment_new)),
                            lt_right,
                        );
                        let interp2 = interp;
                        let tree2 = TreeSM::State {
                            tree: Tree::Node(Box::new(Tree::Leaf(new_val)), tree1.get_Node_1()),
                        };

                        assert(equal(interp2, state_interp_fn(inst, state2)));
                        assert(TreeSM::State::update_child(tree1_state, tree2, is_left, new_val));

                        assert(tree_relation_rec(
                            inst,
                            LinearTree::Leaf(lt_leaf_fragment_new),
                            Tree::Leaf(new_val),
                            left_address,
                        ));
                        assert(tree_relation_rec(inst, lt2, tree2.tree, 0));

                        assert(tree_relation(inst, lt2, tree2));

                        (Tracked(interp2), Tracked(lt2), Gho(tree2))
                    }
                    LinearTree::Node(lt_node_fragment, _, _) => {
                        inst.values_agree(left_address, &interp, &lt_node_fragment);

                        // by assumption, the node should be a leaf
                        proof_from_false()
                    }
                }
            } else {
                // This case should be symmetric to above
                assume(false);
                proof_from_false()
            }
        }
        LinearTree::Leaf(lt_root_fragment) => {
            inst.values_agree(0, &interp, &lt_root_fragment);

            // by assumption, root node should be a Node
            proof_from_false()
        }
    }
}

fn main() {}
","// rust_verify/tests/example.rs ignore --- old experimental example
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::*;
use vstd::map::*;
use vstd::modes::*;
use vstd::multiset::*;
use vstd::option::*;
use vstd::pervasive::*;

verus! {

// Create the ""authoritative-fragmentary"" API for manipulating heap-like things
// (In this case, a disk.)
tokenized_state_machine!{ AuthFrag<#[verifier::reject_recursive_types] K, V> {
    fields {
        #[sharding(variable)]
        pub auth: Map<K, V>,

        #[sharding(map)]
        pub fragments: Map<K, V>,
    }

    #[invariant]
    pub fn the_inv(&self) -> bool {
        self.fragments === self.auth
    }

    init!{
        initialize(m: Map<K, V>) {
            init auth = m;
            init fragments = m;
        }
    }

    transition!{
        update_key(key: K, new_value: V) {
            update auth = pre.auth.insert(key, new_value);

            remove fragments -= [ key => let _ ];
            add fragments += [ key => new_value ];
        }
    }

    property!{
        values_agree(key: K) {
            have fragments >= [ key => let frag_value ];
            assert(pre.auth.dom().contains(key)
                && frag_value === pre.auth.index(key));
        }
    }


    #[inductive(initialize)]
    fn init_inductive(post: Self, m: Map<K, V>) { }

    #[inductive(update_key)]
    fn update_key_inductive(pre: Self, post: Self, key: K, new_value: V) {
        assert_maps_equal!(post.fragments, post.auth);
    }
}}
// We want to show refinement between 2 systems.
// First system: a disk represented by a map from indices to blocks


#[is_variant]
pub enum Block {
    Leaf(u64),
    Node(nat, nat),
}

state_machine!{ DiskSM {
    fields {
        pub disk: Map<nat, Block>,      // root is 0
    }

    // update one of the children of the root

    transition!{
        update_child(left: bool, new_val: u64) {
            // Require that the root block is a node with 2 children.

            require(pre.disk.dom().contains(0));
            require let Block::Node(left_child, right_child) = pre.disk.index(0);

            // Get the address of the left or right child.
            let child = if left { left_child } else { right_child };

            // Require the child to be a leaf.
            require(pre.disk.dom().contains(child));
            require let Block::Leaf(val) = pre.disk.index(child);

            // Update the value at the leaf to a new value.
            update disk[child] = Block::Leaf(new_val);
        }
    }
}}
// state machine 2: tree


#[is_variant]
pub enum Tree {
    Leaf(u64),
    Node(Box<Tree>, Box<Tree>),
}

state_machine!{ TreeSM {
    fields {
        pub tree: Tree,
    }

    // update one of the children of the root

    transition!{
        update_child(left: bool, new_val: u64) {
            require let Tree::Node(left_child, right_child) = pre.tree;
            if left {
                require let Tree::Leaf(old_val_l) = *left_child;
                update tree = Tree::Node(Box::new(Tree::Leaf(new_val), right_child));
            } else {
                require let Tree::Leaf(old_val_r) = *right_child;
                update tree = Tree::Node(left_child, Box::new(Tree::Leaf(new_val)));
            }
        }
    }
}}
// We create the relationship with some intermediary ghost state:
//
// DiskSM::State   -->   DiskInterp   -->   LinearTree   -->   TreeSM::State
//   (spec)                (tracked)          (tracked)           (spec)
// We will devise an explicit function DiskSM::State -> DiskInterp
// and an explicit relation LinearTree -> TreeSM::State
//
// However, the relationship between DiskInterp and LinearTree will be implicit
// via ghost rules.
// First define an ""interpretation"" of the disk state as a linear (tracked) object DiskInterp
// This object uses the ""auth"" token


type DiskInterp = AuthFrag::auth<nat, Block>;

spec fn state_interp_fn(inst: AuthFrag::Instance<nat, Block>, state: DiskSM::State) -> DiskInterp {
    AuthFrag![ inst => auth => state.disk ]
}

// Define the LinearTree type
// This object uses the ""fragment"" tokens. This forces it to be related to the Disk.
pub enum LinearTree {
    Leaf(tracked AuthFrag::fragments<nat, Block>),
    Node(tracked AuthFrag::fragments<nat, Block>, Box<LinearTree>, Box<LinearTree>),
}

// Define the relation between LinearTree and TreeSM::State
spec fn tree_relation_rec(
    inst: AuthFrag::Instance<nat, Block>,
    lt: LinearTree,
    tree: Tree,
    addr: nat,
) -> bool
    decreases lt,
{
    match lt {
        LinearTree::Leaf(frag) => {
            match tree {
                Tree::Leaf(val) => {
                    frag === AuthFrag![ inst => fragments => addr => Block::Leaf(val) ]
                },
                Tree::Node(_, _) => false,
            }
        },
        LinearTree::Node(frag, lt_left, lt_right) => {
            match tree {
                Tree::Leaf(val) => false,
                Tree::Node(tree_left, tree_right) => {
                    &&& frag.instance === inst
                    &&& frag.key === addr
                    &&& frag.value.is_Node()
                    &&& tree_relation_rec(inst, *lt_left, *tree_left, frag.value.get_Node_0())
                    &&& tree_relation_rec(inst, *lt_right, *tree_right, frag.value.get_Node_1())
                },
            }
        },
    }
}

spec fn tree_relation(
    inst: AuthFrag::Instance<nat, Block>,
    lt: LinearTree,
    tree: TreeSM::State,
) -> bool {
    tree_relation_rec(inst, lt, tree.tree, 0)  // root is at 0

}

} // verus!
// refinement proof
// TODO this should return proof, but having trouble with mode-checking
#[verifier::proof]
fn take_step(
    state1: DiskSM::State,
    state2: DiskSM::State,
    is_left: bool,
    new_val: u64,
    #[verifier::proof] inst: AuthFrag::Instance<nat, Block>,
    #[verifier::proof] interp1: AuthFrag::auth<nat, Block>,
    #[verifier::proof] lt1: LinearTree,
    tree1_state: TreeSM::State,
) -> (Tracked<AuthFrag::auth<nat, Block>>, Tracked<LinearTree>, Gho<TreeSM::State>) {
    requires([
        DiskSM::State::update_child(state1, state2, is_left, new_val),
        equal(interp1, state_interp_fn(inst, state1)),
        tree_relation(inst, lt1, tree1_state),
    ]);
    ensures(
        |ret: (Tracked<AuthFrag::auth<nat, Block>>, Tracked<LinearTree>, Gho<TreeSM::State>)| {
            let (Tracked(interp2), Tracked(lt2), Gho(tree2)) = ret;
            equal(interp2, state_interp_fn(inst, state2))
                && TreeSM::State::update_child(tree1_state, tree2, is_left, new_val)
                && tree_relation(inst, lt2, tree2)
        },
    );
    #[verifier::proof]
    let mut interp = interp1;

    let tree1 = tree1_state.tree;

    match lt1 {
        LinearTree::Node(lt_root_fragment, lt_left, lt_right) => {
            inst.values_agree(0, &interp, &lt_root_fragment);

            if is_left {
                let left_address = lt_root_fragment.value.get_Node_0();
                assert(tree_relation_rec(inst, *lt_left, *tree1.get_Node_0(), left_address));

                match *lt_left {
                    LinearTree::Leaf(lt_leaf_fragment) => {
                        inst.values_agree(left_address, &interp, &lt_leaf_fragment);

                        let lt_leaf_fragment_new = inst.update_key(
                            lt_leaf_fragment.key,
                            Block::Leaf(new_val),
                            &mut interp,
                            lt_leaf_fragment,
                        );
                        let lt2 = LinearTree::Node(
                            lt_root_fragment,
                            Box::new(LinearTree::Leaf(lt_leaf_fragment_new)),
                            lt_right,
                        );
                        let interp2 = interp;
                        let tree2 = TreeSM::State {
                            tree: Tree::Node(Box::new(Tree::Leaf(new_val)), tree1.get_Node_1()),
                        };

                        assert(equal(interp2, state_interp_fn(inst, state2)));
                        assert(TreeSM::State::update_child(tree1_state, tree2, is_left, new_val));

                        assert(tree_relation_rec(
                            inst,
                            LinearTree::Leaf(lt_leaf_fragment_new),
                            Tree::Leaf(new_val),
                            left_address,
                        ));
                        assert(tree_relation_rec(inst, lt2, tree2.tree, 0));

                        assert(tree_relation(inst, lt2, tree2));

                        (Tracked(interp2), Tracked(lt2), Gho(tree2))
                    }
                    LinearTree::Node(lt_node_fragment, _, _) => {
                        inst.values_agree(left_address, &interp, &lt_node_fragment);

                        // by assumption, the node should be a leaf
                        proof_from_false()
                    }
                }
            } else {
                // This case should be symmetric to above
                assume(false);
                proof_from_false()
            }
        }
        LinearTree::Leaf(lt_root_fragment) => {
            inst.values_agree(0, &interp, &lt_root_fragment);

            // by assumption, root node should be a Node
            proof_from_false()
        }
    }
}

fn main() {}
",[]
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/dist_rwlock.rs,407,236,0.5798525798525799,523.723,True,0.85,False,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::atomic_ghost::', 'vstd::map::', 'vstd::multiset::', 'vstd::prelude::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,True,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::atomic_ghost::*;
use vstd::map::*;
use vstd::multiset::*;
use vstd::prelude::*;

use verus_state_machines_macros::tokenized_state_machine;

verus! {

tokenized_state_machine!{
    DistRwLock<T> {
        fields {
            #[sharding(constant)]
            pub rc_width: int,

            #[sharding(storage_option)]
            pub storage: Option<T>,

            #[sharding(variable)]
            pub exc_locked: bool,

            #[sharding(map)]
            pub ref_counts: Map<int, int>,

            #[sharding(option)]
            pub exc_pending: Option<int>,

            #[sharding(option)]
            pub exc_guard: Option<()>,

            #[sharding(multiset)]
            pub shared_pending: Multiset<int>,

            #[sharding(multiset)]
            pub shared_guard: Multiset<(int, T)>,
        }

        init!{
            initialize(rc_width: int, init_t: T) {
                require(0 < rc_width);
                init rc_width = rc_width;
                init storage = Option::Some(init_t);
                init exc_locked = false;
                init ref_counts = Map::new(
                    |i| 0 <= i < rc_width,
                    |i| 0,
                );
                init exc_pending = Option::None;
                init exc_guard = Option::None;
                init shared_pending = Multiset::empty();
                init shared_guard = Multiset::empty();
            }
        }

        transition!{
            exc_start() {
                require(!pre.exc_locked);
                update exc_locked = true;
                add exc_pending += Some(0);
            }
        }

        transition!{
            exc_check_count() {
                remove exc_pending -= Some(let r);
                have ref_counts >= [r => 0];

                add exc_pending += Some(r + 1);
            }
        }

        transition!{
            exc_finish() {
                remove exc_pending -= Some(pre.rc_width);
                add exc_guard += Some(());
                withdraw storage -= Some(let _);
            }
        }

        transition!{
            exc_release(t: T) {
                update exc_locked = false;
                remove exc_guard -= Some(());
                deposit storage += Some(t);
            }
        }

        transition!{
            shared_start(r: int) {
                remove ref_counts -= [r => let rc];
                add ref_counts += [r => rc + 1];
                add shared_pending += {r};
            }
        }

        transition!{
            shared_finish(r: int) {
                require(!pre.exc_locked);
                remove shared_pending -= {r};

                birds_eye let t = pre.storage->0;
                add shared_guard += {(r, t)};
            }
        }

        transition!{
            shared_release(val: (int, T)) {
                remove shared_guard -= {val};

                let r = val.0;
                remove ref_counts -= [r => let rc];
                add ref_counts += [r => rc - 1];

                assert(rc > 0) by {
                    assert(0 <= r < pre.rc_width);
                    assert(pre.shared_guard.count(val) > 0);
                    assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);
                    assert(Self::filter_r(pre.shared_guard, r).len() > 0);
                    assert(pre.ref_counts.index(r) > 0);
                };
            }
        }

        property!{
            do_guard(val: (int, T)) {
                have shared_guard >= {val};
                guard storage >= Some(val.1);
            }
        }

        ///// Invariants and proofs

        #[invariant]
        pub fn ref_counts_domain(&self) -> bool {
            &&& 0 < self.rc_width
            &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)
        }

        #[invariant]
        pub fn exc_inv(&self) -> bool {
            &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)
            &&& self.storage is Some <==> self.exc_guard is None
            &&& if let Option::Some(cur_r) = self.exc_pending {
                &&& 0 <= cur_r <= self.rc_width
                &&& self.exc_guard is None
                &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)
            } else {
                true
            }
        }

        #[invariant]
        pub fn shared_pending_in_range(&self) -> bool {
            forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)
        }

        #[invariant]
        pub fn shared_guard_in_range(&self) -> bool {
            forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)
        }

        #[invariant]
        pub fn shared_inv_agree(&self) -> bool {
            forall |v| #[trigger] self.shared_guard.count(v) > 0 ==>
                self.storage === Option::Some(v.1)
        }

        pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {
            shared_guard.filter(|val: (int, T)| val.0 == r)
        }

        #[invariant]
        pub fn shared_counts_agree(&self) -> bool {
            forall |r| 0 <= r < self.rc_width ==>
                #[trigger] self.ref_counts.index(r) ==
                    self.shared_pending.count(r) as int +
                        Self::filter_r(self.shared_guard, r).len() as int
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {
            assert forall |r| 0 <= r < post.rc_width implies
                #[trigger] post.ref_counts.index(r) ==
                    post.shared_pending.count(r) as int +
                        Self::filter_r(post.shared_guard, r).len() as int
            by {
                assert(post.ref_counts.index(r) == 0);
                assert(post.shared_pending.count(r) == 0);
                assert_multisets_equal!(
                    Self::filter_r(post.shared_guard, r),
                    Multiset::empty(),
                );
                assert(Self::filter_r(post.shared_guard, r).len() == 0);
            }
            assert(post.shared_counts_agree());
        }

        #[inductive(exc_start)]
        fn exc_start_inductive(pre: Self, post: Self) {

        }

        #[inductive(exc_check_count)]
        fn exc_check_count_inductive(pre: Self, post: Self) {
            let prev_r = pre.exc_pending->0;
            assert forall |x| #[trigger] post.shared_guard.count(x) > 0
                && x.0 == prev_r implies false
            by {
                assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);
            }
        }

        #[inductive(exc_finish)]
        fn exc_finish_inductive(pre: Self, post: Self) {
        }

        #[inductive(exc_release)]
        fn exc_release_inductive(pre: Self, post: Self, t: T) {

        }

        #[inductive(shared_start)]
        fn shared_start_inductive(pre: Self, post: Self, r: int) { }

        #[inductive(shared_finish)]
        fn shared_finish_inductive(pre: Self, post: Self, r: int) {
            let t = pre.storage->0;

            assert forall |r0| 0 <= r0 < post.rc_width implies
                #[trigger] post.ref_counts.index(r0) ==
                    post.shared_pending.count(r0) as int +
                        Self::filter_r(post.shared_guard, r0).len() as int
            by {
                if r == r0 {
                    assert_multisets_equal!(
                        pre.shared_pending,
                        post.shared_pending.add(Multiset::singleton(r))
                    );
                    assert_multisets_equal!(
                        Self::filter_r(post.shared_guard, r),
                        Self::filter_r(pre.shared_guard, r).add(
                            Multiset::singleton((r, t)))
                    );
                    assert(post.ref_counts.index(r0) ==
                        post.shared_pending.count(r0) as int +
                            Self::filter_r(post.shared_guard, r0).len() as int);
                } else {
                    assert_multisets_equal!(
                          Self::filter_r(post.shared_guard, r0),
                          Self::filter_r(pre.shared_guard, r0)
                    );
                    assert(post.ref_counts.index(r0) ==
                        post.shared_pending.count(r0) as int +
                            Self::filter_r(post.shared_guard, r0).len() as int);
                }
            }
        }

        #[inductive(shared_release)]
        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {
            let r = val.0;
            assert forall |r0| 0 <= r0 < post.rc_width implies
                #[trigger] post.ref_counts.index(r0) ==
                    post.shared_pending.count(r0) as int +
                        Self::filter_r(post.shared_guard, r0).len() as int
            by {
                if r0 == r {
                    assert_multisets_equal!(
                        Self::filter_r(pre.shared_guard, r),
                        Self::filter_r(post.shared_guard, r).add(
                            Multiset::singleton(val))
                    );
                } else {
                    assert_multisets_equal!(
                          Self::filter_r(post.shared_guard, r0),
                          Self::filter_r(pre.shared_guard, r0)
                    );
                }
            }
        }
    }
}

struct_with_invariants!{
    struct RwLock<T> {
        inst: Tracked<DistRwLock::Instance<T>>,
        exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,
        ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,
    }

    spec fn wf(&self) -> bool {

        predicate {
            &&& self.inst@.rc_width() == self.ref_counts@.len()

            &&& forall |i: int| (0 <= i && i < self.ref_counts@.len()) ==>
                #[trigger] self.ref_counts@.index(i).well_formed()
                && self.ref_counts@.index(i).constant() === (self.inst, i)
        }

        invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {
            g.instance_id() == inst@.id()
            && g.value() == b
        }

        invariant on ref_counts with (inst)
            forall |i: int|
            where (0 <= i < self.ref_counts@.len())
            specifically (self.ref_counts@[i])
            is (v: u64, g: DistRwLock::ref_counts<T>)
        {
            g.instance_id() == inst@.id()
            && g.key() == i
            && g.value() == v as int
        }
    }
}

impl<T> RwLock<T> {
    #[verifier::spinoff_prover]
    fn new(rc_width: usize, t: T) -> (s: Self)
        requires
            0 < rc_width,
        ensures
            s.wf(),
    {
        let tracked inst;
        let tracked exc_locked_token;
        let tracked mut ref_counts_tokens;
        proof {
            let tracked (
                Tracked(inst0),
                Tracked(exc_locked_token0),
                Tracked(ref_counts_tokens0),
                _,
                _,
                _,
                _,
            ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));
            inst = inst0;
            exc_locked_token = exc_locked_token0;
            ref_counts_tokens = ref_counts_tokens0;
        }
        let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());
        let exc_locked_atomic = AtomicBool::new(
            Ghost(tracked_inst),
            false,
            Tracked(exc_locked_token),
        );
        let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();
        let mut i: usize = 0;
        assert forall|j: int|
            i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)
              && equal(ref_counts_tokens.index(j), 0)
        by {
            assert(ref_counts_tokens.dom().contains(j));
            assert(equal(ref_counts_tokens.index(j), 0));
        }
        assert(forall|j: int|
            #![trigger( ref_counts_tokens.dom().contains(j) )]
            #![trigger( ref_counts_tokens.index(j) )]
            i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)
              && equal(ref_counts_tokens.index(j), 0)));
        while i < rc_width
            invariant
                i <= rc_width,
                v@.len() == i as int,
                forall|j: int|
                    0 <= j && j < i ==> #[trigger] v@.index(j).well_formed()
                      && equal(v@.index(j).constant(), (tracked_inst, j)),
                tracked_inst@ == inst,
                ref_counts_tokens.instance_id() == inst.id(),
                forall|j: int|
                    #![trigger( ref_counts_tokens.dom().contains(j) )]
                    #![trigger( ref_counts_tokens.index(j) )]
                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)
                      && equal(ref_counts_tokens.index(j), 0)),
        {
            assert(ref_counts_tokens.dom().contains(i as int));
            let tracked ref_count_token = ref_counts_tokens.remove(i as int);
            let rc_atomic = AtomicU64::new(
                Ghost((tracked_inst, i as int)),
                0,
                Tracked(ref_count_token),
            );
            v.push(rc_atomic);
            i = i + 1;
            assert forall|j: int|
                i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)
                && equal(ref_counts_tokens.index(j), 0)
            by {
                assert(ref_counts_tokens.dom().contains(j));
                assert(equal(ref_counts_tokens.index(j), 0));
            }
        }
        let s = RwLock { inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };
        assert(s.inst@.rc_width() == s.ref_counts@.len());
        s
    }
}

} // verus!
fn main() {}
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
 use vstd::atomic_ghost::*;
      use vstd::multiset::*;
      use vstd::prelude::*;
      use verus_state_machines_macros::tokenized_state_machine;
      verus! {
     tokenized_state_machine!{
        DistRwLock<T> {
           fields {
#[sharding(constant)]
            pub rc_width: int,                  
#[sharding(storage_option)]
            pub storage: Option<T>,                  
#[sharding(variable)]
            pub exc_locked: bool,                  
#[sharding(map)]
            pub ref_counts: Map<int, int>,                  
#[sharding(option)]
            pub exc_pending: Option<int>,                  
#[sharding(option)]
            pub exc_guard: Option<()>,                  
#[sharding(multiset)]
            pub shared_pending: Multiset<int>,                  
#[sharding(multiset)]
            pub shared_guard: Multiset<(int, T)>,         }
           init!{
              initialize(rc_width: int, init_t: T) {
                 require(0 < rc_width);
                 init rc_width = rc_width;
                 init storage = Option::Some(init_t);
                 init exc_locked = false;
                 init ref_counts = Map::new(                     |i| 0 <= i < rc_width,                     |i| 0,                 );
                 init exc_pending = Option::None;
                 init exc_guard = Option::None;
                 init shared_pending = Multiset::empty();
                 init shared_guard = Multiset::empty();
             }
          }
           transition!{
              exc_start() {
                 require(!pre.exc_locked);
                 update exc_locked = true;
                 add exc_pending += Some(0);
             }
          }
           transition!{
              exc_check_count() {
                 remove exc_pending -= Some(let r);
                 have ref_counts >= [r => 0];
                 add exc_pending += Some(r + 1);
             }
          }
           transition!{
              exc_finish() {
             }
          }
           transition!{
              exc_release(t: T) {
                 update exc_locked = false;
                 remove exc_guard -= Some(());
                 deposit storage += Some(t);
             }
          }
           transition!{
              shared_start(r: int) {
                 remove ref_counts -= [r => let rc];
                 add ref_counts += [r => rc + 1];
                 add shared_pending += {
r};
             }
          }
           transition!{
              shared_finish(r: int) {
                 require(!pre.exc_locked);
                 remove shared_pending -= {
r};
                 birds_eye let t = pre.storage->0;
                 add shared_guard += {
(r, t)};
             }
          }
           transition!{
              shared_release(val: (int, T)) {
                 remove shared_guard -= {
val};
                 let r = val.0;
                 remove ref_counts -= [r => let rc];
                 add ref_counts += [r => rc - 1];
                 assert(rc > 0) by {
                     assert(0 <= r < pre.rc_width);
                     assert(pre.shared_guard.count(val) > 0);
                     assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);
                     assert(Self::filter_r(pre.shared_guard, r).len() > 0);
                     assert(pre.ref_counts.index(r) > 0);
                 };
             }
          }
#[invariant]
        pub fn ref_counts_domain(&self) -> bool {
              &&& 0 < self.rc_width             &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)         }
#[invariant]
        pub fn exc_inv(&self) -> bool {
              &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)             &&& self.storage is Some <==> self.exc_guard is None             &&& if let Option::Some(cur_r) = self.exc_pending {
                 &&& 0 <= cur_r <= self.rc_width                 &&& self.exc_guard is None                 &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)             }
  else {
                 true             }
          }
#[invariant]
        pub fn shared_pending_in_range(&self) -> bool {
              forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)         }
#[invariant]
        pub fn shared_guard_in_range(&self) -> bool {
              forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)         }
#[invariant]
        pub fn shared_inv_agree(&self) -> bool {
              forall |v|      
#[trigger] self.shared_guard.count(v) > 0 ==>
                self.storage === Option::Some(v.1)         }
           pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {
              shared_guard.filter(|val: (int, T)| val.0 == r)         }
#[invariant]
        pub fn shared_counts_agree(&self) -> bool {
              forall |r| 0 <= r < self.rc_width ==>                      
#[trigger] self.ref_counts.index(r) ==
                    self.shared_pending.count(r) as int +                         Self::filter_r(self.shared_guard, r).len() as int         }
#[inductive(initialize)]
        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {
              assert forall |r| 0 <= r < post.rc_width implies                      
#[trigger] post.ref_counts.index(r) ==
                    post.shared_pending.count(r) as int +                         Self::filter_r(post.shared_guard, r).len() as int             by {
                 assert(post.ref_counts.index(r) == 0);
                 assert_multisets_equal!(                     Self::filter_r(post.shared_guard, r),                     Multiset::empty(),                 );
             }
          }
#[inductive(exc_start)]
        fn exc_start_inductive(pre: Self, post: Self) {
          }
#[inductive(exc_check_count)]
        fn exc_check_count_inductive(pre: Self, post: Self) {
              let prev_r = pre.exc_pending->0;
              assert forall |x|      
#[trigger] post.shared_guard.count(x) > 0
                && x.0 == prev_r implies false             by {
                 assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);
             }
          }
#[inductive(exc_finish)]
        fn exc_finish_inductive(pre: Self, post: Self) {
          }
#[inductive(exc_release)]
        fn exc_release_inductive(pre: Self, post: Self, t: T) {
          }
#[inductive(shared_start)]
        fn shared_start_inductive(pre: Self, post: Self, r: int) {
  }
#[inductive(shared_finish)]
        fn shared_finish_inductive(pre: Self, post: Self, r: int) {
              let t = pre.storage->0;
              assert forall |r0| 0 <= r0 < post.rc_width implies                      
#[trigger] post.ref_counts.index(r0) ==
                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {
                 if r == r0 {
                     assert_multisets_equal!(                         Self::filter_r(post.shared_guard, r),                         Self::filter_r(pre.shared_guard, r).add(                             Multiset::singleton((r, t)))                     );
                 }
 else {
                     assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );
                 }
             }
          }
#[inductive(shared_release)]
        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {
              let r = val.0;
              assert forall |r0| 0 <= r0 < post.rc_width implies                      
#[trigger] post.ref_counts.index(r0) ==
                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {
                 if r0 == r {
                     assert_multisets_equal!(                         Self::filter_r(pre.shared_guard, r),                         Self::filter_r(post.shared_guard, r).add(                             Multiset::singleton(val))                     );
                 }
 else {
                     assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );
                 }
             }
          }
       }
    }
     struct_with_invariants!{
        struct RwLock<T> {
           inst: Tracked<DistRwLock::Instance<T>>,         exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,         ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,     }
        spec fn wf(&self) -> bool {
           invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {
              g.instance_id() == inst@.id()             && g.value() == b         }
           invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {
              g.instance_id() == inst@.id()             && g.key() == i             && g.value() == v as int         }
       }
    }
     impl<T> RwLock<T> {
             fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {
           let tracked inst;
           let tracked exc_locked_token;
           let tracked mut ref_counts_tokens;
           proof {
              let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));
              inst = inst0;
              exc_locked_token = exc_locked_token0;
              ref_counts_tokens = ref_counts_tokens0;
          }
           let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());
           let exc_locked_atomic = AtomicBool::new(             Ghost(tracked_inst),             false,             Tracked(exc_locked_token),         );
           let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();
           let mut i: usize = 0;
           assert forall|j: int|             i <= j && j < rc_width implies      
#[trigger] ref_counts_tokens.dom().contains(j)
              && equal(ref_counts_tokens.index(j), 0)         by {
          }
           while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>      
#[trigger] v@.index(j).well_formed()
                      && equal(v@.index(j).constant(), (tracked_inst, j)),                 tracked_inst@ == inst,                 ref_counts_tokens.instance_id() == inst.id(),                 forall|j: int|                          
#![trigger( ref_counts_tokens.dom().contains(j) )]
#![trigger( ref_counts_tokens.index(j) )]
                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)                       && equal(ref_counts_tokens.index(j), 0)),         {
              let tracked ref_count_token = ref_counts_tokens.remove(i as int);
              let rc_atomic = AtomicU64::new(                 Ghost((tracked_inst, i as int)),                 0,                 Tracked(ref_count_token),             );
              v.push(rc_atomic);
              i = i + 1;
              assert forall|j: int|                 i <= j && j < rc_width implies      
#[trigger] ref_counts_tokens.dom().contains(j)
                && equal(ref_counts_tokens.index(j), 0)             by {
             }
          }
           let s = RwLock {
  inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };
           s     }
    }
     }
       fn main() {
    }
","['#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::map::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\nverus! {\n\ntokenized_state_machine!{\n    DistRwLock<T> {\n        fields {\n            #[sharding(constant)]\n            pub rc_width: int,\n\n            #[sharding(storage_option)]\n            pub storage: Option<T>,\n\n            #[sharding(variable)]\n            pub exc_locked: bool,\n\n            #[sharding(map)]\n            pub ref_counts: Map<int, int>,\n\n            #[sharding(option)]\n            pub exc_pending: Option<int>,\n\n            #[sharding(option)]\n            pub exc_guard: Option<()>,\n\n            #[sharding(multiset)]\n            pub shared_pending: Multiset<int>,\n\n            #[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,\n        }\n\n        init!{\n            initialize(rc_width: int, init_t: T) {\n                require(0 < rc_width);\n                init rc_width = rc_width;\n                init storage = Option::Some(init_t);\n                init exc_locked = false;\n                init ref_counts = Map::new(\n                    |i| 0 <= i < rc_width,\n                    |i| 0,\n                );\n                init exc_pending = Option::None;\n                init exc_guard = Option::None;\n                init shared_pending = Multiset::empty();\n                init shared_guard = Multiset::empty();\n            }\n        }\n\n        transition!{\n            exc_start() {\n                require(!pre.exc_locked);\n                update exc_locked = true;\n                add exc_pending += Some(0);\n            }\n        }\n\n        transition!{\n            exc_check_count() {\n                remove exc_pending -= Some(let r);\n                have ref_counts >= [r => 0];\n\n                add exc_pending += Some(r + 1);\n            }\n        }\n\n        transition!{\n            exc_finish() {\n                remove exc_pending -= Some(pre.rc_width);\n                add exc_guard += Some(());\n                withdraw storage -= Some(let _);\n            }\n        }\n\n        transition!{\n            exc_release(t: T) {\n                update exc_locked = false;\n                remove exc_guard -= Some(());\n                deposit storage += Some(t);\n            }\n        }\n\n        transition!{\n            shared_start(r: int) {\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc + 1];\n                add shared_pending += {r};\n            }\n        }\n\n        transition!{\n            shared_finish(r: int) {\n                require(!pre.exc_locked);\n                remove shared_pending -= {r};\n\n                birds_eye let t = pre.storage->0;\n                add shared_guard += {(r, t)};\n            }\n        }\n\n        transition!{\n            shared_release(val: (int, T)) {\n                remove shared_guard -= {val};\n\n                let r = val.0;\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc - 1];\n\n                assert(rc > 0) by {\n                    assert(0 <= r < pre.rc_width);\n                    assert(pre.shared_guard.count(val) > 0);\n                    assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                    assert(Self::filter_r(pre.shared_guard, r).len() > 0);\n                    assert(pre.ref_counts.index(r) > 0);\n                };\n            }\n        }\n\n        property!{\n            do_guard(val: (int, T)) {\n                have shared_guard >= {val};\n                guard storage >= Some(val.1);\n            }\n        }\n\n        ///// Invariants and proofs\n\n        #[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n            &&& 0 < self.rc_width\n            &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn exc_inv(&self) -> bool {\n            &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)\n            &&& self.storage is Some <==> self.exc_guard is None\n            &&& if let Option::Some(cur_r) = self.exc_pending {\n                &&& 0 <= cur_r <= self.rc_width\n                &&& self.exc_guard is None\n                &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)\n            } else {\n                true\n            }\n        }\n\n        #[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n            forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n            forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n            forall |v| #[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)\n        }\n\n        pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n            shared_guard.filter(|val: (int, T)| val.0 == r)\n        }\n\n        #[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n            forall |r| 0 <= r < self.rc_width ==>\n                #[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +\n                        Self::filter_r(self.shared_guard, r).len() as int\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n            assert forall |r| 0 <= r < post.rc_width implies\n                #[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +\n                        Self::filter_r(post.shared_guard, r).len() as int\n            by {\n                assert(post.ref_counts.index(r) == 0);\n                assert(post.shared_pending.count(r) == 0);\n                assert_multisets_equal!(\n                    Self::filter_r(post.shared_guard, r),\n                    Multiset::empty(),\n                );\n                assert(Self::filter_r(post.shared_guard, r).len() == 0);\n            }\n            assert(post.shared_counts_agree());\n        }\n\n        #[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n\n        }\n\n        #[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n            let prev_r = pre.exc_pending->0;\n            assert forall |x| #[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false\n            by {\n                assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n            }\n        }\n\n        #[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n        }\n\n        #[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n\n        }\n\n        #[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) { }\n\n        #[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n            let t = pre.storage->0;\n\n            assert forall |r0| 0 <= r0 < post.rc_width implies\n                #[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +\n                        Self::filter_r(post.shared_guard, r0).len() as int\n            by {\n                if r == r0 {\n                    assert_multisets_equal!(\n                        pre.shared_pending,\n                        post.shared_pending.add(Multiset::singleton(r))\n                    );\n                    assert_multisets_equal!(\n                        Self::filter_r(post.shared_guard, r),\n                        Self::filter_r(pre.shared_guard, r).add(\n                            Multiset::singleton((r, t)))\n                    );\n                    assert(post.ref_counts.index(r0) ==\n                        post.shared_pending.count(r0) as int +\n                            Self::filter_r(post.shared_guard, r0).len() as int);\n                } else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                    assert(post.ref_counts.index(r0) ==\n                        post.shared_pending.count(r0) as int +\n                            Self::filter_r(post.shared_guard, r0).len() as int);\n                }\n            }\n        }\n\n        #[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n            let r = val.0;\n            assert forall |r0| 0 <= r0 < post.rc_width implies\n                #[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +\n                        Self::filter_r(post.shared_guard, r0).len() as int\n            by {\n                if r0 == r {\n                    assert_multisets_equal!(\n                        Self::filter_r(pre.shared_guard, r),\n                        Self::filter_r(post.shared_guard, r).add(\n                            Multiset::singleton(val))\n                    );\n                } else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                }\n            }\n        }\n    }\n}\n\nstruct_with_invariants!{\n    struct RwLock<T> {\n        inst: Tracked<DistRwLock::Instance<T>>,\n        exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,\n        ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,\n    }\n\n    spec fn wf(&self) -> bool {\n\n        predicate {\n            &&& self.inst@.rc_width() == self.ref_counts@.len()\n\n            &&& forall |i: int| (0 <= i && i < self.ref_counts@.len()) ==>\n                #[trigger] self.ref_counts@.index(i).well_formed()\n                && self.ref_counts@.index(i).constant() === (self.inst, i)\n        }\n\n        invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n            g.instance_id() == inst@.id()\n            && g.value() == b\n        }\n\n        invariant on ref_counts with (inst)\n            forall |i: int|\n            where (0 <= i < self.ref_counts@.len())\n            specifically (self.ref_counts@[i])\n            is (v: u64, g: DistRwLock::ref_counts<T>)\n        {\n            g.instance_id() == inst@.id()\n            && g.key() == i\n            && g.value() == v as int\n        }\n    }\n}\n\nimpl<T> RwLock<T> {\n    #[verifier::spinoff_prover]\n    fn new(rc_width: usize, t: T) -> (s: Self)\n        requires\n            0 < rc_width,\n        ensures\n            s.wf(),\n    {\n        let tracked inst;\n        let tracked exc_locked_token;\n        let tracked mut ref_counts_tokens;\n        proof {\n            let tracked (\n                Tracked(inst0),\n                Tracked(exc_locked_token0),\n                Tracked(ref_counts_tokens0),\n                _,\n                _,\n                _,\n                _,\n            ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n            inst = inst0;\n            exc_locked_token = exc_locked_token0;\n            ref_counts_tokens = ref_counts_tokens0;\n        }\n        let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n        let exc_locked_atomic = AtomicBool::new(\n            Ghost(tracked_inst),\n            false,\n            Tracked(exc_locked_token),\n        );\n        let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n        let mut i: usize = 0;\n        assert forall|j: int|\n            i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)\n        by {\n            assert(ref_counts_tokens.dom().contains(j));\n            assert(equal(ref_counts_tokens.index(j), 0));\n        }\n        assert(forall|j: int|\n            #![trigger( ref_counts_tokens.dom().contains(j) )]\n            #![trigger( ref_counts_tokens.index(j) )]\n            i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)));\n        while i < rc_width\n            invariant\n                i <= rc_width,\n                v@.len() == i as int,\n                forall|j: int|\n                    0 <= j && j < i ==> #[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),\n                tracked_inst@ == inst,\n                ref_counts_tokens.instance_id() == inst.id(),\n                forall|j: int|\n                    #![trigger( ref_counts_tokens.dom().contains(j) )]\n                    #![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n                      && equal(ref_counts_tokens.index(j), 0)),\n        {\n            assert(ref_counts_tokens.dom().contains(i as int));\n            let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n            let rc_atomic = AtomicU64::new(\n                Ghost((tracked_inst, i as int)),\n                0,\n                Tracked(ref_count_token),\n            );\n            v.push(rc_atomic);\n            i = i + 1;\n            assert forall|j: int|\n                i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)\n            by {\n                assert(ref_counts_tokens.dom().contains(j));\n                assert(equal(ref_counts_tokens.index(j), 0));\n            }\n        }\n        let s = RwLock { inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n        assert(s.inst@.rc_width() == s.ref_counts@.len());\n        s\n    }\n}\n\n} // verus!\nfn main() {}\n', 'use vstd;\nfn main() {}\n', '#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::atomic_ghost::*;\n      use vstd::multiset::*;\n      use vstd::prelude::*;\n      use verus_state_machines_macros::tokenized_state_machine;\n      verus! {\n     tokenized_state_machine!{\n        DistRwLock<T> {\n           fields {\n#[sharding(constant)]\n            pub rc_width: int,                  \n#[sharding(storage_option)]\n            pub storage: Option<T>,                  \n#[sharding(variable)]\n            pub exc_locked: bool,                  \n#[sharding(map)]\n            pub ref_counts: Map<int, int>,                  \n#[sharding(option)]\n            pub exc_pending: Option<int>,                  \n#[sharding(option)]\n            pub exc_guard: Option<()>,                  \n#[sharding(multiset)]\n            pub shared_pending: Multiset<int>,                  \n#[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,         }\n           init!{\n              initialize(rc_width: int, init_t: T) {\n                 require(0 < rc_width);\n                 init rc_width = rc_width;\n                 init storage = Option::Some(init_t);\n                 init exc_locked = false;\n                 init ref_counts = Map::new(                     |i| 0 <= i < rc_width,                     |i| 0,                 );\n                 init exc_pending = Option::None;\n                 init exc_guard = Option::None;\n                 init shared_pending = Multiset::empty();\n                 init shared_guard = Multiset::empty();\n             }\n          }\n           transition!{\n              exc_start() {\n                 require(!pre.exc_locked);\n                 update exc_locked = true;\n                 add exc_pending += Some(0);\n             }\n          }\n           transition!{\n              exc_check_count() {\n                 remove exc_pending -= Some(let r);\n                 have ref_counts >= [r => 0];\n                 add exc_pending += Some(r + 1);\n             }\n          }\n           transition!{\n              exc_finish() {\n             }\n          }\n           transition!{\n              exc_release(t: T) {\n                 update exc_locked = false;\n                 remove exc_guard -= Some(());\n                 deposit storage += Some(t);\n             }\n          }\n           transition!{\n              shared_start(r: int) {\n                 remove ref_counts -= [r => let rc];\n                 add ref_counts += [r => rc + 1];\n                 add shared_pending += {\nr};\n             }\n          }\n           transition!{\n              shared_finish(r: int) {\n                 require(!pre.exc_locked);\n                 remove shared_pending -= {\nr};\n                 birds_eye let t = pre.storage->0;\n                 add shared_guard += {\n(r, t)};\n             }\n          }\n           transition!{\n              shared_release(val: (int, T)) {\n                 remove shared_guard -= {\nval};\n                 let r = val.0;\n                 remove ref_counts -= [r => let rc];\n                 add ref_counts += [r => rc - 1];\n                 assert(rc > 0) by {\n                     assert(0 <= r < pre.rc_width);\n                     assert(pre.shared_guard.count(val) > 0);\n                     assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                     assert(Self::filter_r(pre.shared_guard, r).len() > 0);\n                     assert(pre.ref_counts.index(r) > 0);\n                 };\n             }\n          }\n#[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n              &&& 0 < self.rc_width             &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)         }\n#[invariant]\n        pub fn exc_inv(&self) -> bool {\n              &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)             &&& self.storage is Some <==> self.exc_guard is None             &&& if let Option::Some(cur_r) = self.exc_pending {\n                 &&& 0 <= cur_r <= self.rc_width                 &&& self.exc_guard is None                 &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)             }\n  else {\n                 true             }\n          }\n#[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n              forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)         }\n#[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n              forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)         }\n#[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n              forall |v|      \n#[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)         }\n           pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n              shared_guard.filter(|val: (int, T)| val.0 == r)         }\n#[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n              forall |r| 0 <= r < self.rc_width ==>                      \n#[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +                         Self::filter_r(self.shared_guard, r).len() as int         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n              assert forall |r| 0 <= r < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +                         Self::filter_r(post.shared_guard, r).len() as int             by {\n                 assert(post.ref_counts.index(r) == 0);\n                 assert_multisets_equal!(                     Self::filter_r(post.shared_guard, r),                     Multiset::empty(),                 );\n             }\n          }\n#[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n          }\n#[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n              let prev_r = pre.exc_pending->0;\n              assert forall |x|      \n#[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false             by {\n                 assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n             }\n          }\n#[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n          }\n#[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n          }\n#[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) {\n  }\n#[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n              let t = pre.storage->0;\n              assert forall |r0| 0 <= r0 < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                 if r == r0 {\n                     assert_multisets_equal!(                         Self::filter_r(post.shared_guard, r),                         Self::filter_r(pre.shared_guard, r).add(                             Multiset::singleton((r, t)))                     );\n                 }\n else {\n                     assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                 }\n             }\n          }\n#[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n              let r = val.0;\n              assert forall |r0| 0 <= r0 < post.rc_width implies                      \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                 if r0 == r {\n                     assert_multisets_equal!(                         Self::filter_r(pre.shared_guard, r),                         Self::filter_r(post.shared_guard, r).add(                             Multiset::singleton(val))                     );\n                 }\n else {\n                     assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                 }\n             }\n          }\n       }\n    }\n     struct_with_invariants!{\n        struct RwLock<T> {\n           inst: Tracked<DistRwLock::Instance<T>>,         exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,         ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,     }\n        spec fn wf(&self) -> bool {\n           invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n              g.instance_id() == inst@.id()             && g.value() == b         }\n           invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {\n              g.instance_id() == inst@.id()             && g.key() == i             && g.value() == v as int         }\n       }\n    }\n     impl<T> RwLock<T> {\n             fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n           let tracked inst;\n           let tracked exc_locked_token;\n           let tracked mut ref_counts_tokens;\n           proof {\n              let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n              inst = inst0;\n              exc_locked_token = exc_locked_token0;\n              ref_counts_tokens = ref_counts_tokens0;\n          }\n           let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n           let exc_locked_atomic = AtomicBool::new(             Ghost(tracked_inst),             false,             Tracked(exc_locked_token),         );\n           let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n           let mut i: usize = 0;\n           assert forall|j: int|             i <= j && j < rc_width implies      \n#[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)         by {\n          }\n           while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>      \n#[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),                 tracked_inst@ == inst,                 ref_counts_tokens.instance_id() == inst.id(),                 forall|j: int|                          \n#![trigger( ref_counts_tokens.dom().contains(j) )]\n#![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)                       && equal(ref_counts_tokens.index(j), 0)),         {\n              let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n              let rc_atomic = AtomicU64::new(                 Ghost((tracked_inst, i as int)),                 0,                 Tracked(ref_count_token),             );\n              v.push(rc_atomic);\n              i = i + 1;\n              assert forall|j: int|                 i <= j && j < rc_width implies      \n#[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)             by {\n             }\n          }\n           let s = RwLock {\n  inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n           s     }\n    }\n     }\n       fn main() {\n    }\n', '#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::atomic_ghost::*;\n       use vstd::multiset::*;\n       use vstd::prelude::*;\n       use verus_state_machines_macros::tokenized_state_machine;\n       verus! {\n      tokenized_state_machine!{\n         DistRwLock<T> {\n            fields {\n#[sharding(constant)]\n            pub rc_width: int,                   \n#[sharding(storage_option)]\n            pub storage: Option<T>,                   \n#[sharding(variable)]\n            pub exc_locked: bool,                   \n#[sharding(map)]\n            pub ref_counts: Map<int, int>,                   \n#[sharding(option)]\n            pub exc_pending: Option<int>,                   \n#[sharding(option)]\n            pub exc_guard: Option<()>,                   \n#[sharding(multiset)]\n            pub shared_pending: Multiset<int>,                   \n#[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,         }\n            init!{\n               initialize(rc_width: int, init_t: T) {\n                  require(0 < rc_width);\n                  init rc_width = rc_width;\n                  init storage = Option::Some(init_t);\n                  init exc_locked = false;\n                  init ref_counts = Map::new(                     |i| 0 <= i < rc_width,                     |i| 0,                 );\n                  init exc_pending = Option::None;\n                  init exc_guard = Option::None;\n                  init shared_pending = Multiset::empty();\n                  init shared_guard = Multiset::empty();\n              }\n           }\n            transition!{\n               exc_start() {\n                  require(!pre.exc_locked);\n                  update exc_locked = true;\n                  add exc_pending += Some(0);\n              }\n           }\n            transition!{\n               exc_check_count() {\n                  remove exc_pending -= Some(let r);\n                  have ref_counts >= [r => 0];\n                  add exc_pending += Some(r + 1);\n              }\n           }\n            transition!{\n               exc_finish() {\n              }\n           }\n            transition!{\n               exc_release(t: T) {\n                  update exc_locked = false;\n                  remove exc_guard -= Some(());\n                  deposit storage += Some(t);\n              }\n           }\n            transition!{\n               shared_start(r: int) {\n                  remove ref_counts -= [r => let rc];\n                  add ref_counts += [r => rc + 1];\n                  add shared_pending += {\n r};\n              }\n           }\n            transition!{\n               shared_finish(r: int) {\n                  require(!pre.exc_locked);\n                  remove shared_pending -= {\n r};\n                  birds_eye let t = pre.storage->0;\n                  add shared_guard += {\n (r, t)};\n              }\n           }\n            transition!{\n               shared_release(val: (int, T)) {\n                  remove shared_guard -= {\n val};\n                  let r = val.0;\n                  remove ref_counts -= [r => let rc];\n                  add ref_counts += [r => rc - 1];\n                  assert(rc > 0) by {\n                      assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                  };\n              }\n           }\n#[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n               &&& 0 < self.rc_width             &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)         }\n#[invariant]\n        pub fn exc_inv(&self) -> bool {\n               &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)             &&& self.storage is Some <==> self.exc_guard is None             &&& if let Option::Some(cur_r) = self.exc_pending {\n                  &&& 0 <= cur_r <= self.rc_width                 &&& self.exc_guard is None                 &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)             }\n   else {\n                  true             }\n           }\n#[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n               forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)         }\n#[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n               forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)         }\n#[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n               forall |v|       \n#[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)         }\n            pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n               shared_guard.filter(|val: (int, T)| val.0 == r)         }\n#[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n               forall |r| 0 <= r < self.rc_width ==>                       \n#[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +                         Self::filter_r(self.shared_guard, r).len() as int         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n               assert forall |r| 0 <= r < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +                         Self::filter_r(post.shared_guard, r).len() as int             by {\n                  assert_multisets_equal!(                     Self::filter_r(post.shared_guard, r),                     Multiset::empty(),                 );\n              }\n           }\n#[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n           }\n#[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n               let prev_r = pre.exc_pending->0;\n               assert forall |x|       \n#[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false             by {\n                  assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n              }\n           }\n#[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n           }\n#[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n           }\n#[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) {\n   }\n#[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n               let t = pre.storage->0;\n               assert forall |r0| 0 <= r0 < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                  if r == r0 {\n                      assert_multisets_equal!(                         Self::filter_r(post.shared_guard, r),                         Self::filter_r(pre.shared_guard, r).add(                             Multiset::singleton((r, t)))                     );\n                  }\n  else {\n                      assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                  }\n              }\n           }\n#[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n               let r = val.0;\n               assert forall |r0| 0 <= r0 < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                  if r0 == r {\n                      assert_multisets_equal!(                         Self::filter_r(pre.shared_guard, r),                         Self::filter_r(post.shared_guard, r).add(                             Multiset::singleton(val))                     );\n                  }\n  else {\n                      assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                  }\n              }\n           }\n        }\n     }\n      struct_with_invariants!{\n         struct RwLock<T> {\n            inst: Tracked<DistRwLock::Instance<T>>,         exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,         ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,     }\n         spec fn wf(&self) -> bool {\n            invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n               g.instance_id() == inst@.id()             && g.value() == b         }\n            invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {\n               g.instance_id() == inst@.id()             && g.key() == i             && g.value() == v as int         }\n        }\n     }\n      impl<T> RwLock<T> {\n              fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n            let tracked inst;\n            let tracked exc_locked_token;\n            let tracked mut ref_counts_tokens;\n            proof {\n               let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n               inst = inst0;\n               exc_locked_token = exc_locked_token0;\n               ref_counts_tokens = ref_counts_tokens0;\n           }\n            let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n            let exc_locked_atomic = AtomicBool::new(             Ghost(tracked_inst),             false,             Tracked(exc_locked_token),         );\n            let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n            let mut i: usize = 0;\n            assert forall|j: int|             i <= j && j < rc_width implies       \n#[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)         by {\n           }\n            while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>       \n#[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),                 tracked_inst@ == inst,                 ref_counts_tokens.instance_id() == inst.id(),                 forall|j: int|                           \n#![trigger( ref_counts_tokens.dom().contains(j) )]\n#![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)                       && equal(ref_counts_tokens.index(j), 0)),         {\n               let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n               let rc_atomic = AtomicU64::new(                 Ghost((tracked_inst, i as int)),                 0,                 Tracked(ref_count_token),             );\n               v.push(rc_atomic);\n               i = i + 1;\n               assert forall|j: int|                 i <= j && j < rc_width implies       \n#[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)             by {\n              }\n           }\n            let s = RwLock {\n   inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n            s     }\n     }\n      }\n        fn main() {\n     }\n', '#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::atomic_ghost::*;\n       use vstd::multiset::*;\n       use vstd::prelude::*;\n       use verus_state_machines_macros::tokenized_state_machine;\n       verus! {\n      tokenized_state_machine!{\n         DistRwLock<T> {\n            fields {\n#[sharding(constant)]\n            pub rc_width: int,                   \n#[sharding(storage_option)]\n            pub storage: Option<T>,                   \n#[sharding(variable)]\n            pub exc_locked: bool,                   \n#[sharding(map)]\n            pub ref_counts: Map<int, int>,                   \n#[sharding(option)]\n            pub exc_pending: Option<int>,                   \n#[sharding(option)]\n            pub exc_guard: Option<()>,                   \n#[sharding(multiset)]\n            pub shared_pending: Multiset<int>,                   \n#[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,         }\n            init!{\n               initialize(rc_width: int, init_t: T) {\n                  require(0 < rc_width);\n                  init rc_width = rc_width;\n                  init storage = Option::Some(init_t);\n                  init exc_locked = false;\n                  init ref_counts = Map::new(                     |i| 0 <= i < rc_width,                     |i| 0,                 );\n                  init exc_pending = Option::None;\n                  init exc_guard = Option::None;\n                  init shared_pending = Multiset::empty();\n                  init shared_guard = Multiset::empty();\n              }\n           }\n            transition!{\n               exc_start() {\n                  require(!pre.exc_locked);\n                  update exc_locked = true;\n                  add exc_pending += Some(0);\n              }\n           }\n            transition!{\n               exc_check_count() {\n                  remove exc_pending -= Some(let r);\n                  have ref_counts >= [r => 0];\n                  add exc_pending += Some(r + 1);\n              }\n           }\n            transition!{\n               exc_finish() {\n              }\n           }\n            transition!{\n               exc_release(t: T) {\n                  update exc_locked = false;\n                  remove exc_guard -= Some(());\n                  deposit storage += Some(t);\n              }\n           }\n            transition!{\n               shared_start(r: int) {\n                  remove ref_counts -= [r => let rc];\n                  add ref_counts += [r => rc + 1];\n                  add shared_pending += {\n r};\n              }\n           }\n            transition!{\n               shared_finish(r: int) {\n                  require(!pre.exc_locked);\n                  remove shared_pending -= {\n r};\n                  birds_eye let t = pre.storage->0;\n                  add shared_guard += {\n (r, t)};\n              }\n           }\n            transition!{\n               shared_release(val: (int, T)) {\n                  remove shared_guard -= {\n val};\n                  let r = val.0;\n                  remove ref_counts -= [r => let rc];\n                  add ref_counts += [r => rc - 1];\n                  assert(rc > 0) by {\n                      assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                  };\n              }\n           }\n#[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n               &&& 0 < self.rc_width             &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)         }\n#[invariant]\n        pub fn exc_inv(&self) -> bool {\n               &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)             &&& self.storage is Some <==> self.exc_guard is None             &&& if let Option::Some(cur_r) = self.exc_pending {\n                  &&& 0 <= cur_r <= self.rc_width                 &&& self.exc_guard is None                 &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)             }\n   else {\n                  true             }\n           }\n#[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n               forall |v|       \n#[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)         }\n            pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n               shared_guard.filter(|val: (int, T)| val.0 == r)         }\n#[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n               forall |r| 0 <= r < self.rc_width ==>                       \n#[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +                         Self::filter_r(self.shared_guard, r).len() as int         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n               assert forall |r| 0 <= r < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +                         Self::filter_r(post.shared_guard, r).len() as int             by {\n                  assert_multisets_equal!(                     Self::filter_r(post.shared_guard, r),                     Multiset::empty(),                 );\n              }\n           }\n#[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n           }\n#[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n               let prev_r = pre.exc_pending->0;\n               assert forall |x|       \n#[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false             by {\n                  assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n              }\n           }\n#[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n           }\n#[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n           }\n#[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) {\n   }\n#[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n               let t = pre.storage->0;\n               assert forall |r0| 0 <= r0 < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                  if r == r0 {\n                      assert_multisets_equal!(                         Self::filter_r(post.shared_guard, r),                         Self::filter_r(pre.shared_guard, r).add(                             Multiset::singleton((r, t)))                     );\n                  }\n  else {\n                      assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                  }\n              }\n           }\n#[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n               let r = val.0;\n               assert forall |r0| 0 <= r0 < post.rc_width implies                       \n#[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +                         Self::filter_r(post.shared_guard, r0).len() as int             by {\n                  if r0 == r {\n                      assert_multisets_equal!(                         Self::filter_r(pre.shared_guard, r),                         Self::filter_r(post.shared_guard, r).add(                             Multiset::singleton(val))                     );\n                  }\n  else {\n                      assert_multisets_equal!(                           Self::filter_r(post.shared_guard, r0),                           Self::filter_r(pre.shared_guard, r0)                     );\n                  }\n              }\n           }\n        }\n     }\n      struct_with_invariants!{\n         struct RwLock<T> {\n            inst: Tracked<DistRwLock::Instance<T>>,         exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,         ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,     }\n         spec fn wf(&self) -> bool {\n            invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n               g.instance_id() == inst@.id()             && g.value() == b         }\n            invariant on ref_counts with (inst)             forall |i: int|             where (0 <= i < self.ref_counts@.len())             specifically (self.ref_counts@[i])             is (v: u64, g: DistRwLock::ref_counts<T>)         {\n               g.instance_id() == inst@.id()             && g.key() == i             && g.value() == v as int         }\n        }\n     }\n      impl<T> RwLock<T> {\n              fn new(rc_width: usize, t: T) -> (s: Self)         requires             0 < rc_width,         ensures             s.wf(),     {\n            let tracked inst;\n            let tracked exc_locked_token;\n            let tracked mut ref_counts_tokens;\n            proof {\n               let tracked (                 Tracked(inst0),                 Tracked(exc_locked_token0),                 Tracked(ref_counts_tokens0),                 _,                 _,                 _,                 _,             ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n               inst = inst0;\n               exc_locked_token = exc_locked_token0;\n               ref_counts_tokens = ref_counts_tokens0;\n           }\n            let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n            let exc_locked_atomic = AtomicBool::new(             Ghost(tracked_inst),             false,             Tracked(exc_locked_token),         );\n            let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n            let mut i: usize = 0;\n            assert forall|j: int|             i <= j && j < rc_width implies       \n#[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)         by {\n           }\n            while i < rc_width             invariant                 i <= rc_width,                 v@.len() == i as int,                 forall|j: int|                     0 <= j && j < i ==>       \n#[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),                 tracked_inst@ == inst,                 ref_counts_tokens.instance_id() == inst.id(),                 forall|j: int|                           \n#![trigger( ref_counts_tokens.dom().contains(j) )]\n#![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)                       && equal(ref_counts_tokens.index(j), 0)),         {\n               let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n               let rc_atomic = AtomicU64::new(                 Ghost((tracked_inst, i as int)),                 0,                 Tracked(ref_count_token),             );\n               v.push(rc_atomic);\n               i = i + 1;\n               assert forall|j: int|                 i <= j && j < rc_width implies       \n#[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)             by {\n              }\n           }\n            let s = RwLock {\n   inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n            s     }\n     }\n      }\n        fn main() {\n     }\n', '         use vstd::prelude::*;\n                fn main() {\n     }\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/flat_combine.rs,461,200,0.43383947939262474,2099.91,True,0.7,False,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::map::', 'vstd::multiset::', 'vstd::prelude::', 'vstd::seq::', 'vstd::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,,,,"// rust_verify/tests/example.rs expect-warnings
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::map::*;
use vstd::multiset::*;
use vstd::prelude::*;
use vstd::seq::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::tokenized_state_machine;

// Based off of the FlatCombine system from Seagull-NR.
// A major difference is that one didn't make any use of storage, because storage was
// rather complicated to use, and it wasn't necessary.
// Now, I expect storage to be a lot easier to use, easier than the alternative.

verus! {

pub struct Request {
    pub rid: int,
    pub req: int,
}

pub struct Response {
    pub rid: int,
    pub resp: int,
}

#[is_variant]
pub enum Client {
    Idle,
    Waiting { rid: int },
}

#[is_variant]
pub enum Combiner {
    Collecting { elems: Seq<Option<int>> },
    Responding { elems: Seq<Option<int>>, idx: nat },
}

} // verus!
tokenized_state_machine! {
    FlatCombiner {
        fields {
            #[sharding(constant)]
            pub num_clients: nat,

            #[sharding(map)]
            pub clients: Map<nat, Client>,

            #[sharding(map)]
            pub slots: Map<nat, bool>,

            #[sharding(variable)]
            pub combiner: Combiner,

            #[sharding(storage_map)]
            pub requests: Map<nat, Request>,

            #[sharding(storage_map)]
            pub responses: Map<nat, Response>,
        }

        pub open spec fn valid_idx(self, i: nat) -> bool {
            0 <= i && i < self.num_clients
        }

        #[invariant]
        pub fn clients_complete(self) -> bool {
            forall |i: nat| (0 <= i && i < self.num_clients) ==
                self.clients.dom().contains(i)
        }

        #[invariant]
        pub fn slots_complete(self) -> bool {
            forall |i: nat| (0 <= i && i < self.num_clients) ==
                self.slots.dom().contains(i)
        }

        #[invariant]
        pub fn clients_size(self) -> bool {
            match self.combiner {
                Combiner::Collecting{elems} => elems.len() <= self.num_clients,
                Combiner::Responding{elems, idx} => elems.len() == self.num_clients &&
                    0 <= idx && idx <= self.num_clients,
            }
        }

        /*
        #[verifier::spec]
        fn should_have_req_stored(self, i: nat) -> bool {
            0 <= i
            && i < self.slots
            && self.slots.index(i)
            && match self.combiner {
                Combiner::Collecting{elems} => elems.len() < i || elems.index(i).is_None()
                Combiner::Responding{elems, idx} => idx >= i || elems.index(i).is_None()
            }
        }
        */

        pub open spec fn client_waiting(self, i: nat) -> bool {
            self.valid_idx(i)
            && self.clients.index(i).is_Waiting()
        }

        pub open spec fn combiner_has(self, i: nat) -> bool {
            self.valid_idx(i)
            && match self.combiner {
                Combiner::Collecting{elems} => i < elems.len() && elems.index(i as int).is_Some(),
                Combiner::Responding{elems, idx} => i >= idx && elems.index(i as int).is_Some(),
            }
        }

        pub open spec fn combiner_rid(self, i: nat) -> int {
            match self.combiner {
                Combiner::Collecting{elems} => elems.index(i as int).get_Some_0(),
                Combiner::Responding{elems, idx} => elems.index(i as int).get_Some_0(),
            }
        }

        pub open spec fn request_stored(self, i: nat) -> bool {
            self.requests.dom().contains(i)
        }

        pub open spec fn response_stored(self, i: nat) -> bool {
            self.responses.dom().contains(i)
        }

        #[invariant]
        pub fn not_waiting_inv(self) -> bool {
            forall |i: nat| #[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>
                !self.slots.index(i)
        }

        #[invariant]
        pub fn waiting_inv(self) -> bool {
            forall |i: nat| #[trigger] self.client_waiting(i) ==>
                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)
        }

        #[invariant]
        pub fn request_stored_inv(self) -> bool {
            forall |i: nat| #[trigger] self.request_stored(i) ==>
                self.client_waiting(i)
                && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()
                && self.slots.index(i)
        }

        #[invariant]
        pub fn response_stored_inv(self) -> bool {
            forall |i: nat| #[trigger] self.response_stored(i) ==>
                self.client_waiting(i)
                && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()
                && !self.slots.index(i)
        }


        #[invariant]
        pub fn combiner_has_inv(self) -> bool {
            forall |i: nat| #[trigger] self.combiner_has(i) ==>
                self.client_waiting(i)
                && self.slots.index(i)
                && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()
                && !self.request_stored(i)
        }

        init!{
            initialize(num_clients: nat) {
                init num_clients = num_clients;
                init clients = Map::new(
                    |i: nat| 0 <= i && i < num_clients,
                    |i: nat| Client::Idle);
                init slots = Map::new(
                    |i: nat| 0 <= i && i < num_clients,
                    |i: nat| false);
                init combiner = Combiner::Collecting { elems: Seq::empty() };
                init requests = Map::empty();
                init responses = Map::empty();
            }
        }

        #[inductive(initialize)]
        fn init_inductive(post: Self, num_clients: nat) { }

        ///// Client transitions

        transition!{
            client_send(j: nat, request: Request, cur_slot: bool) {
                require(0 <= j && j < pre.num_clients);

                // Move client to 'waiting' state
                remove clients -= [j => Client::Idle];
                add    clients += [j => Client::Waiting{rid: request.rid}];

                // Set the slot
                remove slots -= [j => cur_slot];
                add    slots += [j => true];

                // deposit the request
                deposit requests += [j => request] by {
                    assert(!pre.request_stored(j));
                };
            }
        }

        #[inductive(client_send)]
        fn client_send_inductive(pre: Self,
            post: Self, j: nat, request: Request, cur_slot: bool)
        {
            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
            assert(pre.valid_idx(j));
            assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));
            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));
            assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));
            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));

            assert(post.request_stored(j));
            assert(post.client_waiting(j));

            /*assert_forall_by(|i: nat| {
                requires(post.client_waiting(i));
                ensures(post.request_stored(i) || post.response_stored(i) || post.combiner_has(i));
                if i == j {
                    assert(post.request_stored(i));
                } else {
                    assert(pre.client_waiting(i));
                    assert(post.request_stored(i) || post.response_stored(i) || post.combiner_has(i));
                }
            });*/
        }

        transition!{
            client_recv(j: nat) {
                require(0 <= j && j < pre.num_clients);

                // Move client to 'idle' state
                remove clients -= [j => let Client::Waiting{rid}];
                add    clients += [j => Client::Idle];

                // Check that the slot has been set back to 'false'
                have slots >= [j => false];

                // withdraw the response
                withdraw responses -= [j => let response] by {
                    assert(pre.client_waiting(j));
                    //assert(!pre.request_stored(j));
                    //assert(!pre.combiner_has(j));
                    //assert(pre.response_stored(j));
                };

                // make sure we get back the response for the correct request id:
                assert(response.rid == rid) by {
                    assert(pre.client_waiting(j));
                };
            }
        }

        #[inductive(client_recv)]
        fn client_recv_inductive(pre: Self, post: Self, j: nat) {
            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
            assert(pre.valid_idx(j));
            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));
            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
            assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));

            assert(!post.client_waiting(j));
        }

        ///// Combiner transitions

        transition!{
            combiner_recv() {
                require(pre.combiner.is_Collecting());
                let j = pre.combiner.get_Collecting_elems().len();
                require(0 <= j && j < pre.num_clients);

                // Observe that the slot has been set to 'true'
                have slots >= [j => true];

                // Withdraw a request
                withdraw requests -= [j => let request] by {
                    assert(pre.valid_idx(j));
                    assert(pre.client_waiting(j));
                    assert(pre.request_stored(j));
                };

                // Update combiner's local state to remember we withdrew a request with this ID
                update combiner = Combiner::Collecting{
                    elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),
                };
            }
        }

        #[inductive(combiner_recv)]
        fn combiner_recv_inductive(pre: Self, post: Self) {
            let j = pre.combiner.get_Collecting_elems().len();
            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
            assert(post.valid_idx(j));
            assert(pre.client_waiting(j));
            assert(pre.request_stored(j));
            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
            assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));
            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));

            assert(post.combiner_has(j));
        }

        transition!{
            combiner_skip() {
                require(pre.combiner.is_Collecting());
                let j = pre.combiner.get_Collecting_elems().len();
                require(0 <= j && j < pre.num_clients);

                // In practice, this happens when slot j is set to false, so we could add this:
                //    have slots >= [j => false];
                // but it's not necessary

                // Update combiner's local state to remember that we didn't withdraw
                // anything here.
                update combiner = Combiner::Collecting{
                    elems: pre.combiner.get_Collecting_elems().push(Option::None),
                };
            }
        }

        #[inductive(combiner_skip)]
        fn combiner_skip_inductive(pre: Self, post: Self) {
            let j = pre.combiner.get_Collecting_elems().len();
            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
            assert(post.valid_idx(j));
            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
            assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));
            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));

            assert(!post.combiner_has(j));
        }

        transition!{
            combiner_go_to_responding() {
                require(pre.combiner.is_Collecting());
                require(pre.combiner.get_Collecting_elems().len() == pre.num_clients);
                update combiner = Combiner::Responding{
                    elems: pre.combiner.get_Collecting_elems(),
                    idx: 0,
                };
            }
        }

        transition!{
            combiner_send(response: Response, cur_slot: bool) {
                require(pre.combiner.is_Responding());
                let j = pre.combiner.get_Responding_idx();
                require(0 <= j && j < pre.num_clients);
                let response_opt = pre.combiner.get_Responding_elems().index(j as int);

                // The response we return has to have the right request ID
                require(response_opt === Option::Some(response.rid));

                // Set the slot back to false
                remove slots -= [j => cur_slot];
                add    slots += [j => false];

                // Update the combiner's local state
                update combiner = Combiner::Responding{
                    elems: pre.combiner.get_Responding_elems(),
                    idx: j + 1,
                };

                deposit responses += [j => response] by {
                    assert(pre.valid_idx(j));
                    assert(pre.combiner_has(j));
                    assert(!pre.response_stored(j));
                };
            }
        }

        #[inductive(combiner_send)]
        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {
            let j = pre.combiner.get_Responding_idx();

            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
            assert(post.valid_idx(j));
            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));
            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
            assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));

            assert(pre.valid_idx(j));
            assert(pre.combiner_has(j));
            assert(pre.client_waiting(j));

            assert(!post.combiner_has(j));
        }

        transition!{
            combiner_send_skip() {
                require(pre.combiner.is_Responding());
                let j = pre.combiner.get_Responding_idx();
                require(0 <= j && j < pre.num_clients);
                let response_opt = pre.combiner.get_Responding_elems().index(j as int);

                // The response we return has to have the right request ID
                require(equal(response_opt, Option::None));

                // Update the combiner's local state
                update combiner = Combiner::Responding{
                    elems: pre.combiner.get_Responding_elems(),
                    idx: j + 1,
                };
            }
        }

        #[inductive(combiner_send_skip)]
        fn combiner_send_skip_inductive(pre: Self, post: Self) {
            let j = pre.combiner.get_Responding_idx();

            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
            assert(post.valid_idx(j));
            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));
            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));

            assert(!post.combiner_has(j));
        }

        #[inductive(combiner_go_to_responding)]
        fn combiner_go_to_responding_inductive(pre: Self, post: Self) {
            assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));
            assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));
            assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));
            assert(forall |i| post.request_stored(i) == pre.request_stored(i));
            assert(forall |i| post.response_stored(i) == pre.response_stored(i));
        }

        transition!{
            combiner_go_to_collecting() {
                require(pre.combiner.is_Responding());
                require(pre.combiner.get_Responding_idx() == pre.num_clients);
                update combiner = Combiner::Collecting{ elems: Seq::empty() };
            }
        }

        #[inductive(combiner_go_to_collecting)]
        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {
            assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));
            assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));
            assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));
            assert(forall |i| post.request_stored(i) == pre.request_stored(i));
            assert(forall |i| post.response_stored(i) == pre.response_stored(i));
        }

    }
}

fn main() {}
"," use vstd::prelude::*;
     use verus_state_machines_macros::tokenized_state_machine;
     verus! {
    pub struct Request {
       pub rid: int,     pub req: int, }
    pub struct Response {
       pub rid: int,     pub resp: int, }
#[is_variant]
pub enum Client {
       Idle,     Waiting {
  rid: int }
  , }
#[is_variant]
pub enum Combiner {
       Collecting {
  elems: Seq<Option<int>> }
  ,     Responding {
  elems: Seq<Option<int>>, idx: nat }
  , }
    }
      tokenized_state_machine! {
        FlatCombiner {
           fields {
#[sharding(constant)]
            pub num_clients: nat,                 
#[sharding(map)]
            pub clients: Map<nat, Client>,                 
#[sharding(map)]
            pub slots: Map<nat, bool>,                 
#[sharding(variable)]
            pub combiner: Combiner,                 
#[sharding(storage_map)]
            pub requests: Map<nat, Request>,                 
#[sharding(storage_map)]
            pub responses: Map<nat, Response>,         }
           pub open spec fn valid_idx(self, i: nat) -> bool {
              0 <= i && i < self.num_clients         }
#[invariant]
        pub fn clients_size(self) -> bool {
              match self.combiner {
                 Combiner::Collecting{elems}
 => elems.len() <= self.num_clients,                 Combiner::Responding{elems, idx}
 => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }
          }
           pub open spec fn client_waiting(self, i: nat) -> bool {
              self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }
           pub open spec fn combiner_has(self, i: nat) -> bool {
              self.valid_idx(i)             && match self.combiner {
                 Combiner::Collecting{elems}
 => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{elems, idx}
 => i >= idx && elems.index(i as int).is_Some(),             }
          }
           pub open spec fn combiner_rid(self, i: nat) -> int {
              match self.combiner {
                 Combiner::Collecting{elems}
 => elems.index(i as int).get_Some_0(),                 Combiner::Responding{elems, idx}
 => elems.index(i as int).get_Some_0(),             }
          }
           pub open spec fn request_stored(self, i: nat) -> bool {
              self.requests.dom().contains(i)         }
           pub open spec fn response_stored(self, i: nat) -> bool {
              self.responses.dom().contains(i)         }
#[invariant]
        pub fn not_waiting_inv(self) -> bool {
              forall |i: nat|     
#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>
                !self.slots.index(i)         }
#[invariant]
        pub fn waiting_inv(self) -> bool {
              forall |i: nat|     
#[trigger] self.client_waiting(i) ==>
                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         }
#[invariant]
        pub fn request_stored_inv(self) -> bool {
              forall |i: nat|     
#[trigger] self.request_stored(i) ==>
                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         }
#[invariant]
        pub fn response_stored_inv(self) -> bool {
              forall |i: nat|     
#[trigger] self.response_stored(i) ==>
                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }
#[invariant]
        pub fn combiner_has_inv(self) -> bool {
              forall |i: nat|     
#[trigger] self.combiner_has(i) ==>
                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }
           transition!{
              client_send(j: nat, request: Request, cur_slot: bool) {
                 require(0 <= j && j < pre.num_clients);
                 remove clients -= [j => Client::Idle];
                 add    clients += [j => Client::Waiting{rid: request.rid}
];
                 remove slots -= [j => cur_slot];
                 add    slots += [j => true];
                 deposit requests += [j => request] by {                     assert(!pre.request_stored(j));                 };
             }
          }
#[inductive(client_send)]
        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {
              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
              assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));
              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));
              assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));
              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));
          }
           transition!{
              client_recv(j: nat) {
                 require(0 <= j && j < pre.num_clients);
                 remove clients -= [j => let Client::Waiting{rid}
];
                 add    clients += [j => Client::Idle];
                 have slots >= [j => false];
                 withdraw responses -= [j => let response] by {                     assert(pre.client_waiting(j));                 };
                 assert(response.rid == rid) by {                     assert(pre.client_waiting(j));                 };
             }
          }
#[inductive(client_recv)]
        fn client_recv_inductive(pre: Self, post: Self, j: nat) {
              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));
              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));
          }
           transition!{
              combiner_recv() {
                 require(pre.combiner.is_Collecting());
                 let j = pre.combiner.get_Collecting_elems().len();
                 require(0 <= j && j < pre.num_clients);
                 have slots >= [j => true];
                 withdraw requests -= [j => let request] by {                     assert(pre.valid_idx(j));                     assert(pre.client_waiting(j));                     assert(pre.request_stored(j));                 };
                 update combiner = Combiner::Collecting{                     elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };
             }
          }
#[inductive(combiner_recv)]
        fn combiner_recv_inductive(pre: Self, post: Self) {
              let j = pre.combiner.get_Collecting_elems().len();
              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
              assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));
              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));
          }
           transition!{
              combiner_go_to_responding() {
                 require(pre.combiner.is_Collecting());
                 require(pre.combiner.get_Collecting_elems().len() == pre.num_clients);
                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Collecting_elems(),                     idx: 0,                 };
             }
          }
           transition!{
              combiner_send(response: Response, cur_slot: bool) {
                 require(pre.combiner.is_Responding());
                 let j = pre.combiner.get_Responding_idx();
                 require(0 <= j && j < pre.num_clients);
                 let response_opt = pre.combiner.get_Responding_elems().index(j as int);
                 require(response_opt === Option::Some(response.rid));
                 remove slots -= [j => cur_slot];
                 add    slots += [j => false];
                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };
                 deposit responses += [j => response] by {                     assert(pre.valid_idx(j));                     assert(pre.combiner_has(j));                     assert(!pre.response_stored(j));                 };
             }
          }
#[inductive(combiner_send)]
        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {
              let j = pre.combiner.get_Responding_idx();
              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));
              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));
              assert(!post.combiner_has(j));
          }
           transition!{
              combiner_send_skip() {
                 require(pre.combiner.is_Responding());
             }
          }
#[inductive(combiner_send_skip)]
        fn combiner_send_skip_inductive(pre: Self, post: Self) {
              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));
              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));
              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));
              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));
              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));
          }
#[inductive(combiner_go_to_responding)]
        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {
              assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));
              assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));
              assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));
              assert(forall |i| post.request_stored(i) == pre.request_stored(i));
              assert(forall |i| post.response_stored(i) == pre.response_stored(i));
          }
       }
    }
     fn main() {
   }
","[""// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// Based off of the FlatCombine system from Seagull-NR.\n// A major difference is that one didn't make any use of storage, because storage was\n// rather complicated to use, and it wasn't necessary.\n// Now, I expect storage to be a lot easier to use, easier than the alternative.\n\nverus! {\n\npub struct Request {\n    pub rid: int,\n    pub req: int,\n}\n\npub struct Response {\n    pub rid: int,\n    pub resp: int,\n}\n\n#[is_variant]\npub enum Client {\n    Idle,\n    Waiting { rid: int },\n}\n\n#[is_variant]\npub enum Combiner {\n    Collecting { elems: Seq<Option<int>> },\n    Responding { elems: Seq<Option<int>>, idx: nat },\n}\n\n} // verus!\ntokenized_state_machine! {\n    FlatCombiner {\n        fields {\n            #[sharding(constant)]\n            pub num_clients: nat,\n\n            #[sharding(map)]\n            pub clients: Map<nat, Client>,\n\n            #[sharding(map)]\n            pub slots: Map<nat, bool>,\n\n            #[sharding(variable)]\n            pub combiner: Combiner,\n\n            #[sharding(storage_map)]\n            pub requests: Map<nat, Request>,\n\n            #[sharding(storage_map)]\n            pub responses: Map<nat, Response>,\n        }\n\n        pub open spec fn valid_idx(self, i: nat) -> bool {\n            0 <= i && i < self.num_clients\n        }\n\n        #[invariant]\n        pub fn clients_complete(self) -> bool {\n            forall |i: nat| (0 <= i && i < self.num_clients) ==\n                self.clients.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn slots_complete(self) -> bool {\n            forall |i: nat| (0 <= i && i < self.num_clients) ==\n                self.slots.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn clients_size(self) -> bool {\n            match self.combiner {\n                Combiner::Collecting{elems} => elems.len() <= self.num_clients,\n                Combiner::Responding{elems, idx} => elems.len() == self.num_clients &&\n                    0 <= idx && idx <= self.num_clients,\n            }\n        }\n\n        /*\n        #[verifier::spec]\n        fn should_have_req_stored(self, i: nat) -> bool {\n            0 <= i\n            && i < self.slots\n            && self.slots.index(i)\n            && match self.combiner {\n                Combiner::Collecting{elems} => elems.len() < i || elems.index(i).is_None()\n                Combiner::Responding{elems, idx} => idx >= i || elems.index(i).is_None()\n            }\n        }\n        */\n\n        pub open spec fn client_waiting(self, i: nat) -> bool {\n            self.valid_idx(i)\n            && self.clients.index(i).is_Waiting()\n        }\n\n        pub open spec fn combiner_has(self, i: nat) -> bool {\n            self.valid_idx(i)\n            && match self.combiner {\n                Combiner::Collecting{elems} => i < elems.len() && elems.index(i as int).is_Some(),\n                Combiner::Responding{elems, idx} => i >= idx && elems.index(i as int).is_Some(),\n            }\n        }\n\n        pub open spec fn combiner_rid(self, i: nat) -> int {\n            match self.combiner {\n                Combiner::Collecting{elems} => elems.index(i as int).get_Some_0(),\n                Combiner::Responding{elems, idx} => elems.index(i as int).get_Some_0(),\n            }\n        }\n\n        pub open spec fn request_stored(self, i: nat) -> bool {\n            self.requests.dom().contains(i)\n        }\n\n        pub open spec fn response_stored(self, i: nat) -> bool {\n            self.responses.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)\n        }\n\n        #[invariant]\n        pub fn waiting_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)\n        }\n\n        #[invariant]\n        pub fn request_stored_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)\n                && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()\n                && self.slots.index(i)\n        }\n\n        #[invariant]\n        pub fn response_stored_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)\n                && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()\n                && !self.slots.index(i)\n        }\n\n\n        #[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n            forall |i: nat| #[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)\n                && self.slots.index(i)\n                && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()\n                && !self.request_stored(i)\n        }\n\n        init!{\n            initialize(num_clients: nat) {\n                init num_clients = num_clients;\n                init clients = Map::new(\n                    |i: nat| 0 <= i && i < num_clients,\n                    |i: nat| Client::Idle);\n                init slots = Map::new(\n                    |i: nat| 0 <= i && i < num_clients,\n                    |i: nat| false);\n                init combiner = Combiner::Collecting { elems: Seq::empty() };\n                init requests = Map::empty();\n                init responses = Map::empty();\n            }\n        }\n\n        #[inductive(initialize)]\n        fn init_inductive(post: Self, num_clients: nat) { }\n\n        ///// Client transitions\n\n        transition!{\n            client_send(j: nat, request: Request, cur_slot: bool) {\n                require(0 <= j && j < pre.num_clients);\n\n                // Move client to 'waiting' state\n                remove clients -= [j => Client::Idle];\n                add    clients += [j => Client::Waiting{rid: request.rid}];\n\n                // Set the slot\n                remove slots -= [j => cur_slot];\n                add    slots += [j => true];\n\n                // deposit the request\n                deposit requests += [j => request] by {\n                    assert(!pre.request_stored(j));\n                };\n            }\n        }\n\n        #[inductive(client_send)]\n        fn client_send_inductive(pre: Self,\n            post: Self, j: nat, request: Request, cur_slot: bool)\n        {\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(pre.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(post.request_stored(j));\n            assert(post.client_waiting(j));\n\n            /*assert_forall_by(|i: nat| {\n                requires(post.client_waiting(i));\n                ensures(post.request_stored(i) || post.response_stored(i) || post.combiner_has(i));\n                if i == j {\n                    assert(post.request_stored(i));\n                } else {\n                    assert(pre.client_waiting(i));\n                    assert(post.request_stored(i) || post.response_stored(i) || post.combiner_has(i));\n                }\n            });*/\n        }\n\n        transition!{\n            client_recv(j: nat) {\n                require(0 <= j && j < pre.num_clients);\n\n                // Move client to 'idle' state\n                remove clients -= [j => let Client::Waiting{rid}];\n                add    clients += [j => Client::Idle];\n\n                // Check that the slot has been set back to 'false'\n                have slots >= [j => false];\n\n                // withdraw the response\n                withdraw responses -= [j => let response] by {\n                    assert(pre.client_waiting(j));\n                    //assert(!pre.request_stored(j));\n                    //assert(!pre.combiner_has(j));\n                    //assert(pre.response_stored(j));\n                };\n\n                // make sure we get back the response for the correct request id:\n                assert(response.rid == rid) by {\n                    assert(pre.client_waiting(j));\n                };\n            }\n        }\n\n        #[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(pre.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n\n            assert(!post.client_waiting(j));\n        }\n\n        ///// Combiner transitions\n\n        transition!{\n            combiner_recv() {\n                require(pre.combiner.is_Collecting());\n                let j = pre.combiner.get_Collecting_elems().len();\n                require(0 <= j && j < pre.num_clients);\n\n                // Observe that the slot has been set to 'true'\n                have slots >= [j => true];\n\n                // Withdraw a request\n                withdraw requests -= [j => let request] by {\n                    assert(pre.valid_idx(j));\n                    assert(pre.client_waiting(j));\n                    assert(pre.request_stored(j));\n                };\n\n                // Update combiner's local state to remember we withdrew a request with this ID\n                update combiner = Combiner::Collecting{\n                    elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),\n                };\n            }\n        }\n\n        #[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Collecting_elems().len();\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(pre.client_waiting(j));\n            assert(pre.request_stored(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_skip() {\n                require(pre.combiner.is_Collecting());\n                let j = pre.combiner.get_Collecting_elems().len();\n                require(0 <= j && j < pre.num_clients);\n\n                // In practice, this happens when slot j is set to false, so we could add this:\n                //    have slots >= [j => false];\n                // but it's not necessary\n\n                // Update combiner's local state to remember that we didn't withdraw\n                // anything here.\n                update combiner = Combiner::Collecting{\n                    elems: pre.combiner.get_Collecting_elems().push(Option::None),\n                };\n            }\n        }\n\n        #[inductive(combiner_skip)]\n        fn combiner_skip_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Collecting_elems().len();\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(!post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_go_to_responding() {\n                require(pre.combiner.is_Collecting());\n                require(pre.combiner.get_Collecting_elems().len() == pre.num_clients);\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Collecting_elems(),\n                    idx: 0,\n                };\n            }\n        }\n\n        transition!{\n            combiner_send(response: Response, cur_slot: bool) {\n                require(pre.combiner.is_Responding());\n                let j = pre.combiner.get_Responding_idx();\n                require(0 <= j && j < pre.num_clients);\n                let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n\n                // The response we return has to have the right request ID\n                require(response_opt === Option::Some(response.rid));\n\n                // Set the slot back to false\n                remove slots -= [j => cur_slot];\n                add    slots += [j => false];\n\n                // Update the combiner's local state\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Responding_elems(),\n                    idx: j + 1,\n                };\n\n                deposit responses += [j => response] by {\n                    assert(pre.valid_idx(j));\n                    assert(pre.combiner_has(j));\n                    assert(!pre.response_stored(j));\n                };\n            }\n        }\n\n        #[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n            let j = pre.combiner.get_Responding_idx();\n\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n\n            assert(pre.valid_idx(j));\n            assert(pre.combiner_has(j));\n            assert(pre.client_waiting(j));\n\n            assert(!post.combiner_has(j));\n        }\n\n        transition!{\n            combiner_send_skip() {\n                require(pre.combiner.is_Responding());\n                let j = pre.combiner.get_Responding_idx();\n                require(0 <= j && j < pre.num_clients);\n                let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n\n                // The response we return has to have the right request ID\n                require(equal(response_opt, Option::None));\n\n                // Update the combiner's local state\n                update combiner = Combiner::Responding{\n                    elems: pre.combiner.get_Responding_elems(),\n                    idx: j + 1,\n                };\n            }\n        }\n\n        #[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n            let j = pre.combiner.get_Responding_idx();\n\n            assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n            assert(post.valid_idx(j));\n            assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n\n            assert(!post.combiner_has(j));\n        }\n\n        #[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_responding_inductive(pre: Self, post: Self) {\n            assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n            assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n        }\n\n        transition!{\n            combiner_go_to_collecting() {\n                require(pre.combiner.is_Responding());\n                require(pre.combiner.get_Responding_idx() == pre.num_clients);\n                update combiner = Combiner::Collecting{ elems: Seq::empty() };\n            }\n        }\n\n        #[inductive(combiner_go_to_collecting)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n            assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n            assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n            assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n            assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n            assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n        }\n\n    }\n}\n\nfn main() {}\n"", 'use vstd;\nfn main() {}\n', ' use vstd::prelude::*;\n     use verus_state_machines_macros::tokenized_state_machine;\n     verus! {\n    pub struct Request {\n       pub rid: int,     pub req: int, }\n    pub struct Response {\n       pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n       Idle,     Waiting {\n  rid: int }\n  , }\n#[is_variant]\npub enum Combiner {\n       Collecting {\n  elems: Seq<Option<int>> }\n  ,     Responding {\n  elems: Seq<Option<int>>, idx: nat }\n  , }\n    }\n      tokenized_state_machine! {\n        FlatCombiner {\n           fields {\n#[sharding(constant)]\n            pub num_clients: nat,                 \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                 \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                 \n#[sharding(variable)]\n            pub combiner: Combiner,                 \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                 \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n           pub open spec fn valid_idx(self, i: nat) -> bool {\n              0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.len() <= self.num_clients,                 Combiner::Responding{elems, idx}\n => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n          }\n           pub open spec fn client_waiting(self, i: nat) -> bool {\n              self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n           pub open spec fn combiner_has(self, i: nat) -> bool {\n              self.valid_idx(i)             && match self.combiner {\n                 Combiner::Collecting{elems}\n => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{elems, idx}\n => i >= idx && elems.index(i as int).is_Some(),             }\n          }\n           pub open spec fn combiner_rid(self, i: nat) -> int {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.index(i as int).get_Some_0(),                 Combiner::Responding{elems, idx}\n => elems.index(i as int).get_Some_0(),             }\n          }\n           pub open spec fn request_stored(self, i: nat) -> bool {\n              self.requests.dom().contains(i)         }\n           pub open spec fn response_stored(self, i: nat) -> bool {\n              self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         }\n#[invariant]\n        pub fn request_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         }\n#[invariant]\n        pub fn response_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n           transition!{\n              client_send(j: nat, request: Request, cur_slot: bool) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => Client::Idle];\n                 add    clients += [j => Client::Waiting{rid: request.rid}\n];\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => true];\n                 deposit requests += [j => request] by {                     assert(!pre.request_stored(j));                 };\n             }\n          }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              client_recv(j: nat) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => let Client::Waiting{rid}\n];\n                 add    clients += [j => Client::Idle];\n                 have slots >= [j => false];\n                 withdraw responses -= [j => let response] by {                     assert(pre.client_waiting(j));                 };\n                 assert(response.rid == rid) by {                     assert(pre.client_waiting(j));                 };\n             }\n          }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_recv() {\n                 require(pre.combiner.is_Collecting());\n                 let j = pre.combiner.get_Collecting_elems().len();\n                 require(0 <= j && j < pre.num_clients);\n                 have slots >= [j => true];\n                 withdraw requests -= [j => let request] by {                     assert(pre.valid_idx(j));                     assert(pre.client_waiting(j));                     assert(pre.request_stored(j));                 };\n                 update combiner = Combiner::Collecting{                     elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n             }\n          }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n              let j = pre.combiner.get_Collecting_elems().len();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_go_to_responding() {\n                 require(pre.combiner.is_Collecting());\n                 require(pre.combiner.get_Collecting_elems().len() == pre.num_clients);\n                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Collecting_elems(),                     idx: 0,                 };\n             }\n          }\n           transition!{\n              combiner_send(response: Response, cur_slot: bool) {\n                 require(pre.combiner.is_Responding());\n                 let j = pre.combiner.get_Responding_idx();\n                 require(0 <= j && j < pre.num_clients);\n                 let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                 require(response_opt === Option::Some(response.rid));\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => false];\n                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };\n                 deposit responses += [j => response] by {                     assert(pre.valid_idx(j));                     assert(pre.combiner_has(j));                     assert(!pre.response_stored(j));                 };\n             }\n          }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n              let j = pre.combiner.get_Responding_idx();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n              assert(!post.combiner_has(j));\n          }\n           transition!{\n              combiner_send_skip() {\n                 require(pre.combiner.is_Responding());\n             }\n          }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n          }\n       }\n    }\n     fn main() {\n   }\n', ' use vstd::prelude::*;\n     use verus_state_machines_macros::tokenized_state_machine;\n     verus! {\n    pub struct Request {\n       pub rid: int,     pub req: int, }\n    pub struct Response {\n       pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n       Idle,     Waiting {\n  rid: int }\n  , }\n#[is_variant]\npub enum Combiner {\n       Collecting {\n  elems: Seq<Option<int>> }\n  ,     Responding {\n  elems: Seq<Option<int>>, idx: nat }\n  , }\n    }\n      tokenized_state_machine! {\n        FlatCombiner {\n           fields {\n#[sharding(constant)]\n            pub num_clients: nat,                 \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                 \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                 \n#[sharding(variable)]\n            pub combiner: Combiner,                 \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                 \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n           pub open spec fn valid_idx(self, i: nat) -> bool {\n              0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.len() <= self.num_clients,                 Combiner::Responding{elems, idx}\n => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n          }\n           pub open spec fn client_waiting(self, i: nat) -> bool {\n              self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n           pub open spec fn combiner_has(self, i: nat) -> bool {\n              self.valid_idx(i)             && match self.combiner {\n                 Combiner::Collecting{elems}\n => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{elems, idx}\n => i >= idx && elems.index(i as int).is_Some(),             }\n          }\n           pub open spec fn combiner_rid(self, i: nat) -> int {\n              match self.combiner {\n                 Combiner::Collecting{elems}\n => elems.index(i as int).get_Some_0(),                 Combiner::Responding{elems, idx}\n => elems.index(i as int).get_Some_0(),             }\n          }\n           pub open spec fn request_stored(self, i: nat) -> bool {\n              self.requests.dom().contains(i)         }\n           pub open spec fn response_stored(self, i: nat) -> bool {\n              self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         }\n#[invariant]\n        pub fn request_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         }\n#[invariant]\n        pub fn response_stored_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n              forall |i: nat|     \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n           transition!{\n              client_send(j: nat, request: Request, cur_slot: bool) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => Client::Idle];\n                 add    clients += [j => Client::Waiting{rid: request.rid}\n];\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => true];\n                 deposit requests += [j => request] by {                     assert(!pre.request_stored(j));                 };\n             }\n          }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) && i != j ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) && i != j ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              client_recv(j: nat) {\n                 require(0 <= j && j < pre.num_clients);\n                 remove clients -= [j => let Client::Waiting{rid}\n];\n                 add    clients += [j => Client::Idle];\n                 have slots >= [j => false];\n                 withdraw responses -= [j => let response] by {                     assert(pre.client_waiting(j));                 };\n             }\n          }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_recv() {\n                 require(pre.combiner.is_Collecting());\n                 let j = pre.combiner.get_Collecting_elems().len();\n                 require(0 <= j && j < pre.num_clients);\n                 have slots >= [j => true];\n                 withdraw requests -= [j => let request] by {                     assert(pre.valid_idx(j));                     assert(pre.client_waiting(j));                     assert(pre.request_stored(j));                 };\n                 update combiner = Combiner::Collecting{                     elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n             }\n          }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n              let j = pre.combiner.get_Collecting_elems().len();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n           transition!{\n              combiner_go_to_responding() {\n             }\n          }\n           transition!{\n              combiner_send(response: Response, cur_slot: bool) {\n                 require(pre.combiner.is_Responding());\n                 let j = pre.combiner.get_Responding_idx();\n                 require(0 <= j && j < pre.num_clients);\n                 let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                 require(response_opt === Option::Some(response.rid));\n                 remove slots -= [j => cur_slot];\n                 add    slots += [j => false];\n                 update combiner = Combiner::Responding{                     elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };\n                 deposit responses += [j => response] by {                     assert(pre.valid_idx(j));                     assert(pre.combiner_has(j));                     assert(!pre.response_stored(j));                 };\n             }\n          }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n              let j = pre.combiner.get_Responding_idx();\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n              assert(!post.combiner_has(j));\n          }\n           transition!{\n              combiner_send_skip() {\n             }\n          }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n          }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n              assert(forall |i| post.valid_idx(i) == pre.valid_idx(i));\n              assert(forall |i| post.client_waiting(i) == pre.client_waiting(i));\n              assert(forall |i| post.combiner_has(i) == pre.combiner_has(i));\n              assert(forall |i| post.request_stored(i) == pre.request_stored(i));\n              assert(forall |i| post.response_stored(i) == pre.response_stored(i));\n          }\n       }\n    }\n     fn main() {\n   }\n', ' use vstd::prelude::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n        verus! {\n       pub struct Request {\n          pub rid: int,     pub req: int, }\n       pub struct Response {\n          pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n          Idle,     Waiting {\n     rid: int }\n     , }\n#[is_variant]\npub enum Combiner {\n          Collecting {\n     elems: Seq<Option<int>> }\n     ,     Responding {\n     elems: Seq<Option<int>>, idx: nat }\n     , }\n       }\n         tokenized_state_machine! {\n           FlatCombiner {\n              fields {\n#[sharding(constant)]\n            pub num_clients: nat,                    \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                    \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                    \n#[sharding(variable)]\n            pub combiner: Combiner,                    \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                    \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n              pub open spec fn valid_idx(self, i: nat) -> bool {\n                 0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                 match self.combiner {\n                    Combiner::Collecting{\n  elems}\n    => elems.len() <= self.num_clients,                 Combiner::Responding{\n  elems, idx}\n    => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n             }\n              pub open spec fn client_waiting(self, i: nat) -> bool {\n                 self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n              pub open spec fn combiner_has(self, i: nat) -> bool {\n                 self.valid_idx(i)             && match self.combiner {\n                    Combiner::Collecting{\n  elems}\n    => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{\n  elems, idx}\n    => i >= idx && elems.index(i as int).is_Some(),             }\n             }\n              pub open spec fn combiner_rid(self, i: nat) -> int {\n                 match self.combiner {\n                    Combiner::Collecting{\n  elems}\n    => elems.index(i as int).get_Some_0(),                 Combiner::Responding{\n  elems, idx}\n    => elems.index(i as int).get_Some_0(),             }\n             }\n              pub open spec fn request_stored(self, i: nat) -> bool {\n                 self.requests.dom().contains(i)         }\n              pub open spec fn response_stored(self, i: nat) -> bool {\n                 self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         }\n#[invariant]\n        pub fn request_stored_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         }\n#[invariant]\n        pub fn response_stored_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n                 forall |i: nat|        \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n              transition!{\n                 client_send(j: nat, request: Request, cur_slot: bool) {}\n             }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {}\n              transition!{\n                 client_recv(j: nat) {}\n             }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {}\n              transition!{\n                 combiner_recv() {\n                    require(pre.combiner.is_Collecting());\n                    let j = pre.combiner.get_Collecting_elems().len();\n                    require(0 <= j && j < pre.num_clients);\n                    have slots >= [j => true];\n                    withdraw requests -= [j => let request] by {\n                       assert(pre.valid_idx(j));\n                       assert(pre.client_waiting(j));\n                   };\n                    update combiner = Combiner::Collecting{\n                       elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n                }\n             }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n                 let j = pre.combiner.get_Collecting_elems().len();\n                 assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n                 assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n                 assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n                 assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n                 assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n             }\n              transition!{\n                 combiner_go_to_responding() {}\n             }\n              transition!{\n                 combiner_send(response: Response, cur_slot: bool) {\n                    require(pre.combiner.is_Responding());\n                    let j = pre.combiner.get_Responding_idx();\n                    require(0 <= j && j < pre.num_clients);\n                    let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                    require(response_opt === Option::Some(response.rid));\n                    remove slots -= [j => cur_slot];\n                    add    slots += [j => false];\n                    update combiner = Combiner::Responding{\n                       elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };\n                    deposit responses += [j => response] by {\n                       assert(pre.combiner_has(j));\n                       assert(!pre.response_stored(j));\n                   };\n                }\n             }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n                 let j = pre.combiner.get_Responding_idx();\n                 assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n                 assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n                 assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n                 assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n                 assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));\n                 assert(!post.combiner_has(j));\n             }\n              transition!{\n                 combiner_send_skip() {}\n             }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {}\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {}\n          }\n       }\n        fn main() {}\n', ' use vstd::prelude::*;\n         use verus_state_machines_macros::tokenized_state_machine;\n         verus! {        pub struct Request {           pub rid: int,     pub req: int, }        pub struct Response {           pub rid: int,     pub resp: int, } \n#[is_variant]\npub enum Client {           Idle,     Waiting {      rid: int }      , } \n#[is_variant]\npub enum Combiner {           Collecting {      elems: Seq<Option<int>> }      ,     Responding {      elems: Seq<Option<int>>, idx: nat }      , }        }\n          tokenized_state_machine! {            FlatCombiner {               fields { \n#[sharding(constant)]\n            pub num_clients: nat,                     \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                     \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                     \n#[sharding(variable)]\n            pub combiner: Combiner,                     \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                     \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }               pub open spec fn valid_idx(self, i: nat) -> bool {                  0 <= i && i < self.num_clients         } \n#[invariant]\n        pub fn clients_size(self) -> bool {                  match self.combiner {                     Combiner::Collecting{   elems}     => elems.len() <= self.num_clients,                 Combiner::Responding{   elems, idx}     => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }              }               pub open spec fn client_waiting(self, i: nat) -> bool {                  self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }               pub open spec fn combiner_has(self, i: nat) -> bool {                  self.valid_idx(i)             && match self.combiner {                     Combiner::Collecting{   elems}     => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{   elems, idx}     => i >= idx && elems.index(i as int).is_Some(),             }              }               pub open spec fn combiner_rid(self, i: nat) -> int {                  match self.combiner {                     Combiner::Collecting{   elems}     => elems.index(i as int).get_Some_0(),                 Combiner::Responding{   elems, idx}     => elems.index(i as int).get_Some_0(),             }              }               pub open spec fn request_stored(self, i: nat) -> bool {                  self.requests.dom().contains(i)         }               pub open spec fn response_stored(self, i: nat) -> bool {                  self.responses.dom().contains(i)         } \n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         } \n#[invariant]\n        pub fn waiting_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.client_waiting(i) ==>\n                self.request_stored(i) || self.response_stored(i) || self.combiner_has(i)         } \n#[invariant]\n        pub fn request_stored_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.request_stored(i) ==>\n                self.client_waiting(i)                 && self.requests.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && self.slots.index(i)         } \n#[invariant]\n        pub fn response_stored_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.response_stored(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         } \n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {                  forall |i: nat|         \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }               transition!{                  client_send(j: nat, request: Request, cur_slot: bool) {}              } \n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {}               transition!{                  client_recv(j: nat) {}              } \n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {}               transition!{                  combiner_recv() {                     require(pre.combiner.is_Collecting());                     let j = pre.combiner.get_Collecting_elems().len();                     require(0 <= j && j < pre.num_clients);                     have slots >= [j => true];                     withdraw requests -= [j => let request] by {                        assert(pre.valid_idx(j));                        assert(pre.client_waiting(j));                    };                     update combiner = Combiner::Collecting{                        elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };                 }              } \n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {                  let j = pre.combiner.get_Collecting_elems().len();                  assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));                  assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));                  assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));                  assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));                  assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));              }               transition!{                  combiner_go_to_responding() {}              }               transition!{                  combiner_send(response: Response, cur_slot: bool) {                     require(pre.combiner.is_Responding());                     let j = pre.combiner.get_Responding_idx();                     require(0 <= j && j < pre.num_clients);                     let response_opt = pre.combiner.get_Responding_elems().index(j as int);                     require(response_opt === Option::Some(response.rid));                     remove slots -= [j => cur_slot];                     add    slots += [j => false];                     update combiner = Combiner::Responding{                        elems: pre.combiner.get_Responding_elems(),                     idx: j + 1,                 };                     deposit responses += [j => response] by {                        assert(pre.combiner_has(j));                        assert(!pre.response_stored(j));                    };                 }              } \n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {                  let j = pre.combiner.get_Responding_idx();                  assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));                  assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));                  assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));                  assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));                  assert(forall |i| post.response_stored(i) && i != j ==> pre.response_stored(i));                  assert(!post.combiner_has(j));              }               transition!{                  combiner_send_skip() {}              } \n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {} \n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {}           }        }\n         fn main() {}\n', ' use vstd::prelude::*;\n             use verus_state_machines_macros::tokenized_state_machine;\n             verus! {\n           pub struct Request {\n             pub rid: int,     pub req: int, }\n           pub struct Response {\n             pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n             Idle,     Waiting {\n       rid: int }\n        , }\n#[is_variant]\npub enum Combiner {\n             Collecting {\n       elems: Seq<Option<int>> }\n        ,     Responding {\n       elems: Seq<Option<int>>, idx: nat }\n        , }\n           }\n              tokenized_state_machine! {\n               FlatCombiner {\n                 fields {\n#[sharding(constant)]\n            pub num_clients: nat,                         \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                         \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                         \n#[sharding(variable)]\n            pub combiner: Combiner,                         \n#[sharding(storage_map)]\n            pub requests: Map<nat, Request>,                         \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n                 pub open spec fn valid_idx(self, i: nat) -> bool {\n                   0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                   match self.combiner {\n                     Combiner::Collecting{   elems}\n     => elems.len() <= self.num_clients,                 Combiner::Responding{   elems, idx}\n     => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n               }\n                 pub open spec fn client_waiting(self, i: nat) -> bool {\n                   self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n                 pub open spec fn combiner_has(self, i: nat) -> bool {\n                   self.valid_idx(i)             && match self.combiner {\n                     Combiner::Collecting{   elems}\n     => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{   elems, idx}\n     => i >= idx && elems.index(i as int).is_Some(),             }\n               }\n                 pub open spec fn combiner_rid(self, i: nat) -> int {\n                   match self.combiner {\n                     Combiner::Collecting{   elems}\n     => elems.index(i as int).get_Some_0(),                 Combiner::Responding{   elems, idx}\n     => elems.index(i as int).get_Some_0(),             }\n               }\n                 pub open spec fn request_stored(self, i: nat) -> bool {\n                   self.requests.dom().contains(i)         }\n                 pub open spec fn response_stored(self, i: nat) -> bool {\n                   self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.client_waiting(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n                 transition!{\n                   client_send(j: nat, request: Request, cur_slot: bool) {\n}\n               }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n }\n                 transition!{\n                   client_recv(j: nat) {\n}\n               }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n }\n                 transition!{\n                   combiner_recv() {\n                     require(pre.combiner.is_Collecting());\n                     let j = pre.combiner.get_Collecting_elems().len();\n                     require(0 <= j && j < pre.num_clients);\n                     have slots >= [j => true];\n                     withdraw requests -= [j => let request] by {                        assert(pre.valid_idx(j));                        assert(pre.client_waiting(j));                    };\n                     update combiner = Combiner::Collecting{                        elems: pre.combiner.get_Collecting_elems().push(Option::Some(request.rid)),                 };\n                 }\n               }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n                   let j = pre.combiner.get_Collecting_elems().len();\n                   assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n                   assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n                   assert(forall |i| post.combiner_has(i) && i != j ==> pre.combiner_has(i));\n                   assert(forall |i| post.request_stored(i) ==> pre.request_stored(i));\n                   assert(forall |i| post.response_stored(i) ==> pre.response_stored(i));\n               }\n                 transition!{\n                   combiner_go_to_responding() {\n}\n               }\n                 transition!{\n                   combiner_send(response: Response, cur_slot: bool) {\n                     require(pre.combiner.is_Responding());\n                     let j = pre.combiner.get_Responding_idx();\n                     require(0 <= j && j < pre.num_clients);\n                     let response_opt = pre.combiner.get_Responding_elems().index(j as int);\n                     require(response_opt === Option::Some(response.rid));\n                 }\n               }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n                   let j = pre.combiner.get_Responding_idx();\n                   assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n                   assert(forall |i| post.client_waiting(i) ==> pre.client_waiting(i));\n                   assert(forall |i| post.combiner_has(i) ==> pre.combiner_has(i));\n                   assert(!post.combiner_has(j));\n               }\n                 transition!{\n                   combiner_send_skip() {\n}\n               }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n }\n             }\n           }\n             fn main() {\n   }\n', ' use vstd::prelude::*;\n             use verus_state_machines_macros::tokenized_state_machine;\n             verus! {\n           pub struct Request {\n             pub rid: int,     pub req: int, }\n           pub struct Response {\n             pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n             Idle,     Waiting {\n       rid: int }\n        , }\n#[is_variant]\npub enum Combiner {\n             Collecting {\n       elems: Seq<Option<int>> }\n        ,     Responding {\n       elems: Seq<Option<int>>, idx: nat }\n        , }\n           }\n              tokenized_state_machine! {\n               FlatCombiner {\n                 fields {\n#[sharding(constant)]\n            pub num_clients: nat,                         \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                         \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                         \n#[sharding(variable)]\n            pub combiner: Combiner,                         \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n                 pub open spec fn valid_idx(self, i: nat) -> bool {\n                   0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                   match self.combiner {\n                     Combiner::Collecting{   elems}\n     => elems.len() <= self.num_clients,                 Combiner::Responding{   elems, idx}\n     => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n               }\n                 pub open spec fn client_waiting(self, i: nat) -> bool {\n                   self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n                 pub open spec fn combiner_has(self, i: nat) -> bool {\n                   self.valid_idx(i)             && match self.combiner {\n                     Combiner::Collecting{   elems}\n     => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{   elems, idx}\n     => i >= idx && elems.index(i as int).is_Some(),             }\n               }\n                 pub open spec fn combiner_rid(self, i: nat) -> int {\n                   match self.combiner {\n                     Combiner::Collecting{   elems}\n     => elems.index(i as int).get_Some_0(),                 Combiner::Responding{   elems, idx}\n     => elems.index(i as int).get_Some_0(),             }\n               }\n                 pub open spec fn request_stored(self, i: nat) -> bool {\n                   self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.valid_idx(i) && self.clients.index(i).is_Idle() ==>\n                !self.slots.index(i)         }\n#[invariant]\n        pub fn waiting_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.client_waiting(i) ==>\n                self.client_waiting(i)                 && self.responses.index(i).rid == self.clients.index(i).get_Waiting_rid()                 && !self.slots.index(i)         }\n#[invariant]\n        pub fn combiner_has_inv(self) -> bool {\n                   forall |i: nat|             \n#[trigger] self.combiner_has(i) ==>\n                self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n                 transition!{\n                   client_send(j: nat, request: Request, cur_slot: bool) {\n}\n               }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n }\n                 transition!{\n                   client_recv(j: nat) {\n}\n               }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n }\n                 transition!{\n                   combiner_recv() {\n                 }\n               }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n                   let j = pre.combiner.get_Collecting_elems().len();\n                   assert(forall |i| post.valid_idx(i) ==> pre.valid_idx(i));\n               }\n                 transition!{\n                   combiner_go_to_responding() {\n}\n               }\n                 transition!{\n                   combiner_send(response: Response, cur_slot: bool) {\n                 }\n               }\n#[inductive(combiner_send)]\n        fn combiner_send_inductive(pre: Self, post: Self, response: Response, cur_slot: bool) {\n               }\n                 transition!{\n                   combiner_send_skip() {\n}\n               }\n#[inductive(combiner_send_skip)]\n        fn combiner_send_skip_inductive(pre: Self, post: Self) {\n }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n }\n             }\n           }\n             fn main() {\n   }\n', ' use vstd::prelude::*;\n              use verus_state_machines_macros::tokenized_state_machine;\n              verus! {\n            pub struct Request {\n              pub rid: int,     pub req: int, }\n            pub struct Response {\n              pub rid: int,     pub resp: int, }\n#[is_variant]\npub enum Client {\n              Idle,     Waiting {\n        rid: int }\n         , }\n pub enum Combiner {\n              Collecting {\n        elems: Seq<Option<int>> }\n         ,     Responding {\n        elems: Seq<Option<int>>, idx: nat }\n         , }\n            }\n               tokenized_state_machine! {\n                FlatCombiner {\n                  fields {\n#[sharding(constant)]\n            pub num_clients: nat,                          \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                          \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                          \n#[sharding(variable)]\n            pub combiner: Combiner,                          \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>,         }\n                  pub open spec fn valid_idx(self, i: nat) -> bool {\n                    0 <= i && i < self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                    match self.combiner {\n                      Combiner::Collecting{\n   elems}\n      => elems.len() <= self.num_clients,                 Combiner::Responding{\n   elems, idx}\n      => elems.len() == self.num_clients &&                     0 <= idx && idx <= self.num_clients,             }\n                }\n                  pub open spec fn client_waiting(self, i: nat) -> bool {\n                    self.valid_idx(i)             && self.clients.index(i).is_Waiting()         }\n                  pub open spec fn combiner_has(self, i: nat) -> bool {\n                    self.valid_idx(i)             && match self.combiner {\n                      Combiner::Collecting{\n   elems}\n      => i < elems.len() && elems.index(i as int).is_Some(),                 Combiner::Responding{\n   elems, idx}\n      => i >= idx && elems.index(i as int).is_Some(),             }\n                }\n                  pub open spec fn combiner_rid(self, i: nat) -> int {\n                    match self.combiner {\n                      Combiner::Collecting{\n   elems}\n      => elems.index(i as int).get_Some_0(),                 Combiner::Responding{\n   elems, idx}\n      => elems.index(i as int).get_Some_0(),             }\n                }\n                  pub open spec fn request_stored(self, i: nat) -> bool {\n                    self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                    forall |i: nat|                              self.client_waiting(i)                 && self.slots.index(i)                 && self.combiner_rid(i) == self.clients.index(i).get_Waiting_rid()                 && !self.request_stored(i)         }\n                  transition!{\n                    client_send(j: nat, request: Request, cur_slot: bool) {\n }\n                }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n  }\n                  transition!{\n                    client_recv(j: nat) {\n }\n                }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n  }\n                  transition!{\n                    combiner_recv() {\n                  }\n                }\n#[inductive(combiner_recv)]\n        fn combiner_recv_inductive(pre: Self, post: Self) {\n                }\n                  transition!{\n                    combiner_go_to_responding() {\n }\n                }\n#[inductive(combiner_go_to_responding)]\n        fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n  }\n              }\n            }\n              fn main() {\n    }\n', ' use vstd::prelude::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                verus! {\n              struct Request {\n                ridreq: int}\n              struct Response {\n                ridresp: int}\n#[is_variant]\npub enum Client {\n                Waiting {\n          rid: int }\n           }\n   pub enum Combiner {\n                Collecting {\n          elems: Seq<Option<int>> }\n           ,     Responding {\n          elems: Seq<Option<int>>, idx: nat }\n           }\n              }\n                 tokenized_state_machine! {\n                  FlatCombiner {\n                    fields {\n#[sharding(constant)]\n            pub num_clients: nat,                            \n#[sharding(map)]\n            pub clients: Map<nat, Client>,                            \n#[sharding(map)]\n            pub slots: Map<nat, bool>,                            \n#[sharding(variable)]\n            pub combiner: Combiner,                            \n#[sharding(storage_map)]\n            pub responses: Map<nat, Response>}\n                    pub open spec fn valid_idx(self, i: nat) -> bool {\n                      0 <= self.num_clients         }\n#[invariant]\n        pub fn clients_size(self) -> bool {\n                      match self.combiner {\n                        Combiner::Collecting{\n     elems}\n        => elems.len() <= self.num_clients,                 Combiner::Responding{\n     elems, idx}\n        => elems.len() <= self.num_clients}\n                  }\n                    pub open spec fn client_waiting(self, i: nat) -> bool {\n                      self.clients.index(i).is_Waiting()         }\n                    spec fn combiner_has(self, i: nat) -> bool {\n                      match self.combiner {\n                        Combiner::Collecting{\n     elems}\n        => elems.index(i as int).is_Some(),                 Combiner::Responding{\n     elems, idx}\n        => elems.index(i as int).is_Some()}\n                  }\n                    pub open spec fn combiner_rid(self, i: nat) -> int {\n                      match self.combiner {\n                        Combiner::Collecting{\n     elems}\n        => elems.index(i as int).get_Some_0(),                 Combiner::Responding{\n     elems, idx}\n        => elems.index(i as int).get_Some_0()}\n                  }\n                    pub open spec fn request_stored(self, i: nat) -> bool {\n                      self.responses.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                      forall |i|                              && (i) == self.clients.index(i).get_Waiting_rid()         }\n                    transition!{\n                      client_send(j: nat, request: Request, cur_slot: bool) {\n   }\n                  }\n#[inductive(client_send)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: Request, cur_slot: bool)         {\n    }\n                    transition!{\n                      client_recv(j: nat) {\n   }\n                  }\n#[inductive(client_recv)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n    }\n                    fn combiner_recv_inductive(pre: Self, post: Self) {\n                  }\n                    fn combiner_go_to_collecting_inductive(pre: Self, post: Self) {\n    }\n                }\n              }\n                fn main() {\n      }\n', ' use vstd::prelude::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                verus! {\n              struct a {\n                 }\n              struct b {\n                 }\n#[is_variant]\npub enum c {\n                Waiting {\n          rid: int }\n           }\n   pub enum d {\n                e {\n          elems: Seq<Option<int>> }\n           ,     f {\n          elems: Seq<Option<int>>, g: nat }\n           }\n              }\n                 tokenized_state_machine! {\n                  h {\n                    fields {\n#[sharding(constant)]\n            pub k: nat,                            \n#[sharding(map)]\n            pub clients: Map<nat, c>,                            \n#[sharding(map)]\n            pub l: Map<nat, bool>,                            \n#[sharding(variable)]\n            pub combiner: d,                            \n#[sharding(storage_map)]\n            pub m: Map<nat, b>}\n                      spec fn n(self  ) -> bool {\n                      0 <= self.k         }\n#[invariant]\n        pub fn o(self) -> bool {\n                      match self.combiner {\n                        d::e{\n     elems}\n        => elems.len() <= self.k,                 d::f{\n     elems, g}\n        => elems.len() <= self.k}\n                  }\n                      spec fn p(self, i: nat) -> bool {\n                      self.clients.index(i).is_Waiting()         }\n                    spec fn combiner_has(self, i: nat) -> bool {\n                      match self.combiner {\n                        d::e{\n     elems}\n        => elems.index(i as int).is_Some(),                 d::f{\n     elems, g}\n        => elems.index(i as int).is_Some()}\n                  }\n                      spec fn q(self, i: nat) -> int {\n                      match self.combiner {\n                        d::e{\n     elems}\n        => elems.index(i as int).get_Some_0(),                 d::f{\n     elems, g}\n        => elems.index(i as int).get_Some_0()}\n                  }\n                      spec fn r(self, i: nat) -> bool {\n                      self.m.dom().contains(i)         }\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool {\n                      forall |i|                               i == self.clients.index(i).get_Waiting_rid()         }\n                    transition!{\n                      s(j: nat, request: a, cur_slot: bool) {\n   }\n                  }\n#[inductive(s)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: a, cur_slot: bool)         {\n    }\n                    transition!{\n                      t(j: nat) {\n   }\n                  }\n#[inductive(t)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {\n    }\n                    fn u(  post: Self) {\n                  }\n                    fn combiner_go_to_collecting_inductive(  post: Self) {\n    }\n                }\n              }\n                fn main() {\n      }\n', ' use vstd::prelude::*;\n                use verus_state_machines_macros::tokenized_state_machine;\n                verus! {\n              struct a ;\n              struct b ;\n#[is_variant]\npub enum c {\n                Waiting {}\n           }\n   pub enum d {\n                e {}\n           ,     f {}\n           }\n              }\n                 tokenized_state_machine! {\n                  h {\n                    fields {}\n                      spec fn n(self  ) -> bool ;\n#[invariant]\n        pub fn o(self) -> bool ;\n                      spec fn p(self, i: nat) -> bool ;\n                    spec fn combiner_has(self, i: nat) -> bool ;\n                      spec fn q(self, i: nat) -> int ;\n                      spec fn r(self, i: nat) -> bool ;\n#[invariant]\n        pub fn not_waiting_inv(self) -> bool ;\n                    transition!{\n                      s(j: nat, request: a, cur_slot: bool) {}\n                  }\n#[inductive(s)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: a, cur_slot: bool)         {}\n                    transition!{\n                      t(j: nat) {}\n                  }\n#[inductive(t)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {}\n                    fn u(  post: Self) ;\n                    fn combiner_go_to_collecting_inductive(  post: Self) ;\n                }\n              }\n                fn main() {}\n', ' use vstd::prelude::*;\n                  use verus_state_machines_macros::tokenized_state_machine;\n                  verus! {\n               struct a ;\n               struct b ;\n               }\n                   tokenized_state_machine! {\n                   h {                     fields {}                       spec fn n() -> bool ;  \n#[invariant]\n        pub fn not_waiting_inv(self) -> bool ;                     transition!{                       s(j: nat, request: a, cur_slot: bool) {}                   }  \n#[inductive(s)]\n        fn client_send_inductive(pre: Self,             post: Self, j: nat, request: a, cur_slot: bool)         {}                     transition!{                       t(j: nat) {}                   }  \n#[inductive(t)]\n        fn client_recv_inductive(pre: Self, post: Self, j: nat) {}                     fn u() ;                     fn combiner_go_to_collecting_inductive() ;                 }\n               }\n                  fn main() {\n}\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  h {\n    fields {}\n  }\n}\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/interner.rs,293,94,0.32081911262798635,1157.734,True,0.9999999999999999,False,"['vstd::cell::', 'vstd::invariant::', 'vstd::map::', 'vstd::modes::', 'vstd::multiset::', 'vstd::prelude::', 'vstd::seq::', 'vstd::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,True,,1.0,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#![allow(unused_imports)]

use vstd::cell::*;
use vstd::invariant::*;
use vstd::map::*;
use vstd::modes::*;
use vstd::multiset::*;
use vstd::prelude::*;
use vstd::seq::*;
use vstd::{pervasive::*, prelude::*, *};

use verus_state_machines_macros::tokenized_state_machine;

tokenized_state_machine! {InternSystem<T> {
    fields {
        #[sharding(variable)]
        pub auth: Seq<T>,

        #[sharding(persistent_map)]
        pub frag: Map<int, T>,
    }

    init!{
        empty() {
            init auth = Seq::empty();
            init frag = Map::empty();
        }
    }

    transition!{
        insert(val: T) {
            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);
            update auth = pre.auth.push(val);
        }
    }

    transition!{
        get_frag(idx: int) {
            require(0 <= idx && idx < pre.auth.len());
            let val = pre.auth.index(idx);
            add frag (union)= [idx => val];
        }
    }

    property!{
        get_value(i: int) {
            have frag >= [i => let val];
            assert(i < pre.auth.len() && pre.auth.index(i) === val);
        }
    }

    property!{
        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {
            have frag >= [idx1 => val1];
            have frag >= [idx2 => val2];
            assert((idx1 == idx2) <==> (val1 === val2));
        }
    }

    #[invariant]
    pub fn agreement(&self) -> bool {
        forall |k| #[trigger] self.frag.dom().contains(k) ==>
            0 <= k && k < self.auth.len()
                && self.auth.index(k) === self.frag.index(k)
    }

    #[invariant]
    pub fn distinct(&self) -> bool {
        forall |i: int, j: int|
            0 <= i && i < self.auth.len() &&
            0 <= j && j < self.auth.len() &&
            i != j
            ==>
            self.auth.index(i) !== self.auth.index(j)
    }

    #[inductive(empty)]
    fn empty_inductive(post: Self) { }

    #[inductive(insert)]
    fn insert_inductive(pre: Self, post: Self, val: T) {
        /*assert_forall_by(|k| {
            requires(post.frag.dom().contains(k));
            ensures(0 <= k && k < post.auth.len()
                && equal(post.auth.index(k), post.frag.index(k)));

            assert(pre.frag.dom().contains(k));
            assert(k < pre.auth.len());
            assert(k < post.auth.len());
            assert(equal(post.auth.index(k), post.frag.index(k)));
        })*/
        /*assert_forall_by(|i: int, j: int| {
            requires(
                0 <= i && i < post.auth.len() &&
                0 <= j && j < post.auth.len() &&
                i != j
            );
            ensures(!equal(post.auth.index(i), post.auth.index(j)));

            if i == post.auth.len() as int - 1 {
                if j == post.auth.len() as int - 1 {
                    assert(!equal(post.auth.index(i), post.auth.index(j)));
                } else {
                    assert(!equal(post.auth.index(i), post.auth.index(j)));
                }
            } else {
                if j == post.auth.len() as int - 1 {
                    assert(equal(post.auth.index(pre.auth.len()), val));
                    assert(equal(post.auth.index(j), val));
                    assert(equal(post.auth.index(i), pre.auth.index(i)));
                    assert(!equal(pre.auth.index(i), val));
                    assert(!equal(post.auth.index(i), post.auth.index(j)));
                } else {
                    assert(!equal(post.auth.index(i), post.auth.index(j)));
                }
            }
        })*/
    }

    #[inductive(get_frag)]
    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }
}}

verus! {

// We want the following properties:
//
// There is an `Interner` object. You need access to this object in order to:
//
//  - intern a new string and get an ID for it
//  - look up the original string for a given ID
//
// However, WITHOUT access to the object, you should be able to:
//
// - use `@` to get the original string (in spec-code)
//   so that you could reason about the string as if you just had the original
// - evaluate string equality by comparing the IDs
struct Interner<T> {
    inst: Tracked<InternSystem::Instance<T>>,
    auth: Tracked<InternSystem::auth<T>>,
    store: Vec<T>,
}

struct Interned<T> {
    inst: Tracked<InternSystem::Instance<T>>,
    frag: Tracked<InternSystem::frag<T>>,
    id: usize,
}

#[verifier::external_body]
fn compute_eq<T>(a: &T, b: &T) -> (res: bool)
    ensures
        res <==> (a === b),
{
    unimplemented!();
}

impl<T> Interner<T> {
    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {
        &&& self.inst@ == inst
        &&& self.auth@.instance_id() == inst.id()
        &&& self.auth@.value() === self.store@
    }

    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))
        ensures
            ({
                let s = x.0;
                let inst = x.1@;
                s.wf(inst)
            }),
    {
        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();
        let store = Vec::new();
        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))
    }

    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)
        requires
            old(self).wf(inst),
        ensures
            self.wf(inst) && st.wf(inst) && st@ === val,
    {
        let idx: usize = 0;
        while idx < self.store.len()
            invariant
                0 <= idx && idx <= self.store@.len(),
                self.wf(inst),
        {
            let eq = compute_eq(&val, &self.store[idx]);
            if eq {
                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());
                return Interned {
                    inst: Tracked(self.inst.borrow().clone()),
                    frag: Tracked(frag),
                    id: idx,
                };
            }
        }
        let idx: usize = self.store.len();
        self.store.push(val);
        proof {
            self.inst.borrow().insert(val, self.auth.borrow_mut());
        }
        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());
        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }
    }

    fn get<'a>(
        &'a self,
        interned: &Interned<T>,
        Ghost(inst): Ghost<InternSystem::Instance<T>>,
    ) -> (st: &'a T)
        requires
            self.wf(inst) && interned.wf(inst),
        ensures
            *st === interned@,
    {
        proof {
            self.inst.borrow().get_value(
                interned.id as int,
                self.auth.borrow(),
                interned.frag.borrow(),
            );
        }
        &self.store[interned.id]
    }
}

impl<T> Interned<T> {
    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {
        &&& self.frag@.instance_id() == inst.id()
        &&& inst === self.inst@
        &&& self.id as int == self.frag@.key()
    }

    spec fn view(&self) -> T {
        self.frag@.value()
    }

    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)
        requires
            self.wf(inst),
        ensures
            s.wf(inst) && s@ === self@,
    {
        Interned {
            inst: Tracked(self.inst.borrow().clone()),
            frag: Tracked(self.frag.borrow().clone()),
            id: self.id,
        }
    }

    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)
        requires
            self.wf(inst) && other.wf(inst),
        ensures
            b == (self@ === other@),
    {
        proof {
            self.inst.borrow().compute_equality(
                self.frag@.key(),
                self.frag@.value(),
                other.frag@.key(),
                other.frag@.value(),
                self.frag.borrow(),
                other.frag.borrow(),
            );
        }
        self.id == other.id
    }
}

fn main() {
    let (mut interner, Tracked(inst)) = Interner::<u64>::new();
    let s1 = interner.insert(Ghost(inst), 1);
    let s2 = interner.insert(Ghost(inst), 2);
    let s3 = interner.insert(Ghost(inst), 3);
    let s1_other = interner.insert(Ghost(inst), 1);
    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));
    assert(b1);
    let b2 = s1.cmp_eq(&s2, Ghost(inst));
    assert(!b2);
    let t1 = s1.clone(Ghost(inst));
    let get1 = *interner.get(&t1, Ghost(inst));
    assert(get1 == 1);
    let t2 = s2.clone(Ghost(inst));
    let get2 = *interner.get(&t2, Ghost(inst));
    assert(get1 == 1);
}

} // verus!
"," use vstd::{
 pervasive::*, prelude::*, *};
   use verus_state_machines_macros::tokenized_state_machine;
   tokenized_state_machine! {
 InternSystem<T> {
     fields {           
#[sharding(variable)]
        pub auth: Seq<T>,           
#[sharding(persistent_map)]
        pub frag: Map<int, T>,     }
     init!{         empty() {             init auth = Seq::empty();             init frag = Map::empty();         }     }
     transition!{         insert(val: T) {             require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);             update auth = pre.auth.push(val);         }     }
     transition!{         get_frag(idx: int) {             require(0 <= idx && idx < pre.auth.len());             let val = pre.auth.index(idx);             add frag (union)= [idx => val];         }     }
     property!{         get_value(i: int) {             have frag >= [i => let val];             assert(i < pre.auth.len() && pre.auth.index(i) === val);         }     }
     property!{         compute_equality(idx1: int, val1: T, idx2: int, val2: T) {             have frag >= [idx1 => val1];             have frag >= [idx2 => val2];             assert((idx1 == idx2) <==> (val1 === val2));         }     }
#[invariant]
    pub fn agreement(&self) -> bool {         forall |k|   
#[trigger] self.frag.dom().contains(k) ==>
            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     }
#[invariant]
    pub fn distinct(&self) -> bool {         forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }
#[inductive(empty)]
    fn empty_inductive(post: Self) { }
#[inductive(insert)]
    fn insert_inductive(pre: Self, post: Self, val: T) {     }
#[inductive(get_frag)]
    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }
 }
 }
   verus! {
  struct Interner<T> {
     inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }
  struct Interned<T> {
     inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, }
#[verifier::external_body]
fn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {
     unimplemented!();
 }
  impl<T> Interner<T> {
     spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {         &&& self.inst@ == inst         &&& self.auth@.instance_id() == inst.id()         &&& self.auth@.value() === self.store@     }
     fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))         ensures             ({                 let s = x.0;                 let inst = x.1@;                 s.wf(inst)             }
),     {         let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();         let store = Vec::new();         (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))     }
     fn get<'a>(
        &'a self,         interned: &Interned<T>,         Ghost(inst): Ghost<InternSystem::Instance<T>>,     ) -> (st: &'a T)
        requires
            self.wf(inst) && interned.wf(inst),
    {
        proof {
            self.inst.borrow().get_value(
                interned.id as int,
                self.auth.borrow(),
                interned.frag.borrow(),
            );
        }
        &self.store[interned.id]
    }
}
impl<T> Interned<T> {
    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {
        &&& self.frag@.instance_id() == inst.id()
        &&& inst === self.inst@
        &&& self.id as int == self.frag@.key()
    }
    spec fn view(&self) -> T {
        self.frag@.value()
    }
    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)
    {
        Interned {
            inst: Tracked(self.inst.borrow().clone()),
            frag: Tracked(self.frag.borrow().clone()),
            id: self.id,
        }
    }
    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)
        requires
            self.wf(inst) && other.wf(inst),
    {
        proof {
            self.inst.borrow().compute_equality(
                self.frag@.key(),
                self.frag@.value(),
                other.frag@.key(),
                other.frag@.value(),
                self.frag.borrow(),
                other.frag.borrow(),
            );
        }
        self.id == other.id
    }
}
fn main() {
}
} 
","[""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n"", 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a<b> {\n    fields {\n#[sharding(persistent_map)]\n      pub c : Map<int, b>\n    }\n  }\n}\nverus !{ fn main(); }\n', ""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::{\npervasive::*, prelude::*, *};\n  use verus_state_machines_macros::tokenized_state_machine;\n  tokenized_state_machine! {\nInternSystem<T> {     fields {          \n#[sharding(variable)]\n        pub auth: Seq<T>,          \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }     init!{         empty() {             init auth = Seq::empty();             init frag = Map::empty();         }     }     transition!{         insert(val: T) {             require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);             update auth = pre.auth.push(val);         }     }     transition!{         get_frag(idx: int) {             require(0 <= idx && idx < pre.auth.len());             let val = pre.auth.index(idx);             add frag (union)= [idx => val];         }     }     property!{         get_value(i: int) {             have frag >= [i => let val];             assert(i < pre.auth.len() && pre.auth.index(i) === val);         }     }     property!{         compute_equality(idx1: int, val1: T, idx2: int, val2: T) {             have frag >= [idx1 => val1];             have frag >= [idx2 => val2];             assert((idx1 == idx2) <==> (val1 === val2));         }     }      \n#[invariant]\n    pub fn agreement(&self) -> bool {         forall |k|  \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     }      \n#[invariant]\n    pub fn distinct(&self) -> bool {         forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }      \n#[inductive(empty)]\n    fn empty_inductive(post: Self) { }      \n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {     }      \n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { } }\n}\n  verus! {\n struct Interner<T> {     inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }\n struct Interned<T> {     inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, }\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {     unimplemented!(); }\n impl<T> Interner<T> {     spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {         &&& self.inst@ == inst         &&& self.auth@.instance_id() == inst.id()         &&& self.auth@.value() === self.store@     }     fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))         ensures             ({                 let s = x.0;                 let inst = x.1@;                 s.wf(inst)             }),     {         let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();         let store = Vec::new();         (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))     }     fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)         requires             old(self).wf(inst),         ensures             self.wf(inst) && st.wf(inst) && st@ === val,     {         let idx: usize = 0;         while idx < self.store.len()             invariant                 0 <= idx && idx <= self.store@.len(),                 self.wf(inst),         {             let eq = compute_eq(&val, &self.store[idx]);             if eq {                 let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());                 return Interned {                     inst: Tracked(self.inst.borrow().clone()),                     frag: Tracked(frag),                     id: idx,                 };             }         }         let idx: usize = self.store.len();         self.store.push(val);         proof {             self.inst.borrow().insert(val, self.auth.borrow_mut());         }         let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());         Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }     }     fn get<'a>(\n        &'a self,         interned: &Interned<T>,         Ghost(inst): Ghost<InternSystem::Instance<T>>,     ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\nfn main() {\n}\n} \n"", "" use vstd::{\n pervasive::*, prelude::*, *};\n   use verus_state_machines_macros::tokenized_state_machine;\n   tokenized_state_machine! {\n InternSystem<T> {\n     fields {           \n#[sharding(variable)]\n        pub auth: Seq<T>,           \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }\n     init!{         empty() {             init auth = Seq::empty();             init frag = Map::empty();         }     }\n     transition!{         insert(val: T) {             require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);             update auth = pre.auth.push(val);         }     }\n     transition!{         get_frag(idx: int) {             require(0 <= idx && idx < pre.auth.len());             let val = pre.auth.index(idx);             add frag (union)= [idx => val];         }     }\n     property!{         get_value(i: int) {             have frag >= [i => let val];             assert(i < pre.auth.len() && pre.auth.index(i) === val);         }     }\n     property!{         compute_equality(idx1: int, val1: T, idx2: int, val2: T) {             have frag >= [idx1 => val1];             have frag >= [idx2 => val2];             assert((idx1 == idx2) <==> (val1 === val2));         }     }\n#[invariant]\n    pub fn agreement(&self) -> bool {         forall |k|   \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     }\n#[invariant]\n    pub fn distinct(&self) -> bool {         forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }\n#[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {     }\n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n }\n }\n   verus! {\n  struct Interner<T> {\n     inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }\n  struct Interned<T> {\n     inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, }\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {\n     unimplemented!();\n }\n  impl<T> Interner<T> {\n     spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {         &&& self.inst@ == inst         &&& self.auth@.instance_id() == inst.id()         &&& self.auth@.value() === self.store@     }\n     fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))         ensures             ({                 let s = x.0;                 let inst = x.1@;                 s.wf(inst)             }\n),     {         let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();         let store = Vec::new();         (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))     }\n     fn get<'a>(\n        &'a self,         interned: &Interned<T>,         Ghost(inst): Ghost<InternSystem::Instance<T>>,     ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\nfn main() {\n}\n} \n"", ' use vstd::{\n      pervasive::*, prelude::*, *};\n        use verus_state_machines_macros::tokenized_state_machine;\n        tokenized_state_machine! {\n      InternSystem<T> {\n          fields {\n#[sharding(variable)]\n        pub auth: Seq<T>,                \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }\n          init!{\n             empty() {\n                init auth = Seq::empty();\n                init frag = Map::empty();\n            }\n         }\n          transition!{\n             insert(val: T) {}\n         }\n          transition!{\n             get_frag(idx: int) {}\n         }\n          property!{\n             get_value(i: int) {\n                have frag >= [i => let val];\n                assert(i < pre.auth.len() && pre.auth.index(i) === val);\n            }\n         }\n          property!{\n             compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n                have frag >= [idx1 => val1];\n                have frag >= [idx2 => val2];\n            }\n         }\n#[invariant]\n    pub fn agreement(&self) -> bool {\n             forall |k|        \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     }\n#[invariant]\n    pub fn distinct(&self) -> bool {\n             forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }\n#[inductive(empty)]\n    fn empty_inductive(post: Self) {}\n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {}\n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) {}\n      }\n      }\n        verus! {\n       struct Interner<T> {\n          inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }\n       struct Interned<T> {\n          inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, }\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res <==> (a === b), {\n          unimplemented!();\n      }\n       impl<T> Interner<T> {}\nimpl<T> Interned<T> {}\nfn main() ;\n} \n', ' use vstd::{       pervasive::*, prelude::*, *};\n         use verus_state_machines_macros::tokenized_state_machine;\n         tokenized_state_machine! {       InternSystem<T> {           fields { \n#[sharding(variable)]\n        pub auth: Seq<T>,                 \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }           init!{              empty() {                 init auth = Seq::empty();                 init frag = Map::empty();             }          }           transition!{              insert(val: T) {}          }           transition!{              get_frag(idx: int) {}          }           property!{              get_value(i: int) {                 have frag >= [i => let val];                 assert(i < pre.auth.len() && pre.auth.index(i) === val);             }          }           property!{              compute_equality(idx1: int, val1: T, idx2: int, val2: T) {                 have frag >= [idx1 => val1];                 have frag >= [idx2 => val2];             }          } \n#[invariant]\n    pub fn agreement(&self) -> bool {              forall |k|         \n#[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()                 && self.auth.index(k) === self.frag.index(k)     } \n#[invariant]\n    pub fn distinct(&self) -> bool {              forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     } \n#[inductive(empty)]\n    fn empty_inductive(post: Self) {} \n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {} \n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) {}       }       }\n         verus! {        struct Interner<T> {           inst: Tracked<InternSystem::Instance<T>>,     auth: Tracked<InternSystem::auth<T>>,     store: Vec<T>, }        struct Interned<T> {           inst: Tracked<InternSystem::Instance<T>>,     frag: Tracked<InternSystem::frag<T>>,     id: usize, } \n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)     ensures         res == (a === b), {           unimplemented!();       }        impl<T> Interner<T> {} impl<T> Interned<T> {} fn main() ; }\n', ' use vstd::{\n          pervasive::*, prelude::*, *};\n             use verus_state_machines_macros::tokenized_state_machine;\n             tokenized_state_machine! {\n          InternSystem<T> {\n             fields {\n#[sharding(variable)]\n        pub auth: Seq<T>,                     \n#[sharding(persistent_map)]\n        pub frag: Map<int, T>,     }\n             init!{\n               empty() {\n                 init auth = Seq::empty();\n                 init frag = Map::empty();\n             }\n           }\n             transition!{\n               insert(val: T) {\n}\n           }\n             transition!{\n               get_frag(idx: int) {\n}\n           }\n#[invariant]\n    pub fn agreement(&self) -> bool {\n               forall |i: int, j: int|             0 <= i && i < self.auth.len() &&             0 <= j && j < self.auth.len() &&             i != j             ==>             self.auth.index(i) !== self.auth.index(j)     }\n#[inductive(empty)]\n    fn empty_inductive(post: Self) {\n }\n#[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n }\n#[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) {\n }\n         }\n          }\n             verus! {\n    fn main() ;\n    }\n', ' use vstd::\n              prelude::* ;\n                use verus_state_machines_macros::tokenized_state_machine;\n                tokenized_state_machine! {\n             a<b> {\n                fields {\n#[sharding(variable)]\n        pub auth: Seq<b>,                        \n#[sharding(persistent_map)]\n        pub c: Map<int, b>}\n                init!{\n                  empty() {\n                    init auth = Seq::empty();\n                    init c = Map::empty();\n                }\n              }\n                transition!{\n                  d(e: b) {}\n              }\n                transition!{\n                  get_frag(f: int) {}\n              }\n#[invariant]\n    pub fn agreement(self) -> bool {\n                  forall |g , h |             0   < self.auth.len() ==>             self.auth.index(g) !=self.auth.index(h)     }\n#[inductive(empty)]\n    fn i(post: Self) {}\n#[inductive(d)]\n    fn insert_inductive(pre: Self, post: Self, e: b) {}\n#[inductive(get_frag)]\n    fn j(pre: Self, post: Self, f: int) {}\n            }\n             }\n                verus! {\n       fn main() ;\n       }\n', ' use vstd::               prelude::* ;\n                    use verus_state_machines_macros::tokenized_state_machine;\n                    tokenized_state_machine! {\n                a<b> {\n                  fields {\n#[sharding(variable)]\n        pub auth: Seq<b>,                            \n#[sharding(persistent_map)]\n        pub c: Map<int, b>}\n              }\n                }\n                    verus! {\n          fn main() ;\n          }\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a< b > {\n    fields {\n#[sharding(variable)]\n      pub auth : Seq< b >,\n#[sharding(persistent_map)]\n                 pub c : Map< int, b >\n    }\n  }\n}\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !{\n  a< b > {\n    fields {\n#[sharding(persistent_map)]\n                 pub c : Map< int, b >\n    }\n  }\n}\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\n use verus_state_machines_macros::tokenized_state_machine;\n tokenized_state_machine !{   a< b > {     fields { \n#[sharding(persistent_map)]\n      pub c : Map< int, b >     }   } }\n verus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/leader_election_complete.rs,182,79,0.4340659340659341,308.913,True,0.7999999999999999,False,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::seq::', 'vstd::', 'verus_state_machines_macros::state_machine']",True,,,,,,"#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::seq::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::state_machine;

verus! {

pub open spec fn ids_distinct(ids: Seq<int>) -> bool {
    forall|i: int, j: int|
        i != j && 0 <= i && i < ids.len() && 0 <= j && j < ids.len() ==> ids.index(i) != ids.index(
            j,
        )
}

pub open spec fn between(start: int, node: int, end: int) -> bool {
    if start < end {
        start < node && node < end
    } else {
        node < end || start < node
    }
}

pub open spec fn max(a: int, b: int) -> int {
    if a > b {
        a
    } else {
        b
    }
}

} // verus!
state_machine!(
    X {
        fields {
            pub ids: Seq<int>, // constant
            pub highest_heard: Seq<int>,
        }

        init!{
            ini(ids: Seq<int>) {
                require(ids_distinct(ids));
                require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);
                init ids = ids;
                init highest_heard = Seq::new(ids.len(), |i: int| -1);
            }
        }

        transition!{
            transmission(srcidx: int) {
                require(0 <= srcidx && srcidx < pre.ids.len());

                let dstidx = if srcidx + 1 == pre.ids.len() { 0 } else { srcidx + 1 };
                let message = max(pre.highest_heard.index(srcidx), pre  .ids.index(srcidx));
                let dst_new_max = max(pre.highest_heard.index(dstidx), message);

                update highest_heard = pre.highest_heard.update(dstidx, dst_new_max);
            }
        }

        #[invariant]
        pub fn inv_lengths_match(self) -> bool {
            self.ids.len() == self.highest_heard.len()
        }

        #[invariant]
        pub fn inv_ids_distinct(self) -> bool {
            ids_distinct(self.ids)
        }

        pub open spec fn is_leader(self, i: int) -> bool {
            0 <= i && i < self.ids.len() &&
                self.highest_heard.index(i) == self.ids.index(i)
        }

        #[invariant]
        pub fn safety_condition(self) -> bool {
            forall |i: int, j: int|
                self.is_leader(i) && self.is_leader(j) ==> i == j
        }

        pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {
            forall |node: int| between(start, node, end) && self.valid_idx(node)
                ==> self.highest_heard.index(node) > self.ids.index(node)
        }

        pub open spec fn valid_idx(self, i: int) -> bool {
            0 <= i && i < self.ids.len()
        }

        pub open spec fn is_chord(self, start: int, end: int) -> bool {
               self.valid_idx(start)
            && self.valid_idx(end)
            && self.ids.index(start) == self.highest_heard.index(end)
        }

        #[invariant]
        pub fn on_chord_heard_dominates_id_inv(self) -> bool {
            forall |start: int, end: int|
                self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)
        }

        #[inductive(transmission)]
        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {
            // XXX(travis): this sort of copy-paste is extremely common, we could have
            // a language feature to let us skip it
            let dstidx = if srcidx + 1 == pre.ids.len() { 0 } else { srcidx + 1 };
            let message = max(pre.highest_heard.index(srcidx), pre.ids.index(srcidx));
            let dst_new_max = max(pre.highest_heard.index(dstidx), message);

            assert_by(post.on_chord_heard_dominates_id_inv(), {
              assert forall |start: int, end: int| post.is_chord(start, end)
                implies post.OnChordHeardDominatesId(start, end)
              by {
                assert forall |node: int|
                  between(start, node, end) && post.valid_idx(node)
                  implies post.highest_heard.index(node) > post.ids.index(node)
                by {
                  if dstidx == end {
                    // maybe this chord just sprung into existence
                    if post.highest_heard.index(end) == pre.highest_heard.index(end) {
                      // no change --
                      assert(pre.highest_heard =~= post.highest_heard);
                      assert(equal(pre.highest_heard, post.highest_heard));
                      assert(equal(pre, post));
                      assert(post.highest_heard.index(node) > post.ids.index(node));
                    } else if post.highest_heard.index(end) == pre.ids.index(srcidx) {
                      assert(false); // proof by contradiction
                      assert(post.highest_heard.index(node) > post.ids.index(node));
                    } else if post.highest_heard.index(end) == pre.highest_heard.index(srcidx) {
                      assert(pre.is_chord(start, srcidx));  // trigger
                      assert(pre.valid_idx(node));
                      assert(post.highest_heard.index(node) > post.ids.index(node));
                    }
                  } else {
                    // this chord was already here
                    assert(pre.is_chord(start, end)); // trigger
                    assert(pre.valid_idx(node)); // trigger
                    assert(post.highest_heard.index(node) > post.ids.index(node));
                  }
                }
              }
            });

            assert_by(post.safety_condition(), {
                assert forall |i: int, j: int|
                    post.is_leader(i) && post.is_leader(j) implies i == j
                by {

                    if i != j {
                        if pre.is_leader(i) {
                            assert(pre.is_chord(i, i));
                            //assert(pre.OnChordHeardDominatesId(i, i));
                            //assert(between(i, j, i));
                            assert(pre.valid_idx(j));
                            //assert(pre.highest_heard.index(j) > pre.ids.index(j));
                            assert(!post.is_leader(j));
                            assert(false);
                        }

                        if pre.is_leader(j) {
                            assert(pre.is_chord(j, j));
                            assert(pre.valid_idx(i));
                            assert(!post.is_leader(i));
                            assert(false);
                        }
                    }
                }
            });
        }

        #[inductive(ini)]
        pub fn ind_on_ini(post: Self, ids: Seq<int>) {
            assert(post.on_chord_heard_dominates_id_inv());
        }
    }
);

fn main() {}
","use verus_builtin::*;
     use verus_builtin_macros::*;
     use vstd::seq::*;
     use verus_state_machines_macros::state_machine;
     verus! {
    pub open spec fn ids_distinct(ids: Seq<int>) -> bool {
       forall|i: int, j: int|         i != j && 0 <= i && i < ids.len() && 0 <= j && j < ids.len() ==> ids.index(i) != ids.index(             j,         ) }
    pub open spec fn between(start: int, node: int, end: int) -> bool {
       if start < end {
          start < node && node < end     }
   else {
          node < end || start < node     }
   }
    pub open spec fn max(a: int, b: int) -> int {
       if a > b {
          a     }
   else {
          b     }
   }
    }
      state_machine!(     X {
            fields {
               pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }
            init!{
               ini(ids: Seq<int>) {
                  require(ids_distinct(ids));
                  require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);
                  init ids = ids;
                  init highest_heard = Seq::new(ids.len(), |i: int| -1);
              }
           }
            transition!{
               transmission(srcidx: int) {
                  let dstidx = if srcidx + 1 == pre.ids.len() {
 0 }
  else {
 srcidx + 1 };
              }
           }
#[invariant]
        pub fn inv_lengths_match(self) -> bool {
               self.ids.len() == self.highest_heard.len()         }
#[invariant]
        pub fn inv_ids_distinct(self) -> bool {
               ids_distinct(self.ids)         }
            pub open spec fn is_leader(self, i: int) -> bool {
               0 <= i && i < self.ids.len() &&                 self.highest_heard.index(i) == self.ids.index(i)         }
#[invariant]
        pub fn safety_condition(self) -> bool {
               forall |i: int, j: int|                 self.is_leader(i) && self.is_leader(j) ==> i == j         }
            pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {
               forall |node: int| between(start, node, end) && self.valid_idx(node)                 ==> self.highest_heard.index(node) > self.ids.index(node)         }
            pub open spec fn valid_idx(self, i: int) -> bool {
               0 <= i && i < self.ids.len()         }
            pub open spec fn is_chord(self, start: int, end: int) -> bool {
                  self.valid_idx(start)             && self.valid_idx(end)             && self.ids.index(start) == self.highest_heard.index(end)         }
#[invariant]
        pub fn on_chord_heard_dominates_id_inv(self) -> bool {
               forall |start: int, end: int|                 self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)         }
#[inductive(transmission)]
        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {
               let dstidx = if srcidx + 1 == pre.ids.len() {
  0 }
   else {
  srcidx + 1 };
               assert_by(post.on_chord_heard_dominates_id_inv(), {
              }
  );
               assert_by(post.safety_condition(), {
              }
  );
           }
#[inductive(ini)]
        pub fn ind_on_ini(post: Self, ids: Seq<int>) {
           }
        }
     );
     fn main() {
   }
","['#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::state_machine;\n\nverus! {\n\npub open spec fn ids_distinct(ids: Seq<int>) -> bool {\n    forall|i: int, j: int|\n        i != j && 0 <= i && i < ids.len() && 0 <= j && j < ids.len() ==> ids.index(i) != ids.index(\n            j,\n        )\n}\n\npub open spec fn between(start: int, node: int, end: int) -> bool {\n    if start < end {\n        start < node && node < end\n    } else {\n        node < end || start < node\n    }\n}\n\npub open spec fn max(a: int, b: int) -> int {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n\n} // verus!\nstate_machine!(\n    X {\n        fields {\n            pub ids: Seq<int>, // constant\n            pub highest_heard: Seq<int>,\n        }\n\n        init!{\n            ini(ids: Seq<int>) {\n                require(ids_distinct(ids));\n                require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                init ids = ids;\n                init highest_heard = Seq::new(ids.len(), |i: int| -1);\n            }\n        }\n\n        transition!{\n            transmission(srcidx: int) {\n                require(0 <= srcidx && srcidx < pre.ids.len());\n\n                let dstidx = if srcidx + 1 == pre.ids.len() { 0 } else { srcidx + 1 };\n                let message = max(pre.highest_heard.index(srcidx), pre  .ids.index(srcidx));\n                let dst_new_max = max(pre.highest_heard.index(dstidx), message);\n\n                update highest_heard = pre.highest_heard.update(dstidx, dst_new_max);\n            }\n        }\n\n        #[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n            self.ids.len() == self.highest_heard.len()\n        }\n\n        #[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n            ids_distinct(self.ids)\n        }\n\n        pub open spec fn is_leader(self, i: int) -> bool {\n            0 <= i && i < self.ids.len() &&\n                self.highest_heard.index(i) == self.ids.index(i)\n        }\n\n        #[invariant]\n        pub fn safety_condition(self) -> bool {\n            forall |i: int, j: int|\n                self.is_leader(i) && self.is_leader(j) ==> i == j\n        }\n\n        pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {\n            forall |node: int| between(start, node, end) && self.valid_idx(node)\n                ==> self.highest_heard.index(node) > self.ids.index(node)\n        }\n\n        pub open spec fn valid_idx(self, i: int) -> bool {\n            0 <= i && i < self.ids.len()\n        }\n\n        pub open spec fn is_chord(self, start: int, end: int) -> bool {\n               self.valid_idx(start)\n            && self.valid_idx(end)\n            && self.ids.index(start) == self.highest_heard.index(end)\n        }\n\n        #[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n            forall |start: int, end: int|\n                self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)\n        }\n\n        #[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n            // XXX(travis): this sort of copy-paste is extremely common, we could have\n            // a language feature to let us skip it\n            let dstidx = if srcidx + 1 == pre.ids.len() { 0 } else { srcidx + 1 };\n            let message = max(pre.highest_heard.index(srcidx), pre.ids.index(srcidx));\n            let dst_new_max = max(pre.highest_heard.index(dstidx), message);\n\n            assert_by(post.on_chord_heard_dominates_id_inv(), {\n              assert forall |start: int, end: int| post.is_chord(start, end)\n                implies post.OnChordHeardDominatesId(start, end)\n              by {\n                assert forall |node: int|\n                  between(start, node, end) && post.valid_idx(node)\n                  implies post.highest_heard.index(node) > post.ids.index(node)\n                by {\n                  if dstidx == end {\n                    // maybe this chord just sprung into existence\n                    if post.highest_heard.index(end) == pre.highest_heard.index(end) {\n                      // no change --\n                      assert(pre.highest_heard =~= post.highest_heard);\n                      assert(equal(pre.highest_heard, post.highest_heard));\n                      assert(equal(pre, post));\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    } else if post.highest_heard.index(end) == pre.ids.index(srcidx) {\n                      assert(false); // proof by contradiction\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    } else if post.highest_heard.index(end) == pre.highest_heard.index(srcidx) {\n                      assert(pre.is_chord(start, srcidx));  // trigger\n                      assert(pre.valid_idx(node));\n                      assert(post.highest_heard.index(node) > post.ids.index(node));\n                    }\n                  } else {\n                    // this chord was already here\n                    assert(pre.is_chord(start, end)); // trigger\n                    assert(pre.valid_idx(node)); // trigger\n                    assert(post.highest_heard.index(node) > post.ids.index(node));\n                  }\n                }\n              }\n            });\n\n            assert_by(post.safety_condition(), {\n                assert forall |i: int, j: int|\n                    post.is_leader(i) && post.is_leader(j) implies i == j\n                by {\n\n                    if i != j {\n                        if pre.is_leader(i) {\n                            assert(pre.is_chord(i, i));\n                            //assert(pre.OnChordHeardDominatesId(i, i));\n                            //assert(between(i, j, i));\n                            assert(pre.valid_idx(j));\n                            //assert(pre.highest_heard.index(j) > pre.ids.index(j));\n                            assert(!post.is_leader(j));\n                            assert(false);\n                        }\n\n                        if pre.is_leader(j) {\n                            assert(pre.is_chord(j, j));\n                            assert(pre.valid_idx(i));\n                            assert(!post.is_leader(i));\n                            assert(false);\n                        }\n                    }\n                }\n            });\n        }\n\n        #[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n            assert(post.on_chord_heard_dominates_id_inv());\n        }\n    }\n);\n\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n     use verus_builtin_macros::*;\n     use vstd::seq::*;\n     use verus_state_machines_macros::state_machine;\n     verus! {\n    pub open spec fn ids_distinct(ids: Seq<int>) -> bool {\n       forall|i: int, j: int|         i != j && 0 <= i && i < ids.len() && 0 <= j && j < ids.len() ==> ids.index(i) != ids.index(             j,         ) }\n    pub open spec fn between(start: int, node: int, end: int) -> bool {\n       if start < end {\n          start < node && node < end     }\n   else {\n          node < end || start < node     }\n   }\n    pub open spec fn max(a: int, b: int) -> int {\n       if a > b {\n          a     }\n   else {\n          b     }\n   }\n    }\n      state_machine!(     X {\n            fields {\n               pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n            init!{\n               ini(ids: Seq<int>) {\n                  require(ids_distinct(ids));\n                  require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                  init ids = ids;\n                  init highest_heard = Seq::new(ids.len(), |i: int| -1);\n              }\n           }\n            transition!{\n               transmission(srcidx: int) {\n                  let dstidx = if srcidx + 1 == pre.ids.len() {\n 0 }\n  else {\n srcidx + 1 };\n              }\n           }\n#[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n               self.ids.len() == self.highest_heard.len()         }\n#[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n               ids_distinct(self.ids)         }\n            pub open spec fn is_leader(self, i: int) -> bool {\n               0 <= i && i < self.ids.len() &&                 self.highest_heard.index(i) == self.ids.index(i)         }\n#[invariant]\n        pub fn safety_condition(self) -> bool {\n               forall |i: int, j: int|                 self.is_leader(i) && self.is_leader(j) ==> i == j         }\n            pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool {\n               forall |node: int| between(start, node, end) && self.valid_idx(node)                 ==> self.highest_heard.index(node) > self.ids.index(node)         }\n            pub open spec fn valid_idx(self, i: int) -> bool {\n               0 <= i && i < self.ids.len()         }\n            pub open spec fn is_chord(self, start: int, end: int) -> bool {\n                  self.valid_idx(start)             && self.valid_idx(end)             && self.ids.index(start) == self.highest_heard.index(end)         }\n#[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n               forall |start: int, end: int|                 self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)         }\n#[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n               let dstidx = if srcidx + 1 == pre.ids.len() {\n  0 }\n   else {\n  srcidx + 1 };\n               assert_by(post.on_chord_heard_dominates_id_inv(), {\n              }\n  );\n               assert_by(post.safety_condition(), {\n              }\n  );\n           }\n#[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n           }\n        }\n     );\n     fn main() {\n   }\n', 'use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::seq::*;\n        use verus_state_machines_macros::state_machine;\n        verus! {\n       pub open spec fn ids_distinct(ids: Seq<int>) -> bool ;\n       pub open spec fn between(start: int, node: int, end: int) -> bool ;\n       pub open spec fn max(a: int, b: int) -> int ;\n       }\n         state_machine!(     X {\n               fields {\n                  pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n               init!{\n                  ini(ids: Seq<int>) {\n                     require(ids_distinct(ids));\n                     require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                     init ids = ids;\n                     init highest_heard = Seq::new(ids.len(), |i: int| -1);\n                 }\n              }\n               transition!{\n                  transmission(srcidx: int) {\n                     let dstidx = if srcidx + 1 == pre.ids.len0 {\n    0 }\n     else {\n    srcidx + 1 };\n                 }\n              }\n#[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n                  self.ids.len() == self.highest_heard.len()         }\n#[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n                  ids_distinct(self.ids)         }\n               pub open spec fn is_leader(self, i: int) -> bool {\n                  0 <= i && i < self.ids.len() &&                 self.highest_heard.index(i) == self.ids.index(i)         }\n#[invariant]\n        pub fn safety_condition(self) -> bool {\n                  forall |i: int, j: int|                 self.is_leader(i) && self.is_leader(j) ==> i == j         }\n               pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool ;\n               pub open spec fn valid_idx(self, i: int) -> bool {\n                  0 <= i && i < self.ids.len()         }\n               pub open spec fn is_chord(self, start: int, end: int) -> bool {\n                     self.valid_idx(start)             && self.valid_idx(end)             && self.ids.index(start) == self.highest_heard.index(end)         }\n#[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n                  forall |start: int, end: int|                 self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)         }\n#[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {\n                  let dstidx = if srcidx + 1 == pre.ids.len() {\n     0 }\n      else {\n     srcidx + 1 };\n                  assert_by(post.on_chord_heard_dominates_id_inv(), {\n                 }\n     );\n                  assert_by(post.safety_condition(), {\n                 }\n     );\n              }\n#[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {\n              }\n           }\n        );\n        fn main() {\n      }\n', 'use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::seq::*;\n        use verus_state_machines_macros::state_machine;\n        verus! {\n       pub open spec fn ids_distinct(ids: Seq<int>) -> bool ;\n       pub open spec fn between() -> bool ;\n       pub open spec fn max() -> int ;\n       }\n         state_machine!(     X {\n               fields {\n                  pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n               init!{\n                  ini(ids: Seq<int>) {\n                     require(ids_distinct(ids));\n                     require(forall |k| 0 <= k < ids.len() ==> ids[k] >= 0);\n                     init ids = ids;\n                     init highest_heard = Seq::new(ids.len(), |i: int| -1);\n                 }\n              }\n               transition!{\n                  transmission(srcidx: int) {}\n              }\n#[invariant]\n        pub fn inv_lengths_match(self) -> bool {\n                  self.ids.len() == self.highest_heard.len()         }\n#[invariant]\n        pub fn inv_ids_distinct(self) -> bool {\n                  ids_distinct(self.ids)         }\n               pub open spec fn is_leader(self, i: int) -> bool {\n                  0 <= i && i < self.ids.len() &&                 self.highest_heard.index(i) == self.ids.index(i)         }\n#[invariant]\n        pub fn safety_condition(self) -> bool {\n                  forall |i: int, j: int|                 self.is_leader(i) && self.is_leader(j) ==> i == j         }\n               pub open spec fn OnChordHeardDominatesId(self, start: int, end: int) -> bool ;\n               pub open spec fn valid_idx(self, i: int) -> bool {\n                  0 <= i && i < self.ids.len()         }\n               pub open spec fn is_chord(self, start: int, end: int) -> bool {\n                     self.valid_idx(start)             && self.valid_idx(end)             && self.ids.index(start) == self.highest_heard.index(end)         }\n#[invariant]\n        pub fn on_chord_heard_dominates_id_inv(self) -> bool {\n                  forall |start: int, end: int|                 self.is_chord(start, end) ==> self.OnChordHeardDominatesId(start, end)         }\n#[inductive(transmission)]\n        pub fn preserves_ind(pre: Self, post: Self, srcidx: int) {}\n#[inductive(ini)]\n        pub fn ind_on_ini(post: Self, ids: Seq<int>) {}\n           }\n        );\n        fn main() {}\n', 'use verus_builtin::*;\n               use verus_builtin_macros::*;\n               use vstd::seq::*;\n               use verus_state_machines_macros::state_machine;\n               verus! {\n             }\n                state_machine!(     X {\n                     fields {\n                       pub ids: Seq<int>,              pub highest_heard: Seq<int>,         }\n                 }\n               );\n               fn main() {\n     }\n', 'use verus_builtin::*;\nuse vstd::seq::*;\nuse verus_state_machines_macros::state_machine;\nstate_machine !(X{fields{\n  pub ids : Seq< int >,\n  pub highest_heard : Seq< int >}});\nfn main() {}\n', 'use verus_builtin;\nuse verus_state_machines_macros;\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/maps.rs,136,47,0.34558823529411764,643.519,True,0.7999999999999999,False,"['verus_builtin::', 'vstd::map::', 'vstd::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,,,,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use vstd::map::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::tokenized_state_machine;

tokenized_state_machine!(
    X {
        fields {
            #[sharding(map)]
            pub bool_map: Map<int, bool>,

        }

        init!{
            initialize(cond: bool) {
                init bool_map = Map::empty().insert(5, true);
            }
        }

        transition!{
            add(n: int) {
                remove bool_map -= [n => true];
                add bool_map += [n => true];
            }
        }

        transition!{
            add_have(n: int) {
                remove bool_map -= [n => false];
                have bool_map >= [19 => false];
                add bool_map += [n => true];
            }
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, cond: bool) { }

        #[inductive(add)]
        fn add_inductive(pre: Self, post: Self, n: int) { }

        #[inductive(add_have)]
        fn add_have_inductive(pre: Self, post: Self, n: int) { }
    }
);

tokenized_state_machine!(
    Fancy {
        fields {
            #[sharding(variable)]
            pub m: int,

            #[sharding(map)]
            pub map: Map<int, bool>,

            #[sharding(storage_map)]
            pub storage_map: Map<int, bool>,
        }

        #[invariant]
        pub fn inv1(self) -> bool {
            forall |i: int|
              self.storage_map.dom().contains(i) ==> (0 <= i && i < self.m)
        }

        #[invariant]
        pub fn inv2(self) -> bool {
            forall |i: int|
              (0 <= i && i < self.m) ==> self.storage_map.dom().contains(i)
        }

        #[invariant]
        pub fn inv3(self) -> bool {
            self.m >= 0 &&
            equal(self.storage_map, self.map)
        }

        init!{
            initialize(cond: bool) {
                init m = 0;
                init storage_map = Map::empty();
                init map = Map::empty();
            }
        }

        transition!{
            do_deposit(b: bool) {
                update m = pre.m + 1;
                add map += [pre.m => b];
                deposit storage_map += [pre.m => b];
            }
        }

        transition! {
            do_withdraw(b: bool) {
                require(pre.m >= 1);
                update m = pre.m - 1;
                remove map -= [pre.m => b];
                withdraw storage_map -= [pre.m => b];
            }
        }

        property! {
            do_guard(i: int, b: bool) {
                have map >= [i => b];
                guard storage_map >= [i => b];
            }
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, cond: bool) { }

        #[inductive(do_deposit)]
        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {
            /*
            assert_forall_by(|i: int| {
              requires(post.storage_map.dom().contains(i));
              ensures(0 <= i && i < post.m);
              if pre.storage_map.dom().contains(i) {
                  assert(0 <= i && i < post.m);
              } else {
                  assert(i == pre.m);
                  assert(0 <= i && i < post.m);
              }
            });
            */
        }

        #[inductive(do_withdraw)]
        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) { }
    }
);

fn main() {}
","use verus_builtin::*;
        use vstd::map::*;
        use verus_state_machines_macros::tokenized_state_machine;
        tokenized_state_machine!(     X {
               fields {}
           }
        );
        tokenized_state_machine!(     Fancy {
               fields {
#[sharding(variable)]
            pub m: int,                    
#[sharding(map)]
            pub map: Map<int, bool>,                    
#[sharding(storage_map)]
            pub storage_map: Map<int, bool>,         }
#[invariant]
        pub fn inv1(self) -> bool {
                  forall |i: int|               self.storage_map.dom().contains(i) ==> (0 <= i && i < self.m)         }
#[invariant]
        pub fn inv3(self) -> bool {
                  self.m >= 0 &&             equal(self.storage_map, self.map)         }
               init!{
                  initialize(cond: bool) {
                     init m = 0;
                     init storage_map = Map::empty();
                     init map = Map::empty();
                 }
              }
               transition!{
                  do_deposit(b: bool) {}
              }
               transition! {
                  do_withdraw(b: bool) {}
              }
#[inductive(initialize)]
        fn initialize_inductive(post: Self, cond: bool) {
      }
#[inductive(do_deposit)]
        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {
              }
#[inductive(do_withdraw)]
        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) {
      }
           }
        );
        fn main() {
      }
","['// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::map::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(map)]\n            pub bool_map: Map<int, bool>,\n\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init bool_map = Map::empty().insert(5, true);\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                remove bool_map -= [n => true];\n                add bool_map += [n => true];\n            }\n        }\n\n        transition!{\n            add_have(n: int) {\n                remove bool_map -= [n => false];\n                have bool_map >= [19 => false];\n                add bool_map += [n => true];\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n\n        #[inductive(add_have)]\n        fn add_have_inductive(pre: Self, post: Self, n: int) { }\n    }\n);\n\ntokenized_state_machine!(\n    Fancy {\n        fields {\n            #[sharding(variable)]\n            pub m: int,\n\n            #[sharding(map)]\n            pub map: Map<int, bool>,\n\n            #[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,\n        }\n\n        #[invariant]\n        pub fn inv1(self) -> bool {\n            forall |i: int|\n              self.storage_map.dom().contains(i) ==> (0 <= i && i < self.m)\n        }\n\n        #[invariant]\n        pub fn inv2(self) -> bool {\n            forall |i: int|\n              (0 <= i && i < self.m) ==> self.storage_map.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn inv3(self) -> bool {\n            self.m >= 0 &&\n            equal(self.storage_map, self.map)\n        }\n\n        init!{\n            initialize(cond: bool) {\n                init m = 0;\n                init storage_map = Map::empty();\n                init map = Map::empty();\n            }\n        }\n\n        transition!{\n            do_deposit(b: bool) {\n                update m = pre.m + 1;\n                add map += [pre.m => b];\n                deposit storage_map += [pre.m => b];\n            }\n        }\n\n        transition! {\n            do_withdraw(b: bool) {\n                require(pre.m >= 1);\n                update m = pre.m - 1;\n                remove map -= [pre.m => b];\n                withdraw storage_map -= [pre.m => b];\n            }\n        }\n\n        property! {\n            do_guard(i: int, b: bool) {\n                have map >= [i => b];\n                guard storage_map >= [i => b];\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) { }\n\n        #[inductive(do_deposit)]\n        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {\n            /*\n            assert_forall_by(|i: int| {\n              requires(post.storage_map.dom().contains(i));\n              ensures(0 <= i && i < post.m);\n              if pre.storage_map.dom().contains(i) {\n                  assert(0 <= i && i < post.m);\n              } else {\n                  assert(i == pre.m);\n                  assert(0 <= i && i < post.m);\n              }\n            });\n            */\n        }\n\n        #[inductive(do_withdraw)]\n        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) { }\n    }\n);\n\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n        use vstd::map::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n        tokenized_state_machine!(     X {\n               fields {}\n           }\n        );\n        tokenized_state_machine!(     Fancy {\n               fields {\n#[sharding(variable)]\n            pub m: int,                    \n#[sharding(map)]\n            pub map: Map<int, bool>,                    \n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,         }\n#[invariant]\n        pub fn inv1(self) -> bool {\n                  forall |i: int|               self.storage_map.dom().contains(i) ==> (0 <= i && i < self.m)         }\n#[invariant]\n        pub fn inv3(self) -> bool {\n                  self.m >= 0 &&             equal(self.storage_map, self.map)         }\n               init!{\n                  initialize(cond: bool) {\n                     init m = 0;\n                     init storage_map = Map::empty();\n                     init map = Map::empty();\n                 }\n              }\n               transition!{\n                  do_deposit(b: bool) {}\n              }\n               transition! {\n                  do_withdraw(b: bool) {}\n              }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) {\n      }\n#[inductive(do_deposit)]\n        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {\n              }\n#[inductive(do_withdraw)]\n        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) {\n      }\n           }\n        );\n        fn main() {\n      }\n', 'use verus_builtin::*;\n          use vstd::map::*;\n          use verus_state_machines_macros::tokenized_state_machine;\n          tokenized_state_machine!(     X {\n                fields {  \n#[sharding(variable)]\n            pub m: int,                      \n#[sharding(map)]\n            pub map: Map<int, bool>,                      \n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,         }\n#[invariant]\n        pub fn inv3(self) -> bool {                   self.m >= 0 &&             equal(self.storage_map, self.map)         }\n                init!{                   initialize(cond: bool) {                      init m = 0;                      init storage_map = Map::empty();                      init map = Map::empty();                  }               }\n                transition!{                   do_deposit(b: bool) {}               }\n                transition! {                   do_withdraw(b: bool) {}               }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, cond: bool) {}\n#[inductive(do_deposit)]\n        fn do_deposit_inductive(pre: Self, post: Self, b: bool) {}\n#[inductive(do_withdraw)]\n        fn do_withdraw_inductive(pre: Self, post: Self, b: bool) {}\n            }\n          );\n          fn main() {\n}\n', 'use verus_builtin::*;\n               use vstd::map::*;\n               use verus_state_machines_macros::tokenized_state_machine;\n               tokenized_state_machine!(     X {\n                     fields {\n#[sharding(variable)]\n            pub m: int,                           \n#[sharding(map)]\n            pub map: Map<int, bool>,                           \n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>,         }\n                     init!{\n                       initialize(cond: bool) {\n                         init m = 0;\n                         init storage_map = Map::empty();\n                         init map = Map::empty();\n   }\n                   }\n                 }\n               );\n               fn main() {\n     }\n', 'use verus_builtin::*;\nuse vstd::map::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n                tokenized_state_machine!(     X {\n                      fields {\n#[sharding(variable)]\n            pub m: int,\n#[sharding(map)]\n            pub map: Map<int, bool>,\n#[sharding(storage_map)]\n            pub storage_map: Map<int, bool>}\n                      init!{\n                        initialize() {\n                          init m = 0;\n                          init storage_map = Map::empty();\n                          init map = Map::empty();\n                }\n                }\n                }\n                );\n                fn main() {}\n', 'use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(a{fields{\n#[sharding(variable)]\n  pub b : int,\n#[sharding(map)]\n  pub map : Map< int, bool >,\n#[sharding(storage_map)]\n  pub storage_map : Map< int, bool >\n}});\nfn main() {}\n', 'use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(a{fields{\n#[sharding(map)]\n  pub map : Map< int, bool >,\n#[sharding(storage_map)]\n  pub storage_map : Map< int, bool >\n}});\nfn main() {}\n', 'use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(a{fields{\n#[sharding(map)]\n  pub map : Map< int, bool >\n}});\nfn main() {}\n', 'use verus_builtin::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nfn main() {}\n', 'use verus_builtin;\n   fn main() {\n }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/petersons_algorithm.rs,176,83,0.4715909090909091,886.784,True,0.7999999999999999,False,"['verus_builtin::', 'verus_builtin_macros::', 'verus_state_machines_macros::', 'vstd::prelude::']",True,,,,,,"// rust_verify/tests/example.rs expect-warnings
use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::*;
use vstd::prelude::*;

#[verifier::verify]
pub enum ThreadState {
    Idle,
    SetFlag,
    Waiting,
    Critical,
}

tokenized_state_machine! { Petersons<T> {
    fields {
        #[sharding(variable)] pub flag_0: bool,
        #[sharding(variable)] pub flag_1: bool,
        #[sharding(variable)] pub turn: int,

        #[sharding(variable)] pub thread_0: ThreadState,
        #[sharding(variable)] pub thread_1: ThreadState,

        #[sharding(storage_option)] pub storage: Option<T>,
    }

    #[invariant]
    pub spec fn the_inv(&self) -> bool {
        &&& (self.thread_0 === ThreadState::Idle) <==> !self.flag_0
        &&& (self.thread_1 === ThreadState::Idle) <==> !self.flag_1
        &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)
        &&& self.storage.is_Some() <==>
            (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)
        &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag
        &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag
        &&& self.turn == 0 || self.turn == 1
    }

    init!{
        initialize(t: T) {
            init flag_0 = false;
            init flag_1 = false;
            init turn = 0;
            init thread_0 = ThreadState::Idle;
            init thread_1 = ThreadState::Idle;
            init storage = Option::Some(t);
        }
    }

    //// Thread 0 transitions

    transition!{
        t0_set_flag() {
            require pre.thread_0 === ThreadState::Idle;
            update thread_0 = ThreadState::SetFlag;

            update flag_0 = true;
        }
    }

    transition!{
        t0_set_turn() {
            require pre.thread_0 === ThreadState::SetFlag;
            update thread_0 = ThreadState::Waiting;
            update turn = 1;
        }
    }

    transition!{
        t0_enter_via_flag() {
            require pre.thread_0 === ThreadState::Waiting;
            require pre.flag_1 == false;
            update thread_0 = ThreadState::Critical;
            withdraw storage -= Some(let _);
        }
    }

    transition!{
        t0_enter_via_turn() {
            require pre.thread_0 === ThreadState::Waiting;
            require pre.turn != 1;
            update thread_0 = ThreadState::Critical;
            withdraw storage -= Some(let _);
        }
    }

    transition!{
        t0_done(t: T) {
            require pre.thread_0 === ThreadState::Critical;
            update thread_0 = ThreadState::Idle;
            update flag_0 = false;
            deposit storage += Some(t);
        }
    }

    //// Thread 1 transitions

    transition!{
        t1_set_flag() {
            require pre.thread_1 === ThreadState::Idle;
            update thread_1 = ThreadState::SetFlag;

            update flag_1 = true;
        }
    }

    transition!{
        t1_set_turn() {
            require pre.thread_1 === ThreadState::SetFlag;
            update thread_1 = ThreadState::Waiting;
            update turn = 0;
        }
    }

    transition!{
        t1_enter_via_flag() {
            require pre.thread_1 === ThreadState::Waiting;
            require pre.flag_0 == false;
            update thread_1 = ThreadState::Critical;
            withdraw storage -= Some(let _);
        }
    }

    transition!{
        t1_enter_via_turn() {
            require pre.thread_1 === ThreadState::Waiting;
            require pre.turn != 0;
            update thread_1 = ThreadState::Critical;
            withdraw storage -= Some(let _);
        }
    }

    transition!{
        t1_done(t: T) {
            require pre.thread_1 === ThreadState::Critical;
            update thread_1 = ThreadState::Idle;
            update flag_1 = false;
            deposit storage += Some(t);
        }
    }

    #[inductive(initialize)]
    fn initialize_inductive(post: Self, t: T) { }

    #[inductive(t0_set_flag)]
    fn t0_set_flag_inductive(pre: Self, post: Self) { }

    #[inductive(t0_set_turn)]
    fn t0_set_turn_inductive(pre: Self, post: Self) { }

    #[inductive(t0_enter_via_flag)]
    fn t0_enter_via_flag_inductive(pre: Self, post: Self) { }

    #[inductive(t0_enter_via_turn)]
    fn t0_enter_via_turn_inductive(pre: Self, post: Self) { }

    #[inductive(t0_done)]
    fn t0_done_inductive(pre: Self, post: Self, t: T) { }

    #[inductive(t1_set_flag)]
    fn t1_set_flag_inductive(pre: Self, post: Self) { }

    #[inductive(t1_set_turn)]
    fn t1_set_turn_inductive(pre: Self, post: Self) { }

    #[inductive(t1_enter_via_flag)]
    fn t1_enter_via_flag_inductive(pre: Self, post: Self) { }

    #[inductive(t1_enter_via_turn)]
    fn t1_enter_via_turn_inductive(pre: Self, post: Self) { }

    #[inductive(t1_done)]
    fn t1_done_inductive(pre: Self, post: Self, t: T) { }
}}

fn main() {}
"," use verus_state_machines_macros::*;
        use vstd::prelude::*;
#[verifier::verify]
pub enum ThreadState {
           Idle,     SetFlag,     Waiting,     Critical, }
        tokenized_state_machine! {
       Petersons<T> {
          fields {
#[sharding(variable)] pub flag_0: bool,
#[sharding(variable)] pub flag_1: bool,
#[sharding(variable)] pub turn: int,
#[sharding(variable)] pub thread_0: ThreadState,
#[sharding(variable)] pub thread_1: ThreadState,
#[sharding(storage_option)] pub storage: Option<T>,
    }
#[invariant]
    pub spec fn the_inv(&self) -> bool {
             &&& (self.thread_0 === ThreadState::Idle) <==> !self.flag_0         &&& (self.thread_1 === ThreadState::Idle) <==> !self.flag_1         &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)         &&& self.storage.is_Some() <==>             (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)         &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag         &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag         &&& self.turn == 0 || self.turn == 1     }
          init!{
             initialize(t: T) {
                init flag_0 = false;
                init flag_1 = false;
                init turn = 0;
                init thread_0 = ThreadState::Idle;
                init thread_1 = ThreadState::Idle;
                init storage = Option::Some(t);
            }
         }
          transition!{
             t0_set_flag() {}
         }
          transition!{
             t0_set_turn() {}
         }
          transition!{
             t0_enter_via_flag() {}
         }
          transition!{
             t0_enter_via_turn() {}
         }
          transition!{
             t0_done(t: T) {}
         }
          transition!{
             t1_set_flag() {}
         }
          transition!{
             t1_set_turn() {}
         }
          transition!{
             t1_enter_via_flag() {}
         }
          transition!{
             t1_enter_via_turn() {}
         }
          transition!{
             t1_done(t: T) {}
         }
#[inductive(initialize)]
    fn initialize_inductive(post: Self, t: T) {}
#[inductive(t0_set_flag)]
    fn t0_set_flag_inductive(pre: Self, post: Self) {}
#[inductive(t0_set_turn)]
    fn t0_set_turn_inductive(pre: Self, post: Self) {}
#[inductive(t0_enter_via_flag)]
    fn t0_enter_via_flag_inductive(pre: Self, post: Self) {}
#[inductive(t0_enter_via_turn)]
    fn t0_enter_via_turn_inductive(pre: Self, post: Self) {}
#[inductive(t0_done)]
    fn t0_done_inductive(pre: Self, post: Self, t: T) {}
#[inductive(t1_set_flag)]
    fn t1_set_flag_inductive(pre: Self, post: Self) {}
#[inductive(t1_set_turn)]
    fn t1_set_turn_inductive(pre: Self, post: Self) {}
#[inductive(t1_enter_via_flag)]
    fn t1_enter_via_flag_inductive(pre: Self, post: Self) {}
#[inductive(t1_enter_via_turn)]
    fn t1_enter_via_turn_inductive(pre: Self, post: Self) {}
#[inductive(t1_done)]
    fn t1_done_inductive(pre: Self, post: Self, t: T) {}
      }
      }
        fn main() {}
","['// rust_verify/tests/example.rs expect-warnings\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::*;\nuse vstd::prelude::*;\n\n#[verifier::verify]\npub enum ThreadState {\n    Idle,\n    SetFlag,\n    Waiting,\n    Critical,\n}\n\ntokenized_state_machine! { Petersons<T> {\n    fields {\n        #[sharding(variable)] pub flag_0: bool,\n        #[sharding(variable)] pub flag_1: bool,\n        #[sharding(variable)] pub turn: int,\n\n        #[sharding(variable)] pub thread_0: ThreadState,\n        #[sharding(variable)] pub thread_1: ThreadState,\n\n        #[sharding(storage_option)] pub storage: Option<T>,\n    }\n\n    #[invariant]\n    pub spec fn the_inv(&self) -> bool {\n        &&& (self.thread_0 === ThreadState::Idle) <==> !self.flag_0\n        &&& (self.thread_1 === ThreadState::Idle) <==> !self.flag_1\n        &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)\n        &&& self.storage.is_Some() <==>\n            (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)\n        &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag\n        &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag\n        &&& self.turn == 0 || self.turn == 1\n    }\n\n    init!{\n        initialize(t: T) {\n            init flag_0 = false;\n            init flag_1 = false;\n            init turn = 0;\n            init thread_0 = ThreadState::Idle;\n            init thread_1 = ThreadState::Idle;\n            init storage = Option::Some(t);\n        }\n    }\n\n    //// Thread 0 transitions\n\n    transition!{\n        t0_set_flag() {\n            require pre.thread_0 === ThreadState::Idle;\n            update thread_0 = ThreadState::SetFlag;\n\n            update flag_0 = true;\n        }\n    }\n\n    transition!{\n        t0_set_turn() {\n            require pre.thread_0 === ThreadState::SetFlag;\n            update thread_0 = ThreadState::Waiting;\n            update turn = 1;\n        }\n    }\n\n    transition!{\n        t0_enter_via_flag() {\n            require pre.thread_0 === ThreadState::Waiting;\n            require pre.flag_1 == false;\n            update thread_0 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t0_enter_via_turn() {\n            require pre.thread_0 === ThreadState::Waiting;\n            require pre.turn != 1;\n            update thread_0 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t0_done(t: T) {\n            require pre.thread_0 === ThreadState::Critical;\n            update thread_0 = ThreadState::Idle;\n            update flag_0 = false;\n            deposit storage += Some(t);\n        }\n    }\n\n    //// Thread 1 transitions\n\n    transition!{\n        t1_set_flag() {\n            require pre.thread_1 === ThreadState::Idle;\n            update thread_1 = ThreadState::SetFlag;\n\n            update flag_1 = true;\n        }\n    }\n\n    transition!{\n        t1_set_turn() {\n            require pre.thread_1 === ThreadState::SetFlag;\n            update thread_1 = ThreadState::Waiting;\n            update turn = 0;\n        }\n    }\n\n    transition!{\n        t1_enter_via_flag() {\n            require pre.thread_1 === ThreadState::Waiting;\n            require pre.flag_0 == false;\n            update thread_1 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t1_enter_via_turn() {\n            require pre.thread_1 === ThreadState::Waiting;\n            require pre.turn != 0;\n            update thread_1 = ThreadState::Critical;\n            withdraw storage -= Some(let _);\n        }\n    }\n\n    transition!{\n        t1_done(t: T) {\n            require pre.thread_1 === ThreadState::Critical;\n            update thread_1 = ThreadState::Idle;\n            update flag_1 = false;\n            deposit storage += Some(t);\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) { }\n\n    #[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_enter_via_turn)]\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t0_done)]\n    fn t0_done_inductive(pre: Self, post: Self, t: T) { }\n\n    #[inductive(t1_set_flag)]\n    fn t1_set_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_set_turn)]\n    fn t1_set_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_enter_via_flag)]\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_enter_via_turn)]\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) { }\n\n    #[inductive(t1_done)]\n    fn t1_done_inductive(pre: Self, post: Self, t: T) { }\n}}\n\nfn main() {}\n', 'use verus_state_machines_macros::*;\nuse vstd::prelude::*;\ntokenized_state_machine !{\n  a<b> {\n    fields {\n#[sharding(storage_option)] pub c : Option<b> }\n    }\n  }\n  fn main() {}', ' use verus_state_machines_macros::*;\n        use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n           Idle,     SetFlag,     Waiting,     Critical, }\n        tokenized_state_machine! {\n       Petersons<T> {\n          fields {\n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }\n#[invariant]\n    pub spec fn the_inv(&self) -> bool {\n             &&& (self.thread_0 === ThreadState::Idle) <==> !self.flag_0         &&& (self.thread_1 === ThreadState::Idle) <==> !self.flag_1         &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)         &&& self.storage.is_Some() <==>             (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)         &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag         &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag         &&& self.turn == 0 || self.turn == 1     }\n          init!{\n             initialize(t: T) {\n                init flag_0 = false;\n                init flag_1 = false;\n                init turn = 0;\n                init thread_0 = ThreadState::Idle;\n                init thread_1 = ThreadState::Idle;\n                init storage = Option::Some(t);\n            }\n         }\n          transition!{\n             t0_set_flag() {}\n         }\n          transition!{\n             t0_set_turn() {}\n         }\n          transition!{\n             t0_enter_via_flag() {}\n         }\n          transition!{\n             t0_enter_via_turn() {}\n         }\n          transition!{\n             t0_done(t: T) {}\n         }\n          transition!{\n             t1_set_flag() {}\n         }\n          transition!{\n             t1_set_turn() {}\n         }\n          transition!{\n             t1_enter_via_flag() {}\n         }\n          transition!{\n             t1_enter_via_turn() {}\n         }\n          transition!{\n             t1_done(t: T) {}\n         }\n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) {}\n#[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t0_enter_via_turn)]\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t0_done)]\n    fn t0_done_inductive(pre: Self, post: Self, t: T) {}\n#[inductive(t1_set_flag)]\n    fn t1_set_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t1_set_turn)]\n    fn t1_set_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t1_enter_via_flag)]\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) {}\n#[inductive(t1_enter_via_turn)]\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) {}\n#[inductive(t1_done)]\n    fn t1_done_inductive(pre: Self, post: Self, t: T) {}\n      }\n      }\n        fn main() {}\n', ' use verus_state_machines_macros::*;\n          use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n            Idle,     SetFlag,     Waiting,     Critical, }\n          tokenized_state_machine! {\n        Petersons<T> {           fields {  \n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }  \n#[invariant]\n    pub spec fn the_inv(&self) -> bool {              &&& (self.thread_0 === ThreadState::Idle) == !self.flag_0         &&& (self.thread_1 === ThreadState::Idle) == !self.flag_1         &&& !(self.thread_0 === ThreadState::Critical && self.thread_1 === ThreadState::Critical)         &&& self.storage.is_Some() ==             (self.thread_0 !== ThreadState::Critical && self.thread_1 !== ThreadState::Critical)         &&& self.thread_0 === ThreadState::Critical && self.turn == 1 ==> self.thread_1 === ThreadState::Idle || self.thread_1 === ThreadState::SetFlag         &&& self.thread_1 === ThreadState::Critical && self.turn == 0 ==> self.thread_0 === ThreadState::Idle || self.thread_0 === ThreadState::SetFlag         &&& self.turn == 0 || self.turn == 1     }           init!{              initialize(t: T) {                 init flag_0 = false;                 init flag_1 = false;                 init turn = 0;                 init thread_0 = ThreadState::Idle;                 init thread_1 = ThreadState::Idle;                 init storage = Option::Some(t);             }          }           transition!{              t0_set_flag() {}          }           transition!{              t0_set_turn() {}          }           transition!{              t0_enter_via_flag() {}          }           transition!{              t0_enter_via_turn() {}          }           transition!{              t0_done(t: T) {}          }           transition!{              t1_set_flag() {}          }           transition!{              t1_set_turn() {}          }           transition!{              t1_enter_via_flag() {}          }           transition!{              t1_enter_via_turn() {}          }           transition!{              t1_done(t: T) {}          }  \n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) {}  \n#[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) {}  \n#[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) {}  \n#[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) {}  \n#[inductive(t0_enter_via_turn)]\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) {}  \n#[inductive(t0_done)]\n    fn t0_done_inductive(pre: Self, post: Self, t: T) {}  \n#[inductive(t1_set_flag)]\n    fn t1_set_flag_inductive(pre: Self, post: Self) {}  \n#[inductive(t1_set_turn)]\n    fn t1_set_turn_inductive(pre: Self, post: Self) {}  \n#[inductive(t1_enter_via_flag)]\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) {}  \n#[inductive(t1_enter_via_turn)]\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) {}  \n#[inductive(t1_done)]\n    fn t1_done_inductive(pre: Self, post: Self, t: T) {}       }\n       }\n          fn main() {\n}\n', ' use verus_state_machines_macros::*;\n            use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n              Idle,     SetFlag,     Waiting,     Critical, }\n            tokenized_state_machine! {\n          Petersons<T> {\n            fields {\n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }\n            init!{\n              initialize(t: T) {                 init flag_0 = false;                 init flag_1 = false;                 init turn = 0;                 init thread_0 = ThreadState::Idle;                 init thread_1 = ThreadState::Idle;                 init storage = Option::Some(t);             }\n          }\n            transition!{\n              t0_set_flag() {}\n          }\n            transition!{\n              t0_set_turn() {}\n          }\n            transition!{\n              t0_enter_via_flag() {}\n          }\n            transition!{\n              t0_enter_via_turn() {}\n          }\n            transition!{\n              t0_done(t: T) {}\n          }\n            transition!{\n              t1_set_flag() {}\n          }\n            transition!{\n              t1_set_turn() {}\n          }\n            transition!{\n              t1_enter_via_flag() {}\n          }\n            transition!{\n              t1_enter_via_turn() {}\n          }\n            transition!{\n              t1_done(t: T) {}\n          }\n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, t: T) {\n}\n#[inductive(t0_set_flag)]\n    fn t0_set_flag_inductive(pre: Self, post: Self) {\n}\n#[inductive(t0_set_turn)]\n    fn t0_set_turn_inductive(pre: Self, post: Self) {\n}\n#[inductive(t0_enter_via_flag)]\n    fn t0_enter_via_flag_inductive(pre: Self, post: Self) {\n}\n    fn t0_enter_via_turn_inductive(pre: Self, post: Self) {\n}\n    fn t0_done_inductive(pre: Self, post: Self, t: T) {\n}\n    fn t1_set_flag_inductive(pre: Self, post: Self) {\n}\n    fn t1_set_turn_inductive(pre: Self, post: Self) {\n}\n    fn t1_enter_via_flag_inductive(pre: Self, post: Self) {\n}\n    fn t1_enter_via_turn_inductive(pre: Self, post: Self) {\n}\n    fn t1_done_inductive(pre: Self, post: Self, t: T) {\n}\n        }\n         }\n            fn main() {\n  }\n', ' use verus_state_machines_macros::*;\n             use vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n               Idle,     SetFlag,     Waiting,     Critical, }\n             tokenized_state_machine! {\n           Petersons<T> {\n             fields {\n#[sharding(variable)] pub flag_0: bool,\n#[sharding(variable)] pub flag_1: bool,\n#[sharding(variable)] pub turn: int,\n#[sharding(variable)] pub thread_0: ThreadState,\n#[sharding(variable)] pub thread_1: ThreadState,\n#[sharding(storage_option)] pub storage: Option<T>,\n    }\n             init!{\n               initialize(t: T) {\n                 init flag_0 = false;\n                 init flag_1 = false;\n                 init turn = 0;\n                 init thread_0 = ThreadState::Idle;\n                 init thread_1 = ThreadState::Idle;\n                 init storage = Option::Some(t);\n             }\n           }\n             transition!{\n               t0_set_flag() {\n}\n           }\n             transition!{\n               t0_set_turn() {\n}\n           }\n             transition!{\n               t0_enter_via_flag() {\n}\n           }\n             transition!{\n               t0_enter_via_turn() {\n}\n           }\n             transition!{\n               t0_done(t: T) {\n}\n           }\n             transition!{\n               t1_set_flag() {\n}\n           }\n             transition!{\n               t1_set_turn() {\n}\n           }\n             transition!{\n               t1_enter_via_flag() {\n}\n           }\n             transition!{\n               t1_enter_via_turn() {\n}\n           }\n             transition!{\n               t1_done(t: T) {\n}\n           }\n         }\n          }\n             fn main() {\n   }\n', 'use verus_state_machines_macros::*;\nuse vstd::prelude::*;\n#[verifier::verify]\npub enum ThreadState {\n  Idle,\n  SetFlagWaitingCritical} tokenized_state_machine !{\n  Petersons< T > {\n    fields {\n#[sharding(variable)] pub flag_0 : bool,\n#[sharding(variable)] pub flag_1 : bool,\n#[sharding(variable)] pub turn : int,\n#[sharding(variable)] pub thread_0 : ThreadState,\n#[sharding(variable)] pub thread_1 : ThreadState,\n#[sharding(storage_option)] pub storage : Option<T>,\n    }\n    init !{\n      initialize(t : T) {\n        init flag_0 = false;\n        init flag_1 = false;\n        init turn = 0;\n        init thread_0 = ThreadState::Idle;\n        init thread_1 = ThreadState::Idle;\n        init storage = Option::Some(t);\n      }\n    }\n  }\n}\nfn main() {}\n', 'use verus_state_machines_macros::*;\nuse vstd::prelude::*;\n#[verifier::verify]\npub enum a {\n  b} tokenized_state_machine !{\n  c< d > {\n    fields {\n#[sharding(variable)] pub e : bool,\n#[sharding(variable)] pub f : bool,\n#[sharding(variable)] pub turn : int,\n#[sharding(variable)] pub thread_0 : a,\n#[sharding(variable)] pub thread_1 : a,\n#[sharding(storage_option)] pub storage : Option<d>}\n    init !{\n      initialize(t : d) {\n        init e = false;\n        init f = false;\n        init turn = 0;\n        init thread_0 = a::b;\n        init thread_1 = a::b;\n        init storage = Some(t);\n      }\n    }\n  }\n}\nfn main() {}\n', 'use verus_state_machines_macros::*;\n   use vstd::prelude::*;\n#[verifier::verify]\npub enum a {\n    b}\n   tokenized_state_machine !{\n    c< d > {\n     fields {   \n#[sharding(variable)] pub e : bool,\n#[sharding(variable)] pub f : bool,\n#[sharding(variable)] pub turn : int,\n#[sharding(variable)] pub g : a,\n#[sharding(variable)] pub h : a,\n#[sharding(storage_option)] pub i : Option<d>}\n    init !{       initialize(j : d) {         init e = false;         init f = false;         init turn = 0;         init g = a::b;         init h = a::b;         init i = Some(j);       }     }   }\n }\n  fn main() {\n}\n', 'use verus_state_machines_macros::*;\nuse vstd::prelude::*;\nenum a { } tokenized_state_machine !{\n  c< d > {\n    fields {\n#[sharding(storage_option)] pub i : Option<d> }\n    }\n  }\n  fn main() {}\n', 'use verus_state_machines_macros::*;\n use vstd::prelude::*;\n tokenized_state_machine !{   a< b > {     fields { \n#[sharding(storage_option)] pub c : Option<b> }\n    }   }   fn main() {} ']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/reference-examples/strategy_option.rs,92,20,0.21739130434782608,491.041,True,0.7999999999999999,False,"['vstd::prelude::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,,,,"#![allow(unused_imports)]

use vstd::prelude::*;

use verus_state_machines_macros::tokenized_state_machine;

verus! {

// ANCHOR: full
tokenized_state_machine!{ State {
    fields {
        #[sharding(variable)]
        pub token_exists: bool,

        #[sharding(option)]
        pub field: Option<int>,
    }

    #[invariant]
    pub fn token_exists_correct(&self) -> bool {
        self.token_exists <==> self.field is Some
    }

    init!{
        initialize(v: int) {
            init field = Option::Some(v);
            init token_exists = true;
        }
    }

    transition!{
        add_token(v: int) {
            require !pre.token_exists;
            update token_exists = true;

            add field += Some(v);
        }
    }

    transition!{
        remove_token() {
            remove field -= Some(let _);

            assert pre.token_exists;
            update token_exists = false;
        }
    }

    transition!{
        have_token() {
            have field >= Some(let _);

            assert pre.token_exists;
        }
    }

    #[inductive(initialize)]
    fn initialize_inductive(post: Self, v: int) { }

    #[inductive(add_token)]
    fn add_token_inductive(pre: Self, post: Self, v: int) { }

    #[inductive(remove_token)]
    fn remove_token_inductive(pre: Self, post: Self) { }

    #[inductive(have_token)]
    fn have_token_inductive(pre: Self, post: Self) { }
}}

proof fn option_example() {
    let tracked (Tracked(instance), Tracked(mut token_exists), Tracked(token_opt)) =
        State::Instance::initialize(5);

    let tracked token = token_opt.tracked_unwrap();
    assert(token.value() == 5);

    instance.have_token(&token_exists, &token);
    assert(token_exists.value() == true);

    instance.remove_token(&mut token_exists, token);  // consumes token
    assert(token_exists.value() == false);            // updates token_exists to `false`

    let tracked token = instance.add_token(19, &mut token_exists);
    assert(token_exists.value() == true);  // updates token_exists to `true`
    assert(token.value() == 19);           // new token has value 19
}

// ANCHOR_END: full
fn main() {
}

} // verus!
","use vstd::prelude::*;
          use verus_state_machines_macros::tokenized_state_machine;
          verus! {
        tokenized_state_machine!{       State {          fields {  
#[sharding(variable)]
        pub token_exists: bool,                  
#[sharding(option)]
        pub field: Option<int>,     }  
#[invariant]
    pub fn token_exists_correct(&self) -> bool {             self.token_exists == self.field is Some     }          init!{             initialize(v: int) {                init field = Option::Some(v);                init token_exists = true;            }         }          transition!{             add_token(v: int) {}         }          transition!{             remove_token() {}         }          transition!{             have_token() {}         }  
#[inductive(initialize)]
    fn initialize_inductive(post: Self, v: int) {}  
#[inductive(add_token)]
    fn add_token_inductive(pre: Self, post: Self, v: int) {}  
#[inductive(remove_token)]
    fn remove_token_inductive(pre: Self, post: Self) {}  
#[inductive(have_token)]
    fn have_token_inductive(pre: Self, post: Self) {}      }      }
        fn main() ;
        }
","['#![allow(unused_imports)]\n\nuse vstd::prelude::*;\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\nverus! {\n\n// ANCHOR: full\ntokenized_state_machine!{ State {\n    fields {\n        #[sharding(variable)]\n        pub token_exists: bool,\n\n        #[sharding(option)]\n        pub field: Option<int>,\n    }\n\n    #[invariant]\n    pub fn token_exists_correct(&self) -> bool {\n        self.token_exists <==> self.field is Some\n    }\n\n    init!{\n        initialize(v: int) {\n            init field = Option::Some(v);\n            init token_exists = true;\n        }\n    }\n\n    transition!{\n        add_token(v: int) {\n            require !pre.token_exists;\n            update token_exists = true;\n\n            add field += Some(v);\n        }\n    }\n\n    transition!{\n        remove_token() {\n            remove field -= Some(let _);\n\n            assert pre.token_exists;\n            update token_exists = false;\n        }\n    }\n\n    transition!{\n        have_token() {\n            have field >= Some(let _);\n\n            assert pre.token_exists;\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, v: int) { }\n\n    #[inductive(add_token)]\n    fn add_token_inductive(pre: Self, post: Self, v: int) { }\n\n    #[inductive(remove_token)]\n    fn remove_token_inductive(pre: Self, post: Self) { }\n\n    #[inductive(have_token)]\n    fn have_token_inductive(pre: Self, post: Self) { }\n}}\n\nproof fn option_example() {\n    let tracked (Tracked(instance), Tracked(mut token_exists), Tracked(token_opt)) =\n        State::Instance::initialize(5);\n\n    let tracked token = token_opt.tracked_unwrap();\n    assert(token.value() == 5);\n\n    instance.have_token(&token_exists, &token);\n    assert(token_exists.value() == true);\n\n    instance.remove_token(&mut token_exists, token);  // consumes token\n    assert(token_exists.value() == false);            // updates token_exists to `false`\n\n    let tracked token = instance.add_token(19, &mut token_exists);\n    assert(token_exists.value() == true);  // updates token_exists to `true`\n    assert(token.value() == 19);           // new token has value 19\n}\n\n// ANCHOR_END: full\nfn main() {\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\n          use verus_state_machines_macros::tokenized_state_machine;\n          verus! {\n        tokenized_state_machine!{       State {          fields {  \n#[sharding(variable)]\n        pub token_exists: bool,                  \n#[sharding(option)]\n        pub field: Option<int>,     }  \n#[invariant]\n    pub fn token_exists_correct(&self) -> bool {             self.token_exists == self.field is Some     }          init!{             initialize(v: int) {                init field = Option::Some(v);                init token_exists = true;            }         }          transition!{             add_token(v: int) {}         }          transition!{             remove_token() {}         }          transition!{             have_token() {}         }  \n#[inductive(initialize)]\n    fn initialize_inductive(post: Self, v: int) {}  \n#[inductive(add_token)]\n    fn add_token_inductive(pre: Self, post: Self, v: int) {}  \n#[inductive(remove_token)]\n    fn remove_token_inductive(pre: Self, post: Self) {}  \n#[inductive(have_token)]\n    fn have_token_inductive(pre: Self, post: Self) {}      }      }\n        fn main() ;\n        }\n', 'use vstd::prelude::*;\n               use verus_state_machines_macros::tokenized_state_machine;\n               verus! {\n             tokenized_state_machine!{\n           State {\n             fields {\n#[sharding(variable)]\n        pub token_exists: bool,                       \n#[sharding(option)]\n        pub field: Option<int>,     }\n             init!{\n               initialize(v: int) {\n                 init field = Option::Some(v);\n                 init token_exists = true;\n             }\n           }\n         }\n          }\n             fn main() ;\n             }\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nverus !{\n  tokenized_state_machine !{\n    State {\n      fields{\n#[sharding(variable)]\n        pub token_exists : bool,\n#[sharding(option)]\n        pub field : Option< int >} init !{\n        initialize(v : int) {\n          init field = Some(v);\n          init token_exists = true;\n        }\n      }\n    }\n  }\n  fn main();\n}\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nverus !{\n  tokenized_state_machine !{\n    a {\n      fields{\n#[sharding(variable)]\n        pub b : bool,\n#[sharding(option)]\n        pub c : Option< int >} init !{\n        d(e : int) {\n          init c = Some(e);\n          init b = true;\n        }\n      }\n    }\n  }\n  fn main();\n}\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nverus !{\n  tokenized_state_machine !{\n    a {\n      fields {\n#[sharding(variable)]\n        pub b : bool,\n#[sharding(option)]\n                pub c : Option< int >\n      }\n    }\n  }\n  fn main();\n}\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nverus !{\n  tokenized_state_machine !{\n    a {\n      fields {\n}\n    }\n  }\n  fn main();\n}\n', 'use vstd::prelude::*;\n   verus !{\n    fn main();\n  }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/refinement.rs,121,121,1.0,153.584,True,0.9,False,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::', 'verus_state_machines_macros::case_on_init', 'verus_state_machines_macros::case_on_next', 'verus_state_machines_macros::state_machine']",True,,True,,3.0,3.0,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::case_on_init;
use verus_state_machines_macros::case_on_next;
use verus_state_machines_macros::state_machine;

state_machine! {
    B {
        fields {
            pub number: int,
        }

        init!{
            initialize() {
                init number = 0;
            }
        }

        transition!{
            add(n: int) {
                require(n % 2 == 0);
                update number = pre.number + n;
            }
        }

        #[invariant]
        pub fn is_even(&self) -> bool {
            self.number % 2 == 0
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self) { }

        #[inductive(add)]
        fn add_inductive(pre: Self, post: Self, n: int) { }
    }
}

state_machine! {
    A {
        fields {
            pub number: int,
        }

        init!{
            initialize() {
                init number = 0;
            }
        }

        transition!{
            add(n: int) {
                update number = pre.number + n;
            }
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self) { }

        #[inductive(add)]
        fn add_inductive(pre: Self, post: Self, n: int) { }
    }
}

verus! {

spec fn interp(a: A::State) -> B::State {
    B::State { number: a.number * 2 }
}

proof fn next_refines_next(pre: A::State, post: A::State) {
    requires(
        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),
    );
    ensures(B::State::next(interp(pre), interp(post)));
    reveal(A::State::next);
    match choose|step: A::Step| A::State::next_by(pre, post, step) {
        A::Step::add(n) => {
            assert_by(
                A::State::add(pre, post, n),
                {
                    reveal(A::State::next_by);
                },
            );
            B::show::add(interp(pre), interp(post), 2 * n);
        },
        A::Step::dummy_to_use_type_params(_) => {
            assume(false);  // TODO
        },
    }
}

proof fn next_refines_next_with_macro(pre: A::State, post: A::State) {
    requires(
        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),
    );
    ensures(B::State::next(interp(pre), interp(post)));
    case_on_next!{pre, post, A => {
        add(n) => {
            assert(0u32 === 0u32); // test verus syntax
            B::show::add(interp(pre), interp(post), 2 * n);
        }
    }}
}

proof fn init_refines_init_with_macro(post: A::State) {
    requires(post.invariant() && A::State::init(post));
    ensures(B::State::init(interp(post)));
    case_on_init!{post, A => {
        initialize() => {
            B::show::initialize(interp(post));
        }
    }}
}

} // verus!
fn main() {}
","// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::case_on_init;
use verus_state_machines_macros::case_on_next;
use verus_state_machines_macros::state_machine;

state_machine! {
    B {
        fields {
            pub number: int,
        }

        init!{
            initialize() {
                init number = 0;
            }
        }

        transition!{
            add(n: int) {
                require(n % 2 == 0);
                update number = pre.number + n;
            }
        }

        #[invariant]
        pub fn is_even(&self) -> bool {
            self.number % 2 == 0
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self) { }

        #[inductive(add)]
        fn add_inductive(pre: Self, post: Self, n: int) { }
    }
}

state_machine! {
    A {
        fields {
            pub number: int,
        }

        init!{
            initialize() {
                init number = 0;
            }
        }

        transition!{
            add(n: int) {
                update number = pre.number + n;
            }
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self) { }

        #[inductive(add)]
        fn add_inductive(pre: Self, post: Self, n: int) { }
    }
}

verus! {

spec fn interp(a: A::State) -> B::State {
    B::State { number: a.number * 2 }
}

proof fn next_refines_next(pre: A::State, post: A::State) {
    requires(
        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),
    );
    ensures(B::State::next(interp(pre), interp(post)));
    reveal(A::State::next);
    match choose|step: A::Step| A::State::next_by(pre, post, step) {
        A::Step::add(n) => {
            assert_by(
                A::State::add(pre, post, n),
                {
                    reveal(A::State::next_by);
                },
            );
            B::show::add(interp(pre), interp(post), 2 * n);
        },
        A::Step::dummy_to_use_type_params(_) => {
            assume(false);  // TODO
        },
    }
}

proof fn next_refines_next_with_macro(pre: A::State, post: A::State) {
    requires(
        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),
    );
    ensures(B::State::next(interp(pre), interp(post)));
    case_on_next!{pre, post, A => {
        add(n) => {
            assert(0u32 === 0u32); // test verus syntax
            B::show::add(interp(pre), interp(post), 2 * n);
        }
    }}
}

proof fn init_refines_init_with_macro(post: A::State) {
    requires(post.invariant() && A::State::init(post));
    ensures(B::State::init(interp(post)));
    case_on_init!{post, A => {
        initialize() => {
            B::show::initialize(interp(post));
        }
    }}
}

} // verus!
fn main() {}
","['// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nstate_machine! {\n    B {\n        fields {\n            pub number: int,\n        }\n\n        init!{\n            initialize() {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                require(n % 2 == 0);\n                update number = pre.number + n;\n            }\n        }\n\n        #[invariant]\n        pub fn is_even(&self) -> bool {\n            self.number % 2 == 0\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n    }\n}\n\nstate_machine! {\n    A {\n        fields {\n            pub number: int,\n        }\n\n        init!{\n            initialize() {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(n: int) {\n                update number = pre.number + n;\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, n: int) { }\n    }\n}\n\nverus! {\n\nspec fn interp(a: A::State) -> B::State {\n    B::State { number: a.number * 2 }\n}\n\nproof fn next_refines_next(pre: A::State, post: A::State) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n    );\n    ensures(B::State::next(interp(pre), interp(post)));\n    reveal(A::State::next);\n    match choose|step: A::Step| A::State::next_by(pre, post, step) {\n        A::Step::add(n) => {\n            assert_by(\n                A::State::add(pre, post, n),\n                {\n                    reveal(A::State::next_by);\n                },\n            );\n            B::show::add(interp(pre), interp(post), 2 * n);\n        },\n        A::Step::dummy_to_use_type_params(_) => {\n            assume(false);  // TODO\n        },\n    }\n}\n\nproof fn next_refines_next_with_macro(pre: A::State, post: A::State) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(pre, post),\n    );\n    ensures(B::State::next(interp(pre), interp(post)));\n    case_on_next!{pre, post, A => {\n        add(n) => {\n            assert(0u32 === 0u32); // test verus syntax\n            B::show::add(interp(pre), interp(post), 2 * n);\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: A::State) {\n    requires(post.invariant() && A::State::init(post));\n    ensures(B::State::init(interp(post)));\n    case_on_init!{post, A => {\n        initialize() => {\n            B::show::initialize(interp(post));\n        }\n    }}\n}\n\n} // verus!\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n         use verus_state_machines_macros::state_machine;\n         state_machine! {            B {               fields {}           }        }\n         state_machine! {            A {               fields {}           }        }\n          fn main() {}\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/refinement_labels.rs,135,16,0.11851851851851852,154.549,True,0.7,False,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::', 'verus_state_machines_macros::case_on_init', 'verus_state_machines_macros::case_on_next', 'verus_state_machines_macros::state_machine']",True,,,,,,"#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::case_on_init;
use verus_state_machines_macros::case_on_next;
use verus_state_machines_macros::state_machine;

state_machine! {
    B {
        fields {
            pub number: int,
        }

        pub struct InitLabel { }
        pub struct Label { }

        init!{
            initialize(label: InitLabel) {
                init number = 0;
            }
        }

        transition!{
            add(label: Label, n: int) {
                require(n % 2 == 0);
                update number = pre.number + n;
            }
        }

        #[invariant]
        pub fn is_even(&self) -> bool {
            self.number % 2 == 0
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, label: InitLabel) { }

        #[inductive(add)]
        fn add_inductive(pre: Self, post: Self, label: Label, n: int) { }
    }
}

state_machine! {
    A {
        fields {
            pub number: int,
        }

        pub type Label = B::Label;
        pub type InitLabel = B::InitLabel;

        init!{
            initialize(label: InitLabel) {
                init number = 0;
            }
        }

        transition!{
            add(label: Label, n: int) {
                update number = pre.number + n;
            }
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, label: InitLabel) { }

        #[inductive(add)]
        fn add_inductive(pre: Self, post: Self, label: Label, n: int) { }
    }
}

verus! {

spec fn interp(a: A::State) -> B::State {
    B::State { number: a.number * 2 }
}

proof fn next_refines_next(pre: A::State, post: A::State, label: B::Label) {
    requires(
        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(
            pre,
            post,
            label,
        ),
    );
    ensures(B::State::next(interp(pre), interp(post), label));
    reveal(A::State::next);
    match choose|step: A::Step| A::State::next_by(pre, post, label, step) {
        A::Step::add(n) => {
            assert_by(
                A::State::add(pre, post, label, n),
                {
                    reveal(A::State::next_by);
                },
            );
            B::show::add(interp(pre), interp(post), label, 2 * n);
        },
        A::Step::dummy_to_use_type_params(_) => {
            assume(false);  // TODO
        },
    }
}

proof fn next_refines_next_with_macro(pre: A::State, post: A::State, label: B::Label) {
    requires(
        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(
            pre,
            post,
            label,
        ),
    );
    ensures(B::State::next(interp(pre), interp(post), label));
    case_on_next!{pre, post, label, A => {
        add(n) => {
            assert(0u32 === 0u32); // test verus syntax
            B::show::add(interp(pre), interp(post), label, 2 * n);
        }
    }}
}

proof fn init_refines_init_with_macro(post: A::State, label: B::InitLabel) {
    requires(post.invariant() && A::State::init(post, label));
    ensures(B::State::init(interp(post), label));
    case_on_init!{post, label, A => {
        initialize() => {
            B::show::initialize(interp(post), label);
        }
    }}
}

} // verus!
fn main() {}
","use verus_builtin::*;
        use verus_state_machines_macros::state_machine;
        state_machine! {
           B {
              fields {
                 pub number: int,         }
          }
       }
        state_machine! {
           A {
              fields {
                 pub number: int,         }
          }
       }
         fn main() {
      }
","['#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nstate_machine! {\n    B {\n        fields {\n            pub number: int,\n        }\n\n        pub struct InitLabel { }\n        pub struct Label { }\n\n        init!{\n            initialize(label: InitLabel) {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(label: Label, n: int) {\n                require(n % 2 == 0);\n                update number = pre.number + n;\n            }\n        }\n\n        #[invariant]\n        pub fn is_even(&self) -> bool {\n            self.number % 2 == 0\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, label: InitLabel) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, label: Label, n: int) { }\n    }\n}\n\nstate_machine! {\n    A {\n        fields {\n            pub number: int,\n        }\n\n        pub type Label = B::Label;\n        pub type InitLabel = B::InitLabel;\n\n        init!{\n            initialize(label: InitLabel) {\n                init number = 0;\n            }\n        }\n\n        transition!{\n            add(label: Label, n: int) {\n                update number = pre.number + n;\n            }\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, label: InitLabel) { }\n\n        #[inductive(add)]\n        fn add_inductive(pre: Self, post: Self, label: Label, n: int) { }\n    }\n}\n\nverus! {\n\nspec fn interp(a: A::State) -> B::State {\n    B::State { number: a.number * 2 }\n}\n\nproof fn next_refines_next(pre: A::State, post: A::State, label: B::Label) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(\n            pre,\n            post,\n            label,\n        ),\n    );\n    ensures(B::State::next(interp(pre), interp(post), label));\n    reveal(A::State::next);\n    match choose|step: A::Step| A::State::next_by(pre, post, label, step) {\n        A::Step::add(n) => {\n            assert_by(\n                A::State::add(pre, post, label, n),\n                {\n                    reveal(A::State::next_by);\n                },\n            );\n            B::show::add(interp(pre), interp(post), label, 2 * n);\n        },\n        A::Step::dummy_to_use_type_params(_) => {\n            assume(false);  // TODO\n        },\n    }\n}\n\nproof fn next_refines_next_with_macro(pre: A::State, post: A::State, label: B::Label) {\n    requires(\n        pre.invariant() && post.invariant() && interp(pre).invariant() && A::State::next(\n            pre,\n            post,\n            label,\n        ),\n    );\n    ensures(B::State::next(interp(pre), interp(post), label));\n    case_on_next!{pre, post, label, A => {\n        add(n) => {\n            assert(0u32 === 0u32); // test verus syntax\n            B::show::add(interp(pre), interp(post), label, 2 * n);\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: A::State, label: B::InitLabel) {\n    requires(post.invariant() && A::State::init(post, label));\n    ensures(B::State::init(interp(post), label));\n    case_on_init!{post, label, A => {\n        initialize() => {\n            B::show::initialize(interp(post), label);\n        }\n    }}\n}\n\n} // verus!\nfn main() {}\n', 'use verus_builtin;\nfn main() {}\n', 'use verus_builtin::*;\n        use verus_state_machines_macros::state_machine;\n        state_machine! {\n           B {\n              fields {\n                 pub number: int,         }\n          }\n       }\n        state_machine! {\n           A {\n              fields {\n                 pub number: int,         }\n          }\n       }\n         fn main() {\n      }\n', 'use verus_builtin::*;\n                 fn main() {\n      }\n', 'use verus_builtin;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/rwlock.rs,197,83,0.4213197969543147,490.506,True,0.7999999999999999,False,"['verus_builtin::', 'vstd::cell::', 'vstd::multiset::', 'vstd::prelude::', 'vstd::', 'verus_state_machines_macros::tokenized_state_machine']",True,,,,,,"// rust_verify/tests/example.rs expect-warnings
#[allow(unused_imports)]
use verus_builtin::*;
use vstd::cell::*;
use vstd::multiset::*;
use vstd::prelude::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::tokenized_state_machine;

// TODO make T generic
#[verifier::verify]
pub struct T {
    t: u8,
}

tokenized_state_machine!(RwLock {
    fields {
        #[sharding(variable)]
        pub flags: (bool, nat),

        #[sharding(storage_option)]
        pub storage: Option<T>,

        #[sharding(option)]
        pub pending_writer: Option<()>,

        #[sharding(option)]
        pub writer: Option<()>,

        #[sharding(multiset)]
        pub pending_reader: Multiset<()>,

        #[sharding(multiset)]
        pub reader: Multiset<T>,
    }

    init!{
        initialize_empty() {
            init flags = (true, 0);
            init storage = Option::None;
            init pending_writer = Option::None;
            init writer = Option::Some(());
            init pending_reader = Multiset::empty();
            init reader = Multiset::empty();
        }
    }

    #[inductive(initialize_empty)]
    fn initialize_empty_inductive(post: Self) { }

    /// Increment the 'rc' counter, obtain a pending_reader
    transition!{
        acquire_read_start() {
            update flags = (pre.flags.0, pre.flags.1 + 1);
            add pending_reader += {()};
        }
    }

    /// Exchange the pending_reader for a reader by checking
    /// that the 'exc' bit is 0
    transition!{
        acquire_read_end() {
            require(pre.flags.0 == false);

            remove pending_reader -= {()};

            birds_eye let x: T = pre.storage.get_Some_0();
            add reader += {x};
        }
    }

    /// Decrement the 'rc' counter, abandon the attempt to gain
    /// the 'read' lock.
    transition!{
        acquire_read_abandon() {
            remove pending_reader -= {()};
            assert(pre.flags.1 >= 1);
            update flags = (pre.flags.0, (pre.flags.1 - 1) as nat);
        }
    }

    /// Atomically set 'exc' bit from 'false' to 'true'
    /// Obtain a pending_writer
    transition!{
        acquire_exc_start() {
            require(pre.flags.0 == false);
            update flags = (true, pre.flags.1);
            add pending_writer += Some(());
        }
    }

    /// Finish obtaining the write lock by checking that 'rc' is 0.
    /// Exchange the pending_writer for a writer and withdraw the
    /// stored object.
    transition!{
        acquire_exc_end() {
            require(pre.flags.1 == 0);

            remove pending_writer -= Some(());

            add writer += Some(());

            birds_eye let x = pre.storage.get_Some_0();
            withdraw storage -= Some(x);
        }
    }

    /// Release the write-lock. Update the 'exc' bit back to 'false'.
    /// Return the 'writer' and also deposit an object back into storage.
    transition!{
        release_exc(x: T) {
            remove writer -= Some(());

            update flags = (false, pre.flags.1);

            deposit storage += Some(x);
        }
    }

    /// Check that the 'reader' is actually a guard for the given object.
    property!{
        read_guard(x: T) {
            have reader >= {x};
            guard storage >= Some(x);
        }
    }

    /// Release the reader-lock. Decrement 'rc' and return the 'reader' object.
    #[transition]
    transition!{
        release_shared(x: T) {
            remove reader -= {x};

            assert(pre.flags.1 >= 1) by {
                //assert(pre.reader.count(x) >= 1);
                assert(equal(pre.storage, Option::Some(x)));
                //assert(equal(x, pre.storage.get_Some_0()));
            };
            update flags = (pre.flags.0, (pre.flags.1 - 1) as nat);
        }
    }

    #[invariant]
    pub fn exc_bit_matches(&self) -> bool {
        (if self.flags.0 { 1 } else { 0 as int }) ==
            (if self.pending_writer.is_Some() { 1 } else { 0 as int }) as int
            + (if self.writer.is_Some() { 1 } else { 0 as int }) as int
    }

    #[invariant]
    pub fn count_matches(&self) -> bool {
        self.flags.1 == self.pending_reader.count(())
            + self.reader.count(self.storage.get_Some_0())
    }

    #[invariant]
    pub fn reader_agrees_storage(&self) -> bool {
        forall |t: T| self.reader.count(t) > 0 ==>
            equal(self.storage, Option::Some(t))
    }

    #[invariant]
    pub fn writer_agrees_storage(&self) -> bool {
        self.writer.is_Some() ==> self.storage.is_None()
    }

    #[invariant]
    pub fn writer_agrees_storage_rev(&self) -> bool {
        self.storage.is_None() ==> self.writer.is_Some()
    }

    #[inductive(acquire_read_start)]
    fn acquire_read_start_inductive(pre: Self, post: Self) { }

    #[inductive(acquire_read_end)]
    fn acquire_read_end_inductive(pre: Self, post: Self) { }

    #[inductive(acquire_read_abandon)]
    fn acquire_read_abandon_inductive(pre: Self, post: Self) { }

    #[inductive(acquire_exc_start)]
    fn acquire_exc_start_inductive(pre: Self, post: Self) { }

    #[inductive(acquire_exc_end)]
    fn acquire_exc_end_inductive(pre: Self, post: Self) { }

    #[inductive(release_exc)]
    fn release_exc_inductive(pre: Self, post: Self, x: T) { }

    #[inductive(release_shared)]
    fn release_shared_inductive(pre: Self, post: Self, x: T) {
        assert(equal(pre.storage, Option::Some(x)));
    }
});

fn main() {}
","  use vstd::prelude::*;
        use verus_state_machines_macros::tokenized_state_machine;
#[verifier::verify]
pub struct T ;
        tokenized_state_machine!(RwLock {
           fields {
#[sharding(variable)]
        pub flags: (bool, nat),                
#[sharding(storage_option)]
        pub storage: Option<T>,                
#[sharding(option)]
        pub pending_writer: Option<()>,                
#[sharding(option)]
        pub writer: Option<()>,                
#[sharding(multiset)]
        pub pending_reader: Multiset<()>,                
#[sharding(multiset)]
        pub reader: Multiset<T>,     }
           transition!{
              acquire_read_start() {}
          }
           transition!{
              acquire_read_end() {}
          }
           transition!{
              acquire_read_abandon() {}
          }
           transition!{
              acquire_exc_start() {}
          }
           transition!{
              acquire_exc_end() {}
          }
           transition!{
              release_exc(x: T) {}
          }
                transition!{
              release_shared(x: T) {}
          }
#[invariant]
    pub fn exc_bit_matches(&self) -> bool {
              (if self.flags.0 {
     1 }
      else {
     0 as int }
     ) ==             (if self.pending_writer.is_Some() {
     1 }
      else {
     0 as int }
     ) as int             + (if self.writer.is_Some() {
     1 }
      else {
     0 as int }
     ) as int     }
#[invariant]
    pub fn count_matches(&self) -> bool {
              self.flags.1 == self.pending_reader.count(())             + self.reader.count(self.storage.get_Some_0())     }
#[invariant]
    pub fn reader_agrees_storage(&self) -> bool {
              forall |t: T| self.reader.count(t) > 0 ==>             equal(self.storage, Option::Some(t))     }
#[invariant]
    pub fn writer_agrees_storage(&self) -> bool {
              self.writer.is_Some() ==> self.storage.is_None()     }
#[invariant]
    pub fn writer_agrees_storage_rev(&self) -> bool {
              self.storage.is_None() ==> self.writer.is_Some()     }
#[inductive(acquire_read_start)]
    fn acquire_read_start_inductive(pre: Self, post: Self) {}
#[inductive(acquire_read_end)]
    fn acquire_read_end_inductive(pre: Self, post: Self) {}
#[inductive(acquire_read_abandon)]
    fn acquire_read_abandon_inductive(pre: Self, post: Self) {}
#[inductive(acquire_exc_start)]
    fn acquire_exc_start_inductive(pre: Self, post: Self) {}
#[inductive(acquire_exc_end)]
    fn acquire_exc_end_inductive(pre: Self, post: Self) {}
#[inductive(release_exc)]
    fn release_exc_inductive(pre: Self, post: Self, x: T) {}
#[inductive(release_shared)]
    fn release_shared_inductive(pre: Self, post: Self, x: T) {}
       }
       );
        fn main() {}
","[""// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse vstd::cell::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// TODO make T generic\n#[verifier::verify]\npub struct T {\n    t: u8,\n}\n\ntokenized_state_machine!(RwLock {\n    fields {\n        #[sharding(variable)]\n        pub flags: (bool, nat),\n\n        #[sharding(storage_option)]\n        pub storage: Option<T>,\n\n        #[sharding(option)]\n        pub pending_writer: Option<()>,\n\n        #[sharding(option)]\n        pub writer: Option<()>,\n\n        #[sharding(multiset)]\n        pub pending_reader: Multiset<()>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<T>,\n    }\n\n    init!{\n        initialize_empty() {\n            init flags = (true, 0);\n            init storage = Option::None;\n            init pending_writer = Option::None;\n            init writer = Option::Some(());\n            init pending_reader = Multiset::empty();\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    /// Increment the 'rc' counter, obtain a pending_reader\n    transition!{\n        acquire_read_start() {\n            update flags = (pre.flags.0, pre.flags.1 + 1);\n            add pending_reader += {()};\n        }\n    }\n\n    /// Exchange the pending_reader for a reader by checking\n    /// that the 'exc' bit is 0\n    transition!{\n        acquire_read_end() {\n            require(pre.flags.0 == false);\n\n            remove pending_reader -= {()};\n\n            birds_eye let x: T = pre.storage.get_Some_0();\n            add reader += {x};\n        }\n    }\n\n    /// Decrement the 'rc' counter, abandon the attempt to gain\n    /// the 'read' lock.\n    transition!{\n        acquire_read_abandon() {\n            remove pending_reader -= {()};\n            assert(pre.flags.1 >= 1);\n            update flags = (pre.flags.0, (pre.flags.1 - 1) as nat);\n        }\n    }\n\n    /// Atomically set 'exc' bit from 'false' to 'true'\n    /// Obtain a pending_writer\n    transition!{\n        acquire_exc_start() {\n            require(pre.flags.0 == false);\n            update flags = (true, pre.flags.1);\n            add pending_writer += Some(());\n        }\n    }\n\n    /// Finish obtaining the write lock by checking that 'rc' is 0.\n    /// Exchange the pending_writer for a writer and withdraw the\n    /// stored object.\n    transition!{\n        acquire_exc_end() {\n            require(pre.flags.1 == 0);\n\n            remove pending_writer -= Some(());\n\n            add writer += Some(());\n\n            birds_eye let x = pre.storage.get_Some_0();\n            withdraw storage -= Some(x);\n        }\n    }\n\n    /// Release the write-lock. Update the 'exc' bit back to 'false'.\n    /// Return the 'writer' and also deposit an object back into storage.\n    transition!{\n        release_exc(x: T) {\n            remove writer -= Some(());\n\n            update flags = (false, pre.flags.1);\n\n            deposit storage += Some(x);\n        }\n    }\n\n    /// Check that the 'reader' is actually a guard for the given object.\n    property!{\n        read_guard(x: T) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    /// Release the reader-lock. Decrement 'rc' and return the 'reader' object.\n    #[transition]\n    transition!{\n        release_shared(x: T) {\n            remove reader -= {x};\n\n            assert(pre.flags.1 >= 1) by {\n                //assert(pre.reader.count(x) >= 1);\n                assert(equal(pre.storage, Option::Some(x)));\n                //assert(equal(x, pre.storage.get_Some_0()));\n            };\n            update flags = (pre.flags.0, (pre.flags.1 - 1) as nat);\n        }\n    }\n\n    #[invariant]\n    pub fn exc_bit_matches(&self) -> bool {\n        (if self.flags.0 { 1 } else { 0 as int }) ==\n            (if self.pending_writer.is_Some() { 1 } else { 0 as int }) as int\n            + (if self.writer.is_Some() { 1 } else { 0 as int }) as int\n    }\n\n    #[invariant]\n    pub fn count_matches(&self) -> bool {\n        self.flags.1 == self.pending_reader.count(())\n            + self.reader.count(self.storage.get_Some_0())\n    }\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: T| self.reader.count(t) > 0 ==>\n            equal(self.storage, Option::Some(t))\n    }\n\n    #[invariant]\n    pub fn writer_agrees_storage(&self) -> bool {\n        self.writer.is_Some() ==> self.storage.is_None()\n    }\n\n    #[invariant]\n    pub fn writer_agrees_storage_rev(&self) -> bool {\n        self.storage.is_None() ==> self.writer.is_Some()\n    }\n\n    #[inductive(acquire_read_start)]\n    fn acquire_read_start_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_read_end)]\n    fn acquire_read_end_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_read_abandon)]\n    fn acquire_read_abandon_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_exc_start)]\n    fn acquire_exc_start_inductive(pre: Self, post: Self) { }\n\n    #[inductive(acquire_exc_end)]\n    fn acquire_exc_end_inductive(pre: Self, post: Self) { }\n\n    #[inductive(release_exc)]\n    fn release_exc_inductive(pre: Self, post: Self, x: T) { }\n\n    #[inductive(release_shared)]\n    fn release_shared_inductive(pre: Self, post: Self, x: T) {\n        assert(equal(pre.storage, Option::Some(x)));\n    }\n});\n\nfn main() {}\n"", 'use vstd;\nfn main() {}\n', '  use vstd::prelude::*;\n        use verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\npub struct T ;\n        tokenized_state_machine!(RwLock {\n           fields {\n#[sharding(variable)]\n        pub flags: (bool, nat),                \n#[sharding(storage_option)]\n        pub storage: Option<T>,                \n#[sharding(option)]\n        pub pending_writer: Option<()>,                \n#[sharding(option)]\n        pub writer: Option<()>,                \n#[sharding(multiset)]\n        pub pending_reader: Multiset<()>,                \n#[sharding(multiset)]\n        pub reader: Multiset<T>,     }\n           transition!{\n              acquire_read_start() {}\n          }\n           transition!{\n              acquire_read_end() {}\n          }\n           transition!{\n              acquire_read_abandon() {}\n          }\n           transition!{\n              acquire_exc_start() {}\n          }\n           transition!{\n              acquire_exc_end() {}\n          }\n           transition!{\n              release_exc(x: T) {}\n          }\n                transition!{\n              release_shared(x: T) {}\n          }\n#[invariant]\n    pub fn exc_bit_matches(&self) -> bool {\n              (if self.flags.0 {\n     1 }\n      else {\n     0 as int }\n     ) ==             (if self.pending_writer.is_Some() {\n     1 }\n      else {\n     0 as int }\n     ) as int             + (if self.writer.is_Some() {\n     1 }\n      else {\n     0 as int }\n     ) as int     }\n#[invariant]\n    pub fn count_matches(&self) -> bool {\n              self.flags.1 == self.pending_reader.count(())             + self.reader.count(self.storage.get_Some_0())     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n              forall |t: T| self.reader.count(t) > 0 ==>             equal(self.storage, Option::Some(t))     }\n#[invariant]\n    pub fn writer_agrees_storage(&self) -> bool {\n              self.writer.is_Some() ==> self.storage.is_None()     }\n#[invariant]\n    pub fn writer_agrees_storage_rev(&self) -> bool {\n              self.storage.is_None() ==> self.writer.is_Some()     }\n#[inductive(acquire_read_start)]\n    fn acquire_read_start_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_read_end)]\n    fn acquire_read_end_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_read_abandon)]\n    fn acquire_read_abandon_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_exc_start)]\n    fn acquire_exc_start_inductive(pre: Self, post: Self) {}\n#[inductive(acquire_exc_end)]\n    fn acquire_exc_end_inductive(pre: Self, post: Self) {}\n#[inductive(release_exc)]\n    fn release_exc_inductive(pre: Self, post: Self, x: T) {}\n#[inductive(release_shared)]\n    fn release_shared_inductive(pre: Self, post: Self, x: T) {}\n       }\n       );\n        fn main() {}\n', '  use vstd::prelude::*;\n         use verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\npub struct T ;\n         tokenized_state_machine!(RwLock {            fields { \n#[sharding(multiset)]\n        pub reader: Multiset<T>,     }            transition!{               acquire_read_start() {}           }            transition!{               acquire_read_end() {}           }            transition!{               acquire_read_abandon() {}           }            transition!{               acquire_exc_start() {}           }            transition!{               acquire_exc_end() {}           }            transition!{               release_exc(x: T) {}           }                 transition!{               release_shared(x: T) {}           } \n    fn release_shared_inductive(pre: Self, post: Self, x: T) {}        }\n        );\n         fn main() {}\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\nstruct T;\ntokenized_state_machine !(RwLock{fields{\n#[sharding(multiset)]\n  pub reader : Multiset< T >}});\nfn main() {}\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n#[verifier::verify]\nstruct T;\ntokenized_state_machine !(RwLock{fields{\n}});\nfn main() {}\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n#[verifier::a]\n \ntokenized_state_machine !(b{fields{}});\nfn main() {}\n', 'use vstd::prelude::*;\nuse verus_state_machines_macros::tokenized_state_machine;\ntokenized_state_machine !(b{fields{}});\nfn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/counting_to_2.rs,209,63,0.3014354066985646,675.662,True,0.7999999999999999,False,"['verus_builtin::', 'verus_builtin_macros::', 'verus_state_machines_macros::tokenized_state_machine', 'std::sync::Arc', 'vstd::atomic_ghost::', 'vstd::modes::', 'vstd::prelude::', 'vstd::thread::', 'vstd::']",True,,,,,,"#![allow(unused_imports)]

// ANCHOR: full
use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::tokenized_state_machine;
use std::sync::Arc;
use vstd::atomic_ghost::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::thread::*;
use vstd::{pervasive::*, *};

verus! {

tokenized_state_machine!(
    X {
        fields {
            #[sharding(variable)]
            pub counter: int,

            #[sharding(variable)]
            pub inc_a: bool,

            #[sharding(variable)]
            pub inc_b: bool,
        }

        // ANCHOR: inv
        #[invariant]
        pub fn main_inv(&self) -> bool {
            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })
        }
        // ANCHOR_END: inv

        init!{
            initialize() {
                init counter = 0;
                init inc_a = false;
                init inc_b = false;
            }
        }

        transition!{
            tr_inc_a() {
                require(!pre.inc_a);
                update counter = pre.counter + 1;
                update inc_a = true;
            }
        }

        transition!{
            tr_inc_b() {
                require(!pre.inc_b);
                update counter = pre.counter + 1;
                update inc_b = true;
            }
        }

        property!{
            increment_will_not_overflow_u32() {
                assert 0 <= pre.counter < 0xffff_ffff;
            }
        }

        property!{
            finalize() {
                require(pre.inc_a);
                require(pre.inc_b);
                assert pre.counter == 2;
            }
        }

        // ANCHOR: inv_proof
        #[inductive(tr_inc_a)]
        fn tr_inc_a_preserves(pre: Self, post: Self) {
        }

        #[inductive(tr_inc_b)]
        fn tr_inc_b_preserves(pre: Self, post: Self) {
        }

        #[inductive(initialize)]
        fn initialize_inv(post: Self) {
        }
        // ANCHOR_END: inv_proof
    }
);

// ANCHOR: global_struct
struct_with_invariants!{
    pub struct Global {
        // An AtomicU32 that matches with the `counter` field of the ghost protocol.
        pub atomic: AtomicU32<_, X::counter, _>,

        // The instance of the protocol that the `counter` is part of.
        pub instance: Tracked<X::Instance>,
    }

    spec fn wf(&self) -> bool {
        // Specify the invariant that should hold on the AtomicU32<X::counter>.
        // Specifically the ghost token (`g`) should have
        // the same value as the atomic (`v`).
        // Furthermore, the ghost token should have the appropriate `instance`.
        invariant on atomic with (instance) is (v: u32, g: X::counter) {
            g.instance_id() == instance@.id()
            && g.value() == v as int
        }
    }
}
// ANCHOR_END: global_struct


fn main() {
    // Initialize protocol
    let tracked (
        Tracked(instance),
        Tracked(counter_token),
        Tracked(inc_a_token),
        Tracked(inc_b_token),
    ) = X::Instance::initialize();
    // Initialize the counter
    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());
    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));
    let global = Global { atomic, instance: Tracked(instance.clone()) };
    let global_arc = Arc::new(global);

    // Spawn threads

    // Thread 1
    let global_arc1 = global_arc.clone();
    let join_handle1 = spawn(
        (move || -> (new_token: Tracked<X::inc_a>)
            ensures
                new_token@.instance_id() == instance.id() && new_token@.value() == true,
            {
                // `inc_a_token` is moved into the closure
                let tracked mut token = inc_a_token;
                let globals = &*global_arc1;
                let _ =
                    atomic_with_ghost!(&globals.atomic => fetch_add(1);
                        ghost c => {
                            globals.instance.borrow().increment_will_not_overflow_u32(&c);
                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment
                        }
                    );
                Tracked(token)
            }),
    );

    // Thread 2
    let global_arc2 = global_arc.clone();
    let join_handle2 = spawn(
        (move || -> (new_token: Tracked<X::inc_b>)
            ensures
                new_token@.instance_id() == instance.id() && new_token@.value() == true,
            {
                // `inc_b_token` is moved into the closure
                let tracked mut token = inc_b_token;
                let globals = &*global_arc2;
                let _ =
                    atomic_with_ghost!(&globals.atomic => fetch_add(1);
                        ghost c => {
                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);
                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment
                        }
                    );
                Tracked(token)
            }),
    );

    // Join threads
    let tracked inc_a_token;
    match join_handle1.join() {
        Result::Ok(token) => {
            proof {
                inc_a_token = token.get();
            }
        },
        _ => {
            return ;
        },
    };
    let tracked inc_b_token;
    match join_handle2.join() {
        Result::Ok(token) => {
            proof {
                inc_b_token = token.get();
            }
        },
        _ => {
            return ;
        },
    };

    // Join threads, load the atomic again
    let global = &*global_arc;
    let x =
        atomic_with_ghost!(&global.atomic => load();
        ghost c => {
            instance.finalize(&c, &inc_a_token, &inc_b_token);
        }
    );

    assert(x == 2);
}

} // verus!
// ANCHOR_END: full
"," use verus_state_machines_macros::tokenized_state_machine;
        use std::sync::Arc;
        use vstd::atomic_ghost::*;
        use vstd::prelude::*;
        use vstd::thread::*;
        verus! {
       tokenized_state_machine!(     X {
              fields {
#[sharding(variable)]
            pub counter: int,                    
#[sharding(variable)]
            pub inc_a: bool,                    
#[sharding(variable)]
            pub inc_b: bool,         }
#[invariant]
        pub fn main_inv(&self) -> bool {
                 self.counter == (if self.inc_a {
    1 as int }
     else {
    0 }
    ) + (if self.inc_b {
    1 as int }
     else {
    0 }
    )         }
              init!{
                 initialize() {
                    init counter = 0;
                    init inc_a = false;
                    init inc_b = false;
                }
             }
              transition!{
                 tr_inc_a() {}
             }
              transition!{
                 tr_inc_b() {}
             }
              property!{
                 increment_will_not_overflow_u32() {}
             }
              property!{
                 finalize() {}
             }
#[inductive(tr_inc_a)]
        fn tr_inc_a_preserves(pre: Self, post: Self) {}
#[inductive(tr_inc_b)]
        fn tr_inc_b_preserves(pre: Self, post: Self) {}
#[inductive(initialize)]
        fn initialize_inv(post: Self) {
             }
          }
       );
       struct_with_invariants!{
          pub struct Global {
             pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }
          spec fn wf(&self) -> bool {
             invariant on atomic with (instance) is (v: u32, g: X::counter) {
                g.instance_id() == instance@.id()             && g.value() == v as int         }
         }
      }
       fn main() ;
       }
","['#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        // ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n        // ANCHOR_END: inv\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        // ANCHOR: inv_proof\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n        // ANCHOR_END: inv_proof\n    }\n);\n\n// ANCHOR: global_struct\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the invariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: global_struct\n\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_a_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_b_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n    assert(x == 2);\n}\n\n} // verus!\n// ANCHOR_END: full\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n        use std::sync::Arc;\n        use vstd::atomic_ghost::*;\n        use vstd::prelude::*;\n        use vstd::thread::*;\n        verus! {\n       tokenized_state_machine!(     X {\n              fields {\n#[sharding(variable)]\n            pub counter: int,                    \n#[sharding(variable)]\n            pub inc_a: bool,                    \n#[sharding(variable)]\n            pub inc_b: bool,         }\n#[invariant]\n        pub fn main_inv(&self) -> bool {\n                 self.counter == (if self.inc_a {\n    1 as int }\n     else {\n    0 }\n    ) + (if self.inc_b {\n    1 as int }\n     else {\n    0 }\n    )         }\n              init!{\n                 initialize() {\n                    init counter = 0;\n                    init inc_a = false;\n                    init inc_b = false;\n                }\n             }\n              transition!{\n                 tr_inc_a() {}\n             }\n              transition!{\n                 tr_inc_b() {}\n             }\n              property!{\n                 increment_will_not_overflow_u32() {}\n             }\n              property!{\n                 finalize() {}\n             }\n#[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {}\n#[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {}\n#[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n             }\n          }\n       );\n       struct_with_invariants!{\n          pub struct Global {\n             pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }\n          spec fn wf(&self) -> bool {\n             invariant on atomic with (instance) is (v: u32, g: X::counter) {\n                g.instance_id() == instance@.id()             && g.value() == v as int         }\n         }\n      }\n       fn main() ;\n       }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n          use vstd::prelude::*;\n          verus! {\n        tokenized_state_machine!(     X {               fields {  \n#[sharding(variable)]\n            pub counter: int,                      \n#[sharding(variable)]\n            pub inc_a: bool,                      \n#[sharding(variable)]\n            pub inc_b: bool,         }  \n#[invariant]\n        pub fn main_inv(&self) -> bool {                  self.counter == (if self.inc_a {     1 as int }      else {     0 }     ) + (if self.inc_b {     1 as int }      else {     0 }     )         }               init!{                  initialize() {                     init counter = 0;                     init inc_a = false;                     init inc_b = false;                 }              }               transition!{                  tr_inc_a() {}              }               transition!{                  tr_inc_b() {}              }               property!{                  increment_will_not_overflow_u32() {}              }               property!{                  finalize() {}              }  \n#[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {}  \n#[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {}  \n#[inductive(initialize)]\n        fn initialize_inv(post: Self) {}           }\n        );\n        fn main() ;\n        }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(     X {\n                    fields {\n#[sharding(variable)]\n            pub counter: int,\n#[sharding(variable)]\n            pub inc_a: bool,\n#[sharding(variable)]\n            pub inc_b: bool,         }\n                    init!{\n                      initialize() {\n                        init counter = 0;\n                        init inc_a = false;\n                        init inc_b = false;\n}\n}\nfn initialize_inv(post : Self) {}\n}\n              );\n              fn main();\n              }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(     a {\n                    fields {\n#[sharding(variable)]\n            pub b: int,\n#[sharding(variable)]\n            pub c: bool,\n#[sharding(variable)]\n            pub d: bool}\n                    init!{\n                      initialize() {\n                        init b = 0;\n                        init c = false;\n                        init d = false;\n}\n}\n}\n              );\n              fn main();\n              }\n', 'use verus_state_machines_macros::tokenized_state_machine;\n     use vstd::prelude::*;\n     verus !{\n                  tokenized_state_machine!(     a {\n                       fields {\n#[sharding(variable)]\n            pub b: int,     \n#[sharding(variable)]\n            pub c: bool,     \n#[sharding(variable)]\n            pub d: bool}\n   }\n                  );\n                  fn main();\n                  }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a{fields{\n#[sharding(variable)]\n    pub b : int,\n#[sharding(variable)]\n    pub c : bool,\n#[sharding(variable)]\n    pub d : bool\n  }});\n  fn main();\n}\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a{fields{\n}});\n  fn main();\n}\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a{fields{}});\n  fn main();\n}\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  fn main();\n}\n', 'use verus_state_machines_macros;\n use vstd::prelude::*;\n verus !{   fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/counting_to_n.rs,224,79,0.35267857142857145,370.96,True,0.9999999999999999,False,"['verus_state_machines_macros::tokenized_state_machine', 'std::sync::Arc', 'vstd::atomic_ghost::', 'vstd::modes::', 'vstd::prelude::', 'vstd::thread::', 'vstd::']",True,,,True,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#![allow(unused_imports)]

// ANCHOR: full
use verus_state_machines_macros::tokenized_state_machine;
use std::sync::Arc;
use vstd::atomic_ghost::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::thread::*;
use vstd::{pervasive::*, prelude::*, *};

verus! {

// ANCHOR: fields
tokenized_state_machine!{
    X {
        fields {
            #[sharding(constant)]
            pub num_threads: nat,

            #[sharding(variable)]
            pub counter: int,

            #[sharding(count)]
            pub unstamped_tickets: nat,

            #[sharding(count)]
            pub stamped_tickets: nat,
        }
// ANCHOR_END: fields

// ANCHOR: inv
        #[invariant]
        pub fn main_inv(&self) -> bool {
            self.counter == self.stamped_tickets
            && self.stamped_tickets + self.unstamped_tickets == self.num_threads
        }
// ANCHOR_END: inv

// ANCHOR: init
        init!{
            initialize(num_threads: nat) {
                init num_threads = num_threads;
                init counter = 0;
                init unstamped_tickets = num_threads;
                init stamped_tickets = 0;
            }
        }
// ANCHOR_END: init

// ANCHOR: tr_inc
        transition!{
            tr_inc() {
                // Equivalent to:
                //    require(pre.unstamped_tickets >= 1);
                //    update unstampted_tickets = pre.unstamped_tickets - 1
                // (In any `remove` statement, the `>=` condition is always implicit.)
                remove unstamped_tickets -= (1);

                // Equivalent to:
                //    update stamped_tickets = pre.stamped_tickets + 1
                add stamped_tickets += (1);

                // These still use ordinary 'update' syntax, because `pre.counter`
                // uses the `variable` sharding strategy.
                assert(pre.counter < pre.num_threads);
                update counter = pre.counter + 1;
            }
        }
// ANCHOR_END: tr_inc

// ANCHOR: finalize
        property!{
            finalize() {
                // Equivalent to:
                //    require(pre.unstamped_tickets >= pre.num_threads);
                have stamped_tickets >= (pre.num_threads);

                assert(pre.counter == pre.num_threads);
            }
        }
// ANCHOR_END: finalize

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, num_threads: nat) { }

        #[inductive(tr_inc)]
        fn tr_inc_preserves(pre: Self, post: Self) {
        }
    }
}

struct_with_invariants!{
    pub struct Global {
        pub atomic: AtomicU32<_, X::counter, _>,
        pub instance: Tracked<X::Instance>,
    }

    spec fn wf(&self) -> bool {
        invariant on atomic with (instance) is (v: u32, g: X::counter) {
            g.instance_id() == instance@.id()
            && g.value() == v as int
        }

        predicate {
            self.instance@.num_threads() < 0x100000000
        }
    }
}

fn do_count(num_threads: u32) {
    // Initialize protocol
    let tracked (
        Tracked(instance),
        Tracked(counter_token),
        Tracked(unstamped_tokens),
        Tracked(stamped_tokens),
    ) = X::Instance::initialize(num_threads as nat);
    // Initialize the counter
    let tracked_instance = Tracked(instance.clone());
    let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));
    let global = Global { atomic, instance: tracked_instance };
    let global_arc = Arc::new(global);

    // ANCHOR: loop_spawn
    // Spawn threads
    let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();
    let mut i = 0;
    while i < num_threads
        invariant
            0 <= i,
            i <= num_threads,
            unstamped_tokens.count() + i == num_threads,
            unstamped_tokens.instance_id() == instance.id(),
            join_handles@.len() == i as int,
            forall|j: int, ret|
                0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>
                    ret@.instance_id() == instance.id()
                    && ret@.count() == 1,
            (*global_arc).wf(),
            (*global_arc).instance@ === instance,
    {
        let tracked unstamped_token;
        proof {
            unstamped_token = unstamped_tokens.split(1 as nat);
        }
        let global_arc = global_arc.clone();
        let join_handle = spawn(
            (move || -> (new_token: Tracked<X::stamped_tickets>)
                ensures
                    new_token@.instance_id() == instance.id(),
                    new_token@.count() == 1,
                {
                    let tracked unstamped_token = unstamped_token;
                    let globals = &*global_arc;
                    let tracked stamped_token;
                    let _ =
                        atomic_with_ghost!(
                            &global_arc.atomic => fetch_add(1);
                            update prev -> next;
                            returning ret;
                            ghost c => {
                                stamped_token =
                                    global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);
                            }
                        );
                    Tracked(stamped_token)
                }),
        );
        join_handles.push(join_handle);
        i = i + 1;
    }
    // ANCHOR_END: loop_spawn
    // ANCHOR: loop_join
    // Join threads

    let mut i = 0;
    while i < num_threads
        invariant
            0 <= i,
            i <= num_threads,
            stamped_tokens.count() == i,
            stamped_tokens.instance_id() == instance.id(),
            join_handles@.len() as int + i as int == num_threads,
            forall|j: int, ret|
                0 <= j && j < join_handles@.len() ==>
                    #[trigger] join_handles@.index(j).predicate(ret) ==>
                        ret@.instance_id() == instance.id()
                        && ret@.count() == 1,
            (*global_arc).wf(),
            (*global_arc).instance@ === instance,
    {
        let join_handle = join_handles.pop().unwrap();
        match join_handle.join() {
            Result::Ok(token) => {
                proof {
                    stamped_tokens.join(token.get());
                }
            },
            _ => {
                return ;
            },
        };
        i = i + 1;
    }
    // ANCHOR_END: loop_join

    let global = &*global_arc;
    let x =
        atomic_with_ghost!(&global.atomic => load();
        ghost c => {
            instance.finalize(&c, &stamped_tokens);
        }
    );
    assert(x == num_threads);
}

fn main() {
    do_count(20);
}

} // verus!
// ANCHOR_END: full
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use verus_state_machines_macros::tokenized_state_machine;
     use std::sync::Arc;
     use vstd::atomic_ghost::*;
     use vstd::prelude::*;
     use vstd::thread::*;
     verus! {
    tokenized_state_machine!{
       X {
          fields {
#[sharding(constant)]
            pub num_threads: nat,                 
#[sharding(variable)]
            pub counter: int,                 
#[sharding(count)]
            pub unstamped_tickets: nat,                 
#[sharding(count)]
            pub stamped_tickets: nat,         }
#[invariant]
        pub fn main_inv(&self) -> bool {
             self.counter == self.stamped_tickets             && self.stamped_tickets + self.unstamped_tickets == self.num_threads         }
          init!{
             initialize(num_threads: nat) {                 init num_threads = num_threads;                 init counter = 0;                 init unstamped_tickets = num_threads;                 init stamped_tickets = 0;             }
         }
          transition!{
             tr_inc() {                 remove unstamped_tickets -= (1);                 add stamped_tickets += (1);                 assert(pre.counter < pre.num_threads);                 update counter = pre.counter + 1;             }
         }
#[inductive(initialize)]
        fn initialize_inductive(post: Self, num_threads: nat) {
 }
#[inductive(tr_inc)]
        fn tr_inc_preserves(pre: Self, post: Self) {
         }
      }
   }
    struct_with_invariants!{
       pub struct Global {
          pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }
       spec fn wf(&self) -> bool {
          invariant on atomic with (instance) is (v: u32, g: X::counter) {
             g.instance_id() == instance@.id()             && g.value() == v as int         }
          predicate {
             self.instance@.num_threads() < 0x100000000         }
      }
   }
    fn do_count(num_threads: u32) {
       let tracked (         Tracked(instance),         Tracked(counter_token),         Tracked(unstamped_tokens),         Tracked(stamped_tokens),     ) = X::Instance::initialize(num_threads as nat);
       let tracked_instance = Tracked(instance.clone());
       let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));
       let global = Global {
  atomic, instance: tracked_instance };
       let global_arc = Arc::new(global);
       let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();
       let mut i = 0;
       while i < num_threads         invariant             0 <= i,             i <= num_threads,             unstamped_tokens.count() + i == num_threads,             unstamped_tokens.instance_id() == instance.id(),             join_handles@.len() == i as int,             forall|j: int, ret|                 0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>                     ret@.instance_id() == instance.id()                     && ret@.count() == 1,             (*global_arc).wf(),             (*global_arc).instance@ === instance,     {
          let tracked unstamped_token;
          proof {
             unstamped_token = unstamped_tokens.split(1 as nat);
         }
          let global_arc = global_arc.clone();
          let join_handle = spawn(             (move || -> (new_token: Tracked<X::stamped_tickets>)                 ensures                     new_token@.instance_id() == instance.id(),                     new_token@.count() == 1,                 {
                     let tracked stamped_token;
                     let _ =                         atomic_with_ghost!(                             &global_arc.atomic => fetch_add(1);
                             ghost c => {                                 stamped_token =                                     global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);                             }
                         );
                     Tracked(stamped_token)                 }
 ),         );
          join_handles.push(join_handle);
          i = i + 1;
      }
       let global = &*global_arc;
       let x =         atomic_with_ghost!(&global.atomic => load();
           ghost c => {
          }
       );
   }
    fn main() {
   }
    }
","[""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!{\n    X {\n        fields {\n            #[sharding(constant)]\n            pub num_threads: nat,\n\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(count)]\n            pub unstamped_tickets: nat,\n\n            #[sharding(count)]\n            pub stamped_tickets: nat,\n        }\n// ANCHOR_END: fields\n\n// ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == self.stamped_tickets\n            && self.stamped_tickets + self.unstamped_tickets == self.num_threads\n        }\n// ANCHOR_END: inv\n\n// ANCHOR: init\n        init!{\n            initialize(num_threads: nat) {\n                init num_threads = num_threads;\n                init counter = 0;\n                init unstamped_tickets = num_threads;\n                init stamped_tickets = 0;\n            }\n        }\n// ANCHOR_END: init\n\n// ANCHOR: tr_inc\n        transition!{\n            tr_inc() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= 1);\n                //    update unstampted_tickets = pre.unstamped_tickets - 1\n                // (In any `remove` statement, the `>=` condition is always implicit.)\n                remove unstamped_tickets -= (1);\n\n                // Equivalent to:\n                //    update stamped_tickets = pre.stamped_tickets + 1\n                add stamped_tickets += (1);\n\n                // These still use ordinary 'update' syntax, because `pre.counter`\n                // uses the `variable` sharding strategy.\n                assert(pre.counter < pre.num_threads);\n                update counter = pre.counter + 1;\n            }\n        }\n// ANCHOR_END: tr_inc\n\n// ANCHOR: finalize\n        property!{\n            finalize() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= pre.num_threads);\n                have stamped_tickets >= (pre.num_threads);\n\n                assert(pre.counter == pre.num_threads);\n            }\n        }\n// ANCHOR_END: finalize\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) { }\n\n        #[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct Global {\n        pub atomic: AtomicU32<_, X::counter, _>,\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n\n        predicate {\n            self.instance@.num_threads() < 0x100000000\n        }\n    }\n}\n\nfn do_count(num_threads: u32) {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(unstamped_tokens),\n        Tracked(stamped_tokens),\n    ) = X::Instance::initialize(num_threads as nat);\n    // Initialize the counter\n    let tracked_instance = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: tracked_instance };\n    let global_arc = Arc::new(global);\n\n    // ANCHOR: loop_spawn\n    // Spawn threads\n    let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();\n    let mut i = 0;\n    while i < num_threads\n        invariant\n            0 <= i,\n            i <= num_threads,\n            unstamped_tokens.count() + i == num_threads,\n            unstamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() == i as int,\n            forall|j: int, ret|\n                0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>\n                    ret@.instance_id() == instance.id()\n                    && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance,\n    {\n        let tracked unstamped_token;\n        proof {\n            unstamped_token = unstamped_tokens.split(1 as nat);\n        }\n        let global_arc = global_arc.clone();\n        let join_handle = spawn(\n            (move || -> (new_token: Tracked<X::stamped_tickets>)\n                ensures\n                    new_token@.instance_id() == instance.id(),\n                    new_token@.count() == 1,\n                {\n                    let tracked unstamped_token = unstamped_token;\n                    let globals = &*global_arc;\n                    let tracked stamped_token;\n                    let _ =\n                        atomic_with_ghost!(\n                            &global_arc.atomic => fetch_add(1);\n                            update prev -> next;\n                            returning ret;\n                            ghost c => {\n                                stamped_token =\n                                    global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);\n                            }\n                        );\n                    Tracked(stamped_token)\n                }),\n        );\n        join_handles.push(join_handle);\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_spawn\n    // ANCHOR: loop_join\n    // Join threads\n\n    let mut i = 0;\n    while i < num_threads\n        invariant\n            0 <= i,\n            i <= num_threads,\n            stamped_tokens.count() == i,\n            stamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() as int + i as int == num_threads,\n            forall|j: int, ret|\n                0 <= j && j < join_handles@.len() ==>\n                    #[trigger] join_handles@.index(j).predicate(ret) ==>\n                        ret@.instance_id() == instance.id()\n                        && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance,\n    {\n        let join_handle = join_handles.pop().unwrap();\n        match join_handle.join() {\n            Result::Ok(token) => {\n                proof {\n                    stamped_tokens.join(token.get());\n                }\n            },\n            _ => {\n                return ;\n            },\n        };\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_join\n\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &stamped_tokens);\n        }\n    );\n    assert(x == num_threads);\n}\n\nfn main() {\n    do_count(20);\n}\n\n} // verus!\n// ANCHOR_END: full\n"", 'use vstd::prelude::*;\nverus !{ fn main(); }\n', '#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_state_machines_macros::tokenized_state_machine;\n     use std::sync::Arc;\n     use vstd::atomic_ghost::*;\n     use vstd::prelude::*;\n     use vstd::thread::*;\n     verus! {\n    tokenized_state_machine!{\n       X {\n          fields {\n#[sharding(constant)]\n            pub num_threads: nat,                 \n#[sharding(variable)]\n            pub counter: int,                 \n#[sharding(count)]\n            pub unstamped_tickets: nat,                 \n#[sharding(count)]\n            pub stamped_tickets: nat,         }\n#[invariant]\n        pub fn main_inv(&self) -> bool {\n             self.counter == self.stamped_tickets             && self.stamped_tickets + self.unstamped_tickets == self.num_threads         }\n          init!{\n             initialize(num_threads: nat) {                 init num_threads = num_threads;                 init counter = 0;                 init unstamped_tickets = num_threads;                 init stamped_tickets = 0;             }\n         }\n          transition!{\n             tr_inc() {                 remove unstamped_tickets -= (1);                 add stamped_tickets += (1);                 assert(pre.counter < pre.num_threads);                 update counter = pre.counter + 1;             }\n         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) {\n }\n#[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n         }\n      }\n   }\n    struct_with_invariants!{\n       pub struct Global {\n          pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }\n       spec fn wf(&self) -> bool {\n          invariant on atomic with (instance) is (v: u32, g: X::counter) {\n             g.instance_id() == instance@.id()             && g.value() == v as int         }\n          predicate {\n             self.instance@.num_threads() < 0x100000000         }\n      }\n   }\n    fn do_count(num_threads: u32) {\n       let tracked (         Tracked(instance),         Tracked(counter_token),         Tracked(unstamped_tokens),         Tracked(stamped_tokens),     ) = X::Instance::initialize(num_threads as nat);\n       let tracked_instance = Tracked(instance.clone());\n       let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));\n       let global = Global {\n  atomic, instance: tracked_instance };\n       let global_arc = Arc::new(global);\n       let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();\n       let mut i = 0;\n       while i < num_threads         invariant             0 <= i,             i <= num_threads,             unstamped_tokens.count() + i == num_threads,             unstamped_tokens.instance_id() == instance.id(),             join_handles@.len() == i as int,             forall|j: int, ret|                 0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>                     ret@.instance_id() == instance.id()                     && ret@.count() == 1,             (*global_arc).wf(),             (*global_arc).instance@ === instance,     {\n          let tracked unstamped_token;\n          proof {\n             unstamped_token = unstamped_tokens.split(1 as nat);\n         }\n          let global_arc = global_arc.clone();\n          let join_handle = spawn(             (move || -> (new_token: Tracked<X::stamped_tickets>)                 ensures                     new_token@.instance_id() == instance.id(),                     new_token@.count() == 1,                 {\n                     let tracked stamped_token;\n                     let _ =                         atomic_with_ghost!(                             &global_arc.atomic => fetch_add(1);\n                             ghost c => {                                 stamped_token =                                     global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);                             }\n                         );\n                     Tracked(stamped_token)                 }\n ),         );\n          join_handles.push(join_handle);\n          i = i + 1;\n      }\n       let global = &*global_arc;\n       let x =         atomic_with_ghost!(&global.atomic => load();\n           ghost c => {\n          }\n       );\n   }\n    fn main() {\n   }\n    }\n', '#!\nuse verus_state_machines_macros::tokenized_state_machine;\n        use std::sync::Arc;\n        use vstd::atomic_ghost::*;\n        use vstd::prelude::*;\n        use vstd::thread::*;\n        verus! {\n       tokenized_state_machine!{\n          X {\n             fields {\n#[sharding(constant)]\n            pub num_threads: nat,                    \n#[sharding(variable)]\n            pub counter: int,                    \n#[sharding(count)]\n            pub unstamped_tickets: nat,                    \n#[sharding(count)]\n            pub stamped_tickets: nat,         }\n#[invariant]\n        pub fn main_inv(&self) -> bool {\n                self.counter == self.stamped_tickets             && self.stamped_tickets + self.unstamped_tickets == self.num_threads         }\n             init!{\n                initialize(num_threads: nat) {\n                   init num_threads = num_threads;\n                   init counter = 0;\n                   init unstamped_tickets = num_threads;\n                   init stamped_tickets = 0;\n               }\n            }\n             transition!{\n                tr_inc() {}\n            }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) {}\n#[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {}\n         }\n      }\n       struct_with_invariants!{\n          pub struct Global {\n             pub atomic: AtomicU32<_, X::counter, _>,         pub instance: Tracked<X::Instance>,     }\n          spec fn wf(&self) -> bool {\n             invariant on atomic with (instance) is (v: u32, g: X::counter) {\n                g.instance_id() == instance@.id()             && g.value() == v as int         }\n             predicate {\n                self.instance@.num_threads() < 0x100000000         }\n         }\n      }\n       fn do_count() ;\n       fn main() ;\n       }\n', 'use verus_state_machines_macros::tokenized_state_machine;\n             use vstd::prelude::*;\n             verus! {\n           tokenized_state_machine!{\n             X {\n               fields {\n#[sharding(constant)]\n            pub stamped_tickets: nat,         }\n           }\n         }\n           fn main() ;\n           }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !{\n    X {\n      fields {\n#[sharding(constant)]\n        pub stamped_tickets : nat}\n    }\n  }\n  fn main();\n}\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !{\n    X {\n      fields {\n}\n    }\n  }\n  fn main();\n}\n', '  use vstd::prelude::*;\n    verus !{\n     fn main();\n   }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/counting_to_n_atomic.rs,62,14,0.22580645161290322,215.145,True,0.7,False,"['verus_builtin::', 'verus_builtin_macros::', 'verus_state_machines_macros::state_machine', 'vstd::']",True,,,,,,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::state_machine;
use vstd::{pervasive::*, *};

// ANCHOR: main
state_machine! {
    X {
        fields {
            pub num_threads: nat,
            pub counter: int,
            pub unstamped_tickets: nat,
            pub stamped_tickets: nat,
        }

        #[invariant]
        pub fn main_inv(&self) -> bool {
            self.counter == self.stamped_tickets
            && self.stamped_tickets + self.unstamped_tickets == self.num_threads
        }

        init!{
            initialize(num_threads: nat) {
                init num_threads = num_threads;
                init counter = 0;
                init unstamped_tickets = num_threads;
                init stamped_tickets = 0;
            }
        }

        transition!{
            tr_inc() {
                // Replace a single unstamped ticket with a stamped ticket
                require(pre.unstamped_tickets >= 1);
                update unstamped_tickets = (pre.unstamped_tickets - 1) as nat;
                update stamped_tickets = pre.stamped_tickets + 1;

                assert(pre.counter < pre.num_threads);
                update counter = pre.counter + 1;
            }
        }

        property!{
            finalize() {
                require(pre.stamped_tickets >= pre.num_threads);
                assert(pre.counter == pre.num_threads);
            }
        }
// ANCHOR_END: main

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, num_threads: nat) { }

        #[inductive(tr_inc)]
        fn tr_inc_preserves(pre: Self, post: Self) {
        }
    }
}

fn main() {}
","use verus_builtin::*;
use verus_state_machines_macros::state_machine;
state_machine !{
  X {
    fields {
      pub num_threads : nat,
                        pub counter : int,
                                      pub unstamped_tickets
          : nat,
            pub stamped_tickets : nat,
    }
  }
}
fn main() {}
","['// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::state_machine;\nuse vstd::{pervasive::*, *};\n\n// ANCHOR: main\nstate_machine! {\n    X {\n        fields {\n            pub num_threads: nat,\n            pub counter: int,\n            pub unstamped_tickets: nat,\n            pub stamped_tickets: nat,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == self.stamped_tickets\n            && self.stamped_tickets + self.unstamped_tickets == self.num_threads\n        }\n\n        init!{\n            initialize(num_threads: nat) {\n                init num_threads = num_threads;\n                init counter = 0;\n                init unstamped_tickets = num_threads;\n                init stamped_tickets = 0;\n            }\n        }\n\n        transition!{\n            tr_inc() {\n                // Replace a single unstamped ticket with a stamped ticket\n                require(pre.unstamped_tickets >= 1);\n                update unstamped_tickets = (pre.unstamped_tickets - 1) as nat;\n                update stamped_tickets = pre.stamped_tickets + 1;\n\n                assert(pre.counter < pre.num_threads);\n                update counter = pre.counter + 1;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.stamped_tickets >= pre.num_threads);\n                assert(pre.counter == pre.num_threads);\n            }\n        }\n// ANCHOR_END: main\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) { }\n\n        #[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n        }\n    }\n}\n\nfn main() {}\n', 'use verus_state_machines_macros::state_machine;\nstate_machine !{\n  a {\n    fields {}\n  }\n}\nfn main() {}\n', 'use verus_builtin::*;\nuse verus_state_machines_macros::state_machine;\nstate_machine !{\n  X {\n    fields {\n      pub num_threads : nat,\n                        pub counter : int,\n                                      pub unstamped_tickets\n          : nat,\n            pub stamped_tickets : nat,\n    }\n  }\n}\nfn main() {}\n', 'use verus_state_machines_macros::state_machine;\nstate_machine !{\n  X {\n    fields {\n      }\n  }\n}\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/pcell_example.rs,58,58,1.0,122.557,True,0.7999999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::modes::', 'vstd::prelude::', 'vstd::']",True,,,,,,"// rust_verify/tests/example.rs
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::{cell::*, pervasive::*};

verus! {

// ANCHOR: example
fn main() {
    // Construct a new pcell and obtain the permission for it.
    let (pcell, Tracked(mut perm)) = PCell::<u64>::empty();

    // Initially, cell is unitialized, and the `perm` token
    // represents that as the value `MemContents::Uninit`.
    // The meaning of the permission token is given by its _view_, here `perm@`.
    //
    // The expression `pcell_opt![ pcell.id() => MemContents::Uninit ]` can be read as roughly,
    // ""the cell with value pcell.id() is uninitialized"".
    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);

    // The above could also be written by accessing the fields of the
    // `PointsToData` struct:
    assert(perm.id() === pcell.id());
    assert(perm.mem_contents() === MemContents::Uninit);

    // We can write a value to the pcell (thus initializing it).
    // This only requires an `&` reference to the PCell, but it does
    // mutate the `perm` token.
    pcell.put(Tracked(&mut perm), 5);

    // Having written the value, this is reflected in the token:
    assert(perm@ === pcell_points![ pcell.id() => MemContents::Init(5) ]);

    // We can take the value back out:
    let x = pcell.take(Tracked(&mut perm));

    // Which leaves it uninitialized again:
    assert(x == 5);
    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);
}
// ANCHOR_END: example

} // verus!
/*
// After erasure, this looks more like:

// ANCHOR: erased
fn main() {
  let pcell = PCell::<u64>::empty();
  pcell.put(5);
  let x = pcell.take();
}
// ANCHOR_END: erased
*/
","// rust_verify/tests/example.rs
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::{cell::*, pervasive::*};

verus! {

// ANCHOR: example
fn main() {
    // Construct a new pcell and obtain the permission for it.
    let (pcell, Tracked(mut perm)) = PCell::<u64>::empty();

    // Initially, cell is unitialized, and the `perm` token
    // represents that as the value `MemContents::Uninit`.
    // The meaning of the permission token is given by its _view_, here `perm@`.
    //
    // The expression `pcell_opt![ pcell.id() => MemContents::Uninit ]` can be read as roughly,
    // ""the cell with value pcell.id() is uninitialized"".
    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);

    // The above could also be written by accessing the fields of the
    // `PointsToData` struct:
    assert(perm.id() === pcell.id());
    assert(perm.mem_contents() === MemContents::Uninit);

    // We can write a value to the pcell (thus initializing it).
    // This only requires an `&` reference to the PCell, but it does
    // mutate the `perm` token.
    pcell.put(Tracked(&mut perm), 5);

    // Having written the value, this is reflected in the token:
    assert(perm@ === pcell_points![ pcell.id() => MemContents::Init(5) ]);

    // We can take the value back out:
    let x = pcell.take(Tracked(&mut perm));

    // Which leaves it uninitialized again:
    assert(x == 5);
    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);
}
// ANCHOR_END: example

} // verus!
/*
// After erasure, this looks more like:

// ANCHOR: erased
fn main() {
  let pcell = PCell::<u64>::empty();
  pcell.put(5);
  let x = pcell.take();
}
// ANCHOR_END: erased
*/
","['// rust_verify/tests/example.rs\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::{cell::*, pervasive::*};\n\nverus! {\n\n// ANCHOR: example\nfn main() {\n    // Construct a new pcell and obtain the permission for it.\n    let (pcell, Tracked(mut perm)) = PCell::<u64>::empty();\n\n    // Initially, cell is unitialized, and the `perm` token\n    // represents that as the value `MemContents::Uninit`.\n    // The meaning of the permission token is given by its _view_, here `perm@`.\n    //\n    // The expression `pcell_opt![ pcell.id() => MemContents::Uninit ]` can be read as roughly,\n    // ""the cell with value pcell.id() is uninitialized"".\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);\n\n    // The above could also be written by accessing the fields of the\n    // `PointsToData` struct:\n    assert(perm.id() === pcell.id());\n    assert(perm.mem_contents() === MemContents::Uninit);\n\n    // We can write a value to the pcell (thus initializing it).\n    // This only requires an `&` reference to the PCell, but it does\n    // mutate the `perm` token.\n    pcell.put(Tracked(&mut perm), 5);\n\n    // Having written the value, this is reflected in the token:\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Init(5) ]);\n\n    // We can take the value back out:\n    let x = pcell.take(Tracked(&mut perm));\n\n    // Which leaves it uninitialized again:\n    assert(x == 5);\n    assert(perm@ === pcell_points![ pcell.id() => MemContents::Uninit ]);\n}\n// ANCHOR_END: example\n\n} // verus!\n/*\n// After erasure, this looks more like:\n\n// ANCHOR: erased\nfn main() {\n  let pcell = PCell::<u64>::empty();\n  pcell.put(5);\n  let x = pcell.take();\n}\n// ANCHOR_END: erased\n*/\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/rc.rs,335,165,0.4925373134328358,1653.371,True,0.9,False,"['verus_builtin::', 'verus_builtin_macros::', 'verus_state_machines_macros::tokenized_state_machine', 'vstd::cell::', 'vstd::invariant::', 'vstd::modes::', 'vstd::multiset::', 'vstd::prelude::', 'vstd::simple_pptr::', 'vstd::', 'vstd::shared::']",True,,,True,,,"#![allow(unused_imports)]

// ANCHOR: full
use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::tokenized_state_machine;
use vstd::cell::*;
use vstd::invariant::*;
use vstd::modes::*;
use vstd::multiset::*;
use vstd::prelude::*;
use vstd::simple_pptr::*;
use vstd::{pervasive::*, *};
use vstd::shared::*;

verus! {

// ANCHOR: fields
tokenized_state_machine!(RefCounter<Perm> {
    fields {
        #[sharding(variable)]
        pub counter: nat,

        #[sharding(storage_option)]
        pub storage: Option<Perm>,

        #[sharding(multiset)]
        pub reader: Multiset<Perm>,
    }
// ANCHOR_END: fields

    #[invariant]
    pub fn reader_agrees_storage(&self) -> bool {
        forall |t: Perm| self.reader.count(t) > 0 ==>
            self.storage == Option::Some(t)
    }

    #[invariant]
    pub fn counter_agrees_storage(&self) -> bool {
        self.counter == 0 ==> self.storage is None
    }

    #[invariant]
    pub fn counter_agrees_storage_rev(&self) -> bool {
        self.storage is None ==> self.counter == 0
    }

    #[invariant]
    pub fn counter_agrees_reader_count(&self) -> bool {
        self.storage is Some ==>
            self.reader.count(self.storage->0) == self.counter
    }

    init!{
        initialize_empty() {
            init counter = 0;
            init storage = Option::None;
            init reader = Multiset::empty();
        }
    }

    #[inductive(initialize_empty)]
    fn initialize_empty_inductive(post: Self) { }

    transition!{
        do_deposit(x: Perm) {
            require(pre.counter == 0);
            update counter = 1;
            deposit storage += Some(x);
            add reader += {x};
        }
    }

    #[inductive(do_deposit)]
    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }

    property!{
        reader_guard(x: Perm) {
            have reader >= {x};
            guard storage >= Some(x);
        }
    }

    transition!{
        do_clone(x: Perm) {
            have reader >= {x};
            add reader += {x};
            update counter = pre.counter + 1;
        }
    }

    #[inductive(do_clone)]
    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {
        assert(pre.reader.count(x) > 0);
        assert(pre.storage == Option::Some(x));
        assert(pre.storage is Some);
        assert(pre.counter > 0);
    }

    transition!{
        dec_basic(x: Perm) {
            require(pre.counter >= 2);
            remove reader -= {x};
            update counter = (pre.counter - 1) as nat;
        }
    }

    transition!{
        dec_to_zero(x: Perm) {
            remove reader -= {x};
            require(pre.counter < 2);
            assert(pre.counter == 1);
            update counter = 0;
            withdraw storage -= Some(x);
        }
    }

    #[inductive(dec_basic)]
    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {
        assert(pre.reader.count(x) > 0);
        assert(pre.storage == Option::Some(x));
    }

    #[inductive(dec_to_zero)]
    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }
});

pub struct InnerRc<S> {
    pub rc_cell: PCell<u64>,
    pub s: S,
}

pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;

pub tracked struct GhostStuff<S> {
    pub tracked rc_perm: cell::PointsTo<u64>,
    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,
}

impl<S> GhostStuff<S> {
    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {
        &&& self.rc_perm@.pcell == cell.id()
        &&& self.rc_token.instance_id() == inst.id()
        &&& self.rc_perm.is_init()
        &&& self.rc_perm.value() as nat == self.rc_token.value()
    }
}

impl<S> InnerRc<S> {
    spec fn wf(self, cell: PCell<u64>) -> bool {
        self.rc_cell == cell
    }
}

struct_with_invariants!{
    struct MyRc<S> {
        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,
        pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,
        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,

        pub ptr: PPtr<InnerRc<S>>,

        pub rc_cell: Ghost< PCell<u64> >,
    }

    spec fn wf(self) -> bool {
        predicate {
            &&& self.reader@.element().pptr() == self.ptr

            &&& self.reader@.instance_id() == self.inst@.id()
            &&& self.reader@.element().is_init()
            &&& self.reader@.element().value().rc_cell == self.rc_cell
        }

        invariant on inv with (inst, rc_cell)
            specifically (self.inv@@)
            is (v: GhostStuff<S>)
        {
            v.wf(inst@, rc_cell@)
        }
    }
}

impl<S> MyRc<S> {
    spec fn view(self) -> S {
        self.reader@.element().value().s
    }

    fn new(s: S) -> (rc: Self)
        ensures
            rc.wf(),
            rc@ == s,
    {
        let (rc_cell, Tracked(rc_perm)) = PCell::new(1);
        let inner_rc = InnerRc::<S> { rc_cell, s };
        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);
        let tracked (Tracked(inst), Tracked(mut rc_token), _) =
            RefCounter::Instance::initialize_empty(Option::None);
        let tracked reader = inst.do_deposit(
            ptr_perm,
            &mut rc_token,
            ptr_perm,
        );
        let tracked g = GhostStuff::<S> { rc_perm, rc_token };
        let tr_inst = Tracked(inst);
        let gh_cell = Ghost(rc_cell);
        let tracked inv = LocalInvariant::new((tr_inst, gh_cell), g, 0);
        let tracked inv = Shared::new(inv);
        MyRc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }
    }

    fn borrow<'b>(&'b self) -> (s: &'b S)
        requires
            self.wf(),
        ensures
            *s == self@,
    {
        let tracked inst = self.inst.borrow();
        let tracked reader = self.reader.borrow();
        let tracked perm = inst.reader_guard(reader.element(), &reader);
        &self.ptr.borrow(Tracked(perm)).s
    }

    fn clone(&self) -> (s: Self)
        requires
            self.wf(),
        ensures
            s.wf() && s@ == self@,
    {
        let tracked inst = self.inst.borrow();
        let tracked reader = self.reader.borrow();
        let tracked perm = inst.reader_guard(reader.element(), &reader);
        let inner_rc_ref = self.ptr.borrow(Tracked(perm));
        let tracked new_reader;
        open_local_invariant!(self.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;

            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));

            assume(count < 100000000);

            let count = count + 1;
            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);

            proof {
                new_reader = self.inst.borrow().do_clone(
                    reader.element(),
                    &mut rc_token,
                    &reader);
            }

            proof { g = GhostStuff { rc_perm, rc_token }; }
        });
        MyRc {
            inst: Tracked(self.inst.borrow().clone()),
            inv: Tracked(self.inv.borrow().clone()),
            reader: Tracked(new_reader),
            ptr: self.ptr,
            rc_cell: Ghost(self.rc_cell@),
        }
    }

    fn dispose(self)
        requires
            self.wf(),
    {
        let MyRc {
            inst: Tracked(inst),
            inv: Tracked(inv),
            reader: Tracked(reader),
            ptr,
            rc_cell: _,
        } = self;
        let tracked perm = inst.reader_guard(reader.element(), &reader);
        let inner_rc_ref = &ptr.borrow(Tracked(perm));

        let count;
        let tracked mut inner_rc_perm_opt = None;

        open_local_invariant!(inv.borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;

            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));
            if count >= 2 {
                let count = count - 1;
                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);

                proof {
                    inst.dec_basic(
                        reader.element(),
                        &mut rc_token,
                        reader);
                }
            } else {
                let tracked mut inner_rc_perm = inst.dec_to_zero(
                    reader.element(),
                    &mut rc_token,
                    reader);

                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));

                // we still have to write back to the `inner_rc` to restore the invariant
                // even though inner_rc has been moved onto the stack here.
                // so this will probably get optimized out
                let count = count - 1;
                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);

                proof {
                    inner_rc_perm_opt = Some(inner_rc_perm);
                }
            }

            proof { g = GhostStuff { rc_perm, rc_token }; }
        });

        if count < 2 {
            ptr.free(Tracked(inner_rc_perm_opt.tracked_unwrap()));
        }
    }
}

enum Sequence<V> {
    Nil,
    Cons(V, MyRc<Sequence<V>>),
}

fn main() {
    let nil = MyRc::new(Sequence::Nil);
    let a5 = MyRc::new(Sequence::Cons(5, nil.clone()));
    let a7 = MyRc::new(Sequence::Cons(7, nil.clone()));
    let a67 = MyRc::new(Sequence::Cons(6, a7.clone()));
}

} // verus!
// ANCHOR_END: full
"," use verus_state_machines_macros::tokenized_state_machine;
    use vstd::cell::*;
    use vstd::invariant::*;
    use vstd::multiset::*;
    use vstd::prelude::*;
    use vstd::simple_pptr::*;
    use vstd::{
  pervasive::*, *};
    use vstd::shared::*;
    verus! {
   tokenized_state_machine!(RefCounter<Perm> {
      fields {
#[sharding(variable)]
        pub counter: nat,            
#[sharding(storage_option)]
        pub storage: Option<Perm>,            
#[sharding(multiset)]
        pub reader: Multiset<Perm>,     }
#[invariant]
    pub fn reader_agrees_storage(&self) -> bool {
         forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }
#[invariant]
    pub fn counter_agrees_reader_count(&self) -> bool {
         self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }
      init!{
         initialize_empty() {             init counter = 0;             init storage = Option::None;             init reader = Multiset::empty();         }
     }
#[inductive(initialize_empty)]
    fn initialize_empty_inductive(post: Self) {
 }
      property!{
         reader_guard(x: Perm) {             have reader >= {x};             guard storage >= Some(x);         }
     }
      transition!{
         do_clone(x: Perm) {             have reader >= {x};             add reader += {x};             update counter = pre.counter + 1;         }
     }
#[inductive(do_clone)]
    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {
         assert(pre.reader.count(x) > 0);
         assert(pre.storage == Option::Some(x));
         assert(pre.storage is Some);
         assert(pre.counter > 0);
     }
      transition!{
         dec_basic(x: Perm) {             require(pre.counter >= 2);             remove reader -= {x};             update counter = (pre.counter - 1) as nat;         }
     }
      transition!{
         dec_to_zero(x: Perm) {             remove reader -= {x};             require(pre.counter < 2);             assert(pre.counter == 1);             update counter = 0;             withdraw storage -= Some(x);         }
     }
#[inductive(dec_basic)]
    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {
         assert(pre.reader.count(x) > 0);
         assert(pre.storage == Option::Some(x));
     }
#[inductive(dec_to_zero)]
    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {
 }
  }
  );
   pub struct InnerRc<S> {
      pub rc_cell: PCell<u64>,     pub s: S, }
   pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;
   pub tracked struct GhostStuff<S> {
      pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }
   impl<S> GhostStuff<S> {
      pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {
         &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }
  }
   struct_with_invariants!{
      struct MyRc<S> {
         pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }
      spec fn wf(self) -> bool {
         predicate {             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }
         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }
     }
  }
   impl<S> MyRc<S> {
      fn borrow<'b>(&'b self) -> (s: &'b S)
        requires
            self.wf(),
    {
        let tracked inst = self.inst.borrow();
        let tracked reader = self.reader.borrow();
        let tracked perm = inst.reader_guard(reader.element(), &reader);
        &self.ptr.borrow(Tracked(perm)).s
    }
    fn clone(&self) -> (s: Self)
        requires
            self.wf(),
    {
        let tracked inst = self.inst.borrow();
        let tracked reader = self.reader.borrow();
        let tracked perm = inst.reader_guard(reader.element(), &reader);
        let inner_rc_ref = self.ptr.borrow(Tracked(perm));
        let tracked new_reader;
        open_local_invariant!(self.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;
            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));
            assume(count < 100000000);
            let count = count + 1;
            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);
            proof {
                new_reader = self.inst.borrow().do_clone(
                    reader.element(),
                    &mut rc_token,
                    &reader);
            }
            proof { g = GhostStuff { rc_perm, rc_token }; }
        });
        MyRc {
            inst: Tracked(self.inst.borrow().clone()),
            inv: Tracked(self.inv.borrow().clone()),
            reader: Tracked(new_reader),
            ptr: self.ptr,
            rc_cell: Ghost(self.rc_cell@),
        }
    }
    fn dispose(self)
        requires
            self.wf(),
    {
        let MyRc {
            inst: Tracked(inst),
            inv: Tracked(inv),
            reader: Tracked(reader),
            ptr,
            rc_cell: _,
        } = self;
        let tracked perm = inst.reader_guard(reader.element(), &reader);
        let inner_rc_ref = &ptr.borrow(Tracked(perm));
        let count;
        let tracked mut inner_rc_perm_opt = None;
        open_local_invariant!(inv.borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;
            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));
            if count >= 2 {
                let count = count - 1;
                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);
                proof {
                    inst.dec_basic(
                        reader.element(),
                        &mut rc_token,
                        reader);
                }
            } else {
                let tracked mut inner_rc_perm = inst.dec_to_zero(
                    reader.element(),
                    &mut rc_token,
                    reader);
                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));
                let count = count - 1;
                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);
                proof {
                    inner_rc_perm_opt = Some(inner_rc_perm);
                }
            }
            proof { g = GhostStuff { rc_perm, rc_token }; }
        });
        if count < 2 {
        }
    }
}
fn main() {
}
} 
","[""#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n        assert(pre.counter > 0);\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n            assert(pre.counter == 1);\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerRc<S> {\n    pub rc_cell: PCell<u64>,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: cell::PointsTo<u64>,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n        &&& self.rc_perm@.pcell == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerRc<S> {\n    spec fn wf(self, cell: PCell<u64>) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyRc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerRc<S>>,\n\n        pub rc_cell: Ghost< PCell<u64> >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyRc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n        ensures\n            rc.wf(),\n            rc@ == s,\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(1);\n        let inner_rc = InnerRc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = LocalInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyRc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n        ensures\n            s.wf() && s@ == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n\n            assume(count < 100000000);\n\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n\n                // we still have to write back to the `inner_rc` to restore the invariant\n                // even though inner_rc has been moved onto the stack here.\n                // so this will probably get optimized out\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n\n        if count < 2 {\n            ptr.free(Tracked(inner_rc_perm_opt.tracked_unwrap()));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyRc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyRc::new(Sequence::Nil);\n    let a5 = MyRc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyRc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyRc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n"", 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a<b>{fields{\n#[sharding(storage_option)]\n    pub c : Option<b>\n  }});\n  fn main();\n}\n', "" use verus_state_machines_macros::tokenized_state_machine;\n    use vstd::cell::*;\n    use vstd::invariant::*;\n    use vstd::multiset::*;\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::{\n  pervasive::*, *};\n    use vstd::shared::*;\n    verus! {\n   tokenized_state_machine!(RefCounter<Perm> {\n      fields {\n#[sharding(variable)]\n        pub counter: nat,            \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,            \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n         forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n         self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n      init!{\n         initialize_empty() {             init counter = 0;             init storage = Option::None;             init reader = Multiset::empty();         }\n     }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n }\n      property!{\n         reader_guard(x: Perm) {             have reader >= {x};             guard storage >= Some(x);         }\n     }\n      transition!{\n         do_clone(x: Perm) {             have reader >= {x};             add reader += {x};             update counter = pre.counter + 1;         }\n     }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n         assert(pre.storage is Some);\n         assert(pre.counter > 0);\n     }\n      transition!{\n         dec_basic(x: Perm) {             require(pre.counter >= 2);             remove reader -= {x};             update counter = (pre.counter - 1) as nat;         }\n     }\n      transition!{\n         dec_to_zero(x: Perm) {             remove reader -= {x};             require(pre.counter < 2);             assert(pre.counter == 1);             update counter = 0;             withdraw storage -= Some(x);         }\n     }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         assert(pre.reader.count(x) > 0);\n         assert(pre.storage == Option::Some(x));\n     }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n }\n  }\n  );\n   pub struct InnerRc<S> {\n      pub rc_cell: PCell<u64>,     pub s: S, }\n   pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n   pub tracked struct GhostStuff<S> {\n      pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n   impl<S> GhostStuff<S> {\n      pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n         &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n  }\n   struct_with_invariants!{\n      struct MyRc<S> {\n         pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n      spec fn wf(self) -> bool {\n         predicate {             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n         invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {             v.wf(inst@, rc_cell@)         }\n     }\n  }\n   impl<S> MyRc<S> {\n      fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        if count < 2 {\n        }\n    }\n}\nfn main() {\n}\n} \n"", "" use verus_state_machines_macros::tokenized_state_machine;\n     use vstd::cell::*;\n     use vstd::invariant::*;\n     use vstd::multiset::*;\n     use vstd::prelude::*;\n     use vstd::simple_pptr::*;\n     use vstd::{\n   pervasive::*, *};\n     use vstd::shared::*;\n     verus! {\n    tokenized_state_machine!(RefCounter<Perm> {\n       fields {\n#[sharding(variable)]\n        pub counter: nat,             \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,             \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n          forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n          self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n       init!{\n          initialize_empty() {\n             init counter = 0;\n             init storage = Option::None;\n             init reader = Multiset::empty();\n         }\n      }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n  }\n       property!{\n          reader_guard(x: Perm) {\n             have reader >= {x};\n             guard storage >= Some(x);\n         }\n      }\n       transition!{\n          do_clone(x: Perm) {\n             have reader >= {x};\n             add reader += {x};\n             update counter = pre.counter + 1;\n         }\n      }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n      }\n       transition!{\n          dec_basic(x: Perm) {\n             require(pre.counter >= 2);\n             remove reader -= {x};\n             update counter = (pre.counter - 1) as nat;\n         }\n      }\n       transition!{\n          dec_to_zero(x: Perm) {\n             remove reader -= {x};\n             require(pre.counter < 2);\n             assert(pre.counter == 1);\n             update counter = 0;\n             withdraw storage -= Some(x);\n         }\n      }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n      }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n  }\n   }\n   );\n    pub struct InnerRc<S> {\n       pub rc_cell: PCell<u64>,     pub s: S, }\n    pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n    pub tracked struct GhostStuff<S> {\n       pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n    impl<S> GhostStuff<S> {\n       pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n          &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n   }\n    struct_with_invariants!{\n       struct MyRc<S> {\n          pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n       spec fn wf(self) -> bool {\n          predicate {\n             &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n          invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n             v.wf(inst@, rc_cell@)         }\n      }\n   }\n    impl<S> MyRc<S> {\n       fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        if count < 2 {\n        }\n    }\n}\nfn main() {\n}\n} \n"", "" use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::cell::*;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {\n     }\n          property!{\n             reader_guard(x: Perm) {\n                have reader >= {\n  x};\n                guard storage >= Some(x);\n            }\n         }\n          transition!{\n             do_clone(x: Perm) {\n                have reader >= {\n  x};\n                add reader += {\n  x};\n                update counter = pre.counter + 1;\n            }\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n         }\n          transition!{\n             dec_basic(x: Perm) {\n                remove reader -= {\n  x};\n                update counter = (pre.counter - 1) as nat;\n            }\n         }\n          transition!{\n             dec_to_zero(x: Perm) {\n                remove reader -= {\n  x};\n                require(pre.counter < 2);\n                assert(pre.counter == 1);\n                update counter = 0;\n                withdraw storage -= Some(x);\n            }\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n     }\n      }\n      );\n       pub struct InnerRc<S> {\n          pub rc_cell: PCell<u64>,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n             &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n      }\n       struct_with_invariants!{\n          struct MyRc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyRc<S> {\n          fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    ;\n}\nfn main() ;\n} \n"", "" use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::cell::*;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n          property!{\n             reader_guard(x: Perm) {\n                have reader >= {\n  x};\n                guard storage >= Some(x);\n            }\n         }\n          transition!{\n             do_clone(x: Perm) {\n                have reader >= {\n  x};\n                add reader += {\n  x};\n                update counter = pre.counter + 1;\n            }\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n          transition!{\n             dec_basic(x: Perm) {}\n         }\n          transition!{\n             dec_to_zero(x: Perm) {}\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n         }\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n     }\n      }\n      );\n       pub struct InnerRc<S> {\n          pub rc_cell: PCell<u64>,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n             &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n      }\n       struct_with_invariants!{\n          struct MyRc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyRc<S> {\n          fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            assume(count < 100000000);\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n    fn dispose(self)\n        requires\n            self.wf(),\n    ;\n}\nfn main() ;\n} \n"", ' use verus_state_machines_macros::tokenized_state_machine;\n        use vstd::cell::*;\n        use vstd::invariant::*;\n        use vstd::multiset::*;\n        use vstd::prelude::*;\n        use vstd::simple_pptr::*;\n        use vstd::{\n      pervasive::*, *};\n        use vstd::shared::*;\n        verus! {\n       tokenized_state_machine!(RefCounter<Perm> {\n          fields {\n#[sharding(variable)]\n        pub counter: nat,                \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n             forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }\n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n             self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }\n          init!{\n             initialize_empty() {\n                init counter = 0;\n                init storage = Option::None;\n                init reader = Multiset::empty();\n            }\n         }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n          property!{\n             reader_guard(x: Perm) {\n                have reader >= {\n  x};\n                guard storage >= Some(x);\n            }\n         }\n          transition!{\n             do_clone(x: Perm) {\n                have reader >= {\n  x};\n                add reader += {\n  x};\n                update counter = pre.counter + 1;\n            }\n         }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n          transition!{\n             dec_basic(x: Perm) {}\n         }\n          transition!{\n             dec_to_zero(x: Perm) {}\n         }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}\n      }\n      );\n       pub struct InnerRc<S> {\n          pub rc_cell: PCell<u64>,     pub s: S, }\n       pub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n       pub tracked struct GhostStuff<S> {\n          pub tracked rc_perm: cell::PointsTo<u64>,     pub tracked rc_token: RefCounter::counter<MemPerms<S>>, }\n       impl<S> GhostStuff<S> {\n          pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n             &&& self.rc_perm@.pcell == cell.id()         &&& self.rc_token.instance_id() == inst.id()         &&& self.rc_perm.is_init()         &&& self.rc_perm.value() as nat == self.rc_token.value()     }\n      }\n       struct_with_invariants!{\n          struct MyRc<S> {\n             pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,         pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,         pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,         pub ptr: PPtr<InnerRc<S>>,         pub rc_cell: Ghost< PCell<u64> >,     }\n          spec fn wf(self) -> bool {\n             predicate {\n                &&& self.reader@.element().pptr() == self.ptr             &&& self.reader@.instance_id() == self.inst@.id()             &&& self.reader@.element().is_init()             &&& self.reader@.element().value().rc_cell == self.rc_cell         }\n             invariant on inv with (inst, rc_cell)             specifically (self.inv@@)             is (v: GhostStuff<S>)         {\n                v.wf(inst@, rc_cell@)         }\n         }\n      }\n       impl<S> MyRc<S> {}\nfn main() ;\n} \n', ' use verus_state_machines_macros::tokenized_state_machine;\n          use vstd::cell::*;\n          use vstd::invariant::*;\n          use vstd::multiset::*;\n          use vstd::prelude::*;\n          use vstd::simple_pptr::*;\n          use vstd::{\n       pervasive::*, *};\n          use vstd::shared::*;\n          verus! {\n        tokenized_state_machine!(RefCounter<Perm> {           fields {  \n#[sharding(variable)]\n        pub counter: nat,                  \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                  \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }  \n#[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {              forall |t: Perm| self.reader.count(t) > 0 ==>             self.storage == Option::Some(t)     }  \n#[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {              self.storage is Some ==>             self.reader.count(self.storage->0) == self.counter     }           init!{              initialize_empty() {                 init counter = 0;                 init storage = Option::None;                 init reader = Multiset::empty();             }          }  \n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}           property!{              reader_guard(x: Perm) {                 have reader >= {   x};                 guard storage >= Some(x);             }          }           transition!{              do_clone(x: Perm) {                 have reader >= {   x};                 add reader += {   x};                 update counter = pre.counter + 1;             }          }  \n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}           transition!{              dec_basic(x: Perm) {}          }           transition!{              dec_to_zero(x: Perm) {}          }  \n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}  \n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}       }\n       );\n fn main() ;\n }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n           use vstd::multiset::*;\n           use vstd::prelude::*;\n           verus! {\n         tokenized_state_machine!(RefCounter<Perm> {\n           fields {   \n#[sharding(variable)]\n        pub counter: nat,                   \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                   \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n#[invariant]\n           init!{              initialize_empty() {                 init counter = 0;                 init storage = Option::None;                 init reader = Multiset::empty();             }          }\n#[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) {}\n           transition!{              do_clone(x: Perm) {                 have reader >= {   x};                 add reader += {   x};                 update counter = pre.counter + 1;             }          }\n#[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {}\n           transition!{              dec_basic(x: Perm) {}          }\n           transition!{              dec_to_zero(x: Perm) {}          }\n#[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {}\n#[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {}\n       }\n        );\n  fn main() ;\n  }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n            use vstd::multiset::*;\n            use vstd::prelude::*;\n            verus! {\n          tokenized_state_machine!(RefCounter<Perm> {\n            fields {\n#[sharding(variable)]\n        pub counter: nat,                    \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                    \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n            init!{\n              initialize_empty() {                 init counter = 0;                 init storage = Option::None;                 init reader = Multiset::empty();             }\n          }\n            transition!{\n              do_clone(x: Perm) {                 have reader >= {   x};                 add reader += {   x};                 update counter = pre.counter + 1;             }\n          }\n            transition!{\n              dec_basic(x: Perm) {}\n          }\n            transition!{\n              dec_to_zero(x: Perm) {}\n          }\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n}\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) {\n}\n        }\n         );\n   fn main() ;\n   }\n', ' use verus_state_machines_macros::tokenized_state_machine;\n               use vstd::multiset::*;\n               use vstd::prelude::*;\n               verus! {\n             tokenized_state_machine!(RefCounter<Perm> {\n               fields {\n#[sharding(variable)]\n        pub counter: nat,                       \n#[sharding(storage_option)]\n        pub storage: Option<Perm>,                       \n#[sharding(multiset)]\n        pub reader: Multiset<Perm>,     }\n               init!{\n                 initialize_empty() {\n                   init counter = 0;\n                   init storage = Option::None;\n                   init reader = Multiset::empty();\n  }\n             }\n           }\n            );\n      fn main() ;\n      }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(RefCounter<Perm> {\n                fields {\n#[sharding(variable)]\n        pub counter: nat,\n#[sharding(storage_option)]\n        pub storage: Option<Perm>,\n#[sharding(multiset)]\n        pub reader: Multiset<Perm>}\n                init!{\n                  initialize_empty() {\n                    init counter = 0;\n                    init storage = Option::None;\n                    init reader = Multiset::empty();\n}\n}\n}\n             );\n             fn main();\n             }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nverus !{\n              tokenized_state_machine!(a<b> {\n                fields {\n#[sharding(variable)]\n        pub c: nat,\n#[sharding(storage_option)]\n        pub d: Option<b>,\n#[sharding(multiset)]\n        pub e: Multiset<b>}\n                init!{\n                  f() {\n                    init c = 0;\n                    init d = None;\n                    init e = Multiset::empty();\n}\n}\n}\n             );\n             fn main();\n             }\n', 'use verus_state_machines_macros::tokenized_state_machine;\n   use vstd::prelude::*;\n   verus !{\n                tokenized_state_machine!(a<b> {\n                 fields {   \n#[sharding(variable)]\n        pub c: nat,   \n#[sharding(storage_option)]\n        pub d: Option<b>,   \n#[sharding(multiset)]\n        pub e: Multiset<b>}\n }\n               );\n               fn main();\n               }\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(variable)]\n    pub c : nat,\n#[sharding(storage_option)]\n    pub d : Option< b >,\n#[sharding(multiset)]\n    pub e : Multiset< b >\n  }});\n  fn main();\n}\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(storage_option)]\n    pub d : Option< b >,\n#[sharding(multiset)]\n    pub e : Multiset< b >\n  }});\n  fn main();\n}\n', 'use verus_state_machines_macros::tokenized_state_machine;\nuse vstd::prelude::*;\nverus !{\n  tokenized_state_machine !(a< b >{fields{\n#[sharding(storage_option)]\n    pub d : Option< b >,\n}});\n  fn main();\n}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/ref_cell.rs,435,435,1.0,3600.029,False,0.85,False,"['verus_builtin::', 'verus_builtin_macros::', 'verus_state_machines_macros::tokenized_state_machine', 'vstd::cell', 'vstd::cell::', 'vstd::invariant::', 'vstd::multiset::', 'vstd::pervasive::', 'vstd::prelude::', 'vstd::shared::']",True,,,True,,,"#![allow(unused_imports)]

// ANCHOR: full
use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::tokenized_state_machine;
use vstd::cell;
use vstd::cell::*;
use vstd::invariant::*;
use vstd::multiset::*;
use vstd::pervasive::*;
use vstd::prelude::*;
use vstd::shared::*;

verus! {

//////////////////////////////////////////////////////////////////////////////
pub enum BorrowFlag {
    MutBorrow,
    ReadBorrow(nat),  // 0 if there are no borrows
}

type Perm<S> = cell::PointsTo<S>;

// ANCHOR: fields
tokenized_state_machine!(RefCounter<S> {
    fields {
        #[sharding(constant)]
        pub pcell_loc: CellId,

        #[sharding(variable)]
        pub flag: BorrowFlag,

        #[sharding(storage_option)]
        pub storage: Option<Perm<S>>,

        #[sharding(multiset)]
        pub reader: Multiset<Perm<S>>,

        #[sharding(bool)]
        pub writer: bool,
    }
// ANCHOR_END: fields

    #[invariant]
    pub fn reader_agrees_storage(&self) -> bool {
        forall |t: Perm<S>| #[trigger] self.reader.count(t) > 0 ==>
            self.storage == Option::Some(t)
    }

    #[invariant]
    pub fn flag_inv(&self) -> bool {
        match self.flag {
            BorrowFlag::MutBorrow => {
                self.writer && self.reader == Multiset::<Perm<S>>::empty()
                  && self.storage is None
            }
            BorrowFlag::ReadBorrow(n) => {
                !self.writer
                  && self.storage is Some
                  && self.reader.count(self.storage->0) == n
            }
        }
    }

    #[invariant]
    pub fn storage_inv(&self) -> bool {
        match self.storage {
            Some(x) => x@.pcell == self.pcell_loc && x.is_init(),
            None => true,
        }
    }

    init!{
        initialize_empty(loc: CellId) {
            init pcell_loc = loc;
            init flag = BorrowFlag::MutBorrow;
            init storage = Option::None;
            init reader = Multiset::empty();
            init writer = true;
        }
    }

    #[inductive(initialize_empty)]
    fn initialize_empty_inductive(post: Self, loc: CellId) { }

    transition!{
        do_deposit(x: Perm<S>) {
            require(x@.pcell == pre.pcell_loc && x.is_init());
            remove writer -= true;
            assert(pre.flag == BorrowFlag::MutBorrow);
            update flag = BorrowFlag::ReadBorrow(0);

            deposit storage += Some(x);
        }
    }

    #[inductive(do_deposit)]
    fn do_deposit_inductive(pre: Self, post: Self, x: Perm<S>) { }

    transition!{
        do_withdraw() {
            require(pre.flag == BorrowFlag::ReadBorrow(0));
            update flag = BorrowFlag::MutBorrow;

            add writer += true;

            withdraw storage -= Some(let x);
            assert(x@.pcell == pre.pcell_loc && x.is_init());
        }
    }

    #[inductive(do_withdraw)]
    fn do_withdraw_inductive(pre: Self, post: Self) {
        assert_multisets_equal!(post.reader, Multiset::<Perm<S>>::empty());
    }

    property!{
        reader_guard(x: Perm<S>) {
            have reader >= {x};
            guard storage >= Some(x);
        }
    }

    transition!{
        new_reader() {
            require let BorrowFlag::ReadBorrow(n) = pre.flag;
            update flag = BorrowFlag::ReadBorrow(n + 1);

            birds_eye let x = pre.storage->0;
            add reader += { x };
            assert(x@.pcell == pre.pcell_loc && x.is_init());
        }
    }

    #[inductive(new_reader)]
    fn new_reader_inductive(pre: Self, post: Self) { }

    transition!{
        drop_reader(x: Perm<S>) {
            remove reader -= { x };
            assert let BorrowFlag::ReadBorrow(n) = pre.flag;
            assert n >= 1;
            update flag = BorrowFlag::ReadBorrow((n - 1) as nat);
        }
    }

    #[inductive(drop_reader)]
    fn drop_reader_inductive(pre: Self, post: Self, x: Perm<S>) {
        assert(pre.reader.count(x) > 0);
        assert(pre.storage == Option::Some(x));
        assert(pre.storage is Some);
    }
});

pub tracked struct GhostStuff<S> {
    tracked rc_perm: cell::PointsTo<isize>,
    tracked flag_token: RefCounter::flag<S>,
}

impl<S> GhostStuff<S> {
    pub closed spec fn wf(self, inst: RefCounter::Instance<S>, rc_cell: PCell<isize>) -> bool {
        &&& self.rc_perm@.pcell == rc_cell.id()
        &&& self.flag_token.instance_id() == inst.id()
        &&& self.rc_perm.is_init()
        &&& self.rc_perm.value() as int == match self.flag_token.value() {
            BorrowFlag::MutBorrow => 1,
            BorrowFlag::ReadBorrow(n) => -n,
        }
    }
}

struct_with_invariants!{
    pub struct RefCell<S> {
        // 0: no reference taken
        // 1: mut reference taken
        // -n: n non-mut references taken
        rc_cell: PCell<isize>,
        value_cell: PCell<S>,

        inst: Tracked< RefCounter::Instance<S> >,
        inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,
    }

    pub closed spec fn wf(self) -> bool {
        predicate {
            &&& self.inst@.pcell_loc() == self.value_cell.id()
        }

        invariant on inv with (inst, rc_cell)
            specifically (self.inv@@)
            is (v: GhostStuff<S>)
        {
            v.wf(inst@, rc_cell)
        }
    }
}

pub struct Ref<'a, S> {
    ref_cell: &'a RefCell<S>,
    reader: Tracked<RefCounter::reader<S>>,
}

impl<'a, S> Ref<'a, S> {
    pub closed spec fn wf(&self) -> bool {
        self.ref_cell.wf()
            && self.reader@.instance_id() == self.ref_cell.inst@.id()
            && self.reader@.element()@.pcell == self.ref_cell.value_cell.id()
            && self.reader@.element().is_init()
    }

    pub closed spec fn value(&self) -> S {
        self.reader@.element().value()
    }
}

pub struct RefMut<'a, S> {
    ref_cell: &'a RefCell<S>,
    writer: Tracked<RefCounter::writer<S>>,
    perm: Tracked<Perm<S>>,
}

impl<'a, S> RefMut<'a, S> {
    pub closed spec fn wf(&self) -> bool {
        self.ref_cell.wf()
          && self.writer@.instance_id() == self.ref_cell.inst@.id()
          && self.perm@@.pcell == self.ref_cell.value_cell.id()
          && self.perm@.is_init()
    }

    pub closed spec fn value(&self) -> S {
        self.perm@.value()
    }
}

impl<S> RefCell<S> {
    fn new(s: S) -> (ref_cell: Self)
        ensures
            ref_cell.wf(),
    {
        let (rc_cell, Tracked(rc_perm)) = PCell::new(0);
        let (value_cell, Tracked(value_perm)) = PCell::new(s);
        let tracked (Tracked(inst), Tracked(flag), _, Tracked(writer)) = RefCounter::Instance::<
            S,
        >::initialize_empty(value_cell.id(), None);
        proof {
            inst.do_deposit(value_perm, &mut flag, value_perm, writer.tracked_unwrap());
        }
        let tracked_inst = Tracked(inst);
        let tracked inv = LocalInvariant::new(
            (tracked_inst, rc_cell),
            GhostStuff { rc_perm, flag_token: flag },
            0,
        );
        RefCell::<S> { rc_cell, value_cell, inst: tracked_inst, inv: Tracked(Shared::new(inv)) }
    }

    fn try_borrow<'a>(&'a self) -> (opt_ref: Option<Ref<'a, S>>)
        requires
            self.wf(),
        ensures
            match opt_ref {
                Some(read_ref) => read_ref.wf(),
                None => true,
            },
    {
        let return_value;
        open_local_invariant!(self.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;

            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));

            if cur_rc <= 0 && cur_rc > isize::MIN {
                let new_rc = cur_rc - 1;
                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);

                let tracked (_, Tracked(reader_token)) =
                    self.inst.borrow().new_reader(&mut flag_token);
                return_value = Some(Ref {
                    ref_cell: self,
                    reader: Tracked(reader_token),
                });
            } else {
                return_value = None;
            }

            proof { g = GhostStuff { rc_perm, flag_token }; }
        });
        return_value
    }

    fn try_borrow_mut<'a>(&'a self) -> (opt_ref_mut: Option<RefMut<'a, S>>)
        requires
            self.wf(),
        ensures
            match opt_ref_mut {
                Some(write_ref) => write_ref.wf(),
                None => true,
            },
    {
        let return_value;
        open_local_invariant!(self.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;

            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));

            if cur_rc == 0 {
                let new_rc = 1;
                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);

                let tracked (Tracked(perm), Tracked(writer_token)) =
                    self.inst.borrow().do_withdraw(&mut flag_token);
                return_value = Some(RefMut {
                    ref_cell: self,
                    writer: Tracked(writer_token),
                    perm: Tracked(perm),
                });
            } else {
                return_value = None;
            }

            proof { g = GhostStuff { rc_perm, flag_token }; }
        });
        return_value
    }
}

impl<'a, S> Ref<'a, S> {
    fn borrow<'b>(&'b self) -> (s: &'b S)
        requires
            self.wf(),
        ensures
            *s == self.value(),
    {
        self.ref_cell.value_cell.borrow(
            Tracked(
                self.ref_cell.inst.borrow().reader_guard(self.reader@.element(), self.reader.borrow()),
            ),
        )
    }

    fn dispose(self)
        requires
            self.wf(),
    {
        let Ref { ref_cell, reader: Tracked(reader) } = self;
        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;

            proof {
                ref_cell.inst.borrow().drop_reader(reader.element(), &mut flag_token, reader);
            }

            let cur_rc = *ref_cell.rc_cell.borrow(Tracked(&rc_perm));
            let new_rc = cur_rc + 1;
            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);

            proof { g = GhostStuff { rc_perm, flag_token }; }
        });
    }
}

impl<'a, S> RefMut<'a, S> {
    fn replace(&mut self, in_s: S) -> (out_s: S)
        requires
            old(self).wf(),
        ensures
            self.wf(),
            out_s == old(self).value(),
            in_s == self.value(),
    {
        self.ref_cell.value_cell.replace(Tracked(self.perm.borrow_mut()), in_s)
    }

    fn dispose(self)
        requires
            self.wf(),
    {
        let RefMut { ref_cell, writer: Tracked(writer), perm: Tracked(perm) } = self;
        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;

            proof {
                ref_cell.inst.borrow().do_deposit(perm, &mut flag_token, perm, writer);
            }

            let new_rc = 0;
            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);

            proof { g = GhostStuff { rc_perm, flag_token }; }
        });
    }
}

fn main() {
    let rf = RefCell::new(5);
    let read_ref1 = match rf.try_borrow() {
        Some(x) => x,
        None => {
            return ;
        },
    };
    let read_ref2 = match rf.try_borrow() {
        Some(x) => x,
        None => {
            return ;
        },
    };
    let x = *read_ref1.borrow();
    let y = *read_ref2.borrow();
    print_u64(x);
    print_u64(y);
    read_ref1.dispose();
    read_ref2.dispose();
    let mut write_ref = match rf.try_borrow_mut() {
        Some(x) => x,
        None => {
            return ;
        },
    };
    let t = write_ref.replace(20);
    print_u64(t);
    write_ref.dispose();
    let read_ref3 = match rf.try_borrow() {
        Some(x) => x,
        None => {
            return ;
        },
    };
    let z = *read_ref3.borrow();
    print_u64(z);
    read_ref3.dispose();
}

} // verus!
","#![allow(unused_imports)]

// ANCHOR: full
use verus_builtin::*;
use verus_builtin_macros::*;
use verus_state_machines_macros::tokenized_state_machine;
use vstd::cell;
use vstd::cell::*;
use vstd::invariant::*;
use vstd::multiset::*;
use vstd::pervasive::*;
use vstd::prelude::*;
use vstd::shared::*;

verus! {

//////////////////////////////////////////////////////////////////////////////
pub enum BorrowFlag {
    MutBorrow,
    ReadBorrow(nat),  // 0 if there are no borrows
}

type Perm<S> = cell::PointsTo<S>;

// ANCHOR: fields
tokenized_state_machine!(RefCounter<S> {
    fields {
        #[sharding(constant)]
        pub pcell_loc: CellId,

        #[sharding(variable)]
        pub flag: BorrowFlag,

        #[sharding(storage_option)]
        pub storage: Option<Perm<S>>,

        #[sharding(multiset)]
        pub reader: Multiset<Perm<S>>,

        #[sharding(bool)]
        pub writer: bool,
    }
// ANCHOR_END: fields

    #[invariant]
    pub fn reader_agrees_storage(&self) -> bool {
        forall |t: Perm<S>| #[trigger] self.reader.count(t) > 0 ==>
            self.storage == Option::Some(t)
    }

    #[invariant]
    pub fn flag_inv(&self) -> bool {
        match self.flag {
            BorrowFlag::MutBorrow => {
                self.writer && self.reader == Multiset::<Perm<S>>::empty()
                  && self.storage is None
            }
            BorrowFlag::ReadBorrow(n) => {
                !self.writer
                  && self.storage is Some
                  && self.reader.count(self.storage->0) == n
            }
        }
    }

    #[invariant]
    pub fn storage_inv(&self) -> bool {
        match self.storage {
            Some(x) => x@.pcell == self.pcell_loc && x.is_init(),
            None => true,
        }
    }

    init!{
        initialize_empty(loc: CellId) {
            init pcell_loc = loc;
            init flag = BorrowFlag::MutBorrow;
            init storage = Option::None;
            init reader = Multiset::empty();
            init writer = true;
        }
    }

    #[inductive(initialize_empty)]
    fn initialize_empty_inductive(post: Self, loc: CellId) { }

    transition!{
        do_deposit(x: Perm<S>) {
            require(x@.pcell == pre.pcell_loc && x.is_init());
            remove writer -= true;
            assert(pre.flag == BorrowFlag::MutBorrow);
            update flag = BorrowFlag::ReadBorrow(0);

            deposit storage += Some(x);
        }
    }

    #[inductive(do_deposit)]
    fn do_deposit_inductive(pre: Self, post: Self, x: Perm<S>) { }

    transition!{
        do_withdraw() {
            require(pre.flag == BorrowFlag::ReadBorrow(0));
            update flag = BorrowFlag::MutBorrow;

            add writer += true;

            withdraw storage -= Some(let x);
            assert(x@.pcell == pre.pcell_loc && x.is_init());
        }
    }

    #[inductive(do_withdraw)]
    fn do_withdraw_inductive(pre: Self, post: Self) {
        assert_multisets_equal!(post.reader, Multiset::<Perm<S>>::empty());
    }

    property!{
        reader_guard(x: Perm<S>) {
            have reader >= {x};
            guard storage >= Some(x);
        }
    }

    transition!{
        new_reader() {
            require let BorrowFlag::ReadBorrow(n) = pre.flag;
            update flag = BorrowFlag::ReadBorrow(n + 1);

            birds_eye let x = pre.storage->0;
            add reader += { x };
            assert(x@.pcell == pre.pcell_loc && x.is_init());
        }
    }

    #[inductive(new_reader)]
    fn new_reader_inductive(pre: Self, post: Self) { }

    transition!{
        drop_reader(x: Perm<S>) {
            remove reader -= { x };
            assert let BorrowFlag::ReadBorrow(n) = pre.flag;
            assert n >= 1;
            update flag = BorrowFlag::ReadBorrow((n - 1) as nat);
        }
    }

    #[inductive(drop_reader)]
    fn drop_reader_inductive(pre: Self, post: Self, x: Perm<S>) {
        assert(pre.reader.count(x) > 0);
        assert(pre.storage == Option::Some(x));
        assert(pre.storage is Some);
    }
});

pub tracked struct GhostStuff<S> {
    tracked rc_perm: cell::PointsTo<isize>,
    tracked flag_token: RefCounter::flag<S>,
}

impl<S> GhostStuff<S> {
    pub closed spec fn wf(self, inst: RefCounter::Instance<S>, rc_cell: PCell<isize>) -> bool {
        &&& self.rc_perm@.pcell == rc_cell.id()
        &&& self.flag_token.instance_id() == inst.id()
        &&& self.rc_perm.is_init()
        &&& self.rc_perm.value() as int == match self.flag_token.value() {
            BorrowFlag::MutBorrow => 1,
            BorrowFlag::ReadBorrow(n) => -n,
        }
    }
}

struct_with_invariants!{
    pub struct RefCell<S> {
        // 0: no reference taken
        // 1: mut reference taken
        // -n: n non-mut references taken
        rc_cell: PCell<isize>,
        value_cell: PCell<S>,

        inst: Tracked< RefCounter::Instance<S> >,
        inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,
    }

    pub closed spec fn wf(self) -> bool {
        predicate {
            &&& self.inst@.pcell_loc() == self.value_cell.id()
        }

        invariant on inv with (inst, rc_cell)
            specifically (self.inv@@)
            is (v: GhostStuff<S>)
        {
            v.wf(inst@, rc_cell)
        }
    }
}

pub struct Ref<'a, S> {
    ref_cell: &'a RefCell<S>,
    reader: Tracked<RefCounter::reader<S>>,
}

impl<'a, S> Ref<'a, S> {
    pub closed spec fn wf(&self) -> bool {
        self.ref_cell.wf()
            && self.reader@.instance_id() == self.ref_cell.inst@.id()
            && self.reader@.element()@.pcell == self.ref_cell.value_cell.id()
            && self.reader@.element().is_init()
    }

    pub closed spec fn value(&self) -> S {
        self.reader@.element().value()
    }
}

pub struct RefMut<'a, S> {
    ref_cell: &'a RefCell<S>,
    writer: Tracked<RefCounter::writer<S>>,
    perm: Tracked<Perm<S>>,
}

impl<'a, S> RefMut<'a, S> {
    pub closed spec fn wf(&self) -> bool {
        self.ref_cell.wf()
          && self.writer@.instance_id() == self.ref_cell.inst@.id()
          && self.perm@@.pcell == self.ref_cell.value_cell.id()
          && self.perm@.is_init()
    }

    pub closed spec fn value(&self) -> S {
        self.perm@.value()
    }
}

impl<S> RefCell<S> {
    fn new(s: S) -> (ref_cell: Self)
        ensures
            ref_cell.wf(),
    {
        let (rc_cell, Tracked(rc_perm)) = PCell::new(0);
        let (value_cell, Tracked(value_perm)) = PCell::new(s);
        let tracked (Tracked(inst), Tracked(flag), _, Tracked(writer)) = RefCounter::Instance::<
            S,
        >::initialize_empty(value_cell.id(), None);
        proof {
            inst.do_deposit(value_perm, &mut flag, value_perm, writer.tracked_unwrap());
        }
        let tracked_inst = Tracked(inst);
        let tracked inv = LocalInvariant::new(
            (tracked_inst, rc_cell),
            GhostStuff { rc_perm, flag_token: flag },
            0,
        );
        RefCell::<S> { rc_cell, value_cell, inst: tracked_inst, inv: Tracked(Shared::new(inv)) }
    }

    fn try_borrow<'a>(&'a self) -> (opt_ref: Option<Ref<'a, S>>)
        requires
            self.wf(),
        ensures
            match opt_ref {
                Some(read_ref) => read_ref.wf(),
                None => true,
            },
    {
        let return_value;
        open_local_invariant!(self.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;

            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));

            if cur_rc <= 0 && cur_rc > isize::MIN {
                let new_rc = cur_rc - 1;
                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);

                let tracked (_, Tracked(reader_token)) =
                    self.inst.borrow().new_reader(&mut flag_token);
                return_value = Some(Ref {
                    ref_cell: self,
                    reader: Tracked(reader_token),
                });
            } else {
                return_value = None;
            }

            proof { g = GhostStuff { rc_perm, flag_token }; }
        });
        return_value
    }

    fn try_borrow_mut<'a>(&'a self) -> (opt_ref_mut: Option<RefMut<'a, S>>)
        requires
            self.wf(),
        ensures
            match opt_ref_mut {
                Some(write_ref) => write_ref.wf(),
                None => true,
            },
    {
        let return_value;
        open_local_invariant!(self.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;

            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));

            if cur_rc == 0 {
                let new_rc = 1;
                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);

                let tracked (Tracked(perm), Tracked(writer_token)) =
                    self.inst.borrow().do_withdraw(&mut flag_token);
                return_value = Some(RefMut {
                    ref_cell: self,
                    writer: Tracked(writer_token),
                    perm: Tracked(perm),
                });
            } else {
                return_value = None;
            }

            proof { g = GhostStuff { rc_perm, flag_token }; }
        });
        return_value
    }
}

impl<'a, S> Ref<'a, S> {
    fn borrow<'b>(&'b self) -> (s: &'b S)
        requires
            self.wf(),
        ensures
            *s == self.value(),
    {
        self.ref_cell.value_cell.borrow(
            Tracked(
                self.ref_cell.inst.borrow().reader_guard(self.reader@.element(), self.reader.borrow()),
            ),
        )
    }

    fn dispose(self)
        requires
            self.wf(),
    {
        let Ref { ref_cell, reader: Tracked(reader) } = self;
        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;

            proof {
                ref_cell.inst.borrow().drop_reader(reader.element(), &mut flag_token, reader);
            }

            let cur_rc = *ref_cell.rc_cell.borrow(Tracked(&rc_perm));
            let new_rc = cur_rc + 1;
            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);

            proof { g = GhostStuff { rc_perm, flag_token }; }
        });
    }
}

impl<'a, S> RefMut<'a, S> {
    fn replace(&mut self, in_s: S) -> (out_s: S)
        requires
            old(self).wf(),
        ensures
            self.wf(),
            out_s == old(self).value(),
            in_s == self.value(),
    {
        self.ref_cell.value_cell.replace(Tracked(self.perm.borrow_mut()), in_s)
    }

    fn dispose(self)
        requires
            self.wf(),
    {
        let RefMut { ref_cell, writer: Tracked(writer), perm: Tracked(perm) } = self;
        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {
            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;

            proof {
                ref_cell.inst.borrow().do_deposit(perm, &mut flag_token, perm, writer);
            }

            let new_rc = 0;
            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);

            proof { g = GhostStuff { rc_perm, flag_token }; }
        });
    }
}

fn main() {
    let rf = RefCell::new(5);
    let read_ref1 = match rf.try_borrow() {
        Some(x) => x,
        None => {
            return ;
        },
    };
    let read_ref2 = match rf.try_borrow() {
        Some(x) => x,
        None => {
            return ;
        },
    };
    let x = *read_ref1.borrow();
    let y = *read_ref2.borrow();
    print_u64(x);
    print_u64(y);
    read_ref1.dispose();
    read_ref2.dispose();
    let mut write_ref = match rf.try_borrow_mut() {
        Some(x) => x,
        None => {
            return ;
        },
    };
    let t = write_ref.replace(20);
    print_u64(t);
    write_ref.dispose();
    let read_ref3 = match rf.try_borrow() {
        Some(x) => x,
        None => {
            return ;
        },
    };
    let z = *read_ref3.borrow();
    print_u64(z);
    read_ref3.dispose();
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/unverified_counting_to_2.rs,58,58,0.0,,,,,,False,unknown,,,,,"// rust_verify/tests/example.rs ignore --- ordinary rust, not verus

// ANCHOR: full
// Ordinary Rust code, not Verus

use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
use std::thread::spawn;

fn main() {
    // Initialize an atomic variable

    let atomic = AtomicU32::new(0);

    // Put it in an Arc so it can be shared by multiple threads.

    let shared_atomic = Arc::new(atomic);

    // Spawn a thread to increment the atomic once.

    let handle1 = {
        let shared_atomic = shared_atomic.clone();
        spawn(move || {
            shared_atomic.fetch_add(1, Ordering::SeqCst);
        })
    };

    // Spawn another thread to increment the atomic once.

    let handle2 = {
        let shared_atomic = shared_atomic.clone();
        spawn(move || {
            shared_atomic.fetch_add(1, Ordering::SeqCst);
        })
    };

    // Wait on both threads. Exit if an unexpected condition occurs.

    match handle1.join() {
        Result::Ok(()) => {}
        _ => {
            return;
        }
    };

    match handle2.join() {
        Result::Ok(()) => {}
        _ => {
            return;
        }
    };

    // Load the value, and assert that it should now be 2.

    let val = shared_atomic.load(Ordering::SeqCst);
    assert!(val == 2);
}
// ANCHOR_END: full
","// rust_verify/tests/example.rs ignore --- ordinary rust, not verus

// ANCHOR: full
// Ordinary Rust code, not Verus

use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
use std::thread::spawn;

fn main() {
    // Initialize an atomic variable

    let atomic = AtomicU32::new(0);

    // Put it in an Arc so it can be shared by multiple threads.

    let shared_atomic = Arc::new(atomic);

    // Spawn a thread to increment the atomic once.

    let handle1 = {
        let shared_atomic = shared_atomic.clone();
        spawn(move || {
            shared_atomic.fetch_add(1, Ordering::SeqCst);
        })
    };

    // Spawn another thread to increment the atomic once.

    let handle2 = {
        let shared_atomic = shared_atomic.clone();
        spawn(move || {
            shared_atomic.fetch_add(1, Ordering::SeqCst);
        })
    };

    // Wait on both threads. Exit if an unexpected condition occurs.

    match handle1.join() {
        Result::Ok(()) => {}
        _ => {
            return;
        }
    };

    match handle2.join() {
        Result::Ok(()) => {}
        _ => {
            return;
        }
    };

    // Load the value, and assert that it should now be 2.

    let val = shared_atomic.load(Ordering::SeqCst);
    assert!(val == 2);
}
// ANCHOR_END: full
",[]
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/unverified_counting_to_n.rs,53,53,0.0,,,,,,False,unknown,,,,,"// rust_verify/tests/example.rs ignore --- ordinary rust, not verus

// ANCHOR: full
// Ordinary Rust code, not Verus

use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
use std::thread::spawn;

fn do_count(num_threads: u32) {
    // Initialize an atomic variable

    let atomic = AtomicU32::new(0);

    // Put it in an Arc so it can be shared by multiple threads.

    let shared_atomic = Arc::new(atomic);

    // Spawn `num_threads` threads to increment the atomic once.

    let mut handles = Vec::new();

    for _i in 0..num_threads {
        let handle = {
            let shared_atomic = shared_atomic.clone();
            spawn(move || {
                shared_atomic.fetch_add(1, Ordering::SeqCst);
            })
        };
        handles.push(handle);
    }

    // Wait on all threads. Exit if an unexpected condition occurs.

    for handle in handles.into_iter() {
        match handle.join() {
            Result::Ok(()) => {}
            _ => {
                return;
            }
        };
    }

    // Load the value, and assert that it should now be `num_threads`.

    let val = shared_atomic.load(Ordering::SeqCst);
    assert!(val == num_threads);
}

fn main() {
    do_count(20);
}
// ANCHOR_END: full
","// rust_verify/tests/example.rs ignore --- ordinary rust, not verus

// ANCHOR: full
// Ordinary Rust code, not Verus

use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Arc;
use std::thread::spawn;

fn do_count(num_threads: u32) {
    // Initialize an atomic variable

    let atomic = AtomicU32::new(0);

    // Put it in an Arc so it can be shared by multiple threads.

    let shared_atomic = Arc::new(atomic);

    // Spawn `num_threads` threads to increment the atomic once.

    let mut handles = Vec::new();

    for _i in 0..num_threads {
        let handle = {
            let shared_atomic = shared_atomic.clone();
            spawn(move || {
                shared_atomic.fetch_add(1, Ordering::SeqCst);
            })
        };
        handles.push(handle);
    }

    // Wait on all threads. Exit if an unexpected condition occurs.

    for handle in handles.into_iter() {
        match handle.join() {
            Result::Ok(()) => {}
            _ => {
                return;
            }
        };
    }

    // Load the value, and assert that it should now be `num_threads`.

    let val = shared_atomic.load(Ordering::SeqCst);
    assert!(val == num_threads);
}

fn main() {
    do_count(20);
}
// ANCHOR_END: full
",[]
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/unverified_fifo.rs,132,132,0.0,,,,,,False,unknown,,,,,"// rust_verify/tests/example.rs ignore --- ordianary rust, not verus

// ANCHOR: full
// Ordinary Rust code, not Verus

use std::cell::UnsafeCell;
use std::mem::MaybeUninit;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

// ANCHOR: queue
struct Queue<T> {
    buffer: Vec<UnsafeCell<MaybeUninit<T>>>,
    head: AtomicU64,
    tail: AtomicU64,
}
// ANCHOR_END: queue

// ANCHOR: producer_consumer
pub struct Producer<T> {
    queue: Arc<Queue<T>>,
    tail: usize,
}

pub struct Consumer<T> {
    queue: Arc<Queue<T>>,
    head: usize,
}
// ANCHOR_END: producer_consumer

// ANCHOR: impl
pub fn new_queue<T>(len: usize) -> (Producer<T>, Consumer<T>) {
    // Create a vector of UnsafeCells to serve as the ring buffer

    let mut backing_cells_vec = Vec::<UnsafeCell<MaybeUninit<T>>>::new();
    while backing_cells_vec.len() < len {
        let cell = UnsafeCell::new(MaybeUninit::uninit());
        backing_cells_vec.push(cell);
    }

    // Initialize head and tail to 0 (empty)
    let head_atomic = AtomicU64::new(0);
    let tail_atomic = AtomicU64::new(0);

    // Package it all into a queue object, and make a reference-counted pointer to it
    // so it can be shared by the Producer and the Consumer.
    let queue = Queue::<T> { head: head_atomic, tail: tail_atomic, buffer: backing_cells_vec };
    let queue_arc = Arc::new(queue);

    let prod = Producer::<T> { queue: queue_arc.clone(), tail: 0 };
    let cons = Consumer::<T> { queue: queue_arc, head: 0 };
    (prod, cons)
}

impl<T> Producer<T> {
    pub fn enqueue(&mut self, t: T) {
        // Loop: if the queue is full, then block until it is not.
        loop {
            let len = self.queue.buffer.len();

            // Calculate the index of the slot right after `tail`, wrapping around
            // if necessary. If the enqueue is successful, then we will be updating
            // the `tail` to this value.
            let next_tail = if self.tail + 1 == len { 0 } else { self.tail + 1 };

            // Get the current `head` value from the shared atomic.
            let head = self.queue.head.load(Ordering::SeqCst);

            // Check to make sure there is room. (We can't advance the `tail` pointer
            // if it would become equal to the head, since `tail == head` denotes
            // an empty state.)
            // If there's no room, we'll just loop and try again.
            if head != next_tail as u64 {
                // Here's the unsafe part: writing the given `t` value into the `UnsafeCell`.
                unsafe {
                    (*self.queue.buffer[self.tail].get()).write(t);
                }

                // Update the `tail` (both the shared atomic and our local copy).
                self.queue.tail.store(next_tail as u64, Ordering::SeqCst);
                self.tail = next_tail;

                // Done.
                return;
            }
        }
    }
}

impl<T> Consumer<T> {
    pub fn dequeue(&mut self) -> T {
        // Loop: if the queue is empty, then block until it is not.
        loop {
            let len = self.queue.buffer.len();

            // Calculate the index of the slot right after `head`, wrapping around
            // if necessary. If the enqueue is successful, then we will be updating
            // the `head` to this value.
            let next_head = if self.head + 1 == len { 0 } else { self.head + 1 };

            // Get the current `tail` value from the shared atomic.
            let tail = self.queue.tail.load(Ordering::SeqCst);

            // Check to see if the queue is nonempty.
            // If it's empty, we'll just loop and try again.
            if self.head as u64 != tail {
                // Load the stored message from the UnsafeCell
                // (replacing it with ""uninitialized"" memory).
                let t = unsafe {
                    let mut tmp = MaybeUninit::uninit();
                    std::mem::swap(&mut *self.queue.buffer[self.head].get(), &mut tmp);
                    tmp.assume_init()
                };

                // Update the `head` (both the shared atomic and our local copy).
                self.queue.head.store(next_head as u64, Ordering::SeqCst);
                self.head = next_head;

                // Done. Return the value we loaded out of the buffer.
                return t;
            }
        }
    }
}
// ANCHOR_END: impl

fn main() {
    let (mut producer, mut consumer) = new_queue(20);
    producer.enqueue(5);
    let _x = consumer.dequeue();
}
// ANCHOR_END: full
","// rust_verify/tests/example.rs ignore --- ordianary rust, not verus

// ANCHOR: full
// Ordinary Rust code, not Verus

use std::cell::UnsafeCell;
use std::mem::MaybeUninit;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

// ANCHOR: queue
struct Queue<T> {
    buffer: Vec<UnsafeCell<MaybeUninit<T>>>,
    head: AtomicU64,
    tail: AtomicU64,
}
// ANCHOR_END: queue

// ANCHOR: producer_consumer
pub struct Producer<T> {
    queue: Arc<Queue<T>>,
    tail: usize,
}

pub struct Consumer<T> {
    queue: Arc<Queue<T>>,
    head: usize,
}
// ANCHOR_END: producer_consumer

// ANCHOR: impl
pub fn new_queue<T>(len: usize) -> (Producer<T>, Consumer<T>) {
    // Create a vector of UnsafeCells to serve as the ring buffer

    let mut backing_cells_vec = Vec::<UnsafeCell<MaybeUninit<T>>>::new();
    while backing_cells_vec.len() < len {
        let cell = UnsafeCell::new(MaybeUninit::uninit());
        backing_cells_vec.push(cell);
    }

    // Initialize head and tail to 0 (empty)
    let head_atomic = AtomicU64::new(0);
    let tail_atomic = AtomicU64::new(0);

    // Package it all into a queue object, and make a reference-counted pointer to it
    // so it can be shared by the Producer and the Consumer.
    let queue = Queue::<T> { head: head_atomic, tail: tail_atomic, buffer: backing_cells_vec };
    let queue_arc = Arc::new(queue);

    let prod = Producer::<T> { queue: queue_arc.clone(), tail: 0 };
    let cons = Consumer::<T> { queue: queue_arc, head: 0 };
    (prod, cons)
}

impl<T> Producer<T> {
    pub fn enqueue(&mut self, t: T) {
        // Loop: if the queue is full, then block until it is not.
        loop {
            let len = self.queue.buffer.len();

            // Calculate the index of the slot right after `tail`, wrapping around
            // if necessary. If the enqueue is successful, then we will be updating
            // the `tail` to this value.
            let next_tail = if self.tail + 1 == len { 0 } else { self.tail + 1 };

            // Get the current `head` value from the shared atomic.
            let head = self.queue.head.load(Ordering::SeqCst);

            // Check to make sure there is room. (We can't advance the `tail` pointer
            // if it would become equal to the head, since `tail == head` denotes
            // an empty state.)
            // If there's no room, we'll just loop and try again.
            if head != next_tail as u64 {
                // Here's the unsafe part: writing the given `t` value into the `UnsafeCell`.
                unsafe {
                    (*self.queue.buffer[self.tail].get()).write(t);
                }

                // Update the `tail` (both the shared atomic and our local copy).
                self.queue.tail.store(next_tail as u64, Ordering::SeqCst);
                self.tail = next_tail;

                // Done.
                return;
            }
        }
    }
}

impl<T> Consumer<T> {
    pub fn dequeue(&mut self) -> T {
        // Loop: if the queue is empty, then block until it is not.
        loop {
            let len = self.queue.buffer.len();

            // Calculate the index of the slot right after `head`, wrapping around
            // if necessary. If the enqueue is successful, then we will be updating
            // the `head` to this value.
            let next_head = if self.head + 1 == len { 0 } else { self.head + 1 };

            // Get the current `tail` value from the shared atomic.
            let tail = self.queue.tail.load(Ordering::SeqCst);

            // Check to see if the queue is nonempty.
            // If it's empty, we'll just loop and try again.
            if self.head as u64 != tail {
                // Load the stored message from the UnsafeCell
                // (replacing it with ""uninitialized"" memory).
                let t = unsafe {
                    let mut tmp = MaybeUninit::uninit();
                    std::mem::swap(&mut *self.queue.buffer[self.head].get(), &mut tmp);
                    tmp.assume_init()
                };

                // Update the `head` (both the shared atomic and our local copy).
                self.queue.head.store(next_head as u64, Ordering::SeqCst);
                self.head = next_head;

                // Done. Return the value we loaded out of the buffer.
                return t;
            }
        }
    }
}
// ANCHOR_END: impl

fn main() {
    let (mut producer, mut consumer) = new_queue(20);
    producer.enqueue(5);
    let _x = consumer.dequeue();
}
// ANCHOR_END: full
",[]
/Users/ameliakuang/Repos/dep_verus/examples/state_machines/tutorial/unverified_rc.rs,96,96,0.0,,,,,,False,unknown,,,,,"// rust_verify/tests/example.rs ignore --- ordinary rust, not verus

// ANCHOR: full
// Ordinary Rust code, not Verus

struct InnerRc<T> {
    rc_cell: std::cell::UnsafeCell<u64>,
    t: T,
}

struct Rc<T> {
    ptr: *mut InnerRc<T>,
}

impl<T> Rc<T> {
    fn new(t: T) -> Self {
        // Allocate a new InnerRc object, initialize the counter to 1,
        // and return a pointer to it.
        let rc_cell = std::cell::UnsafeCell::new(1);
        let inner_rc = InnerRc { rc_cell, t };
        let ptr = Box::leak(Box::new(inner_rc));
        Rc { ptr }
    }

    fn clone(&self) -> Self {
        unsafe {
            // Increment the counter.
            // If incrementing the counter would lead to overflow, then abort.
            let inner_rc = &*self.ptr;
            let count = *inner_rc.rc_cell.get();
            if count == 0xffffffffffffffff {
                std::process::abort();
            }
            *inner_rc.rc_cell.get() = count + 1;
        }

        // Return a new Rc object with the same pointer.
        Rc { ptr: self.ptr }
    }

    fn drop(self) {
        unsafe {
            // Decrement the counter.
            let inner_rc = &*self.ptr;
            let count = *inner_rc.rc_cell.get() - 1;
            *inner_rc.rc_cell.get() = count;

            // If the counter hits 0, drop the `T` and deallocate the memory.
            if count == 0 {
                std::ptr::drop_in_place(&mut (*self.ptr).t);
                std::alloc::dealloc(self.ptr as *mut u8, std::alloc::Layout::for_value(&*self.ptr));
            }
        }
    }

    fn borrow(&self) -> &T {
        unsafe { &(*self.ptr).t }
    }
}

// Example usage

enum Sequence<V> {
    Nil,
    Cons(V, Rc<Sequence<V>>),
}

fn main() {
    let nil = Rc::new(Sequence::Nil);
    let nil_clone = nil.clone();
    let a5 = Rc::new(Sequence::Cons(5, nil.clone()));
    let a7 = Rc::new(Sequence::Cons(7, nil.clone()));
    let a67 = Rc::new(Sequence::Cons(6, a7.clone()));

    let x1 = nil.borrow();
    let x2 = nil_clone.borrow();
    match x1 {
        Sequence::Nil => {}
        Sequence::Cons(_, _) => {
            assert!(false);
        }
    }
    match x2 {
        Sequence::Nil => {}
        Sequence::Cons(_, _) => {
            assert!(false);
        }
    }

    nil.drop();
    nil_clone.drop();
    a5.drop();
    a7.drop();
    a67.drop();
}
// ANCHOR_END: full
","// rust_verify/tests/example.rs ignore --- ordinary rust, not verus

// ANCHOR: full
// Ordinary Rust code, not Verus

struct InnerRc<T> {
    rc_cell: std::cell::UnsafeCell<u64>,
    t: T,
}

struct Rc<T> {
    ptr: *mut InnerRc<T>,
}

impl<T> Rc<T> {
    fn new(t: T) -> Self {
        // Allocate a new InnerRc object, initialize the counter to 1,
        // and return a pointer to it.
        let rc_cell = std::cell::UnsafeCell::new(1);
        let inner_rc = InnerRc { rc_cell, t };
        let ptr = Box::leak(Box::new(inner_rc));
        Rc { ptr }
    }

    fn clone(&self) -> Self {
        unsafe {
            // Increment the counter.
            // If incrementing the counter would lead to overflow, then abort.
            let inner_rc = &*self.ptr;
            let count = *inner_rc.rc_cell.get();
            if count == 0xffffffffffffffff {
                std::process::abort();
            }
            *inner_rc.rc_cell.get() = count + 1;
        }

        // Return a new Rc object with the same pointer.
        Rc { ptr: self.ptr }
    }

    fn drop(self) {
        unsafe {
            // Decrement the counter.
            let inner_rc = &*self.ptr;
            let count = *inner_rc.rc_cell.get() - 1;
            *inner_rc.rc_cell.get() = count;

            // If the counter hits 0, drop the `T` and deallocate the memory.
            if count == 0 {
                std::ptr::drop_in_place(&mut (*self.ptr).t);
                std::alloc::dealloc(self.ptr as *mut u8, std::alloc::Layout::for_value(&*self.ptr));
            }
        }
    }

    fn borrow(&self) -> &T {
        unsafe { &(*self.ptr).t }
    }
}

// Example usage

enum Sequence<V> {
    Nil,
    Cons(V, Rc<Sequence<V>>),
}

fn main() {
    let nil = Rc::new(Sequence::Nil);
    let nil_clone = nil.clone();
    let a5 = Rc::new(Sequence::Cons(5, nil.clone()));
    let a7 = Rc::new(Sequence::Cons(7, nil.clone()));
    let a67 = Rc::new(Sequence::Cons(6, a7.clone()));

    let x1 = nil.borrow();
    let x2 = nil_clone.borrow();
    match x1 {
        Sequence::Nil => {}
        Sequence::Cons(_, _) => {
            assert!(false);
        }
    }
    match x2 {
        Sequence::Nil => {}
        Sequence::Cons(_, _) => {
            assert!(false);
        }
    }

    nil.drop();
    nil_clone.drop();
    a5.drop();
    a7.drop();
    a67.drop();
}
// ANCHOR_END: full
",[]
/Users/ameliakuang/Repos/dep_verus/examples/statements.rs,60,60,1.0,247.744,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::']",True,,,,,,"use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

fn main() {
}

fn test_if(b: bool) {
    let mut x: u32 = 0;
    if b {
        x = 10;
    }
    assert(b ==> x == 10);
    if b {
        x = x + 3;
        x = x + 4;
    } else {
        x = x + 2;
    }
    assert(b ==> x == 17);
    assert(!b ==> x == 2);
    assert(x == if b {
        17int
    } else {
        2
    });
    if x == 0 {
        assert(false);
    } else if x == 1 {
        assert(false);
    } else if x == 2 {
        assert(!b);
    } else {
        assert(x == 17);
    }
}

fn test_loop() {
    let mut i: u64 = 10;
    let mut b1: u8 = 20;
    let mut b2: u8 = 200;
    let mut b3: u8 = 30;
    while i < 100
        invariant
            10 <= i,
            i <= 100,
            b1 == i * 2,
        decreases 100 - i,
    {
        assert(b2 <= 255);
        i = i + 1;
        b1 = b1 + 2;
        b2 = b2 / 2;
    }
    assert(b1 == 200);
    assert(b3 == 30);
}

} // verus!
","use verus_builtin::*;
use verus_builtin_macros::*;

verus! {

fn main() {
}

fn test_if(b: bool) {
    let mut x: u32 = 0;
    if b {
        x = 10;
    }
    assert(b ==> x == 10);
    if b {
        x = x + 3;
        x = x + 4;
    } else {
        x = x + 2;
    }
    assert(b ==> x == 17);
    assert(!b ==> x == 2);
    assert(x == if b {
        17int
    } else {
        2
    });
    if x == 0 {
        assert(false);
    } else if x == 1 {
        assert(false);
    } else if x == 2 {
        assert(!b);
    } else {
        assert(x == 17);
    }
}

fn test_loop() {
    let mut i: u64 = 10;
    let mut b1: u8 = 20;
    let mut b2: u8 = 200;
    let mut b3: u8 = 30;
    while i < 100
        invariant
            10 <= i,
            i <= 100,
            b1 == i * 2,
        decreases 100 - i,
    {
        assert(b2 <= 255);
        i = i + 1;
        b1 = b1 + 2;
        b2 = b2 / 2;
    }
    assert(b1 == 200);
    assert(b3 == 30);
}

} // verus!
","['use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nfn test_if(b: bool) {\n    let mut x: u32 = 0;\n    if b {\n        x = 10;\n    }\n    assert(b ==> x == 10);\n    if b {\n        x = x + 3;\n        x = x + 4;\n    } else {\n        x = x + 2;\n    }\n    assert(b ==> x == 17);\n    assert(!b ==> x == 2);\n    assert(x == if b {\n        17int\n    } else {\n        2\n    });\n    if x == 0 {\n        assert(false);\n    } else if x == 1 {\n        assert(false);\n    } else if x == 2 {\n        assert(!b);\n    } else {\n        assert(x == 17);\n    }\n}\n\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;\n    while i < 100\n        invariant\n            10 <= i,\n            i <= 100,\n            b1 == i * 2,\n        decreases 100 - i,\n    {\n        assert(b2 <= 255);\n        i = i + 1;\n        b1 = b1 + 2;\n        b2 = b2 / 2;\n    }\n    assert(b1 == 200);\n    assert(b3 == 30);\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nfn test_if(b: bool) {\n    let mut x: u32 = 0;\n    if b {\n        x = 10;\n    }\n    assert(b ==> x == 10);\n    if b {\n        x = x + 3;\n        x = x + 4;\n    } else {\n        x = x + 2;\n    }\n    assert(b ==> x == 17);\n    assert(!b ==> x == 2);\n    assert(x == if b {\n        17int\n    } else {\n        2\n    });\n    if x == 0 {\n        assert(false);\n    } else if x == 1 {\n        assert(false);\n    } else if x == 2 {\n        assert(!b);\n    } else {\n        assert(x == 17);\n    }\n}\n\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;\n    while i < 100\n        invariant\n            10 <= i,\n            i <= 100,\n            b1 == i * 2,\n        decreases 100 - i,\n    {\n        assert(b2 <= 255);\n        i = i + 1;\n        b1 = b1 + 2;\n        b2 = b2 / 2;\n    }\n    assert(b1 == 200);\n    assert(b3 == 30);\n}\n\n} // verus!\n']"
/Users/ameliakuang/Repos/dep_verus/examples/statics.rs,173,116,0.6705202312138728,2525.93,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::atomic_ghost::', 'vstd::cell::', 'vstd::prelude::', 'vstd::', 'vstd::raw_ptr::MemContents', 'std::sync::atomic::']",True,,,,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::atomic_ghost::*;
use vstd::cell::*;
use vstd::prelude::*;
use vstd::*;
use vstd::raw_ptr::MemContents;

use std::sync::atomic::*;

verus! {

// A simple counter, albeit with nothing verified about it.
exec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);

fn increment_counter() {
    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);
}

// Thread-safe lazy initialization
pub tracked enum GhostState<T: 'static> {
    Uninitialized(cell::PointsTo<Option<T>>),
    Initializing,
    Initialized(&'static cell::PointsTo<Option<T>>),
}

struct_with_invariants!{
    struct Lazy<T: 'static> {
        pub cell: PCell<Option<T>>,
        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>
    }

    spec fn wf(&self) -> bool {
        invariant on state with (cell) is (v: u64, g: GhostState<T>) {
            // State = 0: Uninitialized
            // State = 1: currently initializing
            // State = 2: is initialized
            match g {
                GhostState::Uninitialized(points_to) => {
                    v == 0
                      && points_to.id() == cell.id()
                      && (points_to.mem_contents() === MemContents::Init(None))
                }
                GhostState::Initializing => {
                    v == 1
                }
                GhostState::Initialized(points_to) => {
                    v == 2
                      && points_to.id() == cell.id()
                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))
                }
            }
        }
    }
}

trait Initializable: Sized {
    fn initialize() -> Self;
}

impl<T: Initializable> Lazy<T> {
    const fn new() -> (s: Self)
        ensures
            s.wf(),
    {
        let (pcell, Tracked(points_to)) = PCell::new(None);
        Lazy {
            cell: pcell,
            state: vstd::atomic_ghost::AtomicU64::new(
                Ghost(pcell),
                0,
                Tracked(GhostState::Uninitialized(points_to)),
            ),
        }
    }

    fn get<'a>(&'a self) -> &'a T
        requires
            self.wf(),
    {
        loop
            invariant
                self.wf(),
        {
            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;
            let cur_state =
                atomic_with_ghost!(&self.state => load(); ghost g => {
                match &g {
                    GhostState::Initialized(points_to) => {
                        readonly_points_to = Some(points_to);
                    }
                    _ => { }
                }
            });
            if cur_state == 2 {
                // Already initialized.
                return self.cell.borrow(
                    Tracked(readonly_points_to.tracked_borrow()),
                ).as_ref().unwrap();
            } else {
                // Initialization is required. Try to take the lock if initialization
                // isn't already in progress.
                let mut do_initialization = (cur_state == 0);
                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;
                if do_initialization {
                    let res =
                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);
                        returning res; ghost g =>
                    {
                        g = match g {
                            GhostState::Uninitialized(pt) => {
                                points_to = Some(pt);
                                GhostState::Initializing
                            }
                            GhostState::Initializing => {
                                GhostState::Initializing
                            }
                            GhostState::Initialized(x) => {
                                GhostState::Initialized(x)
                            }
                        };
                    });
                    if res.is_err() {
                        // don't initialize after all
                        do_initialization = false;
                    }
                }
                if do_initialization {
                    // Do initialization
                    let t = T::initialize();
                    let tracked mut points_to = points_to.tracked_unwrap();
                    self.cell.replace(Tracked(&mut points_to), Some(t));
                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);
                    atomic_with_ghost!(&self.state => store(2); ghost g => {
                        g = GhostState::Initialized(static_points_to);
                    });
                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();
                } else {
                    // Wait for initialization to complete by a different thread
                    // (Try again in the next iteration of the loop.)
                }
            }
        }
    }
}

// Example usage
struct X {}

impl Initializable for X {
    fn initialize() -> Self {
        X {  }
    }
}

exec static LAZY_X: Lazy<X>
    ensures
        LAZY_X.wf(),
{
    Lazy::<X>::new()
}

fn get_lazy_x() -> &'static X {
    LAZY_X.get()
}

fn main() {
}

} // verus!
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
 use vstd::cell::*;
  use vstd::prelude::*;
  use vstd::*;
  use std::sync::atomic::*;
  verus! {
 exec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);
 fn increment_counter() {     GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed); }
 pub tracked enum GhostState<T: 'static> {
    Uninitialized(cell::PointsTo<Option<T>>),
    Initializing,
    Initialized(&'static cell::PointsTo<Option<T>>), }
  struct_with_invariants!{
     struct Lazy<T: 'static> {
        pub cell: PCell<Option<T>>,
        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>
    }
    spec fn wf(&self) -> bool {
        invariant on state with (cell) is (v: u64, g: GhostState<T>) {
            match g {
                GhostState::Uninitialized(points_to) => {
                    v == 0
                }
                GhostState::Initializing => {
                    v == 1
                }
                GhostState::Initialized(points_to) => {
                      && points_to.id() == cell.id()
                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))
                }
            }
        }
    }
}
trait Initializable: Sized {
    fn initialize() -> Self;
}
impl<T: Initializable> Lazy<T> {
    const fn new() -> (s: Self)
        ensures
            s.wf(),
    {
        let (pcell, Tracked(points_to)) = PCell::new(None);
        Lazy {
            cell: pcell,
            state: vstd::atomic_ghost::AtomicU64::new(
                Ghost(pcell),
                0,
                Tracked(GhostState::Uninitialized(points_to)),
            ),
        }
    }
    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {         loop             invariant                 self.wf(),         {             let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;
            let cur_state =
                atomic_with_ghost!(&self.state => load(); ghost g => {
                match &g {
                    GhostState::Initialized(points_to) => {
                        readonly_points_to = Some(points_to);
                    }
                    _ => { }
                }
            });
            if cur_state == 2 {
                return self.cell.borrow(
                    Tracked(readonly_points_to.tracked_borrow()),
                ).as_ref().unwrap();
                let mut do_initialization = (cur_state == 0);
                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;
                if do_initialization {
                    let res =
                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);
                        returning res; ghost g =>
                    {
                        g = match g {
                            GhostState::Uninitialized(pt) => {
                                points_to = Some(pt);
                                GhostState::Initializing
                            }
                            GhostState::Initializing => {
                                GhostState::Initializing
                            }
                            GhostState::Initialized(x) => {
                                GhostState::Initialized(x)
                            }
                        };
                    });
                    if res.is_err() {
                        do_initialization = false;
                    }
                }
                if do_initialization {
                    let t = T::initialize();
                    let tracked mut points_to = points_to.tracked_unwrap();
                    self.cell.replace(Tracked(&mut points_to), Some(t));
                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);
                    atomic_with_ghost!(&self.state => store(2); ghost g => {
                        g = GhostState::Initialized(static_points_to);
                    });
                }
            }
        }
    }
}
struct X {}
impl Initializable for X {
    fn initialize() -> Self {
        X {  }
    }
}
exec static LAZY_X: Lazy<X>
    ensures
        LAZY_X.wf(),
{
    Lazy::<X>::new()
}
fn get_lazy_x() -> &'static X {     LAZY_X.get() } fn main() { } }  ","[""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::prelude::*;\nuse vstd::*;\nuse vstd::raw_ptr::MemContents;\n\nuse std::sync::atomic::*;\n\nverus! {\n\n// A simple counter, albeit with nothing verified about it.\nexec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n\nfn increment_counter() {\n    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);\n}\n\n// Thread-safe lazy initialization\npub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>),\n}\n\nstruct_with_invariants!{\n    struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            // State = 0: Uninitialized\n            // State = 1: currently initializing\n            // State = 2: is initialized\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() === MemContents::Init(None))\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                    v == 2\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\n\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\n\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n\n    fn get<'a>(&'a self) -> &'a T\n        requires\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                // Already initialized.\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n            } else {\n                // Initialization is required. Try to take the lock if initialization\n                // isn't already in progress.\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        // don't initialize after all\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    // Do initialization\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();\n                } else {\n                    // Wait for initialization to complete by a different thread\n                    // (Try again in the next iteration of the loop.)\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nstruct X {}\n\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\n\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\n\nfn get_lazy_x() -> &'static X {\n    LAZY_X.get()\n}\n\nfn main() {\n}\n\n} // verus!\n"", "" use cell::*;\n                                 use prelude::*;\n                                 use vstd::*;\n                                 verus! {                             pub enum a<h: 'static> {\n    Initialized(&'static PointsTo<Option<h>>)}\n                                 struct_with_invariants!{                                 struct b<h: 'static> {\n        cell: PCell<Option<h>>,\n        c:atomic_ghost::AtomicU64<_, a<h>, _>\n    }\n    spec fn d(self) -> bool {\n        invariant c with (cell) (e: u64, f: a<h>) {\n            match f {\n                a::Initialized(g) => \n                      g.id() == cell.id()\n            }\n        }\n    }\n}\n   fn main() ;\n   }\n"", ""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n  use vstd::prelude::*;\n  use vstd::*;\n  use std::sync::atomic::*;\n  verus! {\n exec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n fn increment_counter() {     GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed); }\n pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n  struct_with_invariants!{\n     struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {         loop             invariant                 self.wf(),         {             let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                }\n            }\n        }\n    }\n}\nstruct X {}\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\nfn get_lazy_x() -> &'static X {     LAZY_X.get() } fn main() { } }  "", ""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n  use vstd::prelude::*;\n  use vstd::*;\n  use std::sync::atomic::*;\n  verus! {\n exec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n fn increment_counter() {     GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed); }\n pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n  struct_with_invariants!{\n     struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {         loop             invariant                 self.wf(),         {             let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n                let mut do_initialization = (cur_state == 0);\n                if do_initialization {\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                }\n            }\n        }\n    }\n}\nstruct X {}\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\nfn get_lazy_x() -> &'static X {     LAZY_X.get() } fn main() { } }  "", ""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n        use vstd::prelude::*;\n        use vstd::*;\n        verus! {\n       pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n        struct_with_invariants!{\n           struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {\n              loop             invariant                 self.wf(),         {}\n    }\n}\nstruct X ;\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X \n    }\n}\nexec static LAZY_X: Lazy<X>\n    ensures\n{\n    Lazy::<X>::new()\n}\n fn main() ;\n }\n"", ""#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n use vstd::cell::*;\n          use vstd::prelude::*;\n          use vstd::*;\n          verus! {\n        pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n          struct_with_invariants!{\n            struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => \n                      && points_to.id() == cell.id()\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n    fn get<'a>(&'a self) -> &'a T         requires             self.wf(),     {               loop             invariant                 self.wf(),         {}     }\n }\n   fn main() ;\n   }\n"", "" use vstd::cell::*;\n            use vstd::prelude::*;\n            use vstd::*;\n            verus! {\n          pub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>), }\n            struct_with_invariants!{\n              struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => \n                      && points_to.id() == cell.id()\n            }\n        }\n    }\n}\ntrait Initializable: Sized {\n}\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n }\n   fn main() ;\n   }\n"", "" use cell::*;\n                use prelude::*;\n                use vstd::*;\n                verus! {\n              pub enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static PointsTo<Option<T>>)}\n                struct_with_invariants!{\n                  struct Lazy<T: 'static> {\n        cell: PCell<Option<T>>,\n        state:atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n    spec fn wf(self) -> bool {\n        invariant state with (cell) (v: u64, g: GhostState<T>) {\n            match g {\n                (points_to) => {\n                    v == 0\n                }\n                GhostStateInitializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => \n                      points_to.id() == cell.id()\n            }\n        }\n    }\n}\nimpl<T: > Lazy<T> {\n    fn new() -> (Self)\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state:atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)))}\n    }\n }\n   fn main() ;\n   }\n"", "" use cell::*;\n                use prelude::*;\n                use vstd::*;\n                verus! {\n              pub enum a<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static PointsTo<Option<T>>)}\n                struct_with_invariants!{\n                  struct b<T: 'static> {\n        cell: PCell<Option<T>>,\n        c:atomic_ghost::AtomicU64<_, a<T>, _>\n    }\n    spec fn d(self) -> bool {\n        invariant c with (cell) (e: u64, f: a<T>) {\n            match f {\n                points_to => {\n                    e == 0\n                }\n                a::Initialized(points_to) => \n                      points_to.id() == cell.id()\n            }\n        }\n    }\n}\nimpl<T > b<T> {\n    fn new() -> Self\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        b {\n            cell: pcell,\n            c:atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(a::Uninitialized(points_to)))}\n    }\n }\n   fn main() ;\n   }\n"", "" use cell::*;\n                use prelude::*;\n                use vstd::*;\n                verus! {\n              pub enum a<T: 'static> {\n    Uninitialized(),\n    Initializing,\n    Initialized(&'static PointsTo<Option<T>>)}\n                struct_with_invariants!{\n                  struct b<T: 'static> {\n        cell: PCell<Option<T>>,\n        c:atomic_ghost::AtomicU64<_, a<T>, _>\n    }\n    spec fn d(self) -> bool {\n        invariant c with (cell) (e: u64, f: a<T>) {\n            match f {\n                g => {\n                    e == 0\n                }\n                a::Initialized(g) => \n                      g.id() == cell.id()\n            }\n        }\n    }\n}\nimpl<T > b<T> {}\n   fn main() ;\n   }\n"", "" use cell::*;\n                 use prelude::*;\n                 use vstd::*;\n                 verus! {               pub enum a<T: 'static> {\n    Initialized(&'static PointsTo<Option<T>>)}\n                 struct_with_invariants!{                   struct b<T: 'static> {\n        cell: PCell<Option<T>>,\n        c:atomic_ghost::AtomicU64<_, a<T>, _>\n    }\n    spec fn d(self) -> bool {\n        invariant c with (cell) (e: u64, f: a<T>) {\n            match f {\n                g => {\n                    e == 0\n                }\n                a::Initialized(g) => \n                      g.id() == cell.id()\n            }\n        }\n    }\n}\n   fn main() ;\n   }\n""]"
/Users/ameliakuang/Repos/dep_verus/examples/std_test/num.rs,237,237,1.0,311.191,True,0.6499999999999999,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::pervasive::runtime_assert', 'vstd::prelude::']",True,,,,,,"#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::pervasive::runtime_assert;
use vstd::prelude::*;

verus! {

fn test_u32_checked_add() {
    runtime_assert(u32::MAX.checked_add(1).is_none());
    runtime_assert((u32::MAX - 1).checked_add(1).unwrap() == u32::MAX);
    runtime_assert(5u32.checked_add(10).unwrap() == 15);
}

fn test_u32_checked_add_signed() {
    runtime_assert(1u32.checked_add_signed(-2).is_none());
    runtime_assert(1u32.checked_add_signed(-1).unwrap() == 0);
    runtime_assert(5u32.checked_add_signed(10).unwrap() == 15);
}

fn test_u32_checked_sub() {
    runtime_assert(1u32.checked_sub(2).is_none());
    runtime_assert(1u32.checked_sub(1).unwrap() == 0);
    runtime_assert(u32::MAX.checked_sub(u32::MAX).unwrap() == 0);
    runtime_assert(10u32.checked_sub(5).unwrap() == 5);
}

fn test_u32_checked_mul() {
    runtime_assert(u32::MAX.checked_mul(2).is_none());
    runtime_assert(u32::MAX.checked_mul(1).unwrap() == u32::MAX);
    runtime_assert(u32::MAX.checked_mul(0).unwrap() == 0);
    runtime_assert((u32::MAX / 2).checked_mul(4).is_none());
    runtime_assert(5u32.checked_mul(10).unwrap() == 50);
}

fn test_u32_checked_div() {
    runtime_assert(u32::MAX.checked_div(0).is_none());
    runtime_assert(u32::MAX.checked_div(1).unwrap() == u32::MAX);
    runtime_assert(10u32.checked_div(5).unwrap() == 2);
}

fn test_u32_checked_div_euclid() {
    runtime_assert(u32::MAX.checked_div_euclid(0).is_none());
    runtime_assert(u32::MAX.checked_div_euclid(1).unwrap() == u32::MAX);
    runtime_assert(10u32.checked_div_euclid(5).unwrap() == 2);
}

fn test_u32_checked_rem() {
    runtime_assert(u32::MAX.checked_rem(0).is_none());
    runtime_assert(0u32.checked_rem(0).is_none());
    runtime_assert(0u32.checked_rem(1).unwrap() == 0);
    runtime_assert(7u32.checked_rem(2).unwrap() == 1);
}

fn test_u32_checked_rem_euclid() {
    runtime_assert(u32::MAX.checked_rem_euclid(0).is_none());
    runtime_assert(0u32.checked_rem_euclid(0).is_none());
    runtime_assert(0u32.checked_rem_euclid(1).unwrap() == 0);
    runtime_assert(7u32.checked_rem_euclid(2).unwrap() == 1);
}

fn test_i32_checked_add() {
    let neg_ten: i32 = -10;
    runtime_assert(i32::MAX.checked_add(1).is_none());
    runtime_assert((i32::MAX - 2).checked_add(1).unwrap() == i32::MAX - 1);
    runtime_assert(i32::MIN.checked_add(-1).is_none());
    runtime_assert(i32::MIN.checked_add(1).unwrap() == i32::MIN + 1);
    runtime_assert(neg_ten.checked_add(5).unwrap() == -5);
    runtime_assert(10i32.checked_add(5).unwrap() == 15);
    runtime_assert(10i32.checked_add(-5).unwrap() == 5);
    runtime_assert(neg_ten.checked_add(-5).unwrap() == -15);
}

fn test_i32_checked_add_unsigned() {
    let neg_ten: i32 = -10;
    runtime_assert(i32::MAX.checked_add_unsigned(1).is_none());
    runtime_assert((i32::MAX - 1).checked_add_unsigned(1).unwrap() == i32::MAX);
    runtime_assert(i32::MIN.checked_add_unsigned(10).unwrap() == i32::MIN + 10);
    runtime_assert(i32::MIN.checked_add_unsigned(u32::MAX).unwrap() == i32::MAX);
    runtime_assert(neg_ten.checked_add_unsigned(5).unwrap() == -5);
}

fn test_i32_checked_sub() {
    runtime_assert((i32::MIN + 2).checked_sub(1).unwrap() == i32::MIN + 1);
    runtime_assert((i32::MIN + 2).checked_sub(3).is_none());
    runtime_assert(i32::MIN.checked_sub(i32::MIN).unwrap() == 0);
    runtime_assert(i32::MIN.checked_sub(i32::MAX).is_none());
    runtime_assert(0i32.checked_sub(i32::MIN).is_none());
    runtime_assert(0i32.checked_sub(i32::MAX).unwrap() == i32::MIN + 1);
}

fn test_i32_checked_sub_unsigned() {
    let neg_five: i32 = -5;
    runtime_assert(i32::MIN.checked_sub_unsigned(1).is_none());
    runtime_assert((i32::MIN + 1).checked_sub_unsigned(1).unwrap() == i32::MIN);
    runtime_assert(0i32.checked_sub_unsigned(2147483647u32).unwrap() == i32::MIN + 1);
    runtime_assert(neg_five.checked_sub_unsigned(5).unwrap() == -10);
}

fn test_i32_checked_mul() {
    let neg_ten: i32 = -10;
    runtime_assert(i32::MIN.checked_mul(1).unwrap() == i32::MIN);
    runtime_assert(i32::MIN.checked_mul(-1).is_none());
    runtime_assert(i32::MAX.checked_mul(1).unwrap() == i32::MAX);
    runtime_assert(i32::MAX.checked_mul(-1).unwrap() == i32::MIN + 1);
    runtime_assert(i32::MAX.checked_mul(2).is_none());
    runtime_assert(neg_ten.checked_mul(-5).unwrap() == 50);
}

fn test_i32_checked_div() {
    let neg_ten: i32 = -10;
    let lhs: i32 = -97;
    runtime_assert(1i32.checked_div(0).is_none());
    runtime_assert(i32::MIN.checked_div(1).unwrap() == i32::MIN);
    runtime_assert(i32::MAX.checked_div(1).unwrap() == i32::MAX);
    runtime_assert(i32::MIN.checked_div(-1).is_none());
    runtime_assert(i32::MAX.checked_div(-1).unwrap() == i32::MIN + 1);
    runtime_assert(10i32.checked_div(-5).unwrap() == -2);
    runtime_assert(10i32.checked_div(5).unwrap() == 2);
    runtime_assert(neg_ten.checked_div(-5).unwrap() == 2);
    runtime_assert(neg_ten.checked_div(5).unwrap() == -2);
    runtime_assert(97i32.checked_div(-7).unwrap() == -13);
    runtime_assert(97i32.checked_div(7).unwrap() == 13);
    runtime_assert(lhs.checked_div(-7).unwrap() == 13);
    runtime_assert(lhs.checked_div(7).unwrap() == -13);
    let lhs: i32 = -47;
    runtime_assert(47i32.checked_div(-7).unwrap() == -6);
    runtime_assert(47i32.checked_div(7).unwrap() == 6);
    runtime_assert(lhs.checked_div(-7).unwrap() == 6);
    runtime_assert(lhs.checked_div(7).unwrap() == -6);
    runtime_assert(47i32.checked_div(-2).unwrap() == -23);
    runtime_assert(47i32.checked_div(2).unwrap() == 23);
    runtime_assert(lhs.checked_div(-2).unwrap() == 23);
    runtime_assert(lhs.checked_div(2).unwrap() == -23);
    let lhs: i32 = -73;
    runtime_assert(73i32.checked_div(-5).unwrap() == -14);
    runtime_assert(73i32.checked_div(5).unwrap() == 14);
    runtime_assert(lhs.checked_div(-5).unwrap() == 14);
    runtime_assert(lhs.checked_div(5).unwrap() == -14);
    runtime_assert(73i32.checked_div(-47).unwrap() == -1);
    runtime_assert(73i32.checked_div(47).unwrap() == 1);
    runtime_assert(lhs.checked_div(-47).unwrap() == 1);
    runtime_assert(lhs.checked_div(47).unwrap() == -1);
}

fn test_i32_checked_div_euclid() {
    let lhs: i32 = -97;
    runtime_assert(1i32.checked_div_euclid(0).is_none());
    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);
    runtime_assert(i32::MIN.checked_div_euclid(-1).is_none());
    runtime_assert(i32::MAX.checked_div_euclid(1).unwrap() == i32::MAX);
    runtime_assert(i32::MIN.checked_div_euclid(1).unwrap() == i32::MIN);
    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);
    runtime_assert(97i32.checked_div_euclid(-7).unwrap() == -13);
    runtime_assert(97i32.checked_div_euclid(7).unwrap() == 13);
    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 14);
    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -14);
    let lhs: i32 = -47;
    runtime_assert(47i32.checked_div_euclid(-7).unwrap() == -6);
    runtime_assert(47i32.checked_div_euclid(7).unwrap() == 6);
    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 7);
    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -7);
    runtime_assert(47i32.checked_div_euclid(-2).unwrap() == -23);
    runtime_assert(47i32.checked_div_euclid(2).unwrap() == 23);
    runtime_assert(lhs.checked_div_euclid(-2).unwrap() == 24);
    runtime_assert(lhs.checked_div_euclid(2).unwrap() == -24);
    let lhs: i32 = -73;
    runtime_assert(73i32.checked_div_euclid(-5).unwrap() == -14);
    runtime_assert(73i32.checked_div_euclid(5).unwrap() == 14);
    runtime_assert(lhs.checked_div_euclid(-5).unwrap() == 15);
    runtime_assert(lhs.checked_div_euclid(5).unwrap() == -15);
    runtime_assert(73i32.checked_div_euclid(-47).unwrap() == -1);
    runtime_assert(73i32.checked_div_euclid(47).unwrap() == 1);
    runtime_assert(lhs.checked_div_euclid(-47).unwrap() == 2);
    runtime_assert(lhs.checked_div_euclid(47).unwrap() == -2);
}

fn test_i32_checked_rem() {
    let lhs: i32 = -97;
    runtime_assert(1i32.checked_rem(0).is_none());
    runtime_assert(lhs.checked_rem(1).unwrap() == 0);
    runtime_assert(97i32.checked_rem(7).unwrap() == 6);
    runtime_assert(97i32.checked_rem(-7).unwrap() == 6);
    runtime_assert(lhs.checked_rem(7).unwrap() == -6);
    runtime_assert(lhs.checked_rem(-7).unwrap() == -6);
    let lhs: i32 = -47;
    runtime_assert(47i32.checked_rem(-7).unwrap() == 5);
    runtime_assert(47i32.checked_rem(7).unwrap() == 5);
    runtime_assert(lhs.checked_rem(-7).unwrap() == -5);
    runtime_assert(lhs.checked_rem(7).unwrap() == -5);
    runtime_assert(47i32.checked_rem(-2).unwrap() == 1);
    runtime_assert(47i32.checked_rem(2).unwrap() == 1);
    runtime_assert(lhs.checked_rem(-2).unwrap() == -1);
    runtime_assert(lhs.checked_rem(2).unwrap() == -1);
    let lhs: i32 = -73;
    runtime_assert(73i32.checked_rem(-5).unwrap() == 3);
    runtime_assert(73i32.checked_rem(5).unwrap() == 3);
    runtime_assert(lhs.checked_rem(-5).unwrap() == -3);
    runtime_assert(lhs.checked_rem(5).unwrap() == -3);
    runtime_assert(73i32.checked_rem(-47).unwrap() == 26);
    runtime_assert(73i32.checked_rem(47).unwrap() == 26);
    runtime_assert(lhs.checked_rem(-47).unwrap() == -26);
    runtime_assert(lhs.checked_rem(47).unwrap() == -26);
}

fn test_i32_checked_rem_euclid() {
    let lhs: i32 = -97;
    runtime_assert(1i32.checked_rem_euclid(0).is_none());
    runtime_assert(lhs.checked_rem_euclid(1).unwrap() == 0);
    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 1);
    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 1);
    runtime_assert(97i32.checked_rem_euclid(7).unwrap() == 6);
    runtime_assert(97i32.checked_rem_euclid(-7).unwrap() == 6);
    let lhs: i32 = -47;
    runtime_assert(47i32.checked_rem_euclid(-7).unwrap() == 5);
    runtime_assert(47i32.checked_rem_euclid(7).unwrap() == 5);
    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 2);
    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 2);
    runtime_assert(47i32.checked_rem_euclid(-2).unwrap() == 1);
    runtime_assert(47i32.checked_rem_euclid(2).unwrap() == 1);
    runtime_assert(lhs.checked_rem_euclid(-2).unwrap() == 1);
    runtime_assert(lhs.checked_rem_euclid(2).unwrap() == 1);
    let lhs: i32 = -73;
    runtime_assert(73i32.checked_rem_euclid(-5).unwrap() == 3);
    runtime_assert(73i32.checked_rem_euclid(5).unwrap() == 3);
    runtime_assert(lhs.checked_rem_euclid(-5).unwrap() == 2);
    runtime_assert(lhs.checked_rem_euclid(5).unwrap() == 2);
    runtime_assert(73i32.checked_rem_euclid(-47).unwrap() == 26);
    runtime_assert(73i32.checked_rem_euclid(47).unwrap() == 26);
    runtime_assert(lhs.checked_rem_euclid(-47).unwrap() == 21);
    runtime_assert(lhs.checked_rem_euclid(47).unwrap() == 21);
}

fn main() {
}

} // verus!
","#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::pervasive::runtime_assert;
use vstd::prelude::*;

verus! {

fn test_u32_checked_add() {
    runtime_assert(u32::MAX.checked_add(1).is_none());
    runtime_assert((u32::MAX - 1).checked_add(1).unwrap() == u32::MAX);
    runtime_assert(5u32.checked_add(10).unwrap() == 15);
}

fn test_u32_checked_add_signed() {
    runtime_assert(1u32.checked_add_signed(-2).is_none());
    runtime_assert(1u32.checked_add_signed(-1).unwrap() == 0);
    runtime_assert(5u32.checked_add_signed(10).unwrap() == 15);
}

fn test_u32_checked_sub() {
    runtime_assert(1u32.checked_sub(2).is_none());
    runtime_assert(1u32.checked_sub(1).unwrap() == 0);
    runtime_assert(u32::MAX.checked_sub(u32::MAX).unwrap() == 0);
    runtime_assert(10u32.checked_sub(5).unwrap() == 5);
}

fn test_u32_checked_mul() {
    runtime_assert(u32::MAX.checked_mul(2).is_none());
    runtime_assert(u32::MAX.checked_mul(1).unwrap() == u32::MAX);
    runtime_assert(u32::MAX.checked_mul(0).unwrap() == 0);
    runtime_assert((u32::MAX / 2).checked_mul(4).is_none());
    runtime_assert(5u32.checked_mul(10).unwrap() == 50);
}

fn test_u32_checked_div() {
    runtime_assert(u32::MAX.checked_div(0).is_none());
    runtime_assert(u32::MAX.checked_div(1).unwrap() == u32::MAX);
    runtime_assert(10u32.checked_div(5).unwrap() == 2);
}

fn test_u32_checked_div_euclid() {
    runtime_assert(u32::MAX.checked_div_euclid(0).is_none());
    runtime_assert(u32::MAX.checked_div_euclid(1).unwrap() == u32::MAX);
    runtime_assert(10u32.checked_div_euclid(5).unwrap() == 2);
}

fn test_u32_checked_rem() {
    runtime_assert(u32::MAX.checked_rem(0).is_none());
    runtime_assert(0u32.checked_rem(0).is_none());
    runtime_assert(0u32.checked_rem(1).unwrap() == 0);
    runtime_assert(7u32.checked_rem(2).unwrap() == 1);
}

fn test_u32_checked_rem_euclid() {
    runtime_assert(u32::MAX.checked_rem_euclid(0).is_none());
    runtime_assert(0u32.checked_rem_euclid(0).is_none());
    runtime_assert(0u32.checked_rem_euclid(1).unwrap() == 0);
    runtime_assert(7u32.checked_rem_euclid(2).unwrap() == 1);
}

fn test_i32_checked_add() {
    let neg_ten: i32 = -10;
    runtime_assert(i32::MAX.checked_add(1).is_none());
    runtime_assert((i32::MAX - 2).checked_add(1).unwrap() == i32::MAX - 1);
    runtime_assert(i32::MIN.checked_add(-1).is_none());
    runtime_assert(i32::MIN.checked_add(1).unwrap() == i32::MIN + 1);
    runtime_assert(neg_ten.checked_add(5).unwrap() == -5);
    runtime_assert(10i32.checked_add(5).unwrap() == 15);
    runtime_assert(10i32.checked_add(-5).unwrap() == 5);
    runtime_assert(neg_ten.checked_add(-5).unwrap() == -15);
}

fn test_i32_checked_add_unsigned() {
    let neg_ten: i32 = -10;
    runtime_assert(i32::MAX.checked_add_unsigned(1).is_none());
    runtime_assert((i32::MAX - 1).checked_add_unsigned(1).unwrap() == i32::MAX);
    runtime_assert(i32::MIN.checked_add_unsigned(10).unwrap() == i32::MIN + 10);
    runtime_assert(i32::MIN.checked_add_unsigned(u32::MAX).unwrap() == i32::MAX);
    runtime_assert(neg_ten.checked_add_unsigned(5).unwrap() == -5);
}

fn test_i32_checked_sub() {
    runtime_assert((i32::MIN + 2).checked_sub(1).unwrap() == i32::MIN + 1);
    runtime_assert((i32::MIN + 2).checked_sub(3).is_none());
    runtime_assert(i32::MIN.checked_sub(i32::MIN).unwrap() == 0);
    runtime_assert(i32::MIN.checked_sub(i32::MAX).is_none());
    runtime_assert(0i32.checked_sub(i32::MIN).is_none());
    runtime_assert(0i32.checked_sub(i32::MAX).unwrap() == i32::MIN + 1);
}

fn test_i32_checked_sub_unsigned() {
    let neg_five: i32 = -5;
    runtime_assert(i32::MIN.checked_sub_unsigned(1).is_none());
    runtime_assert((i32::MIN + 1).checked_sub_unsigned(1).unwrap() == i32::MIN);
    runtime_assert(0i32.checked_sub_unsigned(2147483647u32).unwrap() == i32::MIN + 1);
    runtime_assert(neg_five.checked_sub_unsigned(5).unwrap() == -10);
}

fn test_i32_checked_mul() {
    let neg_ten: i32 = -10;
    runtime_assert(i32::MIN.checked_mul(1).unwrap() == i32::MIN);
    runtime_assert(i32::MIN.checked_mul(-1).is_none());
    runtime_assert(i32::MAX.checked_mul(1).unwrap() == i32::MAX);
    runtime_assert(i32::MAX.checked_mul(-1).unwrap() == i32::MIN + 1);
    runtime_assert(i32::MAX.checked_mul(2).is_none());
    runtime_assert(neg_ten.checked_mul(-5).unwrap() == 50);
}

fn test_i32_checked_div() {
    let neg_ten: i32 = -10;
    let lhs: i32 = -97;
    runtime_assert(1i32.checked_div(0).is_none());
    runtime_assert(i32::MIN.checked_div(1).unwrap() == i32::MIN);
    runtime_assert(i32::MAX.checked_div(1).unwrap() == i32::MAX);
    runtime_assert(i32::MIN.checked_div(-1).is_none());
    runtime_assert(i32::MAX.checked_div(-1).unwrap() == i32::MIN + 1);
    runtime_assert(10i32.checked_div(-5).unwrap() == -2);
    runtime_assert(10i32.checked_div(5).unwrap() == 2);
    runtime_assert(neg_ten.checked_div(-5).unwrap() == 2);
    runtime_assert(neg_ten.checked_div(5).unwrap() == -2);
    runtime_assert(97i32.checked_div(-7).unwrap() == -13);
    runtime_assert(97i32.checked_div(7).unwrap() == 13);
    runtime_assert(lhs.checked_div(-7).unwrap() == 13);
    runtime_assert(lhs.checked_div(7).unwrap() == -13);
    let lhs: i32 = -47;
    runtime_assert(47i32.checked_div(-7).unwrap() == -6);
    runtime_assert(47i32.checked_div(7).unwrap() == 6);
    runtime_assert(lhs.checked_div(-7).unwrap() == 6);
    runtime_assert(lhs.checked_div(7).unwrap() == -6);
    runtime_assert(47i32.checked_div(-2).unwrap() == -23);
    runtime_assert(47i32.checked_div(2).unwrap() == 23);
    runtime_assert(lhs.checked_div(-2).unwrap() == 23);
    runtime_assert(lhs.checked_div(2).unwrap() == -23);
    let lhs: i32 = -73;
    runtime_assert(73i32.checked_div(-5).unwrap() == -14);
    runtime_assert(73i32.checked_div(5).unwrap() == 14);
    runtime_assert(lhs.checked_div(-5).unwrap() == 14);
    runtime_assert(lhs.checked_div(5).unwrap() == -14);
    runtime_assert(73i32.checked_div(-47).unwrap() == -1);
    runtime_assert(73i32.checked_div(47).unwrap() == 1);
    runtime_assert(lhs.checked_div(-47).unwrap() == 1);
    runtime_assert(lhs.checked_div(47).unwrap() == -1);
}

fn test_i32_checked_div_euclid() {
    let lhs: i32 = -97;
    runtime_assert(1i32.checked_div_euclid(0).is_none());
    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);
    runtime_assert(i32::MIN.checked_div_euclid(-1).is_none());
    runtime_assert(i32::MAX.checked_div_euclid(1).unwrap() == i32::MAX);
    runtime_assert(i32::MIN.checked_div_euclid(1).unwrap() == i32::MIN);
    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);
    runtime_assert(97i32.checked_div_euclid(-7).unwrap() == -13);
    runtime_assert(97i32.checked_div_euclid(7).unwrap() == 13);
    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 14);
    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -14);
    let lhs: i32 = -47;
    runtime_assert(47i32.checked_div_euclid(-7).unwrap() == -6);
    runtime_assert(47i32.checked_div_euclid(7).unwrap() == 6);
    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 7);
    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -7);
    runtime_assert(47i32.checked_div_euclid(-2).unwrap() == -23);
    runtime_assert(47i32.checked_div_euclid(2).unwrap() == 23);
    runtime_assert(lhs.checked_div_euclid(-2).unwrap() == 24);
    runtime_assert(lhs.checked_div_euclid(2).unwrap() == -24);
    let lhs: i32 = -73;
    runtime_assert(73i32.checked_div_euclid(-5).unwrap() == -14);
    runtime_assert(73i32.checked_div_euclid(5).unwrap() == 14);
    runtime_assert(lhs.checked_div_euclid(-5).unwrap() == 15);
    runtime_assert(lhs.checked_div_euclid(5).unwrap() == -15);
    runtime_assert(73i32.checked_div_euclid(-47).unwrap() == -1);
    runtime_assert(73i32.checked_div_euclid(47).unwrap() == 1);
    runtime_assert(lhs.checked_div_euclid(-47).unwrap() == 2);
    runtime_assert(lhs.checked_div_euclid(47).unwrap() == -2);
}

fn test_i32_checked_rem() {
    let lhs: i32 = -97;
    runtime_assert(1i32.checked_rem(0).is_none());
    runtime_assert(lhs.checked_rem(1).unwrap() == 0);
    runtime_assert(97i32.checked_rem(7).unwrap() == 6);
    runtime_assert(97i32.checked_rem(-7).unwrap() == 6);
    runtime_assert(lhs.checked_rem(7).unwrap() == -6);
    runtime_assert(lhs.checked_rem(-7).unwrap() == -6);
    let lhs: i32 = -47;
    runtime_assert(47i32.checked_rem(-7).unwrap() == 5);
    runtime_assert(47i32.checked_rem(7).unwrap() == 5);
    runtime_assert(lhs.checked_rem(-7).unwrap() == -5);
    runtime_assert(lhs.checked_rem(7).unwrap() == -5);
    runtime_assert(47i32.checked_rem(-2).unwrap() == 1);
    runtime_assert(47i32.checked_rem(2).unwrap() == 1);
    runtime_assert(lhs.checked_rem(-2).unwrap() == -1);
    runtime_assert(lhs.checked_rem(2).unwrap() == -1);
    let lhs: i32 = -73;
    runtime_assert(73i32.checked_rem(-5).unwrap() == 3);
    runtime_assert(73i32.checked_rem(5).unwrap() == 3);
    runtime_assert(lhs.checked_rem(-5).unwrap() == -3);
    runtime_assert(lhs.checked_rem(5).unwrap() == -3);
    runtime_assert(73i32.checked_rem(-47).unwrap() == 26);
    runtime_assert(73i32.checked_rem(47).unwrap() == 26);
    runtime_assert(lhs.checked_rem(-47).unwrap() == -26);
    runtime_assert(lhs.checked_rem(47).unwrap() == -26);
}

fn test_i32_checked_rem_euclid() {
    let lhs: i32 = -97;
    runtime_assert(1i32.checked_rem_euclid(0).is_none());
    runtime_assert(lhs.checked_rem_euclid(1).unwrap() == 0);
    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 1);
    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 1);
    runtime_assert(97i32.checked_rem_euclid(7).unwrap() == 6);
    runtime_assert(97i32.checked_rem_euclid(-7).unwrap() == 6);
    let lhs: i32 = -47;
    runtime_assert(47i32.checked_rem_euclid(-7).unwrap() == 5);
    runtime_assert(47i32.checked_rem_euclid(7).unwrap() == 5);
    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 2);
    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 2);
    runtime_assert(47i32.checked_rem_euclid(-2).unwrap() == 1);
    runtime_assert(47i32.checked_rem_euclid(2).unwrap() == 1);
    runtime_assert(lhs.checked_rem_euclid(-2).unwrap() == 1);
    runtime_assert(lhs.checked_rem_euclid(2).unwrap() == 1);
    let lhs: i32 = -73;
    runtime_assert(73i32.checked_rem_euclid(-5).unwrap() == 3);
    runtime_assert(73i32.checked_rem_euclid(5).unwrap() == 3);
    runtime_assert(lhs.checked_rem_euclid(-5).unwrap() == 2);
    runtime_assert(lhs.checked_rem_euclid(5).unwrap() == 2);
    runtime_assert(73i32.checked_rem_euclid(-47).unwrap() == 26);
    runtime_assert(73i32.checked_rem_euclid(47).unwrap() == 26);
    runtime_assert(lhs.checked_rem_euclid(-47).unwrap() == 21);
    runtime_assert(lhs.checked_rem_euclid(47).unwrap() == 21);
}

fn main() {
}

} // verus!
","['#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn test_u32_checked_add() {\n    runtime_assert(u32::MAX.checked_add(1).is_none());\n    runtime_assert((u32::MAX - 1).checked_add(1).unwrap() == u32::MAX);\n    runtime_assert(5u32.checked_add(10).unwrap() == 15);\n}\n\nfn test_u32_checked_add_signed() {\n    runtime_assert(1u32.checked_add_signed(-2).is_none());\n    runtime_assert(1u32.checked_add_signed(-1).unwrap() == 0);\n    runtime_assert(5u32.checked_add_signed(10).unwrap() == 15);\n}\n\nfn test_u32_checked_sub() {\n    runtime_assert(1u32.checked_sub(2).is_none());\n    runtime_assert(1u32.checked_sub(1).unwrap() == 0);\n    runtime_assert(u32::MAX.checked_sub(u32::MAX).unwrap() == 0);\n    runtime_assert(10u32.checked_sub(5).unwrap() == 5);\n}\n\nfn test_u32_checked_mul() {\n    runtime_assert(u32::MAX.checked_mul(2).is_none());\n    runtime_assert(u32::MAX.checked_mul(1).unwrap() == u32::MAX);\n    runtime_assert(u32::MAX.checked_mul(0).unwrap() == 0);\n    runtime_assert((u32::MAX / 2).checked_mul(4).is_none());\n    runtime_assert(5u32.checked_mul(10).unwrap() == 50);\n}\n\nfn test_u32_checked_div() {\n    runtime_assert(u32::MAX.checked_div(0).is_none());\n    runtime_assert(u32::MAX.checked_div(1).unwrap() == u32::MAX);\n    runtime_assert(10u32.checked_div(5).unwrap() == 2);\n}\n\nfn test_u32_checked_div_euclid() {\n    runtime_assert(u32::MAX.checked_div_euclid(0).is_none());\n    runtime_assert(u32::MAX.checked_div_euclid(1).unwrap() == u32::MAX);\n    runtime_assert(10u32.checked_div_euclid(5).unwrap() == 2);\n}\n\nfn test_u32_checked_rem() {\n    runtime_assert(u32::MAX.checked_rem(0).is_none());\n    runtime_assert(0u32.checked_rem(0).is_none());\n    runtime_assert(0u32.checked_rem(1).unwrap() == 0);\n    runtime_assert(7u32.checked_rem(2).unwrap() == 1);\n}\n\nfn test_u32_checked_rem_euclid() {\n    runtime_assert(u32::MAX.checked_rem_euclid(0).is_none());\n    runtime_assert(0u32.checked_rem_euclid(0).is_none());\n    runtime_assert(0u32.checked_rem_euclid(1).unwrap() == 0);\n    runtime_assert(7u32.checked_rem_euclid(2).unwrap() == 1);\n}\n\nfn test_i32_checked_add() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MAX.checked_add(1).is_none());\n    runtime_assert((i32::MAX - 2).checked_add(1).unwrap() == i32::MAX - 1);\n    runtime_assert(i32::MIN.checked_add(-1).is_none());\n    runtime_assert(i32::MIN.checked_add(1).unwrap() == i32::MIN + 1);\n    runtime_assert(neg_ten.checked_add(5).unwrap() == -5);\n    runtime_assert(10i32.checked_add(5).unwrap() == 15);\n    runtime_assert(10i32.checked_add(-5).unwrap() == 5);\n    runtime_assert(neg_ten.checked_add(-5).unwrap() == -15);\n}\n\nfn test_i32_checked_add_unsigned() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MAX.checked_add_unsigned(1).is_none());\n    runtime_assert((i32::MAX - 1).checked_add_unsigned(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_add_unsigned(10).unwrap() == i32::MIN + 10);\n    runtime_assert(i32::MIN.checked_add_unsigned(u32::MAX).unwrap() == i32::MAX);\n    runtime_assert(neg_ten.checked_add_unsigned(5).unwrap() == -5);\n}\n\nfn test_i32_checked_sub() {\n    runtime_assert((i32::MIN + 2).checked_sub(1).unwrap() == i32::MIN + 1);\n    runtime_assert((i32::MIN + 2).checked_sub(3).is_none());\n    runtime_assert(i32::MIN.checked_sub(i32::MIN).unwrap() == 0);\n    runtime_assert(i32::MIN.checked_sub(i32::MAX).is_none());\n    runtime_assert(0i32.checked_sub(i32::MIN).is_none());\n    runtime_assert(0i32.checked_sub(i32::MAX).unwrap() == i32::MIN + 1);\n}\n\nfn test_i32_checked_sub_unsigned() {\n    let neg_five: i32 = -5;\n    runtime_assert(i32::MIN.checked_sub_unsigned(1).is_none());\n    runtime_assert((i32::MIN + 1).checked_sub_unsigned(1).unwrap() == i32::MIN);\n    runtime_assert(0i32.checked_sub_unsigned(2147483647u32).unwrap() == i32::MIN + 1);\n    runtime_assert(neg_five.checked_sub_unsigned(5).unwrap() == -10);\n}\n\nfn test_i32_checked_mul() {\n    let neg_ten: i32 = -10;\n    runtime_assert(i32::MIN.checked_mul(1).unwrap() == i32::MIN);\n    runtime_assert(i32::MIN.checked_mul(-1).is_none());\n    runtime_assert(i32::MAX.checked_mul(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MAX.checked_mul(-1).unwrap() == i32::MIN + 1);\n    runtime_assert(i32::MAX.checked_mul(2).is_none());\n    runtime_assert(neg_ten.checked_mul(-5).unwrap() == 50);\n}\n\nfn test_i32_checked_div() {\n    let neg_ten: i32 = -10;\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_div(0).is_none());\n    runtime_assert(i32::MIN.checked_div(1).unwrap() == i32::MIN);\n    runtime_assert(i32::MAX.checked_div(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div(-1).is_none());\n    runtime_assert(i32::MAX.checked_div(-1).unwrap() == i32::MIN + 1);\n    runtime_assert(10i32.checked_div(-5).unwrap() == -2);\n    runtime_assert(10i32.checked_div(5).unwrap() == 2);\n    runtime_assert(neg_ten.checked_div(-5).unwrap() == 2);\n    runtime_assert(neg_ten.checked_div(5).unwrap() == -2);\n    runtime_assert(97i32.checked_div(-7).unwrap() == -13);\n    runtime_assert(97i32.checked_div(7).unwrap() == 13);\n    runtime_assert(lhs.checked_div(-7).unwrap() == 13);\n    runtime_assert(lhs.checked_div(7).unwrap() == -13);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_div(-7).unwrap() == -6);\n    runtime_assert(47i32.checked_div(7).unwrap() == 6);\n    runtime_assert(lhs.checked_div(-7).unwrap() == 6);\n    runtime_assert(lhs.checked_div(7).unwrap() == -6);\n    runtime_assert(47i32.checked_div(-2).unwrap() == -23);\n    runtime_assert(47i32.checked_div(2).unwrap() == 23);\n    runtime_assert(lhs.checked_div(-2).unwrap() == 23);\n    runtime_assert(lhs.checked_div(2).unwrap() == -23);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_div(-5).unwrap() == -14);\n    runtime_assert(73i32.checked_div(5).unwrap() == 14);\n    runtime_assert(lhs.checked_div(-5).unwrap() == 14);\n    runtime_assert(lhs.checked_div(5).unwrap() == -14);\n    runtime_assert(73i32.checked_div(-47).unwrap() == -1);\n    runtime_assert(73i32.checked_div(47).unwrap() == 1);\n    runtime_assert(lhs.checked_div(-47).unwrap() == 1);\n    runtime_assert(lhs.checked_div(47).unwrap() == -1);\n}\n\nfn test_i32_checked_div_euclid() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_div_euclid(0).is_none());\n    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div_euclid(-1).is_none());\n    runtime_assert(i32::MAX.checked_div_euclid(1).unwrap() == i32::MAX);\n    runtime_assert(i32::MIN.checked_div_euclid(1).unwrap() == i32::MIN);\n    runtime_assert((i32::MIN + 1).checked_div_euclid(-1).unwrap() == i32::MAX);\n    runtime_assert(97i32.checked_div_euclid(-7).unwrap() == -13);\n    runtime_assert(97i32.checked_div_euclid(7).unwrap() == 13);\n    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 14);\n    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -14);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_div_euclid(-7).unwrap() == -6);\n    runtime_assert(47i32.checked_div_euclid(7).unwrap() == 6);\n    runtime_assert(lhs.checked_div_euclid(-7).unwrap() == 7);\n    runtime_assert(lhs.checked_div_euclid(7).unwrap() == -7);\n    runtime_assert(47i32.checked_div_euclid(-2).unwrap() == -23);\n    runtime_assert(47i32.checked_div_euclid(2).unwrap() == 23);\n    runtime_assert(lhs.checked_div_euclid(-2).unwrap() == 24);\n    runtime_assert(lhs.checked_div_euclid(2).unwrap() == -24);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_div_euclid(-5).unwrap() == -14);\n    runtime_assert(73i32.checked_div_euclid(5).unwrap() == 14);\n    runtime_assert(lhs.checked_div_euclid(-5).unwrap() == 15);\n    runtime_assert(lhs.checked_div_euclid(5).unwrap() == -15);\n    runtime_assert(73i32.checked_div_euclid(-47).unwrap() == -1);\n    runtime_assert(73i32.checked_div_euclid(47).unwrap() == 1);\n    runtime_assert(lhs.checked_div_euclid(-47).unwrap() == 2);\n    runtime_assert(lhs.checked_div_euclid(47).unwrap() == -2);\n}\n\nfn test_i32_checked_rem() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_rem(0).is_none());\n    runtime_assert(lhs.checked_rem(1).unwrap() == 0);\n    runtime_assert(97i32.checked_rem(7).unwrap() == 6);\n    runtime_assert(97i32.checked_rem(-7).unwrap() == 6);\n    runtime_assert(lhs.checked_rem(7).unwrap() == -6);\n    runtime_assert(lhs.checked_rem(-7).unwrap() == -6);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_rem(-7).unwrap() == 5);\n    runtime_assert(47i32.checked_rem(7).unwrap() == 5);\n    runtime_assert(lhs.checked_rem(-7).unwrap() == -5);\n    runtime_assert(lhs.checked_rem(7).unwrap() == -5);\n    runtime_assert(47i32.checked_rem(-2).unwrap() == 1);\n    runtime_assert(47i32.checked_rem(2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem(-2).unwrap() == -1);\n    runtime_assert(lhs.checked_rem(2).unwrap() == -1);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_rem(-5).unwrap() == 3);\n    runtime_assert(73i32.checked_rem(5).unwrap() == 3);\n    runtime_assert(lhs.checked_rem(-5).unwrap() == -3);\n    runtime_assert(lhs.checked_rem(5).unwrap() == -3);\n    runtime_assert(73i32.checked_rem(-47).unwrap() == 26);\n    runtime_assert(73i32.checked_rem(47).unwrap() == 26);\n    runtime_assert(lhs.checked_rem(-47).unwrap() == -26);\n    runtime_assert(lhs.checked_rem(47).unwrap() == -26);\n}\n\nfn test_i32_checked_rem_euclid() {\n    let lhs: i32 = -97;\n    runtime_assert(1i32.checked_rem_euclid(0).is_none());\n    runtime_assert(lhs.checked_rem_euclid(1).unwrap() == 0);\n    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 1);\n    runtime_assert(97i32.checked_rem_euclid(7).unwrap() == 6);\n    runtime_assert(97i32.checked_rem_euclid(-7).unwrap() == 6);\n    let lhs: i32 = -47;\n    runtime_assert(47i32.checked_rem_euclid(-7).unwrap() == 5);\n    runtime_assert(47i32.checked_rem_euclid(7).unwrap() == 5);\n    runtime_assert(lhs.checked_rem_euclid(-7).unwrap() == 2);\n    runtime_assert(lhs.checked_rem_euclid(7).unwrap() == 2);\n    runtime_assert(47i32.checked_rem_euclid(-2).unwrap() == 1);\n    runtime_assert(47i32.checked_rem_euclid(2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(-2).unwrap() == 1);\n    runtime_assert(lhs.checked_rem_euclid(2).unwrap() == 1);\n    let lhs: i32 = -73;\n    runtime_assert(73i32.checked_rem_euclid(-5).unwrap() == 3);\n    runtime_assert(73i32.checked_rem_euclid(5).unwrap() == 3);\n    runtime_assert(lhs.checked_rem_euclid(-5).unwrap() == 2);\n    runtime_assert(lhs.checked_rem_euclid(5).unwrap() == 2);\n    runtime_assert(73i32.checked_rem_euclid(-47).unwrap() == 26);\n    runtime_assert(73i32.checked_rem_euclid(47).unwrap() == 26);\n    runtime_assert(lhs.checked_rem_euclid(-47).unwrap() == 21);\n    runtime_assert(lhs.checked_rem_euclid(47).unwrap() == 21);\n}\n\nfn main() {\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', '  use vstd::prelude::*;\n        verus! {\n       fn main() {\n      }\n       }\n', '  use vstd::prelude::*;\n        verus! {\n       fn main() ;\n       }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/std_test/option_test.rs,63,63,1.0,0.971,False,0.7999999999999999,True,"['std::option::Option::', 'vstd::pervasive::runtime_assert', 'vstd::prelude::']",True,,,,,,"use std::option::Option::{None, Some};

use vstd::pervasive::runtime_assert;
use vstd::prelude::*;

verus! {

fn is_some_test() {
    let a: Option<i32> = None;
    let b = Some(2);
    runtime_assert(!a.is_some());
    runtime_assert(b.is_some());
}

fn is_none_test() {
    let a: Option<i32> = None;
    let b = Some(2);
    runtime_assert(a.is_none());
    runtime_assert(!b.is_none());
}

fn as_ref_test() {
    let a = Option::Some(2);
    if let Some(ref_val) = a.as_ref() {
        runtime_assert(*ref_val == 2);
    } else {
        runtime_assert(false);
    }
}

fn unwrap_test() {
    let a = Option::Some(2);
    let b = Option::Some(4);
    runtime_assert(a.unwrap() == 2);
    runtime_assert(a.unwrap() != b.unwrap());
}

fn expect_test() {
    let a = Option::Some(2);
    let b = Option::Some(4);
    runtime_assert(a.expect(""is some"") == 2);
    runtime_assert(a.expect(""is some"") != b.expect(""is some""));
}

fn unwrap_or_test() {
    let a = Option::Some(2);
    let b = Option::None;
    runtime_assert(a.unwrap_or(3) == 2);
    runtime_assert(b.unwrap_or(3) == 3);
}

fn ok_or_test() {
    let a: Option<i32> = Option::Some(2);
    let b: Option<i32> = Option::None;
    let ra: Result<i32, bool> = a.ok_or(false);
    let rb: Result<i32, bool> = b.ok_or(false);
    assert(ra.is_ok());
    assert(ra.unwrap() == 2);
    assert(rb.is_err());
    assert(rb.unwrap_err() == false);
}

} // verus!
","use std::option::Option::{None, Some};

use vstd::pervasive::runtime_assert;
use vstd::prelude::*;

verus! {

fn is_some_test() {
    let a: Option<i32> = None;
    let b = Some(2);
    runtime_assert(!a.is_some());
    runtime_assert(b.is_some());
}

fn is_none_test() {
    let a: Option<i32> = None;
    let b = Some(2);
    runtime_assert(a.is_none());
    runtime_assert(!b.is_none());
}

fn as_ref_test() {
    let a = Option::Some(2);
    if let Some(ref_val) = a.as_ref() {
        runtime_assert(*ref_val == 2);
    } else {
        runtime_assert(false);
    }
}

fn unwrap_test() {
    let a = Option::Some(2);
    let b = Option::Some(4);
    runtime_assert(a.unwrap() == 2);
    runtime_assert(a.unwrap() != b.unwrap());
}

fn expect_test() {
    let a = Option::Some(2);
    let b = Option::Some(4);
    runtime_assert(a.expect(""is some"") == 2);
    runtime_assert(a.expect(""is some"") != b.expect(""is some""));
}

fn unwrap_or_test() {
    let a = Option::Some(2);
    let b = Option::None;
    runtime_assert(a.unwrap_or(3) == 2);
    runtime_assert(b.unwrap_or(3) == 3);
}

fn ok_or_test() {
    let a: Option<i32> = Option::Some(2);
    let b: Option<i32> = Option::None;
    let ra: Result<i32, bool> = a.ok_or(false);
    let rb: Result<i32, bool> = b.ok_or(false);
    assert(ra.is_ok());
    assert(ra.unwrap() == 2);
    assert(rb.is_err());
    assert(rb.unwrap_err() == false);
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/std_test/result.rs,65,65,1.0,0.954,False,0.7999999999999999,True,"['vstd::pervasive::runtime_assert', 'vstd::prelude::']",True,,,,,,"use vstd::pervasive::runtime_assert;
use vstd::prelude::*;

verus! {

fn is_ok_test() {
    let r1: Result<i32, i32> = Ok(7);
    runtime_assert(r1.is_ok() == true);
    let r2: Result<i32, i32> = Err(7);
    runtime_assert(r2.is_ok() == false);
    let r3: Result<i32, bool> = Err(true);
    runtime_assert(r3.is_ok() == false);
}

fn map_test() {
    let r1: Result<i32, i32> = Ok(7);
    let op = |x: i32| -> (y: i32)
        requires
            x < 100000,
        ensures
            y > x,
        { x + 1 };
    let r2 = r1.map(op);
    runtime_assert(r2.unwrap() > 7);
    let r3: Result<i32, i32> = Err(9);
    let r4: Result<i32, i32> = r3.map(op);
    runtime_assert(r4.unwrap_err() == 9);
}

fn ok_test() {
    let r1: Result<i32, i32> = Ok(7);
    runtime_assert(r1.ok().is_some());
    runtime_assert(r1.ok().unwrap() == 7);
    let r2: Result<i32, i32> = Err(7);
    runtime_assert(r2.ok().is_none());
    let r3: Result<i32, bool> = Err(true);
    runtime_assert(r3.ok().is_none());
    let r4: Result<bool, i32> = Ok(false);
    runtime_assert(r4.ok().is_some());
    runtime_assert(r4.ok().unwrap() == false);
}

fn err_test() {
    let r1: Result<i32, i32> = Ok(7);
    runtime_assert(r1.err().is_none());
    let r2: Result<i32, i32> = Err(7);
    runtime_assert(r2.err().is_some());
    runtime_assert(r2.err().unwrap() == 7);
    let r3: Result<i32, bool> = Err(true);
    runtime_assert(r3.err().is_some());
    runtime_assert(r3.err().unwrap() == true);
    let r4: Result<bool, i32> = Ok(true);
    runtime_assert(r4.err().is_none());
}

fn expect_test() {
    let r1: Result<i32, i32> = Ok(7);
    runtime_assert(r1.ok().is_some());
    runtime_assert(r1.ok().expect(""is ok"") == 7);
    let r2: Result<bool, i32> = Ok(false);
    runtime_assert(r2.ok().is_some());
    runtime_assert(r2.ok().expect(""is ok"") == false);
}

} // verus!
","use vstd::pervasive::runtime_assert;
use vstd::prelude::*;

verus! {

fn is_ok_test() {
    let r1: Result<i32, i32> = Ok(7);
    runtime_assert(r1.is_ok() == true);
    let r2: Result<i32, i32> = Err(7);
    runtime_assert(r2.is_ok() == false);
    let r3: Result<i32, bool> = Err(true);
    runtime_assert(r3.is_ok() == false);
}

fn map_test() {
    let r1: Result<i32, i32> = Ok(7);
    let op = |x: i32| -> (y: i32)
        requires
            x < 100000,
        ensures
            y > x,
        { x + 1 };
    let r2 = r1.map(op);
    runtime_assert(r2.unwrap() > 7);
    let r3: Result<i32, i32> = Err(9);
    let r4: Result<i32, i32> = r3.map(op);
    runtime_assert(r4.unwrap_err() == 9);
}

fn ok_test() {
    let r1: Result<i32, i32> = Ok(7);
    runtime_assert(r1.ok().is_some());
    runtime_assert(r1.ok().unwrap() == 7);
    let r2: Result<i32, i32> = Err(7);
    runtime_assert(r2.ok().is_none());
    let r3: Result<i32, bool> = Err(true);
    runtime_assert(r3.ok().is_none());
    let r4: Result<bool, i32> = Ok(false);
    runtime_assert(r4.ok().is_some());
    runtime_assert(r4.ok().unwrap() == false);
}

fn err_test() {
    let r1: Result<i32, i32> = Ok(7);
    runtime_assert(r1.err().is_none());
    let r2: Result<i32, i32> = Err(7);
    runtime_assert(r2.err().is_some());
    runtime_assert(r2.err().unwrap() == 7);
    let r3: Result<i32, bool> = Err(true);
    runtime_assert(r3.err().is_some());
    runtime_assert(r3.err().unwrap() == true);
    let r4: Result<bool, i32> = Ok(true);
    runtime_assert(r4.err().is_none());
}

fn expect_test() {
    let r1: Result<i32, i32> = Ok(7);
    runtime_assert(r1.ok().is_some());
    runtime_assert(r1.ok().expect(""is ok"") == 7);
    let r2: Result<bool, i32> = Ok(false);
    runtime_assert(r2.ok().is_some());
    runtime_assert(r2.ok().expect(""is ok"") == false);
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/std_test/vecdeque_test.rs,63,63,1.0,1.06,False,0.7,True,"['std::collections::VecDeque', 'vstd::pervasive::runtime_assert', 'vstd::std_specs::vecdeque::', 'vstd::prelude::']",True,,,,,,"#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use std::collections::VecDeque;
use vstd::pervasive::runtime_assert;
#[allow(unused_imports)]
use vstd::std_specs::vecdeque::*;
use vstd::prelude::*;

verus! {

fn vec_deque_test()
{
    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();
    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();
    v1.push_back(3);
    v1.push_back(4);
    let front = v1.pop_front();
    runtime_assert(front.is_some());
    runtime_assert(front.unwrap() == 3);
    assert(v1@ == seq![4u32]);

    v2.push_back(5);
    assert(v2.len() == 1);
    v2.push_back(7);
    assert(v2@.len() == 2);
    v2.insert(1, 6);
    assert(v2@ == seq![5u32, 6u32, 7u32]);

    v1.append(&mut v2);
    assert(v2@.len() == 0);
    assert(v1@.len() == 4);
    assert(v1@ == seq![4u32, 5u32, 6u32, 7u32]);
    v1.remove(2);
    assert(v1@ == seq![4u32, 5u32, 7u32]);
    
    let mut x = v1.pop_front();
    runtime_assert(x.is_some());
    runtime_assert(x.unwrap() == 4);
    x = v1.pop_front();
    runtime_assert(x.is_some());
    runtime_assert(x.unwrap() == 5);
    x = v1.pop_front();
    runtime_assert(x.is_some());
    runtime_assert(x.unwrap() == 7);
    x = v1.pop_front();
    runtime_assert(x.is_none());

    v1.push_back(10);
    v1.push_back(11);
    assert(v1@ == seq![10u32, 11u32]);

    let mut i: usize = 0;
    for x in it: v1.iter()
        invariant
            i == it.pos,
            it.elements == seq![10u32, 11u32],
    {
        assert(x > 9);
        assert(x < 12);
        i = i + 1;
    }
}

} // verus!
","#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]
use std::collections::VecDeque;
use vstd::pervasive::runtime_assert;
#[allow(unused_imports)]
use vstd::std_specs::vecdeque::*;
use vstd::prelude::*;

verus! {

fn vec_deque_test()
{
    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();
    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();
    v1.push_back(3);
    v1.push_back(4);
    let front = v1.pop_front();
    runtime_assert(front.is_some());
    runtime_assert(front.unwrap() == 3);
    assert(v1@ == seq![4u32]);

    v2.push_back(5);
    assert(v2.len() == 1);
    v2.push_back(7);
    assert(v2@.len() == 2);
    v2.insert(1, 6);
    assert(v2@ == seq![5u32, 6u32, 7u32]);

    v1.append(&mut v2);
    assert(v2@.len() == 0);
    assert(v1@.len() == 4);
    assert(v1@ == seq![4u32, 5u32, 6u32, 7u32]);
    v1.remove(2);
    assert(v1@ == seq![4u32, 5u32, 7u32]);
    
    let mut x = v1.pop_front();
    runtime_assert(x.is_some());
    runtime_assert(x.unwrap() == 4);
    x = v1.pop_front();
    runtime_assert(x.is_some());
    runtime_assert(x.unwrap() == 5);
    x = v1.pop_front();
    runtime_assert(x.is_some());
    runtime_assert(x.unwrap() == 7);
    x = v1.pop_front();
    runtime_assert(x.is_none());

    v1.push_back(10);
    v1.push_back(11);
    assert(v1@ == seq![10u32, 11u32]);

    let mut i: usize = 0;
    for x in it: v1.iter()
        invariant
            i == it.pos,
            it.elements == seq![10u32, 11u32],
    {
        assert(x > 9);
        assert(x < 12);
        i = i + 1;
    }
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/summer_school/chapter-1-22.rs,240,240,1.0,3600.025,False,0.85,False,"['prelude::', 'seq::', 'vstd::prelude::', 'vstd::']",True,,,True,1.0,1.0,"// rust_verify/tests/example.rs expect-warnings
#[allow(unused_imports)]
use prelude::*;
#[allow(unused_imports)]
use seq::*;
use vstd::prelude::*;
#[allow(unused_imports)]
use vstd::*;

verus! {

#[is_variant]
#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box
enum Tree {
    Nil,
    Node { value: i64, left: Box<Tree>, right: Box<Tree> },
}

impl Tree {
    spec fn view(&self) -> Seq<int>
        decreases self,
    {
        match *self {
            Tree::Nil => seq![],
            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),
        }
    }

    spec fn is_sorted(&self) -> bool
        decreases self,
    {
        match *self {
            Tree::Nil => true,
            Tree::Node { value, left, right } => {
                &&& sequences_ordered_at_interface(left@, seq![value as int])
                &&& sequences_ordered_at_interface(seq![value as int], right@)
                &&& left.is_sorted()
                &&& right.is_sorted()
            },
        }
    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)
    // TODO(utaal): is self being Spec too restrictive?

}

spec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {
    if seq1.len() == 0 || seq2.len() == 0 {
        true
    } else {
        seq1.last() <= seq2[0]
    }
}

spec fn sequence_is_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

// TODO: change the default for --multiple-errors
// we can have --jon-mode :p
// TODO: shall multiple errors in the same method be sorted?
proof fn sorted_tree_means_sorted_sequence(tree: Tree)
    requires
        tree.is_sorted(),
    ensures
        sequence_is_sorted(tree@),
    decreases tree  // guessed by Dafny ,
{
    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR
    if let Tree::Node { left, right, value: _ } = tree {
        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny
        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny
    }
}

#[is_variant]
#[derive(Eq, PartialEq, Structural)]
enum TreeSortedness {
    Unsorted,
    Empty,
    Bounded(i64, i64),
}

fn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)
    ensures
        tree.is_sorted() == !ret.is_Unsorted(),
        tree.is_Nil() == ret.is_Empty(),
        if let TreeSortedness::Bounded(l, r) = ret {
            l == tree@[0] && r == tree@.last()
        } else {
            true
        },
// TODO: suboptimal span for error message:
// error: postcondition not satisfied
//   --> rust_verify/example/summer_school.rs:82:13
//    |
// 82 |             TreeSortedness::Unsorted => true,
//    |             ^^^^^^^^^^^^^^^^^^^^^^^^

    decreases tree,
{
    match tree {
        Tree::Nil => TreeSortedness::Empty,
        Tree::Node { left, value, right } => {
            let left_sortedness = check_is_sorted_tree(left);
            let left_bound;
            match left_sortedness {
                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,
                TreeSortedness::Empty => left_bound = *value,
                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {
                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));
                    // assert(!tree.is_sorted());
                    return TreeSortedness::Unsorted;
                } else {
                    // assert(left@[0] == ll);
                    // assert(left@.last() == lr);
                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));
                    left_bound = ll;
                },
            }
            // assert(left.is_Nil() ==> left_sortedness.is_Empty());
            // assert(left_sortedness.is_Empty() ==> left.is_Nil());

            let right_sortedness = check_is_sorted_tree(right);
            let right_bound;
            match right_sortedness {
                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,
                TreeSortedness::Empty => right_bound = *value,
                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {
                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));
                    // assert(!tree.is_sorted());
                    return TreeSortedness::Unsorted;
                } else {
                    // assert(*value <= rl);
                    // assert(right@.last() == rr);
                    // assert(right@[0] == rl);
                    // assert(seq![*value as int].last() == *value as int);
                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));
                    right_bound = rr;
                },
            }
            proof {
                sorted_tree_means_sorted_sequence(**left);
                sorted_tree_means_sorted_sequence(**right);
            }
            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));
            // assert(tree@.len() > 0);
            // assert(left.is_sorted());
            // assert(right.is_sorted());
            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));
            // assert(sequences_ordered_at_interface(seq![*value as int], right@));
            // assert(tree.is_sorted());
            // TODO cannot use proof variable inside forall/assert_by statements (left)
            // #[verifier::spec] let left = left;
            // assert_by(left_bound == tree@[0], {
            //     if left.is_Nil() {
            //         assert(left_sortedness.is_Empty());
            //         assert(*value as int == tree@[0]);
            //         assert(left_bound == *value);
            //         assert(left_bound == tree@[0]);
            //     } else {
            //         assert(left_bound == tree@[0]);
            //     }
            // });
            assert(right_bound == tree@.last());
            TreeSortedness::Bounded(left_bound, right_bound)
        },
    }
}

fn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)
    requires
        tree.is_sorted(),
    ensures
        ret == tree@.contains(needle as int),
    decreases tree,
{
    match tree {
        Tree::Nil => false,
        Tree::Node { left, value, right } => {
            if needle == *value {
                assert(tree@[left@.len() as int] == needle);  // trigger
                true
            } else if needle < *value {
                let ret = find_in_binary_tree(left, needle);
                if ret {
                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?
                    proof {
                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;
                        assert(tree@[idx] == needle);  // trigger
                    }
                } else {
                    proof {
                        sorted_tree_means_sorted_sequence(**right);
                    }
                    //                    assert_forall_by(|idx: nat| {
                    //                        requires(idx < tree@.len());
                    //                        ensures(tree@.index(idx) != needle);
                    //                        if idx < left@.len() {
                    //                          assert(tree@.index(idx) != needle);
                    //                        } else if idx==left@.len() {
                    //                          assert(tree@.index(idx) != needle);
                    //                        } else {
                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint ""expected struct `verus_builtin::int`, found struct `verus_builtin::nat`""
                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);
                    //                          assert(tree@.index(idx) == right@.index(right_idx));
                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?
                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));
                    //                          assert(sequence_is_sorted(right@));
                    //                          if 0 < right_idx {
                    //                            assert(right@.index(0) <= right@.index(right_idx));
                    //                          }
                    //                          assert((*value as int) <= right@.index(right_idx));
                    //                          assert(tree@.index(idx) != needle);
                    //                        }
                    //                    });
                }
                //                assert(ret == tree@.contains(needle));

                ret
            } else {
                let ret = find_in_binary_tree(right, needle);
                proof {
                    if ret {
                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;
                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger
                    } else {
                        sorted_tree_means_sorted_sequence(**left);
                    }
                }
                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete
                ret
            }
        },
    }
}

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs expect-warnings
#[allow(unused_imports)]
use prelude::*;
#[allow(unused_imports)]
use seq::*;
use vstd::prelude::*;
#[allow(unused_imports)]
use vstd::*;

verus! {

#[is_variant]
#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box
enum Tree {
    Nil,
    Node { value: i64, left: Box<Tree>, right: Box<Tree> },
}

impl Tree {
    spec fn view(&self) -> Seq<int>
        decreases self,
    {
        match *self {
            Tree::Nil => seq![],
            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),
        }
    }

    spec fn is_sorted(&self) -> bool
        decreases self,
    {
        match *self {
            Tree::Nil => true,
            Tree::Node { value, left, right } => {
                &&& sequences_ordered_at_interface(left@, seq![value as int])
                &&& sequences_ordered_at_interface(seq![value as int], right@)
                &&& left.is_sorted()
                &&& right.is_sorted()
            },
        }
    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)
    // TODO(utaal): is self being Spec too restrictive?

}

spec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {
    if seq1.len() == 0 || seq2.len() == 0 {
        true
    } else {
        seq1.last() <= seq2[0]
    }
}

spec fn sequence_is_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

// TODO: change the default for --multiple-errors
// we can have --jon-mode :p
// TODO: shall multiple errors in the same method be sorted?
proof fn sorted_tree_means_sorted_sequence(tree: Tree)
    requires
        tree.is_sorted(),
    ensures
        sequence_is_sorted(tree@),
    decreases tree  // guessed by Dafny ,
{
    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR
    if let Tree::Node { left, right, value: _ } = tree {
        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny
        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny
    }
}

#[is_variant]
#[derive(Eq, PartialEq, Structural)]
enum TreeSortedness {
    Unsorted,
    Empty,
    Bounded(i64, i64),
}

fn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)
    ensures
        tree.is_sorted() == !ret.is_Unsorted(),
        tree.is_Nil() == ret.is_Empty(),
        if let TreeSortedness::Bounded(l, r) = ret {
            l == tree@[0] && r == tree@.last()
        } else {
            true
        },
// TODO: suboptimal span for error message:
// error: postcondition not satisfied
//   --> rust_verify/example/summer_school.rs:82:13
//    |
// 82 |             TreeSortedness::Unsorted => true,
//    |             ^^^^^^^^^^^^^^^^^^^^^^^^

    decreases tree,
{
    match tree {
        Tree::Nil => TreeSortedness::Empty,
        Tree::Node { left, value, right } => {
            let left_sortedness = check_is_sorted_tree(left);
            let left_bound;
            match left_sortedness {
                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,
                TreeSortedness::Empty => left_bound = *value,
                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {
                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));
                    // assert(!tree.is_sorted());
                    return TreeSortedness::Unsorted;
                } else {
                    // assert(left@[0] == ll);
                    // assert(left@.last() == lr);
                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));
                    left_bound = ll;
                },
            }
            // assert(left.is_Nil() ==> left_sortedness.is_Empty());
            // assert(left_sortedness.is_Empty() ==> left.is_Nil());

            let right_sortedness = check_is_sorted_tree(right);
            let right_bound;
            match right_sortedness {
                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,
                TreeSortedness::Empty => right_bound = *value,
                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {
                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));
                    // assert(!tree.is_sorted());
                    return TreeSortedness::Unsorted;
                } else {
                    // assert(*value <= rl);
                    // assert(right@.last() == rr);
                    // assert(right@[0] == rl);
                    // assert(seq![*value as int].last() == *value as int);
                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));
                    right_bound = rr;
                },
            }
            proof {
                sorted_tree_means_sorted_sequence(**left);
                sorted_tree_means_sorted_sequence(**right);
            }
            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));
            // assert(tree@.len() > 0);
            // assert(left.is_sorted());
            // assert(right.is_sorted());
            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));
            // assert(sequences_ordered_at_interface(seq![*value as int], right@));
            // assert(tree.is_sorted());
            // TODO cannot use proof variable inside forall/assert_by statements (left)
            // #[verifier::spec] let left = left;
            // assert_by(left_bound == tree@[0], {
            //     if left.is_Nil() {
            //         assert(left_sortedness.is_Empty());
            //         assert(*value as int == tree@[0]);
            //         assert(left_bound == *value);
            //         assert(left_bound == tree@[0]);
            //     } else {
            //         assert(left_bound == tree@[0]);
            //     }
            // });
            assert(right_bound == tree@.last());
            TreeSortedness::Bounded(left_bound, right_bound)
        },
    }
}

fn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)
    requires
        tree.is_sorted(),
    ensures
        ret == tree@.contains(needle as int),
    decreases tree,
{
    match tree {
        Tree::Nil => false,
        Tree::Node { left, value, right } => {
            if needle == *value {
                assert(tree@[left@.len() as int] == needle);  // trigger
                true
            } else if needle < *value {
                let ret = find_in_binary_tree(left, needle);
                if ret {
                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?
                    proof {
                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;
                        assert(tree@[idx] == needle);  // trigger
                    }
                } else {
                    proof {
                        sorted_tree_means_sorted_sequence(**right);
                    }
                    //                    assert_forall_by(|idx: nat| {
                    //                        requires(idx < tree@.len());
                    //                        ensures(tree@.index(idx) != needle);
                    //                        if idx < left@.len() {
                    //                          assert(tree@.index(idx) != needle);
                    //                        } else if idx==left@.len() {
                    //                          assert(tree@.index(idx) != needle);
                    //                        } else {
                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint ""expected struct `verus_builtin::int`, found struct `verus_builtin::nat`""
                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);
                    //                          assert(tree@.index(idx) == right@.index(right_idx));
                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?
                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));
                    //                          assert(sequence_is_sorted(right@));
                    //                          if 0 < right_idx {
                    //                            assert(right@.index(0) <= right@.index(right_idx));
                    //                          }
                    //                          assert((*value as int) <= right@.index(right_idx));
                    //                          assert(tree@.index(idx) != needle);
                    //                        }
                    //                    });
                }
                //                assert(ret == tree@.contains(needle));

                ret
            } else {
                let ret = find_in_binary_tree(right, needle);
                proof {
                    if ret {
                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;
                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger
                    } else {
                        sorted_tree_means_sorted_sequence(**left);
                    }
                }
                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete
                ret
            }
        },
    }
}

fn main() {
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/summer_school/chapter-2-3.rs,110,110,1.0,122.981,True,0.9,False,"['multiset::', 'prelude::', 'seq::', 'set::', 'vstd::prelude::', 'vstd::']",True,,,,,,"// rust_verify/tests/example.rs
use multiset::*;
#[allow(unused_imports)]
use prelude::*;
#[allow(unused_imports)]
use seq::*;
use set::*;
use vstd::prelude::*;
#[allow(unused_imports)]
use vstd::*;

verus! {

spec fn is_sorted(seqint: Seq<int>) -> bool {
    // summer school definition:
    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?
    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.
    // But jonh hates that summer school definition! Better to forall pairs of indices.
    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]
}

spec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat
    decreases a.len(),
{
    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [""vstd"", ""seq"", ""Seq""] }, [TypParam(""T"")]))', vir/src/recursion.rs:86:14
    if a.len() == 0 {
        0
    } else {
        count_in_seq(a.drop_last(), t) + if a.last() == t {
            1nat
        } else {
            0
        }
    }
}

//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat
//{
//    exists(|indices:Set<nat>|
//            true
//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())
//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))
//         )
//}
spec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {
    forall|t: T| count_in_seq(a, t) == b.count(t)
}

spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>
    decreases input.len(),  // TODO(utaal): when bug fixed, remove len
{
    // show we CAN build a multiset constructively from a seq
    if input.len() == 0 {
        Multiset::empty()
    } else {
        multiset_from_seq(input.drop_last()).insert(input.last())
    }
}

proof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)
    requires
        multiset_from_seq(input) == output,
    ensures
// show we did build a multiset constructively from a seq

        multiset_matches_seq(input, output),
        // show there's no other multiset that'll work.
        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,
{
    if input.len() == 0 {
        //assert(output == Multiset::empty());
        assert(multiset_matches_seq(input, output));
        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO
    } else {
        /*
        let prev = multiset_from_seq(
        let output = multiset_lemma(input.drop_last()
        assert(multiset_matches_seq(input, output));
        // show there's no other multiset that'll work.
        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));
        output
        */
        assume(false);
        assert(multiset_matches_seq(input, output));
        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);
    }
}

spec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {
    &&& is_sorted(output)
    &&& multiset_from_seq(output) == multiset_from_seq(input)
}

spec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {
    i64seq.map(|_index: int, i: i64| i as int)
}

fn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)
    ensures
        sort_spec(view_i64(input.view()), view_i64(output.view())),
{
    assume(false);
    input  // TODO(jonh): haven't actually implemented

}

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs
use multiset::*;
#[allow(unused_imports)]
use prelude::*;
#[allow(unused_imports)]
use seq::*;
use set::*;
use vstd::prelude::*;
#[allow(unused_imports)]
use vstd::*;

verus! {

spec fn is_sorted(seqint: Seq<int>) -> bool {
    // summer school definition:
    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?
    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.
    // But jonh hates that summer school definition! Better to forall pairs of indices.
    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]
}

spec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat
    decreases a.len(),
{
    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [""vstd"", ""seq"", ""Seq""] }, [TypParam(""T"")]))', vir/src/recursion.rs:86:14
    if a.len() == 0 {
        0
    } else {
        count_in_seq(a.drop_last(), t) + if a.last() == t {
            1nat
        } else {
            0
        }
    }
}

//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat
//{
//    exists(|indices:Set<nat>|
//            true
//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())
//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))
//         )
//}
spec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {
    forall|t: T| count_in_seq(a, t) == b.count(t)
}

spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>
    decreases input.len(),  // TODO(utaal): when bug fixed, remove len
{
    // show we CAN build a multiset constructively from a seq
    if input.len() == 0 {
        Multiset::empty()
    } else {
        multiset_from_seq(input.drop_last()).insert(input.last())
    }
}

proof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)
    requires
        multiset_from_seq(input) == output,
    ensures
// show we did build a multiset constructively from a seq

        multiset_matches_seq(input, output),
        // show there's no other multiset that'll work.
        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,
{
    if input.len() == 0 {
        //assert(output == Multiset::empty());
        assert(multiset_matches_seq(input, output));
        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO
    } else {
        /*
        let prev = multiset_from_seq(
        let output = multiset_lemma(input.drop_last()
        assert(multiset_matches_seq(input, output));
        // show there's no other multiset that'll work.
        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));
        output
        */
        assume(false);
        assert(multiset_matches_seq(input, output));
        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);
    }
}

spec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {
    &&& is_sorted(output)
    &&& multiset_from_seq(output) == multiset_from_seq(input)
}

spec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {
    i64seq.map(|_index: int, i: i64| i as int)
}

fn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)
    ensures
        sort_spec(view_i64(input.view()), view_i64(output.view())),
{
    assume(false);
    input  // TODO(jonh): haven't actually implemented

}

fn main() {
}

} // verus!
","['// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n    //decreases(a);   // TOOD(utaal): thread \'rustc\' panicked at \'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [""vstd"", ""seq"", ""Seq""] }, [TypParam(""T"")]))\', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there\'s no other multiset that\'ll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{\n    if input.len() == 0 {\n        //assert(output == Multiset::empty());\n        assert(multiset_matches_seq(input, output));\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n        assert(multiset_matches_seq(input, output));\n        // show there\'s no other multiset that\'ll work.\n        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));\n        output\n        */\n        assume(false);\n        assert(multiset_matches_seq(input, output));\n        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n    assume(false);\n    input  // TODO(jonh): haven\'t actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', 'use vstd::prelude::*;\nverus !{ fn main(); }\n', '  use vstd::prelude::*;\n        verus! {\n       fn main() ;\n       }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/summer_school/chapter-6-1.rs,308,54,0.17532467532467533,247.842,True,0.7999999999999999,False,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::map::', 'vstd::seq::', 'vstd::set::', 'vstd::', 'verus_state_machines_macros::case_on_init', 'verus_state_machines_macros::case_on_next', 'verus_state_machines_macros::state_machine']",True,,,,,,"#![allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::map::*;
use vstd::seq::*;
use vstd::set::*;
use vstd::{pervasive::*, *};

use verus_state_machines_macros::case_on_init;
use verus_state_machines_macros::case_on_next;
use verus_state_machines_macros::state_machine;

verus! {

#[verifier::external_body]  /* vattr */
pub struct Key {}

#[verifier::external_body]  /* vattr */
pub struct Value {}

#[verifier::external_body]  /* vattr */
#[verifier::spec]
pub fn default() -> Value {
    unimplemented!()
}

state_machine!{
    MapSpec {
        fields {
            pub map: Map<Key, Value>,
        }

        init!{
            empty() {
                init map = Map::total(|k| default());
            }
        }

        transition!{
            insert_op(key: Key, value: Value) {
                update map = pre.map.insert(key, value);
            }
        }

        transition!{
            query_op(key: Key, value: Value) {
                require(pre.map.contains_pair(key, value));
            }
        }

        transition!{
            noop() {
            }
        }
    }
}

state_machine!{
    ShardedKVProtocol {
        fields {
            // TODO have a way to annotate this as a constant outside of tokenized mode
            pub map_count: int,

            pub maps: Seq<Map<Key, Value>>,
        }

        init!{
            initialize(map_count: int) {
                require(0 < map_count);
                init map_count = map_count;
                init maps = Seq::new(map_count as nat, |i| {
                    if i == 0 {
                        Map::total(|k| default())
                    } else {
                        Map::empty()
                    }
                });
            }
        }

        pub open spec fn valid_host(&self, i: int) -> bool {
            0 <= i < self.map_count
        }

        transition!{
            insert(idx: int, key: Key, value: Value) {
                require(pre.valid_host(idx));
                require(pre.maps.index(idx).dom().contains(key));
                update maps[idx][key] = value;
            }
        }

        transition!{
            query(idx: int, key: Key, value: Value) {
                require(pre.valid_host(idx));
                require(pre.maps.index(idx).contains_pair(key, value));
            }
        }

        transition!{
            transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {
                require(pre.valid_host(send_idx));
                require(pre.valid_host(recv_idx));
                require(pre.maps.index(send_idx).contains_pair(key, value));
                require(send_idx != recv_idx);
                update maps[send_idx] = pre.maps.index(send_idx).remove(key);
                update maps[recv_idx][key] = value;
            }
        }

        pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {
            self.valid_host(hostidx)
            && self.maps.index(hostidx).dom().contains(key)
        }

        pub open spec fn key_holder(&self, key: Key) -> int {
            choose|idx| self.host_has_key(idx, key)
        }

        pub open spec fn abstraction_one_key(&self, key: Key) -> Value {
            if exists |idx| self.host_has_key(idx, key) {
                self.maps.index(self.key_holder(key)).index(key)
            } else {
                default()
            }
        }

        pub open spec fn interp_map(&self) -> Map<Key, Value> {
            Map::total(|key| self.abstraction_one_key(key))
        }

        #[invariant]
        pub open fn num_hosts(&self) -> bool {
            self.maps.len() == self.map_count
        }

        #[invariant]
        pub open fn inv_no_dupes(&self) -> bool {
            forall |i: int, j: int, key: Key|
                self.host_has_key(i, key) && self.host_has_key(j, key) ==> i == j
        }

        #[inductive(initialize)]
        fn initialize_inductive(post: Self, map_count: int) {
        }

        #[inductive(insert)]
        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {
            //assert(forall(|k: Key| pre.host_has_key(idx, k) ==> post.host_has_key(idx, k)));
            //assert(forall(|k: Key| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k)));
            //assert(forall(|k: Key| pre.host_has_key(idx, k) == post.host_has_key(idx, k)));
            assert(forall |i: int, k: Key| pre.host_has_key(i, k) == post.host_has_key(i, k));
        }

        #[inductive(query)]
        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) { }

        #[inductive(transfer)]
        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {
            assert(forall |i: int, k: Key| !equal(k, key) ==> pre.host_has_key(i, k) == post.host_has_key(i, k));
            assert(forall |i: int| i != send_idx && i != recv_idx ==> pre.host_has_key(i, key) == post.host_has_key(i, key));

            assert(equal(post.maps.index(send_idx),
                pre.maps.index(send_idx).remove(key)));

            assert(!post.host_has_key(send_idx, key));
            assert(pre.host_has_key(send_idx, key));

            /*assert_forall_by(|i: int, j: int, k: Key| {
                requires(post.host_has_key(i, k) && post.host_has_key(j, k));
                ensures(i == j);
                if equal(k, key) {
                    assert(i != send_idx);
                    assert(j != send_idx);
                    if i != recv_idx {
                        assert(pre.host_has_key(i, key));
                    }
                    if i != recv_idx && j != recv_idx {
                        assert(pre.host_has_key(i, key));
                        assert(pre.host_has_key(j, key));
                        assert(pre.inv_no_dupes());
                        assert(i == j);
                    }
                    assert(i == j);
                } else {
                    assert(i == j);
                }
            });*/
        }
    }
}

spec fn interp(a: ShardedKVProtocol::State) -> MapSpec::State {
    MapSpec::State { map: a.interp_map() }
}

proof fn next_refines_next_with_macro(pre: ShardedKVProtocol::State, post: ShardedKVProtocol::State)
    requires
        pre.invariant(),
        post.invariant(),
        interp(pre).invariant(),
        ShardedKVProtocol::State::next(pre, post),
    ensures
        MapSpec::State::next(interp(pre), interp(post)),
{
    case_on_next!{pre, post, ShardedKVProtocol => {
        insert(idx, key, value) => {
            assert_maps_equal!(pre.interp_map().insert(key, value), post.interp_map(), k => {
                if equal(k, key) {
                    assert(pre.host_has_key(idx, key));
                    assert(post.host_has_key(idx, key));
                } else {
                    assert(pre.interp_map().dom().contains(k));
                    assert(post.interp_map().dom().contains(k));

                    if exists |idx| pre.host_has_key(idx, k) {
                        let i = pre.key_holder(k);
                        assert(pre.host_has_key(i, k));
                        assert(post.host_has_key(i, k));
                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));
                    } else {
                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));
                        /*assert(forall |idx| !post.host_has_key(idx, k));
                        assert(!exists(|idx| post.host_has_key(idx, k)));
                        assert(equal(pre.abstraction_one_key(k), default()));
                        assert(equal(post.abstraction_one_key(k), default()));
                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));*/
                    }

                    /*assert(pre.interp_map().dom().contains(k) ==>
                        post.interp_map().dom().contains(k)
                        && equal(pre.interp_map().index(k), post.interp_map().index(k))
                    );
                    assert(post.interp_map().dom().contains(k) ==>
                        pre.interp_map().dom().contains(k));*/
                }
            });
            MapSpec::show::insert_op(interp(pre), interp(post), key, value);
        }
        query(idx, key, value) => {
            //assert(interp(pre).map =~= interp(post).map);
            //assert(equal(interp(pre).map, interp(post).map));

            //assert(equal(Map::total(|key| pre.abstraction_one_key(key)).dom(),
            //    Set::empty().complement()));
            //assert(equal(pre.interp_map(),
            //    Map::total(|key| pre.abstraction_one_key(key))));
            //assert(equal(pre.interp_map().dom(), Set::empty().complement()));

            //assert(equal(interp(pre).map.dom(), Set::empty().complement()));
            //assert(interp(pre).map.dom().contains(key));
            //assert(equal(interp(pre).map.index(key),
            //    pre.abstraction_one_key(key)));

            assert(pre.host_has_key(idx, key));
            //assert(pre.host_has_key(pre.key_holder(key), key));
            //assert(equal(pre.key_holder(key), idx));

            //assert(equal(pre.abstraction_one_key(key), value));
            //assert(equal(interp(pre).map.index(key), value));
            MapSpec::show::query_op(interp(pre), interp(post), key, value);
        }
        transfer(send_idx, recv_idx, key, value) => {
            assert_maps_equal!(pre.interp_map(), post.interp_map(), k: Key => {
                if equal(k, key) {
                    assert(pre.host_has_key(send_idx, key));
                    assert(post.host_has_key(recv_idx, key));
                } else {
                    assert(pre.interp_map().dom().contains(k));
                    assert(post.interp_map().dom().contains(k));

                    if exists |idx| pre.host_has_key(idx, k) {
                        let i = pre.key_holder(k);
                        assert(pre.host_has_key(i, k));
                        assert(post.host_has_key(i, k));
                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));
                    } else {
                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));
                    }
                }
            });
            MapSpec::show::noop(interp(pre), interp(post));
        }
    }}
}

proof fn init_refines_init_with_macro(post: ShardedKVProtocol::State)
    requires
        post.invariant() && ShardedKVProtocol::State::init(post),
    ensures
        MapSpec::State::init(interp(post)),
{
    case_on_init!{post, ShardedKVProtocol => {
        initialize(n) => {
            assert_maps_equal!(interp(post).map, Map::total(|k| default()), k: Key => {
                assert(interp(post).map.dom().contains(k));
                assert(equal(interp(post).map.index(k), default()));
            });

            MapSpec::show::empty(interp(post));
        }
    }}
}

fn main() {
}

} // verus!
","use verus_builtin::*;
     use verus_builtin_macros::*;
     use vstd::map::*;
     use vstd::seq::*;
     use verus_state_machines_macros::state_machine;
     verus! {
     pub struct Key {
  }
     pub struct Value {
  }
#[verifier::external_body]  
#[verifier::spec]
pub fn default() -> Value {
       unimplemented!() }
    state_machine!{
       ShardedKVProtocol {
          fields {
             pub map_count: int,             pub maps: Seq<Map<Key, Value>>,         }
          init!{
             initialize(map_count: int) {                 require(0 < map_count);                 init map_count = map_count;                 init maps = Seq::new(map_count as nat, |i| {                     if i == 0 {                         Map::total(|k| default())                     } else {                         Map::empty()                     }                 });             }
         }
          pub open spec fn valid_host(&self, i: int) -> bool {
             0 <= i < self.map_count         }
          transition!{
             insert(idx: int, key: Key, value: Value) {                 require(pre.valid_host(idx));                 require(pre.maps.index(idx).dom().contains(key));                 update maps[idx][key] = value;             }
         }
          transition!{
             query(idx: int, key: Key, value: Value) {                 require(pre.valid_host(idx));                 require(pre.maps.index(idx).contains_pair(key, value));             }
         }
          transition!{
             transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {                 require(pre.valid_host(send_idx));                 require(pre.valid_host(recv_idx));                 require(pre.maps.index(send_idx).contains_pair(key, value));                 require(send_idx != recv_idx);                 update maps[send_idx] = pre.maps.index(send_idx).remove(key);                 update maps[recv_idx][key] = value;             }
         }
          pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {
             self.valid_host(hostidx)             && self.maps.index(hostidx).dom().contains(key)         }
#[invariant]
        pub open fn num_hosts(&self) -> bool {
             self.maps.len() == self.map_count         }
#[inductive(initialize)]
        fn initialize_inductive(post: Self, map_count: int) {
         }
#[inductive(insert)]
        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {
         }
#[inductive(query)]
        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {
 }
#[inductive(transfer)]
        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {
         }
      }
   }
    fn main() {
   }
    }
","['#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nverus! {\n\n#[verifier::external_body]  /* vattr */\npub struct Key {}\n\n#[verifier::external_body]  /* vattr */\npub struct Value {}\n\n#[verifier::external_body]  /* vattr */\n#[verifier::spec]\npub fn default() -> Value {\n    unimplemented!()\n}\n\nstate_machine!{\n    MapSpec {\n        fields {\n            pub map: Map<Key, Value>,\n        }\n\n        init!{\n            empty() {\n                init map = Map::total(|k| default());\n            }\n        }\n\n        transition!{\n            insert_op(key: Key, value: Value) {\n                update map = pre.map.insert(key, value);\n            }\n        }\n\n        transition!{\n            query_op(key: Key, value: Value) {\n                require(pre.map.contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            noop() {\n            }\n        }\n    }\n}\n\nstate_machine!{\n    ShardedKVProtocol {\n        fields {\n            // TODO have a way to annotate this as a constant outside of tokenized mode\n            pub map_count: int,\n\n            pub maps: Seq<Map<Key, Value>>,\n        }\n\n        init!{\n            initialize(map_count: int) {\n                require(0 < map_count);\n                init map_count = map_count;\n                init maps = Seq::new(map_count as nat, |i| {\n                    if i == 0 {\n                        Map::total(|k| default())\n                    } else {\n                        Map::empty()\n                    }\n                });\n            }\n        }\n\n        pub open spec fn valid_host(&self, i: int) -> bool {\n            0 <= i < self.map_count\n        }\n\n        transition!{\n            insert(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).dom().contains(key));\n                update maps[idx][key] = value;\n            }\n        }\n\n        transition!{\n            query(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {\n                require(pre.valid_host(send_idx));\n                require(pre.valid_host(recv_idx));\n                require(pre.maps.index(send_idx).contains_pair(key, value));\n                require(send_idx != recv_idx);\n                update maps[send_idx] = pre.maps.index(send_idx).remove(key);\n                update maps[recv_idx][key] = value;\n            }\n        }\n\n        pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n            self.valid_host(hostidx)\n            && self.maps.index(hostidx).dom().contains(key)\n        }\n\n        pub open spec fn key_holder(&self, key: Key) -> int {\n            choose|idx| self.host_has_key(idx, key)\n        }\n\n        pub open spec fn abstraction_one_key(&self, key: Key) -> Value {\n            if exists |idx| self.host_has_key(idx, key) {\n                self.maps.index(self.key_holder(key)).index(key)\n            } else {\n                default()\n            }\n        }\n\n        pub open spec fn interp_map(&self) -> Map<Key, Value> {\n            Map::total(|key| self.abstraction_one_key(key))\n        }\n\n        #[invariant]\n        pub open fn num_hosts(&self) -> bool {\n            self.maps.len() == self.map_count\n        }\n\n        #[invariant]\n        pub open fn inv_no_dupes(&self) -> bool {\n            forall |i: int, j: int, key: Key|\n                self.host_has_key(i, key) && self.host_has_key(j, key) ==> i == j\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, map_count: int) {\n        }\n\n        #[inductive(insert)]\n        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n            //assert(forall(|k: Key| pre.host_has_key(idx, k) ==> post.host_has_key(idx, k)));\n            //assert(forall(|k: Key| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k)));\n            //assert(forall(|k: Key| pre.host_has_key(idx, k) == post.host_has_key(idx, k)));\n            assert(forall |i: int, k: Key| pre.host_has_key(i, k) == post.host_has_key(i, k));\n        }\n\n        #[inductive(query)]\n        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) { }\n\n        #[inductive(transfer)]\n        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n            assert(forall |i: int, k: Key| !equal(k, key) ==> pre.host_has_key(i, k) == post.host_has_key(i, k));\n            assert(forall |i: int| i != send_idx && i != recv_idx ==> pre.host_has_key(i, key) == post.host_has_key(i, key));\n\n            assert(equal(post.maps.index(send_idx),\n                pre.maps.index(send_idx).remove(key)));\n\n            assert(!post.host_has_key(send_idx, key));\n            assert(pre.host_has_key(send_idx, key));\n\n            /*assert_forall_by(|i: int, j: int, k: Key| {\n                requires(post.host_has_key(i, k) && post.host_has_key(j, k));\n                ensures(i == j);\n                if equal(k, key) {\n                    assert(i != send_idx);\n                    assert(j != send_idx);\n                    if i != recv_idx {\n                        assert(pre.host_has_key(i, key));\n                    }\n                    if i != recv_idx && j != recv_idx {\n                        assert(pre.host_has_key(i, key));\n                        assert(pre.host_has_key(j, key));\n                        assert(pre.inv_no_dupes());\n                        assert(i == j);\n                    }\n                    assert(i == j);\n                } else {\n                    assert(i == j);\n                }\n            });*/\n        }\n    }\n}\n\nspec fn interp(a: ShardedKVProtocol::State) -> MapSpec::State {\n    MapSpec::State { map: a.interp_map() }\n}\n\nproof fn next_refines_next_with_macro(pre: ShardedKVProtocol::State, post: ShardedKVProtocol::State)\n    requires\n        pre.invariant(),\n        post.invariant(),\n        interp(pre).invariant(),\n        ShardedKVProtocol::State::next(pre, post),\n    ensures\n        MapSpec::State::next(interp(pre), interp(post)),\n{\n    case_on_next!{pre, post, ShardedKVProtocol => {\n        insert(idx, key, value) => {\n            assert_maps_equal!(pre.interp_map().insert(key, value), post.interp_map(), k => {\n                if equal(k, key) {\n                    assert(pre.host_has_key(idx, key));\n                    assert(post.host_has_key(idx, key));\n                } else {\n                    assert(pre.interp_map().dom().contains(k));\n                    assert(post.interp_map().dom().contains(k));\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n                        assert(pre.host_has_key(i, k));\n                        assert(post.host_has_key(i, k));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));\n                    } else {\n                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));\n                        /*assert(forall |idx| !post.host_has_key(idx, k));\n                        assert(!exists(|idx| post.host_has_key(idx, k)));\n                        assert(equal(pre.abstraction_one_key(k), default()));\n                        assert(equal(post.abstraction_one_key(k), default()));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));*/\n                    }\n\n                    /*assert(pre.interp_map().dom().contains(k) ==>\n                        post.interp_map().dom().contains(k)\n                        && equal(pre.interp_map().index(k), post.interp_map().index(k))\n                    );\n                    assert(post.interp_map().dom().contains(k) ==>\n                        pre.interp_map().dom().contains(k));*/\n                }\n            });\n            MapSpec::show::insert_op(interp(pre), interp(post), key, value);\n        }\n        query(idx, key, value) => {\n            //assert(interp(pre).map =~= interp(post).map);\n            //assert(equal(interp(pre).map, interp(post).map));\n\n            //assert(equal(Map::total(|key| pre.abstraction_one_key(key)).dom(),\n            //    Set::empty().complement()));\n            //assert(equal(pre.interp_map(),\n            //    Map::total(|key| pre.abstraction_one_key(key))));\n            //assert(equal(pre.interp_map().dom(), Set::empty().complement()));\n\n            //assert(equal(interp(pre).map.dom(), Set::empty().complement()));\n            //assert(interp(pre).map.dom().contains(key));\n            //assert(equal(interp(pre).map.index(key),\n            //    pre.abstraction_one_key(key)));\n\n            assert(pre.host_has_key(idx, key));\n            //assert(pre.host_has_key(pre.key_holder(key), key));\n            //assert(equal(pre.key_holder(key), idx));\n\n            //assert(equal(pre.abstraction_one_key(key), value));\n            //assert(equal(interp(pre).map.index(key), value));\n            MapSpec::show::query_op(interp(pre), interp(post), key, value);\n        }\n        transfer(send_idx, recv_idx, key, value) => {\n            assert_maps_equal!(pre.interp_map(), post.interp_map(), k: Key => {\n                if equal(k, key) {\n                    assert(pre.host_has_key(send_idx, key));\n                    assert(post.host_has_key(recv_idx, key));\n                } else {\n                    assert(pre.interp_map().dom().contains(k));\n                    assert(post.interp_map().dom().contains(k));\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n                        assert(pre.host_has_key(i, k));\n                        assert(post.host_has_key(i, k));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));\n                    } else {\n                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));\n                    }\n                }\n            });\n            MapSpec::show::noop(interp(pre), interp(post));\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: ShardedKVProtocol::State)\n    requires\n        post.invariant() && ShardedKVProtocol::State::init(post),\n    ensures\n        MapSpec::State::init(interp(post)),\n{\n    case_on_init!{post, ShardedKVProtocol => {\n        initialize(n) => {\n            assert_maps_equal!(interp(post).map, Map::total(|k| default()), k: Key => {\n                assert(interp(post).map.dom().contains(k));\n                assert(equal(interp(post).map.index(k), default()));\n            });\n\n            MapSpec::show::empty(interp(post));\n        }\n    }}\n}\n\nfn main() {\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\n     use verus_builtin_macros::*;\n     use vstd::map::*;\n     use vstd::seq::*;\n     use verus_state_machines_macros::state_machine;\n     verus! {\n     pub struct Key {\n  }\n     pub struct Value {\n  }\n#[verifier::external_body]  \n#[verifier::spec]\npub fn default() -> Value {\n       unimplemented!() }\n    state_machine!{\n       ShardedKVProtocol {\n          fields {\n             pub map_count: int,             pub maps: Seq<Map<Key, Value>>,         }\n          init!{\n             initialize(map_count: int) {                 require(0 < map_count);                 init map_count = map_count;                 init maps = Seq::new(map_count as nat, |i| {                     if i == 0 {                         Map::total(|k| default())                     } else {                         Map::empty()                     }                 });             }\n         }\n          pub open spec fn valid_host(&self, i: int) -> bool {\n             0 <= i < self.map_count         }\n          transition!{\n             insert(idx: int, key: Key, value: Value) {                 require(pre.valid_host(idx));                 require(pre.maps.index(idx).dom().contains(key));                 update maps[idx][key] = value;             }\n         }\n          transition!{\n             query(idx: int, key: Key, value: Value) {                 require(pre.valid_host(idx));                 require(pre.maps.index(idx).contains_pair(key, value));             }\n         }\n          transition!{\n             transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {                 require(pre.valid_host(send_idx));                 require(pre.valid_host(recv_idx));                 require(pre.maps.index(send_idx).contains_pair(key, value));                 require(send_idx != recv_idx);                 update maps[send_idx] = pre.maps.index(send_idx).remove(key);                 update maps[recv_idx][key] = value;             }\n         }\n          pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n             self.valid_host(hostidx)             && self.maps.index(hostidx).dom().contains(key)         }\n#[invariant]\n        pub open fn num_hosts(&self) -> bool {\n             self.maps.len() == self.map_count         }\n#[inductive(initialize)]\n        fn initialize_inductive(post: Self, map_count: int) {\n         }\n#[inductive(insert)]\n        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n         }\n#[inductive(query)]\n        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n }\n#[inductive(transfer)]\n        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n         }\n      }\n   }\n    fn main() {\n   }\n    }\n', 'use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::map::*;\n        use vstd::seq::*;\n        use verus_state_machines_macros::state_machine;\n        verus! {\n        pub struct Key {\n     }\n        pub struct Value {\n     }\n#[verifier::external_body]  \n#[verifier::spec]\npub fn default() -> Value {\n          unimplemented!() }\n       state_machine!{\n          ShardedKVProtocol {\n             fields {\n                pub map_count: int,             pub maps: Seq<Map<Key, Value>>,         }\n             init!{\n                initialize(map_count: int) {\n                   init map_count = map_count;\n                   init maps = Seq::new(map_count as nat, |i| {\n                       if i == 0 {\n                          Map::total(|k| default())                     }\n   else {\n                          Map::empty()                     }\n                   }\n  );\n               }\n            }\n             pub open spec fn valid_host(&self, i: int) -> bool {\n                0 <= i < self.map_count         }\n             transition!{\n                insert(idx: int, key: Key, value: Value) {\n               }\n            }\n             transition!{\n                query(idx: int, key: Key, value: Value) {\n               }\n            }\n             transition!{\n                transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {\n               }\n            }\n         }\n      }\n       fn main() {\n      }\n       }\n', 'use verus_builtin::*;\n        use verus_builtin_macros::*;\n        use vstd::map::*;\n        use vstd::seq::*;\n        use verus_state_machines_macros::state_machine;\n        verus! {\n        pub struct Key ;\n        pub struct Value ;\n#[verifier::external_body]  \n#[verifier::spec]\npub fn default() -> Value {\n          unimplemented!() }\n       state_machine!{\n          ShardedKVProtocol {\n             fields {\n                pub map_count: int,             pub maps: Seq<Map<Key, Value>>,         }\n             init!{\n                initialize(map_count: int) {\n                   init map_count = map_count;\n                   init maps = Seq::new(map_count as nat, |i| \n                       if i == 0 {\n                          Map::total(|k| default())                     }\n   else {\n                          Map::empty()                     }\n                   \n  );\n               }\n            }\n             pub open spec fn valid_host() -> bool ;\n             transition!{\n                insert() {}\n            }\n             transition!{\n                query() {}\n            }\n             transition!{\n                transfer() {}\n            }\n         }\n      }\n       fn main() ;\n       }\n', 'use verus_builtin::*;\n               use verus_builtin_macros::*;\n               verus! {\n             fn main() ;\n             }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/syntax_attr.rs,339,339,1.0,154.699,True,0.85,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",True,,,True,,,"#![feature(proc_macro_hygiene)]
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{modes::*, prelude::*, seq::*, *};

fn main() {}

/// functions may be declared exec (default), proof, or spec, which contain
/// exec code, proof code, and spec code, respectively.
///   - exec code: compiled, may have requires/ensures
///   - proof code: erased before compilation, may have requires/ensures
///   - spec code: erased before compilation, no requires/ensures, but may have recommends
/// exec and proof functions may name their return values inside parentheses, before the return type
#[verus_spec(sum =>
    requires
        x < 100,
        y < 100,
    ensures
        sum < 200,
)]
fn my_exec_fun(x: u32, y: u32) -> u32
{
    x + y
}

verus! {

proof fn my_proof_fun(x: int, y: int) -> (sum: int)
    requires
        x < 100,
        y < 100,
    ensures
        sum < 200,
{
    x + y
}

spec fn my_spec_fun(x: int, y: int) -> int
    recommends
        x < 100,
        y < 100,
{
    x + y
}

} // verus!

/// exec code cannot directly call proof functions or spec functions.
/// However, exec code can contain proof blocks (proof { ... }),
/// which contain proof code.
/// This proof code can call proof functions and spec functions.
#[verus_spec(
    requires
        x < 100,
        y < 100,
)]
fn test_my_funs(x: u32, y: u32)
{
    // my_proof_fun(x, y); // not allowed in exec code
    // let u = my_spec_fun(x, y); // not allowed exec code
    proof! {
        let u = my_spec_fun(x as int, y as int);  // allowed in proof code
        my_proof_fun(u / 2, y as int);  // allowed in proof code
    }
}

verus! {

/// spec functions with pub or pub(...) must specify whether the body of the function
/// should also be made publicly visible (open function) or not visible (closed function).
pub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {
    // function and body visible to all
    x / 2 + y / 2
}

/* TODO
pub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {
    // function visible to all, body visible to crate
    x / 2 + y / 2
}
*/

// TODO(main_new) pub(crate) is not being handled correctly
// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {
//     // function and body visible to crate
//     x / 2 + y / 2
// }
pub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {
    // function visible to all, body visible to module
    x / 2 + y / 2
}

pub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {
    // function visible to crate, body visible to module
    x / 2 + y / 2
}

} // verus!

/// Recursive functions must have decreases clauses so that Verus can verify that the functions
/// terminate.
#[verus_spec(
    requires
        0 < x < 100,
        y < 100 - x,
    decreases x,
)]
fn test_rec(x: u64, y: u64)
{
    if x > 1 {
        test_rec(x - 1, y + 1);
    }
}

verus! {

/// Multiple decreases clauses are ordered lexicographically, so that later clauses may
/// increase when earlier clauses decrease.
spec fn test_rec2(x: int, y: int) -> int
    decreases x, y,
{
    if y > 0 {
        1 + test_rec2(x, y - 1)
    } else if x > 0 {
        2 + test_rec2(x - 1, 100)
    } else {
        3
    }
}

/// To help prove termination, recursive spec functions may have embedded proof blocks
/// that can make assertions, use broadcasts, and call lemmas.
spec fn test_rec_proof_block(x: int, y: int) -> int
    decreases x,
{
    if x < 1 {
        0
    } else {
        proof {
            assert(x - 1 >= 0);
        }
        test_rec_proof_block(x - 1, y + 1) + 1
    }
}

/// Decreases and recommends may specify additional clauses:
///   - decreases .. ""when"" restricts the function definition to a condition
///     that makes the function terminate
///   - decreases .. ""via"" specifies a proof function that proves the termination
///     (although proof blocks are usually simpler; see above)
///   - recommends .. ""when"" specifies a proof function that proves the
///     recommendations of the functions invoked in the body
spec fn add0(a: nat, b: nat) -> nat
    recommends
        a > 0,
    via add0_recommends
{
    a + b
}

spec fn dec0(a: int) -> int
    decreases a,
    when a > 0
    via dec0_decreases
{
    if a > 0 {
        dec0(a - 1)
    } else {
        0
    }
}

#[via_fn]
proof fn add0_recommends(a: nat, b: nat) {
    // proof
}

#[via_fn]
proof fn dec0_decreases(a: int) {
    // proof
}

} // verus!

/// variables may be exec, tracked, or ghost
///   - exec: compiled
///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)
///   - ghost: erased before compilation, no lifetime checking, can create default value of any type
/// Different variable modes may be used in different code modes:
///   - variables in exec code are always exec
///   - variables in proof code are ghost by default (tracked variables must be marked ""tracked"")
///   - variables in spec code are always ghost
/// For example:
#[verus_spec(
    requires
        a < 100,
        b < 100,
)]
fn test_my_funs2(
    a: u32,  // exec variable
    b: u32,  // exec variable
)
{
    let s = a + b;  // s is an exec variable
    proof! {
        let u = a + b;  // u is a ghost variable
        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y
    }
}

verus! {

/// assume and assert are treated as proof code even outside of proof blocks.
/// ""assert by"" may be used to provide proof code that proves the assertion.
#[verifier::opaque]
spec fn f1(i: int) -> int {
    i + 1
}

} // verus!

#[verus_spec()]
fn assert_by_test() {
    proof! {
        assert(f1(3) > 3) by {
            reveal(f1);  // reveal f1's definition just inside this block
        }
        assert(f1(3) > 3);
    }
}

/// ""assert by"" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.
#[verus_spec()]
fn assert_by_provers(x: u32) {
    proof! {
        assert(x ^ x == 0u32) by (bit_vector);
        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);
    }
}

verus! {

/// ""let ghost"" currently requires the verus! macro
/// Variables in exec code may be exec, ghost, or tracked.
fn test_ghost(x: u32, y: u32)
    requires
        x < 100,
        y < 100,
{
    let ghost u: int = my_spec_fun(x as int, y as int);
    let ghost mut v = u + 1;
    assert(v == x + y + 1);
    proof {
        v = v + 1;  // proof code may assign to ghost mut variables
    }
    let ghost w = {
        let temp = v + 1;
        temp + 1
    };
    assert(w == x + y + 4);
}

/// Ghost(...) expressions and patterns currently require the verus! macro
/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:
fn test_ghost_unwrap(
    x: u32,
    Ghost(y): Ghost<u32>,
)  // unwrap so that y has typ u32, not Ghost<u32>
    requires
        x < 100,
        y < 100,
{
    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:
    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));
    let Ghost(mut v): Ghost<int> = Ghost(u + 1);
    assert(v == x + y + 1);
    proof {
        v = v + 1;  // assign directly to ghost mut v
    }
    let Ghost(w): Ghost<int> = Ghost(
        {
            // proof block that returns a ghost value
            let temp = v + 1;
            temp + 1
        },
    );
    assert(w == x + y + 4);
}

} // verus!

/// Trait functions may have specifications
trait T {
    #[verus_spec(r =>
        requires
            0 <= i < 10,
            0 <= j < 10,
        ensures
            i <= r,
            j <= r,
    )]
    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;
}

#[verus_spec(ret =>
    with
        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>
    requires
        x < 100,
        *old(y) < 100,
    ensures
        *y == x,
        ret == x,
        z == x,
)]
fn test_mut_tracked(x: u32) -> u32 {
    proof!{
        *y = x;
    }
    #[verus_spec(with |=Ghost(x))]
    x
}

fn test_cal_mut_tracked(x: u32) {
    proof_decl!{
        let ghost mut z;
        let tracked mut y = 0u32;
        z = 0u32;
    }
    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]
    let _ = test_mut_tracked(0u32);

    (#[verus_spec(with Tracked(&mut y), Ghost(0))]
    test_mut_tracked(0u32));

    return;
}","#![feature(proc_macro_hygiene)]
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{modes::*, prelude::*, seq::*, *};

fn main() {}

/// functions may be declared exec (default), proof, or spec, which contain
/// exec code, proof code, and spec code, respectively.
///   - exec code: compiled, may have requires/ensures
///   - proof code: erased before compilation, may have requires/ensures
///   - spec code: erased before compilation, no requires/ensures, but may have recommends
/// exec and proof functions may name their return values inside parentheses, before the return type
#[verus_spec(sum =>
    requires
        x < 100,
        y < 100,
    ensures
        sum < 200,
)]
fn my_exec_fun(x: u32, y: u32) -> u32
{
    x + y
}

verus! {

proof fn my_proof_fun(x: int, y: int) -> (sum: int)
    requires
        x < 100,
        y < 100,
    ensures
        sum < 200,
{
    x + y
}

spec fn my_spec_fun(x: int, y: int) -> int
    recommends
        x < 100,
        y < 100,
{
    x + y
}

} // verus!

/// exec code cannot directly call proof functions or spec functions.
/// However, exec code can contain proof blocks (proof { ... }),
/// which contain proof code.
/// This proof code can call proof functions and spec functions.
#[verus_spec(
    requires
        x < 100,
        y < 100,
)]
fn test_my_funs(x: u32, y: u32)
{
    // my_proof_fun(x, y); // not allowed in exec code
    // let u = my_spec_fun(x, y); // not allowed exec code
    proof! {
        let u = my_spec_fun(x as int, y as int);  // allowed in proof code
        my_proof_fun(u / 2, y as int);  // allowed in proof code
    }
}

verus! {

/// spec functions with pub or pub(...) must specify whether the body of the function
/// should also be made publicly visible (open function) or not visible (closed function).
pub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {
    // function and body visible to all
    x / 2 + y / 2
}

/* TODO
pub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {
    // function visible to all, body visible to crate
    x / 2 + y / 2
}
*/

// TODO(main_new) pub(crate) is not being handled correctly
// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {
//     // function and body visible to crate
//     x / 2 + y / 2
// }
pub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {
    // function visible to all, body visible to module
    x / 2 + y / 2
}

pub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {
    // function visible to crate, body visible to module
    x / 2 + y / 2
}

} // verus!

/// Recursive functions must have decreases clauses so that Verus can verify that the functions
/// terminate.
#[verus_spec(
    requires
        0 < x < 100,
        y < 100 - x,
    decreases x,
)]
fn test_rec(x: u64, y: u64)
{
    if x > 1 {
        test_rec(x - 1, y + 1);
    }
}

verus! {

/// Multiple decreases clauses are ordered lexicographically, so that later clauses may
/// increase when earlier clauses decrease.
spec fn test_rec2(x: int, y: int) -> int
    decreases x, y,
{
    if y > 0 {
        1 + test_rec2(x, y - 1)
    } else if x > 0 {
        2 + test_rec2(x - 1, 100)
    } else {
        3
    }
}

/// To help prove termination, recursive spec functions may have embedded proof blocks
/// that can make assertions, use broadcasts, and call lemmas.
spec fn test_rec_proof_block(x: int, y: int) -> int
    decreases x,
{
    if x < 1 {
        0
    } else {
        proof {
            assert(x - 1 >= 0);
        }
        test_rec_proof_block(x - 1, y + 1) + 1
    }
}

/// Decreases and recommends may specify additional clauses:
///   - decreases .. ""when"" restricts the function definition to a condition
///     that makes the function terminate
///   - decreases .. ""via"" specifies a proof function that proves the termination
///     (although proof blocks are usually simpler; see above)
///   - recommends .. ""when"" specifies a proof function that proves the
///     recommendations of the functions invoked in the body
spec fn add0(a: nat, b: nat) -> nat
    recommends
        a > 0,
    via add0_recommends
{
    a + b
}

spec fn dec0(a: int) -> int
    decreases a,
    when a > 0
    via dec0_decreases
{
    if a > 0 {
        dec0(a - 1)
    } else {
        0
    }
}

#[via_fn]
proof fn add0_recommends(a: nat, b: nat) {
    // proof
}

#[via_fn]
proof fn dec0_decreases(a: int) {
    // proof
}

} // verus!

/// variables may be exec, tracked, or ghost
///   - exec: compiled
///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)
///   - ghost: erased before compilation, no lifetime checking, can create default value of any type
/// Different variable modes may be used in different code modes:
///   - variables in exec code are always exec
///   - variables in proof code are ghost by default (tracked variables must be marked ""tracked"")
///   - variables in spec code are always ghost
/// For example:
#[verus_spec(
    requires
        a < 100,
        b < 100,
)]
fn test_my_funs2(
    a: u32,  // exec variable
    b: u32,  // exec variable
)
{
    let s = a + b;  // s is an exec variable
    proof! {
        let u = a + b;  // u is a ghost variable
        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y
    }
}

verus! {

/// assume and assert are treated as proof code even outside of proof blocks.
/// ""assert by"" may be used to provide proof code that proves the assertion.
#[verifier::opaque]
spec fn f1(i: int) -> int {
    i + 1
}

} // verus!

#[verus_spec()]
fn assert_by_test() {
    proof! {
        assert(f1(3) > 3) by {
            reveal(f1);  // reveal f1's definition just inside this block
        }
        assert(f1(3) > 3);
    }
}

/// ""assert by"" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.
#[verus_spec()]
fn assert_by_provers(x: u32) {
    proof! {
        assert(x ^ x == 0u32) by (bit_vector);
        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);
    }
}

verus! {

/// ""let ghost"" currently requires the verus! macro
/// Variables in exec code may be exec, ghost, or tracked.
fn test_ghost(x: u32, y: u32)
    requires
        x < 100,
        y < 100,
{
    let ghost u: int = my_spec_fun(x as int, y as int);
    let ghost mut v = u + 1;
    assert(v == x + y + 1);
    proof {
        v = v + 1;  // proof code may assign to ghost mut variables
    }
    let ghost w = {
        let temp = v + 1;
        temp + 1
    };
    assert(w == x + y + 4);
}

/// Ghost(...) expressions and patterns currently require the verus! macro
/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:
fn test_ghost_unwrap(
    x: u32,
    Ghost(y): Ghost<u32>,
)  // unwrap so that y has typ u32, not Ghost<u32>
    requires
        x < 100,
        y < 100,
{
    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:
    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));
    let Ghost(mut v): Ghost<int> = Ghost(u + 1);
    assert(v == x + y + 1);
    proof {
        v = v + 1;  // assign directly to ghost mut v
    }
    let Ghost(w): Ghost<int> = Ghost(
        {
            // proof block that returns a ghost value
            let temp = v + 1;
            temp + 1
        },
    );
    assert(w == x + y + 4);
}

} // verus!

/// Trait functions may have specifications
trait T {
    #[verus_spec(r =>
        requires
            0 <= i < 10,
            0 <= j < 10,
        ensures
            i <= r,
            j <= r,
    )]
    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;
}

#[verus_spec(ret =>
    with
        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>
    requires
        x < 100,
        *old(y) < 100,
    ensures
        *y == x,
        ret == x,
        z == x,
)]
fn test_mut_tracked(x: u32) -> u32 {
    proof!{
        *y = x;
    }
    #[verus_spec(with |=Ghost(x))]
    x
}

fn test_cal_mut_tracked(x: u32) {
    proof_decl!{
        let ghost mut z;
        let tracked mut y = 0u32;
        z = 0u32;
    }
    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]
    let _ = test_mut_tracked(0u32);

    (#[verus_spec(with Tracked(&mut y), Ghost(0))]
    test_mut_tracked(0u32));

    return;
}","['#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. ""when"" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. ""via"" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. ""when"" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked ""tracked"")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// ""assert by"" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1\'s definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// ""assert by"" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// ""let ghost"" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}', 'use vstd;\nfn main() {}\n', ' use vstd::{};\n        fn main() {}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/test_expand_errors.rs,238,238,1.0,,,0.75,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::map::', 'vstd::modes::', 'vstd::prelude::', 'vstd::seq::', 'vstd::']",False,postcondition,,,,,"// rust_verify/tests/example.rs expand-errors
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::map::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::seq::*;
use vstd::*;

verus! {

spec fn e() -> bool;

spec fn f() -> bool;

spec fn g() -> bool;

spec fn h() -> bool;

spec fn k(i: int) -> bool;

spec fn z() -> bool {
    (e() ==> h()) && (forall|i: int| k(i))
}

spec fn stuff() -> bool {
    f() && g() && z()
}

proof fn test()
    requires
        f(),
{
    assert(stuff());
}

proof fn test_ret()
    ensures
        z(),
{
}

pub spec fn ai(i: int) -> bool;

pub spec fn bi(i: int) -> bool;

pub spec fn ci(i: int) -> bool;

pub open spec fn all_a() -> bool {
    forall|i: int| ai(i)
}

pub open spec fn all_b() -> bool {
    forall|i: int| bi(i)
}

pub open spec fn all_c() -> bool {
    forall|i: int| ci(i)
}

pub proof fn test2(j: int)
    requires
        forall|i: int| ai(i),
        forall|i: int| (#[trigger] ai(i)) ==> bi(i),
{
    assert(ai(j) && bi(j) && ci(j));
}

pub proof fn test_let(j: int)
    requires
        ai(j + 1),
{
    assert({
        let k = j + 3;
        let r = k - 2;
        ai(r) && bi(r)
    });
}

pub proof fn test_match(m: Option<int>)
    requires
        m.is_some(),
{
    assert(match m {
        Some(x) => x == 5,
        None => false,
    });
}

pub proof fn test_match3(foo: Foo) {
    assert(match foo {
        Foo::Bar => false,
        Foo::Qux(z) => z == 0,
        Foo::Duck(w, y) => w == y,
    });
}

pub proof fn test3(a: bool, b: bool) {
    assert(a <==> b);
}

pub proof fn test_xor(a: bool, b: bool) {
    assert(a ^ b);
}

pub proof fn test4(a: Option<u8>, b: Option<u8>) {
    assert(a == b);
}

pub struct X {
    pub a: u32,
    pub b: bool,
    pub c: u64,
}

pub proof fn test5(a: X, b: X) {
    assert(a == b);
}

pub proof fn test6(a: Option<u64>, b: u64) {
    assert(a == Some(b));
}

pub proof fn test7(a: Option<u64>, b: u64) {
    assert(Some(b) == a);
}

pub proof fn test8(a: Option<u64>, b: u64) {
    assert(a === None);
}

pub proof fn test9(a: Option<u64>, b: u64) {
    assert(None === a);
}

pub proof fn test10(a: Option<u64>, b: u64) {
    assert(None === Some(b));
}

pub proof fn test11(a: u64, b: u64) {
    assert(Some(a) == Some(b));
}

#[verifier::external_body]
pub struct OpaqueDT {
    u: u64,
}

pub proof fn test12(a: OpaqueDT, b: OpaqueDT) {
    assert(a == b);
}

pub enum Foo {
    Bar,
    Qux(u64),
    Duck(u64, u64),
}

pub proof fn test13(a: Foo, b: u64) {
    assert(a == Foo::Qux(b));
}

pub proof fn test14(a: Foo, b: u64, c: u64) {
    assert(Foo::Duck(b, c) == a);
}

pub proof fn test15(a: Foo) {
    assert(a === Foo::Bar);
}

pub proof fn test16(a: Foo, b: u64) {
    assert(Foo::Bar === a);
}

pub proof fn test17(a: u64, b: u64, c: u64) {
    assert(Foo::Qux(a) === Foo::Duck(b, c));
}

pub proof fn test18(b: u64, c: u64, e: u64, f: u64) {
    assert(Foo::Duck(b, c) == Foo::Duck(e, f));
}

#[verifier::opaque]
spec fn some_opaque() -> bool {
    false
}

spec fn some_non_opaque() -> bool {
    false
}

proof fn test_opaque1() {
    assert(some_opaque());
}

proof fn test_opaque2() {
    reveal(some_opaque);
    assert(some_opaque());
}

proof fn test_opaque3() {
    hide(some_non_opaque);
    assert(some_non_opaque());
}

spec fn other(i: int) -> bool;

spec fn recursive_function(i: int, base: bool) -> bool
    decreases i,
{
    if i <= 0 {
        base
    } else {
        recursive_function(i - 1, base)
    }
}

proof fn test_rec() {
    reveal_with_fuel(recursive_function, 3);
    assert(recursive_function(3, true));  // should fail with ""reached fuel limit for recursion""
}

proof fn test_rec2() {
    reveal_with_fuel(recursive_function, 4);
    assert(recursive_function(3, true));  // should pass
}

proof fn test_rec3() {
    reveal_with_fuel(recursive_function, 4);
    assert(recursive_function(3, false));
}

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs expand-errors
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::map::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::seq::*;
use vstd::*;

verus! {

spec fn e() -> bool;

spec fn f() -> bool;

spec fn g() -> bool;

spec fn h() -> bool;

spec fn k(i: int) -> bool;

spec fn z() -> bool {
    (e() ==> h()) && (forall|i: int| k(i))
}

spec fn stuff() -> bool {
    f() && g() && z()
}

proof fn test()
    requires
        f(),
{
    assert(stuff());
}

proof fn test_ret()
    ensures
        z(),
{
}

pub spec fn ai(i: int) -> bool;

pub spec fn bi(i: int) -> bool;

pub spec fn ci(i: int) -> bool;

pub open spec fn all_a() -> bool {
    forall|i: int| ai(i)
}

pub open spec fn all_b() -> bool {
    forall|i: int| bi(i)
}

pub open spec fn all_c() -> bool {
    forall|i: int| ci(i)
}

pub proof fn test2(j: int)
    requires
        forall|i: int| ai(i),
        forall|i: int| (#[trigger] ai(i)) ==> bi(i),
{
    assert(ai(j) && bi(j) && ci(j));
}

pub proof fn test_let(j: int)
    requires
        ai(j + 1),
{
    assert({
        let k = j + 3;
        let r = k - 2;
        ai(r) && bi(r)
    });
}

pub proof fn test_match(m: Option<int>)
    requires
        m.is_some(),
{
    assert(match m {
        Some(x) => x == 5,
        None => false,
    });
}

pub proof fn test_match3(foo: Foo) {
    assert(match foo {
        Foo::Bar => false,
        Foo::Qux(z) => z == 0,
        Foo::Duck(w, y) => w == y,
    });
}

pub proof fn test3(a: bool, b: bool) {
    assert(a <==> b);
}

pub proof fn test_xor(a: bool, b: bool) {
    assert(a ^ b);
}

pub proof fn test4(a: Option<u8>, b: Option<u8>) {
    assert(a == b);
}

pub struct X {
    pub a: u32,
    pub b: bool,
    pub c: u64,
}

pub proof fn test5(a: X, b: X) {
    assert(a == b);
}

pub proof fn test6(a: Option<u64>, b: u64) {
    assert(a == Some(b));
}

pub proof fn test7(a: Option<u64>, b: u64) {
    assert(Some(b) == a);
}

pub proof fn test8(a: Option<u64>, b: u64) {
    assert(a === None);
}

pub proof fn test9(a: Option<u64>, b: u64) {
    assert(None === a);
}

pub proof fn test10(a: Option<u64>, b: u64) {
    assert(None === Some(b));
}

pub proof fn test11(a: u64, b: u64) {
    assert(Some(a) == Some(b));
}

#[verifier::external_body]
pub struct OpaqueDT {
    u: u64,
}

pub proof fn test12(a: OpaqueDT, b: OpaqueDT) {
    assert(a == b);
}

pub enum Foo {
    Bar,
    Qux(u64),
    Duck(u64, u64),
}

pub proof fn test13(a: Foo, b: u64) {
    assert(a == Foo::Qux(b));
}

pub proof fn test14(a: Foo, b: u64, c: u64) {
    assert(Foo::Duck(b, c) == a);
}

pub proof fn test15(a: Foo) {
    assert(a === Foo::Bar);
}

pub proof fn test16(a: Foo, b: u64) {
    assert(Foo::Bar === a);
}

pub proof fn test17(a: u64, b: u64, c: u64) {
    assert(Foo::Qux(a) === Foo::Duck(b, c));
}

pub proof fn test18(b: u64, c: u64, e: u64, f: u64) {
    assert(Foo::Duck(b, c) == Foo::Duck(e, f));
}

#[verifier::opaque]
spec fn some_opaque() -> bool {
    false
}

spec fn some_non_opaque() -> bool {
    false
}

proof fn test_opaque1() {
    assert(some_opaque());
}

proof fn test_opaque2() {
    reveal(some_opaque);
    assert(some_opaque());
}

proof fn test_opaque3() {
    hide(some_non_opaque);
    assert(some_non_opaque());
}

spec fn other(i: int) -> bool;

spec fn recursive_function(i: int, base: bool) -> bool
    decreases i,
{
    if i <= 0 {
        base
    } else {
        recursive_function(i - 1, base)
    }
}

proof fn test_rec() {
    reveal_with_fuel(recursive_function, 3);
    assert(recursive_function(3, true));  // should fail with ""reached fuel limit for recursion""
}

proof fn test_rec2() {
    reveal_with_fuel(recursive_function, 4);
    assert(recursive_function(3, true));  // should pass
}

proof fn test_rec3() {
    reveal_with_fuel(recursive_function, 4);
    assert(recursive_function(3, false));
}

fn main() {
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/traits.rs,79,8,0.10126582278481013,183.981,True,0.7,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::pervasive::']",True,,,,,,"// rust_verify/tests/example.rs
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::pervasive::*;

verus! {

trait T<A> {
    spec fn req(&self, a: A) -> bool;

    spec fn ens(&self, a: A, r: A) -> bool;

    fn f(&self, a: &A) -> (ra: A)
        requires
            self.req(*a),
        ensures
            self.ens(*a, ra),
    ;
}

struct B {
    x: bool,
}

struct I {
    x: u64,
}

impl T<bool> for B {
    spec fn req(&self, a: bool) -> bool {
        a
    }

    spec fn ens(&self, a: bool, r: bool) -> bool {
        r == (a && self.x)
    }

    fn f(&self, a: &bool) -> bool {
        *a && self.x
    }
}

impl T<u64> for I {
    spec fn req(&self, a: u64) -> bool {
        self.x < a && a < 100
    }

    spec fn ens(&self, a: u64, r: u64) -> bool {
        self.x <= r && r < 100
    }

    fn f(&self, a: &u64) -> u64 {
        self.x / 2 + a / 2
    }
}

fn p<A, Z: T<A>>(a: &A, z: &Z) -> (rz: A)
    requires
        z.req(*a),
    ensures
        z.ens(*a, rz),
{
    z.f(a)
}

fn test() -> bool {
    let i = I { x: 30 };
    print_u64(p(&70, &i));
    let b = B { x: false };
    b.f(&true) && p(&true, &b)
}

#[verifier::external_body]
fn main() {
    println!(""{}"", test());
}

} // verus!
","use verus_builtin::*;
          use verus_builtin_macros::*;
          verus! {
        trait T<A> {           spec fn req(&self, a: A) -> bool;           spec fn ens(&self, a: A, r: A) -> bool;           fn f(&self, a: &A) -> (ra: A)         requires             self.req(*a),         ensures             self.ens(*a, ra),     ;       }
        struct B {           x: bool, }
        struct I {           x: u64, }
      fn main() ;
        }
","['// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::pervasive::*;\n\nverus! {\n\ntrait T<A> {\n    spec fn req(&self, a: A) -> bool;\n\n    spec fn ens(&self, a: A, r: A) -> bool;\n\n    fn f(&self, a: &A) -> (ra: A)\n        requires\n            self.req(*a),\n        ensures\n            self.ens(*a, ra),\n    ;\n}\n\nstruct B {\n    x: bool,\n}\n\nstruct I {\n    x: u64,\n}\n\nimpl T<bool> for B {\n    spec fn req(&self, a: bool) -> bool {\n        a\n    }\n\n    spec fn ens(&self, a: bool, r: bool) -> bool {\n        r == (a && self.x)\n    }\n\n    fn f(&self, a: &bool) -> bool {\n        *a && self.x\n    }\n}\n\nimpl T<u64> for I {\n    spec fn req(&self, a: u64) -> bool {\n        self.x < a && a < 100\n    }\n\n    spec fn ens(&self, a: u64, r: u64) -> bool {\n        self.x <= r && r < 100\n    }\n\n    fn f(&self, a: &u64) -> u64 {\n        self.x / 2 + a / 2\n    }\n}\n\nfn p<A, Z: T<A>>(a: &A, z: &Z) -> (rz: A)\n    requires\n        z.req(*a),\n    ensures\n        z.ens(*a, rz),\n{\n    z.f(a)\n}\n\nfn test() -> bool {\n    let i = I { x: 30 };\n    print_u64(p(&70, &i));\n    let b = B { x: false };\n    b.f(&true) && p(&true, &b)\n}\n\n#[verifier::external_body]\nfn main() {\n    println!(""{}"", test());\n}\n\n} // verus!\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n', 'use verus_builtin::*;\n          use verus_builtin_macros::*;\n          verus! {\n        trait T<A> {           spec fn req(&self, a: A) -> bool;           spec fn ens(&self, a: A, r: A) -> bool;           fn f(&self, a: &A) -> (ra: A)         requires             self.req(*a),         ensures             self.ens(*a, ra),     ;       }\n        struct B {           x: bool, }\n        struct I {           x: u64, }\n      fn main() ;\n        }\n', 'use verus_builtin;\nuse verus_builtin_macros::*;\nverus !{ fn main(); }\n']"
/Users/ameliakuang/Repos/dep_verus/examples/trigger_loops.rs,113,113,1.0,,,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::']",False,other,,,,,"// rust_verify/tests/example.rs ignore --- these examples are expected to timeout to test the quantifier profiler (i.e., exceed their rlimit)
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{pervasive::*, prelude::*, *};

verus! {

// ANCHOR: def_f_g
uninterp spec fn f(x: nat, y: nat) -> bool;

uninterp spec fn g(x: nat) -> bool;

uninterp spec fn h(x: nat, y: nat) -> bool;
// ANCHOR_END: def_f_g

uninterp spec fn j(x: nat) -> bool;

proof fn quantifier_example()
    requires
        forall|x| g(x),
    ensures
        exists|y| g(y),
{
    let w = choose|z| g(z);
    assert(g(w));
}

proof fn choose_example()
    requires
        exists|x| g(x),
{
    let z = choose|y| g(y);
    assert(g(z));
}

proof fn cost_example()
    requires
        f(1, 2),
        forall|x, y| #[trigger] f(x, y) <==> g(x) && g(y),
        forall|z| #[trigger] g(z) == j(z + 2),
{
    assert(j(3) && j(4));
}

proof fn cost_example2()
    requires
        g(1),
        g(2),
        forall|x, y| f(x, y) <==> #[trigger] g(x) && #[trigger] g(y),
        forall|z| #[trigger] g(z) == j(z + 2),
{
    assert(j(3) && j(4));
}

proof fn trigger_forever()
    requires
        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),
    ensures
        forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y),
{
}

// Split the triggering over two different quantifiers
// ANCHOR: trigger_forever2
proof fn trigger_forever2()
    requires
        forall|x: nat| g(x),
        forall|x: nat, y: nat| h(x, y) == f(x, y),
        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),
    ensures
        forall|x: nat, y: nat| x > 2318 && y < 100 ==> h(x, y),
{
    assert(g(4));
}
// ANCHOR_END: trigger_forever2

fn simple_loop()
    ensures
        forall|x| 0 <= x < 10 ==> g(x),
{
    let mut x: u32 = 0;
    while x < 10
        invariant
            0 <= x <= 10,
            forall|i: u32| 0 <= i < x ==> g(i as nat)
        decreases 10 - x
    {
        assume(g(x as nat));
        x = x + 1;
    }
}

fn bad_loop()
    requires
        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),
{
    let mut x = 10;
    while x > 10
        invariant
            forall|x: nat, y: nat|
                f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),
        decreases x
    {
        x = x - 1;
        assert(forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y));
    }
}

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs ignore --- these examples are expected to timeout to test the quantifier profiler (i.e., exceed their rlimit)
#[allow(unused_imports)]
use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::{pervasive::*, prelude::*, *};

verus! {

// ANCHOR: def_f_g
uninterp spec fn f(x: nat, y: nat) -> bool;

uninterp spec fn g(x: nat) -> bool;

uninterp spec fn h(x: nat, y: nat) -> bool;
// ANCHOR_END: def_f_g

uninterp spec fn j(x: nat) -> bool;

proof fn quantifier_example()
    requires
        forall|x| g(x),
    ensures
        exists|y| g(y),
{
    let w = choose|z| g(z);
    assert(g(w));
}

proof fn choose_example()
    requires
        exists|x| g(x),
{
    let z = choose|y| g(y);
    assert(g(z));
}

proof fn cost_example()
    requires
        f(1, 2),
        forall|x, y| #[trigger] f(x, y) <==> g(x) && g(y),
        forall|z| #[trigger] g(z) == j(z + 2),
{
    assert(j(3) && j(4));
}

proof fn cost_example2()
    requires
        g(1),
        g(2),
        forall|x, y| f(x, y) <==> #[trigger] g(x) && #[trigger] g(y),
        forall|z| #[trigger] g(z) == j(z + 2),
{
    assert(j(3) && j(4));
}

proof fn trigger_forever()
    requires
        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),
    ensures
        forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y),
{
}

// Split the triggering over two different quantifiers
// ANCHOR: trigger_forever2
proof fn trigger_forever2()
    requires
        forall|x: nat| g(x),
        forall|x: nat, y: nat| h(x, y) == f(x, y),
        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),
    ensures
        forall|x: nat, y: nat| x > 2318 && y < 100 ==> h(x, y),
{
    assert(g(4));
}
// ANCHOR_END: trigger_forever2

fn simple_loop()
    ensures
        forall|x| 0 <= x < 10 ==> g(x),
{
    let mut x: u32 = 0;
    while x < 10
        invariant
            0 <= x <= 10,
            forall|i: u32| 0 <= i < x ==> g(i as nat)
        decreases 10 - x
    {
        assume(g(x as nat));
        x = x + 1;
    }
}

fn bad_loop()
    requires
        forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),
{
    let mut x = 10;
    while x > 10
        invariant
            forall|x: nat, y: nat|
                f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> #[trigger] f(x, y),
        decreases x
    {
        x = x - 1;
        assert(forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y));
    }
}

fn main() {
}

} // verus!
",[]
/Users/ameliakuang/Repos/dep_verus/examples/vectors.rs,158,14,0.08860759493670886,157.954,True,0.7999999999999999,True,['vstd::prelude::'],True,,,,,,"// rust_verify/tests/example.rs
use vstd::prelude::*;

verus! {

fn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|i: int| 0 <= i < v.len() && k == v[i],
    ensures
        r < v.len(),
        k == v[r as int],
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            i2 < v.len(),
            exists|i: int| i1 <= i <= i2 && k == v[i],
            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        decreases i2 - i1,
    {
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
    }
    i1
}

fn reverse(v: &mut Vec<u64>)
    ensures
        v.len() == old(v).len(),
        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
        invariant
            length == v.len(),
            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],
            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],
            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}

#[verifier::loop_isolation(false)]
fn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)
    requires
        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|i: int| 0 <= i < v.len() && k == v[i],
    ensures
        r < v.len(),
        k == v[r as int],
{
    let mut i1: usize = 0;
    let mut i2: usize = v.len() - 1;
    while i1 != i2
        invariant
            i2 < v.len(),
            exists|i: int| i1 <= i <= i2 && k == v[i],
        decreases i2 - i1,
    {
        let ghost d = i2 - i1;
        let ix = i1 + (i2 - i1) / 2;
        if v[ix] < k {
            i1 = ix + 1;
        } else {
            i2 = ix;
        }
        assert(i2 - i1 < d);
    }
    i1
}

#[verifier::loop_isolation(false)]
fn reverse_no_spinoff(v: &mut Vec<u64>)
    ensures
        v.len() == old(v).len(),
        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],
{
    let length = v.len();
    let ghost v1 = v@;
    for n in 0..(length / 2)
        invariant
            length == v.len(),
            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],
            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],
            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],
    {
        let x = v[n];
        let y = v[length - 1 - n];
        v.set(n, y);
        v.set(length - 1 - n, x);
    }
}

fn pusher() -> Vec<u64> {
    let mut v = Vec::new();
    v.push(0);
    v.push(1);
    v.push(2);
    v.push(3);
    v.push(4);
    let ghost goal = Seq::new(5, |i: int| i as u64);
    assert(v@ =~= goal);
    assert(v[2] == 2);
    v.pop();
    v.push(4);
    assert(v@ =~= goal);
    v
}

uninterp spec fn uninterp_fn(x: u64) -> bool;

fn pop_test(t: Vec<u64>)
    requires
        t.len() > 0,
        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),
{
    let mut t = t;
    let x = t.pop().unwrap();
    assert(uninterp_fn(x));
    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));
}

fn push_test(t: Vec<u64>, y: u64)
    requires
        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),
        uninterp_fn(y),
{
    let mut t = t;
    t.push(y);
    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));
}

} // verus!
fn main() {
    let mut v = vec![0, 10, 20, 30, 40, 50, 60, 70, 80, 90];
    println!(""{}"", binary_search(&v, 70));
    println!();
    reverse(&mut v);
    for x in v {
        println!(""{}"", x);
    }

    println!(""Pushed 5 values:"");
    for x in pusher() {
        println!(""{}"", x);
    }
}
","use vstd::prelude::*;
      verus! {
     uninterp spec fn uninterp_fn(x: u64) -> bool;
     fn pop_test(t: Vec<u64>)     requires         t.len() > 0,         forall|i: int|      
#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),
{
   }
     fn push_test(t: Vec<u64>, y: u64)     requires         forall|i: int|      
#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),
        uninterp_fn(y), {
  }
     }
       fn main() {
     }
","['// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn reverse(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n        invariant\n            length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\n#[verifier::loop_isolation(false)]\nfn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n        decreases i2 - i1,\n    {\n        let ghost d = i2 - i1;\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n        assert(i2 - i1 < d);\n    }\n    i1\n}\n\n#[verifier::loop_isolation(false)]\nfn reverse_no_spinoff(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n        invariant\n            length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\nfn pusher() -> Vec<u64> {\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(1);\n    v.push(2);\n    v.push(3);\n    v.push(4);\n    let ghost goal = Seq::new(5, |i: int| i as u64);\n    assert(v@ =~= goal);\n    assert(v[2] == 2);\n    v.pop();\n    v.push(4);\n    assert(v@ =~= goal);\n    v\n}\n\nuninterp spec fn uninterp_fn(x: u64) -> bool;\n\nfn pop_test(t: Vec<u64>)\n    requires\n        t.len() > 0,\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n{\n    let mut t = t;\n    let x = t.pop().unwrap();\n    assert(uninterp_fn(x));\n    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));\n}\n\nfn push_test(t: Vec<u64>, y: u64)\n    requires\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y),\n{\n    let mut t = t;\n    t.push(y);\n    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));\n}\n\n} // verus!\nfn main() {\n    let mut v = vec![0, 10, 20, 30, 40, 50, 60, 70, 80, 90];\n    println!(""{}"", binary_search(&v, 70));\n    println!();\n    reverse(&mut v);\n    for x in v {\n        println!(""{}"", x);\n    }\n\n    println!(""Pushed 5 values:"");\n    for x in pusher() {\n        println!(""{}"", x);\n    }\n}\n', 'use vstd;\nfn main() {}\n', 'use vstd::prelude::*;\n      verus! {\n     uninterp spec fn uninterp_fn(x: u64) -> bool;\n     fn pop_test(t: Vec<u64>)     requires         t.len() > 0,         forall|i: int|      \n#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n{\n   }\n     fn push_test(t: Vec<u64>, y: u64)     requires         forall|i: int|      \n#![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y), {\n  }\n     }\n       fn main() {\n     }\n', 'use vstd::prelude::*;\n           fn main() {\n}\n', 'use vstd;\nfn main() {}\n']"
/Users/ameliakuang/Repos/dep_verus/examples/verified_vec.rs,171,171,1.0,,,0.9,True,"['verus_builtin::', 'verus_builtin_macros::', 'vstd::layout::', 'vstd::modes::', 'vstd::prelude::', 'vstd::ptr::', 'vstd::']",False,other,,True,,,"// rust_verify/tests/example.rs ignore --- intending to deprecate PPtr, should update this to raw_ptr
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::layout::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::ptr::*;
use vstd::*;

verus! {

struct Vector<V> {
    pub ptr: PPtr<V>,
    pub len: usize,
    pub capacity: usize,
    pub elems: Tracked<Map<nat, PointsTo<V>>>,
    pub rest: Tracked<PointsToRaw>,
    pub dealloc: Tracked<DeallocRaw>,
}

impl<V> Vector<V> {
    pub closed spec fn well_formed(&self) -> bool {
        &&& self.len <= self.capacity
        &&& (forall|i: nat| 0 <= i < self.len ==> self.elems@.dom().contains(i))
        &&& (forall|i: nat|
            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.pptr == self.ptr.id()
                + i as int * size_of::<V>())
        &&& (forall|i: nat|
            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.value.is_Some())
        &&& self.rest@.is_range(
            self.ptr.id() + self.len * size_of::<V>(),
            (self.capacity - self.len) * size_of::<V>(),
        )
        &&& self.dealloc@@.pptr == self.ptr.id()
        &&& self.dealloc@@.size == self.capacity * size_of::<V>()
        &&& self.dealloc@@.align == align_of::<V>()
        &&& is_sized::<V>()
    }

    pub closed spec fn view(&self) -> Seq<V> {
        Seq::new(self.len as nat, |i: int| self.elems@.index(i as nat)@.value.get_Some_0())
    }

    pub fn empty() -> (vec: Self)
        requires
            is_sized::<V>(),
        ensures
            vec.well_formed(),
    {
        layout_for_type_is_valid::<V>();
        let (p, Tracked(points_to), Tracked(dealloc)) = PPtr::<V>::alloc(
            0,
            std::mem::align_of::<V>(),
        );
        Vector {
            ptr: p,
            len: 0,
            capacity: 0,
            elems: Tracked(Map::tracked_empty()),
            rest: Tracked(points_to),
            dealloc: Tracked(dealloc),
        }
    }

    pub fn index(&self, i: usize) -> (elem: &V)
        requires
            self.well_formed(),
            0 <= i < self@.len(),
        ensures
            *elem === self@.index(i as int),
    {
        let ptr_usize = self.ptr.to_usize();
        assume((i as int * size_of::<V>()) as usize as int == (i as int * size_of::<V>()));
        assume((ptr_usize as int + i as int * size_of::<V>()) as usize as int == (ptr_usize as int
            + i as int * size_of::<V>()));
        let elem_ptr_usize = ptr_usize + i * std::mem::size_of::<V>();
        let elem_ptr = PPtr::<V>::from_usize(elem_ptr_usize);
        let tracked perm = self.elems.borrow().tracked_borrow(i as nat);
        elem_ptr.borrow(Tracked(perm))
    }

    pub fn resize(&mut self, new_capacity: usize)
        requires
            old(self).well_formed(),
            old(self).len <= new_capacity,
        ensures
            self.well_formed(),
            old(self)@ === self@,
            self.capacity === new_capacity,
    {
        // TODO implement
        assume(false);
    }

    pub fn push(&mut self, v: V)
        requires
            old(self).well_formed(),
        ensures
            self@ === old(self)@.push(v),
    {
        if self.len == self.capacity {
            assume((self.capacity as int * 2) as usize as int == (self.capacity as int * 2));
            let new_cap = if self.capacity == 0 {
                2
            } else {
                self.capacity * 2
            };
            self.resize(new_cap);
            assert((if self.capacity == 0 {
                2
            } else {
                self.capacity * 2
            }) > self.capacity) by (nonlinear_arith);
            assert(new_cap > old(self).capacity);
            assert(self@.len() == old(self)@.len());
            assert(self.len == old(self).len);
            assert(self.len < self.capacity);
        }
        assert(self.len < self.capacity);
        let tracked mut points_to;
        proof {
            let tracked mut rest = PointsToRaw::empty();
            tracked_swap(&mut rest, self.rest.borrow_mut());
            assert(size_of::<V>() as int <= (self.capacity - self.len) * size_of::<V>()) by {
                assert((self.capacity - self.len) >= 1 ==> size_of::<V>() as int <= (self.capacity
                    - self.len) * size_of::<V>()) by (nonlinear_arith);
            }
            assert(rest.is_range(
                self.ptr.id() + self.len * size_of::<V>(),
                (self.capacity - self.len) * size_of::<V>(),
            ));
            assert(rest@.dom() == crate::set_lib::set_int_range(
                self.ptr.id() + self.len * size_of::<V>(),
                self.ptr.id() + self.len * size_of::<V>() + (self.capacity - self.len) * size_of::<
                    V,
                >(),
            ));
            let item_range = crate::set_lib::set_int_range(
                self.ptr.id() + self.len * size_of::<V>(),
                self.ptr.id() + self.len * size_of::<V>() + size_of::<V>() as int,
            );
            assert(item_range.subset_of(rest@.dom()));
            let tracked (points_to_raw, mut rest) = rest.split(item_range);
            assume((self.ptr.id() + self.len * size_of::<V>()) % align_of::<V>() as int == 0);
            points_to = points_to_raw.into_typed::<V>(self.ptr.id() + self.len * size_of::<V>());
            tracked_swap(&mut rest, self.rest.borrow_mut());
        }
        let i = self.len;
        let ptr_usize = self.ptr.to_usize();
        assume((i as int * size_of::<V>()) as usize as int == (i as int * size_of::<V>()));
        assume((ptr_usize as int + i as int * size_of::<V>()) as usize as int == (ptr_usize as int
            + i as int * size_of::<V>()));
        let elem_ptr_usize = ptr_usize + i * std::mem::size_of::<V>();
        let elem_ptr = PPtr::<V>::from_usize(elem_ptr_usize);
        elem_ptr.put(Tracked(&mut points_to), v);
        proof {
            self.elems.borrow_mut().tracked_insert(self.len as nat, points_to);
        }
        self.len = self.len + 1;
        proof {
            assert_seqs_equal!(self@, old(self)@.push(v));
        }
    }
}

fn main() {
}

} // verus!
","// rust_verify/tests/example.rs ignore --- intending to deprecate PPtr, should update this to raw_ptr
#![allow(unused_imports)]

use verus_builtin::*;
use verus_builtin_macros::*;
use vstd::layout::*;
use vstd::modes::*;
use vstd::prelude::*;
use vstd::ptr::*;
use vstd::*;

verus! {

struct Vector<V> {
    pub ptr: PPtr<V>,
    pub len: usize,
    pub capacity: usize,
    pub elems: Tracked<Map<nat, PointsTo<V>>>,
    pub rest: Tracked<PointsToRaw>,
    pub dealloc: Tracked<DeallocRaw>,
}

impl<V> Vector<V> {
    pub closed spec fn well_formed(&self) -> bool {
        &&& self.len <= self.capacity
        &&& (forall|i: nat| 0 <= i < self.len ==> self.elems@.dom().contains(i))
        &&& (forall|i: nat|
            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.pptr == self.ptr.id()
                + i as int * size_of::<V>())
        &&& (forall|i: nat|
            0 <= i < self.len ==> (#[trigger] self.elems@.index(i))@.value.is_Some())
        &&& self.rest@.is_range(
            self.ptr.id() + self.len * size_of::<V>(),
            (self.capacity - self.len) * size_of::<V>(),
        )
        &&& self.dealloc@@.pptr == self.ptr.id()
        &&& self.dealloc@@.size == self.capacity * size_of::<V>()
        &&& self.dealloc@@.align == align_of::<V>()
        &&& is_sized::<V>()
    }

    pub closed spec fn view(&self) -> Seq<V> {
        Seq::new(self.len as nat, |i: int| self.elems@.index(i as nat)@.value.get_Some_0())
    }

    pub fn empty() -> (vec: Self)
        requires
            is_sized::<V>(),
        ensures
            vec.well_formed(),
    {
        layout_for_type_is_valid::<V>();
        let (p, Tracked(points_to), Tracked(dealloc)) = PPtr::<V>::alloc(
            0,
            std::mem::align_of::<V>(),
        );
        Vector {
            ptr: p,
            len: 0,
            capacity: 0,
            elems: Tracked(Map::tracked_empty()),
            rest: Tracked(points_to),
            dealloc: Tracked(dealloc),
        }
    }

    pub fn index(&self, i: usize) -> (elem: &V)
        requires
            self.well_formed(),
            0 <= i < self@.len(),
        ensures
            *elem === self@.index(i as int),
    {
        let ptr_usize = self.ptr.to_usize();
        assume((i as int * size_of::<V>()) as usize as int == (i as int * size_of::<V>()));
        assume((ptr_usize as int + i as int * size_of::<V>()) as usize as int == (ptr_usize as int
            + i as int * size_of::<V>()));
        let elem_ptr_usize = ptr_usize + i * std::mem::size_of::<V>();
        let elem_ptr = PPtr::<V>::from_usize(elem_ptr_usize);
        let tracked perm = self.elems.borrow().tracked_borrow(i as nat);
        elem_ptr.borrow(Tracked(perm))
    }

    pub fn resize(&mut self, new_capacity: usize)
        requires
            old(self).well_formed(),
            old(self).len <= new_capacity,
        ensures
            self.well_formed(),
            old(self)@ === self@,
            self.capacity === new_capacity,
    {
        // TODO implement
        assume(false);
    }

    pub fn push(&mut self, v: V)
        requires
            old(self).well_formed(),
        ensures
            self@ === old(self)@.push(v),
    {
        if self.len == self.capacity {
            assume((self.capacity as int * 2) as usize as int == (self.capacity as int * 2));
            let new_cap = if self.capacity == 0 {
                2
            } else {
                self.capacity * 2
            };
            self.resize(new_cap);
            assert((if self.capacity == 0 {
                2
            } else {
                self.capacity * 2
            }) > self.capacity) by (nonlinear_arith);
            assert(new_cap > old(self).capacity);
            assert(self@.len() == old(self)@.len());
            assert(self.len == old(self).len);
            assert(self.len < self.capacity);
        }
        assert(self.len < self.capacity);
        let tracked mut points_to;
        proof {
            let tracked mut rest = PointsToRaw::empty();
            tracked_swap(&mut rest, self.rest.borrow_mut());
            assert(size_of::<V>() as int <= (self.capacity - self.len) * size_of::<V>()) by {
                assert((self.capacity - self.len) >= 1 ==> size_of::<V>() as int <= (self.capacity
                    - self.len) * size_of::<V>()) by (nonlinear_arith);
            }
            assert(rest.is_range(
                self.ptr.id() + self.len * size_of::<V>(),
                (self.capacity - self.len) * size_of::<V>(),
            ));
            assert(rest@.dom() == crate::set_lib::set_int_range(
                self.ptr.id() + self.len * size_of::<V>(),
                self.ptr.id() + self.len * size_of::<V>() + (self.capacity - self.len) * size_of::<
                    V,
                >(),
            ));
            let item_range = crate::set_lib::set_int_range(
                self.ptr.id() + self.len * size_of::<V>(),
                self.ptr.id() + self.len * size_of::<V>() + size_of::<V>() as int,
            );
            assert(item_range.subset_of(rest@.dom()));
            let tracked (points_to_raw, mut rest) = rest.split(item_range);
            assume((self.ptr.id() + self.len * size_of::<V>()) % align_of::<V>() as int == 0);
            points_to = points_to_raw.into_typed::<V>(self.ptr.id() + self.len * size_of::<V>());
            tracked_swap(&mut rest, self.rest.borrow_mut());
        }
        let i = self.len;
        let ptr_usize = self.ptr.to_usize();
        assume((i as int * size_of::<V>()) as usize as int == (i as int * size_of::<V>()));
        assume((ptr_usize as int + i as int * size_of::<V>()) as usize as int == (ptr_usize as int
            + i as int * size_of::<V>()));
        let elem_ptr_usize = ptr_usize + i * std::mem::size_of::<V>();
        let elem_ptr = PPtr::<V>::from_usize(elem_ptr_usize);
        elem_ptr.put(Tracked(&mut points_to), v);
        proof {
            self.elems.borrow_mut().tracked_insert(self.len as nat, points_to);
        }
        self.len = self.len + 1;
        proof {
            assert_seqs_equal!(self@, old(self)@.push(v));
        }
    }
}

fn main() {
}

} // verus!
",[]
