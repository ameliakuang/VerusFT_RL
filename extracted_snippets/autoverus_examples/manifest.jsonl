{"id": "ex1_27e416c1", "original_code": "Failed assertion\n```\nLine 48-48:\n                    assert(j < n);\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i,\n                    n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                proof {\n                    assert(j < n);\n                }\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "minimized_code": "Failed assertion\n```\nLine 48-48:\n                    assert(j < n);\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i,\n                    n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                proof {\n                    assert(j < n);\n                }\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-assert/ex1.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 472, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpqop08g7s", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpqop08g7s", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpqop08g7s", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpqop08g7s", "lines": [76, 76], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `assertion` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `assertion` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpqop08g7s", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed assertion", "highlight_start": 8, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 76, "minimized_LOC": 76, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 10, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\n        ensures\n\n            invariant\n\n                invariant", "proof": "proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n\nproof {\n                    assert(j < n);\n                }\n\nproof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n\nproof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }"}}}, "all_snapshots": []}
{"id": "ex2_27e416c1", "original_code": "Failed assertion\n```\nLine 24-24:\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "minimized_code": "Failed assertion\n```\nLine 24-24:\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-assert/ex2.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 158, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpk6olrx8v", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpk6olrx8v", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpk6olrx8v", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpk6olrx8v", "lines": [70, 70], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `assertion` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `assertion` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpk6olrx8v", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed assertion", "highlight_start": 8, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 70, "minimized_LOC": 70, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\n        ensures\n\n            invariant\n\n                invariant", "proof": "proof {\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n\nproof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n\nproof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }"}}}, "all_snapshots": []}
{"id": "ex3_27e416c1", "original_code": "Failed assertion\n```\nLine 87-87:\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nproof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n    assert(sorted_between(a, i, i + 1));\n    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);\n}\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n    assert(sorted_between(a, i, k));\n    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);\n    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);\n}\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n}\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n}\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{\n    let n = nums.len();\n    if n == 0 {\n        proof {\n            let r = Seq::new(0, |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n        return;\n    }\n    let ghost mut r = Seq::new(nums@.len(), |i: int| i);\n    proof {\n        assert(is_reorder_of(r, nums@, nums@));\n    }\n    for i in 1..n\n    invariant\n        sorted_between(nums@, 0, i as int),\n        is_reorder_of(r, nums@, old(nums)@),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let mut j = i;\n        while j > 0\n        invariant\n            0 <= j <= i < n,\n            n == nums.len(),\n            sorted_between(nums@, 0, j as int),\n            sorted_between(nums@, j as int, i as int + 1),\n            is_reorder_of(r, nums@, old(nums)@),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            if nums[j - 1] > nums[j] {\n                let temp = nums[j - 1];\n                nums.set(j - 1, nums[j]);\n                nums.set(j, temp);\n                proof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n            }\n            proof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n            j -= 1;\n            proof {\n                assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n            }\n        }\n    }\n}\n}\n```\n", "minimized_code": "Failed assertion\n```\nLine 87-87:\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nproof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n    assert(sorted_between(a, i, i + 1));\n    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);\n}\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n    assert(sorted_between(a, i, k));\n    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);\n    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);\n}\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n}\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n}\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{\n    let n = nums.len();\n    if n == 0 {\n        proof {\n            let r = Seq::new(0, |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n        return;\n    }\n    let ghost mut r = Seq::new(nums@.len(), |i: int| i);\n    proof {\n        assert(is_reorder_of(r, nums@, nums@));\n    }\n    for i in 1..n\n    invariant\n        sorted_between(nums@, 0, i as int),\n        is_reorder_of(r, nums@, old(nums)@),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let mut j = i;\n        while j > 0\n        invariant\n            0 <= j <= i < n,\n            n == nums.len(),\n            sorted_between(nums@, 0, j as int),\n            sorted_between(nums@, j as int, i as int + 1),\n            is_reorder_of(r, nums@, old(nums)@),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            if nums[j - 1] > nums[j] {\n                let temp = nums[j - 1];\n                nums.set(j - 1, nums[j]);\n                nums.set(j, temp);\n                proof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n            }\n            proof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n            j -= 1;\n            proof {\n                assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n            }\n        }\n    }\n}\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-assert/ex3.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 165, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpnmvdwzt9", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpnmvdwzt9", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpnmvdwzt9", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpnmvdwzt9", "lines": [101, 101], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `assertion` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `assertion` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpnmvdwzt9", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed assertion", "highlight_start": 8, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 101, "minimized_LOC": 101, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 18, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    ensures\n\n    invariant\n\n        invariant", "proof": "proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n\nproof {\n            let r = Seq::new(0, |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n\nproof {\n        assert(is_reorder_of(r, nums@, nums@));\n    }\n\nproof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n\nproof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n\nproof {\n                assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n            }"}}}, "all_snapshots": []}
{"id": "ex1_27e416c1", "original_code": "no rules expected the token `;`\n```\nLine 50-50:\n    let q = seq![0; n];\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nproof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n    assert(sorted_between(a, i, i + 1));\n    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);\n}\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n    assert(sorted_between(a, i, k));\n    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);\n    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);\n}\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n}\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n}\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{\n    let n = nums.len();\n    if n == 0 {\n        return;\n    }\n    proof {\n        let q = seq![0; n];\n    }\n    for i in 1..n\n    invariant\n        1 <= i <= n,\n        sorted_between(nums@, 0, i as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@.take(i as int), old(nums)@),\n    {\n        let mut j = i;\n        while j > 0\n        invariant\n            0 < j <= i,\n            sorted_between(nums@, 0, j as int),\n            sorted_between(nums@, j as int, i as int + 1),\n            exists|r: Seq<int>| is_reorder_of(r, nums@.take(i as int), old(nums)@),\n        {\n            if nums[j - 1] > nums[j] {\n                let temp = nums[j - 1];\n                nums.set(j - 1, nums[j]);\n                nums.set(j, temp);\n                proof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n            }\n            proof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n            j -= 1;\n        }\n    }\n}\n}\n```\n", "minimized_code": "no rules expected the token `;`\n```\nLine 50-50:\n    let q = seq![0; n];\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nproof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n    assert(sorted_between(a, i, i + 1));\n    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);\n}\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n    assert(sorted_between(a, i, k));\n    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);\n    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);\n}\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n}\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n}\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{\n    let n = nums.len();\n    if n == 0 {\n        return;\n    }\n    proof {\n        let q = seq![0; n];\n    }\n    for i in 1..n\n    invariant\n        1 <= i <= n,\n        sorted_between(nums@, 0, i as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@.take(i as int), old(nums)@),\n    {\n        let mut j = i;\n        while j > 0\n        invariant\n            0 < j <= i,\n            sorted_between(nums@, 0, j as int),\n            sorted_between(nums@, j as int, i as int + 1),\n            exists|r: Seq<int>| is_reorder_of(r, nums@.take(i as int), old(nums)@),\n        {\n            if nums[j - 1] > nums[j] {\n                let temp = nums[j - 1];\n                nums.set(j - 1, nums[j]);\n                nums.set(j, temp);\n                proof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n            }\n            proof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n            j -= 1;\n        }\n    }\n}\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-default/ex1.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 154, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpl7iqx4ux", "lines": [1, 1], "label": null, "text": [{"text": "no rules expected the token `;`", "highlight_start": 29, "highlight_end": 30}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpl7iqx4ux", "lines": [1, 1], "label": null, "text": [{"text": "no rules expected the token `;`", "highlight_start": 31, "highlight_end": 32}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpl7iqx4ux", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpl7iqx4ux", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpl7iqx4ux", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpl7iqx4ux", "lines": [91, 91], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `rules` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `rules` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpl7iqx4ux", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "no rules expected the token `;`", "highlight_start": 4, "highlight_end": 9}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 91, "minimized_LOC": 91, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    ensures\n\n    invariant\n\n        invariant", "proof": "proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n\nproof {\n        let q = seq![0; n];\n    }\n\nproof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n\nproof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }"}}}, "all_snapshots": []}
{"id": "ex1_27e416c1", "original_code": "Failed invariant at end of the loop\n```\nLine 43-43:\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n            }\n        }\n    }\n}\n```\n", "minimized_code": "Failed invariant at end of the loop\n```\nLine 43-43:\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n            }\n        }\n    }\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-inv-end/ex1.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "invariant", "verify_time_ms": 153, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp0zyf07_0", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp0zyf07_0", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp0zyf07_0", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp0zyf07_0", "lines": [63, 63], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `invariant` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `invariant` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp0zyf07_0", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed invariant at end of the loop", "highlight_start": 8, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 63, "minimized_LOC": 63, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\nFailed invariant at end of the loop\n\n        ensures\n\n            invariant\n\n                invariant", "proof": "proof {\n            let r = Seq::new(nums@.len(), |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }"}}}, "all_snapshots": []}
{"id": "ex2_27e416c1", "original_code": "Failed invariant at end of the loop\n```\nLine 79-79:\n                j > 0,\n```\n\nCode\n```\nuse vstd::multiset::Multiset;\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\n    forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n\n    decreases input.len()\n\n{\n\n    if input.len() == 0 {\n\n        Multiset::empty()\n\n    } else {\n\n        multiset_from_seq(input.drop_last()).insert(input.last())\n\n    }\n\n}\n\nproof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        multiset_from_seq(s).contains(s[i]),\n        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),\n    decreases\n        s.len(),\n{\n    if i == s.len() - 1 {\n        assert(s.update(i, v) =~= s.drop_last().push(v));\n        assert(multiset_from_seq(s) == multiset_from_seq(s.drop_last()).insert(s.last()));\n        assert(s.drop_last().push(v).drop_last() =~= s.drop_last());\n    } else if s.len() != 0 {\n        update_seq_multiset(s.drop_last(), i, v);\n        assert(s.drop_last().update(i, v) =~= s.update(i, v).drop_last());\n    }\n}\n\n\n#[verifier::loop_isolation(false)]\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n{\n\n    let n = nums.len();\n\n    if n == 0 {\n        return;\n    }\n\n    for i in 1..n\n        invariant\n            n == nums.len(),\n            sorted_between(nums@, 0, i as int),\n            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n    {\n        let mut j = i;\n\n        while j != 0\n            invariant\n                j <= i,\n                i < n,\n                n == nums.len(),\n                forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                j > 0,\n                sorted_between(nums@, j as int, i + 1),\n                multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n        {\n\n            if nums[j - 1] > nums[j] {\n\n                let temp = nums[j - 1];\n\n                proof {\n                    update_seq_multiset(nums@, j-1, nums[j as int])\n                }\n                nums.set(j - 1, nums[j]);\n\n                assert(multiset_from_seq(old(nums)@) == multiset_from_seq(nums@).remove(nums[j as int]).insert(temp));\n\n                proof{\n                    update_seq_multiset(nums@, j as int, temp)\n                }\n                nums.set(j, temp);\n            }\n\n            j -= 1;\n\n        }\n\n    }\n\n}\n}\n```\n", "minimized_code": "Failed invariant at end of the loop\n```\nLine 79-79:\n                j > 0,\n```\n\nCode\n```\nuse vstd::multiset::Multiset;\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\n    forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n\n    decreases input.len()\n\n{\n\n    if input.len() == 0 {\n\n        Multiset::empty()\n\n    } else {\n\n        multiset_from_seq(input.drop_last()).insert(input.last())\n\n    }\n\n}\n\nproof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        multiset_from_seq(s).contains(s[i]),\n        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),\n    decreases\n        s.len(),\n{\n    if i == s.len() - 1 {\n        assert(s.update(i, v) =~= s.drop_last().push(v));\n        assert(multiset_from_seq(s) == multiset_from_seq(s.drop_last()).insert(s.last()));\n        assert(s.drop_last().push(v).drop_last() =~= s.drop_last());\n    } else if s.len() != 0 {\n        update_seq_multiset(s.drop_last(), i, v);\n        assert(s.drop_last().update(i, v) =~= s.update(i, v).drop_last());\n    }\n}\n\n\n#[verifier::loop_isolation(false)]\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n{\n\n    let n = nums.len();\n\n    if n == 0 {\n        return;\n    }\n\n    for i in 1..n\n        invariant\n            n == nums.len(),\n            sorted_between(nums@, 0, i as int),\n            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n    {\n        let mut j = i;\n\n        while j != 0\n            invariant\n                j <= i,\n                i < n,\n                n == nums.len(),\n                forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                j > 0,\n                sorted_between(nums@, j as int, i + 1),\n                multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n        {\n\n            if nums[j - 1] > nums[j] {\n\n                let temp = nums[j - 1];\n\n                proof {\n                    update_seq_multiset(nums@, j-1, nums[j as int])\n                }\n                nums.set(j - 1, nums[j]);\n\n                assert(multiset_from_seq(old(nums)@) == multiset_from_seq(nums@).remove(nums[j as int]).insert(temp));\n\n                proof{\n                    update_seq_multiset(nums@, j as int, temp)\n                }\n                nums.set(j, temp);\n            }\n\n            j -= 1;\n\n        }\n\n    }\n\n}\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-inv-end/ex2.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "invariant", "verify_time_ms": 148, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp728t3r81", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp728t3r81", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp728t3r81", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp728t3r81", "lines": [117, 117], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `invariant` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `invariant` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp728t3r81", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed invariant at end of the loop", "highlight_start": 8, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 117, "minimized_LOC": 117, "self_contained": true, "dependencies": ["vstd::multiset::Multiset", "vstd::prelude::"], "complexity_verus_tokens": 14, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n{", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n\n    decreases input.len()\n\n{\n\nFailed invariant at end of the loop\n\n    decreases input.len()\n\n    requires\n\n    ensures\n\n    decreases\n\n    ensures\n\n        invariant\n\n            invariant", "proof": "proof fn update_seq_multiset<T>(s: Seq<T>, i: int, v: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        multiset_from_seq(s).contains(s[i]),\n        multiset_from_seq(s.update(i, v)) =~= multiset_from_seq(s).remove(s[i]).insert(v),\n    decreases\n        s.len(),\n{\n\nproof {\n                    update_seq_multiset(nums@, j-1, nums[j as int])\n                }\n\nproof{\n                    update_seq_multiset(nums@, j as int, temp)\n                }"}}}, "all_snapshots": []}
{"id": "ex1_27e416c1", "original_code": "Failed invariant before the loop\n```\nLine 31-31:\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "minimized_code": "Failed invariant before the loop\n```\nLine 31-31:\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-inv-front/ex1.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "invariant", "verify_time_ms": 137, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5984d6wu", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5984d6wu", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5984d6wu", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5984d6wu", "lines": [67, 67], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `invariant` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `invariant` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp5984d6wu", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed invariant before the loop", "highlight_start": 8, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 67, "minimized_LOC": 67, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\nFailed invariant before the loop\n\n        ensures\n\n            invariant\n\n                invariant", "proof": "proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n\nproof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }"}}}, "all_snapshots": []}
{"id": "ex2_27e416c1", "original_code": "Failed invariant before the loop\n```\nLine 67-67:\nn == nums.len(),\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nproof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n    assert(sorted_between(a, i, i + 1));\n    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);\n}\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n    assert(sorted_between(a, i, k));\n    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);\n    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);\n}\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n}\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n}\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{\n    let n = nums.len();\n    if n == 0 {\n        proof {\n            let r = Seq::new(0, |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n        return;\n    }\n    proof {\n        let r = Seq::new(nums@.len(), |i: int| i);\n        assert(is_reorder_of(r, nums@, nums@));\n    }\n    for i in 1..n\n    invariant\n        sorted_between(nums@, 0, i as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let mut j = i;\n        while j > 0\n        invariant\n            0 <= j <= i < n,\n            n == nums.len(),\n            sorted_between(nums@, 0, j as int),\n            sorted_between(nums@, j as int, i as int + 1),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            if nums[j - 1] > nums[j] {\n                let temp = nums[j - 1];\n                nums.set(j - 1, nums[j]);\n                nums.set(j, temp);\n                proof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n            }\n            proof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n            j -= 1;\n        }\n    }\n}\n}\n```\n", "minimized_code": "Failed invariant before the loop\n```\nLine 67-67:\nn == nums.len(),\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n\nproof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n    assert(sorted_between(a, i, i + 1));\n    assert(forall |x: int, y:int| i <= x < y < (i + 1) ==> a[x] <= a[y]);\n}\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n    assert(sorted_between(a, i, k));\n    assert(forall |x: int, y:int| i <= x < y < j ==> a[x] <= a[y]);\n    assert(forall |x: int, y:int| j <= x < y < k ==> a[x] <= a[y]);\n}\n\nspec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n    forall |i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n}\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n}\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{\n    let n = nums.len();\n    if n == 0 {\n        proof {\n            let r = Seq::new(0, |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n        return;\n    }\n    proof {\n        let r = Seq::new(nums@.len(), |i: int| i);\n        assert(is_reorder_of(r, nums@, nums@));\n    }\n    for i in 1..n\n    invariant\n        sorted_between(nums@, 0, i as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let mut j = i;\n        while j > 0\n        invariant\n            0 <= j <= i < n,\n            n == nums.len(),\n            sorted_between(nums@, 0, j as int),\n            sorted_between(nums@, j as int, i as int + 1),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            if nums[j - 1] > nums[j] {\n                let temp = nums[j - 1];\n                nums.set(j - 1, nums[j]);\n                nums.set(j, temp);\n                proof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n            }\n            proof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }\n            j -= 1;\n        }\n    }\n}\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-inv-front/ex2.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "invariant", "verify_time_ms": 137, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpd3_85pyh", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpd3_85pyh", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpd3_85pyh", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpd3_85pyh", "lines": [96, 96], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `invariant` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `invariant` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpd3_85pyh", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed invariant before the loop", "highlight_start": 8, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 96, "minimized_LOC": 96, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 17, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n\nfn test1(nums: &mut Vec<u32>)\n    ensures\n        sorted_between(nums@, 0, nums@.len() as int),\n        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n{", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\nFailed invariant before the loop\n\n    requires\n\n    ensures\n\n    requires\n\n    ensures\n\n    ensures\n\n    invariant\n\n        invariant", "proof": "proof fn lemma_sorted_between_single_element(a: Seq<u32>, i: int)\n    requires\n        0 <= i < a.len() as int,\n    ensures\n        sorted_between(a, i, i + 1),\n{\n\nproof fn lemma_sorted_between_transitive(a: Seq<u32>, i: int, j: int, k: int)\n    requires\n        sorted_between(a, i, k),\n        i <= j,\n        j <= k,\n    ensures\n        sorted_between(a, i, j),\n        sorted_between(a, j, k),\n{\n\nproof {\n            let r = Seq::new(0, |i: int| i);\n            assert(is_reorder_of(r, nums@, nums@));\n        }\n\nproof {\n        let r = Seq::new(nums@.len(), |i: int| i);\n        assert(is_reorder_of(r, nums@, nums@));\n    }\n\nproof {\n                    lemma_sorted_between_single_element(nums@, j as int - 1);\n                }\n\nproof {\n                lemma_sorted_between_transitive(nums@, 0, j as int, i as int + 1);\n            }"}}}, "all_snapshots": []}
{"id": "ex1_27e416c1", "original_code": "Failed post-condition\n```\nLine 21-21:\n    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n```\nFailed location\n```\nLine 25-25:\n    return;\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "minimized_code": "Failed post-condition\n```\nLine 21-21:\n    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n```\nFailed location\n```\nLine 25-25:\n    return;\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-postcond/ex1.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 142, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpgtzh77a4", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpgtzh77a4", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpgtzh77a4", "lines": [7, 7], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpgtzh77a4", "lines": [10, 10], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpgtzh77a4", "lines": [13, 13], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpgtzh77a4", "lines": [72, 72], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `post` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `post` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpgtzh77a4", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed post-condition", "highlight_start": 8, "highlight_end": 12}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 72, "minimized_LOC": 72, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 8, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\n        ensures\n\n            invariant\n\n                invariant", "proof": "proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n\nproof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }"}}}, "all_snapshots": []}
{"id": "ex1_27e416c1", "original_code": "Failed pre-condition\n```\n        i < vec.view().len(),\n```\nFailed location\n```\nLine 47-47:\n            if nums[j - 1] > nums[j] {\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i,\n                    n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "minimized_code": "Failed pre-condition\n```\n        i < vec.view().len(),\n```\nFailed location\n```\nLine 47-47:\n            if nums[j - 1] > nums[j] {\n```\n\nCode\n```\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i,\n                    n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    proof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n                proof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }\n            }\n        }\n    }\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-precond/ex1.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 139, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfjuq52a6", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfjuq52a6", "lines": [4, 4], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfjuq52a6", "lines": [6, 6], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfjuq52a6", "lines": [9, 9], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfjuq52a6", "lines": [12, 12], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfjuq52a6", "lines": [77, 77], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unclosed delimiter", "message": "VerusErrorType.Other: unclosed delimiter", "spans": []}, {"error_type": "Other", "error_text": "this file contains an unclosed delimiter (unclosed delimiter)", "message": "VerusErrorType.Other: this file contains an unclosed delimiter (unclosed delimiter)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfjuq52a6", "lines": [8, 8], "label": "unclosed delimiter", "text": [{"text": "            if nums[j - 1] > nums[j] {", "highlight_start": 38, "highlight_end": 39}]}, {"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfjuq52a6", "lines": [77, 77], "label": null, "text": [{"text": "```", "highlight_start": 5, "highlight_end": 5}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 77, "minimized_LOC": 77, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\n        ensures\n\n            invariant\n\n                invariant", "proof": "proof {\n            let r = Seq::new(nums@.len(), |i: int| i); // Added by AI, for assertion fail\n            assert(is_reorder_of(r, nums@, nums@)); // Added by AI, for assertion fail\n            assert(exists|r: Seq<int>| is_reorder_of(r, nums@, nums@));\n        }\n\nproof {\n                        let r1 = choose|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@);\n                        let r2 = r1.update(j-1, r1[j as int]).update(j as int, r1[j-1]);\n                        assert(is_reorder_of(r2, nums@.update(j-1, nums@[j as int]).update(j as int, nums@[j-1]), old(nums)@));\n                    }\n\nproof{\n                    assert(exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@));\n                }"}}}, "all_snapshots": []}
{"id": "ex1_27e416c1", "original_code": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let ghost mut r = Seq::new(nums@.len(), |i: int| i);\n        assert(is_reorder_of(r, nums@, nums@));\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n            }\n        }\n    }\n}\n", "minimized_code": "use vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]\n    }\n\n\n    spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n    &&& r.len() == s.len()\n    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()\n    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]\n    &&& p =~= r.map_values(|i: int| s[i])\n    }\n\n    fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {\n        let ghost mut r = Seq::new(nums@.len(), |i: int| i);\n        assert(is_reorder_of(r, nums@, nums@));\n        let n = nums.len();\n        if n == 0 {\n            return;\n        }\n        for i in 1..n\n            invariant\n                n == nums.len(),\n                sorted_between(nums@, 0, i as int),\n                is_reorder_of(r, nums@, old(nums)@),\n        {\n            let mut j = i;\n            while j != 0\n                invariant\n                    0 <= j <= i < n == nums.len(),\n                    forall|x: int, y: int| 0 <= x <= y <= i ==> x != j && y != j ==> nums[x] <= nums[y],\n                    sorted_between(nums@, j as int, i + 1),\n                    is_reorder_of(r, nums@, old(nums)@),\n            {\n                if nums[j - 1] > nums[j] {\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n            }\n        }\n    }\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-proof/ex1.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 1144, "verus_errors": [{"error_type": "Other", "error_text": "loop must have a decreases clause ()", "message": "VerusErrorType.Other: loop must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpfu6oxsd5", "lines": [35, 35], "label": null, "text": [{"text": "            while j != 0", "highlight_start": 13, "highlight_end": 25}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 51, "minimized_LOC": 51, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 7, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {\n\n fn test1(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),\n    {", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> bool {\n\n        ensures\n\n            invariant\n\n                invariant"}}}, "all_snapshots": []}
{"id": "ex3_27e416c1", "original_code": "#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len()\n{\n    if seq.len() == 0 {\n        Set::empty()\n    } else {\n        seq_to_set_rec(seq.drop_last()).insert(seq.last())\n    }\n}\n\n/// helper function showing that the resulting set contains all elements of the sequence\nproof fn seq_to_set_rec_contains<A>(seq: Seq<A>)\n    ensures forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a)\n    decreases seq.len()\n{\n    if seq.len() > 0 {\n        assert(forall |a| #[trigger] seq.drop_last().contains(a) <==> seq_to_set_rec(seq.drop_last()).contains(a)) by {\n            seq_to_set_rec_contains(seq.drop_last());\n        }\n\n        assert(seq.ext_equal(seq.drop_last().push(seq.last())));\n        assert forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a) by {\n            if !seq.drop_last().contains(a) {\n                if a == seq.last() {\n                    assert(seq.contains(a));\n                    assert(seq_to_set_rec(seq).contains(a));\n                } else {\n                    assert(!seq_to_set_rec(seq).contains(a));\n                }\n            }\n        }\n    }\n}\n\n/// helper function showing that the recursive definition matches the set comprehension one\nproof fn seq_to_set_equal_rec<A>(seq: Seq<A>)\n    ensures seq.to_set() == seq_to_set_rec(seq)\n{\n    assert(forall |n| #[trigger] seq.contains(n) <==> seq_to_set_rec(seq).contains(n)) by {\n        seq_to_set_rec_contains(seq);\n    }\n    assert(forall |n| #[trigger] seq.contains(n) <==> seq.to_set().contains(n));\n    assert(seq.to_set().ext_equal(seq_to_set_rec(seq)));\n}\n\nproof fn lemma_seq_push_to_set_insert<T>(s: Seq<T>, val: T)\nensures\n    s.push(val).to_set() === s.to_set().insert(val),\n{\n    seq_to_set_equal_rec(s.push(val));\n    assert(s.ext_equal(s.push(val).drop_last()));\n    seq_to_set_equal_rec(s);\n    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val)));\n    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val).drop_last()).insert(val));\n}\n\nfn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)\nensures\n    res@.no_duplicates(),\n    nums@.to_set().ext_equal(res@.to_set())\n{\n    let mut res = Vec::new();\n    let mut i = 0;\n    while i < nums.len()\n    invariant\n        0 <= i <= nums@.len(),\n        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n        res@.no_duplicates(),\n    {\n        let mut found = false;\n        let mut j = 0;\n\n        while j < res.len()\n        invariant\n            0 <= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n            !found,\n            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n        ensures\n            0<= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),\n            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n            !found ==> j == res@.len(),\n        {\n            if nums[i] == res[j] {\n                found = true;\n                break;\n            }\n            j += 1;\n        }\n        if !found {\n            res.push(nums[i]);\n        }\n        i += 1;\n    }\n    proof {\n        assert(nums@.subrange(0, i  as int).ext_equal(nums@));\n    }\n    res\n}\n}\n", "minimized_code": "#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len()\n{\n    if seq.len() == 0 {\n        Set::empty()\n    } else {\n        seq_to_set_rec(seq.drop_last()).insert(seq.last())\n    }\n}\n\n/// helper function showing that the resulting set contains all elements of the sequence\nproof fn seq_to_set_rec_contains<A>(seq: Seq<A>)\n    ensures forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a)\n    decreases seq.len()\n{\n    if seq.len() > 0 {\n        assert(forall |a| #[trigger] seq.drop_last().contains(a) <==> seq_to_set_rec(seq.drop_last()).contains(a)) by {\n            seq_to_set_rec_contains(seq.drop_last());\n        }\n\n        assert(seq.ext_equal(seq.drop_last().push(seq.last())));\n        assert forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a) by {\n            if !seq.drop_last().contains(a) {\n                if a == seq.last() {\n                    assert(seq.contains(a));\n                    assert(seq_to_set_rec(seq).contains(a));\n                } else {\n                    assert(!seq_to_set_rec(seq).contains(a));\n                }\n            }\n        }\n    }\n}\n\n/// helper function showing that the recursive definition matches the set comprehension one\nproof fn seq_to_set_equal_rec<A>(seq: Seq<A>)\n    ensures seq.to_set() == seq_to_set_rec(seq)\n{\n    assert(forall |n| #[trigger] seq.contains(n) <==> seq_to_set_rec(seq).contains(n)) by {\n        seq_to_set_rec_contains(seq);\n    }\n    assert(forall |n| #[trigger] seq.contains(n) <==> seq.to_set().contains(n));\n    assert(seq.to_set().ext_equal(seq_to_set_rec(seq)));\n}\n\nproof fn lemma_seq_push_to_set_insert<T>(s: Seq<T>, val: T)\nensures\n    s.push(val).to_set() === s.to_set().insert(val),\n{\n    seq_to_set_equal_rec(s.push(val));\n    assert(s.ext_equal(s.push(val).drop_last()));\n    seq_to_set_equal_rec(s);\n    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val)));\n    assert(s.push(val).to_set() === seq_to_set_rec(s.push(val).drop_last()).insert(val));\n}\n\nfn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)\nensures\n    res@.no_duplicates(),\n    nums@.to_set().ext_equal(res@.to_set())\n{\n    let mut res = Vec::new();\n    let mut i = 0;\n    while i < nums.len()\n    invariant\n        0 <= i <= nums@.len(),\n        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n        res@.no_duplicates(),\n    {\n        let mut found = false;\n        let mut j = 0;\n\n        while j < res.len()\n        invariant\n            0 <= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n            !found,\n            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n        ensures\n            0<= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),\n            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n            !found ==> j == res@.len(),\n        {\n            if nums[i] == res[j] {\n                found = true;\n                break;\n            }\n            j += 1;\n        }\n        if !found {\n            res.push(nums[i]);\n        }\n        i += 1;\n    }\n    proof {\n        assert(nums@.subrange(0, i  as int).ext_equal(nums@));\n    }\n    res\n}\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-proof/ex3.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 667, "verus_errors": [{"error_type": "Other", "error_text": "no method named `ext_equal` found for struct `vstd::seq::Seq<A>` in the current scope (method not found in `vstd::seq::Seq<A>`)", "message": "VerusErrorType.Other: no method named `ext_equal` found for struct `vstd::seq::Seq<A>` in the current scope (method not found in `vstd::seq::Seq<A>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxa68h8be", "lines": [26, 26], "label": "method not found in `vstd::seq::Seq<A>`", "text": [{"text": "        assert(seq.ext_equal(seq.drop_last().push(seq.last())));", "highlight_start": 20, "highlight_end": 29}]}]}, {"error_type": "Other", "error_text": "no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<A>`)", "message": "VerusErrorType.Other: no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<A>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxa68h8be", "lines": [48, 48], "label": "method not found in `vstd::set::Set<A>`", "text": [{"text": "    assert(seq.to_set().ext_equal(seq_to_set_rec(seq)));", "highlight_start": 25, "highlight_end": 34}]}]}, {"error_type": "Other", "error_text": "no method named `ext_equal` found for struct `vstd::seq::Seq<A>` in the current scope (method not found in `vstd::seq::Seq<T>`)", "message": "VerusErrorType.Other: no method named `ext_equal` found for struct `vstd::seq::Seq<A>` in the current scope (method not found in `vstd::seq::Seq<T>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxa68h8be", "lines": [56, 56], "label": "method not found in `vstd::seq::Seq<T>`", "text": [{"text": "    assert(s.ext_equal(s.push(val).drop_last()));", "highlight_start": 14, "highlight_end": 23}]}]}, {"error_type": "Other", "error_text": "no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<i32>`)", "message": "VerusErrorType.Other: no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<i32>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxa68h8be", "lines": [65, 65], "label": "method not found in `vstd::set::Set<i32>`", "text": [{"text": "    nums@.to_set().ext_equal(res@.to_set())", "highlight_start": 20, "highlight_end": 29}]}]}, {"error_type": "Other", "error_text": "no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<i32>`)", "message": "VerusErrorType.Other: no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<i32>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxa68h8be", "lines": [72, 72], "label": "method not found in `vstd::set::Set<i32>`", "text": [{"text": "        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),", "highlight_start": 47, "highlight_end": 56}]}]}, {"error_type": "Other", "error_text": "no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<i32>`)", "message": "VerusErrorType.Other: no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<i32>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxa68h8be", "lines": [83, 83], "label": "method not found in `vstd::set::Set<i32>`", "text": [{"text": "            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),", "highlight_start": 51, "highlight_end": 60}]}]}, {"error_type": "Other", "error_text": "no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<i32>`)", "message": "VerusErrorType.Other: no method named `ext_equal` found for struct `vstd::set::Set<A>` in the current scope (method not found in `vstd::set::Set<i32>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxa68h8be", "lines": [90, 90], "label": "method not found in `vstd::set::Set<i32>`", "text": [{"text": "            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),", "highlight_start": 51, "highlight_end": 60}]}]}, {"error_type": "Other", "error_text": "no method named `ext_equal` found for struct `vstd::seq::Seq<A>` in the current scope (method not found in `vstd::seq::Seq<i32>`)", "message": "VerusErrorType.Other: no method named `ext_equal` found for struct `vstd::seq::Seq<A>` in the current scope (method not found in `vstd::seq::Seq<i32>`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpxa68h8be", "lines": [107, 107], "label": "method not found in `vstd::seq::Seq<i32>`", "text": [{"text": "        assert(nums@.subrange(0, i  as int).ext_equal(nums@));", "highlight_start": 45, "highlight_end": 54}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 111, "minimized_LOC": 111, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 15, "has_meaningful_spec": true, "readability_score": 0.9, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n\nfn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)\nensures\n    res@.no_duplicates(),\n    nums@.to_set().ext_equal(res@.to_set())\n{", "spec": "spec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len()\n{\n\n    decreases seq.len()\n\n    ensures forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a)\n\n    decreases seq.len()\n\n    ensures seq.to_set() == seq_to_set_rec(seq)\n\nensures\n\nensures\n\n    invariant\n\n        invariant\n\n        ensures", "proof": "proof fn seq_to_set_rec_contains<A>(seq: Seq<A>)\n    ensures forall |a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a)\n    decreases seq.len()\n{\n\nproof fn seq_to_set_equal_rec<A>(seq: Seq<A>)\n    ensures seq.to_set() == seq_to_set_rec(seq)\n{\n\nproof fn lemma_seq_push_to_set_insert<T>(s: Seq<T>, val: T)\nensures\n    s.push(val).to_set() === s.to_set().insert(val),\n{\n\nproof {\n        assert(nums@.subrange(0, i  as int).ext_equal(nums@));\n    }"}}}, "all_snapshots": []}
{"id": "ex2_27e416c1", "original_code": "Failed assertion\n```\nLine 58-58:\n            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));\n```\n\nCode:\n```\n#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len()\n{\n    if seq.len() == 0 {\n        Set::empty()\n    } else {\n        seq_to_set_rec(seq.drop_last()).insert(seq.last())\n    }\n}\n\nfn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)\nensures\n    res@.no_duplicates(),\n    nums@.to_set().ext_equal(res@.to_set())\n{\n    let mut res = Vec::new();\n    let mut i = 0;\n    while i < nums.len()\n    invariant\n        0 <= i <= nums@.len(),\n        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n        res@.no_duplicates(),\n    {\n        let mut found = false;\n        let mut j = 0;\n\n        while j < res.len()\n        invariant\n            0 <= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n            !found,\n            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n        ensures\n            0<= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),\n            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n            !found ==> j == res@.len(),\n        {\n            if nums[i] == res[j] {\n                found = true;\n                break;\n            }\n            j += 1;\n        }\n        proof {\n            let val = nums@[i as int];\n            assert(nums@.subrange(0, i as int + 1).ext_equal(nums@.subrange(0, i as int).push(val)));\n            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));\n            if found {\n                assert(res@.contains(val));\n                assert(res@.to_set().contains(val));\n                assert(res@.to_set().ext_equal(res@.to_set().insert(val)));\n                assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set()));\n            }\n\n        }\n        if !found {\n            res.push(nums[i]);\n        }\n        i += 1;\n    }\n    proof {\n        assert(nums@.subrange(0, i  as int).ext_equal(nums@));\n    }\n    res\n}\n}\n```\n", "minimized_code": "Failed assertion\n```\nLine 58-58:\n            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));\n```\n\nCode:\n```\n#[allow(unused_imports)]\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\nspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len()\n{\n    if seq.len() == 0 {\n        Set::empty()\n    } else {\n        seq_to_set_rec(seq.drop_last()).insert(seq.last())\n    }\n}\n\nfn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)\nensures\n    res@.no_duplicates(),\n    nums@.to_set().ext_equal(res@.to_set())\n{\n    let mut res = Vec::new();\n    let mut i = 0;\n    while i < nums.len()\n    invariant\n        0 <= i <= nums@.len(),\n        nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n        res@.no_duplicates(),\n    {\n        let mut found = false;\n        let mut j = 0;\n\n        while j < res.len()\n        invariant\n            0 <= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n            !found,\n            forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n        ensures\n            0<= i < nums@.len(),\n            0 <= j <= res@.len(),\n            res@.no_duplicates(),\n            nums@.subrange(0, i  as int).to_set().ext_equal(res@.to_set()),\n            found ==> (j < res@.len() && res@[j as int] == nums@[i as int]),\n            !found ==> forall |k| 0 <= k < j ==> res@[k] != nums@[i as int],\n            !found ==> j == res@.len(),\n        {\n            if nums[i] == res[j] {\n                found = true;\n                break;\n            }\n            j += 1;\n        }\n        proof {\n            let val = nums@[i as int];\n            assert(nums@.subrange(0, i as int + 1).ext_equal(nums@.subrange(0, i as int).push(val)));\n            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));\n            if found {\n                assert(res@.contains(val));\n                assert(res@.to_set().contains(val));\n                assert(res@.to_set().ext_equal(res@.to_set().insert(val)));\n                assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set()));\n            }\n\n        }\n        if !found {\n            res.push(nums[i]);\n        }\n        i += 1;\n    }\n    proof {\n        assert(nums@.subrange(0, i  as int).ext_equal(nums@));\n    }\n    res\n}\n}\n```\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-proof-func-middle/ex2.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 141, "verus_errors": [{"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpr41layfr", "lines": [2, 2], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpr41layfr", "lines": [5, 5], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpr41layfr", "lines": [8, 8], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "unknown start of token: ` ()", "message": "VerusErrorType.Other: unknown start of token: ` ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpr41layfr", "lines": [86, 86], "label": null, "text": [{"text": "```", "highlight_start": 1, "highlight_end": 4}]}]}, {"error_type": "Other", "error_text": "expected one of `!` or `::`, found `assertion` (expected one of `!` or `::`)", "message": "VerusErrorType.Other: expected one of `!` or `::`, found `assertion` (expected one of `!` or `::`)", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmpr41layfr", "lines": [1, 1], "label": "expected one of `!` or `::`", "text": [{"text": "Failed assertion", "highlight_start": 8, "highlight_end": 17}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 86, "minimized_LOC": 86, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 9, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n\nfn remove_duplicates(nums: Vec<i32>) -> (res: Vec<i32>)\nensures\n    res@.no_duplicates(),\n    nums@.to_set().ext_equal(res@.to_set())\n{", "spec": "spec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len()\n{\n\n    decreases seq.len()\n\nensures\n\n    invariant\n\n        invariant\n\n        ensures", "proof": "proof {\n            let val = nums@[i as int];\n            assert(nums@.subrange(0, i as int + 1).ext_equal(nums@.subrange(0, i as int).push(val)));\n            assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set().insert(val)));\n            if found {\n                assert(res@.contains(val));\n                assert(res@.to_set().contains(val));\n                assert(res@.to_set().ext_equal(res@.to_set().insert(val)));\n                assert(nums@.subrange(0, i as int + 1).to_set().ext_equal(res@.to_set()));\n            }\n\n        }\n\nproof {\n        assert(nums@.subrange(0, i  as int).ext_equal(nums@));\n    }"}}}, "all_snapshots": []}
{"id": "ex4_27e416c1", "original_code": "use vstd::multiset::Multiset;\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\n        forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n\n    }\n\n    spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n\n        decreases input.len()\n\n    {\n\n        if input.len() == 0 {\n\n            Multiset::empty()\n\n        } else {\n\n            multiset_from_seq(input.drop_last()).insert(input.last())\n\n        }\n\n    }\n\n\n    #[verifier::loop_isolation(false)]\n\n    fn bubble_sort(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n    {\n\n        let n = nums.len();\n\n        if n == 0 {\n            return;\n        }\n\n        for i in 1..n\n        {\n            let mut j = i;\n\n            while j != 0\n            {\n                if nums[j - 1] > nums[j] {\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n            }\n        }\n\n    }\n}\n", "minimized_code": "use vstd::multiset::Multiset;\nuse vstd::prelude::*;\nfn main() {}\n\nverus! {\n    spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\n        forall|i: int, j:int| from <= i < j < to ==> a[i] <= a[j]\n\n    }\n\n    spec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n\n        decreases input.len()\n\n    {\n\n        if input.len() == 0 {\n\n            Multiset::empty()\n\n        } else {\n\n            multiset_from_seq(input.drop_last()).insert(input.last())\n\n        }\n\n    }\n\n\n    #[verifier::loop_isolation(false)]\n\n    fn bubble_sort(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n    {\n\n        let n = nums.len();\n\n        if n == 0 {\n            return;\n        }\n\n        for i in 1..n\n        {\n            let mut j = i;\n\n            while j != 0\n            {\n                if nums[j - 1] > nums[j] {\n                    let temp = nums[j - 1];\n                    nums.set(j - 1, nums[j]);\n                    nums.set(j, temp);\n                }\n                j -= 1;\n            }\n        }\n\n    }\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/input-temp/ex4.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 505, "verus_errors": [{"error_type": "Other", "error_text": "loop must have a decreases clause ()", "message": "VerusErrorType.Other: loop must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmppdhnmic5", "lines": [49, 49], "label": null, "text": [{"text": "            while j != 0", "highlight_start": 13, "highlight_end": 25}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 61, "minimized_LOC": 61, "self_contained": true, "dependencies": ["vstd::multiset::Multiset", "vstd::prelude::"], "complexity_verus_tokens": 5, "has_meaningful_spec": false, "readability_score": 0.7999999999999999, "reduction_ratio": 1.0}, "labeling": {"segments": {"exec": "\nfn main() {\n\n fn bubble_sort(nums: &mut Vec<u32>)\n        ensures\n            sorted_between(nums@, 0, nums@.len() as int),\n            multiset_from_seq(old(nums)@) === multiset_from_seq(nums@)\n    {", "spec": "spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> bool {\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n\n        decreases input.len()\n\n    {\n\n        decreases input.len()\n\n        ensures"}}}, "all_snapshots": []}
{"id": "ex6_27e416c1", "original_code": "\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\n\n    proof fn lemma_seq_subrange_ascend<T>(v: Seq<T>, i: int, j: int)\n        requires\n            0<= i < j <= v.len(),\n        ensures\n            v.subrange(i as int, j as int).drop_last() == v.subrange(i as int, j-1 ),\n    {\n        assert(v.subrange(i as int, j as int).drop_last() =~= v.subrange(i as int, j-1));\n    }\n\n    proof fn lemma_seq_subrange_all<T>(v: Seq<T>)\n        ensures\n            v == v.subrange(0, v.len() as int),\n    {\n        assert(v =~= v.subrange(0, v.len() as int));\n    }\n\n    #[verifier::loop_isolation(false)]\n\n    pub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)\n        requires\n            old(y).len() == 0,\n        ensures\n            y@ == x@.filter(|k: u64| true),\n    {\n        proof {\n            reveal(Seq::filter);\n        }\n\n        let mut i: usize = 0;\n\n        assert(y@ == x@.subrange(0, (i) as int).filter(|k: u64| true));\n\n        while (i < x.len())\n            invariant\n                i <= x.len(),\n                y@ == x@.subrange(0, (i) as int).filter(|k: u64| true),\n        {\n\n            y.push(x[i]);\n            i = i + 1;\n\n            proof {\n                lemma_seq_subrange_ascend(x@, 0, i as int);\n            }\n        }\n\n        proof {\n            lemma_seq_subrange_all(x@);\n        }\n    }\n}\n", "minimized_code": "\nuse vstd::prelude::*;\nfn main() {}\n\nverus!{\n\n    proof fn lemma_seq_subrange_ascend<T>(v: Seq<T>, i: int, j: int)\n        requires\n            0<= i < j <= v.len(),\n        ensures\n            v.subrange(i as int, j as int).drop_last() == v.subrange(i as int, j-1 ),\n    {\n        assert(v.subrange(i as int, j as int).drop_last() =~= v.subrange(i as int, j-1));\n    }\n\n    proof fn lemma_seq_subrange_all<T>(v: Seq<T>)\n        ensures\n            v == v.subrange(0, v.len() as int),\n    {\n        assert(v =~= v.subrange(0, v.len() as int));\n    }\n\n    #[verifier::loop_isolation(false)]\n\n    pub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)\n        requires\n            old(y).len() == 0,\n        ensures\n            y@ == x@.filter(|k: u64| true),\n    {\n        proof {\n            reveal(Seq::filter);\n        }\n\n        let mut i: usize = 0;\n\n        assert(y@ == x@.subrange(0, (i) as int).filter(|k: u64| true));\n\n        while (i < x.len())\n            invariant\n                i <= x.len(),\n                y@ == x@.subrange(0, (i) as int).filter(|k: u64| true),\n        {\n\n            y.push(x[i]);\n            i = i + 1;\n\n            proof {\n                lemma_seq_subrange_ascend(x@, 0, i as int);\n            }\n        }\n\n        proof {\n            lemma_seq_subrange_all(x@);\n        }\n    }\n}\n", "metadata": {"provenance": {"source_repo": "https://github.com/microsoft/verus-proof-synthesis.git", "file_path": "/Users/ameliakuang/Repos/verus-proof-synthesis/autoverus/examples/output/ex6.rs", "commit_sha": "27e416c1c2de62b9733f9cc6ca4119a6be0c2640"}, "verification": {"status": "failed", "error_type": "other", "verify_time_ms": 484, "verus_errors": [{"error_type": "Other", "error_text": "loop must have a decreases clause ()", "message": "VerusErrorType.Other: loop must have a decreases clause ()", "spans": [{"file_name": "/var/folders/90/7_f2j4ds4lxgxgg3n_kqsgm40000gn/T/tmp3w55b1zn", "lines": [39, 39], "label": null, "text": [{"text": "        while (i < x.len())", "highlight_start": 9, "highlight_end": 28}]}]}], "minimum_verifiable": false, "minimized_status": null}, "quality": {"original_LOC": 57, "minimized_LOC": 57, "self_contained": true, "dependencies": ["vstd::prelude::"], "complexity_verus_tokens": 13, "has_meaningful_spec": true, "readability_score": 0.9999999999999999, "reduction_ratio": 1.0}, "labeling": {"has_proof_block": true, "segments": {"exec": "\nfn main() {\n\n pub fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)\n        requires\n            old(y).len() == 0,\n        ensures\n            y@ == x@.filter(|k: u64| true),\n    {", "spec": "        requires\n\n        ensures\n\n        ensures\n\n        requires\n\n        ensures\n\n            invariant", "proof": "proof fn lemma_seq_subrange_ascend<T>(v: Seq<T>, i: int, j: int)\n        requires\n            0<= i < j <= v.len(),\n        ensures\n            v.subrange(i as int, j as int).drop_last() == v.subrange(i as int, j-1 ),\n    {\n\nproof fn lemma_seq_subrange_all<T>(v: Seq<T>)\n        ensures\n            v == v.subrange(0, v.len() as int),\n    {\n\nproof {\n            reveal(Seq::filter);\n        }\n\nproof {\n                lemma_seq_subrange_ascend(x@, 0, i as int);\n            }\n\nproof {\n            lemma_seq_subrange_all(x@);\n        }"}}}, "all_snapshots": []}
